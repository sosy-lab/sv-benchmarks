/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 55 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/alternative.h"
struct module;
#line 310 "include/linux/printk.h"
struct file_operations;
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 23 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 24
struct pt_regs;
#line 386 "include/linux/kernel.h"
struct pid;
#line 14 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2024_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2024_8 ldv_2024 ;
};
#line 27 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_2031_10 {
   u32 read ;
   s32 write ;
};
#line 33 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct_ldv_2031_10 ldv_2031 ;
};
#line 33 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
#line 34
struct task_struct;
#line 35
struct lockdep_map;
#line 18 "include/linux/lockdep.h"
struct mm_struct;
#line 58 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2096_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2111_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2112_11 {
   struct __anonstruct_ldv_2096_12 ldv_2096 ;
   struct __anonstruct_ldv_2111_13 ldv_2111 ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2112_11 ldv_2112 ;
};
#line 13 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 212 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 214 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 214 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 302
struct page;
#line 302 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 310
struct file;
#line 325
struct seq_file;
#line 355
struct thread_struct;
#line 357
struct cpumask;
#line 127 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2767_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2767_18 ldv_2767 ;
};
#line 97 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 648 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 298 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5125_23 {
   u64 rip ;
   u64 rdp ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5131_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5132_22 {
   struct __anonstruct_ldv_5125_23 ldv_5125 ;
   struct __anonstruct_ldv_5131_24 ldv_5131 ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5141_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5132_22 ldv_5132 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5141_25 ldv_5141 ;
};
#line 350 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 371 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 376 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 382 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 388 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 396 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 443
struct kmem_cache;
#line 444
struct perf_event;
#line 445 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 574 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_5960_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_5961_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_5960_29 ldv_5960 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_5961_28 ldv_5961 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 63 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 144 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
struct timespec;
#line 110 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 32 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 37 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 813 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct nameidata;
#line 115
struct path;
#line 116
struct vfsmount;
#line 117 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_7487_37 {
   u32 hash ;
   u32 len ;
};
#line 117 "include/linux/rculist_bl.h"
union __anonunion_ldv_7489_36 {
   struct __anonstruct_ldv_7487_37 ldv_7487 ;
   u64 hash_len ;
};
#line 117 "include/linux/rculist_bl.h"
struct qstr {
   union __anonunion_ldv_7489_36 ldv_7489 ;
   unsigned char const   *name ;
};
#line 87 "include/linux/dcache.h"
struct inode;
#line 87
struct dentry_operations;
#line 87
struct super_block;
#line 87 "include/linux/dcache.h"
union __anonunion_d_u_38 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 87 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_38 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 138 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 411 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 23 "include/linux/path.h"
struct nameidata {
   struct path path ;
   struct qstr last ;
   struct path root ;
   struct inode *inode ;
   unsigned int flags ;
   unsigned int seq ;
   int last_type ;
   unsigned int depth ;
   char *saved_names[9U] ;
};
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_39 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_39 nodemask_t;
#line 513
struct mnt_namespace;
#line 514 "include/linux/nodemask.h"
struct vfsmount {
   struct dentry *mnt_root ;
   struct super_block *mnt_sb ;
   int mnt_flags ;
};
#line 68 "include/linux/mount.h"
struct file_system_type;
#line 133 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 46 "include/linux/uidgid.h"
typedef uid_t kuid_t;
#line 47 "include/linux/uidgid.h"
typedef gid_t kgid_t;
#line 197 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 380 "include/linux/radix-tree.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 83
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 90
struct pid_namespace;
#line 90 "include/linux/rbtree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/fiemap.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 42
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 48
struct rw_semaphore;
#line 49 "include/linux/shrinker.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 314 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 353
struct tvec_base;
#line 354 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 267
struct work_struct;
#line 50 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 96 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   int cpu ;
};
#line 22 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_105 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_105 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct vm_area_struct;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 56 "include/uapi/linux/fs.h"
struct export_operations;
#line 58
struct iovec;
#line 59
struct kiocb;
#line 60
struct kobject;
#line 61
struct pipe_inode_info;
#line 62
struct poll_table_struct;
#line 63
struct kstatfs;
#line 64
struct cred;
#line 65
struct swap_info_struct;
#line 65 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 241 "include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 36 "include/linux/projid.h"
typedef projid_t kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_12904_132 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_12904_132 ldv_12904 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 332 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 378 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 409
struct address_space;
#line 410
struct writeback_control;
#line 340 "include/linux/fs.h"
union __anonunion_arg_134 {
   char *buf ;
   void *data ;
};
#line 340 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_133 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_134 arg ;
   int error ;
};
#line 340 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_133 read_descriptor_t;
#line 343 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 402
struct backing_dev_info;
#line 403 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 424
struct request_queue;
#line 425
struct hd_struct;
#line 425
struct gendisk;
#line 425 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 497
struct posix_acl;
#line 498
struct inode_operations;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_13340_135 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 498 "include/linux/fs.h"
union __anonunion_ldv_13360_136 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 498
struct file_lock;
#line 498
struct cdev;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_13376_137 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 498 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_13340_135 ldv_13340 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_13360_136 ldv_13360 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_13376_137 ldv_13376 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 726 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 734 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 757 "include/linux/fs.h"
union __anonunion_f_u_138 {
   struct list_head fu_list ;
   struct callback_head fu_rcuhead ;
};
#line 757 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_138 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 900
struct files_struct;
#line 900 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 901 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 906 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 918
struct net;
#line 923
struct nlm_lockowner;
#line 924 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_140 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_139 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_140 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_139 fl_u ;
};
#line 1010 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1216 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1232
struct super_operations;
#line 1232
struct xattr_handler;
#line 1232
struct mtd_info;
#line 1232 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1469 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1508 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1545 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
};
#line 1588 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1801 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 398 "include/linux/gfp.h"
struct mem_cgroup;
#line 137 "include/linux/slab.h"
struct __anonstruct_ldv_16331_142 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 137 "include/linux/slab.h"
union __anonunion_ldv_16332_141 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_16331_142 ldv_16331 ;
};
#line 137 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_16332_141 ldv_16332 ;
};
#line 235
struct sock;
#line 236
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 242 "include/linux/slab.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 110 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 129
struct sysfs_dirent;
#line 194 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 54 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 65 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 75 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 30 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 33 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 35
struct user_struct;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 39
struct keyring_list;
#line 116 "include/linux/key.h"
union __anonunion_ldv_17789_145 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 116
struct key_user;
#line 116 "include/linux/key.h"
union __anonunion_ldv_17798_146 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 116 "include/linux/key.h"
union __anonunion_type_data_147 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 116 "include/linux/key.h"
union __anonunion_payload_148 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 116 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_17789_145 ldv_17789 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_17798_146 ldv_17798 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_147 type_data ;
   union __anonunion_payload_148 payload ;
};
#line 42 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 48 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 55
struct uprobe;
#line 55 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 69 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 88 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_18077_150 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_18087_154 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_18089_153 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_18087_154 ldv_18087 ;
   int units ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_18091_152 {
   union __anonunion_ldv_18089_153 ldv_18089 ;
   atomic_t _count ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_18092_151 {
   unsigned long counters ;
   struct __anonstruct_ldv_18091_152 ldv_18091 ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_18093_149 {
   union __anonunion_ldv_18077_150 ldv_18077 ;
   union __anonunion_ldv_18092_151 ldv_18092 ;
};
#line 112 "include/linux/uprobes.h"
struct __anonstruct_ldv_18100_156 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 112
struct slab;
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_18104_155 {
   struct list_head lru ;
   struct __anonstruct_ldv_18100_156 ldv_18100 ;
   struct list_head list ;
   struct slab *slab_page ;
};
#line 112 "include/linux/uprobes.h"
union __anonunion_ldv_18109_157 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 112 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_18093_149 ldv_18093 ;
   union __anonunion_ldv_18104_155 ldv_18104 ;
   union __anonunion_ldv_18109_157 ldv_18109 ;
   unsigned long debug_flags ;
   int _last_nid ;
};
#line 179 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 219 "include/linux/mm_types.h"
struct __anonstruct_linear_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 219 "include/linux/mm_types.h"
union __anonunion_shared_158 {
   struct __anonstruct_linear_159 linear ;
   struct list_head nonlinear ;
};
#line 219
struct anon_vma;
#line 219
struct vm_operations_struct;
#line 219
struct mempolicy;
#line 219 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_158 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 291 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 297 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 310 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 323
struct linux_binfmt;
#line 323
struct mmu_notifier_mm;
#line 323 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
#line 157 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 181 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 23 "include/linux/sem.h"
struct sem_undo_list;
#line 23 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_160 {
   unsigned long sig[1U] ;
};
#line 24 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_160 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 22 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 124 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 34 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_162 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_163 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_164 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_166 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_167 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_168 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_161 {
   int _pad[28U] ;
   struct __anonstruct__kill_162 _kill ;
   struct __anonstruct__timer_163 _timer ;
   struct __anonstruct__rt_164 _rt ;
   struct __anonstruct__sigchld_165 _sigchld ;
   struct __anonstruct__sigfault_166 _sigfault ;
   struct __anonstruct__sigpoll_167 _sigpoll ;
   struct __anonstruct__sigsys_168 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_161 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 80 "include/linux/seccomp.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/seccomp.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 460 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 40 "include/linux/latencytop.h"
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct thread_group_cred;
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 345
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 185
struct futex_pi_state;
#line 186
struct robust_list_head;
#line 187
struct bio_list;
#line 188
struct fs_struct;
#line 189
struct perf_event_context;
#line 190
struct blk_plug;
#line 121 "include/linux/sched.h"
struct cfs_rq;
#line 122
struct task_group;
#line 44 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 106 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/aio_abi.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 38 "include/linux/uio.h"
struct kioctx;
#line 39 "include/linux/uio.h"
union __anonunion_ki_obj_171 {
   void *user ;
   struct task_struct *tsk ;
};
#line 39
struct eventfd_ctx;
#line 39 "include/linux/uio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_171 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 161 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
#line 181 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct callback_head callback_head ;
};
#line 378 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 430 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 438 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 445 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 457 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 477 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 513
struct autogroup;
#line 514
struct tty_struct;
#line 514
struct taskstats;
#line 514
struct tty_audit_buf;
#line 514 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 690 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 734
struct reclaim_state;
#line 735 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 750 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1050
struct uts_namespace;
#line 1051
struct rq;
#line 1052 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*migrate_task_rq)(struct task_struct * , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1119 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1124 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1136 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1171 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1206
struct rt_rq;
#line 1206 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1229 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1600
struct css_set;
#line 1600
struct compat_robust_list_head;
#line 1600 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   atomic_t ptrace_bp_refcnt ;
   struct uprobe_task *utask ;
};
#line 2849
struct ipc_namespace;
#line 2850 "include/linux/sched.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns ;
   struct net *net_ns ;
};
#line 71 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 11 "include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 54 "include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned char for_kupdate : 1 ;
   unsigned char for_background : 1 ;
   unsigned char tagged_writepages : 1 ;
   unsigned char for_reclaim : 1 ;
   unsigned char range_cyclic : 1 ;
};
#line 81
struct bdi_writeback;
#line 39 "include/linux/backing-dev.h"
typedef int congested_fn(void * , int  );
#line 48 "include/linux/backing-dev.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned int nr ;
   unsigned long last_old_flush ;
   unsigned long last_active ;
   struct task_struct *task ;
   struct timer_list wakeup_timer ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   spinlock_t list_lock ;
};
#line 65 "include/linux/backing-dev.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct percpu_counter bdi_stat[4U] ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   struct bdi_writeback wb ;
   spinlock_t wb_lock ;
   struct list_head work_list ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 67 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_crypt_stat;
#line 68
struct ecryptfs_mount_crypt_stat;
#line 192
struct crypto_blkcipher;
#line 192
struct crypto_hash;
#line 192 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_crypt_stat {
   u32 flags ;
   unsigned int file_version ;
   size_t iv_bytes ;
   size_t metadata_size ;
   size_t extent_size ;
   size_t key_size ;
   size_t extent_shift ;
   unsigned int extent_mask ;
   struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
   struct crypto_blkcipher *tfm ;
   struct crypto_hash *hash_tfm ;
   unsigned char cipher[32U] ;
   unsigned char key[64U] ;
   unsigned char root_iv[16U] ;
   struct list_head keysig_list ;
   struct mutex keysig_list_mutex ;
   struct mutex cs_tfm_mutex ;
   struct mutex cs_hash_tfm_mutex ;
   struct mutex cs_mutex ;
};
#line 235 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_inode_info {
   struct inode vfs_inode ;
   struct inode *wii_inode ;
   struct mutex lower_file_mutex ;
   atomic_t lower_file_count ;
   struct file *lower_file ;
   struct ecryptfs_crypt_stat crypt_stat ;
};
#line 245 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_dentry_info {
   struct path lower_path ;
   struct ecryptfs_crypt_stat *crypt_stat ;
};
#line 304 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_mount_crypt_stat {
   u32 flags ;
   struct list_head global_auth_tok_list ;
   struct mutex global_auth_tok_list_mutex ;
   size_t global_default_cipher_key_size ;
   size_t global_default_fn_cipher_key_bytes ;
   unsigned char global_default_cipher_name[33U] ;
   unsigned char global_default_fn_cipher_name[33U] ;
   char global_default_fnek_sig[17U] ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 39 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 275 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 279 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 332 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_sb_info {
   struct super_block *wsi_sb ;
   struct ecryptfs_mount_crypt_stat mount_crypt_stat ;
   struct backing_dev_info bdi ;
};
#line 339 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_file_info {
   struct file *wfi_file ;
   struct ecryptfs_crypt_stat *crypt_stat ;
};
#line 204 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
struct ecryptfs_getdents_callback {
   void *dirent ;
   struct dentry *dentry ;
   int (*filldir)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   int filldir_called ;
   int entries_written ;
};
#line 146 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 233 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/special_insns.h"
struct exec_domain;
#line 26 "include/linux/personality.h"
struct map_segment;
#line 26 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 586 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_27 {
   unsigned long seg ;
};
#line 586 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_27 mm_segment_t;
#line 74 "include/linux/file.h"
struct compat_timespec;
#line 75 "include/linux/file.h"
struct __anonstruct_futex_32 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 75 "include/linux/file.h"
struct __anonstruct_nanosleep_33 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 75
struct pollfd;
#line 75 "include/linux/file.h"
struct __anonstruct_poll_34 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 75 "include/linux/file.h"
union __anonunion_ldv_6497_31 {
   struct __anonstruct_futex_32 futex ;
   struct __anonstruct_nanosleep_33 nanosleep ;
   struct __anonstruct_poll_34 poll ;
};
#line 75 "include/linux/file.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion_ldv_6497_31 ldv_6497 ;
};
#line 52 "include/linux/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 447 "include/linux/slab.h"
struct scatterlist;
#line 448
struct crypto_ablkcipher;
#line 449
struct crypto_async_request;
#line 450
struct crypto_aead;
#line 453
struct crypto_rng;
#line 454
struct crypto_tfm;
#line 455
struct crypto_type;
#line 456
struct aead_givcrypt_request;
#line 457
struct skcipher_givcrypt_request;
#line 129 "include/linux/crypto.h"
struct crypto_async_request {
   struct list_head list ;
   void (*complete)(struct crypto_async_request * , int  ) ;
   void *data ;
   struct crypto_tfm *tfm ;
   u32 flags ;
};
#line 138 "include/linux/crypto.h"
struct ablkcipher_request {
   struct crypto_async_request base ;
   unsigned int nbytes ;
   void *info ;
   struct scatterlist *src ;
   struct scatterlist *dst ;
   void *__ctx[] ;
};
#line 151 "include/linux/crypto.h"
struct aead_request {
   struct crypto_async_request base ;
   unsigned int assoclen ;
   unsigned int cryptlen ;
   u8 *iv ;
   struct scatterlist *assoc ;
   struct scatterlist *src ;
   struct scatterlist *dst ;
   void *__ctx[] ;
};
#line 177 "include/linux/crypto.h"
struct blkcipher_desc {
   struct crypto_blkcipher *tfm ;
   void *info ;
   u32 flags ;
};
#line 191 "include/linux/crypto.h"
struct hash_desc {
   struct crypto_hash *tfm ;
   u32 flags ;
};
#line 196 "include/linux/crypto.h"
struct ablkcipher_alg {
   int (*setkey)(struct crypto_ablkcipher * , u8 const   * , unsigned int  ) ;
   int (*encrypt)(struct ablkcipher_request * ) ;
   int (*decrypt)(struct ablkcipher_request * ) ;
   int (*givencrypt)(struct skcipher_givcrypt_request * ) ;
   int (*givdecrypt)(struct skcipher_givcrypt_request * ) ;
   char const   *geniv ;
   unsigned int min_keysize ;
   unsigned int max_keysize ;
   unsigned int ivsize ;
};
#line 215 "include/linux/crypto.h"
struct aead_alg {
   int (*setkey)(struct crypto_aead * , u8 const   * , unsigned int  ) ;
   int (*setauthsize)(struct crypto_aead * , unsigned int  ) ;
   int (*encrypt)(struct aead_request * ) ;
   int (*decrypt)(struct aead_request * ) ;
   int (*givencrypt)(struct aead_givcrypt_request * ) ;
   int (*givdecrypt)(struct aead_givcrypt_request * ) ;
   char const   *geniv ;
   unsigned int ivsize ;
   unsigned int maxauthsize ;
};
#line 230 "include/linux/crypto.h"
struct blkcipher_alg {
   int (*setkey)(struct crypto_tfm * , u8 const   * , unsigned int  ) ;
   int (*encrypt)(struct blkcipher_desc * , struct scatterlist * , struct scatterlist * ,
                  unsigned int  ) ;
   int (*decrypt)(struct blkcipher_desc * , struct scatterlist * , struct scatterlist * ,
                  unsigned int  ) ;
   char const   *geniv ;
   unsigned int min_keysize ;
   unsigned int max_keysize ;
   unsigned int ivsize ;
};
#line 247 "include/linux/crypto.h"
struct cipher_alg {
   unsigned int cia_min_keysize ;
   unsigned int cia_max_keysize ;
   int (*cia_setkey)(struct crypto_tfm * , u8 const   * , unsigned int  ) ;
   void (*cia_encrypt)(struct crypto_tfm * , u8 * , u8 const   * ) ;
   void (*cia_decrypt)(struct crypto_tfm * , u8 * , u8 const   * ) ;
};
#line 256 "include/linux/crypto.h"
struct compress_alg {
   int (*coa_compress)(struct crypto_tfm * , u8 const   * , unsigned int  , u8 * ,
                       unsigned int * ) ;
   int (*coa_decompress)(struct crypto_tfm * , u8 const   * , unsigned int  , u8 * ,
                         unsigned int * ) ;
};
#line 262 "include/linux/crypto.h"
struct rng_alg {
   int (*rng_make_random)(struct crypto_rng * , u8 * , unsigned int  ) ;
   int (*rng_reset)(struct crypto_rng * , u8 * , unsigned int  ) ;
   unsigned int seedsize ;
};
#line 271 "include/linux/crypto.h"
union __anonunion_cra_u_155 {
   struct ablkcipher_alg ablkcipher ;
   struct aead_alg aead ;
   struct blkcipher_alg blkcipher ;
   struct cipher_alg cipher ;
   struct compress_alg compress ;
   struct rng_alg rng ;
};
#line 271 "include/linux/crypto.h"
struct crypto_alg {
   struct list_head cra_list ;
   struct list_head cra_users ;
   u32 cra_flags ;
   unsigned int cra_blocksize ;
   unsigned int cra_ctxsize ;
   unsigned int cra_alignmask ;
   int cra_priority ;
   atomic_t cra_refcnt ;
   char cra_name[64U] ;
   char cra_driver_name[64U] ;
   struct crypto_type  const  *cra_type ;
   union __anonunion_cra_u_155 cra_u ;
   int (*cra_init)(struct crypto_tfm * ) ;
   void (*cra_exit)(struct crypto_tfm * ) ;
   void (*cra_destroy)(struct crypto_alg * ) ;
   struct module *cra_module ;
};
#line 325 "include/linux/crypto.h"
struct ablkcipher_tfm {
   int (*setkey)(struct crypto_ablkcipher * , u8 const   * , unsigned int  ) ;
   int (*encrypt)(struct ablkcipher_request * ) ;
   int (*decrypt)(struct ablkcipher_request * ) ;
   int (*givencrypt)(struct skcipher_givcrypt_request * ) ;
   int (*givdecrypt)(struct skcipher_givcrypt_request * ) ;
   struct crypto_ablkcipher *base ;
   unsigned int ivsize ;
   unsigned int reqsize ;
};
#line 345 "include/linux/crypto.h"
struct aead_tfm {
   int (*setkey)(struct crypto_aead * , u8 const   * , unsigned int  ) ;
   int (*encrypt)(struct aead_request * ) ;
   int (*decrypt)(struct aead_request * ) ;
   int (*givencrypt)(struct aead_givcrypt_request * ) ;
   int (*givdecrypt)(struct aead_givcrypt_request * ) ;
   struct crypto_aead *base ;
   unsigned int ivsize ;
   unsigned int authsize ;
   unsigned int reqsize ;
};
#line 360 "include/linux/crypto.h"
struct blkcipher_tfm {
   void *iv ;
   int (*setkey)(struct crypto_tfm * , u8 const   * , unsigned int  ) ;
   int (*encrypt)(struct blkcipher_desc * , struct scatterlist * , struct scatterlist * ,
                  unsigned int  ) ;
   int (*decrypt)(struct blkcipher_desc * , struct scatterlist * , struct scatterlist * ,
                  unsigned int  ) ;
};
#line 369 "include/linux/crypto.h"
struct cipher_tfm {
   int (*cit_setkey)(struct crypto_tfm * , u8 const   * , unsigned int  ) ;
   void (*cit_encrypt_one)(struct crypto_tfm * , u8 * , u8 const   * ) ;
   void (*cit_decrypt_one)(struct crypto_tfm * , u8 * , u8 const   * ) ;
};
#line 377 "include/linux/crypto.h"
struct hash_tfm {
   int (*init)(struct hash_desc * ) ;
   int (*update)(struct hash_desc * , struct scatterlist * , unsigned int  ) ;
   int (*final)(struct hash_desc * , u8 * ) ;
   int (*digest)(struct hash_desc * , struct scatterlist * , unsigned int  , u8 * ) ;
   int (*setkey)(struct crypto_hash * , u8 const   * , unsigned int  ) ;
   unsigned int digestsize ;
};
#line 389 "include/linux/crypto.h"
struct compress_tfm {
   int (*cot_compress)(struct crypto_tfm * , u8 const   * , unsigned int  , u8 * ,
                       unsigned int * ) ;
   int (*cot_decompress)(struct crypto_tfm * , u8 const   * , unsigned int  , u8 * ,
                         unsigned int * ) ;
};
#line 396 "include/linux/crypto.h"
struct rng_tfm {
   int (*rng_gen_random)(struct crypto_rng * , u8 * , unsigned int  ) ;
   int (*rng_reset)(struct crypto_rng * , u8 * , unsigned int  ) ;
};
#line 404 "include/linux/crypto.h"
union __anonunion_crt_u_156 {
   struct ablkcipher_tfm ablkcipher ;
   struct aead_tfm aead ;
   struct blkcipher_tfm blkcipher ;
   struct cipher_tfm cipher ;
   struct hash_tfm hash ;
   struct compress_tfm compress ;
   struct rng_tfm rng ;
};
#line 404 "include/linux/crypto.h"
struct crypto_tfm {
   u32 crt_flags ;
   union __anonunion_crt_u_156 crt_u ;
   void (*exit)(struct crypto_tfm * ) ;
   struct crypto_alg *__crt_alg ;
   void *__crt_ctx[] ;
};
#line 433 "include/linux/crypto.h"
struct crypto_ablkcipher {
   struct crypto_tfm base ;
};
#line 437 "include/linux/crypto.h"
struct crypto_aead {
   struct crypto_tfm base ;
};
#line 441 "include/linux/crypto.h"
struct crypto_blkcipher {
   struct crypto_tfm base ;
};
#line 453 "include/linux/crypto.h"
struct crypto_hash {
   struct crypto_tfm base ;
};
#line 457 "include/linux/crypto.h"
struct crypto_rng {
   struct crypto_tfm base ;
};
#line 28 "include/linux/fs_stack.h"
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
#line 37 "include/keys/encrypted-type.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 6 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.o.c"
struct __va_list_tag;
#line 6 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.o.c"
typedef struct __va_list_tag __va_list_tag;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list[1U];
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list[1U];
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 153 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 195 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 289
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 296
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 304
struct wakeup_source;
#line 494 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 499
struct dev_pm_qos;
#line 499 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 557 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 128 "include/linux/kobject.h"
struct kobj_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct kobject * , struct kobj_attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct kobj_attribute * , char const   * ,
                    size_t  ) ;
};
#line 214
struct kernel_param;
#line 215 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 47 "include/linux/moduleparam.h"
struct kparam_string;
#line 47
struct kparam_array;
#line 47 "include/linux/moduleparam.h"
union __anonunion_ldv_14548_137 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 47 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_14548_137 ldv_14548 ;
};
#line 59 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 65 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 457 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 210 "include/linux/jump_label.h"
struct tracepoint;
#line 211 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 201
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 207 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 222
struct module_sect_attrs;
#line 222
struct module_notes_attrs;
#line 222
struct ftrace_event_call;
#line 222 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/smap.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 123 "include/net/checksum.h"
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 23 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 53 "include/linux/device.h"
struct device_attribute;
#line 53
struct driver_attribute;
#line 53 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 127
struct device_type;
#line 184
struct of_device_id;
#line 184
struct acpi_device_id;
#line 184 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 249 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 303
struct class_attribute;
#line 303 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 398 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 451 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 478 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 577 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 587 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 592
struct dma_coherent_mem;
#line 592 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
};
#line 720 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 17 "include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 471 "include/linux/hrtimer.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 322 "include/linux/key.h"
struct match_token {
   int token ;
   char const   *pattern ;
};
#line 26 "include/linux/parser.h"
struct __anonstruct_substring_t_173 {
   char *from ;
   char *to ;
};
#line 26 "include/linux/parser.h"
typedef struct __anonstruct_substring_t_173 substring_t;
#line 358 "include/linux/backing-dev.h"
struct ecryptfs_session_key {
   u32 flags ;
   u32 encrypted_key_size ;
   u32 decrypted_key_size ;
   u8 encrypted_key[512U] ;
   u8 decrypted_key[64U] ;
};
#line 73 "include/linux/ecryptfs.h"
struct ecryptfs_password {
   u32 password_bytes ;
   s32 hash_algo ;
   u32 hash_iterations ;
   u32 session_key_encryption_key_bytes ;
   u32 flags ;
   u8 session_key_encryption_key[64U] ;
   u8 signature[17U] ;
   u8 salt[8U] ;
};
#line 93 "include/linux/ecryptfs.h"
struct ecryptfs_private_key {
   u32 key_size ;
   u32 data_len ;
   u8 signature[17U] ;
   char pki_type[17U] ;
   u8 data[] ;
};
#line 98 "include/linux/ecryptfs.h"
union __anonunion_token_187 {
   struct ecryptfs_password password ;
   struct ecryptfs_private_key private_key ;
};
#line 98 "include/linux/ecryptfs.h"
struct ecryptfs_auth_tok {
   u16 version ;
   u16 token_type ;
   u32 flags ;
   struct ecryptfs_session_key session_key ;
   u8 reserved[32U] ;
   union __anonunion_token_187 token ;
};
#line 252 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_global_auth_tok {
   u32 flags ;
   struct list_head mount_crypt_stat_list ;
   struct key *global_auth_tok_key ;
   unsigned char sig[17U] ;
};
#line 280 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_key_tfm {
   struct crypto_blkcipher *key_tfm ;
   size_t key_size ;
   struct mutex key_tfm_mutex ;
   struct list_head key_tfm_list ;
   unsigned char cipher_name[33U] ;
};
#line 781 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
struct ecryptfs_cache_info {
   struct kmem_cache **cache ;
   char const   *name ;
   size_t size ;
   void (*ctor)(void * ) ;
};
#line 1208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
typedef int ldv_func_ret_type___2;
#line 1270 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
typedef int ldv_func_ret_type___8;
#line 80 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
struct __anonstruct___kernel_fsid_t_5 {
   int val[2U] ;
};
#line 80 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef struct __anonstruct___kernel_fsid_t_5 __kernel_fsid_t;
#line 166 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 447 "include/linux/slab.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   void *private ;
};
#line 34 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 7 "include/asm-generic/statfs.h"
struct kstatfs {
   long f_type ;
   long f_bsize ;
   u64 f_blocks ;
   u64 f_bfree ;
   u64 f_bavail ;
   u64 f_files ;
   u64 f_ffree ;
   __kernel_fsid_t f_fsid ;
   long f_namelen ;
   long f_frsize ;
   long f_flags ;
   long f_spare[4U] ;
};
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 244 "include/linux/pagemap.h"
typedef int filler_t(void * , struct page * );
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 124 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_key_sig {
   struct list_head crypt_stat_list ;
   char keysig[17U] ;
};
#line 179 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_filename {
   struct list_head crypt_stat_list ;
   u32 flags ;
   u32 seq_no ;
   char *filename ;
   char *encrypted_filename ;
   size_t filename_size ;
   size_t encrypted_filename_size ;
   char fnek_sig[16U] ;
   char dentry_name[57U] ;
};
#line 1143 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
struct ecryptfs_flag_map_elem {
   u32 file_flag ;
   u32 local_flag ;
};
#line 1220 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
struct ecryptfs_cipher_code_str_map_elem {
   char cipher_str[16U] ;
   u8 cipher_code ;
};
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 224 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
struct perf_event_attr;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 173 "include/linux/seq_file.h"
struct ring_buffer;
#line 174
struct ring_buffer_iter;
#line 183 "include/linux/ring_buffer.h"
struct trace_seq;
#line 32 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state;
#line 2667 "include/linux/fs.h"
struct trace_seq {
   unsigned char buffer[4096U] ;
   unsigned int len ;
   unsigned int readpos ;
   int full ;
};
#line 284 "include/linux/hardirq.h"
union __anonunion_ldv_22028_170 {
   __u64 sample_period ;
   __u64 sample_freq ;
};
#line 284 "include/linux/hardirq.h"
union __anonunion_ldv_22057_171 {
   __u32 wakeup_events ;
   __u32 wakeup_watermark ;
};
#line 284 "include/linux/hardirq.h"
union __anonunion_ldv_22062_172 {
   __u64 bp_addr ;
   __u64 config1 ;
};
#line 284 "include/linux/hardirq.h"
union __anonunion_ldv_22066_173 {
   __u64 bp_len ;
   __u64 config2 ;
};
#line 284 "include/linux/hardirq.h"
struct perf_event_attr {
   __u32 type ;
   __u32 size ;
   __u64 config ;
   union __anonunion_ldv_22028_170 ldv_22028 ;
   __u64 sample_type ;
   __u64 read_format ;
   unsigned char disabled : 1 ;
   unsigned char inherit : 1 ;
   unsigned char pinned : 1 ;
   unsigned char exclusive : 1 ;
   unsigned char exclude_user : 1 ;
   unsigned char exclude_kernel : 1 ;
   unsigned char exclude_hv : 1 ;
   unsigned char exclude_idle : 1 ;
   unsigned char mmap : 1 ;
   unsigned char comm : 1 ;
   unsigned char freq : 1 ;
   unsigned char inherit_stat : 1 ;
   unsigned char enable_on_exec : 1 ;
   unsigned char task : 1 ;
   unsigned char watermark : 1 ;
   unsigned char precise_ip : 2 ;
   unsigned char mmap_data : 1 ;
   unsigned char sample_id_all : 1 ;
   unsigned char exclude_host : 1 ;
   unsigned char exclude_guest : 1 ;
   unsigned char exclude_callchain_kernel : 1 ;
   unsigned char exclude_callchain_user : 1 ;
   unsigned long __reserved_1 : 41 ;
   union __anonunion_ldv_22057_171 ldv_22057 ;
   __u32 bp_type ;
   union __anonunion_ldv_22062_172 ldv_22062 ;
   union __anonunion_ldv_22066_173 ldv_22066 ;
   __u64 branch_sample_type ;
   __u64 sample_regs_user ;
   __u32 sample_stack_user ;
   __u32 __reserved_2 ;
};
#line 2849 "include/linux/sched.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 53 "include/linux/xattr.h"
struct simple_xattrs {
   struct list_head head ;
   spinlock_t lock ;
};
#line 98
struct cgroupfs_root;
#line 100
struct cgroup;
#line 101
struct css_id;
#line 62 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   atomic_t refcnt ;
   unsigned long flags ;
   struct css_id *id ;
   struct work_struct dput_work ;
};
#line 140 "include/linux/cgroup.h"
struct cgroup {
   unsigned long flags ;
   atomic_t count ;
   int id ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head files ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroupfs_root *root ;
   struct cgroup *top_cgroup ;
   struct list_head css_sets ;
   struct list_head allcg_node ;
   struct list_head cft_q_node ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct callback_head callback_head ;
   struct list_head event_list ;
   spinlock_t event_list_lock ;
   struct simple_xattrs xattrs ;
};
#line 214 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cg_links ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct callback_head callback_head ;
};
#line 11 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/local.h"
struct __anonstruct_local_t_182 {
   atomic_long_t a ;
};
#line 11 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/local.h"
typedef struct __anonstruct_local_t_182 local_t;
#line 25 "include/asm-generic/local64.h"
struct __anonstruct_local64_t_183 {
   local_t a ;
};
#line 25 "include/asm-generic/local64.h"
typedef struct __anonstruct_local64_t_183 local64_t;
#line 34 "include/linux/perf_event.h"
struct arch_hw_breakpoint {
   unsigned long address ;
   u8 len ;
   u8 type ;
};
#line 49 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/hw_breakpoint.h"
struct pmu;
#line 84 "include/linux/nsproxy.h"
struct pidmap {
   atomic_t nr_free ;
   void *page ;
};
#line 15 "include/linux/pid_namespace.h"
struct bsd_acct_struct;
#line 16 "include/linux/pid_namespace.h"
struct pid_namespace {
   struct kref kref ;
   struct pidmap pidmap[128U] ;
   int last_pid ;
   int nr_hashed ;
   struct task_struct *child_reaper ;
   struct kmem_cache *pid_cachep ;
   unsigned int level ;
   struct pid_namespace *parent ;
   struct vfsmount *proc_mnt ;
   struct bsd_acct_struct *bacct ;
   struct user_namespace *user_ns ;
   struct work_struct proc_work ;
   kgid_t pid_gid ;
   int hide_pid ;
   int reboot ;
   unsigned int proc_inum ;
};
#line 210 "include/linux/cpu.h"
struct irq_work {
   unsigned long flags ;
   struct llist_node llnode ;
   void (*func)(struct irq_work * ) ;
};
#line 9 "include/linux/perf_regs.h"
struct perf_callchain_entry {
   __u64 nr ;
   __u64 ip[127U] ;
};
#line 61 "include/linux/perf_event.h"
struct perf_raw_record {
   u32 size ;
   void *data ;
};
#line 66 "include/linux/perf_event.h"
struct perf_branch_entry {
   __u64 from ;
   __u64 to ;
   unsigned char mispred : 1 ;
   unsigned char predicted : 1 ;
   unsigned long reserved : 62 ;
};
#line 85 "include/linux/perf_event.h"
struct perf_branch_stack {
   __u64 nr ;
   struct perf_branch_entry entries[0U] ;
};
#line 99 "include/linux/perf_event.h"
struct perf_regs_user {
   __u64 abi ;
   struct pt_regs *regs ;
};
#line 104 "include/linux/perf_event.h"
struct hw_perf_event_extra {
   u64 config ;
   unsigned int reg ;
   int alloc ;
   int idx ;
};
#line 116 "include/linux/perf_event.h"
struct __anonstruct_ldv_27551_185 {
   u64 config ;
   u64 last_tag ;
   unsigned long config_base ;
   unsigned long event_base ;
   int event_base_rdpmc ;
   int idx ;
   int last_cpu ;
   struct hw_perf_event_extra extra_reg ;
   struct hw_perf_event_extra branch_reg ;
};
#line 116 "include/linux/perf_event.h"
struct __anonstruct_ldv_27554_186 {
   struct hrtimer hrtimer ;
};
#line 116 "include/linux/perf_event.h"
struct __anonstruct_ldv_27559_187 {
   struct arch_hw_breakpoint info ;
   struct list_head bp_list ;
   struct task_struct *bp_target ;
};
#line 116 "include/linux/perf_event.h"
union __anonunion_ldv_27560_184 {
   struct __anonstruct_ldv_27551_185 ldv_27551 ;
   struct __anonstruct_ldv_27554_186 ldv_27554 ;
   struct __anonstruct_ldv_27559_187 ldv_27559 ;
};
#line 116 "include/linux/perf_event.h"
struct hw_perf_event {
   union __anonunion_ldv_27560_184 ldv_27560 ;
   int state ;
   local64_t prev_count ;
   u64 sample_period ;
   u64 last_period ;
   local64_t period_left ;
   u64 interrupts_seq ;
   u64 interrupts ;
   u64 freq_time_stamp ;
   u64 freq_count_stamp ;
};
#line 162
struct perf_cpu_context;
#line 162 "include/linux/perf_event.h"
struct pmu {
   struct list_head entry ;
   struct device *dev ;
   struct attribute_group  const  **attr_groups ;
   char *name ;
   int type ;
   int *pmu_disable_count ;
   struct perf_cpu_context *pmu_cpu_context ;
   int task_ctx_nr ;
   void (*pmu_enable)(struct pmu * ) ;
   void (*pmu_disable)(struct pmu * ) ;
   int (*event_init)(struct perf_event * ) ;
   int (*add)(struct perf_event * , int  ) ;
   void (*del)(struct perf_event * , int  ) ;
   void (*start)(struct perf_event * , int  ) ;
   void (*stop)(struct perf_event * , int  ) ;
   void (*read)(struct perf_event * ) ;
   void (*start_txn)(struct pmu * ) ;
   int (*commit_txn)(struct pmu * ) ;
   void (*cancel_txn)(struct pmu * ) ;
   int (*event_idx)(struct perf_event * ) ;
   void (*flush_branch_stack)(void) ;
};
#line 263
enum perf_event_active_state {
    PERF_EVENT_STATE_ERROR = -2,
    PERF_EVENT_STATE_OFF = -1,
    PERF_EVENT_STATE_INACTIVE = 0,
    PERF_EVENT_STATE_ACTIVE = 1
} ;
#line 270
struct perf_sample_data;
#line 292 "include/linux/perf_event.h"
struct perf_cgroup_info {
   u64 time ;
   u64 timestamp ;
};
#line 306 "include/linux/perf_event.h"
struct perf_cgroup {
   struct cgroup_subsys_state css ;
   struct perf_cgroup_info *info ;
};
#line 311
struct event_filter;
#line 311 "include/linux/perf_event.h"
struct perf_event {
   struct list_head group_entry ;
   struct list_head event_entry ;
   struct list_head sibling_list ;
   struct hlist_node hlist_entry ;
   int nr_siblings ;
   int group_flags ;
   struct perf_event *group_leader ;
   struct pmu *pmu ;
   enum perf_event_active_state state ;
   unsigned int attach_state ;
   local64_t count ;
   atomic64_t child_count ;
   u64 total_time_enabled ;
   u64 total_time_running ;
   u64 tstamp_enabled ;
   u64 tstamp_running ;
   u64 tstamp_stopped ;
   u64 shadow_ctx_time ;
   struct perf_event_attr attr ;
   u16 header_size ;
   u16 id_header_size ;
   u16 read_size ;
   struct hw_perf_event hw ;
   struct perf_event_context *ctx ;
   atomic_long_t refcount ;
   atomic64_t child_total_time_enabled ;
   atomic64_t child_total_time_running ;
   struct mutex child_mutex ;
   struct list_head child_list ;
   struct perf_event *parent ;
   int oncpu ;
   int cpu ;
   struct list_head owner_entry ;
   struct task_struct *owner ;
   struct mutex mmap_mutex ;
   atomic_t mmap_count ;
   int mmap_locked ;
   struct user_struct *mmap_user ;
   struct ring_buffer *rb ;
   struct list_head rb_entry ;
   wait_queue_head_t waitq ;
   struct fasync_struct *fasync ;
   int pending_wakeup ;
   int pending_kill ;
   int pending_disable ;
   struct irq_work pending ;
   atomic_t event_limit ;
   void (*destroy)(struct perf_event * ) ;
   struct callback_head callback_head ;
   struct pid_namespace *ns ;
   u64 id ;
   void (*overflow_handler)(struct perf_event * , struct perf_sample_data * , struct pt_regs * ) ;
   void *overflow_handler_context ;
   struct ftrace_event_call *tp_event ;
   struct event_filter *filter ;
   struct perf_cgroup *cgrp ;
   int cgrp_defer_enabled ;
};
#line 440
enum perf_event_context_type {
    task_context = 0,
    cpu_context = 1
} ;
#line 445 "include/linux/perf_event.h"
struct perf_event_context {
   struct pmu *pmu ;
   enum perf_event_context_type type ;
   raw_spinlock_t lock ;
   struct mutex mutex ;
   struct list_head pinned_groups ;
   struct list_head flexible_groups ;
   struct list_head event_list ;
   int nr_events ;
   int nr_active ;
   int is_active ;
   int nr_stat ;
   int nr_freq ;
   int rotate_disable ;
   atomic_t refcount ;
   struct task_struct *task ;
   u64 time ;
   u64 timestamp ;
   struct perf_event_context *parent_ctx ;
   u64 parent_gen ;
   u64 generation ;
   int pin_count ;
   int nr_cgroups ;
   int nr_branch_stack ;
   struct callback_head callback_head ;
};
#line 499 "include/linux/perf_event.h"
struct perf_cpu_context {
   struct perf_event_context ctx ;
   struct perf_event_context *task_ctx ;
   int active_oncpu ;
   int exclusive ;
   struct list_head rotation_list ;
   int jiffies_interval ;
   struct pmu *unique_pmu ;
   struct perf_cgroup *cgrp ;
};
#line 561 "include/linux/perf_event.h"
struct __anonstruct_tid_entry_188 {
   u32 pid ;
   u32 tid ;
};
#line 561 "include/linux/perf_event.h"
struct __anonstruct_cpu_entry_189 {
   u32 cpu ;
   u32 reserved ;
};
#line 561 "include/linux/perf_event.h"
struct perf_sample_data {
   u64 type ;
   u64 ip ;
   struct __anonstruct_tid_entry_188 tid_entry ;
   u64 time ;
   u64 addr ;
   u64 id ;
   u64 stream_id ;
   struct __anonstruct_cpu_entry_189 cpu_entry ;
   u64 period ;
   struct perf_callchain_entry *callchain ;
   struct perf_raw_record *raw ;
   struct perf_branch_stack *br_stack ;
   struct perf_regs_user regs_user ;
   u64 stack_user_size ;
};
#line 756
struct trace_array;
#line 757
struct tracer;
#line 39 "include/linux/ftrace_event.h"
struct trace_entry {
   unsigned short type ;
   unsigned char flags ;
   unsigned char preempt_count ;
   int pid ;
   int padding ;
};
#line 54 "include/linux/ftrace_event.h"
struct trace_iterator {
   struct trace_array *tr ;
   struct tracer *trace ;
   void *private ;
   int cpu_file ;
   struct mutex mutex ;
   struct ring_buffer_iter **buffer_iter ;
   unsigned long iter_flags ;
   struct trace_seq tmp_seq ;
   struct trace_seq seq ;
   struct trace_entry *ent ;
   unsigned long lost_events ;
   int leftover ;
   int ent_size ;
   int cpu ;
   u64 ts ;
   loff_t pos ;
   long idx ;
   cpumask_var_t started ;
};
#line 94
struct trace_event;
#line 98
enum print_line_t;
#line 99 "include/linux/ftrace_event.h"
struct trace_event_functions {
   enum print_line_t (*trace)(struct trace_iterator * , int  , struct trace_event * ) ;
   enum print_line_t (*raw)(struct trace_iterator * , int  , struct trace_event * ) ;
   enum print_line_t (*hex)(struct trace_iterator * , int  , struct trace_event * ) ;
   enum print_line_t (*binary)(struct trace_iterator * , int  , struct trace_event * ) ;
};
#line 107 "include/linux/ftrace_event.h"
struct trace_event {
   struct hlist_node node ;
   struct list_head list ;
   int type ;
   struct trace_event_functions *funcs ;
};
#line 117
enum print_line_t {
    TRACE_TYPE_PARTIAL_LINE = 0,
    TRACE_TYPE_HANDLED = 1,
    TRACE_TYPE_UNHANDLED = 2,
    TRACE_TYPE_NO_CONSUME = 3
} ;
#line 147
enum trace_reg {
    TRACE_REG_REGISTER = 0,
    TRACE_REG_UNREGISTER = 1,
    TRACE_REG_PERF_REGISTER = 2,
    TRACE_REG_PERF_UNREGISTER = 3,
    TRACE_REG_PERF_OPEN = 4,
    TRACE_REG_PERF_CLOSE = 5,
    TRACE_REG_PERF_ADD = 6,
    TRACE_REG_PERF_DEL = 7
} ;
#line 158 "include/linux/ftrace_event.h"
struct ftrace_event_class {
   char *system ;
   void *probe ;
   void *perf_probe ;
   int (*reg)(struct ftrace_event_call * , enum trace_reg  , void * ) ;
   int (*define_fields)(struct ftrace_event_call * ) ;
   struct list_head *(*get_fields)(struct ftrace_event_call * ) ;
   struct list_head fields ;
   int (*raw_init)(struct ftrace_event_call * ) ;
};
#line 198 "include/linux/ftrace_event.h"
struct ftrace_event_call {
   struct list_head list ;
   struct ftrace_event_class *class ;
   char *name ;
   struct dentry *dir ;
   struct trace_event event ;
   char const   *print_fmt ;
   struct event_filter *filter ;
   void *mod ;
   void *data ;
   unsigned int flags ;
   int perf_refcount ;
   struct hlist_head *perf_events ;
};
#line 273 "include/linux/scatterlist.h"
struct user_key_payload {
   struct callback_head rcu ;
   unsigned short datalen ;
   char data[0U] ;
};
#line 47 "include/keys/user-type.h"
struct encrypted_key_payload {
   struct callback_head rcu ;
   char *format ;
   char *master_desc ;
   char *datalen ;
   u8 *iv ;
   u8 *encrypted_data ;
   unsigned short datablob_len ;
   unsigned short decrypted_datalen ;
   unsigned short payload_datalen ;
   unsigned short encrypted_key_format ;
   u8 *decrypted_data ;
   u8 payload_data[0U] ;
};
#line 55 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_key_record {
   unsigned char type ;
   size_t enc_key_size ;
   unsigned char sig[8U] ;
   unsigned char enc_key[512U] ;
};
#line 345 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_auth_tok_list_item {
   unsigned char encrypted_session_key[64U] ;
   struct list_head list ;
   struct ecryptfs_auth_tok auth_tok ;
};
#line 352 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_message {
   u32 index ;
   u32 data_len ;
   u8 data[] ;
};
#line 361 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_msg_ctx {
   u8 state ;
   u8 type ;
   u32 index ;
   u32 counter ;
   size_t msg_size ;
   struct ecryptfs_message *msg ;
   struct task_struct *task ;
   struct list_head node ;
   struct list_head daemon_out_list ;
   struct mutex mux ;
};
#line 721 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
struct ecryptfs_write_tag_70_packet_silly_stack {
   u8 cipher_code ;
   size_t max_packet_size ;
   size_t packet_size_len ;
   size_t block_aligned_filename_size ;
   size_t block_size ;
   size_t i ;
   size_t j ;
   size_t num_rand_bytes ;
   struct mutex *tfm_mutex ;
   char *block_aligned_filename ;
   struct ecryptfs_auth_tok *auth_tok ;
   struct scatterlist src_sg[2U] ;
   struct scatterlist dst_sg[2U] ;
   struct blkcipher_desc desc ;
   char iv[16U] ;
   char hash[16U] ;
   char tmp_hash[16U] ;
   struct hash_desc hash_desc ;
   struct scatterlist hash_sg ;
};
#line 1014 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
struct ecryptfs_parse_tag_70_packet_silly_stack {
   u8 cipher_code ;
   size_t max_packet_size ;
   size_t packet_size_len ;
   size_t parsed_tag_70_packet_size ;
   size_t block_aligned_filename_size ;
   size_t block_size ;
   size_t i ;
   struct mutex *tfm_mutex ;
   char *decrypted_filename ;
   struct ecryptfs_auth_tok *auth_tok ;
   struct scatterlist src_sg[2U] ;
   struct scatterlist dst_sg[2U] ;
   struct blkcipher_desc desc ;
   char fnek_sig_hex[17U] ;
   char iv[16U] ;
   char cipher_string[32U] ;
};
#line 2802 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
typedef int ldv_func_ret_type___4;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 84 "include/linux/nsproxy.h"
struct uid_gid_extent {
   u32 first ;
   u32 lower_first ;
   u32 count ;
};
#line 18 "include/linux/user_namespace.h"
struct uid_gid_map {
   u32 nr_extents ;
   struct uid_gid_extent extent[5U] ;
};
#line 19 "include/linux/user_namespace.h"
struct user_namespace {
   struct uid_gid_map uid_map ;
   struct uid_gid_map gid_map ;
   struct uid_gid_map projid_map ;
   struct kref kref ;
   struct user_namespace *parent ;
   kuid_t owner ;
   kgid_t group ;
   unsigned int proc_inum ;
};
#line 387 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_daemon {
   u32 flags ;
   u32 num_queued_msg_ctx ;
   struct file *file ;
   struct mutex mux ;
   struct list_head msg_ctx_out_queue ;
   wait_queue_head_t wait ;
   struct hlist_node euid_chain ;
};
#line 652 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
typedef int ldv_func_ret_type___3;
#line 11 "include/linux/wait.h"
struct __wait_queue;
#line 11 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 14 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 74 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/archrandom.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations  const  *fops ;
   struct list_head list ;
   struct device *parent ;
   struct device *this_device ;
   char const   *nodename ;
   umode_t mode ;
};
#line 251 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 40 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 687 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct ecryptfs_open_req {
   struct file **lower_file ;
   struct path path ;
   struct completion done ;
   struct list_head kthread_ctl_list ;
};
#line 171 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
struct ecryptfs_kthread_ctl {
   u32 flags ;
   struct mutex mux ;
   struct list_head req_list ;
   wait_queue_head_t wait ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 169 "include/linux/mutex.h"
extern void mutex_unlock(struct mutex * ) ;
#line 172
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_4(struct mutex *ldv_func_arg1 ) ;
#line 7 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 10
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) ;
#line 19
void ldv_mutex_lock_cred_guard_mutex(struct mutex *lock ) ;
#line 23
void ldv_mutex_unlock_cred_guard_mutex(struct mutex *lock ) ;
#line 99
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 103
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 398 "include/linux/dcache.h"
extern void dput(struct dentry * ) ;
#line 63 "include/linux/mount.h"
extern void mntput(struct vfsmount * ) ;
#line 11 "include/linux/fs_stack.h"
extern void fsstack_copy_attr_all(struct inode * , struct inode  const  * ) ;
#line 136 "include/linux/slab.h"
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
#line 438 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct ecryptfs_inode_info *ecryptfs_inode_to_private(struct inode *inode ) 
{ 
  struct inode  const  *__mptr ;

  {
#line 440
  __mptr = (struct inode  const  *)inode;
#line 440
  return ((struct ecryptfs_inode_info *)__mptr);
}
}
#line 443 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct inode *ecryptfs_inode_to_lower(struct inode *inode ) 
{ 
  struct ecryptfs_inode_info *tmp ;

  {
#line 445
  tmp = ecryptfs_inode_to_private(inode);
#line 445
  return (tmp->wii_inode);
}
}
#line 481 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct ecryptfs_dentry_info *ecryptfs_dentry_to_private(struct dentry *dentry ) 
{ 


  {
#line 483
  return ((struct ecryptfs_dentry_info *)dentry->d_fsdata);
}
}
#line 494 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct dentry *ecryptfs_dentry_to_lower(struct dentry *dentry ) 
{ 


  {
#line 496
  return (((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path.dentry);
}
}
#line 507 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct vfsmount *ecryptfs_dentry_to_lower_mnt(struct dentry *dentry ) 
{ 


  {
#line 509
  return (((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path.mnt);
}
}
#line 530
struct dentry_operations  const  ecryptfs_dops ;
#line 539 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_dentry_info_cache  ;
#line 181 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
static int ecryptfs_d_revalidate(struct dentry *dentry , unsigned int flags ) 
{ 
  struct dentry *lower_dentry ;
  struct vfsmount *lower_mnt ;
  int rc ;
  struct inode *lower_inode ;
  struct inode *tmp ;

  {
#line 185
  rc = 1;
#line 187
  if ((flags & 64U) != 0U) {
#line 188
    return (-10);
  } else {

  }
#line 190
  lower_dentry = ecryptfs_dentry_to_lower(dentry);
#line 191
  lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);
#line 192
  if ((unsigned long )lower_dentry->d_op == (unsigned long )((struct dentry_operations  const  *)0) || (unsigned long )(lower_dentry->d_op)->d_revalidate == (unsigned long )((int (*/* const  */)(struct dentry * ,
                                                                                                                                                                                                   unsigned int  ))0)) {
#line 193
    goto out;
  } else {

  }
#line 194
  rc = (*((lower_dentry->d_op)->d_revalidate))(lower_dentry, flags);
#line 195
  if ((unsigned long )dentry->d_inode != (unsigned long )((struct inode *)0)) {
#line 196
    tmp = ecryptfs_inode_to_lower(dentry->d_inode);
#line 196
    lower_inode = tmp;
#line 199
    fsstack_copy_attr_all(dentry->d_inode, (struct inode  const  *)lower_inode);
  } else {

  }
  out: ;
#line 202
  return (rc);
}
}
#line 213 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
static void ecryptfs_d_release(struct dentry *dentry ) 
{ 
  struct dentry *tmp ;
  struct vfsmount *tmp___0 ;
  struct dentry *tmp___1 ;
  struct ecryptfs_dentry_info *tmp___2 ;
  struct ecryptfs_dentry_info *tmp___3 ;

  {
#line 215
  tmp___3 = ecryptfs_dentry_to_private(dentry);
#line 215
  if ((unsigned long )tmp___3 != (unsigned long )((struct ecryptfs_dentry_info *)0)) {
#line 216
    tmp___1 = ecryptfs_dentry_to_lower(dentry);
#line 216
    if ((unsigned long )tmp___1 != (unsigned long )((struct dentry *)0)) {
#line 217
      tmp = ecryptfs_dentry_to_lower(dentry);
#line 217
      dput(tmp);
#line 218
      tmp___0 = ecryptfs_dentry_to_lower_mnt(dentry);
#line 218
      mntput(tmp___0);
    } else {

    }
#line 220
    tmp___2 = ecryptfs_dentry_to_private(dentry);
#line 220
    kmem_cache_free(ecryptfs_dentry_info_cache, (void *)tmp___2);
  } else {

  }
#line 223
  return;
}
}
#line 226 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
struct dentry_operations  const  ecryptfs_dops  = 
#line 226
     {& ecryptfs_d_revalidate, 0, 0, 0, & ecryptfs_d_release, 0, 0, 0, 0, 0};
#line 247
void ldv_check_final_state(void) ;
#line 256
void ldv_initialize(void) ;
#line 259
extern void ldv_handler_precall(void) ;
#line 262
extern int __VERIFIER_nondet_int(void) ;
#line 265 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
int LDV_IN_INTERRUPT  ;
#line 268 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
void ldv_main0_sequence_infinite_withcheck_stateful(void) 
{ 
  struct dentry *var_group1 ;
  unsigned int var_ecryptfs_d_revalidate_0_p1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 290
  LDV_IN_INTERRUPT = 1;
#line 299
  ldv_initialize();
#line 303
  goto ldv_24676;
  ldv_24675: 
#line 306
  tmp = __VERIFIER_nondet_int();
#line 306
  switch (tmp) {
  case 0: 
#line 316
  ldv_handler_precall();
#line 317
  ecryptfs_d_revalidate(var_group1, var_ecryptfs_d_revalidate_0_p1);
#line 324
  goto ldv_24672;
  case 1: 
#line 333
  ldv_handler_precall();
#line 334
  ecryptfs_d_release(var_group1);
#line 341
  goto ldv_24672;
  default: ;
#line 342
  goto ldv_24672;
  }
  ldv_24672: ;
  ldv_24676: 
#line 303
  tmp___0 = __VERIFIER_nondet_int();
#line 303
  if (tmp___0 != 0) {
#line 304
    goto ldv_24675;
  } else {

  }


#line 351
  ldv_check_final_state();
#line 354
  return;
}
}
#line 358 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 363
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 365
  mutex_lock(ldv_func_arg1);
#line 366
  return;
}
}
#line 368 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 373
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 375
  mutex_unlock(ldv_func_arg1);
#line 376
  return;
}
}
#line 378 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 383
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 385
  mutex_lock(ldv_func_arg1);
#line 386
  return;
}
}
#line 388 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/dentry.c.prepared"
void ldv_mutex_unlock_4(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 393
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 395
  mutex_unlock(ldv_func_arg1);
#line 396
  return;
}
}
#line 119 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 55 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *memset(void * , int  , size_t  ) ;
#line 172 "include/linux/mutex.h"
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_lock_9(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_15(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) ;
#line 47
void ldv_mutex_lock_cs_mutex(struct mutex *lock ) ;
#line 51
void ldv_mutex_unlock_cs_mutex(struct mutex *lock ) ;
#line 647 "include/linux/fs.h"
__inline static loff_t i_size_read(struct inode  const  *inode ) 
{ 


  {
#line 666
  return ((loff_t )inode->i_size);
}
}
#line 1792
extern void touch_atime(struct path * ) ;
#line 2194
extern int filemap_write_and_wait(struct address_space * ) ;
#line 2204
extern int vfs_fsync(struct file * , int  ) ;
#line 2287
extern loff_t default_llseek(struct file * , loff_t  , int  ) ;
#line 2357
extern int generic_file_mmap(struct file * , struct vm_area_struct * ) ;
#line 2363
extern ssize_t generic_file_aio_read(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                     loff_t  ) ;
#line 2366
extern ssize_t generic_file_aio_write(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                      loff_t  ) ;
#line 2371
extern ssize_t do_sync_read(struct file * , char * , size_t  , loff_t * ) ;
#line 2372
extern ssize_t do_sync_write(struct file * , char const   * , size_t  , loff_t * ) ;
#line 2384
extern ssize_t generic_file_splice_read(struct file * , loff_t * , struct pipe_inode_info * ,
                                        size_t  , unsigned int  ) ;
#line 2399
extern loff_t generic_file_llseek(struct file * , loff_t  , int  ) ;
#line 2473
extern int vfs_readdir(struct file * , int (*)(void * , char const   * , int  , loff_t  ,
                                               u64  , unsigned int  ) , void * ) ;
#line 2524
extern ssize_t generic_read_dir(struct file * , char * , size_t  , loff_t * ) ;
#line 232 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 223 "include/linux/slub_def.h"
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 412 "include/linux/slab.h"
__inline static void *kmem_cache_zalloc(struct kmem_cache *k , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 414
  tmp = kmem_cache_alloc(k, flags | 32768U);
#line 414
  return (tmp);
}
}
#line 213 "include/linux/aio.h"
extern ssize_t wait_on_sync_kiocb(struct kiocb * ) ;
#line 15 "include/linux/fs_stack.h"
__inline static void fsstack_copy_attr_atime(struct inode *dest , struct inode  const  *src ) 
{ 


  {
#line 18
  dest->i_atime = src->i_atime;
#line 19
  return;
}
}
#line 413 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct ecryptfs_file_info *ecryptfs_file_to_private(struct file *file ) 
{ 


  {
#line 415
  return ((struct ecryptfs_file_info *)file->private_data);
}
}
#line 419 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static void ecryptfs_set_file_private(struct file *file , struct ecryptfs_file_info *file_info ) 
{ 


  {
#line 422
  file->private_data = (void *)file_info;
#line 423
  return;
}
}
#line 425 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct file *ecryptfs_file_to_lower(struct file *file ) 
{ 


  {
#line 427
  return (((struct ecryptfs_file_info *)file->private_data)->wfi_file);
}
}
#line 431 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static void ecryptfs_set_file_lower(struct file *file , struct file *lower_file ) 
{ 


  {
#line 433
  ((struct ecryptfs_file_info *)file->private_data)->wfi_file = lower_file;
#line 434
  return;
}
}
#line 455 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct ecryptfs_sb_info *ecryptfs_superblock_to_private(struct super_block *sb ) 
{ 


  {
#line 457
  return ((struct ecryptfs_sb_info *)sb->s_fs_info);
}
}
#line 522
void __ecryptfs_printk(char const   *fmt  , ...) ;
#line 524
struct file_operations  const  ecryptfs_main_fops ;
#line 525
struct file_operations  const  ecryptfs_dir_fops ;
#line 538 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_file_info_cache  ;
#line 552
int ecryptfs_initialize_file(struct dentry *ecryptfs_dentry , struct inode *ecryptfs_inode ) ;
#line 554
int ecryptfs_decode_and_decrypt_filename(char **plaintext_name , size_t *plaintext_name_size ,
                                         struct dentry *ecryptfs_dir_dentry , char const   *name ,
                                         size_t name_size ) ;
#line 581
int ecryptfs_read_metadata(struct dentry *ecryptfs_dentry ) ;
#line 672
int ecryptfs_get_lower_file(struct dentry *dentry , struct inode *inode ) ;
#line 673
void ecryptfs_put_lower_file(struct inode *inode ) ;
#line 182 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static ssize_t ecryptfs_read_update_atime(struct kiocb *iocb , struct iovec  const  *iov ,
                                          unsigned long nr_segs , loff_t pos ) 
{ 
  ssize_t rc ;
  struct path lower ;
  struct file *file ;

  {
#line 188
  file = iocb->ki_filp;
#line 190
  rc = generic_file_aio_read(iocb, iov, nr_segs, pos);
#line 195
  if (rc == -529L) {
#line 196
    rc = wait_on_sync_kiocb(iocb);
  } else {

  }
#line 197
  if (rc >= 0L) {
#line 198
    lower.dentry = ecryptfs_dentry_to_lower(file->f_path.dentry);
#line 199
    lower.mnt = ecryptfs_dentry_to_lower_mnt(file->f_path.dentry);
#line 200
    touch_atime(& lower);
  } else {

  }
#line 202
  return (rc);
}
}
#line 215 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static int ecryptfs_filldir(void *dirent , char const   *lower_name , int lower_namelen ,
                            loff_t offset , u64 ino , unsigned int d_type ) 
{ 
  struct ecryptfs_getdents_callback *buf ;
  size_t name_size ;
  char *name ;
  int rc ;

  {
#line 218
  buf = (struct ecryptfs_getdents_callback *)dirent;
#line 224
  buf->filldir_called = buf->filldir_called + 1;
#line 225
  rc = ecryptfs_decode_and_decrypt_filename(& name, & name_size, buf->dentry, lower_name,
                                            (size_t )lower_namelen);
#line 228
  if (rc != 0) {
#line 229
    printk("\v%s: Error attempting to decode and decrypt filename [%s]; rc = [%d]\n",
           "ecryptfs_filldir", lower_name, rc);
#line 232
    goto out;
  } else {

  }
#line 234
  rc = (*(buf->filldir))(buf->dirent, (char const   *)name, (int )name_size, offset,
                         ino, d_type);
#line 235
  kfree((void const   *)name);
#line 236
  if (rc >= 0) {
#line 237
    buf->entries_written = buf->entries_written + 1;
  } else {

  }
  out: ;
#line 239
  return (rc);
}
}
#line 248 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static int ecryptfs_readdir(struct file *file , void *dirent , int (*filldir)(void * ,
                                                                              char const   * ,
                                                                              int  ,
                                                                              loff_t  ,
                                                                              u64  ,
                                                                              unsigned int  ) ) 
{ 
  int rc ;
  struct file *lower_file ;
  struct inode *inode ;
  struct ecryptfs_getdents_callback buf ;

  {
#line 255
  lower_file = ecryptfs_file_to_lower(file);
#line 256
  lower_file->f_pos = file->f_pos;
#line 257
  inode = (file->f_path.dentry)->d_inode;
#line 258
  memset((void *)(& buf), 0, 32UL);
#line 259
  buf.dirent = dirent;
#line 260
  buf.dentry = file->f_path.dentry;
#line 261
  buf.filldir = filldir;
#line 262
  buf.filldir_called = 0;
#line 263
  buf.entries_written = 0;
#line 264
  rc = vfs_readdir(lower_file, & ecryptfs_filldir, (void *)(& buf));
#line 265
  file->f_pos = lower_file->f_pos;
#line 266
  if (rc < 0) {
#line 267
    goto out;
  } else {

  }
#line 268
  if (buf.filldir_called != 0 && buf.entries_written == 0) {
#line 269
    goto out;
  } else {

  }
#line 270
  if (rc >= 0) {
#line 271
    fsstack_copy_attr_atime(inode, (struct inode  const  *)(lower_file->f_path.dentry)->d_inode);
  } else {

  }
  out: ;
#line 274
  return (rc);
}
}
#line 279 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static int read_or_initialize_metadata(struct dentry *dentry ) 
{ 
  struct inode *inode ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  int rc ;
  struct ecryptfs_inode_info *tmp ;
  struct ecryptfs_sb_info *tmp___0 ;
  struct inode *tmp___1 ;
  loff_t tmp___2 ;

  {
#line 281
  inode = dentry->d_inode;
#line 286
  tmp = ecryptfs_inode_to_private(inode);
#line 286
  crypt_stat = & tmp->crypt_stat;
#line 287
  tmp___0 = ecryptfs_superblock_to_private(inode->i_sb);
#line 287
  mount_crypt_stat = & tmp___0->mount_crypt_stat;
#line 289
  ldv_mutex_lock_13(& crypt_stat->cs_mutex);
#line 291
  if ((crypt_stat->flags & 2U) != 0U && (crypt_stat->flags & 64U) != 0U) {
#line 293
    rc = 0;
#line 294
    goto out;
  } else {

  }
#line 297
  rc = ecryptfs_read_metadata(dentry);
#line 298
  if (rc == 0) {
#line 299
    goto out;
  } else {

  }
#line 301
  if ((int )mount_crypt_stat->flags & 1) {
#line 302
    crypt_stat->flags = crypt_stat->flags & 4294950907U;
#line 304
    rc = 0;
#line 305
    goto out;
  } else {

  }
#line 308
  if ((mount_crypt_stat->flags & 2U) == 0U) {
#line 308
    tmp___1 = ecryptfs_inode_to_lower(inode);
#line 308
    tmp___2 = i_size_read((struct inode  const  *)tmp___1);
#line 308
    if (tmp___2 == 0LL) {
#line 310
      rc = ecryptfs_initialize_file(dentry, inode);
#line 311
      if (rc == 0) {
#line 312
        goto out;
      } else {

      }
    } else {

    }
  } else {

  }
#line 315
  rc = -5;
  out: 
#line 317
  ldv_mutex_unlock_14(& crypt_stat->cs_mutex);
#line 318
  return (rc);
}
}
#line 330 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static int ecryptfs_open(struct inode *inode , struct file *file ) 
{ 
  int rc ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct dentry *ecryptfs_dentry ;
  struct dentry *lower_dentry ;
  struct ecryptfs_file_info *file_info ;
  struct ecryptfs_sb_info *tmp ;
  void *tmp___0 ;
  struct ecryptfs_inode_info *tmp___1 ;
  struct ecryptfs_inode_info *tmp___2 ;
  struct ecryptfs_inode_info *tmp___3 ;
  loff_t tmp___4 ;
  struct ecryptfs_file_info *tmp___5 ;

  {
#line 332
  rc = 0;
#line 333
  crypt_stat = 0;
#line 335
  ecryptfs_dentry = file->f_path.dentry;
#line 341
  tmp = ecryptfs_superblock_to_private(ecryptfs_dentry->d_sb);
#line 341
  mount_crypt_stat = & tmp->mount_crypt_stat;
#line 343
  if ((mount_crypt_stat->flags & 4U) != 0U && (((((int )file->f_flags & 1 || (file->f_flags & 2U) != 0U) || (file->f_flags & 64U) != 0U) || (file->f_flags & 512U) != 0U) || (file->f_flags & 1024U) != 0U)) {
#line 347
    printk("\fMount has encrypted view enabled; files may only be read\n");
#line 349
    rc = -1;
#line 350
    goto out;
  } else {

  }
#line 353
  tmp___0 = kmem_cache_zalloc(ecryptfs_file_info_cache, 208U);
#line 353
  file_info = (struct ecryptfs_file_info *)tmp___0;
#line 354
  ecryptfs_set_file_private(file, file_info);
#line 355
  if ((unsigned long )file_info == (unsigned long )((struct ecryptfs_file_info *)0)) {
#line 356
    __ecryptfs_printk("\v%s: Error attempting to allocate memory\n", "ecryptfs_open");
#line 358
    rc = -12;
#line 359
    goto out;
  } else {

  }
#line 361
  lower_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry);
#line 362
  tmp___1 = ecryptfs_inode_to_private(inode);
#line 362
  crypt_stat = & tmp___1->crypt_stat;
#line 363
  ldv_mutex_lock_15(& crypt_stat->cs_mutex);
#line 364
  if ((crypt_stat->flags & 2U) == 0U) {
#line 365
    __ecryptfs_printk("\017%s: Setting flags for stat...\n", "ecryptfs_open");
#line 367
    crypt_stat->flags = crypt_stat->flags | 6U;
  } else {

  }
#line 370
  ldv_mutex_unlock_16(& crypt_stat->cs_mutex);
#line 371
  rc = ecryptfs_get_lower_file(ecryptfs_dentry, inode);
#line 372
  if (rc != 0) {
#line 373
    printk("\v%s: Error attempting to initialize the lower file for the dentry with name [%s]; rc = [%d]\n",
           "ecryptfs_open", ecryptfs_dentry->d_name.name, rc);
#line 377
    goto out_free;
  } else {

  }
#line 379
  tmp___2 = ecryptfs_inode_to_private(inode);
#line 379
  if (((tmp___2->lower_file)->f_flags & 3U) == 0U && (file->f_flags & 3U) != 0U) {
#line 381
    rc = -1;
#line 382
    printk("\f%s: Lower file is RO; eCryptfs file must hence be opened RO\n", "ecryptfs_open");
#line 384
    goto out_put;
  } else {

  }
#line 386
  tmp___3 = ecryptfs_inode_to_private(inode);
#line 386
  ecryptfs_set_file_lower(file, tmp___3->lower_file);
#line 388
  if (((int )(ecryptfs_dentry->d_inode)->i_mode & 61440) == 16384) {
#line 389
    __ecryptfs_printk("\017%s: This is a directory\n", "ecryptfs_open");
#line 390
    ldv_mutex_lock_17(& crypt_stat->cs_mutex);
#line 391
    crypt_stat->flags = crypt_stat->flags & 4294967291U;
#line 392
    ldv_mutex_unlock_18(& crypt_stat->cs_mutex);
#line 393
    rc = 0;
#line 394
    goto out;
  } else {

  }
#line 396
  rc = read_or_initialize_metadata(ecryptfs_dentry);
#line 397
  if (rc != 0) {
#line 398
    goto out_put;
  } else {

  }
#line 399
  tmp___4 = i_size_read((struct inode  const  *)inode);
#line 399
  __ecryptfs_printk("\017%s: inode w/ addr = [0x%p], i_ino = [0x%.16lx] size: [0x%.16llx]\n",
                    "ecryptfs_open", inode, inode->i_ino, (unsigned long long )tmp___4);
#line 402
  goto out;
  out_put: 
#line 404
  ecryptfs_put_lower_file(inode);
  out_free: 
#line 406
  tmp___5 = ecryptfs_file_to_private(file);
#line 406
  kmem_cache_free(ecryptfs_file_info_cache, (void *)tmp___5);
  out: ;
#line 409
  return (rc);
}
}
#line 412 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static int ecryptfs_flush(struct file *file , fl_owner_t td ) 
{ 
  struct file *lower_file ;
  struct file *tmp ;
  int tmp___0 ;

  {
#line 414
  tmp = ecryptfs_file_to_lower(file);
#line 414
  lower_file = tmp;
#line 416
  if ((unsigned long )lower_file->f_op != (unsigned long )((struct file_operations  const  *)0) && (unsigned long )(lower_file->f_op)->flush != (unsigned long )((int (*/* const  */)(struct file * ,
                                                                                                                                                                                      fl_owner_t  ))0)) {
#line 417
    filemap_write_and_wait(file->f_mapping);
#line 418
    tmp___0 = (*((lower_file->f_op)->flush))(lower_file, td);
#line 418
    return (tmp___0);
  } else {

  }
#line 421
  return (0);
}
}
#line 424 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static int ecryptfs_release(struct inode *inode , struct file *file ) 
{ 
  struct ecryptfs_file_info *tmp ;

  {
#line 426
  ecryptfs_put_lower_file(inode);
#line 427
  tmp = ecryptfs_file_to_private(file);
#line 427
  kmem_cache_free(ecryptfs_file_info_cache, (void *)tmp);
#line 429
  return (0);
}
}
#line 433 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static int ecryptfs_fsync(struct file *file , loff_t start , loff_t end , int datasync ) 
{ 
  struct file *tmp ;
  int tmp___0 ;

  {
#line 435
  tmp = ecryptfs_file_to_lower(file);
#line 435
  tmp___0 = vfs_fsync(tmp, datasync);
#line 435
  return (tmp___0);
}
}
#line 438 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static int ecryptfs_fasync(int fd , struct file *file , int flag ) 
{ 
  int rc ;
  struct file *lower_file ;

  {
#line 440
  rc = 0;
#line 441
  lower_file = 0;
#line 443
  lower_file = ecryptfs_file_to_lower(file);
#line 444
  if ((unsigned long )lower_file->f_op != (unsigned long )((struct file_operations  const  *)0) && (unsigned long )(lower_file->f_op)->fasync != (unsigned long )((int (*/* const  */)(int  ,
                                                                                                                                                                                       struct file * ,
                                                                                                                                                                                       int  ))0)) {
#line 445
    rc = (*((lower_file->f_op)->fasync))(fd, lower_file, flag);
  } else {

  }
#line 446
  return (rc);
}
}
#line 450 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static long ecryptfs_unlocked_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) 
{ 
  struct file *lower_file ;
  long rc ;
  struct ecryptfs_file_info *tmp ;

  {
#line 452
  lower_file = 0;
#line 453
  rc = -25L;
#line 455
  tmp = ecryptfs_file_to_private(file);
#line 455
  if ((unsigned long )tmp != (unsigned long )((struct ecryptfs_file_info *)0)) {
#line 456
    lower_file = ecryptfs_file_to_lower(file);
  } else {

  }
#line 457
  if (((unsigned long )lower_file != (unsigned long )((struct file *)0) && (unsigned long )lower_file->f_op != (unsigned long )((struct file_operations  const  *)0)) && (unsigned long )(lower_file->f_op)->unlocked_ioctl != (unsigned long )((long (*/* const  */)(struct file * ,
                                                                                                                                                                                                                                                                      unsigned int  ,
                                                                                                                                                                                                                                                                      unsigned long  ))0)) {
#line 458
    rc = (*((lower_file->f_op)->unlocked_ioctl))(lower_file, cmd, arg);
  } else {

  }
#line 459
  return (rc);
}
}
#line 464 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
static long ecryptfs_compat_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) 
{ 
  struct file *lower_file ;
  long rc ;
  struct ecryptfs_file_info *tmp ;

  {
#line 466
  lower_file = 0;
#line 467
  rc = -515L;
#line 469
  tmp = ecryptfs_file_to_private(file);
#line 469
  if ((unsigned long )tmp != (unsigned long )((struct ecryptfs_file_info *)0)) {
#line 470
    lower_file = ecryptfs_file_to_lower(file);
  } else {

  }
#line 471
  if (((unsigned long )lower_file != (unsigned long )((struct file *)0) && (unsigned long )lower_file->f_op != (unsigned long )((struct file_operations  const  *)0)) && (unsigned long )(lower_file->f_op)->compat_ioctl != (unsigned long )((long (*/* const  */)(struct file * ,
                                                                                                                                                                                                                                                                    unsigned int  ,
                                                                                                                                                                                                                                                                    unsigned long  ))0)) {
#line 472
    rc = (*((lower_file->f_op)->compat_ioctl))(lower_file, cmd, arg);
  } else {

  }
#line 473
  return (rc);
}
}
#line 477 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
struct file_operations  const  ecryptfs_dir_fops  = 
#line 477
     {0, & default_llseek, & generic_read_dir, 0, 0, 0, & ecryptfs_readdir, 0, & ecryptfs_unlocked_ioctl,
    & ecryptfs_compat_ioctl, 0, & ecryptfs_open, & ecryptfs_flush, & ecryptfs_release,
    & ecryptfs_fsync, 0, & ecryptfs_fasync, 0, 0, 0, 0, 0, 0, & generic_file_splice_read,
    0, 0, 0};
#line 493 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
struct file_operations  const  ecryptfs_main_fops  = 
#line 493
     {0, & generic_file_llseek, & do_sync_read, & do_sync_write, & ecryptfs_read_update_atime,
    & generic_file_aio_write, & ecryptfs_readdir, 0, & ecryptfs_unlocked_ioctl, & ecryptfs_compat_ioctl,
    & generic_file_mmap, & ecryptfs_open, & ecryptfs_flush, & ecryptfs_release, & ecryptfs_fsync,
    0, & ecryptfs_fasync, 0, 0, 0, 0, 0, 0, & generic_file_splice_read, 0, 0, 0};
#line 532
extern void ldv_check_return_value(int  ) ;
#line 550 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void main(void) 
{ 
  struct file *var_group1 ;
  void *var_ecryptfs_readdir_2_p1 ;
  int (*var_ecryptfs_readdir_2_p2)(void * , char const   * , int  , loff_t  , u64  ,
                                   unsigned int  ) ;
  unsigned int var_ecryptfs_unlocked_ioctl_9_p1 ;
  unsigned long var_ecryptfs_unlocked_ioctl_9_p2 ;
  unsigned int var_ecryptfs_compat_ioctl_10_p1 ;
  unsigned long var_ecryptfs_compat_ioctl_10_p2 ;
  struct inode *var_group2 ;
  int res_ecryptfs_open_4 ;
  fl_owner_t var_ecryptfs_flush_5_p1 ;
  loff_t var_ecryptfs_fsync_7_p1 ;
  loff_t var_ecryptfs_fsync_7_p2 ;
  int var_ecryptfs_fsync_7_p3 ;
  int var_ecryptfs_fasync_8_p0 ;
  int var_ecryptfs_fasync_8_p2 ;
  struct kiocb *var_group3 ;
  struct iovec  const  *var_ecryptfs_read_update_atime_0_p1 ;
  unsigned long var_ecryptfs_read_update_atime_0_p2 ;
  loff_t var_ecryptfs_read_update_atime_0_p3 ;
  int ldv_s_ecryptfs_dir_fops_file_operations ;
  int ldv_s_ecryptfs_main_fops_file_operations ;
  int tmp ;
  int tmp___0 ;

  {
#line 788
  ldv_s_ecryptfs_dir_fops_file_operations = 0;
#line 791
  ldv_s_ecryptfs_main_fops_file_operations = 0;
#line 778
  LDV_IN_INTERRUPT = 1;
#line 787
  ldv_initialize();
#line 795
  goto ldv_29222;
  ldv_29221: 
#line 800
  tmp = __VERIFIER_nondet_int();
#line 800
  switch (tmp) {
  case 0: ;
#line 805
  if (ldv_s_ecryptfs_dir_fops_file_operations == 0) {
#line 810
    ldv_handler_precall();
#line 811
    res_ecryptfs_open_4 = ecryptfs_open(var_group2, var_group1);
#line 812
    ldv_check_return_value(res_ecryptfs_open_4);
#line 813
    if (res_ecryptfs_open_4 != 0) {
#line 814
      goto ldv_module_exit;
    } else {

    }
#line 823
    ldv_s_ecryptfs_dir_fops_file_operations = ldv_s_ecryptfs_dir_fops_file_operations + 1;
  } else {

  }
#line 829
  goto ldv_29203;
  case 1: ;
#line 833
  if (ldv_s_ecryptfs_dir_fops_file_operations == 1) {
#line 838
    ldv_handler_precall();
#line 839
    ecryptfs_release(var_group2, var_group1);
#line 848
    ldv_s_ecryptfs_dir_fops_file_operations = 0;
  } else {

  }
#line 854
  goto ldv_29203;
  case 2: 
#line 863
  ldv_handler_precall();
#line 864
  ecryptfs_readdir(var_group1, var_ecryptfs_readdir_2_p1, var_ecryptfs_readdir_2_p2);
#line 879
  goto ldv_29203;
  case 3: 
#line 888
  ldv_handler_precall();
#line 889
  ecryptfs_unlocked_ioctl(var_group1, var_ecryptfs_unlocked_ioctl_9_p1, var_ecryptfs_unlocked_ioctl_9_p2);
#line 904
  goto ldv_29203;
  case 4: 
#line 915
  ldv_handler_precall();
#line 916
  ecryptfs_compat_ioctl(var_group1, var_ecryptfs_compat_ioctl_10_p1, var_ecryptfs_compat_ioctl_10_p2);
#line 930
  goto ldv_29203;
  case 5: 
#line 939
  ldv_handler_precall();
#line 940
  ecryptfs_flush(var_group1, var_ecryptfs_flush_5_p1);
#line 955
  goto ldv_29203;
  case 6: 
#line 964
  ldv_handler_precall();
#line 965
  ecryptfs_fsync(var_group1, var_ecryptfs_fsync_7_p1, var_ecryptfs_fsync_7_p2, var_ecryptfs_fsync_7_p3);
#line 980
  goto ldv_29203;
  case 7: 
#line 989
  ldv_handler_precall();
#line 990
  ecryptfs_fasync(var_ecryptfs_fasync_8_p0, var_group1, var_ecryptfs_fasync_8_p2);
#line 1005
  goto ldv_29203;
  case 8: ;
#line 1009
  if (ldv_s_ecryptfs_main_fops_file_operations == 0) {
#line 1014
    ldv_handler_precall();
#line 1015
    res_ecryptfs_open_4 = ecryptfs_open(var_group2, var_group1);
#line 1016
    ldv_check_return_value(res_ecryptfs_open_4);
#line 1017
    if (res_ecryptfs_open_4 != 0) {
#line 1018
      goto ldv_module_exit;
    } else {

    }
#line 1027
    ldv_s_ecryptfs_main_fops_file_operations = ldv_s_ecryptfs_main_fops_file_operations + 1;
  } else {

  }
#line 1033
  goto ldv_29203;
  case 9: ;
#line 1037
  if (ldv_s_ecryptfs_main_fops_file_operations == 1) {
#line 1042
    ldv_handler_precall();
#line 1043
    ecryptfs_release(var_group2, var_group1);
#line 1052
    ldv_s_ecryptfs_main_fops_file_operations = 0;
  } else {

  }
#line 1058
  goto ldv_29203;
  case 10: 
#line 1067
  ldv_handler_precall();
#line 1068
  ecryptfs_read_update_atime(var_group3, var_ecryptfs_read_update_atime_0_p1, var_ecryptfs_read_update_atime_0_p2,
                             var_ecryptfs_read_update_atime_0_p3);
#line 1083
  goto ldv_29203;
  case 11: 
#line 1092
  ldv_handler_precall();
#line 1093
  ecryptfs_readdir(var_group1, var_ecryptfs_readdir_2_p1, var_ecryptfs_readdir_2_p2);
#line 1108
  goto ldv_29203;
  case 12: 
#line 1117
  ldv_handler_precall();
#line 1118
  ecryptfs_unlocked_ioctl(var_group1, var_ecryptfs_unlocked_ioctl_9_p1, var_ecryptfs_unlocked_ioctl_9_p2);
#line 1133
  goto ldv_29203;
  case 13: 
#line 1144
  ldv_handler_precall();
#line 1145
  ecryptfs_compat_ioctl(var_group1, var_ecryptfs_compat_ioctl_10_p1, var_ecryptfs_compat_ioctl_10_p2);
#line 1159
  goto ldv_29203;
  case 14: 
#line 1168
  ldv_handler_precall();
#line 1169
  ecryptfs_flush(var_group1, var_ecryptfs_flush_5_p1);
#line 1184
  goto ldv_29203;
  case 15: 
#line 1193
  ldv_handler_precall();
#line 1194
  ecryptfs_fsync(var_group1, var_ecryptfs_fsync_7_p1, var_ecryptfs_fsync_7_p2, var_ecryptfs_fsync_7_p3);
#line 1209
  goto ldv_29203;
  case 16: 
#line 1218
  ldv_handler_precall();
#line 1219
  ecryptfs_fasync(var_ecryptfs_fasync_8_p0, var_group1, var_ecryptfs_fasync_8_p2);
#line 1234
  goto ldv_29203;
  default: ;
#line 1235
  goto ldv_29203;
  }
  ldv_29203: ;
  ldv_29222: 
#line 795
  tmp___0 = __VERIFIER_nondet_int();
#line 795
  if ((tmp___0 != 0 || ldv_s_ecryptfs_dir_fops_file_operations != 0) || ldv_s_ecryptfs_main_fops_file_operations != 0) {
#line 798
    goto ldv_29221;
  } else {

  }

  ldv_module_exit: ;
#line 1244
  ldv_check_final_state();
#line 1247
  return;
}
}
#line 1251 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_lock_9(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1256
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1258
  mutex_lock(ldv_func_arg1);
#line 1259
  return;
}
}
#line 1261 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1266
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1268
  mutex_unlock(ldv_func_arg1);
#line 1269
  return;
}
}
#line 1271 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1276
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1278
  mutex_lock(ldv_func_arg1);
#line 1279
  return;
}
}
#line 1281 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1286
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1288
  mutex_unlock(ldv_func_arg1);
#line 1289
  return;
}
}
#line 1291 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1296
  ldv_mutex_lock_cs_mutex(ldv_func_arg1);
#line 1298
  mutex_lock(ldv_func_arg1);
#line 1299
  return;
}
}
#line 1301 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1306
  ldv_mutex_unlock_cs_mutex(ldv_func_arg1);
#line 1308
  mutex_unlock(ldv_func_arg1);
#line 1309
  return;
}
}
#line 1311 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_lock_15(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1316
  ldv_mutex_lock_cs_mutex(ldv_func_arg1);
#line 1318
  mutex_lock(ldv_func_arg1);
#line 1319
  return;
}
}
#line 1321 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1326
  ldv_mutex_unlock_cs_mutex(ldv_func_arg1);
#line 1328
  mutex_unlock(ldv_func_arg1);
#line 1329
  return;
}
}
#line 1331 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1336
  ldv_mutex_lock_cs_mutex(ldv_func_arg1);
#line 1338
  mutex_lock(ldv_func_arg1);
#line 1339
  return;
}
}
#line 1341 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/file.c.prepared"
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1346
  ldv_mutex_unlock_cs_mutex(ldv_func_arg1);
#line 1348
  mutex_unlock(ldv_func_arg1);
#line 1349
  return;
}
}
#line 1 "<compiler builtins>"
void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;
#line 1
long __builtin_expect(long exp , long c ) ;
#line 88 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 34 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 61
extern size_t strlen(char const   * ) ;
#line 22 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 


  {
#line 24
  return ((void *)error);
}
}
#line 27 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 


  {
#line 29
  return ((long )ptr);
}
}
#line 32 "include/linux/err.h"
__inline static long IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 34
  tmp = __builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
#line 34
  return (tmp);
}
}
#line 49 "include/linux/err.h"
__inline static void *ERR_CAST(void const   *ptr ) 
{ 


  {
#line 52
  return ((void *)ptr);
}
}
#line 134 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 137
void ldv_mutex_lock_nested_33(struct mutex *ldv_func_arg1 , unsigned int ldv_func_arg2 ) ;
#line 172
void ldv_mutex_unlock_30(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_32(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_36(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_38(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_40(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_42(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_44(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_46(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_48(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_52(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_29(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_31(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_35(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_37(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_41(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_45(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_47(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) ;
#line 107
void ldv_mutex_lock_i_mutex(struct mutex *lock ) ;
#line 111
void ldv_mutex_unlock_i_mutex(struct mutex *lock ) ;
#line 206 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/thread_info.h"
extern unsigned long kernel_stack ;
#line 208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ 
  struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
#line 211
  switch (8UL) {
  case 1UL: 
#line 211
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6520;
  case 2UL: 
#line 211
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6520;
  case 4UL: 
#line 211
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6520;
  case 8UL: 
#line 211
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6520;
  default: 
#line 211
  __bad_percpu_size();
  }
  ldv_6520: 
#line 211
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
#line 213
  return (ti);
}
}
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 283 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 285
  _raw_spin_lock(& lock->ldv_5961.rlock);
#line 286
  return;
}
}
#line 323 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 325
  _raw_spin_unlock(& lock->ldv_5961.rlock);
#line 326
  return;
}
}
#line 1009 "include/linux/mm.h"
extern void truncate_setsize(struct inode * , loff_t  ) ;
#line 220 "include/linux/dcache.h"
extern void d_instantiate(struct dentry * , struct inode * ) ;
#line 224
extern void d_drop(struct dentry * ) ;
#line 255
extern void d_rehash(struct dentry * ) ;
#line 266 "include/linux/dcache.h"
__inline static void d_add(struct dentry *entry , struct inode *inode ) 
{ 


  {
#line 268
  d_instantiate(entry, inode);
#line 269
  d_rehash(entry);
#line 270
  return;
}
}
#line 350 "include/linux/dcache.h"
__inline static struct dentry *dget_dlock(struct dentry *dentry ) 
{ 


  {
#line 352
  if ((unsigned long )dentry != (unsigned long )((struct dentry *)0)) {
#line 353
    dentry->d_count = dentry->d_count + 1U;
  } else {

  }
#line 354
  return (dentry);
}
}
#line 357 "include/linux/dcache.h"
__inline static struct dentry *dget(struct dentry *dentry ) 
{ 


  {
#line 359
  if ((unsigned long )dentry != (unsigned long )((struct dentry *)0)) {
#line 360
    spin_lock(& dentry->d_lock);
#line 361
    dget_dlock(dentry);
#line 362
    spin_unlock(& dentry->d_lock);
  } else {

  }
#line 364
  return (dentry);
}
}
#line 367
extern struct dentry *dget_parent(struct dentry * ) ;
#line 675 "include/linux/fs.h"
__inline static void i_size_write(struct inode *inode , loff_t i_size ) 
{ 


  {
#line 686
  inode->i_size = i_size;
#line 687
  return;
}
}
#line 1451
extern int vfs_create(struct inode * , struct dentry * , umode_t  , bool  ) ;
#line 1452
extern int vfs_mkdir(struct inode * , struct dentry * , umode_t  ) ;
#line 1453
extern int vfs_mknod(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
#line 1454
extern int vfs_symlink(struct inode * , struct dentry * , char const   * ) ;
#line 1455
extern int vfs_link(struct dentry * , struct inode * , struct dentry * ) ;
#line 1456
extern int vfs_rmdir(struct inode * , struct dentry * ) ;
#line 1457
extern int vfs_unlink(struct inode * , struct dentry * ) ;
#line 1458
extern int vfs_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
#line 1755
extern void clear_nlink(struct inode * ) ;
#line 1756
extern void set_nlink(struct inode * , unsigned int  ) ;
#line 2148
extern void init_special_inode(struct inode * , umode_t  , dev_t  ) ;
#line 2151
extern void make_bad_inode(struct inode * ) ;
#line 2211
extern int notify_change(struct dentry * , struct iattr * ) ;
#line 2212
extern int inode_permission(struct inode * , int  ) ;
#line 2295
extern void iput(struct inode * ) ;
#line 2296
extern struct inode *igrab(struct inode * ) ;
#line 2312
extern struct inode *iget5_locked(struct super_block * , unsigned long  , int (*)(struct inode * ,
                                                                                  void * ) ,
                                  int (*)(struct inode * , void * ) , void * ) ;
#line 2321
extern void unlock_new_inode(struct inode * ) ;
#line 2464
extern int generic_readlink(struct dentry * , char * , int  ) ;
#line 2465
extern void generic_fillattr(struct inode * , struct kstat * ) ;
#line 2466
extern int vfs_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
#line 2550
extern int inode_change_ok(struct inode  const  * , struct iattr * ) ;
#line 2551
extern int inode_newsize_ok(struct inode  const  * , loff_t  ) ;
#line 75 "include/linux/namei.h"
extern struct dentry *lookup_one_len(char const   * , struct dentry * , int  ) ;
#line 81
extern struct dentry *lock_rename(struct dentry * , struct dentry * ) ;
#line 82
extern void unlock_rename(struct dentry * , struct dentry * ) ;
#line 86 "include/linux/namei.h"
__inline static void nd_set_link(struct nameidata *nd , char *path ) 
{ 


  {
#line 88
  nd->saved_names[nd->depth] = path;
#line 89
  return;
}
}
#line 91 "include/linux/namei.h"
__inline static char *nd_get_link(struct nameidata *nd ) 
{ 


  {
#line 93
  return (nd->saved_names[nd->depth]);
}
}
#line 64 "include/linux/mount.h"
extern struct vfsmount *mntget(struct vfsmount * ) ;
#line 224 "include/linux/slub_def.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 274 "include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 289
  tmp___2 = __kmalloc(size, flags);
#line 289
  return (tmp___2);
}
}
#line 422 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 424
  tmp = kmalloc(size, flags | 32768U);
#line 424
  return (tmp);
}
}
#line 12 "include/linux/fs_stack.h"
extern void fsstack_copy_inode_size(struct inode * , struct inode * ) ;
#line 21 "include/linux/fs_stack.h"
__inline static void fsstack_copy_attr_times(struct inode *dest , struct inode  const  *src ) 
{ 


  {
#line 24
  dest->i_atime = src->i_atime;
#line 25
  dest->i_mtime = src->i_mtime;
#line 26
  dest->i_ctime = src->i_ctime;
#line 27
  return;
}
}
#line 43 "include/linux/xattr.h"
extern int vfs_setxattr(struct dentry * , char const   * , void const   * , size_t  ,
                        int  ) ;
#line 405 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static size_t ecryptfs_lower_header_size(struct ecryptfs_crypt_stat *crypt_stat ) 
{ 


  {
#line 407
  if ((crypt_stat->flags & 128U) != 0U) {
#line 408
    return (0UL);
  } else {

  }
#line 409
  return (crypt_stat->metadata_size);
}
}
#line 449 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static void ecryptfs_set_inode_lower(struct inode *inode , struct inode *lower_inode ) 
{ 
  struct ecryptfs_inode_info *tmp ;

  {
#line 451
  tmp = ecryptfs_inode_to_private(inode);
#line 451
  tmp->wii_inode = lower_inode;
#line 452
  return;
}
}
#line 468 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct super_block *ecryptfs_superblock_to_lower(struct super_block *sb ) 
{ 


  {
#line 470
  return (((struct ecryptfs_sb_info *)sb->s_fs_info)->wsi_sb);
}
}
#line 487 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static void ecryptfs_set_dentry_private(struct dentry *dentry , struct ecryptfs_dentry_info *dentry_info ) 
{ 


  {
#line 490
  dentry->d_fsdata = (void *)dentry_info;
#line 491
  return;
}
}
#line 500 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static void ecryptfs_set_dentry_lower(struct dentry *dentry , struct dentry *lower_dentry ) 
{ 


  {
#line 502
  ((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path.dentry = lower_dentry;
#line 503
  return;
}
}
#line 513 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static void ecryptfs_set_dentry_lower_mnt(struct dentry *dentry , struct vfsmount *lower_mnt ) 
{ 


  {
#line 515
  ((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path.mnt = lower_mnt;
#line 516
  return;
}
}
#line 526
struct inode_operations  const  ecryptfs_main_iops ;
#line 527
struct inode_operations  const  ecryptfs_dir_iops ;
#line 528
struct inode_operations  const  ecryptfs_symlink_iops ;
#line 531
struct address_space_operations  const  ecryptfs_aops ;
#line 549
struct inode *ecryptfs_get_inode(struct inode *lower_inode , struct super_block *sb ) ;
#line 559
int ecryptfs_encrypt_and_encode_filename(char **encoded_name , size_t *encoded_name_size ,
                                         struct ecryptfs_crypt_stat *crypt_stat ,
                                         struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                         char const   *name , size_t name_size ) ;
#line 571
void ecryptfs_init_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat ) ;
#line 576
int ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode ) ;
#line 579
int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry , struct inode *ecryptfs_inode ) ;
#line 582
int ecryptfs_new_file_context(struct inode *ecryptfs_inode ) ;
#line 586
int ecryptfs_read_and_validate_header_region(struct inode *inode ) ;
#line 587
int ecryptfs_read_and_validate_xattr_region(struct dentry *dentry , struct inode *inode ) ;
#line 591
void ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat ) ;
#line 599
int ecryptfs_truncate(struct dentry *dentry , loff_t new_length ) ;
#line 601
ssize_t ecryptfs_getxattr_lower(struct dentry *lower_dentry , char const   *name ,
                                void *value , size_t size ) ;
#line 604
int ecryptfs_setxattr(struct dentry *dentry , char const   *name , void const   *value ,
                      size_t size , int flags ) ;
#line 644
int ecryptfs_write(struct inode *ecryptfs_inode , char *data , loff_t offset , size_t size ) ;
#line 175 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static struct dentry *lock_parent(struct dentry *dentry ) 
{ 
  struct dentry *dir ;

  {
#line 179
  dir = dget_parent(dentry);
#line 180
  ldv_mutex_lock_nested_33(& (dir->d_inode)->i_mutex, 1U);
#line 181
  return (dir);
}
}
#line 184 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static void unlock_dir(struct dentry *dir ) 
{ 


  {
#line 186
  ldv_mutex_unlock_34(& (dir->d_inode)->i_mutex);
#line 187
  dput(dir);
#line 188
  return;
}
}
#line 190 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_inode_test(struct inode *inode , void *lower_inode ) 
{ 
  struct inode *tmp ;

  {
#line 192
  tmp = ecryptfs_inode_to_lower(inode);
#line 192
  if ((unsigned long )tmp == (unsigned long )((struct inode *)lower_inode)) {
#line 193
    return (1);
  } else {

  }
#line 194
  return (0);
}
}
#line 197 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_inode_set(struct inode *inode , void *opaque ) 
{ 
  struct inode *lower_inode ;

  {
#line 199
  lower_inode = (struct inode *)opaque;
#line 201
  ecryptfs_set_inode_lower(inode, lower_inode);
#line 202
  fsstack_copy_attr_all(inode, (struct inode  const  *)lower_inode);
#line 204
  fsstack_copy_inode_size(inode, lower_inode);
#line 205
  inode->i_ino = lower_inode->i_ino;
#line 206
  inode->i_version = inode->i_version + 1ULL;
#line 207
  (inode->i_mapping)->a_ops = & ecryptfs_aops;
#line 208
  (inode->i_mapping)->backing_dev_info = (inode->i_sb)->s_bdi;
#line 210
  if (((int )inode->i_mode & 61440) == 40960) {
#line 211
    inode->i_op = & ecryptfs_symlink_iops;
  } else
#line 212
  if (((int )inode->i_mode & 61440) == 16384) {
#line 213
    inode->i_op = & ecryptfs_dir_iops;
  } else {
#line 215
    inode->i_op = & ecryptfs_main_iops;
  }
#line 217
  if (((int )inode->i_mode & 61440) == 16384) {
#line 218
    inode->i_fop = & ecryptfs_dir_fops;
  } else
#line 219
  if (((((int )inode->i_mode & 61440) == 8192 || ((int )inode->i_mode & 61440) == 24576) || ((int )inode->i_mode & 61440) == 4096) || ((int )inode->i_mode & 61440) == 49152) {
#line 220
    init_special_inode(inode, (int )inode->i_mode, inode->i_rdev);
  } else {
#line 222
    inode->i_fop = & ecryptfs_main_fops;
  }
#line 224
  return (0);
}
}
#line 227 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static struct inode *__ecryptfs_get_inode(struct inode *lower_inode , struct super_block *sb ) 
{ 
  struct inode *inode ;
  void *tmp ;
  struct super_block *tmp___0 ;
  void *tmp___1 ;
  struct inode *tmp___2 ;
  void *tmp___3 ;

  {
#line 232
  tmp___0 = ecryptfs_superblock_to_lower(sb);
#line 232
  if ((unsigned long )lower_inode->i_sb != (unsigned long )tmp___0) {
#line 233
    tmp = ERR_PTR(-18L);
#line 233
    return ((struct inode *)tmp);
  } else {

  }
#line 234
  tmp___2 = igrab(lower_inode);
#line 234
  if ((unsigned long )tmp___2 == (unsigned long )((struct inode *)0)) {
#line 235
    tmp___1 = ERR_PTR(-116L);
#line 235
    return ((struct inode *)tmp___1);
  } else {

  }
#line 236
  inode = iget5_locked(sb, (unsigned long )lower_inode, & ecryptfs_inode_test, & ecryptfs_inode_set,
                       (void *)lower_inode);
#line 239
  if ((unsigned long )inode == (unsigned long )((struct inode *)0)) {
#line 240
    iput(lower_inode);
#line 241
    tmp___3 = ERR_PTR(-13L);
#line 241
    return ((struct inode *)tmp___3);
  } else {

  }
#line 243
  if ((inode->i_state & 8UL) == 0UL) {
#line 244
    iput(lower_inode);
  } else {

  }
#line 246
  return (inode);
}
}
#line 249 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
struct inode *ecryptfs_get_inode(struct inode *lower_inode , struct super_block *sb ) 
{ 
  struct inode *inode ;
  struct inode *tmp ;
  long tmp___0 ;

  {
#line 252
  tmp = __ecryptfs_get_inode(lower_inode, sb);
#line 252
  inode = tmp;
#line 254
  tmp___0 = IS_ERR((void const   *)inode);
#line 254
  if (tmp___0 == 0L && (inode->i_state & 8UL) != 0UL) {
#line 255
    unlock_new_inode(inode);
  } else {

  }
#line 257
  return (inode);
}
}
#line 270 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_interpose(struct dentry *lower_dentry , struct dentry *dentry ,
                              struct super_block *sb ) 
{ 
  struct inode *inode ;
  struct inode *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 273
  tmp = ecryptfs_get_inode(lower_dentry->d_inode, sb);
#line 273
  inode = tmp;
#line 275
  tmp___1 = IS_ERR((void const   *)inode);
#line 275
  if (tmp___1 != 0L) {
#line 276
    tmp___0 = PTR_ERR((void const   *)inode);
#line 276
    return ((int )tmp___0);
  } else {

  }
#line 277
  d_instantiate(dentry, inode);
#line 279
  return (0);
}
}
#line 282 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_do_unlink(struct inode *dir , struct dentry *dentry , struct inode *inode ) 
{ 
  struct dentry *lower_dentry ;
  struct dentry *tmp ;
  struct inode *lower_dir_inode ;
  struct inode *tmp___0 ;
  struct dentry *lower_dir_dentry ;
  int rc ;
  struct inode *tmp___1 ;

  {
#line 285
  tmp = ecryptfs_dentry_to_lower(dentry);
#line 285
  lower_dentry = tmp;
#line 286
  tmp___0 = ecryptfs_inode_to_lower(dir);
#line 286
  lower_dir_inode = tmp___0;
#line 290
  dget(lower_dentry);
#line 291
  lower_dir_dentry = lock_parent(lower_dentry);
#line 292
  rc = vfs_unlink(lower_dir_inode, lower_dentry);
#line 293
  if (rc != 0) {
#line 294
    printk("\vError in vfs_unlink; rc = [%d]\n", rc);
#line 295
    goto out_unlock;
  } else {

  }
#line 297
  fsstack_copy_attr_times(dir, (struct inode  const  *)lower_dir_inode);
#line 298
  tmp___1 = ecryptfs_inode_to_lower(inode);
#line 298
  set_nlink(inode, tmp___1->ldv_13340.i_nlink);
#line 299
  inode->i_ctime = dir->i_ctime;
#line 300
  d_drop(dentry);
  out_unlock: 
#line 302
  unlock_dir(lower_dir_dentry);
#line 303
  dput(lower_dentry);
#line 304
  return (rc);
}
}
#line 321 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static struct inode *ecryptfs_do_create(struct inode *directory_inode , struct dentry *ecryptfs_dentry ,
                                        umode_t mode ) 
{ 
  int rc ;
  struct dentry *lower_dentry ;
  struct dentry *lower_dir_dentry ;
  struct inode *inode ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;

  {
#line 329
  lower_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry);
#line 330
  lower_dir_dentry = lock_parent(lower_dentry);
#line 331
  tmp___0 = IS_ERR((void const   *)lower_dir_dentry);
#line 331
  if (tmp___0 != 0L) {
#line 332
    __ecryptfs_printk("\v%s: Error locking directory of dentry\n", "ecryptfs_do_create");
#line 334
    tmp = ERR_CAST((void const   *)lower_dir_dentry);
#line 334
    inode = (struct inode *)tmp;
#line 335
    goto out;
  } else {

  }
#line 337
  rc = vfs_create(lower_dir_dentry->d_inode, lower_dentry, (int )mode, 1);
#line 338
  if (rc != 0) {
#line 339
    printk("\v%s: Failure to create dentry in lower fs; rc = [%d]\n", "ecryptfs_do_create",
           rc);
#line 341
    tmp___1 = ERR_PTR((long )rc);
#line 341
    inode = (struct inode *)tmp___1;
#line 342
    goto out_lock;
  } else {

  }
#line 344
  inode = __ecryptfs_get_inode(lower_dentry->d_inode, directory_inode->i_sb);
#line 346
  tmp___2 = IS_ERR((void const   *)inode);
#line 346
  if (tmp___2 != 0L) {
#line 347
    vfs_unlink(lower_dir_dentry->d_inode, lower_dentry);
#line 348
    goto out_lock;
  } else {

  }
#line 350
  fsstack_copy_attr_times(directory_inode, (struct inode  const  *)lower_dir_dentry->d_inode);
#line 351
  fsstack_copy_inode_size(directory_inode, lower_dir_dentry->d_inode);
  out_lock: 
#line 353
  unlock_dir(lower_dir_dentry);
  out: ;
#line 355
  return (inode);
}
}
#line 366 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
int ecryptfs_initialize_file(struct dentry *ecryptfs_dentry , struct inode *ecryptfs_inode ) 
{ 
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_inode_info *tmp ;
  int rc ;

  {
#line 369
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 369
  crypt_stat = & tmp->crypt_stat;
#line 371
  rc = 0;
#line 373
  if (((int )ecryptfs_inode->i_mode & 61440) == 16384) {
#line 374
    __ecryptfs_printk("\017%s: This is a directory\n", "ecryptfs_initialize_file");
#line 375
    crypt_stat->flags = crypt_stat->flags & 4294967291U;
#line 376
    goto out;
  } else {

  }
#line 378
  __ecryptfs_printk("\017%s: Initializing crypto context\n", "ecryptfs_initialize_file");
#line 379
  rc = ecryptfs_new_file_context(ecryptfs_inode);
#line 380
  if (rc != 0) {
#line 381
    __ecryptfs_printk("\v%s: Error creating new file context; rc = [%d]\n", "ecryptfs_initialize_file",
                      rc);
#line 383
    goto out;
  } else {

  }
#line 385
  rc = ecryptfs_get_lower_file(ecryptfs_dentry, ecryptfs_inode);
#line 386
  if (rc != 0) {
#line 387
    printk("\v%s: Error attempting to initialize the lower file for the dentry with name [%s]; rc = [%d]\n",
           "ecryptfs_initialize_file", ecryptfs_dentry->d_name.name, rc);
#line 391
    goto out;
  } else {

  }
#line 393
  rc = ecryptfs_write_metadata(ecryptfs_dentry, ecryptfs_inode);
#line 394
  if (rc != 0) {
#line 395
    printk("\vError writing headers; rc = [%d]\n", rc);
  } else {

  }
#line 396
  ecryptfs_put_lower_file(ecryptfs_inode);
  out: ;
#line 398
  return (rc);
}
}
#line 412 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_create(struct inode *directory_inode , struct dentry *ecryptfs_dentry ,
                           umode_t mode , bool excl ) 
{ 
  struct inode *ecryptfs_inode ;
  int rc ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 418
  ecryptfs_inode = ecryptfs_do_create(directory_inode, ecryptfs_dentry, (int )mode);
#line 420
  tmp___0 = IS_ERR((void const   *)ecryptfs_inode);
#line 420
  tmp___1 = __builtin_expect(tmp___0 != 0L, 0L);
#line 420
  if (tmp___1 != 0L) {
#line 421
    __ecryptfs_printk("\f%s: Failed to create file inlower filesystem\n", "ecryptfs_create");
#line 423
    tmp = PTR_ERR((void const   *)ecryptfs_inode);
#line 423
    rc = (int )tmp;
#line 424
    goto out;
  } else {

  }
#line 428
  rc = ecryptfs_initialize_file(ecryptfs_dentry, ecryptfs_inode);
#line 429
  if (rc != 0) {
#line 430
    ecryptfs_do_unlink(directory_inode, ecryptfs_dentry, ecryptfs_inode);
#line 432
    make_bad_inode(ecryptfs_inode);
#line 433
    unlock_new_inode(ecryptfs_inode);
#line 434
    iput(ecryptfs_inode);
#line 435
    goto out;
  } else {

  }
#line 437
  unlock_new_inode(ecryptfs_inode);
#line 438
  d_instantiate(ecryptfs_dentry, ecryptfs_inode);
  out: ;
#line 440
  return (rc);
}
}
#line 443 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_i_size_read(struct dentry *dentry , struct inode *inode ) 
{ 
  struct ecryptfs_crypt_stat *crypt_stat ;
  int rc ;
  struct ecryptfs_inode_info *tmp ;

  {
#line 448
  rc = ecryptfs_get_lower_file(dentry, inode);
#line 449
  if (rc != 0) {
#line 450
    printk("\v%s: Error attempting to initialize the lower file for the dentry with name [%s]; rc = [%d]\n",
           "ecryptfs_i_size_read", dentry->d_name.name, rc);
#line 454
    return (rc);
  } else {

  }
#line 457
  tmp = ecryptfs_inode_to_private(inode);
#line 457
  crypt_stat = & tmp->crypt_stat;
#line 459
  if ((crypt_stat->flags & 2U) == 0U) {
#line 460
    ecryptfs_set_default_sizes(crypt_stat);
  } else {

  }
#line 462
  rc = ecryptfs_read_and_validate_header_region(inode);
#line 463
  ecryptfs_put_lower_file(inode);
#line 464
  if (rc != 0) {
#line 465
    rc = ecryptfs_read_and_validate_xattr_region(dentry, inode);
#line 466
    if (rc == 0) {
#line 467
      crypt_stat->flags = crypt_stat->flags | 128U;
    } else {

    }
  } else {

  }
#line 471
  return (0);
}
}
#line 477 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_lookup_interpose(struct dentry *dentry , struct dentry *lower_dentry ,
                                     struct inode *dir_inode ) 
{ 
  struct inode *inode ;
  struct inode *lower_inode ;
  struct ecryptfs_dentry_info *dentry_info ;
  struct vfsmount *lower_mnt ;
  int rc ;
  void *tmp ;
  struct vfsmount *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 481
  lower_inode = lower_dentry->d_inode;
#line 484
  rc = 0;
#line 486
  tmp = kmem_cache_alloc(ecryptfs_dentry_info_cache, 208U);
#line 486
  dentry_info = (struct ecryptfs_dentry_info *)tmp;
#line 487
  if ((unsigned long )dentry_info == (unsigned long )((struct ecryptfs_dentry_info *)0)) {
#line 488
    printk("\v%s: Out of memory whilst attempting to allocate ecryptfs_dentry_info struct\n",
           "ecryptfs_lookup_interpose");
#line 491
    dput(lower_dentry);
#line 492
    return (-12);
  } else {

  }
#line 495
  tmp___0 = ecryptfs_dentry_to_lower_mnt(dentry->d_parent);
#line 495
  lower_mnt = mntget(tmp___0);
#line 496
  fsstack_copy_attr_atime(dir_inode, (struct inode  const  *)(lower_dentry->d_parent)->d_inode);
#line 497
  tmp___1 = __builtin_expect(lower_dentry->d_count == 0U, 0L);
#line 497
  if (tmp___1 != 0L) {
#line 497
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"),
                         "i" (497), "i" (12UL));
    ldv_27556: ;
#line 497
    goto ldv_27556;
  } else {

  }
#line 499
  ecryptfs_set_dentry_private(dentry, dentry_info);
#line 500
  ecryptfs_set_dentry_lower(dentry, lower_dentry);
#line 501
  ecryptfs_set_dentry_lower_mnt(dentry, lower_mnt);
#line 503
  if ((unsigned long )lower_dentry->d_inode == (unsigned long )((struct inode *)0)) {
#line 505
    d_add(dentry, 0);
#line 506
    return (0);
  } else {

  }
#line 508
  inode = __ecryptfs_get_inode(lower_inode, dir_inode->i_sb);
#line 509
  tmp___4 = IS_ERR((void const   *)inode);
#line 509
  if (tmp___4 != 0L) {
#line 510
    tmp___2 = PTR_ERR((void const   *)inode);
#line 510
    printk("\v%s: Error interposing; rc = [%ld]\n", "ecryptfs_lookup_interpose", tmp___2);
#line 512
    tmp___3 = PTR_ERR((void const   *)inode);
#line 512
    return ((int )tmp___3);
  } else {

  }
#line 514
  if (((int )inode->i_mode & 61440) == 32768) {
#line 515
    rc = ecryptfs_i_size_read(dentry, inode);
#line 516
    if (rc != 0) {
#line 517
      make_bad_inode(inode);
#line 518
      return (rc);
    } else {

    }
  } else {

  }
#line 522
  if ((inode->i_state & 8UL) != 0UL) {
#line 523
    unlock_new_inode(inode);
  } else {

  }
#line 524
  d_add(dentry, inode);
#line 526
  return (rc);
}
}
#line 538 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static struct dentry *ecryptfs_lookup(struct inode *ecryptfs_dir_inode , struct dentry *ecryptfs_dentry ,
                                      unsigned int flags ) 
{ 
  char *encrypted_and_encoded_name ;
  size_t encrypted_and_encoded_name_size ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct dentry *lower_dir_dentry ;
  struct dentry *lower_dentry ;
  int rc ;
  long tmp ;
  long tmp___0 ;
  struct ecryptfs_sb_info *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;

  {
#line 542
  encrypted_and_encoded_name = 0;
#line 544
  mount_crypt_stat = 0;
#line 546
  rc = 0;
#line 548
  lower_dir_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry->d_parent);
#line 549
  ldv_mutex_lock_35(& (lower_dir_dentry->d_inode)->i_mutex);
#line 550
  lower_dentry = lookup_one_len((char const   *)ecryptfs_dentry->d_name.name, lower_dir_dentry,
                                (int )ecryptfs_dentry->d_name.ldv_7489.ldv_7487.len);
#line 553
  ldv_mutex_unlock_36(& (lower_dir_dentry->d_inode)->i_mutex);
#line 554
  tmp___0 = IS_ERR((void const   *)lower_dentry);
#line 554
  if (tmp___0 != 0L) {
#line 555
    tmp = PTR_ERR((void const   *)lower_dentry);
#line 555
    rc = (int )tmp;
#line 556
    __ecryptfs_printk("\017%s: %s: lookup_one_len() returned [%d] on lower_dentry = [%s]\n",
                      "ecryptfs_lookup", "ecryptfs_lookup", rc, ecryptfs_dentry->d_name.name);
#line 559
    goto out;
  } else {

  }
#line 561
  if ((unsigned long )lower_dentry->d_inode != (unsigned long )((struct inode *)0)) {
#line 562
    goto interpose;
  } else {

  }
#line 563
  tmp___1 = ecryptfs_superblock_to_private(ecryptfs_dentry->d_sb);
#line 563
  mount_crypt_stat = & tmp___1->mount_crypt_stat;
#line 565
  if ((unsigned long )mount_crypt_stat == (unsigned long )((struct ecryptfs_mount_crypt_stat *)0) || (mount_crypt_stat->flags & 16U) == 0U) {
#line 567
    goto interpose;
  } else {

  }
#line 568
  dput(lower_dentry);
#line 569
  rc = ecryptfs_encrypt_and_encode_filename(& encrypted_and_encoded_name, & encrypted_and_encoded_name_size,
                                            0, mount_crypt_stat, (char const   *)ecryptfs_dentry->d_name.name,
                                            (size_t )ecryptfs_dentry->d_name.ldv_7489.ldv_7487.len);
#line 573
  if (rc != 0) {
#line 574
    printk("\v%s: Error attempting to encrypt and encode filename; rc = [%d]\n", "ecryptfs_lookup",
           rc);
#line 576
    goto out;
  } else {

  }
#line 578
  ldv_mutex_lock_37(& (lower_dir_dentry->d_inode)->i_mutex);
#line 579
  lower_dentry = lookup_one_len((char const   *)encrypted_and_encoded_name, lower_dir_dentry,
                                (int )encrypted_and_encoded_name_size);
#line 582
  ldv_mutex_unlock_38(& (lower_dir_dentry->d_inode)->i_mutex);
#line 583
  tmp___3 = IS_ERR((void const   *)lower_dentry);
#line 583
  if (tmp___3 != 0L) {
#line 584
    tmp___2 = PTR_ERR((void const   *)lower_dentry);
#line 584
    rc = (int )tmp___2;
#line 585
    __ecryptfs_printk("\017%s: %s: lookup_one_len() returned [%d] on lower_dentry = [%s]\n",
                      "ecryptfs_lookup", "ecryptfs_lookup", rc, encrypted_and_encoded_name);
#line 588
    goto out;
  } else {

  }
  interpose: 
#line 591
  rc = ecryptfs_lookup_interpose(ecryptfs_dentry, lower_dentry, ecryptfs_dir_inode);
  out: 
#line 594
  kfree((void const   *)encrypted_and_encoded_name);
#line 595
  tmp___4 = ERR_PTR((long )rc);
#line 595
  return ((struct dentry *)tmp___4);
}
}
#line 598 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_link(struct dentry *old_dentry , struct inode *dir , struct dentry *new_dentry ) 
{ 
  struct dentry *lower_old_dentry ;
  struct dentry *lower_new_dentry ;
  struct dentry *lower_dir_dentry ;
  u64 file_size_save ;
  int rc ;
  loff_t tmp ;
  struct inode *tmp___0 ;

  {
#line 607
  tmp = i_size_read((struct inode  const  *)old_dentry->d_inode);
#line 607
  file_size_save = (u64 )tmp;
#line 608
  lower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);
#line 609
  lower_new_dentry = ecryptfs_dentry_to_lower(new_dentry);
#line 610
  dget(lower_old_dentry);
#line 611
  dget(lower_new_dentry);
#line 612
  lower_dir_dentry = lock_parent(lower_new_dentry);
#line 613
  rc = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode, lower_new_dentry);
#line 615
  if (rc != 0 || (unsigned long )lower_new_dentry->d_inode == (unsigned long )((struct inode *)0)) {
#line 616
    goto out_lock;
  } else {

  }
#line 617
  rc = ecryptfs_interpose(lower_new_dentry, new_dentry, dir->i_sb);
#line 618
  if (rc != 0) {
#line 619
    goto out_lock;
  } else {

  }
#line 620
  fsstack_copy_attr_times(dir, (struct inode  const  *)lower_dir_dentry->d_inode);
#line 621
  fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
#line 622
  tmp___0 = ecryptfs_inode_to_lower(old_dentry->d_inode);
#line 622
  set_nlink(old_dentry->d_inode, tmp___0->ldv_13340.i_nlink);
#line 624
  i_size_write(new_dentry->d_inode, (loff_t )file_size_save);
  out_lock: 
#line 626
  unlock_dir(lower_dir_dentry);
#line 627
  dput(lower_new_dentry);
#line 628
  dput(lower_old_dentry);
#line 629
  return (rc);
}
}
#line 632 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_unlink(struct inode *dir , struct dentry *dentry ) 
{ 
  int tmp ;

  {
#line 634
  tmp = ecryptfs_do_unlink(dir, dentry, dentry->d_inode);
#line 634
  return (tmp);
}
}
#line 637 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_symlink(struct inode *dir , struct dentry *dentry , char const   *symname ) 
{ 
  int rc ;
  struct dentry *lower_dentry ;
  struct dentry *lower_dir_dentry ;
  char *encoded_symname ;
  size_t encoded_symlen ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct ecryptfs_sb_info *tmp ;
  size_t tmp___0 ;

  {
#line 645
  mount_crypt_stat = 0;
#line 647
  lower_dentry = ecryptfs_dentry_to_lower(dentry);
#line 648
  dget(lower_dentry);
#line 649
  lower_dir_dentry = lock_parent(lower_dentry);
#line 650
  tmp = ecryptfs_superblock_to_private(dir->i_sb);
#line 650
  mount_crypt_stat = & tmp->mount_crypt_stat;
#line 652
  tmp___0 = strlen(symname);
#line 652
  rc = ecryptfs_encrypt_and_encode_filename(& encoded_symname, & encoded_symlen, 0,
                                            mount_crypt_stat, symname, tmp___0);
#line 657
  if (rc != 0) {
#line 658
    goto out_lock;
  } else {

  }
#line 659
  rc = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry, (char const   *)encoded_symname);
#line 661
  kfree((void const   *)encoded_symname);
#line 662
  if (rc != 0 || (unsigned long )lower_dentry->d_inode == (unsigned long )((struct inode *)0)) {
#line 663
    goto out_lock;
  } else {

  }
#line 664
  rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);
#line 665
  if (rc != 0) {
#line 666
    goto out_lock;
  } else {

  }
#line 667
  fsstack_copy_attr_times(dir, (struct inode  const  *)lower_dir_dentry->d_inode);
#line 668
  fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
  out_lock: 
#line 670
  unlock_dir(lower_dir_dentry);
#line 671
  dput(lower_dentry);
#line 672
  if ((unsigned long )dentry->d_inode == (unsigned long )((struct inode *)0)) {
#line 673
    d_drop(dentry);
  } else {

  }
#line 674
  return (rc);
}
}
#line 677 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_mkdir(struct inode *dir , struct dentry *dentry , umode_t mode ) 
{ 
  int rc ;
  struct dentry *lower_dentry ;
  struct dentry *lower_dir_dentry ;

  {
#line 683
  lower_dentry = ecryptfs_dentry_to_lower(dentry);
#line 684
  lower_dir_dentry = lock_parent(lower_dentry);
#line 685
  rc = vfs_mkdir(lower_dir_dentry->d_inode, lower_dentry, (int )mode);
#line 686
  if (rc != 0 || (unsigned long )lower_dentry->d_inode == (unsigned long )((struct inode *)0)) {
#line 687
    goto out;
  } else {

  }
#line 688
  rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);
#line 689
  if (rc != 0) {
#line 690
    goto out;
  } else {

  }
#line 691
  fsstack_copy_attr_times(dir, (struct inode  const  *)lower_dir_dentry->d_inode);
#line 692
  fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
#line 693
  set_nlink(dir, (lower_dir_dentry->d_inode)->ldv_13340.i_nlink);
  out: 
#line 695
  unlock_dir(lower_dir_dentry);
#line 696
  if ((unsigned long )dentry->d_inode == (unsigned long )((struct inode *)0)) {
#line 697
    d_drop(dentry);
  } else {

  }
#line 698
  return (rc);
}
}
#line 701 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_rmdir(struct inode *dir , struct dentry *dentry ) 
{ 
  struct dentry *lower_dentry ;
  struct dentry *lower_dir_dentry ;
  int rc ;

  {
#line 707
  lower_dentry = ecryptfs_dentry_to_lower(dentry);
#line 708
  dget(dentry);
#line 709
  lower_dir_dentry = lock_parent(lower_dentry);
#line 710
  dget(lower_dentry);
#line 711
  rc = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
#line 712
  dput(lower_dentry);
#line 713
  if (rc == 0 && (unsigned long )dentry->d_inode != (unsigned long )((struct inode *)0)) {
#line 714
    clear_nlink(dentry->d_inode);
  } else {

  }
#line 715
  fsstack_copy_attr_times(dir, (struct inode  const  *)lower_dir_dentry->d_inode);
#line 716
  set_nlink(dir, (lower_dir_dentry->d_inode)->ldv_13340.i_nlink);
#line 717
  unlock_dir(lower_dir_dentry);
#line 718
  if (rc == 0) {
#line 719
    d_drop(dentry);
  } else {

  }
#line 720
  dput(dentry);
#line 721
  return (rc);
}
}
#line 725 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_mknod(struct inode *dir , struct dentry *dentry , umode_t mode ,
                          dev_t dev ) 
{ 
  int rc ;
  struct dentry *lower_dentry ;
  struct dentry *lower_dir_dentry ;

  {
#line 731
  lower_dentry = ecryptfs_dentry_to_lower(dentry);
#line 732
  lower_dir_dentry = lock_parent(lower_dentry);
#line 733
  rc = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, (int )mode, dev);
#line 734
  if (rc != 0 || (unsigned long )lower_dentry->d_inode == (unsigned long )((struct inode *)0)) {
#line 735
    goto out;
  } else {

  }
#line 736
  rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);
#line 737
  if (rc != 0) {
#line 738
    goto out;
  } else {

  }
#line 739
  fsstack_copy_attr_times(dir, (struct inode  const  *)lower_dir_dentry->d_inode);
#line 740
  fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
  out: 
#line 742
  unlock_dir(lower_dir_dentry);
#line 743
  if ((unsigned long )dentry->d_inode == (unsigned long )((struct inode *)0)) {
#line 744
    d_drop(dentry);
  } else {

  }
#line 745
  return (rc);
}
}
#line 749 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_rename(struct inode *old_dir , struct dentry *old_dentry , struct inode *new_dir ,
                           struct dentry *new_dentry ) 
{ 
  int rc ;
  struct dentry *lower_old_dentry ;
  struct dentry *lower_new_dentry ;
  struct dentry *lower_old_dir_dentry ;
  struct dentry *lower_new_dir_dentry ;
  struct dentry *trap ;
  struct inode *target_inode ;
  struct inode *tmp ;

  {
#line 757
  trap = 0;
#line 760
  lower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);
#line 761
  lower_new_dentry = ecryptfs_dentry_to_lower(new_dentry);
#line 762
  dget(lower_old_dentry);
#line 763
  dget(lower_new_dentry);
#line 764
  lower_old_dir_dentry = dget_parent(lower_old_dentry);
#line 765
  lower_new_dir_dentry = dget_parent(lower_new_dentry);
#line 766
  target_inode = new_dentry->d_inode;
#line 767
  trap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
#line 769
  if ((unsigned long )trap == (unsigned long )lower_old_dentry) {
#line 770
    rc = -22;
#line 771
    goto out_lock;
  } else {

  }
#line 774
  if ((unsigned long )trap == (unsigned long )lower_new_dentry) {
#line 775
    rc = -39;
#line 776
    goto out_lock;
  } else {

  }
#line 778
  rc = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry, lower_new_dir_dentry->d_inode,
                  lower_new_dentry);
#line 780
  if (rc != 0) {
#line 781
    goto out_lock;
  } else {

  }
#line 782
  if ((unsigned long )target_inode != (unsigned long )((struct inode *)0)) {
#line 783
    tmp = ecryptfs_inode_to_lower(target_inode);
#line 783
    fsstack_copy_attr_all(target_inode, (struct inode  const  *)tmp);
  } else {

  }
#line 785
  fsstack_copy_attr_all(new_dir, (struct inode  const  *)lower_new_dir_dentry->d_inode);
#line 786
  if ((unsigned long )new_dir != (unsigned long )old_dir) {
#line 787
    fsstack_copy_attr_all(old_dir, (struct inode  const  *)lower_old_dir_dentry->d_inode);
  } else {

  }
  out_lock: 
#line 789
  unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
#line 790
  dput(lower_new_dir_dentry);
#line 791
  dput(lower_old_dir_dentry);
#line 792
  dput(lower_new_dentry);
#line 793
  dput(lower_old_dentry);
#line 794
  return (rc);
}
}
#line 797 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_readlink_lower(struct dentry *dentry , char **buf , size_t *bufsiz ) 
{ 
  struct dentry *lower_dentry ;
  struct dentry *tmp ;
  char *lower_buf ;
  mm_segment_t old_fs ;
  int rc ;
  void *tmp___0 ;
  struct thread_info *tmp___1 ;
  struct thread_info *tmp___2 ;
  mm_segment_t __constr_expr_0 ;
  struct thread_info *tmp___3 ;

  {
#line 800
  tmp = ecryptfs_dentry_to_lower(dentry);
#line 800
  lower_dentry = tmp;
#line 805
  tmp___0 = kmalloc(4096UL, 208U);
#line 805
  lower_buf = (char *)tmp___0;
#line 806
  if ((unsigned long )lower_buf == (unsigned long )((char *)0)) {
#line 807
    rc = -12;
#line 808
    goto out;
  } else {

  }
#line 810
  tmp___1 = current_thread_info();
#line 810
  old_fs = tmp___1->addr_limit;
#line 811
  tmp___2 = current_thread_info();
#line 811
  __constr_expr_0.seg = 0xffffffffffffffffUL;
#line 811
  tmp___2->addr_limit = __constr_expr_0;
#line 812
  rc = (*(((lower_dentry->d_inode)->i_op)->readlink))(lower_dentry, lower_buf, 4096);
#line 815
  tmp___3 = current_thread_info();
#line 815
  tmp___3->addr_limit = old_fs;
#line 816
  if (rc < 0) {
#line 817
    goto out;
  } else {

  }
#line 818
  rc = ecryptfs_decode_and_decrypt_filename(buf, bufsiz, dentry, (char const   *)lower_buf,
                                            (size_t )rc);
  out: 
#line 821
  kfree((void const   *)lower_buf);
#line 822
  return (rc);
}
}
#line 825 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static void *ecryptfs_follow_link(struct dentry *dentry , struct nameidata *nd ) 
{ 
  char *buf ;
  size_t len ;
  int rc ;
  struct dentry *tmp ;

  {
#line 828
  len = 4096UL;
#line 831
  rc = ecryptfs_readlink_lower(dentry, & buf, & len);
#line 832
  if (rc != 0) {
#line 833
    goto out;
  } else {

  }
#line 834
  tmp = ecryptfs_dentry_to_lower(dentry);
#line 834
  fsstack_copy_attr_atime(dentry->d_inode, (struct inode  const  *)tmp->d_inode);
#line 836
  *(buf + len) = 0;
  out: 
#line 838
  nd_set_link(nd, buf);
#line 839
  return (0);
}
}
#line 843 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static void ecryptfs_put_link(struct dentry *dentry , struct nameidata *nd , void *ptr ) 
{ 
  char *buf ;
  char *tmp ;
  long tmp___0 ;

  {
#line 845
  tmp = nd_get_link(nd);
#line 845
  buf = tmp;
#line 846
  tmp___0 = IS_ERR((void const   *)buf);
#line 846
  if (tmp___0 == 0L) {
#line 848
    kfree((void const   *)buf);
  } else {

  }
#line 849
  return;
}
}
#line 864 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static loff_t upper_size_to_lower_size(struct ecryptfs_crypt_stat *crypt_stat , loff_t upper_size ) 
{ 
  loff_t lower_size ;
  size_t tmp ;
  loff_t num_extents ;

  {
#line 869
  tmp = ecryptfs_lower_header_size(crypt_stat);
#line 869
  lower_size = (loff_t )tmp;
#line 870
  if (upper_size != 0LL) {
#line 873
    num_extents = upper_size >> (int )crypt_stat->extent_shift;
#line 874
    if (((loff_t )(~ crypt_stat->extent_mask) & upper_size) != 0LL) {
#line 875
      num_extents = num_extents + 1LL;
    } else {

    }
#line 876
    lower_size = (loff_t )((unsigned long long )crypt_stat->extent_size * (unsigned long long )num_extents + (unsigned long long )lower_size);
  } else {

  }
#line 878
  return (lower_size);
}
}
#line 897 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int truncate_upper(struct dentry *dentry , struct iattr *ia , struct iattr *lower_ia ) 
{ 
  int rc ;
  struct inode *inode ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  loff_t i_size ;
  loff_t tmp ;
  loff_t lower_size_before_truncate ;
  loff_t lower_size_after_truncate ;
  long tmp___0 ;
  struct ecryptfs_inode_info *tmp___1 ;
  char zero[1U] ;
  size_t num_zeros ;
  char *zeros_virt ;
  void *tmp___2 ;

  {
#line 900
  rc = 0;
#line 901
  inode = dentry->d_inode;
#line 903
  tmp = i_size_read((struct inode  const  *)inode);
#line 903
  i_size = tmp;
#line 907
  tmp___0 = __builtin_expect(ia->ia_size == i_size, 0L);
#line 907
  if (tmp___0 != 0L) {
#line 908
    lower_ia->ia_valid = lower_ia->ia_valid & 4294967287U;
#line 909
    return (0);
  } else {

  }
#line 911
  rc = ecryptfs_get_lower_file(dentry, inode);
#line 912
  if (rc != 0) {
#line 913
    return (rc);
  } else {

  }
#line 914
  tmp___1 = ecryptfs_inode_to_private(dentry->d_inode);
#line 914
  crypt_stat = & tmp___1->crypt_stat;
#line 916
  if (ia->ia_size > i_size) {
#line 917
    zero[0] = 0;
#line 919
    lower_ia->ia_valid = lower_ia->ia_valid & 4294967287U;
#line 924
    rc = ecryptfs_write(inode, (char *)(& zero), ia->ia_size + -1LL, 1UL);
  } else {
#line 931
    num_zeros = (size_t )(4096ULL - ((unsigned long long )ia->ia_size & 4095ULL));
#line 934
    if ((crypt_stat->flags & 4U) == 0U) {
#line 935
      truncate_setsize(inode, ia->ia_size);
#line 936
      lower_ia->ia_size = ia->ia_size;
#line 937
      lower_ia->ia_valid = lower_ia->ia_valid | 8U;
#line 938
      goto out;
    } else {

    }
#line 940
    if (num_zeros != 0UL) {
#line 943
      tmp___2 = kzalloc(num_zeros, 208U);
#line 943
      zeros_virt = (char *)tmp___2;
#line 944
      if ((unsigned long )zeros_virt == (unsigned long )((char *)0)) {
#line 945
        rc = -12;
#line 946
        goto out;
      } else {

      }
#line 948
      rc = ecryptfs_write(inode, zeros_virt, ia->ia_size, num_zeros);
#line 950
      kfree((void const   *)zeros_virt);
#line 951
      if (rc != 0) {
#line 952
        printk("\vError attempting to zero out the remainder of the end page on reducing truncate; rc = [%d]\n",
               rc);
#line 955
        goto out;
      } else {

      }
    } else {

    }
#line 958
    truncate_setsize(inode, ia->ia_size);
#line 959
    rc = ecryptfs_write_inode_size_to_metadata(inode);
#line 960
    if (rc != 0) {
#line 961
      printk("\vProblem with ecryptfs_write_inode_size_to_metadata; rc = [%d]\n",
             rc);
#line 964
      goto out;
    } else {

    }
#line 968
    lower_size_before_truncate = upper_size_to_lower_size(crypt_stat, i_size);
#line 970
    lower_size_after_truncate = upper_size_to_lower_size(crypt_stat, ia->ia_size);
#line 972
    if (lower_size_after_truncate < lower_size_before_truncate) {
#line 973
      lower_ia->ia_size = lower_size_after_truncate;
#line 974
      lower_ia->ia_valid = lower_ia->ia_valid | 8U;
    } else {
#line 976
      lower_ia->ia_valid = lower_ia->ia_valid & 4294967287U;
    }
  }
  out: 
#line 979
  ecryptfs_put_lower_file(inode);
#line 980
  return (rc);
}
}
#line 983 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_inode_newsize_ok(struct inode *inode , loff_t offset ) 
{ 
  struct ecryptfs_crypt_stat *crypt_stat ;
  loff_t lower_oldsize ;
  loff_t lower_newsize ;
  struct ecryptfs_inode_info *tmp ;
  loff_t tmp___0 ;
  int tmp___1 ;

  {
#line 988
  tmp = ecryptfs_inode_to_private(inode);
#line 988
  crypt_stat = & tmp->crypt_stat;
#line 989
  tmp___0 = i_size_read((struct inode  const  *)inode);
#line 989
  lower_oldsize = upper_size_to_lower_size(crypt_stat, tmp___0);
#line 991
  lower_newsize = upper_size_to_lower_size(crypt_stat, offset);
#line 992
  if (lower_newsize > lower_oldsize) {
#line 999
    tmp___1 = inode_newsize_ok((struct inode  const  *)inode, lower_newsize);
#line 999
    return (tmp___1);
  } else {

  }
#line 1002
  return (0);
}
}
#line 1015 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
int ecryptfs_truncate(struct dentry *dentry , loff_t new_length ) 
{ 
  struct iattr ia ;
  struct iattr lower_ia ;
  int rc ;
  struct dentry *lower_dentry ;
  struct dentry *tmp ;

  {
#line 1017
  ia.ia_valid = 8U;
#line 1017
  ia.ia_mode = (unsigned short)0;
#line 1017
  ia.ia_uid = 0U;
#line 1017
  ia.ia_gid = 0U;
#line 1017
  ia.ia_size = new_length;
#line 1017
  ia.ia_atime.tv_sec = 0L;
#line 1017
  ia.ia_atime.tv_nsec = 0L;
#line 1017
  ia.ia_mtime.tv_sec = 0L;
#line 1017
  ia.ia_mtime.tv_nsec = 0L;
#line 1017
  ia.ia_ctime.tv_sec = 0L;
#line 1017
  ia.ia_ctime.tv_nsec = 0L;
#line 1017
  ia.ia_file = 0;
#line 1018
  lower_ia.ia_valid = 0U;
#line 1018
  lower_ia.ia_mode = (unsigned short)0;
#line 1018
  lower_ia.ia_uid = 0U;
#line 1018
  lower_ia.ia_gid = 0U;
#line 1018
  lower_ia.ia_size = 0LL;
#line 1018
  lower_ia.ia_atime.tv_sec = 0L;
#line 1018
  lower_ia.ia_atime.tv_nsec = 0L;
#line 1018
  lower_ia.ia_mtime.tv_sec = 0L;
#line 1018
  lower_ia.ia_mtime.tv_nsec = 0L;
#line 1018
  lower_ia.ia_ctime.tv_sec = 0L;
#line 1018
  lower_ia.ia_ctime.tv_nsec = 0L;
#line 1018
  lower_ia.ia_file = 0;
#line 1021
  rc = ecryptfs_inode_newsize_ok(dentry->d_inode, new_length);
#line 1022
  if (rc != 0) {
#line 1023
    return (rc);
  } else {

  }
#line 1025
  rc = truncate_upper(dentry, & ia, & lower_ia);
#line 1026
  if (rc == 0 && (lower_ia.ia_valid & 8U) != 0U) {
#line 1027
    tmp = ecryptfs_dentry_to_lower(dentry);
#line 1027
    lower_dentry = tmp;
#line 1029
    ldv_mutex_lock_39(& (lower_dentry->d_inode)->i_mutex);
#line 1030
    rc = notify_change(lower_dentry, & lower_ia);
#line 1031
    ldv_mutex_unlock_40(& (lower_dentry->d_inode)->i_mutex);
  } else {

  }
#line 1033
  return (rc);
}
}
#line 1037 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_permission(struct inode *inode , int mask ) 
{ 
  struct inode *tmp ;
  int tmp___0 ;

  {
#line 1039
  tmp = ecryptfs_inode_to_lower(inode);
#line 1039
  tmp___0 = inode_permission(tmp, mask);
#line 1039
  return (tmp___0);
}
}
#line 1054 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_setattr(struct dentry *dentry , struct iattr *ia ) 
{ 
  int rc ;
  struct dentry *lower_dentry ;
  struct iattr lower_ia ;
  struct inode *inode ;
  struct inode *lower_inode ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_inode_info *tmp ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct ecryptfs_sb_info *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 1056
  rc = 0;
#line 1063
  tmp = ecryptfs_inode_to_private(dentry->d_inode);
#line 1063
  crypt_stat = & tmp->crypt_stat;
#line 1064
  if ((crypt_stat->flags & 1U) == 0U) {
#line 1065
    ecryptfs_init_crypt_stat(crypt_stat);
  } else {

  }
#line 1066
  inode = dentry->d_inode;
#line 1067
  lower_inode = ecryptfs_inode_to_lower(inode);
#line 1068
  lower_dentry = ecryptfs_dentry_to_lower(dentry);
#line 1069
  ldv_mutex_lock_41(& crypt_stat->cs_mutex);
#line 1070
  if (((int )(dentry->d_inode)->i_mode & 61440) == 16384) {
#line 1071
    crypt_stat->flags = crypt_stat->flags & 4294967291U;
  } else
#line 1072
  if (((int )(dentry->d_inode)->i_mode & 61440) == 32768 && ((crypt_stat->flags & 2U) == 0U || (crypt_stat->flags & 64U) == 0U)) {
#line 1077
    tmp___0 = ecryptfs_superblock_to_private(dentry->d_sb);
#line 1077
    mount_crypt_stat = & tmp___0->mount_crypt_stat;
#line 1079
    rc = ecryptfs_get_lower_file(dentry, inode);
#line 1080
    if (rc != 0) {
#line 1081
      ldv_mutex_unlock_42(& crypt_stat->cs_mutex);
#line 1082
      goto out;
    } else {

    }
#line 1084
    rc = ecryptfs_read_metadata(dentry);
#line 1085
    ecryptfs_put_lower_file(inode);
#line 1086
    if (rc != 0) {
#line 1087
      if ((mount_crypt_stat->flags & 1U) == 0U) {
#line 1089
        rc = -5;
#line 1090
        printk("\fEither the lower file is not in a valid eCryptfs format, or the key could not be retrieved. Plaintext passthrough mode is not enabled; returning -EIO\n");
#line 1095
        ldv_mutex_unlock_43(& crypt_stat->cs_mutex);
#line 1096
        goto out;
      } else {

      }
#line 1098
      rc = 0;
#line 1099
      crypt_stat->flags = crypt_stat->flags & 4294950907U;
    } else {

    }
  } else {

  }
#line 1103
  ldv_mutex_unlock_44(& crypt_stat->cs_mutex);
#line 1105
  rc = inode_change_ok((struct inode  const  *)inode, ia);
#line 1106
  if (rc != 0) {
#line 1107
    goto out;
  } else {

  }
#line 1108
  if ((ia->ia_valid & 8U) != 0U) {
#line 1109
    rc = ecryptfs_inode_newsize_ok(inode, ia->ia_size);
#line 1110
    if (rc != 0) {
#line 1111
      goto out;
    } else {

    }
  } else {

  }
#line 1114
  __len = 80UL;
#line 1114
  if (__len > 63UL) {
#line 1114
    __ret = __memcpy((void *)(& lower_ia), (void const   *)ia, __len);
  } else {
#line 1114
    __ret = __builtin_memcpy((void *)(& lower_ia), (void const   *)ia, __len);
  }
#line 1115
  if ((ia->ia_valid & 8192U) != 0U) {
#line 1116
    lower_ia.ia_file = ecryptfs_file_to_lower(ia->ia_file);
  } else {

  }
#line 1117
  if ((ia->ia_valid & 8U) != 0U) {
#line 1118
    rc = truncate_upper(dentry, ia, & lower_ia);
#line 1119
    if (rc < 0) {
#line 1120
      goto out;
    } else {

    }
  } else {

  }
#line 1127
  if ((lower_ia.ia_valid & 6144U) != 0U) {
#line 1128
    lower_ia.ia_valid = lower_ia.ia_valid & 4294967294U;
  } else {

  }
#line 1130
  ldv_mutex_lock_45(& (lower_dentry->d_inode)->i_mutex);
#line 1131
  rc = notify_change(lower_dentry, & lower_ia);
#line 1132
  ldv_mutex_unlock_46(& (lower_dentry->d_inode)->i_mutex);
  out: 
#line 1134
  fsstack_copy_attr_all(inode, (struct inode  const  *)lower_inode);
#line 1135
  return (rc);
}
}
#line 1138 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
int ecryptfs_getattr_link(struct vfsmount *mnt , struct dentry *dentry , struct kstat *stat ) 
{ 
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  int rc ;
  struct ecryptfs_sb_info *tmp ;
  char *target ;
  size_t targetsiz ;

  {
#line 1142
  rc = 0;
#line 1144
  tmp = ecryptfs_superblock_to_private(dentry->d_sb);
#line 1144
  mount_crypt_stat = & tmp->mount_crypt_stat;
#line 1146
  generic_fillattr(dentry->d_inode, stat);
#line 1147
  if ((mount_crypt_stat->flags & 16U) != 0U) {
#line 1151
    rc = ecryptfs_readlink_lower(dentry, & target, & targetsiz);
#line 1152
    if (rc == 0) {
#line 1153
      kfree((void const   *)target);
#line 1154
      stat->size = (loff_t )targetsiz;
    } else {

    }
  } else {

  }
#line 1157
  return (rc);
}
}
#line 1160 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
int ecryptfs_getattr(struct vfsmount *mnt , struct dentry *dentry , struct kstat *stat ) 
{ 
  struct kstat lower_stat ;
  int rc ;
  struct dentry *tmp ;
  struct vfsmount *tmp___0 ;
  struct inode *tmp___1 ;

  {
#line 1166
  tmp = ecryptfs_dentry_to_lower(dentry);
#line 1166
  tmp___0 = ecryptfs_dentry_to_lower_mnt(dentry);
#line 1166
  rc = vfs_getattr(tmp___0, tmp, & lower_stat);
#line 1168
  if (rc == 0) {
#line 1169
    tmp___1 = ecryptfs_inode_to_lower(dentry->d_inode);
#line 1169
    fsstack_copy_attr_all(dentry->d_inode, (struct inode  const  *)tmp___1);
#line 1171
    generic_fillattr(dentry->d_inode, stat);
#line 1172
    stat->blocks = lower_stat.blocks;
  } else {

  }
#line 1174
  return (rc);
}
}
#line 1178 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
int ecryptfs_setxattr(struct dentry *dentry , char const   *name , void const   *value ,
                      size_t size , int flags ) 
{ 
  int rc ;
  struct dentry *lower_dentry ;

  {
#line 1181
  rc = 0;
#line 1184
  lower_dentry = ecryptfs_dentry_to_lower(dentry);
#line 1185
  if ((unsigned long )((lower_dentry->d_inode)->i_op)->setxattr == (unsigned long )((int (*/* const  */)(struct dentry * ,
                                                                                                         char const   * ,
                                                                                                         void const   * ,
                                                                                                         size_t  ,
                                                                                                         int  ))0)) {
#line 1186
    rc = -95;
#line 1187
    goto out;
  } else {

  }
#line 1190
  rc = vfs_setxattr(lower_dentry, name, value, size, flags);
#line 1191
  if (rc == 0) {
#line 1192
    fsstack_copy_attr_all(dentry->d_inode, (struct inode  const  *)lower_dentry->d_inode);
  } else {

  }
  out: ;
#line 1194
  return (rc);
}
}
#line 1198 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
ssize_t ecryptfs_getxattr_lower(struct dentry *lower_dentry , char const   *name ,
                                void *value , size_t size ) 
{ 
  int rc ;
  ssize_t tmp ;

  {
#line 1201
  rc = 0;
#line 1203
  if ((unsigned long )((lower_dentry->d_inode)->i_op)->getxattr == (unsigned long )((ssize_t (*/* const  */)(struct dentry * ,
                                                                                                             char const   * ,
                                                                                                             void * ,
                                                                                                             size_t  ))0)) {
#line 1204
    rc = -95;
#line 1205
    goto out;
  } else {

  }
#line 1207
  ldv_mutex_lock_47(& (lower_dentry->d_inode)->i_mutex);
#line 1208
  tmp = (*(((lower_dentry->d_inode)->i_op)->getxattr))(lower_dentry, name, value,
                                                       size);
#line 1208
  rc = (int )tmp;
#line 1210
  ldv_mutex_unlock_48(& (lower_dentry->d_inode)->i_mutex);
  out: ;
#line 1212
  return ((ssize_t )rc);
}
}
#line 1216 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static ssize_t ecryptfs_getxattr(struct dentry *dentry , char const   *name , void *value ,
                                 size_t size ) 
{ 
  struct dentry *tmp ;
  ssize_t tmp___0 ;

  {
#line 1219
  tmp = ecryptfs_dentry_to_lower(dentry);
#line 1219
  tmp___0 = ecryptfs_getxattr_lower(tmp, name, value, size);
#line 1219
  return (tmp___0);
}
}
#line 1224 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static ssize_t ecryptfs_listxattr(struct dentry *dentry , char *list , size_t size ) 
{ 
  int rc ;
  struct dentry *lower_dentry ;
  ssize_t tmp ;

  {
#line 1226
  rc = 0;
#line 1229
  lower_dentry = ecryptfs_dentry_to_lower(dentry);
#line 1230
  if ((unsigned long )((lower_dentry->d_inode)->i_op)->listxattr == (unsigned long )((ssize_t (*/* const  */)(struct dentry * ,
                                                                                                              char * ,
                                                                                                              size_t  ))0)) {
#line 1231
    rc = -95;
#line 1232
    goto out;
  } else {

  }
#line 1234
  ldv_mutex_lock_49(& (lower_dentry->d_inode)->i_mutex);
#line 1235
  tmp = (*(((lower_dentry->d_inode)->i_op)->listxattr))(lower_dentry, list, size);
#line 1235
  rc = (int )tmp;
#line 1236
  ldv_mutex_unlock_50(& (lower_dentry->d_inode)->i_mutex);
  out: ;
#line 1238
  return ((ssize_t )rc);
}
}
#line 1241 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
static int ecryptfs_removexattr(struct dentry *dentry , char const   *name ) 
{ 
  int rc ;
  struct dentry *lower_dentry ;

  {
#line 1243
  rc = 0;
#line 1246
  lower_dentry = ecryptfs_dentry_to_lower(dentry);
#line 1247
  if ((unsigned long )((lower_dentry->d_inode)->i_op)->removexattr == (unsigned long )((int (*/* const  */)(struct dentry * ,
                                                                                                            char const   * ))0)) {
#line 1248
    rc = -95;
#line 1249
    goto out;
  } else {

  }
#line 1251
  ldv_mutex_lock_51(& (lower_dentry->d_inode)->i_mutex);
#line 1252
  rc = (*(((lower_dentry->d_inode)->i_op)->removexattr))(lower_dentry, name);
#line 1253
  ldv_mutex_unlock_52(& (lower_dentry->d_inode)->i_mutex);
  out: ;
#line 1255
  return (rc);
}
}
#line 1258 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
struct inode_operations  const  ecryptfs_symlink_iops  = 
#line 1258
     {0, & ecryptfs_follow_link, & ecryptfs_permission, 0, & generic_readlink, & ecryptfs_put_link,
    0, 0, 0, 0, 0, 0, 0, 0, & ecryptfs_setattr, & ecryptfs_getattr_link, & ecryptfs_setxattr,
    & ecryptfs_getxattr, & ecryptfs_listxattr, & ecryptfs_removexattr, 0, 0, 0};
#line 1271 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
struct inode_operations  const  ecryptfs_dir_iops  = 
#line 1271
     {& ecryptfs_lookup, 0, & ecryptfs_permission, 0, 0, 0, & ecryptfs_create, & ecryptfs_link,
    & ecryptfs_unlink, & ecryptfs_symlink, & ecryptfs_mkdir, & ecryptfs_rmdir, & ecryptfs_mknod,
    & ecryptfs_rename, & ecryptfs_setattr, 0, & ecryptfs_setxattr, & ecryptfs_getxattr,
    & ecryptfs_listxattr, & ecryptfs_removexattr, 0, 0, 0};
#line 1289 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
struct inode_operations  const  ecryptfs_main_iops  = 
#line 1289
     {0, 0, & ecryptfs_permission, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ecryptfs_setattr,
    & ecryptfs_getattr, & ecryptfs_setxattr, & ecryptfs_getxattr, & ecryptfs_listxattr,
    & ecryptfs_removexattr, 0, 0, 0};
#line 1336 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_main2_sequence_infinite_withcheck_stateful(void) 
{ 
  struct dentry *var_group1 ;
  struct nameidata *var_group2 ;
  void *var_ecryptfs_put_link_23_p2 ;
  struct inode *var_group3 ;
  int var_ecryptfs_permission_28_p1 ;
  struct iattr *var_group4 ;
  struct vfsmount *var_group5 ;
  struct kstat *var_ecryptfs_getattr_link_30_p2 ;
  char const   *var_ecryptfs_setxattr_32_p1 ;
  void const   *var_ecryptfs_setxattr_32_p2 ;
  size_t var_ecryptfs_setxattr_32_p3 ;
  int var_ecryptfs_setxattr_32_p4 ;
  char const   *var_ecryptfs_getxattr_34_p1 ;
  void *var_ecryptfs_getxattr_34_p2 ;
  size_t var_ecryptfs_getxattr_34_p3 ;
  char *var_ecryptfs_listxattr_35_p1 ;
  size_t var_ecryptfs_listxattr_35_p2 ;
  char const   *var_ecryptfs_removexattr_36_p1 ;
  umode_t var_ecryptfs_create_10_p2 ;
  bool var_ecryptfs_create_10_p3 ;
  unsigned int var_ecryptfs_lookup_13_p2 ;
  struct dentry *var_ecryptfs_link_14_p2 ;
  char const   *var_ecryptfs_symlink_16_p2 ;
  umode_t var_ecryptfs_mkdir_17_p2 ;
  umode_t var_ecryptfs_mknod_19_p2 ;
  dev_t var_ecryptfs_mknod_19_p3 ;
  struct inode *var_ecryptfs_rename_20_p2 ;
  struct dentry *var_ecryptfs_rename_20_p3 ;
  struct kstat *var_ecryptfs_getattr_31_p2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1474
  LDV_IN_INTERRUPT = 1;
#line 1483
  ldv_initialize();
#line 1491
  goto ldv_27855;
  ldv_27854: 
#line 1494
  tmp = __VERIFIER_nondet_int();
#line 1494
  switch (tmp) {
  case 0: 
#line 1504
  ldv_handler_precall();
#line 1505
  ecryptfs_follow_link(var_group1, var_group2);
#line 1512
  goto ldv_27822;
  case 1: 
#line 1521
  ldv_handler_precall();
#line 1522
  ecryptfs_put_link(var_group1, var_group2, var_ecryptfs_put_link_23_p2);
#line 1529
  goto ldv_27822;
  case 2: 
#line 1538
  ldv_handler_precall();
#line 1539
  ecryptfs_permission(var_group3, var_ecryptfs_permission_28_p1);
#line 1546
  goto ldv_27822;
  case 3: 
#line 1555
  ldv_handler_precall();
#line 1556
  ecryptfs_setattr(var_group1, var_group4);
#line 1563
  goto ldv_27822;
  case 4: 
#line 1572
  ldv_handler_precall();
#line 1573
  ecryptfs_getattr_link(var_group5, var_group1, var_ecryptfs_getattr_link_30_p2);
#line 1580
  goto ldv_27822;
  case 5: 
#line 1589
  ldv_handler_precall();
#line 1590
  ecryptfs_setxattr(var_group1, var_ecryptfs_setxattr_32_p1, var_ecryptfs_setxattr_32_p2,
                    var_ecryptfs_setxattr_32_p3, var_ecryptfs_setxattr_32_p4);
#line 1597
  goto ldv_27822;
  case 6: 
#line 1606
  ldv_handler_precall();
#line 1607
  ecryptfs_getxattr(var_group1, var_ecryptfs_getxattr_34_p1, var_ecryptfs_getxattr_34_p2,
                    var_ecryptfs_getxattr_34_p3);
#line 1614
  goto ldv_27822;
  case 7: 
#line 1623
  ldv_handler_precall();
#line 1624
  ecryptfs_listxattr(var_group1, var_ecryptfs_listxattr_35_p1, var_ecryptfs_listxattr_35_p2);
#line 1631
  goto ldv_27822;
  case 8: 
#line 1640
  ldv_handler_precall();
#line 1641
  ecryptfs_removexattr(var_group1, var_ecryptfs_removexattr_36_p1);
#line 1648
  goto ldv_27822;
  case 9: 
#line 1657
  ldv_handler_precall();
#line 1658
  ecryptfs_create(var_group3, var_group1, (int )var_ecryptfs_create_10_p2, (int )var_ecryptfs_create_10_p3);
#line 1665
  goto ldv_27822;
  case 10: 
#line 1674
  ldv_handler_precall();
#line 1675
  ecryptfs_lookup(var_group3, var_group1, var_ecryptfs_lookup_13_p2);
#line 1682
  goto ldv_27822;
  case 11: 
#line 1691
  ldv_handler_precall();
#line 1692
  ecryptfs_link(var_group1, var_group3, var_ecryptfs_link_14_p2);
#line 1699
  goto ldv_27822;
  case 12: 
#line 1708
  ldv_handler_precall();
#line 1709
  ecryptfs_unlink(var_group3, var_group1);
#line 1716
  goto ldv_27822;
  case 13: 
#line 1725
  ldv_handler_precall();
#line 1726
  ecryptfs_symlink(var_group3, var_group1, var_ecryptfs_symlink_16_p2);
#line 1733
  goto ldv_27822;
  case 14: 
#line 1742
  ldv_handler_precall();
#line 1743
  ecryptfs_mkdir(var_group3, var_group1, (int )var_ecryptfs_mkdir_17_p2);
#line 1750
  goto ldv_27822;
  case 15: 
#line 1759
  ldv_handler_precall();
#line 1760
  ecryptfs_rmdir(var_group3, var_group1);
#line 1767
  goto ldv_27822;
  case 16: 
#line 1776
  ldv_handler_precall();
#line 1777
  ecryptfs_mknod(var_group3, var_group1, (int )var_ecryptfs_mknod_19_p2, var_ecryptfs_mknod_19_p3);
#line 1784
  goto ldv_27822;
  case 17: 
#line 1793
  ldv_handler_precall();
#line 1794
  ecryptfs_rename(var_group3, var_group1, var_ecryptfs_rename_20_p2, var_ecryptfs_rename_20_p3);
#line 1801
  goto ldv_27822;
  case 18: 
#line 1810
  ldv_handler_precall();
#line 1811
  ecryptfs_permission(var_group3, var_ecryptfs_permission_28_p1);
#line 1818
  goto ldv_27822;
  case 19: 
#line 1827
  ldv_handler_precall();
#line 1828
  ecryptfs_setattr(var_group1, var_group4);
#line 1835
  goto ldv_27822;
  case 20: 
#line 1844
  ldv_handler_precall();
#line 1845
  ecryptfs_setxattr(var_group1, var_ecryptfs_setxattr_32_p1, var_ecryptfs_setxattr_32_p2,
                    var_ecryptfs_setxattr_32_p3, var_ecryptfs_setxattr_32_p4);
#line 1852
  goto ldv_27822;
  case 21: 
#line 1861
  ldv_handler_precall();
#line 1862
  ecryptfs_getxattr(var_group1, var_ecryptfs_getxattr_34_p1, var_ecryptfs_getxattr_34_p2,
                    var_ecryptfs_getxattr_34_p3);
#line 1869
  goto ldv_27822;
  case 22: 
#line 1878
  ldv_handler_precall();
#line 1879
  ecryptfs_listxattr(var_group1, var_ecryptfs_listxattr_35_p1, var_ecryptfs_listxattr_35_p2);
#line 1886
  goto ldv_27822;
  case 23: 
#line 1895
  ldv_handler_precall();
#line 1896
  ecryptfs_removexattr(var_group1, var_ecryptfs_removexattr_36_p1);
#line 1903
  goto ldv_27822;
  case 24: 
#line 1912
  ldv_handler_precall();
#line 1913
  ecryptfs_permission(var_group3, var_ecryptfs_permission_28_p1);
#line 1920
  goto ldv_27822;
  case 25: 
#line 1929
  ldv_handler_precall();
#line 1930
  ecryptfs_setattr(var_group1, var_group4);
#line 1937
  goto ldv_27822;
  case 26: 
#line 1946
  ldv_handler_precall();
#line 1947
  ecryptfs_getattr(var_group5, var_group1, var_ecryptfs_getattr_31_p2);
#line 1954
  goto ldv_27822;
  case 27: 
#line 1963
  ldv_handler_precall();
#line 1964
  ecryptfs_setxattr(var_group1, var_ecryptfs_setxattr_32_p1, var_ecryptfs_setxattr_32_p2,
                    var_ecryptfs_setxattr_32_p3, var_ecryptfs_setxattr_32_p4);
#line 1971
  goto ldv_27822;
  case 28: 
#line 1980
  ldv_handler_precall();
#line 1981
  ecryptfs_getxattr(var_group1, var_ecryptfs_getxattr_34_p1, var_ecryptfs_getxattr_34_p2,
                    var_ecryptfs_getxattr_34_p3);
#line 1988
  goto ldv_27822;
  case 29: 
#line 1997
  ldv_handler_precall();
#line 1998
  ecryptfs_listxattr(var_group1, var_ecryptfs_listxattr_35_p1, var_ecryptfs_listxattr_35_p2);
#line 2005
  goto ldv_27822;
  case 30: 
#line 2014
  ldv_handler_precall();
#line 2015
  ecryptfs_removexattr(var_group1, var_ecryptfs_removexattr_36_p1);
#line 2022
  goto ldv_27822;
  default: ;
#line 2023
  goto ldv_27822;
  }
  ldv_27822: ;
  ldv_27855: 
#line 1491
  tmp___0 = __VERIFIER_nondet_int();
#line 1491
  if (tmp___0 != 0) {
#line 1492
    goto ldv_27854;
  } else {

  }


#line 2032
  ldv_check_final_state();
#line 2035
  return;
}
}
#line 2039 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_29(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2044
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2046
  mutex_lock(ldv_func_arg1);
#line 2047
  return;
}
}
#line 2049 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_30(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2054
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2056
  mutex_unlock(ldv_func_arg1);
#line 2057
  return;
}
}
#line 2059 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_31(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2064
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 2066
  mutex_lock(ldv_func_arg1);
#line 2067
  return;
}
}
#line 2069 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_32(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2074
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 2076
  mutex_unlock(ldv_func_arg1);
#line 2077
  return;
}
}
#line 2079 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_nested_33(struct mutex *ldv_func_arg1 , unsigned int ldv_func_arg2 ) 
{ 


  {
#line 2085
  ldv_mutex_lock_i_mutex(ldv_func_arg1);
#line 2087
  mutex_lock_nested(ldv_func_arg1, ldv_func_arg2);
#line 2088
  return;
}
}
#line 2090 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2095
  ldv_mutex_unlock_i_mutex(ldv_func_arg1);
#line 2097
  mutex_unlock(ldv_func_arg1);
#line 2098
  return;
}
}
#line 2100 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_35(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2105
  ldv_mutex_lock_i_mutex(ldv_func_arg1);
#line 2107
  mutex_lock(ldv_func_arg1);
#line 2108
  return;
}
}
#line 2110 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_36(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2115
  ldv_mutex_unlock_i_mutex(ldv_func_arg1);
#line 2117
  mutex_unlock(ldv_func_arg1);
#line 2118
  return;
}
}
#line 2120 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_37(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2125
  ldv_mutex_lock_i_mutex(ldv_func_arg1);
#line 2127
  mutex_lock(ldv_func_arg1);
#line 2128
  return;
}
}
#line 2130 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_38(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2135
  ldv_mutex_unlock_i_mutex(ldv_func_arg1);
#line 2137
  mutex_unlock(ldv_func_arg1);
#line 2138
  return;
}
}
#line 2140 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_39(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2145
  ldv_mutex_lock_i_mutex(ldv_func_arg1);
#line 2147
  mutex_lock(ldv_func_arg1);
#line 2148
  return;
}
}
#line 2150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_40(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2155
  ldv_mutex_unlock_i_mutex(ldv_func_arg1);
#line 2157
  mutex_unlock(ldv_func_arg1);
#line 2158
  return;
}
}
#line 2160 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_41(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2165
  ldv_mutex_lock_cs_mutex(ldv_func_arg1);
#line 2167
  mutex_lock(ldv_func_arg1);
#line 2168
  return;
}
}
#line 2170 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_42(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2175
  ldv_mutex_unlock_cs_mutex(ldv_func_arg1);
#line 2177
  mutex_unlock(ldv_func_arg1);
#line 2178
  return;
}
}
#line 2180 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_43(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2185
  ldv_mutex_unlock_cs_mutex(ldv_func_arg1);
#line 2187
  mutex_unlock(ldv_func_arg1);
#line 2188
  return;
}
}
#line 2190 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_44(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2195
  ldv_mutex_unlock_cs_mutex(ldv_func_arg1);
#line 2197
  mutex_unlock(ldv_func_arg1);
#line 2198
  return;
}
}
#line 2200 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_45(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2205
  ldv_mutex_lock_i_mutex(ldv_func_arg1);
#line 2207
  mutex_lock(ldv_func_arg1);
#line 2208
  return;
}
}
#line 2210 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_46(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2215
  ldv_mutex_unlock_i_mutex(ldv_func_arg1);
#line 2217
  mutex_unlock(ldv_func_arg1);
#line 2218
  return;
}
}
#line 2220 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_47(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2225
  ldv_mutex_lock_i_mutex(ldv_func_arg1);
#line 2227
  mutex_lock(ldv_func_arg1);
#line 2228
  return;
}
}
#line 2230 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_48(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2235
  ldv_mutex_unlock_i_mutex(ldv_func_arg1);
#line 2237
  mutex_unlock(ldv_func_arg1);
#line 2238
  return;
}
}
#line 2240 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_49(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2245
  ldv_mutex_lock_i_mutex(ldv_func_arg1);
#line 2247
  mutex_lock(ldv_func_arg1);
#line 2248
  return;
}
}
#line 2250 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_50(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2255
  ldv_mutex_unlock_i_mutex(ldv_func_arg1);
#line 2257
  mutex_unlock(ldv_func_arg1);
#line 2258
  return;
}
}
#line 2260 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_lock_51(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2265
  ldv_mutex_lock_i_mutex(ldv_func_arg1);
#line 2267
  mutex_lock(ldv_func_arg1);
#line 2268
  return;
}
}
#line 2270 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/inode.c.prepared"
void ldv_mutex_unlock_52(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2275
  ldv_mutex_unlock_i_mutex(ldv_func_arg1);
#line 2277
  mutex_unlock(ldv_func_arg1);
#line 2278
  return;
}
}
#line 1 "<compiler builtins>"
void __builtin_va_end(__builtin_va_list  ) ;
#line 1
void __builtin_va_start(__builtin_va_list  ) ;
#line 111 "include/linux/printk.h"
extern int vprintk(char const   * , __va_list_tag * ) ;
#line 346 "include/linux/kernel.h"
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
#line 361
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2861: ;
#line 14
  return (pfo_ret__);
}
}
#line 62 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 86
extern char *strsep(char ** , char const   * ) ;
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 15 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 35 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 37
  v->counter = i;
#line 38
  return;
}
}
#line 173 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 175
  __ret = i;
#line 175
  switch (4UL) {
  case 1UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  case 2UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  case 4UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  case 8UL: 
#line 175
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 175
  goto ldv_5474;
  default: 
#line 175
  __xadd_wrong_size();
  }
  ldv_5474: ;
#line 175
  return (__ret + i);
}
}
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 168
extern int mutex_trylock(struct mutex * ) ;
#line 171
int ldv_mutex_trylock_80(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_85(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_87(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_89(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) ;
#line 206
extern int atomic_dec_and_mutex_lock(atomic_t * , struct mutex * ) ;
#line 209
int ldv_atomic_dec_and_mutex_lock_86(atomic_t *ldv_func_arg1 , struct mutex *ldv_func_arg2 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_79(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_82(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_84(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_88(struct mutex *ldv_func_arg1 ) ;
#line 95
void ldv_mutex_lock_key_tfm_list_mutex(struct mutex *lock ) ;
#line 99
void ldv_mutex_unlock_key_tfm_list_mutex(struct mutex *lock ) ;
#line 121
int ldv_atomic_dec_and_mutex_lock_lower_file_count(atomic_t *cnt , struct mutex *lock ) ;
#line 127
void ldv_mutex_lock_lower_file_mutex(struct mutex *lock ) ;
#line 131
void ldv_mutex_unlock_lower_file_mutex(struct mutex *lock ) ;
#line 135
void ldv_mutex_lock_mutex(struct mutex *lock ) ;
#line 136
int ldv_mutex_trylock_mutex(struct mutex *lock ) ;
#line 139
void ldv_mutex_unlock_mutex(struct mutex *lock ) ;
#line 75 "include/linux/rcutree.h"
extern void rcu_barrier(void) ;
#line 325 "include/linux/rcupdate.h"
extern int debug_lockdep_rcu_enabled(void) ;
#line 241 "include/linux/dcache.h"
extern struct dentry *d_make_root(struct inode * ) ;
#line 14 "include/linux/file.h"
extern void fput(struct file * ) ;
#line 18 "include/linux/uidgid.h"
extern struct user_namespace init_user_ns ;
#line 49 "include/linux/uidgid.h"
__inline static uid_t __kuid_val(kuid_t uid ) 
{ 


  {
#line 51
  return (uid);
}
}
#line 70 "include/linux/uidgid.h"
__inline static bool uid_eq(kuid_t left , kuid_t right ) 
{ 
  uid_t tmp ;
  uid_t tmp___0 ;

  {
#line 72
  tmp = __kuid_val(left);
#line 72
  tmp___0 = __kuid_val(right);
#line 72
  return (tmp == tmp___0);
}
}
#line 162 "include/linux/uidgid.h"
__inline static uid_t from_kuid(struct user_namespace *to , kuid_t kuid ) 
{ 
  uid_t tmp ;

  {
#line 164
  tmp = __kuid_val(kuid);
#line 164
  return (tmp);
}
}
#line 105 "include/linux/rwsem.h"
extern void up_write(struct rw_semaphore * ) ;
#line 170 "include/linux/sysfs.h"
extern int sysfs_create_group(struct kobject * , struct attribute_group  const  * ) ;
#line 174
extern void sysfs_remove_group(struct kobject * , struct attribute_group  const  * ) ;
#line 97 "include/linux/kobject.h"
extern struct kobject *kobject_create_and_add(char const   * , struct kobject * ) ;
#line 104
extern void kobject_put(struct kobject * ) ;
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 13 "include/linux/path.h"
extern void path_put(struct path * ) ;
#line 66 "include/linux/namei.h"
extern int kern_path(char const   * , unsigned int  , struct path * ) ;
#line 128 "include/linux/slab.h"
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
#line 134
extern void kmem_cache_destroy(struct kmem_cache * ) ;
#line 695 "include/linux/fs.h"
__inline static uid_t i_uid_read(struct inode  const  *inode ) 
{ 
  uid_t tmp ;

  {
#line 697
  tmp = from_kuid(& init_user_ns, inode->i_uid);
#line 697
  return (tmp);
}
}
#line 1843
extern void kill_anon_super(struct super_block * ) ;
#line 1846
extern void deactivate_locked_super(struct super_block * ) ;
#line 1847
extern int set_anon_super(struct super_block * , void * ) ;
#line 1850
extern struct super_block *sget(struct file_system_type * , int (*)(struct super_block * ,
                                                                    void * ) , int (*)(struct super_block * ,
                                                                                       void * ) ,
                                int  , void * ) ;
#line 1865
extern int register_filesystem(struct file_system_type * ) ;
#line 1866
extern int unregister_filesystem(struct file_system_type * ) ;
#line 1888
extern struct kobject *fs_kobj ;
#line 2292
extern void inode_init_once(struct inode * ) ;
#line 28 "include/linux/parser.h"
extern int match_token(char * , struct match_token  const  * , substring_t * ) ;
#line 115 "include/linux/backing-dev.h"
extern void bdi_destroy(struct backing_dev_info * ) ;
#line 122
extern int bdi_setup_and_register(struct backing_dev_info * , char * , unsigned int  ) ;
#line 303 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct mutex key_tfm_list_mutex ;
#line 461 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static void ecryptfs_set_superblock_private(struct super_block *sb , struct ecryptfs_sb_info *sb_info ) 
{ 


  {
#line 464
  sb->s_fs_info = (void *)sb_info;
#line 465
  return;
}
}
#line 474 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static void ecryptfs_set_superblock_lower(struct super_block *sb , struct super_block *lower_sb ) 
{ 


  {
#line 477
  ((struct ecryptfs_sb_info *)sb->s_fs_info)->wsi_sb = lower_sb;
#line 478
  return;
}
}
#line 529
struct super_operations  const  ecryptfs_sops ;
#line 532
int ecryptfs_verbosity ;
#line 533
unsigned int ecryptfs_message_buf_len ;
#line 534
long ecryptfs_message_wait_timeout ;
#line 535
unsigned int ecryptfs_number_of_users ;
#line 537
struct kmem_cache *ecryptfs_auth_tok_list_item_cache ;
#line 540
struct kmem_cache *ecryptfs_inode_info_cache ;
#line 541 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_sb_info_cache  ;
#line 542
struct kmem_cache *ecryptfs_header_cache ;
#line 543
struct kmem_cache *ecryptfs_xattr_cache ;
#line 544
struct kmem_cache *ecryptfs_key_record_cache ;
#line 545
struct kmem_cache *ecryptfs_key_sig_cache ;
#line 546
struct kmem_cache *ecryptfs_global_auth_tok_cache ;
#line 547
struct kmem_cache *ecryptfs_key_tfm_cache ;
#line 573
void ecryptfs_destroy_mount_crypt_stat(struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) ;
#line 589
u8 ecryptfs_code_for_cipher_string(char *cipher_name , size_t key_bytes ) ;
#line 613
int ecryptfs_init_messaging(void) ;
#line 614
void ecryptfs_release_messaging(void) ;
#line 622
int ecryptfs_add_global_auth_tok(struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                 char *sig , u32 global_auth_tok_flags ) ;
#line 628
int ecryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm , char *cipher_name ,
                             size_t key_size ) ;
#line 630
int ecryptfs_init_crypto(void) ;
#line 631
int ecryptfs_destroy_crypto(void) ;
#line 632
int ecryptfs_tfm_exists(char *cipher_name , struct ecryptfs_key_tfm **key_tfm ) ;
#line 636
int ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key , struct ecryptfs_auth_tok **auth_tok ,
                                      char *sig ) ;
#line 666
int ecryptfs_init_kthread(void) ;
#line 667
void ecryptfs_destroy_kthread(void) ;
#line 668
int ecryptfs_privileged_open(struct file **lower_file , struct dentry *lower_dentry ,
                             struct vfsmount *lower_mnt , struct cred  const  *cred ) ;
#line 181 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
int ecryptfs_verbosity  =    0;
#line 191 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
unsigned int ecryptfs_message_buf_len  =    32U;
#line 203 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
long ecryptfs_message_wait_timeout  =    3L;
#line 216 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
unsigned int ecryptfs_number_of_users  =    4U;
#line 222 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void __ecryptfs_printk(char const   *fmt  , ...) 
{ 
  va_list args ;

  {
#line 225
  __builtin_va_start((__va_list_tag *)(& args));
#line 226
  if ((int )((signed char )*(fmt + 1UL)) == 55) {
#line 227
    if (ecryptfs_verbosity > 0) {
#line 228
      vprintk(fmt, (__va_list_tag *)(& args));
    } else {
#line 230
      vprintk(fmt, (__va_list_tag *)(& args));
    }
  } else {

  }
#line 231
  __builtin_va_end((__va_list_tag *)(& args));
#line 232
  return;
}
}
#line 255 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static int ecryptfs_init_lower_file(struct dentry *dentry , struct file **lower_file ) 
{ 
  struct cred  const  *cred ;
  int tmp ;
  struct task_struct *tmp___0 ;
  struct dentry *lower_dentry ;
  struct dentry *tmp___1 ;
  struct vfsmount *lower_mnt ;
  struct vfsmount *tmp___2 ;
  int rc ;

  {
#line 258
  tmp = debug_lockdep_rcu_enabled();
#line 258
  tmp___0 = get_current();
#line 258
  cred = tmp___0->cred;
#line 259
  tmp___1 = ecryptfs_dentry_to_lower(dentry);
#line 259
  lower_dentry = tmp___1;
#line 260
  tmp___2 = ecryptfs_dentry_to_lower_mnt(dentry);
#line 260
  lower_mnt = tmp___2;
#line 263
  rc = ecryptfs_privileged_open(lower_file, lower_dentry, lower_mnt, cred);
#line 265
  if (rc != 0) {
#line 266
    printk("\vError opening lower file for lower_dentry [0x%p] and lower_mnt [0x%p]; rc = [%d]\n",
           lower_dentry, lower_mnt, rc);
#line 269
    *lower_file = 0;
  } else {

  }
#line 271
  return (rc);
}
}
#line 274 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
int ecryptfs_get_lower_file(struct dentry *dentry , struct inode *inode ) 
{ 
  struct ecryptfs_inode_info *inode_info ;
  int count ;
  int rc ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 277
  rc = 0;
#line 279
  inode_info = ecryptfs_inode_to_private(inode);
#line 280
  ldv_mutex_lock_84(& inode_info->lower_file_mutex);
#line 281
  count = atomic_add_return(1, & inode_info->lower_file_count);
#line 282
  __ret_warn_once = count <= 0;
#line 282
  tmp___1 = __builtin_expect(__ret_warn_once != 0, 0L);
#line 282
  if (tmp___1 != 0L) {
#line 282
    __ret_warn_on = ! __warned;
#line 282
    tmp = __builtin_expect(__ret_warn_on != 0, 0L);
#line 282
    if (tmp != 0L) {
#line 282
      warn_slowpath_null("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared",
                         282);
    } else {

    }
#line 282
    tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
#line 282
    if (tmp___0 != 0L) {
#line 282
      __warned = 1;
    } else {

    }
  } else {

  }
#line 282
  tmp___2 = __builtin_expect(__ret_warn_once != 0, 0L);
#line 282
  if (tmp___2 != 0L) {
#line 283
    rc = -22;
  } else
#line 284
  if (count == 1) {
#line 285
    rc = ecryptfs_init_lower_file(dentry, & inode_info->lower_file);
#line 287
    if (rc != 0) {
#line 288
      atomic_set(& inode_info->lower_file_count, 0);
    } else {

    }
  } else {

  }
#line 290
  ldv_mutex_unlock_85(& inode_info->lower_file_mutex);
#line 291
  return (rc);
}
}
#line 294 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ecryptfs_put_lower_file(struct inode *inode ) 
{ 
  struct ecryptfs_inode_info *inode_info ;
  int tmp ;

  {
#line 298
  inode_info = ecryptfs_inode_to_private(inode);
#line 299
  tmp = ldv_atomic_dec_and_mutex_lock_86(& inode_info->lower_file_count, & inode_info->lower_file_mutex);
#line 299
  if (tmp != 0) {
#line 301
    filemap_write_and_wait(inode->i_mapping);
#line 302
    fput(inode_info->lower_file);
#line 303
    inode_info->lower_file = 0;
#line 304
    ldv_mutex_unlock_87(& inode_info->lower_file_mutex);
  } else {

  }
#line 306
  return;
}
}
#line 318 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static struct match_token  const  tokens[15U]  = 
#line 318
  {      {0, "sig=%s"}, 
        {1, "ecryptfs_sig=%s"}, 
        {2, "cipher=%s"}, 
        {3, "ecryptfs_cipher=%s"}, 
        {4, "ecryptfs_key_bytes=%u"}, 
        {5, "ecryptfs_passthrough"}, 
        {6, "ecryptfs_xattr_metadata"}, 
        {7, "ecryptfs_encrypted_view"}, 
        {8, "ecryptfs_fnek_sig=%s"}, 
        {9, "ecryptfs_fn_cipher=%s"}, 
        {10, "ecryptfs_fn_key_bytes=%u"}, 
        {11, "ecryptfs_unlink_sigs"}, 
        {12, "ecryptfs_mount_auth_tok_only"}, 
        {13, "ecryptfs_check_dev_ruid"}, 
        {14, 0}};
#line 336 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static int ecryptfs_init_global_auth_toks(struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) 
{ 
  struct ecryptfs_global_auth_tok *global_auth_tok ;
  struct ecryptfs_auth_tok *auth_tok ;
  int rc ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 341
  rc = 0;
#line 343
  __mptr = (struct list_head  const  *)mount_crypt_stat->global_auth_tok_list.next;
#line 343
  global_auth_tok = (struct ecryptfs_global_auth_tok *)__mptr + 0xfffffffffffffff8UL;
#line 343
  goto ldv_32009;
  ldv_32008: 
#line 346
  rc = ecryptfs_keyring_auth_tok_for_sig(& global_auth_tok->global_auth_tok_key, & auth_tok,
                                         (char *)(& global_auth_tok->sig));
#line 349
  if (rc != 0) {
#line 350
    printk("\vCould not find valid key in user session keyring for sig specified in mount option: [%s]\n",
           (unsigned char *)(& global_auth_tok->sig));
#line 353
    global_auth_tok->flags = global_auth_tok->flags | 1U;
#line 354
    goto out;
  } else {
#line 356
    global_auth_tok->flags = global_auth_tok->flags & 4294967294U;
#line 357
    up_write(& (global_auth_tok->global_auth_tok_key)->sem);
  }
#line 343
  __mptr___0 = (struct list_head  const  *)global_auth_tok->mount_crypt_stat_list.next;
#line 343
  global_auth_tok = (struct ecryptfs_global_auth_tok *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_32009: ;
#line 343
  if ((unsigned long )global_auth_tok != (unsigned long )mount_crypt_stat) {
#line 344
    goto ldv_32008;
  } else {

  }

  out: ;
#line 361
  return (rc);
}
}
#line 364 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static void ecryptfs_init_mount_crypt_stat(struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) 
{ 
  struct lock_class_key __key ;

  {
#line 367
  memset((void *)mount_crypt_stat, 0, 296UL);
#line 369
  INIT_LIST_HEAD(& mount_crypt_stat->global_auth_tok_list);
#line 370
  __mutex_init(& mount_crypt_stat->global_auth_tok_list_mutex, "&mount_crypt_stat->global_auth_tok_list_mutex",
               & __key);
#line 371
  mount_crypt_stat->flags = mount_crypt_stat->flags | 8U;
#line 372
  return;
}
}
#line 394 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi , char *options , uid_t *check_ruid ) 
{ 
  char *p ;
  int rc ;
  int sig_set ;
  int cipher_name_set ;
  int fn_cipher_name_set ;
  int cipher_key_bytes ;
  int cipher_key_bytes_set ;
  int fn_cipher_key_bytes ;
  int fn_cipher_key_bytes_set ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  substring_t args[3U] ;
  int token ;
  char *sig_src ;
  char *cipher_name_dst ;
  char *cipher_name_src ;
  char *fn_cipher_name_dst ;
  char *fn_cipher_name_src ;
  char *fnek_dst ;
  char *fnek_src ;
  char *cipher_key_bytes_src ;
  char *fn_cipher_key_bytes_src ;
  u8 cipher_code ;
  long tmp ;
  long tmp___0 ;
  int cipher_name_len ;
  size_t tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 398
  rc = 0;
#line 399
  sig_set = 0;
#line 400
  cipher_name_set = 0;
#line 401
  fn_cipher_name_set = 0;
#line 403
  cipher_key_bytes_set = 0;
#line 405
  fn_cipher_key_bytes_set = 0;
#line 406
  mount_crypt_stat = & sbi->mount_crypt_stat;
#line 421
  *check_ruid = 0U;
#line 423
  if ((unsigned long )options == (unsigned long )((char *)0)) {
#line 424
    rc = -22;
#line 425
    goto out;
  } else {

  }
#line 427
  ecryptfs_init_mount_crypt_stat(mount_crypt_stat);
#line 428
  goto ldv_32043;
  ldv_32062: ;
#line 429
  if ((int )((signed char )*p) == 0) {
#line 430
    goto ldv_32043;
  } else {

  }
#line 431
  token = match_token(p, (struct match_token  const  *)(& tokens), (substring_t *)(& args));
#line 432
  switch (token) {
  case 0: ;
  case 1: 
#line 435
  sig_src = args[0].from;
#line 436
  rc = ecryptfs_add_global_auth_tok(mount_crypt_stat, sig_src, 0U);
#line 438
  if (rc != 0) {
#line 439
    printk("\vError attempting to register global sig; rc = [%d]\n", rc);
#line 441
    goto out;
  } else {

  }
#line 443
  sig_set = 1;
#line 444
  goto ldv_32046;
  case 2: ;
  case 3: 
#line 447
  cipher_name_src = args[0].from;
#line 448
  cipher_name_dst = (char *)(& mount_crypt_stat->global_default_cipher_name);
#line 451
  strncpy(cipher_name_dst, (char const   *)cipher_name_src, 32UL);
#line 453
  *(cipher_name_dst + 32UL) = 0;
#line 454
  cipher_name_set = 1;
#line 455
  goto ldv_32046;
  case 4: 
#line 457
  cipher_key_bytes_src = args[0].from;
#line 458
  tmp = simple_strtol((char const   *)cipher_key_bytes_src, & cipher_key_bytes_src,
                      0U);
#line 458
  cipher_key_bytes = (int )tmp;
#line 461
  mount_crypt_stat->global_default_cipher_key_size = (size_t )cipher_key_bytes;
#line 463
  cipher_key_bytes_set = 1;
#line 464
  goto ldv_32046;
  case 5: 
#line 466
  mount_crypt_stat->flags = mount_crypt_stat->flags | 1U;
#line 468
  goto ldv_32046;
  case 6: 
#line 470
  mount_crypt_stat->flags = mount_crypt_stat->flags | 2U;
#line 472
  goto ldv_32046;
  case 7: 
#line 474
  mount_crypt_stat->flags = mount_crypt_stat->flags | 2U;
#line 476
  mount_crypt_stat->flags = mount_crypt_stat->flags | 4U;
#line 478
  goto ldv_32046;
  case 8: 
#line 480
  fnek_src = args[0].from;
#line 481
  fnek_dst = (char *)(& mount_crypt_stat->global_default_fnek_sig);
#line 483
  strncpy(fnek_dst, (char const   *)fnek_src, 16UL);
#line 484
  mount_crypt_stat->global_default_fnek_sig[16] = 0;
#line 486
  rc = ecryptfs_add_global_auth_tok(mount_crypt_stat, (char *)(& mount_crypt_stat->global_default_fnek_sig),
                                    2U);
#line 490
  if (rc != 0) {
#line 491
    printk("\vError attempting to register global fnek sig [%s]; rc = [%d]\n", (char *)(& mount_crypt_stat->global_default_fnek_sig),
           rc);
#line 495
    goto out;
  } else {

  }
#line 497
  mount_crypt_stat->flags = mount_crypt_stat->flags | 48U;
#line 500
  goto ldv_32046;
  case 9: 
#line 502
  fn_cipher_name_src = args[0].from;
#line 503
  fn_cipher_name_dst = (char *)(& mount_crypt_stat->global_default_fn_cipher_name);
#line 505
  strncpy(fn_cipher_name_dst, (char const   *)fn_cipher_name_src, 32UL);
#line 507
  mount_crypt_stat->global_default_fn_cipher_name[32] = 0U;
#line 509
  fn_cipher_name_set = 1;
#line 510
  goto ldv_32046;
  case 10: 
#line 512
  fn_cipher_key_bytes_src = args[0].from;
#line 513
  tmp___0 = simple_strtol((char const   *)fn_cipher_key_bytes_src, & fn_cipher_key_bytes_src,
                          0U);
#line 513
  fn_cipher_key_bytes = (int )tmp___0;
#line 516
  mount_crypt_stat->global_default_fn_cipher_key_bytes = (size_t )fn_cipher_key_bytes;
#line 518
  fn_cipher_key_bytes_set = 1;
#line 519
  goto ldv_32046;
  case 11: 
#line 521
  mount_crypt_stat->flags = mount_crypt_stat->flags | 8192U;
#line 522
  goto ldv_32046;
  case 12: 
#line 524
  mount_crypt_stat->flags = mount_crypt_stat->flags | 128U;
#line 526
  goto ldv_32046;
  case 13: 
#line 528
  *check_ruid = 1U;
#line 529
  goto ldv_32046;
  case 14: ;
  default: 
#line 532
  printk("\f%s: eCryptfs: unrecognized option [%s]\n", "ecryptfs_parse_options", p);
  }
  ldv_32046: ;
  ldv_32043: 
#line 428
  p = strsep(& options, ",");
#line 428
  if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 429
    goto ldv_32062;
  } else {

  }

#line 537
  if (sig_set == 0) {
#line 538
    rc = -22;
#line 539
    __ecryptfs_printk("\v%s: You must supply at least one valid auth tok signature as a mount parameter; see the eCryptfs README\n",
                      "ecryptfs_parse_options");
#line 542
    goto out;
  } else {

  }
#line 544
  if (cipher_name_set == 0) {
#line 545
    tmp___1 = strlen("aes");
#line 545
    cipher_name_len = (int )tmp___1;
#line 547
    tmp___2 = __builtin_expect(cipher_name_len > 31, 0L);
#line 547
    if (tmp___2 != 0L) {
#line 547
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"),
                           "i" (547), "i" (12UL));
      ldv_32065: ;
#line 547
      goto ldv_32065;
    } else {

    }
#line 548
    strcpy((char *)(& mount_crypt_stat->global_default_cipher_name), "aes");
  } else {

  }
#line 551
  if ((mount_crypt_stat->flags & 16U) != 0U && fn_cipher_name_set == 0) {
#line 553
    strcpy((char *)(& mount_crypt_stat->global_default_fn_cipher_name), (char const   *)(& mount_crypt_stat->global_default_cipher_name));
  } else {

  }
#line 555
  if (cipher_key_bytes_set == 0) {
#line 556
    mount_crypt_stat->global_default_cipher_key_size = 0UL;
  } else {

  }
#line 557
  if ((mount_crypt_stat->flags & 16U) != 0U && fn_cipher_key_bytes_set == 0) {
#line 559
    mount_crypt_stat->global_default_fn_cipher_key_bytes = mount_crypt_stat->global_default_cipher_key_size;
  } else {

  }
#line 562
  cipher_code = ecryptfs_code_for_cipher_string((char *)(& mount_crypt_stat->global_default_cipher_name),
                                                mount_crypt_stat->global_default_cipher_key_size);
#line 565
  if ((unsigned int )cipher_code == 0U) {
#line 566
    __ecryptfs_printk("\v%s: eCryptfs doesn\'t support cipher: %s", "ecryptfs_parse_options",
                      (unsigned char *)(& mount_crypt_stat->global_default_cipher_name));
#line 569
    rc = -22;
#line 570
    goto out;
  } else {

  }
#line 573
  ldv_mutex_lock_88(& key_tfm_list_mutex);
#line 574
  tmp___3 = ecryptfs_tfm_exists((char *)(& mount_crypt_stat->global_default_cipher_name),
                                0);
#line 574
  if (tmp___3 == 0) {
#line 576
    rc = ecryptfs_add_new_key_tfm(0, (char *)(& mount_crypt_stat->global_default_cipher_name),
                                  mount_crypt_stat->global_default_cipher_key_size);
#line 579
    if (rc != 0) {
#line 580
      printk("\vError attempting to initialize cipher with name = [%s] and key size = [%td]; rc = [%d]\n",
             (unsigned char *)(& mount_crypt_stat->global_default_cipher_name), mount_crypt_stat->global_default_cipher_key_size,
             rc);
#line 586
      rc = -22;
#line 587
      ldv_mutex_unlock_89(& key_tfm_list_mutex);
#line 588
      goto out;
    } else {

    }
  } else {

  }
#line 591
  if ((mount_crypt_stat->flags & 16U) != 0U) {
#line 591
    tmp___4 = ecryptfs_tfm_exists((char *)(& mount_crypt_stat->global_default_fn_cipher_name),
                                  0);
#line 591
    if (tmp___4 == 0) {
#line 594
      rc = ecryptfs_add_new_key_tfm(0, (char *)(& mount_crypt_stat->global_default_fn_cipher_name),
                                    mount_crypt_stat->global_default_fn_cipher_key_bytes);
#line 597
      if (rc != 0) {
#line 598
        printk("\vError attempting to initialize cipher with name = [%s] and key size = [%td]; rc = [%d]\n",
               (unsigned char *)(& mount_crypt_stat->global_default_fn_cipher_name),
               mount_crypt_stat->global_default_fn_cipher_key_bytes, rc);
#line 604
        rc = -22;
#line 605
        ldv_mutex_unlock_90(& key_tfm_list_mutex);
#line 606
        goto out;
      } else {

      }
    } else {

    }
  } else {

  }
#line 609
  ldv_mutex_unlock_91(& key_tfm_list_mutex);
#line 610
  rc = ecryptfs_init_global_auth_toks(mount_crypt_stat);
#line 611
  if (rc != 0) {
#line 612
    printk("\fOne or more global auth toks could not properly register; rc = [%d]\n",
           rc);
  } else {

  }
  out: ;
#line 615
  return (rc);
}
}
#line 619
static struct file_system_type ecryptfs_fs_type ;
#line 628 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static struct dentry *ecryptfs_mount(struct file_system_type *fs_type , int flags ,
                                     char const   *dev_name___0 , void *raw_data ) 
{ 
  struct super_block *s ;
  struct ecryptfs_sb_info *sbi ;
  struct ecryptfs_dentry_info *root_info ;
  char const   *err ;
  struct inode *inode ;
  struct path path ;
  uid_t check_ruid ;
  int rc ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  struct task_struct *tmp___3 ;
  uid_t tmp___4 ;
  uid_t tmp___5 ;
  int tmp___6 ;
  struct task_struct *tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  void *tmp___12 ;
  struct dentry *tmp___13 ;
  void *tmp___14 ;

  {
#line 634
  err = "Getting sb failed";
#line 640
  tmp = kmem_cache_zalloc(ecryptfs_sb_info_cache, 208U);
#line 640
  sbi = (struct ecryptfs_sb_info *)tmp;
#line 641
  if ((unsigned long )sbi == (unsigned long )((struct ecryptfs_sb_info *)0)) {
#line 642
    rc = -12;
#line 643
    goto out;
  } else {

  }
#line 646
  rc = ecryptfs_parse_options(sbi, (char *)raw_data, & check_ruid);
#line 647
  if (rc != 0) {
#line 648
    err = "Error parsing options";
#line 649
    goto out;
  } else {

  }
#line 652
  s = sget(fs_type, 0, & set_anon_super, flags, 0);
#line 653
  tmp___1 = IS_ERR((void const   *)s);
#line 653
  if (tmp___1 != 0L) {
#line 654
    tmp___0 = PTR_ERR((void const   *)s);
#line 654
    rc = (int )tmp___0;
#line 655
    goto out;
  } else {

  }
#line 658
  rc = bdi_setup_and_register(& sbi->bdi, (char *)"ecryptfs", 4U);
#line 659
  if (rc != 0) {
#line 660
    goto out1;
  } else {

  }
#line 662
  ecryptfs_set_superblock_private(s, sbi);
#line 663
  s->s_bdi = & sbi->bdi;
#line 666
  sbi = 0;
#line 667
  s->s_op = & ecryptfs_sops;
#line 668
  s->s_d_op = & ecryptfs_dops;
#line 670
  err = "Reading sb failed";
#line 671
  rc = kern_path(dev_name___0, 3U, & path);
#line 672
  if (rc != 0) {
#line 673
    __ecryptfs_printk("\f%s: kern_path() failed\n", "ecryptfs_mount");
#line 674
    goto out1;
  } else {

  }
#line 676
  if ((unsigned long )((path.dentry)->d_sb)->s_type == (unsigned long )(& ecryptfs_fs_type)) {
#line 677
    rc = -22;
#line 678
    printk("\vMount on filesystem of type eCryptfs explicitly disallowed due to known incompatibilities\n");
#line 681
    goto out_free;
  } else {

  }
#line 684
  if (check_ruid != 0U) {
#line 684
    tmp___6 = debug_lockdep_rcu_enabled();
#line 684
    tmp___7 = get_current();
#line 684
    tmp___8 = uid_eq(((path.dentry)->d_inode)->i_uid, (tmp___7->cred)->uid);
#line 684
    if (tmp___8) {
#line 684
      tmp___9 = 0;
    } else {
#line 684
      tmp___9 = 1;
    }
#line 684
    if (tmp___9) {
#line 685
      rc = -1;
#line 689
      tmp___2 = debug_lockdep_rcu_enabled();
#line 689
      tmp___3 = get_current();
#line 689
      tmp___4 = from_kuid(& init_user_ns, (tmp___3->cred)->uid);
#line 689
      tmp___5 = i_uid_read((struct inode  const  *)(path.dentry)->d_inode);
#line 689
      printk("\vMount of device (uid: %d) not owned by requested user (uid: %d)\n",
             tmp___5, tmp___4);
#line 690
      goto out_free;
    } else {

    }
  } else {

  }
#line 693
  ecryptfs_set_superblock_lower(s, (path.dentry)->d_sb);
#line 700
  s->s_flags = (unsigned long )(flags & -65537);
#line 701
  s->s_flags = s->s_flags | (((path.dentry)->d_sb)->s_flags & 65537UL);
#line 703
  s->s_maxbytes = ((path.dentry)->d_sb)->s_maxbytes;
#line 704
  s->s_blocksize = ((path.dentry)->d_sb)->s_blocksize;
#line 705
  s->s_magic = 61791UL;
#line 707
  inode = ecryptfs_get_inode((path.dentry)->d_inode, s);
#line 708
  tmp___10 = PTR_ERR((void const   *)inode);
#line 708
  rc = (int )tmp___10;
#line 709
  tmp___11 = IS_ERR((void const   *)inode);
#line 709
  if (tmp___11 != 0L) {
#line 710
    goto out_free;
  } else {

  }
#line 712
  s->s_root = d_make_root(inode);
#line 713
  if ((unsigned long )s->s_root == (unsigned long )((struct dentry *)0)) {
#line 714
    rc = -12;
#line 715
    goto out_free;
  } else {

  }
#line 718
  rc = -12;
#line 719
  tmp___12 = kmem_cache_zalloc(ecryptfs_dentry_info_cache, 208U);
#line 719
  root_info = (struct ecryptfs_dentry_info *)tmp___12;
#line 720
  if ((unsigned long )root_info == (unsigned long )((struct ecryptfs_dentry_info *)0)) {
#line 721
    goto out_free;
  } else {

  }
#line 724
  ecryptfs_set_dentry_private(s->s_root, root_info);
#line 725
  ecryptfs_set_dentry_lower(s->s_root, path.dentry);
#line 726
  ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);
#line 728
  s->s_flags = s->s_flags | 1073741824UL;
#line 729
  tmp___13 = dget(s->s_root);
#line 729
  return (tmp___13);
  out_free: 
#line 732
  path_put(& path);
  out1: 
#line 734
  deactivate_locked_super(s);
  out: ;
#line 736
  if ((unsigned long )sbi != (unsigned long )((struct ecryptfs_sb_info *)0)) {
#line 737
    ecryptfs_destroy_mount_crypt_stat(& sbi->mount_crypt_stat);
#line 738
    kmem_cache_free(ecryptfs_sb_info_cache, (void *)sbi);
  } else {

  }
#line 740
  printk("\v%s; rc = [%d]\n", err, rc);
#line 741
  tmp___14 = ERR_PTR((long )rc);
#line 741
  return ((struct dentry *)tmp___14);
}
}
#line 750 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static void ecryptfs_kill_block_super(struct super_block *sb ) 
{ 
  struct ecryptfs_sb_info *sb_info ;
  struct ecryptfs_sb_info *tmp ;

  {
#line 752
  tmp = ecryptfs_superblock_to_private(sb);
#line 752
  sb_info = tmp;
#line 753
  kill_anon_super(sb);
#line 754
  if ((unsigned long )sb_info == (unsigned long )((struct ecryptfs_sb_info *)0)) {
#line 755
    return;
  } else {

  }
#line 756
  ecryptfs_destroy_mount_crypt_stat(& sb_info->mount_crypt_stat);
#line 757
  bdi_destroy(& sb_info->bdi);
#line 758
  kmem_cache_free(ecryptfs_sb_info_cache, (void *)sb_info);
#line 759
  return;
}
}
#line 761 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static struct file_system_type ecryptfs_fs_type  = 
#line 761
     {"ecryptfs", 0, & ecryptfs_mount, & ecryptfs_kill_block_super, & __this_module,
    0, {0}, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
              {(char)0}}}, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                             {(char)0}, {(char)0}, {(char)0}}}, {{{(char)0}, {(char)0},
                                                                  {(char)0}, {(char)0},
                                                                  {(char)0}, {(char)0},
                                                                  {(char)0}, {(char)0}}},
    {{{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
       {(char)0}}}, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                      {(char)0}, {(char)0}}}, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                                {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
      {(char)0}}}, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                     {(char)0}, {(char)0}}}, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                               {(char)0}, {(char)0}, {(char)0}, {(char)0}}}};
#line 775 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static void inode_info_init_once(void *vptr ) 
{ 
  struct ecryptfs_inode_info *ei ;

  {
#line 777
  ei = (struct ecryptfs_inode_info *)vptr;
#line 779
  inode_init_once(& ei->vfs_inode);
#line 780
  return;
}
}
#line 787 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static struct ecryptfs_cache_info ecryptfs_cache_infos[11U]  = 
#line 787
  {      {& ecryptfs_auth_tok_list_item_cache, "ecryptfs_auth_tok_list_item", 824UL, 0}, 
        {& ecryptfs_file_info_cache,
      "ecryptfs_file_cache", 16UL, 0}, 
        {& ecryptfs_dentry_info_cache, "ecryptfs_dentry_info_cache", 24UL, 0}, 
        {& ecryptfs_inode_info_cache, "ecryptfs_inode_cache", 2104UL, & inode_info_init_once}, 
        {& ecryptfs_sb_info_cache,
      "ecryptfs_sb_cache", 1568UL, 0}, 
        {& ecryptfs_header_cache, "ecryptfs_headers", 4096UL, 0}, 
        {& ecryptfs_xattr_cache, "ecryptfs_xattr_cache", 4096UL, 0}, 
        {& ecryptfs_key_record_cache, "ecryptfs_key_record_cache", 536UL, 0}, 
        {& ecryptfs_key_sig_cache, "ecryptfs_key_sig_cache", 40UL, 0}, 
        {& ecryptfs_global_auth_tok_cache, "ecryptfs_global_auth_tok_cache", 56UL, 0}, 
        {& ecryptfs_key_tfm_cache,
      "ecryptfs_key_tfm_cache", 240UL, 0}};
#line 846 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static void ecryptfs_free_kmem_caches(void) 
{ 
  int i ;
  struct ecryptfs_cache_info *info ;

  {
#line 854
  rcu_barrier();
#line 856
  i = 0;
#line 856
  goto ldv_32114;
  ldv_32113: 
#line 859
  info = (struct ecryptfs_cache_info *)(& ecryptfs_cache_infos) + (unsigned long )i;
#line 860
  if ((unsigned long )*(info->cache) != (unsigned long )((struct kmem_cache *)0)) {
#line 861
    kmem_cache_destroy(*(info->cache));
  } else {

  }
#line 856
  i = i + 1;
  ldv_32114: ;
#line 856
  if ((unsigned int )i <= 10U) {
#line 857
    goto ldv_32113;
  } else {

  }

#line 861
  return;
}
}
#line 870 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static int ecryptfs_init_kmem_caches(void) 
{ 
  int i ;
  struct ecryptfs_cache_info *info ;

  {
#line 874
  i = 0;
#line 874
  goto ldv_32125;
  ldv_32124: 
#line 877
  info = (struct ecryptfs_cache_info *)(& ecryptfs_cache_infos) + (unsigned long )i;
#line 878
  *(info->cache) = kmem_cache_create(info->name, info->size, 0UL, 8192UL, info->ctor);
#line 880
  if ((unsigned long )*(info->cache) == (unsigned long )((struct kmem_cache *)0)) {
#line 881
    ecryptfs_free_kmem_caches();
#line 882
    __ecryptfs_printk("\f%s: %s: kmem_cache_create failed\n", "ecryptfs_init_kmem_caches",
                      info->name);
#line 885
    return (-12);
  } else {

  }
#line 874
  i = i + 1;
  ldv_32125: ;
#line 874
  if ((unsigned int )i <= 10U) {
#line 875
    goto ldv_32124;
  } else {

  }

#line 888
  return (0);
}
}
#line 891 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static struct kobject *ecryptfs_kobj  ;
#line 893 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static ssize_t version_show(struct kobject *kobj , struct kobj_attribute *attr , char *buff ) 
{ 
  int tmp ;

  {
#line 896
  tmp = snprintf(buff, 4096UL, "%d\n", 375);
#line 896
  return ((ssize_t )tmp);
}
}
#line 899 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static struct kobj_attribute version_attr  =    {{"version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                     {(char)0}, {(char)0}, {(char)0}}}}, & version_show,
    0};
#line 901 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static struct attribute *attributes[2U]  = {      & version_attr.attr,      0};
#line 906 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static struct attribute_group attr_group  =    {0, 0, (struct attribute **)(& attributes)};
#line 910 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static int do_sysfs_registration(void) 
{ 
  int rc ;

  {
#line 914
  ecryptfs_kobj = kobject_create_and_add("ecryptfs", fs_kobj);
#line 915
  if ((unsigned long )ecryptfs_kobj == (unsigned long )((struct kobject *)0)) {
#line 916
    printk("\vUnable to create ecryptfs kset\n");
#line 917
    rc = -12;
#line 918
    goto out;
  } else {

  }
#line 920
  rc = sysfs_create_group(ecryptfs_kobj, (struct attribute_group  const  *)(& attr_group));
#line 921
  if (rc != 0) {
#line 922
    printk("\vUnable to create ecryptfs version attributes\n");
#line 924
    kobject_put(ecryptfs_kobj);
  } else {

  }
  out: ;
#line 927
  return (rc);
}
}
#line 930 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static void do_sysfs_unregistration(void) 
{ 


  {
#line 932
  sysfs_remove_group(ecryptfs_kobj, (struct attribute_group  const  *)(& attr_group));
#line 933
  kobject_put(ecryptfs_kobj);
#line 934
  return;
}
}
#line 936 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static int ecryptfs_init(void) 
{ 
  int rc ;

  {
#line 951
  rc = ecryptfs_init_kmem_caches();
#line 952
  if (rc != 0) {
#line 953
    printk("\vFailed to allocate one or more kmem_cache objects\n");
#line 955
    goto out;
  } else {

  }
#line 957
  rc = do_sysfs_registration();
#line 958
  if (rc != 0) {
#line 959
    printk("\vsysfs registration failed\n");
#line 960
    goto out_free_kmem_caches;
  } else {

  }
#line 962
  rc = ecryptfs_init_kthread();
#line 963
  if (rc != 0) {
#line 964
    printk("\v%s: kthread initialization failed; rc = [%d]\n", "ecryptfs_init", rc);
#line 966
    goto out_do_sysfs_unregistration;
  } else {

  }
#line 968
  rc = ecryptfs_init_messaging();
#line 969
  if (rc != 0) {
#line 970
    printk("\vFailure occurred while attempting to initialize the communications channel to ecryptfsd\n");
#line 973
    goto out_destroy_kthread;
  } else {

  }
#line 975
  rc = ecryptfs_init_crypto();
#line 976
  if (rc != 0) {
#line 977
    printk("\vFailure whilst attempting to init crypto; rc = [%d]\n", rc);
#line 979
    goto out_release_messaging;
  } else {

  }
#line 981
  rc = register_filesystem(& ecryptfs_fs_type);
#line 982
  if (rc != 0) {
#line 983
    printk("\vFailed to register filesystem\n");
#line 984
    goto out_destroy_crypto;
  } else {

  }
#line 986
  if (ecryptfs_verbosity > 0) {
#line 987
    printk("\neCryptfs verbosity set to %d. Secret values will be written to the syslog!\n",
           ecryptfs_verbosity);
  } else {

  }
#line 990
  goto out;
  out_destroy_crypto: 
#line 992
  ecryptfs_destroy_crypto();
  out_release_messaging: 
#line 994
  ecryptfs_release_messaging();
  out_destroy_kthread: 
#line 996
  ecryptfs_destroy_kthread();
  out_do_sysfs_unregistration: 
#line 998
  do_sysfs_unregistration();
  out_free_kmem_caches: 
#line 1000
  ecryptfs_free_kmem_caches();
  out: ;
#line 1002
  return (rc);
}
}
#line 1005 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
static void ecryptfs_exit(void) 
{ 
  int rc ;

  {
#line 1009
  rc = ecryptfs_destroy_crypto();
#line 1010
  if (rc != 0) {
#line 1011
    printk("\vFailure whilst attempting to destroy crypto; rc = [%d]\n", rc);
  } else {

  }
#line 1013
  ecryptfs_release_messaging();
#line 1014
  ecryptfs_destroy_kthread();
#line 1015
  do_sysfs_unregistration();
#line 1016
  unregister_filesystem(& ecryptfs_fs_type);
#line 1017
  ecryptfs_free_kmem_caches();
#line 1018
  return;
}
}
#line 1065 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_main3_sequence_infinite_withcheck_stateful(void) 
{ 
  struct file_system_type *var_group1 ;
  int var_ecryptfs_mount_6_p1 ;
  char const   *var_ecryptfs_mount_6_p2 ;
  void *var_ecryptfs_mount_6_p3 ;
  struct super_block *var_group2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1093
  LDV_IN_INTERRUPT = 1;
#line 1102
  ldv_initialize();
#line 1108
  ldv_handler_precall();
#line 1109
  tmp = ecryptfs_init();
#line 1109
  if (tmp != 0) {
#line 1110
    goto ldv_final;
  } else {

  }
#line 1114
  goto ldv_32199;
  ldv_32198: 
#line 1117
  tmp___0 = __VERIFIER_nondet_int();
#line 1117
  switch (tmp___0) {
  case 0: 
#line 1127
  ldv_handler_precall();
#line 1128
  ecryptfs_mount(var_group1, var_ecryptfs_mount_6_p1, var_ecryptfs_mount_6_p2, var_ecryptfs_mount_6_p3);
#line 1135
  goto ldv_32195;
  case 1: 
#line 1144
  ldv_handler_precall();
#line 1145
  ecryptfs_kill_block_super(var_group2);
#line 1152
  goto ldv_32195;
  default: ;
#line 1153
  goto ldv_32195;
  }
  ldv_32195: ;
  ldv_32199: 
#line 1114
  tmp___1 = __VERIFIER_nondet_int();
#line 1114
  if (tmp___1 != 0) {
#line 1115
    goto ldv_32198;
  } else {

  }

#line 1165
  ldv_handler_precall();
#line 1166
  ecryptfs_exit();
  ldv_final: 
#line 1169
  ldv_check_final_state();
#line 1172
  return;
}
}
#line 1176 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1181
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1183
  mutex_lock(ldv_func_arg1);
#line 1184
  return;
}
}
#line 1186 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1191
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1193
  mutex_unlock(ldv_func_arg1);
#line 1194
  return;
}
}
#line 1196 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_lock_79(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1201
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 1203
  mutex_lock(ldv_func_arg1);
#line 1204
  return;
}
}
#line 1206 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
int ldv_mutex_trylock_80(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1211
  tmp = mutex_trylock(ldv_func_arg1);
#line 1211
  ldv_func_res = tmp;
#line 1213
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 1213
  return (tmp___0);
#line 1215
  return (ldv_func_res);
}
}
#line 1218 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1223
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 1225
  mutex_unlock(ldv_func_arg1);
#line 1226
  return;
}
}
#line 1228 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_lock_82(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1233
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1235
  mutex_lock(ldv_func_arg1);
#line 1236
  return;
}
}
#line 1238 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_unlock_83(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1243
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1245
  mutex_unlock(ldv_func_arg1);
#line 1246
  return;
}
}
#line 1248 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_lock_84(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1253
  ldv_mutex_lock_lower_file_mutex(ldv_func_arg1);
#line 1255
  mutex_lock(ldv_func_arg1);
#line 1256
  return;
}
}
#line 1258 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_unlock_85(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1263
  ldv_mutex_unlock_lower_file_mutex(ldv_func_arg1);
#line 1265
  mutex_unlock(ldv_func_arg1);
#line 1266
  return;
}
}
#line 1268 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
int ldv_atomic_dec_and_mutex_lock_86(atomic_t *ldv_func_arg1 , struct mutex *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1274
  tmp = atomic_dec_and_mutex_lock(ldv_func_arg1, ldv_func_arg2);
#line 1274
  ldv_func_res = tmp;
#line 1276
  tmp___0 = ldv_atomic_dec_and_mutex_lock_lower_file_count(ldv_func_arg1, ldv_func_arg2);
#line 1276
  return (tmp___0);
#line 1278
  return (ldv_func_res);
}
}
#line 1281 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_unlock_87(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1286
  ldv_mutex_unlock_lower_file_mutex(ldv_func_arg1);
#line 1288
  mutex_unlock(ldv_func_arg1);
#line 1289
  return;
}
}
#line 1291 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_lock_88(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1296
  ldv_mutex_lock_key_tfm_list_mutex(ldv_func_arg1);
#line 1298
  mutex_lock(ldv_func_arg1);
#line 1299
  return;
}
}
#line 1301 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_unlock_89(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1306
  ldv_mutex_unlock_key_tfm_list_mutex(ldv_func_arg1);
#line 1308
  mutex_unlock(ldv_func_arg1);
#line 1309
  return;
}
}
#line 1311 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1316
  ldv_mutex_unlock_key_tfm_list_mutex(ldv_func_arg1);
#line 1318
  mutex_unlock(ldv_func_arg1);
#line 1319
  return;
}
}
#line 1321 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/main.c.prepared"
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1326
  ldv_mutex_unlock_key_tfm_list_mutex(ldv_func_arg1);
#line 1328
  mutex_unlock(ldv_func_arg1);
#line 1329
  return;
}
}
#line 172 "include/linux/mutex.h"
void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_112(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
void ldv_mutex_lock_107(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_109(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_111(struct mutex *ldv_func_arg1 ) ;
#line 71
void ldv_mutex_lock_global_auth_tok_list_mutex(struct mutex *lock ) ;
#line 75
void ldv_mutex_unlock_global_auth_tok_list_mutex(struct mutex *lock ) ;
#line 166 "include/linux/rcupdate.h"
extern void call_rcu_sched(struct callback_head * , void (*)(struct callback_head * ) ) ;
#line 2326 "include/linux/fs.h"
extern void clear_inode(struct inode * ) ;
#line 92 "include/linux/seq_file.h"
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 1523 "include/linux/mm.h"
extern void truncate_inode_pages(struct address_space * , loff_t  ) ;
#line 540 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_inode_info_cache  ;
#line 572
void ecryptfs_destroy_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat ) ;
#line 684
int ecryptfs_set_f_namelen(long *namelen , long lower_namelen , struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) ;
#line 187 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
static struct inode *ecryptfs_alloc_inode(struct super_block *sb ) 
{ 
  struct ecryptfs_inode_info *inode_info ;
  struct inode *inode ;
  void *tmp ;
  long tmp___0 ;
  struct lock_class_key __key ;

  {
#line 190
  inode = 0;
#line 192
  tmp = kmem_cache_alloc(ecryptfs_inode_info_cache, 208U);
#line 192
  inode_info = (struct ecryptfs_inode_info *)tmp;
#line 193
  tmp___0 = __builtin_expect((unsigned long )inode_info == (unsigned long )((struct ecryptfs_inode_info *)0),
                             0L);
#line 193
  if (tmp___0 != 0L) {
#line 194
    goto out;
  } else {

  }
#line 195
  ecryptfs_init_crypt_stat(& inode_info->crypt_stat);
#line 196
  __mutex_init(& inode_info->lower_file_mutex, "&inode_info->lower_file_mutex", & __key);
#line 197
  atomic_set(& inode_info->lower_file_count, 0);
#line 198
  inode_info->lower_file = 0;
#line 199
  inode = & inode_info->vfs_inode;
  out: ;
#line 201
  return (inode);
}
}
#line 204 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
static void ecryptfs_i_callback(struct callback_head *head ) 
{ 
  struct inode *inode ;
  struct callback_head  const  *__mptr ;
  struct ecryptfs_inode_info *inode_info ;

  {
#line 206
  __mptr = (struct callback_head  const  *)head;
#line 206
  inode = (struct inode *)__mptr + 0xfffffffffffffe28UL;
#line 208
  inode_info = ecryptfs_inode_to_private(inode);
#line 210
  kmem_cache_free(ecryptfs_inode_info_cache, (void *)inode_info);
#line 211
  return;
}
}
#line 222 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
static void ecryptfs_destroy_inode(struct inode *inode ) 
{ 
  struct ecryptfs_inode_info *inode_info ;
  long tmp ;

  {
#line 226
  inode_info = ecryptfs_inode_to_private(inode);
#line 227
  tmp = __builtin_expect((unsigned long )inode_info->lower_file != (unsigned long )((struct file *)0),
                         0L);
#line 227
  if (tmp != 0L) {
#line 227
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"),
                         "i" (227), "i" (12UL));
    ldv_25976: ;
#line 227
    goto ldv_25976;
  } else {

  }
#line 228
  ecryptfs_destroy_crypt_stat(& inode_info->crypt_stat);
#line 229
  call_rcu_sched(& inode->ldv_13360.i_rcu, & ecryptfs_i_callback);
#line 230
  return;
}
}
#line 240 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
static int ecryptfs_statfs(struct dentry *dentry , struct kstatfs *buf ) 
{ 
  struct dentry *lower_dentry ;
  struct dentry *tmp ;
  int rc ;
  struct ecryptfs_sb_info *tmp___0 ;

  {
#line 242
  tmp = ecryptfs_dentry_to_lower(dentry);
#line 242
  lower_dentry = tmp;
#line 245
  if ((unsigned long )((lower_dentry->d_sb)->s_op)->statfs == (unsigned long )((int (*/* const  */)(struct dentry * ,
                                                                                                    struct kstatfs * ))0)) {
#line 246
    return (-38);
  } else {

  }
#line 248
  rc = (*(((lower_dentry->d_sb)->s_op)->statfs))(lower_dentry, buf);
#line 249
  if (rc != 0) {
#line 250
    return (rc);
  } else {

  }
#line 252
  buf->f_type = 61791L;
#line 253
  tmp___0 = ecryptfs_superblock_to_private(dentry->d_sb);
#line 253
  rc = ecryptfs_set_f_namelen(& buf->f_namelen, buf->f_namelen, & tmp___0->mount_crypt_stat);
#line 256
  return (rc);
}
}
#line 269 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
static void ecryptfs_evict_inode(struct inode *inode ) 
{ 
  struct inode *tmp ;

  {
#line 271
  truncate_inode_pages(& inode->i_data, 0LL);
#line 272
  clear_inode(inode);
#line 273
  tmp = ecryptfs_inode_to_lower(inode);
#line 273
  iput(tmp);
#line 274
  return;
}
}
#line 282 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
static int ecryptfs_show_options(struct seq_file *m , struct dentry *root ) 
{ 
  struct super_block *sb ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct ecryptfs_sb_info *tmp ;
  struct ecryptfs_global_auth_tok *walker ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 284
  sb = root->d_sb;
#line 285
  tmp = ecryptfs_superblock_to_private(sb);
#line 285
  mount_crypt_stat = & tmp->mount_crypt_stat;
#line 289
  ldv_mutex_lock_111(& mount_crypt_stat->global_auth_tok_list_mutex);
#line 290
  __mptr = (struct list_head  const  *)mount_crypt_stat->global_auth_tok_list.next;
#line 290
  walker = (struct ecryptfs_global_auth_tok *)__mptr + 0xfffffffffffffff8UL;
#line 290
  goto ldv_25998;
  ldv_25997: ;
#line 293
  if ((walker->flags & 2U) != 0U) {
#line 294
    seq_printf(m, ",ecryptfs_fnek_sig=%s", (unsigned char *)(& walker->sig));
  } else {
#line 296
    seq_printf(m, ",ecryptfs_sig=%s", (unsigned char *)(& walker->sig));
  }
#line 290
  __mptr___0 = (struct list_head  const  *)walker->mount_crypt_stat_list.next;
#line 290
  walker = (struct ecryptfs_global_auth_tok *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_25998: ;
#line 290
  if ((unsigned long )walker != (unsigned long )mount_crypt_stat) {
#line 291
    goto ldv_25997;
  } else {

  }
#line 298
  ldv_mutex_unlock_112(& mount_crypt_stat->global_auth_tok_list_mutex);
#line 300
  seq_printf(m, ",ecryptfs_cipher=%s", (unsigned char *)(& mount_crypt_stat->global_default_cipher_name));
#line 303
  if (mount_crypt_stat->global_default_cipher_key_size != 0UL) {
#line 304
    seq_printf(m, ",ecryptfs_key_bytes=%zd", mount_crypt_stat->global_default_cipher_key_size);
  } else {

  }
#line 306
  if ((int )mount_crypt_stat->flags & 1) {
#line 307
    seq_printf(m, ",ecryptfs_passthrough");
  } else {

  }
#line 308
  if ((mount_crypt_stat->flags & 2U) != 0U) {
#line 309
    seq_printf(m, ",ecryptfs_xattr_metadata");
  } else {

  }
#line 310
  if ((mount_crypt_stat->flags & 4U) != 0U) {
#line 311
    seq_printf(m, ",ecryptfs_encrypted_view");
  } else {

  }
#line 312
  if ((mount_crypt_stat->flags & 8192U) != 0U) {
#line 313
    seq_printf(m, ",ecryptfs_unlink_sigs");
  } else {

  }
#line 314
  if ((mount_crypt_stat->flags & 128U) != 0U) {
#line 315
    seq_printf(m, ",ecryptfs_mount_auth_tok_only");
  } else {

  }
#line 317
  return (0);
}
}
#line 320 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
struct super_operations  const  ecryptfs_sops  = 
#line 320
     {& ecryptfs_alloc_inode, & ecryptfs_destroy_inode, 0, 0, 0, & ecryptfs_evict_inode,
    0, 0, 0, 0, & ecryptfs_statfs, 0, 0, & ecryptfs_show_options, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 366 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
void ldv_main4_sequence_infinite_withcheck_stateful(void) 
{ 
  struct super_block *var_group1 ;
  struct inode *var_group2 ;
  struct dentry *var_group3 ;
  struct kstatfs *var_group4 ;
  struct seq_file *var_group5 ;
  int tmp ;
  int tmp___0 ;

  {
#line 400
  LDV_IN_INTERRUPT = 1;
#line 409
  ldv_initialize();
#line 413
  goto ldv_26030;
  ldv_26029: 
#line 416
  tmp = __VERIFIER_nondet_int();
#line 416
  switch (tmp) {
  case 0: 
#line 426
  ldv_handler_precall();
#line 427
  ecryptfs_alloc_inode(var_group1);
#line 434
  goto ldv_26023;
  case 1: 
#line 443
  ldv_handler_precall();
#line 444
  ecryptfs_destroy_inode(var_group2);
#line 451
  goto ldv_26023;
  case 2: 
#line 460
  ldv_handler_precall();
#line 461
  ecryptfs_statfs(var_group3, var_group4);
#line 468
  goto ldv_26023;
  case 3: 
#line 477
  ldv_handler_precall();
#line 478
  ecryptfs_evict_inode(var_group2);
#line 485
  goto ldv_26023;
  case 4: 
#line 494
  ldv_handler_precall();
#line 495
  ecryptfs_show_options(var_group5, var_group3);
#line 502
  goto ldv_26023;
  default: ;
#line 503
  goto ldv_26023;
  }
  ldv_26023: ;
  ldv_26030: 
#line 413
  tmp___0 = __VERIFIER_nondet_int();
#line 413
  if (tmp___0 != 0) {
#line 414
    goto ldv_26029;
  } else {

  }


#line 512
  ldv_check_final_state();
#line 515
  return;
}
}
#line 519 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
void ldv_mutex_lock_107(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 524
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 526
  mutex_lock(ldv_func_arg1);
#line 527
  return;
}
}
#line 529 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 534
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 536
  mutex_unlock(ldv_func_arg1);
#line 537
  return;
}
}
#line 539 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
void ldv_mutex_lock_109(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 544
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 546
  mutex_lock(ldv_func_arg1);
#line 547
  return;
}
}
#line 549 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
void ldv_mutex_unlock_110(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 554
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 556
  mutex_unlock(ldv_func_arg1);
#line 557
  return;
}
}
#line 559 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
void ldv_mutex_lock_111(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 564
  ldv_mutex_lock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 566
  mutex_lock(ldv_func_arg1);
#line 567
  return;
}
}
#line 569 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/super.c.prepared"
void ldv_mutex_unlock_112(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 574
  ldv_mutex_unlock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 576
  mutex_unlock(ldv_func_arg1);
#line 577
  return;
}
}
#line 62 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static void set_bit(unsigned int nr , unsigned long volatile   *addr ) 
{ 


  {
#line 70
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 72
  return;
}
}
#line 100 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(int nr , unsigned long volatile   *addr ) 
{ 


  {
#line 107
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 109
  return;
}
}
#line 197 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 201
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2,%1\n\tsbb %0,%0": "=r" (oldbit),
                       "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 204
  return (oldbit);
}
}
#line 215 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit_lock(int nr , unsigned long volatile   *addr ) 
{ 
  int tmp ;

  {
#line 217
  tmp = test_and_set_bit(nr, addr);
#line 217
  return (tmp);
}
}
#line 318 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(unsigned int nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 320
  return ((int )((unsigned long )*(addr + (unsigned long )(nr / 64U)) >> ((int )nr & 63)) & 1);
}
}
#line 14 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 152 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 172 "include/linux/mutex.h"
void ldv_mutex_unlock_120(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
void ldv_mutex_lock_119(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_121(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_123(struct mutex *ldv_func_arg1 ) ;
#line 208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info___0(void) 
{ 
  struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
#line 211
  switch (8UL) {
  case 1UL: 
#line 211
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6379;
  case 2UL: 
#line 211
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6379;
  case 4UL: 
#line 211
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6379;
  case 8UL: 
#line 211
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6379;
  default: 
#line 211
  __bad_percpu_size();
  }
  ldv_6379: 
#line 211
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
#line 213
  return (ti);
}
}
#line 280 "include/linux/page-flags.h"
__inline static int PageUptodate(struct page *page ) 
{ 
  int ret ;
  int tmp ;

  {
#line 282
  tmp = constant_test_bit(3U, (unsigned long const volatile   *)(& page->flags));
#line 282
  ret = tmp;
#line 292
  if (ret != 0) {
#line 293
    __asm__  volatile   ("": : : "memory");
  } else {

  }
#line 295
  return (ret);
}
}
#line 304 "include/linux/page-flags.h"
__inline static void SetPageUptodate(struct page *page ) 
{ 


  {
#line 318
  __asm__  volatile   ("": : : "memory");
#line 319
  set_bit(3U, (unsigned long volatile   *)(& page->flags));
#line 320
  return;
}
}
#line 323 "include/linux/page-flags.h"
__inline static void ClearPageUptodate(struct page *page ) 
{ 


  {
#line 323
  clear_bit(3, (unsigned long volatile   *)(& page->flags));
#line 324
  return;
}
}
#line 453 "include/linux/mm.h"
extern void put_page(struct page * ) ;
#line 771 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 773
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 80L) << 12) + 0xffff880000000000UL));
}
}
#line 16 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 
  struct thread_info *tmp ;

  {
#line 18
  tmp = current_thread_info___0();
#line 18
  tmp->preempt_count = tmp->preempt_count + 1;
#line 23
  __asm__  volatile   ("": : : "memory");
#line 24
  return;
}
}
#line 26 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 
  struct thread_info *tmp ;

  {
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  tmp = current_thread_info___0();
#line 33
  tmp->preempt_count = tmp->preempt_count + -1;
#line 37
  __asm__  volatile   ("": : : "memory");
#line 38
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
#line 68
  pagefault_disable();
#line 69
  tmp = lowmem_page_address((struct page  const  *)page);
#line 69
  return (tmp);
}
}
#line 73 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
#line 75
  pagefault_enable();
#line 76
  return;
}
}
#line 192 "include/linux/highmem.h"
__inline static void zero_user_segments(struct page *page , unsigned int start1 ,
                                        unsigned int end1 , unsigned int start2 ,
                                        unsigned int end2 ) 
{ 
  void *kaddr ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 196
  tmp = kmap_atomic(page);
#line 196
  kaddr = tmp;
#line 198
  tmp___0 = __builtin_expect(end1 > 4096U, 0L);
#line 198
  if (tmp___0 != 0L) {
#line 198
    goto _L;
  } else {
#line 198
    tmp___1 = __builtin_expect(end2 > 4096U, 0L);
#line 198
    if (tmp___1 != 0L) {
      _L: /* CIL Label */ 
#line 198
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/highmem.h"),
                           "i" (198), "i" (12UL));
      ldv_20290: ;
#line 198
      goto ldv_20290;
    } else {

    }
  }
#line 200
  if (end1 > start1) {
#line 201
    memset(kaddr + (unsigned long )start1, 0, (size_t )(end1 - start1));
  } else {

  }
#line 203
  if (end2 > start2) {
#line 204
    memset(kaddr + (unsigned long )start2, 0, (size_t )(end2 - start2));
  } else {

  }
#line 206
  __kunmap_atomic(kaddr);
#line 207
  return;
}
}
#line 210 "include/linux/highmem.h"
__inline static void zero_user_segment(struct page *page , unsigned int start , unsigned int end ) 
{ 


  {
#line 213
  zero_user_segments(page, start, end, 0U, 0U);
#line 214
  return;
}
}
#line 216 "include/linux/highmem.h"
__inline static void zero_user(struct page *page , unsigned int start , unsigned int size ) 
{ 


  {
#line 219
  zero_user_segments(page, start, start + size, 0U, 0U);
#line 220
  return;
}
}
#line 259 "include/linux/pagemap.h"
extern struct page *grab_cache_page_write_begin(struct address_space * , unsigned long  ,
                                                unsigned int  ) ;
#line 275
extern struct page *read_cache_page(struct address_space * , unsigned long  , filler_t * ,
                                    void * ) ;
#line 290 "include/linux/pagemap.h"
__inline static struct page *read_mapping_page(struct address_space *mapping , unsigned long index ,
                                               void *data ) 
{ 
  filler_t *filler ;
  struct page *tmp ;

  {
#line 293
  filler = (filler_t *)(mapping->a_ops)->readpage;
#line 294
  tmp = read_cache_page(mapping, index, filler, data);
#line 294
  return (tmp);
}
}
#line 324
extern void __lock_page(struct page * ) ;
#line 328
extern void unlock_page(struct page * ) ;
#line 340 "include/linux/pagemap.h"
__inline static int trylock_page(struct page *page ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 342
  tmp = test_and_set_bit_lock(0, (unsigned long volatile   *)(& page->flags));
#line 342
  tmp___0 = __builtin_expect(tmp == 0, 1L);
#line 342
  return ((int )tmp___0);
}
}
#line 348 "include/linux/pagemap.h"
__inline static void lock_page(struct page *page ) 
{ 
  int tmp ;

  {
#line 350
  __might_sleep("include/linux/pagemap.h", 350, 0);
#line 351
  tmp = trylock_page(page);
#line 351
  if (tmp == 0) {
#line 352
    __lock_page(page);
  } else {

  }
#line 353
  return;
}
}
#line 62 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_be64(u64 val , void *p ) 
{ 
  __u64 tmp ;

  {
#line 64
  tmp = __fswab64(val);
#line 64
  *((__be64 *)p) = tmp;
#line 65
  return;
}
}
#line 543 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_xattr_cache  ;
#line 577
int ecryptfs_encrypt_page(struct page *page ) ;
#line 578
int ecryptfs_decrypt_page(struct page *page ) ;
#line 583
void ecryptfs_write_crypt_stat_flags(char *page_virt , struct ecryptfs_crypt_stat *crypt_stat ,
                                     size_t *written ) ;
#line 606
int ecryptfs_read_xattr_region(char *page_virt , struct inode *ecryptfs_inode ) ;
#line 617
void ecryptfs_write_header_metadata(char *virt , struct ecryptfs_crypt_stat *crypt_stat ,
                                    size_t *written ) ;
#line 639
int ecryptfs_write_lower(struct inode *ecryptfs_inode , char *data , loff_t offset ,
                         size_t size ) ;
#line 641
int ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode , struct page *page_for_lower ,
                                      size_t offset_in_page , size_t size ) ;
#line 647
int ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs , unsigned long page_index___0 ,
                                     size_t offset_in_page , size_t size , struct inode *ecryptfs_inode ) ;
#line 651
struct page *ecryptfs_get_locked_page(struct inode *inode , loff_t index ) ;
#line 183 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
struct page *ecryptfs_get_locked_page(struct inode *inode , loff_t index ) 
{ 
  struct page *page ;
  struct page *tmp ;
  long tmp___0 ;

  {
#line 185
  tmp = read_mapping_page(inode->i_mapping, (unsigned long )index, 0);
#line 185
  page = tmp;
#line 186
  tmp___0 = IS_ERR((void const   *)page);
#line 186
  if (tmp___0 == 0L) {
#line 187
    lock_page(page);
  } else {

  }
#line 188
  return (page);
}
}
#line 201 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static int ecryptfs_writepage(struct page *page , struct writeback_control *wbc ) 
{ 
  int rc ;

  {
#line 205
  rc = ecryptfs_encrypt_page(page);
#line 206
  if (rc != 0) {
#line 207
    __ecryptfs_printk("\f%s: Error encrypting page (upper index [0x%.16lx])\n", "ecryptfs_writepage",
                      page->ldv_18093.ldv_18077.index);
#line 209
    ClearPageUptodate(page);
#line 210
    goto out;
  } else {

  }
#line 212
  SetPageUptodate(page);
  out: 
#line 214
  unlock_page(page);
#line 215
  return (rc);
}
}
#line 218 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static void strip_xattr_flag(char *page_virt , struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  size_t written ;

  {
#line 221
  if ((crypt_stat->flags & 128U) != 0U) {
#line 224
    crypt_stat->flags = crypt_stat->flags & 4294967167U;
#line 225
    ecryptfs_write_crypt_stat_flags(page_virt, crypt_stat, & written);
#line 227
    crypt_stat->flags = crypt_stat->flags | 128U;
  } else {

  }
#line 229
  return;
}
}
#line 258 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static int ecryptfs_copy_up_encrypted_with_header(struct page *page , struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  loff_t extent_num_in_page ;
  loff_t num_extents_per_page ;
  int rc ;
  loff_t view_extent_num ;
  size_t num_header_extents_at_front ;
  char *page_virt ;
  void *tmp ;
  size_t written ;
  loff_t lower_offset ;

  {
#line 261
  extent_num_in_page = 0LL;
#line 262
  num_extents_per_page = (loff_t )(4096UL / crypt_stat->extent_size);
#line 264
  rc = 0;
#line 266
  goto ldv_27289;
  ldv_27288: 
#line 267
  view_extent_num = (long long )page->ldv_18093.ldv_18077.index * num_extents_per_page + extent_num_in_page;
#line 270
  num_header_extents_at_front = crypt_stat->metadata_size / crypt_stat->extent_size;
#line 273
  if ((unsigned long long )view_extent_num < (unsigned long long )num_header_extents_at_front) {
#line 277
    tmp = kmap_atomic(page);
#line 277
    page_virt = (char *)tmp;
#line 278
    memset((void *)page_virt, 0, 4096UL);
#line 280
    if (view_extent_num == 0LL) {
#line 283
      rc = ecryptfs_read_xattr_region(page_virt, (page->mapping)->host);
#line 285
      strip_xattr_flag(page_virt + 16UL, crypt_stat);
#line 286
      ecryptfs_write_header_metadata(page_virt + 20UL, crypt_stat, & written);
    } else {

    }
#line 290
    __kunmap_atomic((void *)page_virt);
#line 292
    if (rc != 0) {
#line 293
      printk("\v%s: Error reading xattr region; rc = [%d]\n", "ecryptfs_copy_up_encrypted_with_header",
             rc);
#line 295
      goto out;
    } else {

    }
  } else {
#line 299
    lower_offset = (loff_t )((unsigned long long )crypt_stat->extent_size * (unsigned long long )view_extent_num - (unsigned long long )crypt_stat->metadata_size);
#line 303
    rc = ecryptfs_read_lower_page_segment(page, (unsigned long )(lower_offset >> 12),
                                          (size_t )lower_offset & 4095UL, crypt_stat->extent_size,
                                          (page->mapping)->host);
#line 307
    if (rc != 0) {
#line 308
      printk("\v%s: Error attempting to read extent at offset [%lld] in the lower file; rc = [%d]\n",
             "ecryptfs_copy_up_encrypted_with_header", lower_offset, rc);
#line 312
      goto out;
    } else {

    }
  }
#line 315
  extent_num_in_page = extent_num_in_page + 1LL;
  ldv_27289: ;
#line 266
  if (extent_num_in_page < num_extents_per_page) {
#line 267
    goto ldv_27288;
  } else {

  }

  out: ;
#line 318
  return (rc);
}
}
#line 330 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static int ecryptfs_readpage(struct file *file , struct page *page ) 
{ 
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_inode_info *tmp ;
  int rc ;

  {
#line 332
  tmp = ecryptfs_inode_to_private((page->mapping)->host);
#line 332
  crypt_stat = & tmp->crypt_stat;
#line 334
  rc = 0;
#line 336
  if ((unsigned long )crypt_stat == (unsigned long )((struct ecryptfs_crypt_stat *)0) || (crypt_stat->flags & 4U) == 0U) {
#line 337
    rc = ecryptfs_read_lower_page_segment(page, page->ldv_18093.ldv_18077.index, 0UL,
                                          4096UL, (page->mapping)->host);
  } else
#line 340
  if ((crypt_stat->flags & 256U) != 0U) {
#line 341
    if ((crypt_stat->flags & 128U) != 0U) {
#line 342
      rc = ecryptfs_copy_up_encrypted_with_header(page, crypt_stat);
#line 344
      if (rc != 0) {
#line 345
        printk("\v%s: Error attempting to copy the encrypted content from the lower file whilst inserting the metadata from the xattr into the header; rc = [%d]\n",
               "ecryptfs_readpage", rc);
#line 350
        goto out;
      } else {

      }
    } else {
#line 354
      rc = ecryptfs_read_lower_page_segment(page, page->ldv_18093.ldv_18077.index,
                                            0UL, 4096UL, (page->mapping)->host);
#line 357
      if (rc != 0) {
#line 358
        printk("\vError reading page; rc = [%d]\n", rc);
#line 360
        goto out;
      } else {

      }
    }
  } else {
#line 364
    rc = ecryptfs_decrypt_page(page);
#line 365
    if (rc != 0) {
#line 366
      __ecryptfs_printk("\v%s: Error decrypting page; rc = [%d]\n", "ecryptfs_readpage",
                        rc);
#line 368
      goto out;
    } else {

    }
  }
  out: ;
#line 372
  if (rc != 0) {
#line 373
    ClearPageUptodate(page);
  } else {
#line 375
    SetPageUptodate(page);
  }
#line 376
  __ecryptfs_printk("\017%s: Unlocking page with index = [0x%.16lx]\n", "ecryptfs_readpage",
                    page->ldv_18093.ldv_18077.index);
#line 378
  unlock_page(page);
#line 379
  return (rc);
}
}
#line 385 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static int fill_zeros_to_end_of_page(struct page *page , unsigned int to ) 
{ 
  struct inode *inode ;
  int end_byte_in_page ;
  loff_t tmp ;
  loff_t tmp___0 ;

  {
#line 387
  inode = (page->mapping)->host;
#line 390
  tmp = i_size_read((struct inode  const  *)inode);
#line 390
  if ((unsigned long long )tmp / 4096ULL != (unsigned long long )page->ldv_18093.ldv_18077.index) {
#line 391
    goto out;
  } else {

  }
#line 392
  tmp___0 = i_size_read((struct inode  const  *)inode);
#line 392
  end_byte_in_page = (int )tmp___0 & 4095;
#line 393
  if ((unsigned int )end_byte_in_page < to) {
#line 394
    end_byte_in_page = (int )to;
  } else {

  }
#line 395
  zero_user_segment(page, (unsigned int )end_byte_in_page, 4096U);
  out: ;
#line 397
  return (0);
}
}
#line 414 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static int ecryptfs_write_begin(struct file *file , struct address_space *mapping ,
                                loff_t pos , unsigned int len , unsigned int flags ,
                                struct page **pagep , void **fsdata ) 
{ 
  unsigned long index ;
  struct page *page ;
  loff_t prev_page_end_size ;
  int rc ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_inode_info *tmp ;
  loff_t tmp___0 ;
  int tmp___1 ;
  loff_t tmp___2 ;
  loff_t tmp___3 ;
  long tmp___4 ;

  {
#line 419
  index = (unsigned long )(pos >> 12);
#line 422
  rc = 0;
#line 424
  page = grab_cache_page_write_begin(mapping, index, flags);
#line 425
  if ((unsigned long )page == (unsigned long )((struct page *)0)) {
#line 426
    return (-12);
  } else {

  }
#line 427
  *pagep = page;
#line 429
  prev_page_end_size = (long long )index << 12;
#line 430
  tmp___1 = PageUptodate(page);
#line 430
  if (tmp___1 == 0) {
#line 431
    tmp = ecryptfs_inode_to_private(mapping->host);
#line 431
    crypt_stat = & tmp->crypt_stat;
#line 434
    if ((crypt_stat->flags & 4U) == 0U) {
#line 435
      rc = ecryptfs_read_lower_page_segment(page, index, 0UL, 4096UL, mapping->host);
#line 437
      if (rc != 0) {
#line 438
        printk("\v%s: Error attemping to read lower page segment; rc = [%d]\n", "ecryptfs_write_begin",
               rc);
#line 441
        ClearPageUptodate(page);
#line 442
        goto out;
      } else {
#line 444
        SetPageUptodate(page);
      }
    } else
#line 445
    if ((crypt_stat->flags & 256U) != 0U) {
#line 446
      if ((crypt_stat->flags & 128U) != 0U) {
#line 447
        rc = ecryptfs_copy_up_encrypted_with_header(page, crypt_stat);
#line 449
        if (rc != 0) {
#line 450
          printk("\v%s: Error attempting to copy the encrypted content from the lower file whilst inserting the metadata from the xattr into the header; rc = [%d]\n",
                 "ecryptfs_write_begin", rc);
#line 456
          ClearPageUptodate(page);
#line 457
          goto out;
        } else {

        }
#line 459
        SetPageUptodate(page);
      } else {
#line 461
        rc = ecryptfs_read_lower_page_segment(page, index, 0UL, 4096UL, mapping->host);
#line 464
        if (rc != 0) {
#line 465
          printk("\v%s: Error reading page; rc = [%d]\n", "ecryptfs_write_begin",
                 rc);
#line 468
          ClearPageUptodate(page);
#line 469
          goto out;
        } else {

        }
#line 471
        SetPageUptodate(page);
      }
    } else {
#line 474
      tmp___0 = i_size_read((struct inode  const  *)(page->mapping)->host);
#line 474
      if (tmp___0 <= prev_page_end_size) {
#line 476
        zero_user(page, 0U, 4096U);
      } else {
#line 478
        rc = ecryptfs_decrypt_page(page);
#line 479
        if (rc != 0) {
#line 480
          printk("\v%s: Error decrypting page at index [%ld]; rc = [%d]\n", "ecryptfs_write_begin",
                 page->ldv_18093.ldv_18077.index, rc);
#line 484
          ClearPageUptodate(page);
#line 485
          goto out;
        } else {

        }
      }
#line 488
      SetPageUptodate(page);
    }
  } else {

  }
#line 493
  if (index != 0UL) {
#line 494
    tmp___2 = i_size_read((struct inode  const  *)(page->mapping)->host);
#line 494
    if (tmp___2 < prev_page_end_size) {
#line 495
      rc = ecryptfs_truncate(file->f_path.dentry, prev_page_end_size);
#line 497
      if (rc != 0) {
#line 498
        printk("\v%s: Error on attempt to truncate to (higher) offset [%lld]; rc = [%d]\n",
               "ecryptfs_write_begin", prev_page_end_size, rc);
#line 502
        goto out;
      } else {

      }
    } else {

    }
  } else {

  }
#line 508
  tmp___3 = i_size_read((struct inode  const  *)mapping->host);
#line 508
  if (tmp___3 == prev_page_end_size && pos != 0LL) {
#line 510
    zero_user(page, 0U, 4096U);
  } else {

  }
  out: 
#line 512
  tmp___4 = __builtin_expect(rc != 0, 0L);
#line 512
  if (tmp___4 != 0L) {
#line 513
    unlock_page(page);
#line 514
    put_page(page);
#line 515
    *pagep = 0;
  } else {

  }
#line 517
  return (rc);
}
}
#line 527 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static int ecryptfs_write_inode_size_to_header(struct inode *ecryptfs_inode ) 
{ 
  char *file_size_virt ;
  int rc ;
  void *tmp ;
  loff_t tmp___0 ;

  {
#line 532
  tmp = kmalloc(8UL, 208U);
#line 532
  file_size_virt = (char *)tmp;
#line 533
  if ((unsigned long )file_size_virt == (unsigned long )((char *)0)) {
#line 534
    rc = -12;
#line 535
    goto out;
  } else {

  }
#line 537
  tmp___0 = i_size_read((struct inode  const  *)ecryptfs_inode);
#line 537
  put_unaligned_be64((u64 )tmp___0, (void *)file_size_virt);
#line 538
  rc = ecryptfs_write_lower(ecryptfs_inode, file_size_virt, 0LL, 8UL);
#line 540
  kfree((void const   *)file_size_virt);
#line 541
  if (rc < 0) {
#line 542
    printk("\v%s: Error writing file size to header; rc = [%d]\n", "ecryptfs_write_inode_size_to_header",
           rc);
  } else {
#line 545
    rc = 0;
  }
  out: ;
#line 547
  return (rc);
}
}
#line 552 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static int ecryptfs_write_inode_size_to_xattr(struct inode *ecryptfs_inode ) 
{ 
  ssize_t size ;
  void *xattr_virt ;
  struct dentry *lower_dentry ;
  struct ecryptfs_inode_info *tmp ;
  struct inode *lower_inode ;
  int rc ;
  loff_t tmp___0 ;

  {
#line 556
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 556
  lower_dentry = (tmp->lower_file)->f_path.dentry;
#line 558
  lower_inode = lower_dentry->d_inode;
#line 561
  if ((unsigned long )(lower_inode->i_op)->getxattr == (unsigned long )((ssize_t (*/* const  */)(struct dentry * ,
                                                                                                 char const   * ,
                                                                                                 void * ,
                                                                                                 size_t  ))0) || (unsigned long )(lower_inode->i_op)->setxattr == (unsigned long )((int (*/* const  */)(struct dentry * ,
                                                                                                                                                                                                        char const   * ,
                                                                                                                                                                                                        void const   * ,
                                                                                                                                                                                                        size_t  ,
                                                                                                                                                                                                        int  ))0)) {
#line 562
    printk("\fNo support for setting xattr in lower filesystem\n");
#line 564
    rc = -38;
#line 565
    goto out;
  } else {

  }
#line 567
  xattr_virt = kmem_cache_alloc(ecryptfs_xattr_cache, 208U);
#line 568
  if ((unsigned long )xattr_virt == (unsigned long )((void *)0)) {
#line 569
    printk("\vOut of memory whilst attempting to write inode size to xattr\n");
#line 571
    rc = -12;
#line 572
    goto out;
  } else {

  }
#line 574
  ldv_mutex_lock_123(& lower_inode->i_mutex);
#line 575
  size = (*((lower_inode->i_op)->getxattr))(lower_dentry, "user.ecryptfs", xattr_virt,
                                            4096UL);
#line 577
  if (size < 0L) {
#line 578
    size = 8L;
  } else {

  }
#line 579
  tmp___0 = i_size_read((struct inode  const  *)ecryptfs_inode);
#line 579
  put_unaligned_be64((u64 )tmp___0, xattr_virt);
#line 580
  rc = (*((lower_inode->i_op)->setxattr))(lower_dentry, "user.ecryptfs", (void const   *)xattr_virt,
                                          (size_t )size, 0);
#line 582
  ldv_mutex_unlock_124(& lower_inode->i_mutex);
#line 583
  if (rc != 0) {
#line 584
    printk("\vError whilst attempting to write inode size to lower file xattr; rc = [%d]\n",
           rc);
  } else {

  }
#line 586
  kmem_cache_free(ecryptfs_xattr_cache, xattr_virt);
  out: ;
#line 588
  return (rc);
}
}
#line 591 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
int ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode ) 
{ 
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_inode_info *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 595
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 595
  crypt_stat = & tmp->crypt_stat;
#line 596
  tmp___0 = __builtin_expect((crypt_stat->flags & 4U) == 0U, 0L);
#line 596
  if (tmp___0 != 0L) {
#line 596
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"),
                         "i" (596), "i" (12UL));
    ldv_27343: ;
#line 596
    goto ldv_27343;
  } else {

  }
#line 597
  if ((crypt_stat->flags & 128U) != 0U) {
#line 598
    tmp___1 = ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);
#line 598
    return (tmp___1);
  } else {
#line 600
    tmp___2 = ecryptfs_write_inode_size_to_header(ecryptfs_inode);
#line 600
    return (tmp___2);
  }
}
}
#line 613 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static int ecryptfs_write_end(struct file *file , struct address_space *mapping ,
                              loff_t pos , unsigned int len , unsigned int copied ,
                              struct page *page , void *fsdata ) 
{ 
  unsigned long index ;
  unsigned int from ;
  unsigned int to ;
  struct inode *ecryptfs_inode ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_inode_info *tmp ;
  int rc ;
  struct inode *tmp___0 ;
  loff_t tmp___1 ;
  loff_t tmp___2 ;

  {
#line 618
  index = (unsigned long )(pos >> 12);
#line 619
  from = (unsigned int )pos & 4095U;
#line 620
  to = from + copied;
#line 621
  ecryptfs_inode = mapping->host;
#line 622
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 622
  crypt_stat = & tmp->crypt_stat;
#line 626
  __ecryptfs_printk("\017%s: Calling fill_zeros_to_end_of_page(page w/ index = [0x%.16lx], to = [%d])\n",
                    "ecryptfs_write_end", index, to);
#line 628
  if ((crypt_stat->flags & 4U) == 0U) {
#line 629
    rc = ecryptfs_write_lower_page_segment(ecryptfs_inode, page, 0UL, (size_t )to);
#line 631
    if (rc == 0) {
#line 632
      rc = (int )copied;
#line 633
      tmp___0 = ecryptfs_inode_to_lower(ecryptfs_inode);
#line 633
      fsstack_copy_inode_size(ecryptfs_inode, tmp___0);
    } else {

    }
#line 636
    goto out;
  } else {

  }
#line 639
  rc = fill_zeros_to_end_of_page(page, to);
#line 640
  if (rc != 0) {
#line 641
    __ecryptfs_printk("\f%s: Error attempting to fill zeros in page with index = [0x%.16lx]\n",
                      "ecryptfs_write_end", index);
#line 643
    goto out;
  } else {

  }
#line 645
  rc = ecryptfs_encrypt_page(page);
#line 646
  if (rc != 0) {
#line 647
    __ecryptfs_printk("\f%s: Error encrypting page (upper index [0x%.16lx])\n", "ecryptfs_write_end",
                      index);
#line 649
    goto out;
  } else {

  }
#line 651
  tmp___2 = i_size_read((struct inode  const  *)ecryptfs_inode);
#line 651
  if ((loff_t )copied + pos > tmp___2) {
#line 652
    i_size_write(ecryptfs_inode, (loff_t )copied + pos);
#line 653
    tmp___1 = i_size_read((struct inode  const  *)ecryptfs_inode);
#line 653
    __ecryptfs_printk("\017%s: Expanded file size to [0x%.16llx]\n", "ecryptfs_write_end",
                      (unsigned long long )tmp___1);
  } else {

  }
#line 657
  rc = ecryptfs_write_inode_size_to_metadata(ecryptfs_inode);
#line 658
  if (rc != 0) {
#line 659
    printk("\vError writing inode size to metadata; rc = [%d]\n", rc);
  } else {
#line 662
    rc = (int )copied;
  }
  out: 
#line 664
  unlock_page(page);
#line 665
  put_page(page);
#line 666
  return (rc);
}
}
#line 669 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
static sector_t ecryptfs_bmap(struct address_space *mapping , sector_t block ) 
{ 
  int rc ;
  struct inode *inode ;
  struct inode *lower_inode ;
  sector_t tmp ;

  {
#line 671
  rc = 0;
#line 675
  inode = mapping->host;
#line 676
  lower_inode = ecryptfs_inode_to_lower(inode);
#line 677
  if ((unsigned long )((lower_inode->i_mapping)->a_ops)->bmap != (unsigned long )((sector_t (*/* const  */)(struct address_space * ,
                                                                                                            sector_t  ))0)) {
#line 678
    tmp = (*(((lower_inode->i_mapping)->a_ops)->bmap))(lower_inode->i_mapping, block);
#line 678
    rc = (int )tmp;
  } else {

  }
#line 680
  return ((sector_t )rc);
}
}
#line 683 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
struct address_space_operations  const  ecryptfs_aops  = 
#line 683
     {& ecryptfs_writepage, & ecryptfs_readpage, 0, 0, 0, & ecryptfs_write_begin, & ecryptfs_write_end,
    & ecryptfs_bmap, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 728 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
void ldv_main5_sequence_infinite_withcheck_stateful(void) 
{ 
  struct page *var_group1 ;
  struct writeback_control *var_group2 ;
  struct file *var_group3 ;
  struct address_space *var_group4 ;
  loff_t var_ecryptfs_write_begin_6_p2 ;
  unsigned int var_ecryptfs_write_begin_6_p3 ;
  unsigned int var_ecryptfs_write_begin_6_p4 ;
  struct page **var_ecryptfs_write_begin_6_p5 ;
  void **var_ecryptfs_write_begin_6_p6 ;
  loff_t var_ecryptfs_write_end_10_p2 ;
  unsigned int var_ecryptfs_write_end_10_p3 ;
  unsigned int var_ecryptfs_write_end_10_p4 ;
  struct page *var_ecryptfs_write_end_10_p5 ;
  void *var_ecryptfs_write_end_10_p6 ;
  sector_t var_ecryptfs_bmap_11_p1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 782
  LDV_IN_INTERRUPT = 1;
#line 791
  ldv_initialize();
#line 795
  goto ldv_27408;
  ldv_27407: 
#line 798
  tmp = __VERIFIER_nondet_int();
#line 798
  switch (tmp) {
  case 0: 
#line 808
  ldv_handler_precall();
#line 809
  ecryptfs_writepage(var_group1, var_group2);
#line 816
  goto ldv_27401;
  case 1: 
#line 825
  ldv_handler_precall();
#line 826
  ecryptfs_readpage(var_group3, var_group1);
#line 833
  goto ldv_27401;
  case 2: 
#line 842
  ldv_handler_precall();
#line 843
  ecryptfs_write_begin(var_group3, var_group4, var_ecryptfs_write_begin_6_p2, var_ecryptfs_write_begin_6_p3,
                       var_ecryptfs_write_begin_6_p4, var_ecryptfs_write_begin_6_p5,
                       var_ecryptfs_write_begin_6_p6);
#line 850
  goto ldv_27401;
  case 3: 
#line 859
  ldv_handler_precall();
#line 860
  ecryptfs_write_end(var_group3, var_group4, var_ecryptfs_write_end_10_p2, var_ecryptfs_write_end_10_p3,
                     var_ecryptfs_write_end_10_p4, var_ecryptfs_write_end_10_p5, var_ecryptfs_write_end_10_p6);
#line 867
  goto ldv_27401;
  case 4: 
#line 876
  ldv_handler_precall();
#line 877
  ecryptfs_bmap(var_group4, var_ecryptfs_bmap_11_p1);
#line 884
  goto ldv_27401;
  default: ;
#line 885
  goto ldv_27401;
  }
  ldv_27401: ;
  ldv_27408: 
#line 795
  tmp___0 = __VERIFIER_nondet_int();
#line 795
  if (tmp___0 != 0) {
#line 796
    goto ldv_27407;
  } else {

  }


#line 894
  ldv_check_final_state();
#line 897
  return;
}
}
#line 901 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
void ldv_mutex_lock_119(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 906
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 908
  mutex_lock(ldv_func_arg1);
#line 909
  return;
}
}
#line 911 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
void ldv_mutex_unlock_120(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 916
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 918
  mutex_unlock(ldv_func_arg1);
#line 919
  return;
}
}
#line 921 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
void ldv_mutex_lock_121(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 926
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 928
  mutex_lock(ldv_func_arg1);
#line 929
  return;
}
}
#line 931 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 936
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 938
  mutex_unlock(ldv_func_arg1);
#line 939
  return;
}
}
#line 941 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
void ldv_mutex_lock_123(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 946
  ldv_mutex_lock_i_mutex(ldv_func_arg1);
#line 948
  mutex_lock(ldv_func_arg1);
#line 949
  return;
}
}
#line 951 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/mmap.c.prepared"
void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 956
  ldv_mutex_unlock_i_mutex(ldv_func_arg1);
#line 958
  mutex_unlock(ldv_func_arg1);
#line 959
  return;
}
}
#line 324 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 328
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 333
  return (oldbit);
}
}
#line 172 "include/linux/mutex.h"
void ldv_mutex_unlock_132(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/read_write.c.prepared"
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) ;
#line 208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info___1(void) 
{ 
  struct thread_info *ti ;
  unsigned long pfo_ret__ ;

  {
#line 211
  switch (8UL) {
  case 1UL: 
#line 211
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6363;
  case 2UL: 
#line 211
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6363;
  case 4UL: 
#line 211
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6363;
  case 8UL: 
#line 211
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& kernel_stack));
#line 211
  goto ldv_6363;
  default: 
#line 211
  __bad_percpu_size();
  }
  ldv_6363: 
#line 211
  ti = (struct thread_info *)(pfo_ret__ - 8152UL);
#line 213
  return (ti);
}
}
#line 91 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
#line 93
  tmp = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
#line 93
  return (tmp);
}
}
#line 1583 "include/linux/fs.h"
extern ssize_t vfs_read(struct file * , char * , size_t  , loff_t * ) ;
#line 1584
extern ssize_t vfs_write(struct file * , char const   * , size_t  , loff_t * ) ;
#line 1742
extern void __mark_inode_dirty(struct inode * , int  ) ;
#line 1748 "include/linux/fs.h"
__inline static void mark_inode_dirty_sync(struct inode *inode ) 
{ 


  {
#line 1750
  __mark_inode_dirty(inode, 1);
#line 1751
  return;
}
}
#line 16 "include/linux/uaccess.h"
__inline static void pagefault_disable___0(void) 
{ 
  struct thread_info *tmp ;

  {
#line 18
  tmp = current_thread_info___1();
#line 18
  tmp->preempt_count = tmp->preempt_count + 1;
#line 23
  __asm__  volatile   ("": : : "memory");
#line 24
  return;
}
}
#line 26 "include/linux/uaccess.h"
__inline static void pagefault_enable___0(void) 
{ 
  struct thread_info *tmp ;

  {
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  tmp = current_thread_info___1();
#line 33
  tmp->preempt_count = tmp->preempt_count + -1;
#line 37
  __asm__  volatile   ("": : : "memory");
#line 38
  return;
}
}
#line 56 "include/linux/highmem.h"
__inline static void *kmap(struct page *page ) 
{ 
  void *tmp ;

  {
#line 58
  __might_sleep("include/linux/highmem.h", 58, 0);
#line 59
  tmp = lowmem_page_address((struct page  const  *)page);
#line 59
  return (tmp);
}
}
#line 62 "include/linux/highmem.h"
__inline static void kunmap(struct page *page ) 
{ 


  {
#line 64
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic___0(struct page *page ) 
{ 
  void *tmp ;

  {
#line 68
  pagefault_disable___0();
#line 69
  tmp = lowmem_page_address((struct page  const  *)page);
#line 69
  return (tmp);
}
}
#line 73 "include/linux/highmem.h"
__inline static void __kunmap_atomic___0(void *addr ) 
{ 


  {
#line 75
  pagefault_enable___0();
#line 76
  return;
}
}
#line 57 "include/linux/signal.h"
__inline static int sigismember(sigset_t *set , int _sig ) 
{ 
  unsigned long sig ;

  {
#line 59
  sig = (unsigned long )(_sig + -1);
#line 61
  return ((int )(set->sig[0] >> (int )sig) & 1);
}
}
#line 2592 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp ;

  {
#line 2594
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2594
  return (tmp);
}
}
#line 2618 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2620
  tmp = test_tsk_thread_flag(p, 2);
#line 2620
  tmp___0 = __builtin_expect(tmp != 0, 0L);
#line 2620
  return ((int )tmp___0);
}
}
#line 2623 "include/linux/sched.h"
__inline static int __fatal_signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2625
  tmp = sigismember(& p->pending.signal, 9);
#line 2625
  tmp___0 = __builtin_expect(tmp != 0, 0L);
#line 2625
  return ((int )tmp___0);
}
}
#line 2628 "include/linux/sched.h"
__inline static int fatal_signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2630
  tmp = signal_pending(p);
#line 2630
  if (tmp != 0) {
#line 2630
    tmp___0 = __fatal_signal_pending(p);
#line 2630
    if (tmp___0 != 0) {
#line 2630
      tmp___1 = 1;
    } else {
#line 2630
      tmp___1 = 0;
    }
  } else {
#line 2630
    tmp___1 = 0;
  }
#line 2630
  return (tmp___1);
}
}
#line 645 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
int ecryptfs_read_lower(char *data , loff_t offset , size_t size , struct inode *ecryptfs_inode ) ;
#line 174 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/read_write.c.prepared"
int ecryptfs_write_lower(struct inode *ecryptfs_inode , char *data , loff_t offset ,
                         size_t size ) 
{ 
  struct file *lower_file ;
  mm_segment_t fs_save ;
  ssize_t rc ;
  struct ecryptfs_inode_info *tmp ;
  struct thread_info *tmp___0 ;
  struct thread_info *tmp___1 ;
  mm_segment_t __constr_expr_0 ;
  struct thread_info *tmp___2 ;

  {
#line 181
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 181
  lower_file = tmp->lower_file;
#line 182
  if ((unsigned long )lower_file == (unsigned long )((struct file *)0)) {
#line 183
    return (-5);
  } else {

  }
#line 184
  tmp___0 = current_thread_info___1();
#line 184
  fs_save = tmp___0->addr_limit;
#line 185
  tmp___1 = current_thread_info___1();
#line 185
  __constr_expr_0.seg = 0xffffffffffffffffUL;
#line 185
  tmp___1->addr_limit = __constr_expr_0;
#line 186
  rc = vfs_write(lower_file, (char const   *)data, size, & offset);
#line 187
  tmp___2 = current_thread_info___1();
#line 187
  tmp___2->addr_limit = fs_save;
#line 188
  mark_inode_dirty_sync(ecryptfs_inode);
#line 189
  return ((int )rc);
}
}
#line 208 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/read_write.c.prepared"
int ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode , struct page *page_for_lower ,
                                      size_t offset_in_page , size_t size ) 
{ 
  char *virt ;
  loff_t offset ;
  int rc ;
  void *tmp ;

  {
#line 216
  offset = (loff_t )((unsigned long long )((long long )page_for_lower->ldv_18093.ldv_18077.index << 12) + (unsigned long long )offset_in_page);
#line 218
  tmp = kmap(page_for_lower);
#line 218
  virt = (char *)tmp;
#line 219
  rc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);
#line 220
  if (rc > 0) {
#line 221
    rc = 0;
  } else {

  }
#line 222
  kunmap(page_for_lower);
#line 223
  return (rc);
}
}
#line 244 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/read_write.c.prepared"
int ecryptfs_write(struct inode *ecryptfs_inode , char *data , loff_t offset , size_t size ) 
{ 
  struct page *ecryptfs_page ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  char *ecryptfs_page_virt ;
  loff_t ecryptfs_file_size ;
  loff_t tmp ;
  loff_t data_offset ;
  loff_t pos ;
  int rc ;
  struct ecryptfs_inode_info *tmp___0 ;
  unsigned long ecryptfs_page_idx ;
  size_t start_offset_in_page ;
  size_t num_bytes ;
  loff_t total_remaining_bytes ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  loff_t total_remaining_zeros ;
  long tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  size_t __len ;
  void *__ret ;
  int rc2 ;

  {
#line 250
  tmp = i_size_read((struct inode  const  *)ecryptfs_inode);
#line 250
  ecryptfs_file_size = tmp;
#line 251
  data_offset = 0LL;
#line 253
  rc = 0;
#line 255
  tmp___0 = ecryptfs_inode_to_private(ecryptfs_inode);
#line 255
  crypt_stat = & tmp___0->crypt_stat;
#line 260
  if (offset > ecryptfs_file_size) {
#line 261
    pos = ecryptfs_file_size;
  } else {
#line 263
    pos = offset;
  }
#line 264
  goto ldv_25676;
  ldv_25675: 
#line 265
  ecryptfs_page_idx = (unsigned long )(pos >> 12);
#line 266
  start_offset_in_page = (size_t )pos & 4095UL;
#line 267
  num_bytes = 4096UL - start_offset_in_page;
#line 268
  total_remaining_bytes = (loff_t )(((unsigned long long )offset + (unsigned long long )size) - (unsigned long long )pos);
#line 270
  tmp___1 = get_current();
#line 270
  tmp___2 = fatal_signal_pending(tmp___1);
#line 270
  if (tmp___2 != 0) {
#line 271
    rc = -4;
#line 272
    goto ldv_25668;
  } else {

  }
#line 275
  if ((unsigned long long )total_remaining_bytes < (unsigned long long )num_bytes) {
#line 276
    num_bytes = (size_t )total_remaining_bytes;
  } else {

  }
#line 277
  if (pos < offset) {
#line 279
    total_remaining_zeros = offset - pos;
#line 281
    if ((unsigned long long )total_remaining_zeros < (unsigned long long )num_bytes) {
#line 282
      num_bytes = (size_t )total_remaining_zeros;
    } else {

    }
  } else {

  }
#line 284
  ecryptfs_page = ecryptfs_get_locked_page(ecryptfs_inode, (loff_t )ecryptfs_page_idx);
#line 286
  tmp___4 = IS_ERR((void const   *)ecryptfs_page);
#line 286
  if (tmp___4 != 0L) {
#line 287
    tmp___3 = PTR_ERR((void const   *)ecryptfs_page);
#line 287
    rc = (int )tmp___3;
#line 288
    printk("\v%s: Error getting page at index [%ld] from eCryptfs inode mapping; rc = [%d]\n",
           "ecryptfs_write", ecryptfs_page_idx, rc);
#line 292
    goto out;
  } else {

  }
#line 294
  tmp___5 = kmap_atomic___0(ecryptfs_page);
#line 294
  ecryptfs_page_virt = (char *)tmp___5;
#line 302
  if (pos < offset || start_offset_in_page == 0UL) {
#line 305
    memset((void *)(ecryptfs_page_virt + start_offset_in_page), 0, 4096UL - start_offset_in_page);
  } else {

  }
#line 311
  if (pos >= offset) {
#line 312
    __len = num_bytes;
#line 312
    __ret = __builtin_memcpy((void *)(ecryptfs_page_virt + start_offset_in_page),
                             (void const   *)data + (unsigned long )data_offset, __len);
#line 315
    data_offset = (loff_t )((unsigned long long )data_offset + (unsigned long long )num_bytes);
  } else {

  }
#line 317
  __kunmap_atomic___0((void *)ecryptfs_page_virt);
#line 319
  SetPageUptodate(ecryptfs_page);
#line 320
  unlock_page(ecryptfs_page);
#line 321
  if ((crypt_stat->flags & 4U) != 0U) {
#line 322
    rc = ecryptfs_encrypt_page(ecryptfs_page);
  } else {
#line 324
    rc = ecryptfs_write_lower_page_segment(ecryptfs_inode, ecryptfs_page, start_offset_in_page,
                                           (size_t )data_offset);
  }
#line 328
  put_page(ecryptfs_page);
#line 329
  if (rc != 0) {
#line 330
    printk("\v%s: Error encrypting page; rc = [%d]\n", "ecryptfs_write", rc);
#line 332
    goto out;
  } else {

  }
#line 334
  pos = (loff_t )((unsigned long long )pos + (unsigned long long )num_bytes);
  ldv_25676: ;
#line 264
  if ((unsigned long long )pos < (unsigned long long )offset + (unsigned long long )size) {
#line 265
    goto ldv_25675;
  } else {

  }
  ldv_25668: ;
#line 336
  if (pos > ecryptfs_file_size) {
#line 337
    i_size_write(ecryptfs_inode, pos);
#line 338
    if ((crypt_stat->flags & 4U) != 0U) {
#line 341
      rc2 = ecryptfs_write_inode_size_to_metadata(ecryptfs_inode);
#line 343
      if (rc2 != 0) {
#line 344
        printk("\vProblem with ecryptfs_write_inode_size_to_metadata; rc = [%d]\n",
               rc2);
#line 347
        if (rc == 0) {
#line 348
          rc = rc2;
        } else {

        }
#line 349
        goto out;
      } else {

      }
    } else {

    }
  } else {

  }
  out: ;
#line 354
  return (rc);
}
}
#line 370 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/read_write.c.prepared"
int ecryptfs_read_lower(char *data , loff_t offset , size_t size , struct inode *ecryptfs_inode ) 
{ 
  struct file *lower_file ;
  mm_segment_t fs_save ;
  ssize_t rc ;
  struct ecryptfs_inode_info *tmp ;
  struct thread_info *tmp___0 ;
  struct thread_info *tmp___1 ;
  mm_segment_t __constr_expr_0 ;
  struct thread_info *tmp___2 ;

  {
#line 377
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 377
  lower_file = tmp->lower_file;
#line 378
  if ((unsigned long )lower_file == (unsigned long )((struct file *)0)) {
#line 379
    return (-5);
  } else {

  }
#line 380
  tmp___0 = current_thread_info___1();
#line 380
  fs_save = tmp___0->addr_limit;
#line 381
  tmp___1 = current_thread_info___1();
#line 381
  __constr_expr_0.seg = 0xffffffffffffffffUL;
#line 381
  tmp___1->addr_limit = __constr_expr_0;
#line 382
  rc = vfs_read(lower_file, data, size, & offset);
#line 383
  tmp___2 = current_thread_info___1();
#line 383
  tmp___2->addr_limit = fs_save;
#line 384
  return ((int )rc);
}
}
#line 402 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/read_write.c.prepared"
int ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs , unsigned long page_index___0 ,
                                     size_t offset_in_page , size_t size , struct inode *ecryptfs_inode ) 
{ 
  char *virt ;
  loff_t offset ;
  int rc ;
  void *tmp ;

  {
#line 411
  offset = (loff_t )((unsigned long long )((long long )page_index___0 << 12) + (unsigned long long )offset_in_page);
#line 412
  tmp = kmap(page_for_ecryptfs);
#line 412
  virt = (char *)tmp;
#line 413
  rc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);
#line 414
  if (rc > 0) {
#line 415
    rc = 0;
  } else {

  }
#line 416
  kunmap(page_for_ecryptfs);
#line 418
  return (rc);
}
}
#line 421 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/read_write.c.prepared"
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 426
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 428
  mutex_lock(ldv_func_arg1);
#line 429
  return;
}
}
#line 431 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/read_write.c.prepared"
void ldv_mutex_unlock_132(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 436
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 438
  mutex_unlock(ldv_func_arg1);
#line 439
  return;
}
}
#line 489 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 491
  bitpos = -1;
#line 497
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 500
  return (bitpos + 1);
}
}
#line 7 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 154 "include/uapi/linux/swab.h"
__inline static __u16 __swab16p(__u16 const   *p ) 
{ 
  __u16 tmp ;

  {
#line 159
  tmp = __fswab16((int )*p);
#line 159
  return (tmp);
}
}
#line 167 "include/uapi/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ 
  __u32 tmp ;

  {
#line 172
  tmp = __fswab32(*p);
#line 172
  return (tmp);
}
}
#line 180 "include/uapi/linux/swab.h"
__inline static __u64 __swab64p(__u64 const   *p ) 
{ 
  __u64 tmp ;

  {
#line 185
  tmp = __fswab64(*p);
#line 185
  return (tmp);
}
}
#line 71 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __swab64p(p);
#line 73
  return (tmp);
}
}
#line 79 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __be32_to_cpup(__be32 const   *p ) 
{ 
  __u32 tmp ;

  {
#line 81
  tmp = __swab32p(p);
#line 81
  return (tmp);
}
}
#line 87 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ 
  __u16 tmp ;

  {
#line 89
  tmp = __swab16p(p);
#line 89
  return (tmp);
}
}
#line 358 "include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 47 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 62
  __list_add(new, head, head->next);
#line 63
  return;
}
}
#line 112
extern void list_del(struct list_head * ) ;
#line 61 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_64_types.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 13 "include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size ) 
{ 
  int order ;

  {
#line 17
  size = size - 1UL;
#line 18
  size = size >> 12;
#line 22
  order = fls64((__u64 )size);
#line 24
  return (order);
}
}
#line 64 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern int strcmp(char const   * , char const   * ) ;
#line 41 "include/linux/string.h"
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 23 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 25
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 124 "include/linux/mutex.h"
__inline static int mutex_is_locked(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 126
  tmp = atomic_read((atomic_t const   *)(& lock->count));
#line 126
  return (tmp != 1);
}
}
#line 172
void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_147(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_148(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_154(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_156(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_158(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_160(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_135(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_137(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_141(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_143(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_149(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_151(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_155(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_157(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_159(struct mutex *ldv_func_arg1 ) ;
#line 67
void ldv_mutex_lock_cs_hash_tfm_mutex(struct mutex *lock ) ;
#line 71
void ldv_mutex_unlock_cs_hash_tfm_mutex(struct mutex *lock ) ;
#line 83
void ldv_mutex_lock_cs_tfm_mutex(struct mutex *lock ) ;
#line 87
void ldv_mutex_unlock_cs_tfm_mutex(struct mutex *lock ) ;
#line 131
void ldv_mutex_lock_keysig_list_mutex(struct mutex *lock ) ;
#line 135
void ldv_mutex_unlock_keysig_list_mutex(struct mutex *lock ) ;
#line 179
void ldv_mutex_lock_tfm_mutex(struct mutex *lock ) ;
#line 183
void ldv_mutex_unlock_tfm_mutex(struct mutex *lock ) ;
#line 329 "include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 332 "include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
#line 334
  tmp = alloc_pages_current(gfp_mask, order);
#line 334
  return (tmp);
}
}
#line 365
extern void __free_pages(struct page * , unsigned int  ) ;
#line 366
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 17 "include/linux/random.h"
extern void get_random_bytes(void * , int  ) ;
#line 209 "include/linux/key.h"
extern void key_put(struct key * ) ;
#line 492 "include/linux/crypto.h"
extern struct crypto_tfm *crypto_alloc_base(char const   * , u32  , u32  ) ;
#line 495 "include/linux/crypto.h"
__inline static void crypto_free_tfm(struct crypto_tfm *tfm ) 
{ 


  {
#line 497
  return;
}
}
#line 525 "include/linux/crypto.h"
__inline static unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm ) 
{ 


  {
#line 527
  return ((tfm->__crt_alg)->cra_blocksize);
}
}
#line 540 "include/linux/crypto.h"
__inline static void crypto_tfm_set_flags(struct crypto_tfm *tfm , u32 flags ) 
{ 


  {
#line 542
  tfm->crt_flags = tfm->crt_flags | flags;
#line 543
  return;
}
}
#line 871 "include/linux/crypto.h"
__inline static struct crypto_blkcipher *__crypto_blkcipher_cast(struct crypto_tfm *tfm ) 
{ 


  {
#line 874
  return ((struct crypto_blkcipher *)tfm);
}
}
#line 884 "include/linux/crypto.h"
__inline static struct crypto_blkcipher *crypto_alloc_blkcipher(char const   *alg_name ,
                                                                u32 type , u32 mask ) 
{ 
  struct crypto_tfm *tmp ;
  struct crypto_blkcipher *tmp___0 ;

  {
#line 887
  type = type & 4294967280U;
#line 888
  type = type | 4U;
#line 889
  mask = mask | 15U;
#line 891
  tmp = crypto_alloc_base(alg_name, type, mask);
#line 891
  tmp___0 = __crypto_blkcipher_cast(tmp);
#line 891
  return (tmp___0);
}
}
#line 894 "include/linux/crypto.h"
__inline static struct crypto_tfm *crypto_blkcipher_tfm(struct crypto_blkcipher *tfm ) 
{ 


  {
#line 897
  return (& tfm->base);
}
}
#line 900 "include/linux/crypto.h"
__inline static void crypto_free_blkcipher(struct crypto_blkcipher *tfm ) 
{ 
  struct crypto_tfm *tmp ;

  {
#line 902
  tmp = crypto_blkcipher_tfm(tfm);
#line 902
  crypto_free_tfm(tmp);
#line 903
  return;
}
}
#line 919 "include/linux/crypto.h"
__inline static struct blkcipher_tfm *crypto_blkcipher_crt(struct crypto_blkcipher *tfm ) 
{ 
  struct crypto_tfm *tmp ;

  {
#line 922
  tmp = crypto_blkcipher_tfm(tfm);
#line 922
  return (& tmp->crt_u.blkcipher);
}
}
#line 925 "include/linux/crypto.h"
__inline static struct blkcipher_alg *crypto_blkcipher_alg(struct crypto_blkcipher *tfm ) 
{ 
  struct crypto_tfm *tmp ;

  {
#line 928
  tmp = crypto_blkcipher_tfm(tfm);
#line 928
  return (& (tmp->__crt_alg)->cra_u.blkcipher);
}
}
#line 936 "include/linux/crypto.h"
__inline static unsigned int crypto_blkcipher_blocksize(struct crypto_blkcipher *tfm ) 
{ 
  struct crypto_tfm *tmp ;
  unsigned int tmp___0 ;

  {
#line 939
  tmp = crypto_blkcipher_tfm(tfm);
#line 939
  tmp___0 = crypto_tfm_alg_blocksize(tmp);
#line 939
  return (tmp___0);
}
}
#line 953 "include/linux/crypto.h"
__inline static void crypto_blkcipher_set_flags(struct crypto_blkcipher *tfm , u32 flags ) 
{ 
  struct crypto_tfm *tmp ;

  {
#line 956
  tmp = crypto_blkcipher_tfm(tfm);
#line 956
  crypto_tfm_set_flags(tmp, flags);
#line 957
  return;
}
}
#line 965 "include/linux/crypto.h"
__inline static int crypto_blkcipher_setkey(struct crypto_blkcipher *tfm , u8 const   *key ,
                                            unsigned int keylen ) 
{ 
  struct blkcipher_tfm *tmp ;
  struct crypto_tfm *tmp___0 ;
  int tmp___1 ;

  {
#line 968
  tmp = crypto_blkcipher_crt(tfm);
#line 968
  tmp___0 = crypto_blkcipher_tfm(tfm);
#line 968
  tmp___1 = (*(tmp->setkey))(tmp___0, key, keylen);
#line 968
  return (tmp___1);
}
}
#line 981 "include/linux/crypto.h"
__inline static int crypto_blkcipher_encrypt_iv(struct blkcipher_desc *desc , struct scatterlist *dst ,
                                                struct scatterlist *src , unsigned int nbytes ) 
{ 
  struct blkcipher_tfm *tmp ;
  int tmp___0 ;

  {
#line 986
  tmp = crypto_blkcipher_crt(desc->tfm);
#line 986
  tmp___0 = (*(tmp->encrypt))(desc, dst, src, nbytes);
#line 986
  return (tmp___0);
}
}
#line 998 "include/linux/crypto.h"
__inline static int crypto_blkcipher_decrypt_iv(struct blkcipher_desc *desc , struct scatterlist *dst ,
                                                struct scatterlist *src , unsigned int nbytes ) 
{ 
  struct blkcipher_tfm *tmp ;
  int tmp___0 ;

  {
#line 1003
  tmp = crypto_blkcipher_crt(desc->tfm);
#line 1003
  tmp___0 = (*(tmp->decrypt))(desc, dst, src, nbytes);
#line 1003
  return (tmp___0);
}
}
#line 1111 "include/linux/crypto.h"
__inline static struct crypto_hash *__crypto_hash_cast(struct crypto_tfm *tfm ) 
{ 


  {
#line 1113
  return ((struct crypto_hash *)tfm);
}
}
#line 1123 "include/linux/crypto.h"
__inline static struct crypto_hash *crypto_alloc_hash(char const   *alg_name , u32 type ,
                                                      u32 mask ) 
{ 
  struct crypto_tfm *tmp ;
  struct crypto_hash *tmp___0 ;

  {
#line 1126
  type = type & 4294967280U;
#line 1127
  mask = mask & 4294967280U;
#line 1128
  type = type | 8U;
#line 1129
  mask = mask | 14U;
#line 1131
  tmp = crypto_alloc_base(alg_name, type, mask);
#line 1131
  tmp___0 = __crypto_hash_cast(tmp);
#line 1131
  return (tmp___0);
}
}
#line 1134 "include/linux/crypto.h"
__inline static struct crypto_tfm *crypto_hash_tfm(struct crypto_hash *tfm ) 
{ 


  {
#line 1136
  return (& tfm->base);
}
}
#line 1139 "include/linux/crypto.h"
__inline static void crypto_free_hash(struct crypto_hash *tfm ) 
{ 
  struct crypto_tfm *tmp ;

  {
#line 1141
  tmp = crypto_hash_tfm(tfm);
#line 1141
  crypto_free_tfm(tmp);
#line 1142
  return;
}
}
#line 1154 "include/linux/crypto.h"
__inline static struct hash_tfm *crypto_hash_crt(struct crypto_hash *tfm ) 
{ 
  struct crypto_tfm *tmp ;

  {
#line 1156
  tmp = crypto_hash_tfm(tfm);
#line 1156
  return (& tmp->crt_u.hash);
}
}
#line 1189 "include/linux/crypto.h"
__inline static int crypto_hash_init(struct hash_desc *desc ) 
{ 
  struct hash_tfm *tmp ;
  int tmp___0 ;

  {
#line 1191
  tmp = crypto_hash_crt(desc->tfm);
#line 1191
  tmp___0 = (*(tmp->init))(desc);
#line 1191
  return (tmp___0);
}
}
#line 1194 "include/linux/crypto.h"
__inline static int crypto_hash_update(struct hash_desc *desc , struct scatterlist *sg ,
                                       unsigned int nbytes ) 
{ 
  struct hash_tfm *tmp ;
  int tmp___0 ;

  {
#line 1198
  tmp = crypto_hash_crt(desc->tfm);
#line 1198
  tmp___0 = (*(tmp->update))(desc, sg, nbytes);
#line 1198
  return (tmp___0);
}
}
#line 1201 "include/linux/crypto.h"
__inline static int crypto_hash_final(struct hash_desc *desc , u8 *out ) 
{ 
  struct hash_tfm *tmp ;
  int tmp___0 ;

  {
#line 1203
  tmp = crypto_hash_crt(desc->tfm);
#line 1203
  tmp___0 = (*(tmp->final))(desc, out);
#line 1203
  return (tmp___0);
}
}
#line 57 "include/linux/scatterlist.h"
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page ) 
{ 
  unsigned long page_link ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 59
  page_link = sg->page_link & 3UL;
#line 65
  tmp = __builtin_expect(((unsigned long )page & 3UL) != 0UL, 0L);
#line 65
  if (tmp != 0L) {
#line 65
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (65), "i" (12UL));
    ldv_23465: ;
#line 65
    goto ldv_23465;
  } else {

  }
#line 67
  tmp___0 = __builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 67
  if (tmp___0 != 0L) {
#line 67
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (67), "i" (12UL));
    ldv_23466: ;
#line 67
    goto ldv_23466;
  } else {

  }
#line 68
  tmp___1 = __builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 68
  if (tmp___1 != 0L) {
#line 68
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (68), "i" (12UL));
    ldv_23467: ;
#line 68
    goto ldv_23467;
  } else {

  }
#line 70
  sg->page_link = page_link | (unsigned long )page;
#line 71
  return;
}
}
#line 87 "include/linux/scatterlist.h"
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset ) 
{ 


  {
#line 90
  sg_assign_page(sg, page);
#line 91
  sg->offset = offset;
#line 92
  sg->length = len;
#line 93
  return;
}
}
#line 207
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 208
extern void sg_init_one(struct scatterlist * , void const   * , unsigned int  ) ;
#line 22 "include/linux/unaligned/access_ok.h"
__inline static u16 get_unaligned_be16(void const   *p ) 
{ 
  __u16 tmp ;

  {
#line 24
  tmp = __be16_to_cpup((__be16 const   *)p);
#line 24
  return (tmp);
}
}
#line 27 "include/linux/unaligned/access_ok.h"
__inline static u32 get_unaligned_be32(void const   *p ) 
{ 
  __u32 tmp ;

  {
#line 29
  tmp = __be32_to_cpup((__be32 const   *)p);
#line 29
  return (tmp);
}
}
#line 32 "include/linux/unaligned/access_ok.h"
__inline static u64 get_unaligned_be64(void const   *p ) 
{ 
  __u64 tmp ;

  {
#line 34
  tmp = __be64_to_cpup((__be64 const   *)p);
#line 34
  return (tmp);
}
}
#line 52 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_be16(u16 val , void *p ) 
{ 
  __u16 tmp ;

  {
#line 54
  tmp = __fswab16((int )val);
#line 54
  *((__be16 *)p) = tmp;
#line 55
  return;
}
}
#line 57 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_be32(u32 val , void *p ) 
{ 
  __u32 tmp ;

  {
#line 59
  tmp = __fswab32(val);
#line 59
  *((__be32 *)p) = tmp;
#line 60
  return;
}
}
#line 53 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
void ecryptfs_to_hex(char *dst , char *src , size_t src_size ) ;
#line 54
void ecryptfs_from_hex(char *dst , char *src , int dst_size ) ;
#line 303 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct mutex key_tfm_list_mutex  ;
#line 542 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_header_cache  ;
#line 547 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_key_tfm_cache  ;
#line 551
void ecryptfs_i_size_init(char const   *page_virt , struct inode *inode ) ;
#line 566
void ecryptfs_dump_hex(char *data , int bytes ) ;
#line 567
int virt_to_scatterlist(void const   *addr , int size , struct scatterlist *sg , int sg_size ) ;
#line 569
int ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat ) ;
#line 575
int ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat ) ;
#line 590
int ecryptfs_cipher_code_to_string(char *str , u8 cipher_code ) ;
#line 592
int ecryptfs_generate_key_packet_set(char *dest_base , struct ecryptfs_crypt_stat *crypt_stat ,
                                     struct dentry *ecryptfs_dentry , size_t *len ,
                                     size_t max ) ;
#line 597
int ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat , unsigned char *src ,
                              struct dentry *ecryptfs_dentry ) ;
#line 620
int ecryptfs_add_keysig(struct ecryptfs_crypt_stat *crypt_stat , char *sig ) ;
#line 633
int ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm , struct mutex **tfm_mutex ,
                                               char *cipher_name ) ;
#line 675
int ecryptfs_write_tag_70_packet(char *dest , size_t *remaining_bytes , size_t *packet_size ,
                                 struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                 char *filename , size_t filename_size ) ;
#line 680
int ecryptfs_parse_tag_70_packet(char **filename , size_t *filename_size , size_t *packet_size ,
                                 struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                 char *data , size_t max_packet_size ) ;
#line 686
int ecryptfs_derive_iv(char *iv , struct ecryptfs_crypt_stat *crypt_stat , loff_t offset ) ;
#line 177 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_decrypt_page_offset(struct ecryptfs_crypt_stat *crypt_stat , struct page *dst_page ,
                                        int dst_offset , struct page *src_page , int src_offset ,
                                        int size , unsigned char *iv ) ;
#line 182
static int ecryptfs_encrypt_page_offset(struct ecryptfs_crypt_stat *crypt_stat , struct page *dst_page ,
                                        int dst_offset , struct page *src_page , int src_offset ,
                                        int size , unsigned char *iv ) ;
#line 194 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_to_hex(char *dst , char *src , size_t src_size ) 
{ 
  int x ;

  {
#line 198
  x = 0;
#line 198
  goto ldv_27424;
  ldv_27423: 
#line 199
  sprintf(dst + (unsigned long )(x * 2), "%.2x", (int )((unsigned char )*(src + (unsigned long )x)));
#line 198
  x = x + 1;
  ldv_27424: ;
#line 198
  if ((size_t )x < src_size) {
#line 199
    goto ldv_27423;
  } else {

  }

#line 203
  return;
}
}
#line 209 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_from_hex(char *dst , char *src , int dst_size ) 
{ 
  int x ;
  char tmp[3U] ;
  unsigned int tmp___0 ;
  long tmp___1 ;

  {
#line 212
  tmp[0] = 0;
#line 212
  tmp___0 = 1U;
#line 212
  while (1) {
#line 212
    if (tmp___0 >= 3U) {
#line 212
      break;
    } else {

    }
#line 212
    tmp[tmp___0] = (char)0;
#line 212
    tmp___0 = tmp___0 + 1U;
  }
#line 214
  x = 0;
#line 214
  goto ldv_27434;
  ldv_27433: 
#line 215
  tmp[0] = *(src + (unsigned long )(x * 2));
#line 216
  tmp[1] = *(src + ((unsigned long )(x * 2) + 1UL));
#line 217
  tmp___1 = simple_strtol((char const   *)(& tmp), 0, 16U);
#line 217
  *(dst + (unsigned long )x) = (char )tmp___1;
#line 214
  x = x + 1;
  ldv_27434: ;
#line 214
  if (x < dst_size) {
#line 215
    goto ldv_27433;
  } else {

  }

#line 219
  return;
}
}
#line 231 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_calculate_md5(char *dst , struct ecryptfs_crypt_stat *crypt_stat ,
                                  char *src , int len ) 
{ 
  struct scatterlist sg ;
  struct hash_desc desc ;
  int rc ;
  long tmp ;
  long tmp___0 ;

  {
#line 236
  desc.tfm = crypt_stat->hash_tfm;
#line 236
  desc.flags = 512U;
#line 240
  rc = 0;
#line 242
  ldv_mutex_lock_139(& crypt_stat->cs_hash_tfm_mutex);
#line 243
  sg_init_one(& sg, (void const   *)src, (unsigned int )len);
#line 244
  if ((unsigned long )desc.tfm == (unsigned long )((struct crypto_hash *)0)) {
#line 245
    desc.tfm = crypto_alloc_hash("md5", 0U, 128U);
#line 247
    tmp___0 = IS_ERR((void const   *)desc.tfm);
#line 247
    if (tmp___0 != 0L) {
#line 248
      tmp = PTR_ERR((void const   *)desc.tfm);
#line 248
      rc = (int )tmp;
#line 249
      __ecryptfs_printk("\v%s: Error attempting to allocate crypto context; rc = [%d]\n",
                        "ecryptfs_calculate_md5", rc);
#line 252
      goto out;
    } else {

    }
#line 254
    crypt_stat->hash_tfm = desc.tfm;
  } else {

  }
#line 256
  rc = crypto_hash_init(& desc);
#line 257
  if (rc != 0) {
#line 258
    printk("\v%s: Error initializing crypto hash; rc = [%d]\n", "ecryptfs_calculate_md5",
           rc);
#line 261
    goto out;
  } else {

  }
#line 263
  rc = crypto_hash_update(& desc, & sg, (unsigned int )len);
#line 264
  if (rc != 0) {
#line 265
    printk("\v%s: Error updating crypto hash; rc = [%d]\n", "ecryptfs_calculate_md5",
           rc);
#line 268
    goto out;
  } else {

  }
#line 270
  rc = crypto_hash_final(& desc, (u8 *)dst);
#line 271
  if (rc != 0) {
#line 272
    printk("\v%s: Error finalizing crypto hash; rc = [%d]\n", "ecryptfs_calculate_md5",
           rc);
#line 275
    goto out;
  } else {

  }
  out: 
#line 278
  ldv_mutex_unlock_140(& crypt_stat->cs_hash_tfm_mutex);
#line 279
  return (rc);
}
}
#line 282 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_crypto_api_algify_cipher_name(char **algified_name , char *cipher_name ,
                                                  char *chaining_modifier ) 
{ 
  int cipher_name_len ;
  size_t tmp ;
  int chaining_modifier_len ;
  size_t tmp___0 ;
  int algified_name_len ;
  int rc ;
  void *tmp___1 ;

  {
#line 286
  tmp = strlen((char const   *)cipher_name);
#line 286
  cipher_name_len = (int )tmp;
#line 287
  tmp___0 = strlen((char const   *)chaining_modifier);
#line 287
  chaining_modifier_len = (int )tmp___0;
#line 291
  algified_name_len = (chaining_modifier_len + cipher_name_len) + 3;
#line 292
  tmp___1 = kmalloc((size_t )algified_name_len, 208U);
#line 292
  *algified_name = (char *)tmp___1;
#line 293
  if ((unsigned long )*algified_name == (unsigned long )((char *)0)) {
#line 294
    rc = -12;
#line 295
    goto out;
  } else {

  }
#line 297
  snprintf(*algified_name, (size_t )algified_name_len, "%s(%s)", chaining_modifier,
           cipher_name);
#line 299
  rc = 0;
  out: ;
#line 301
  return (rc);
}
}
#line 315 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_derive_iv(char *iv , struct ecryptfs_crypt_stat *crypt_stat , loff_t offset ) 
{ 
  int rc ;
  char dst[16U] ;
  char src[32U] ;
  long tmp ;
  size_t __len ;
  void *__ret ;
  long tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  long tmp___1 ;

  {
#line 318
  rc = 0;
#line 322
  tmp = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 322
  if (tmp != 0L) {
#line 323
    __ecryptfs_printk("\017%s: root iv:\n", "ecryptfs_derive_iv");
#line 324
    ecryptfs_dump_hex((char *)(& crypt_stat->root_iv), (int )crypt_stat->iv_bytes);
  } else {

  }
#line 330
  __len = crypt_stat->iv_bytes;
#line 330
  __ret = __builtin_memcpy((void *)(& src), (void const   *)(& crypt_stat->root_iv),
                           __len);
#line 331
  memset((void *)(& src) + crypt_stat->iv_bytes, 0, 16UL);
#line 332
  snprintf((char *)(& src) + crypt_stat->iv_bytes, 16UL, "%lld", offset);
#line 333
  tmp___0 = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 333
  if (tmp___0 != 0L) {
#line 334
    __ecryptfs_printk("\017%s: source:\n", "ecryptfs_derive_iv");
#line 335
    ecryptfs_dump_hex((char *)(& src), (int )((unsigned int )crypt_stat->iv_bytes + 16U));
  } else {

  }
#line 337
  rc = ecryptfs_calculate_md5((char *)(& dst), crypt_stat, (char *)(& src), (int )((unsigned int )crypt_stat->iv_bytes + 16U));
#line 339
  if (rc != 0) {
#line 340
    __ecryptfs_printk("\f%s: Error attempting to compute MD5 while generating IV for a page\n",
                      "ecryptfs_derive_iv");
#line 342
    goto out;
  } else {

  }
#line 344
  __len___0 = crypt_stat->iv_bytes;
#line 344
  __ret___0 = __builtin_memcpy((void *)iv, (void const   *)(& dst), __len___0);
#line 345
  tmp___1 = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 345
  if (tmp___1 != 0L) {
#line 346
    __ecryptfs_printk("\017%s: derived iv:\n", "ecryptfs_derive_iv");
#line 347
    ecryptfs_dump_hex(iv, (int )crypt_stat->iv_bytes);
  } else {

  }
  out: ;
#line 350
  return (rc);
}
}
#line 360 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_init_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;

  {
#line 362
  memset((void *)crypt_stat, 0, 880UL);
#line 363
  INIT_LIST_HEAD(& crypt_stat->keysig_list);
#line 364
  __mutex_init(& crypt_stat->keysig_list_mutex, "&crypt_stat->keysig_list_mutex",
               & __key);
#line 365
  __mutex_init(& crypt_stat->cs_mutex, "&crypt_stat->cs_mutex", & __key___0);
#line 366
  __mutex_init(& crypt_stat->cs_tfm_mutex, "&crypt_stat->cs_tfm_mutex", & __key___1);
#line 367
  __mutex_init(& crypt_stat->cs_hash_tfm_mutex, "&crypt_stat->cs_hash_tfm_mutex",
               & __key___2);
#line 368
  crypt_stat->flags = crypt_stat->flags | 1U;
#line 369
  return;
}
}
#line 377 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_destroy_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  struct ecryptfs_key_sig *key_sig ;
  struct ecryptfs_key_sig *key_sig_tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 381
  if ((unsigned long )crypt_stat->tfm != (unsigned long )((struct crypto_blkcipher *)0)) {
#line 382
    crypto_free_blkcipher(crypt_stat->tfm);
  } else {

  }
#line 383
  if ((unsigned long )crypt_stat->hash_tfm != (unsigned long )((struct crypto_hash *)0)) {
#line 384
    crypto_free_hash(crypt_stat->hash_tfm);
  } else {

  }
#line 385
  __mptr = (struct list_head  const  *)crypt_stat->keysig_list.next;
#line 385
  key_sig = (struct ecryptfs_key_sig *)__mptr;
#line 385
  __mptr___0 = (struct list_head  const  *)key_sig->crypt_stat_list.next;
#line 385
  key_sig_tmp = (struct ecryptfs_key_sig *)__mptr___0;
#line 385
  goto ldv_27492;
  ldv_27491: 
#line 387
  list_del(& key_sig->crypt_stat_list);
#line 388
  kmem_cache_free(ecryptfs_key_sig_cache, (void *)key_sig);
#line 385
  key_sig = key_sig_tmp;
#line 385
  __mptr___1 = (struct list_head  const  *)key_sig_tmp->crypt_stat_list.next;
#line 385
  key_sig_tmp = (struct ecryptfs_key_sig *)__mptr___1;
  ldv_27492: ;
#line 385
  if ((unsigned long )(& key_sig->crypt_stat_list) != (unsigned long )(& crypt_stat->keysig_list)) {
#line 386
    goto ldv_27491;
  } else {

  }
#line 390
  memset((void *)crypt_stat, 0, 880UL);
#line 391
  return;
}
}
#line 393 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_destroy_mount_crypt_stat(struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) 
{ 
  struct ecryptfs_global_auth_tok *auth_tok ;
  struct ecryptfs_global_auth_tok *auth_tok_tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 398
  if ((mount_crypt_stat->flags & 8U) == 0U) {
#line 399
    return;
  } else {

  }
#line 400
  ldv_mutex_lock_141(& mount_crypt_stat->global_auth_tok_list_mutex);
#line 401
  __mptr = (struct list_head  const  *)mount_crypt_stat->global_auth_tok_list.next;
#line 401
  auth_tok = (struct ecryptfs_global_auth_tok *)__mptr + 0xfffffffffffffff8UL;
#line 401
  __mptr___0 = (struct list_head  const  *)auth_tok->mount_crypt_stat_list.next;
#line 401
  auth_tok_tmp = (struct ecryptfs_global_auth_tok *)__mptr___0 + 0xfffffffffffffff8UL;
#line 401
  goto ldv_27506;
  ldv_27505: 
#line 404
  list_del(& auth_tok->mount_crypt_stat_list);
#line 405
  if ((unsigned long )auth_tok->global_auth_tok_key != (unsigned long )((struct key *)0) && (auth_tok->flags & 1U) == 0U) {
#line 407
    key_put(auth_tok->global_auth_tok_key);
  } else {

  }
#line 408
  kmem_cache_free(ecryptfs_global_auth_tok_cache, (void *)auth_tok);
#line 401
  auth_tok = auth_tok_tmp;
#line 401
  __mptr___1 = (struct list_head  const  *)auth_tok_tmp->mount_crypt_stat_list.next;
#line 401
  auth_tok_tmp = (struct ecryptfs_global_auth_tok *)__mptr___1 + 0xfffffffffffffff8UL;
  ldv_27506: ;
#line 401
  if ((unsigned long )auth_tok != (unsigned long )mount_crypt_stat) {
#line 402
    goto ldv_27505;
  } else {

  }
#line 410
  ldv_mutex_unlock_142(& mount_crypt_stat->global_auth_tok_list_mutex);
#line 411
  memset((void *)mount_crypt_stat, 0, 296UL);
#line 412
  return;
}
}
#line 427 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int virt_to_scatterlist(void const   *addr , int size , struct scatterlist *sg , int sg_size ) 
{ 
  int i ;
  struct page *pg ;
  int offset ;
  int remainder_of_page ;
  unsigned long tmp ;

  {
#line 430
  i = 0;
#line 435
  sg_init_table(sg, (unsigned int )sg_size);
#line 437
  goto ldv_27519;
  ldv_27518: 
#line 438
  tmp = __phys_addr((unsigned long )addr);
#line 438
  pg = 0xffffea0000000000UL + (tmp >> 12);
#line 439
  offset = (int )((long )addr) & 4095;
#line 440
  if ((unsigned long )sg != (unsigned long )((struct scatterlist *)0)) {
#line 441
    sg_set_page(sg + (unsigned long )i, pg, 0U, (unsigned int )offset);
  } else {

  }
#line 442
  remainder_of_page = (int )(4096U - (unsigned int )offset);
#line 443
  if (size >= remainder_of_page) {
#line 444
    if ((unsigned long )sg != (unsigned long )((struct scatterlist *)0)) {
#line 445
      (sg + (unsigned long )i)->length = (unsigned int )remainder_of_page;
    } else {

    }
#line 446
    addr = addr + (unsigned long )remainder_of_page;
#line 447
    size = size - remainder_of_page;
  } else {
#line 449
    if ((unsigned long )sg != (unsigned long )((struct scatterlist *)0)) {
#line 450
      (sg + (unsigned long )i)->length = (unsigned int )size;
    } else {

    }
#line 451
    addr = addr + (unsigned long )size;
#line 452
    size = 0;
  }
#line 454
  i = i + 1;
  ldv_27519: ;
#line 437
  if (size > 0 && i < sg_size) {
#line 438
    goto ldv_27518;
  } else {

  }

#line 456
  if (size > 0) {
#line 457
    return (-12);
  } else {

  }
#line 458
  return (i);
}
}
#line 471 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int encrypt_scatterlist(struct ecryptfs_crypt_stat *crypt_stat , struct scatterlist *dest_sg ,
                               struct scatterlist *src_sg , int size , unsigned char *iv ) 
{ 
  struct blkcipher_desc desc ;
  int rc ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 476
  desc.tfm = crypt_stat->tfm;
#line 476
  desc.info = (void *)iv;
#line 476
  desc.flags = 512U;
#line 481
  rc = 0;
#line 483
  tmp = __builtin_expect((unsigned long )crypt_stat == (unsigned long )((struct ecryptfs_crypt_stat *)0),
                         0L);
#line 483
  if (tmp != 0L) {
#line 483
    tmp___1 = 1;
  } else {
#line 483
    tmp___0 = __builtin_expect((unsigned long )crypt_stat->tfm == (unsigned long )((struct crypto_blkcipher *)0),
                               0L);
#line 483
    if (tmp___0 != 0L) {
#line 483
      tmp___1 = 1;
    } else {
#line 483
      tmp___1 = 0;
    }
  }
#line 483
  if (tmp___1 != 0) {
#line 483
    goto _L;
  } else {
#line 483
    tmp___2 = __builtin_expect((crypt_stat->flags & 1U) == 0U, 0L);
#line 483
    if (tmp___2 != 0L) {
      _L: /* CIL Label */ 
#line 483
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"),
                           "i" (484), "i" (12UL));
      ldv_27530: ;
#line 483
      goto ldv_27530;
    } else {

    }
  }
#line 485
  tmp___3 = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 485
  if (tmp___3 != 0L) {
#line 486
    __ecryptfs_printk("\017%s: Key size [%zd]; key:\n", "encrypt_scatterlist", crypt_stat->key_size);
#line 488
    ecryptfs_dump_hex((char *)(& crypt_stat->key), (int )crypt_stat->key_size);
  } else {

  }
#line 492
  ldv_mutex_lock_143(& crypt_stat->cs_tfm_mutex);
#line 493
  if ((crypt_stat->flags & 512U) == 0U) {
#line 494
    rc = crypto_blkcipher_setkey(crypt_stat->tfm, (u8 const   *)(& crypt_stat->key),
                                 (unsigned int )crypt_stat->key_size);
#line 496
    crypt_stat->flags = crypt_stat->flags | 512U;
  } else {

  }
#line 498
  if (rc != 0) {
#line 499
    __ecryptfs_printk("\v%s: Error setting key; rc = [%d]\n", "encrypt_scatterlist",
                      rc);
#line 501
    ldv_mutex_unlock_144(& crypt_stat->cs_tfm_mutex);
#line 502
    rc = -22;
#line 503
    goto out;
  } else {

  }
#line 505
  __ecryptfs_printk("\017%s: Encrypting [%d] bytes.\n", "encrypt_scatterlist", size);
#line 506
  crypto_blkcipher_encrypt_iv(& desc, dest_sg, src_sg, (unsigned int )size);
#line 507
  ldv_mutex_unlock_145(& crypt_stat->cs_tfm_mutex);
  out: ;
#line 509
  return (rc);
}
}
#line 517 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static void ecryptfs_lower_offset_for_extent(loff_t *offset , loff_t extent_num ,
                                             struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  size_t tmp ;

  {
#line 520
  tmp = ecryptfs_lower_header_size(crypt_stat);
#line 520
  *offset = (loff_t )((unsigned long long )tmp + (unsigned long long )crypt_stat->extent_size * (unsigned long long )extent_num);
#line 522
  return;
}
}
#line 537 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_encrypt_extent(struct page *enc_extent_page , struct ecryptfs_crypt_stat *crypt_stat ,
                                   struct page *page , unsigned long extent_offset ) 
{ 
  loff_t extent_base ;
  char extent_iv[16U] ;
  int rc ;

  {
#line 546
  extent_base = (loff_t )((unsigned long long )page->ldv_18093.ldv_18077.index * (unsigned long long )(4096UL / crypt_stat->extent_size));
#line 548
  rc = ecryptfs_derive_iv((char *)(& extent_iv), crypt_stat, (loff_t )((unsigned long long )extent_base + (unsigned long long )extent_offset));
#line 550
  if (rc != 0) {
#line 551
    __ecryptfs_printk("\v%s: Error attempting to derive IV for extent [0x%.16llx]; rc = [%d]\n",
                      "ecryptfs_encrypt_extent", (unsigned long long )extent_base + (unsigned long long )extent_offset,
                      rc);
#line 554
    goto out;
  } else {

  }
#line 556
  rc = ecryptfs_encrypt_page_offset(crypt_stat, enc_extent_page, 0, page, (int )((unsigned int )crypt_stat->extent_size * (unsigned int )extent_offset),
                                    (int )crypt_stat->extent_size, (unsigned char *)(& extent_iv));
#line 560
  if (rc < 0) {
#line 561
    printk("\v%s: Error attempting to encrypt page with page->index = [%ld], extent_offset = [%ld]; rc = [%d]\n",
           "ecryptfs_encrypt_extent", page->ldv_18093.ldv_18077.index, extent_offset,
           rc);
#line 565
    goto out;
  } else {

  }
#line 567
  rc = 0;
  out: ;
#line 569
  return (rc);
}
}
#line 588 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_encrypt_page(struct page *page ) 
{ 
  struct inode *ecryptfs_inode ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  char *enc_extent_virt ;
  struct page *enc_extent_page ;
  loff_t extent_offset ;
  int rc ;
  struct ecryptfs_inode_info *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  loff_t offset ;

  {
#line 593
  enc_extent_page = 0;
#line 595
  rc = 0;
#line 597
  ecryptfs_inode = (page->mapping)->host;
#line 598
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 598
  crypt_stat = & tmp->crypt_stat;
#line 600
  tmp___0 = __builtin_expect((crypt_stat->flags & 4U) == 0U, 0L);
#line 600
  if (tmp___0 != 0L) {
#line 600
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"),
                         "i" (600), "i" (12UL));
    ldv_27558: ;
#line 600
    goto ldv_27558;
  } else {

  }
#line 601
  enc_extent_page = alloc_pages(131280U, 0U);
#line 602
  if ((unsigned long )enc_extent_page == (unsigned long )((struct page *)0)) {
#line 603
    rc = -12;
#line 604
    __ecryptfs_printk("\v%s: Error allocating memory for encrypted extent\n", "ecryptfs_encrypt_page");
#line 606
    goto out;
  } else {

  }
#line 608
  tmp___1 = kmap(enc_extent_page);
#line 608
  enc_extent_virt = (char *)tmp___1;
#line 609
  extent_offset = 0LL;
#line 609
  goto ldv_27563;
  ldv_27562: 
#line 614
  rc = ecryptfs_encrypt_extent(enc_extent_page, crypt_stat, page, (unsigned long )extent_offset);
#line 616
  if (rc != 0) {
#line 617
    printk("\v%s: Error encrypting extent; rc = [%d]\n", "ecryptfs_encrypt_page",
           rc);
#line 619
    goto out;
  } else {

  }
#line 621
  ecryptfs_lower_offset_for_extent(& offset, (loff_t )((unsigned long long )page->ldv_18093.ldv_18077.index * (unsigned long long )(4096UL / crypt_stat->extent_size) + (unsigned long long )extent_offset),
                                   crypt_stat);
#line 626
  rc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, offset, crypt_stat->extent_size);
#line 628
  if (rc < 0) {
#line 629
    __ecryptfs_printk("\v%s: Error attempting to write lower page; rc = [%d]\n", "ecryptfs_encrypt_page",
                      rc);
#line 632
    goto out;
  } else {

  }
#line 611
  extent_offset = extent_offset + 1LL;
  ldv_27563: ;
#line 609
  if ((unsigned long long )extent_offset < (unsigned long long )(4096UL / crypt_stat->extent_size)) {
#line 611
    goto ldv_27562;
  } else {

  }
#line 635
  rc = 0;
  out: ;
#line 637
  if ((unsigned long )enc_extent_page != (unsigned long )((struct page *)0)) {
#line 638
    kunmap(enc_extent_page);
#line 639
    __free_pages(enc_extent_page, 0U);
  } else {

  }
#line 641
  return (rc);
}
}
#line 644 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_decrypt_extent(struct page *page , struct ecryptfs_crypt_stat *crypt_stat ,
                                   struct page *enc_extent_page , unsigned long extent_offset ) 
{ 
  loff_t extent_base ;
  char extent_iv[16U] ;
  int rc ;

  {
#line 653
  extent_base = (loff_t )((unsigned long long )page->ldv_18093.ldv_18077.index * (unsigned long long )(4096UL / crypt_stat->extent_size));
#line 655
  rc = ecryptfs_derive_iv((char *)(& extent_iv), crypt_stat, (loff_t )((unsigned long long )extent_base + (unsigned long long )extent_offset));
#line 657
  if (rc != 0) {
#line 658
    __ecryptfs_printk("\v%s: Error attempting to derive IV for extent [0x%.16llx]; rc = [%d]\n",
                      "ecryptfs_decrypt_extent", (unsigned long long )extent_base + (unsigned long long )extent_offset,
                      rc);
#line 661
    goto out;
  } else {

  }
#line 663
  rc = ecryptfs_decrypt_page_offset(crypt_stat, page, (int )((unsigned int )crypt_stat->extent_size * (unsigned int )extent_offset),
                                    enc_extent_page, 0, (int )crypt_stat->extent_size,
                                    (unsigned char *)(& extent_iv));
#line 668
  if (rc < 0) {
#line 669
    printk("\v%s: Error attempting to decrypt to page with page->index = [%ld], extent_offset = [%ld]; rc = [%d]\n",
           "ecryptfs_decrypt_extent", page->ldv_18093.ldv_18077.index, extent_offset,
           rc);
#line 673
    goto out;
  } else {

  }
#line 675
  rc = 0;
  out: ;
#line 677
  return (rc);
}
}
#line 696 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_decrypt_page(struct page *page ) 
{ 
  struct inode *ecryptfs_inode ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  char *enc_extent_virt ;
  struct page *enc_extent_page ;
  unsigned long extent_offset ;
  int rc ;
  struct ecryptfs_inode_info *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  loff_t offset ;

  {
#line 701
  enc_extent_page = 0;
#line 703
  rc = 0;
#line 705
  ecryptfs_inode = (page->mapping)->host;
#line 706
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 706
  crypt_stat = & tmp->crypt_stat;
#line 708
  tmp___0 = __builtin_expect((crypt_stat->flags & 4U) == 0U, 0L);
#line 708
  if (tmp___0 != 0L) {
#line 708
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"),
                         "i" (708), "i" (12UL));
    ldv_27585: ;
#line 708
    goto ldv_27585;
  } else {

  }
#line 709
  enc_extent_page = alloc_pages(131280U, 0U);
#line 710
  if ((unsigned long )enc_extent_page == (unsigned long )((struct page *)0)) {
#line 711
    rc = -12;
#line 712
    __ecryptfs_printk("\v%s: Error allocating memory for encrypted extent\n", "ecryptfs_decrypt_page");
#line 714
    goto out;
  } else {

  }
#line 716
  tmp___1 = kmap(enc_extent_page);
#line 716
  enc_extent_virt = (char *)tmp___1;
#line 717
  extent_offset = 0UL;
#line 717
  goto ldv_27590;
  ldv_27589: 
#line 722
  ecryptfs_lower_offset_for_extent(& offset, (loff_t )(page->ldv_18093.ldv_18077.index * (4096UL / crypt_stat->extent_size) + extent_offset),
                                   crypt_stat);
#line 726
  rc = ecryptfs_read_lower(enc_extent_virt, offset, crypt_stat->extent_size, ecryptfs_inode);
#line 729
  if (rc < 0) {
#line 730
    __ecryptfs_printk("\v%s: Error attempting to read lower page; rc = [%d]\n", "ecryptfs_decrypt_page",
                      rc);
#line 733
    goto out;
  } else {

  }
#line 735
  rc = ecryptfs_decrypt_extent(page, crypt_stat, enc_extent_page, extent_offset);
#line 737
  if (rc != 0) {
#line 738
    printk("\v%s: Error encrypting extent; rc = [%d]\n", "ecryptfs_decrypt_page",
           rc);
#line 740
    goto out;
  } else {

  }
#line 719
  extent_offset = extent_offset + 1UL;
  ldv_27590: ;
#line 717
  if (4096UL / crypt_stat->extent_size > extent_offset) {
#line 719
    goto ldv_27589;
  } else {

  }

  out: ;
#line 744
  if ((unsigned long )enc_extent_page != (unsigned long )((struct page *)0)) {
#line 745
    kunmap(enc_extent_page);
#line 746
    __free_pages(enc_extent_page, 0U);
  } else {

  }
#line 748
  return (rc);
}
}
#line 761 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int decrypt_scatterlist(struct ecryptfs_crypt_stat *crypt_stat , struct scatterlist *dest_sg ,
                               struct scatterlist *src_sg , int size , unsigned char *iv ) 
{ 
  struct blkcipher_desc desc ;
  int rc ;

  {
#line 766
  desc.tfm = crypt_stat->tfm;
#line 766
  desc.info = (void *)iv;
#line 766
  desc.flags = 512U;
#line 771
  rc = 0;
#line 774
  ldv_mutex_lock_146(& crypt_stat->cs_tfm_mutex);
#line 775
  rc = crypto_blkcipher_setkey(crypt_stat->tfm, (u8 const   *)(& crypt_stat->key),
                               (unsigned int )crypt_stat->key_size);
#line 777
  if (rc != 0) {
#line 778
    __ecryptfs_printk("\v%s: Error setting key; rc = [%d]\n", "decrypt_scatterlist",
                      rc);
#line 780
    ldv_mutex_unlock_147(& crypt_stat->cs_tfm_mutex);
#line 781
    rc = -22;
#line 782
    goto out;
  } else {

  }
#line 784
  __ecryptfs_printk("\017%s: Decrypting [%d] bytes.\n", "decrypt_scatterlist", size);
#line 785
  rc = crypto_blkcipher_decrypt_iv(& desc, dest_sg, src_sg, (unsigned int )size);
#line 786
  ldv_mutex_unlock_148(& crypt_stat->cs_tfm_mutex);
#line 787
  if (rc != 0) {
#line 788
    __ecryptfs_printk("\v%s: Error decrypting; rc = [%d]\n", "decrypt_scatterlist",
                      rc);
#line 790
    goto out;
  } else {

  }
#line 792
  rc = size;
  out: ;
#line 794
  return (rc);
}
}
#line 810 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_encrypt_page_offset(struct ecryptfs_crypt_stat *crypt_stat , struct page *dst_page ,
                                        int dst_offset , struct page *src_page , int src_offset ,
                                        int size , unsigned char *iv ) 
{ 
  struct scatterlist src_sg ;
  struct scatterlist dst_sg ;
  int tmp ;

  {
#line 817
  sg_init_table(& src_sg, 1U);
#line 818
  sg_init_table(& dst_sg, 1U);
#line 820
  sg_set_page(& src_sg, src_page, (unsigned int )size, (unsigned int )src_offset);
#line 821
  sg_set_page(& dst_sg, dst_page, (unsigned int )size, (unsigned int )dst_offset);
#line 822
  tmp = encrypt_scatterlist(crypt_stat, & dst_sg, & src_sg, size, iv);
#line 822
  return (tmp);
}
}
#line 838 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_decrypt_page_offset(struct ecryptfs_crypt_stat *crypt_stat , struct page *dst_page ,
                                        int dst_offset , struct page *src_page , int src_offset ,
                                        int size , unsigned char *iv ) 
{ 
  struct scatterlist src_sg ;
  struct scatterlist dst_sg ;
  int tmp ;

  {
#line 845
  sg_init_table(& src_sg, 1U);
#line 846
  sg_set_page(& src_sg, src_page, (unsigned int )size, (unsigned int )src_offset);
#line 848
  sg_init_table(& dst_sg, 1U);
#line 849
  sg_set_page(& dst_sg, dst_page, (unsigned int )size, (unsigned int )dst_offset);
#line 851
  tmp = decrypt_scatterlist(crypt_stat, & dst_sg, & src_sg, size, iv);
#line 851
  return (tmp);
}
}
#line 865 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  char *full_alg_name ;
  int rc ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 868
  rc = -22;
#line 870
  if ((unsigned long )(& crypt_stat->cipher) == (unsigned long )((unsigned char (*)[32U])0)) {
#line 871
    __ecryptfs_printk("\v%s: No cipher specified\n", "ecryptfs_init_crypt_ctx");
#line 872
    goto out;
  } else {

  }
#line 874
  tmp = strlen((char const   *)(& crypt_stat->cipher));
#line 874
  __ecryptfs_printk("\017%s: Initializing cipher [%s]; strlen = [%d]; key_size_bits = [%zd]\n",
                    "ecryptfs_init_crypt_ctx", (unsigned char *)(& crypt_stat->cipher),
                    (int )tmp, crypt_stat->key_size << 3);
#line 879
  if ((unsigned long )crypt_stat->tfm != (unsigned long )((struct crypto_blkcipher *)0)) {
#line 880
    rc = 0;
#line 881
    goto out;
  } else {

  }
#line 883
  ldv_mutex_lock_149(& crypt_stat->cs_tfm_mutex);
#line 884
  rc = ecryptfs_crypto_api_algify_cipher_name(& full_alg_name, (char *)(& crypt_stat->cipher),
                                              (char *)"cbc");
#line 886
  if (rc != 0) {
#line 887
    goto out_unlock;
  } else {

  }
#line 888
  crypt_stat->tfm = crypto_alloc_blkcipher((char const   *)full_alg_name, 0U, 128U);
#line 890
  kfree((void const   *)full_alg_name);
#line 891
  tmp___1 = IS_ERR((void const   *)crypt_stat->tfm);
#line 891
  if (tmp___1 != 0L) {
#line 892
    tmp___0 = PTR_ERR((void const   *)crypt_stat->tfm);
#line 892
    rc = (int )tmp___0;
#line 893
    crypt_stat->tfm = 0;
#line 894
    __ecryptfs_printk("\v%s: cryptfs: init_crypt_ctx(): Error initializing cipher [%s]\n",
                      "ecryptfs_init_crypt_ctx", (unsigned char *)(& crypt_stat->cipher));
#line 897
    goto out_unlock;
  } else {

  }
#line 899
  crypto_blkcipher_set_flags(crypt_stat->tfm, 256U);
#line 900
  rc = 0;
  out_unlock: 
#line 902
  ldv_mutex_unlock_150(& crypt_stat->cs_tfm_mutex);
  out: ;
#line 904
  return (rc);
}
}
#line 907 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static void set_extent_mask_and_shift(struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  int extent_size_tmp ;

  {
#line 911
  crypt_stat->extent_mask = 4294967295U;
#line 912
  crypt_stat->extent_shift = 0UL;
#line 913
  if (crypt_stat->extent_size == 0UL) {
#line 914
    return;
  } else {

  }
#line 915
  extent_size_tmp = (int )crypt_stat->extent_size;
#line 916
  goto ldv_27638;
  ldv_27637: 
#line 917
  extent_size_tmp = extent_size_tmp >> 1;
#line 918
  crypt_stat->extent_mask = crypt_stat->extent_mask << 1;
#line 919
  crypt_stat->extent_shift = crypt_stat->extent_shift + 1UL;
  ldv_27638: ;
#line 916
  if ((extent_size_tmp & 1) == 0) {
#line 917
    goto ldv_27637;
  } else {

  }

#line 921
  return;
}
}
#line 923 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat ) 
{ 


  {
#line 927
  crypt_stat->extent_size = 4096UL;
#line 928
  set_extent_mask_and_shift(crypt_stat);
#line 929
  crypt_stat->iv_bytes = 16UL;
#line 930
  if ((crypt_stat->flags & 128U) != 0U) {
#line 931
    crypt_stat->metadata_size = 8192UL;
  } else {
#line 934
    crypt_stat->metadata_size = 8192UL;
  }
#line 938
  return;
}
}
#line 947 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  int rc ;
  char dst[16U] ;
  long tmp ;
  long tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 949
  rc = 0;
#line 952
  tmp = __builtin_expect(crypt_stat->iv_bytes > 16UL, 0L);
#line 952
  if (tmp != 0L) {
#line 952
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"),
                         "i" (952), "i" (12UL));
    ldv_27648: ;
#line 952
    goto ldv_27648;
  } else {

  }
#line 953
  tmp___0 = __builtin_expect(crypt_stat->iv_bytes == 0UL, 0L);
#line 953
  if (tmp___0 != 0L) {
#line 953
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"),
                         "i" (953), "i" (12UL));
    ldv_27649: ;
#line 953
    goto ldv_27649;
  } else {

  }
#line 954
  if ((crypt_stat->flags & 64U) == 0U) {
#line 955
    rc = -22;
#line 956
    __ecryptfs_printk("\f%s: Session key not valid; cannot generate root IV\n", "ecryptfs_compute_root_iv");
#line 958
    goto out;
  } else {

  }
#line 960
  rc = ecryptfs_calculate_md5((char *)(& dst), crypt_stat, (char *)(& crypt_stat->key),
                              (int )crypt_stat->key_size);
#line 962
  if (rc != 0) {
#line 963
    __ecryptfs_printk("\f%s: Error attempting to compute MD5 while generating root IV\n",
                      "ecryptfs_compute_root_iv");
#line 965
    goto out;
  } else {

  }
#line 967
  __len = crypt_stat->iv_bytes;
#line 967
  __ret = __builtin_memcpy((void *)(& crypt_stat->root_iv), (void const   *)(& dst),
                           __len);
  out: ;
#line 969
  if (rc != 0) {
#line 970
    memset((void *)(& crypt_stat->root_iv), 0, crypt_stat->iv_bytes);
#line 971
    crypt_stat->flags = crypt_stat->flags | 8U;
  } else {

  }
#line 973
  return (rc);
}
}
#line 976 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static void ecryptfs_generate_new_key(struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  long tmp ;

  {
#line 978
  get_random_bytes((void *)(& crypt_stat->key), (int )crypt_stat->key_size);
#line 979
  crypt_stat->flags = crypt_stat->flags | 64U;
#line 980
  ecryptfs_compute_root_iv(crypt_stat);
#line 981
  tmp = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 981
  if (tmp != 0L) {
#line 982
    __ecryptfs_printk("\017%s: Generated new session key:\n", "ecryptfs_generate_new_key");
#line 983
    ecryptfs_dump_hex((char *)(& crypt_stat->key), (int )crypt_stat->key_size);
  } else {

  }
#line 986
  return;
}
}
#line 996 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static void ecryptfs_copy_mount_wide_flags_to_inode_flags(struct ecryptfs_crypt_stat *crypt_stat ,
                                                          struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) 
{ 


  {
#line 1000
  if ((mount_crypt_stat->flags & 2U) != 0U) {
#line 1001
    crypt_stat->flags = crypt_stat->flags | 128U;
  } else {

  }
#line 1002
  if ((mount_crypt_stat->flags & 4U) != 0U) {
#line 1003
    crypt_stat->flags = crypt_stat->flags | 256U;
  } else {

  }
#line 1004
  if ((mount_crypt_stat->flags & 16U) != 0U) {
#line 1005
    crypt_stat->flags = crypt_stat->flags | 1024U;
#line 1006
    if ((mount_crypt_stat->flags & 32U) != 0U) {
#line 1008
      crypt_stat->flags = crypt_stat->flags | 2048U;
    } else
#line 1009
    if ((mount_crypt_stat->flags & 64U) != 0U) {
#line 1011
      crypt_stat->flags = crypt_stat->flags | 4096U;
    } else {

    }
  } else {

  }
#line 1013
  return;
}
}
#line 1015 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_copy_mount_wide_sigs_to_inode_sigs(struct ecryptfs_crypt_stat *crypt_stat ,
                                                       struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) 
{ 
  struct ecryptfs_global_auth_tok *global_auth_tok ;
  int rc ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1020
  rc = 0;
#line 1022
  ldv_mutex_lock_151(& crypt_stat->keysig_list_mutex);
#line 1023
  ldv_mutex_lock_152(& mount_crypt_stat->global_auth_tok_list_mutex);
#line 1025
  __mptr = (struct list_head  const  *)mount_crypt_stat->global_auth_tok_list.next;
#line 1025
  global_auth_tok = (struct ecryptfs_global_auth_tok *)__mptr + 0xfffffffffffffff8UL;
#line 1025
  goto ldv_27676;
  ldv_27675: ;
#line 1028
  if ((global_auth_tok->flags & 2U) != 0U) {
#line 1029
    goto ldv_27673;
  } else {

  }
#line 1030
  rc = ecryptfs_add_keysig(crypt_stat, (char *)(& global_auth_tok->sig));
#line 1031
  if (rc != 0) {
#line 1032
    printk("\vError adding keysig; rc = [%d]\n", rc);
#line 1033
    goto out;
  } else {

  }
  ldv_27673: 
#line 1025
  __mptr___0 = (struct list_head  const  *)global_auth_tok->mount_crypt_stat_list.next;
#line 1025
  global_auth_tok = (struct ecryptfs_global_auth_tok *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_27676: ;
#line 1025
  if ((unsigned long )global_auth_tok != (unsigned long )mount_crypt_stat) {
#line 1026
    goto ldv_27675;
  } else {

  }

  out: 
#line 1038
  ldv_mutex_unlock_153(& mount_crypt_stat->global_auth_tok_list_mutex);
#line 1039
  ldv_mutex_unlock_154(& crypt_stat->keysig_list_mutex);
#line 1040
  return (rc);
}
}
#line 1050 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static void ecryptfs_set_default_crypt_stat_vals(struct ecryptfs_crypt_stat *crypt_stat ,
                                                 struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) 
{ 


  {
#line 1054
  ecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat, mount_crypt_stat);
#line 1056
  ecryptfs_set_default_sizes(crypt_stat);
#line 1057
  strcpy((char *)(& crypt_stat->cipher), "aes");
#line 1058
  crypt_stat->key_size = 16UL;
#line 1059
  crypt_stat->flags = crypt_stat->flags & 4294967231U;
#line 1060
  crypt_stat->file_version = 3U;
#line 1061
  crypt_stat->mount_crypt_stat = mount_crypt_stat;
#line 1062
  return;
}
}
#line 1083 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_new_file_context(struct inode *ecryptfs_inode ) 
{ 
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_inode_info *tmp ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct ecryptfs_sb_info *tmp___0 ;
  int cipher_name_len ;
  int rc ;
  size_t tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 1085
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 1085
  crypt_stat = & tmp->crypt_stat;
#line 1087
  tmp___0 = ecryptfs_superblock_to_private(ecryptfs_inode->i_sb);
#line 1087
  mount_crypt_stat = & tmp___0->mount_crypt_stat;
#line 1091
  rc = 0;
#line 1093
  ecryptfs_set_default_crypt_stat_vals(crypt_stat, mount_crypt_stat);
#line 1094
  crypt_stat->flags = crypt_stat->flags | 68U;
#line 1095
  ecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat, mount_crypt_stat);
#line 1097
  rc = ecryptfs_copy_mount_wide_sigs_to_inode_sigs(crypt_stat, mount_crypt_stat);
#line 1099
  if (rc != 0) {
#line 1100
    printk("\vError attempting to copy mount-wide key sigs to the inode key sigs; rc = [%d]\n",
           rc);
#line 1102
    goto out;
  } else {

  }
#line 1104
  tmp___1 = strlen((char const   *)(& mount_crypt_stat->global_default_cipher_name));
#line 1104
  cipher_name_len = (int )tmp___1;
#line 1106
  __len = (size_t )cipher_name_len;
#line 1106
  __ret = __builtin_memcpy((void *)(& crypt_stat->cipher), (void const   *)(& mount_crypt_stat->global_default_cipher_name),
                           __len);
#line 1109
  crypt_stat->cipher[cipher_name_len] = 0U;
#line 1110
  crypt_stat->key_size = mount_crypt_stat->global_default_cipher_key_size;
#line 1112
  ecryptfs_generate_new_key(crypt_stat);
#line 1113
  rc = ecryptfs_init_crypt_ctx(crypt_stat);
#line 1114
  if (rc != 0) {
#line 1115
    __ecryptfs_printk("\v%s: Error initializing cryptographic context for cipher [%s]: rc = [%d]\n",
                      "ecryptfs_new_file_context", (unsigned char *)(& crypt_stat->cipher),
                      rc);
  } else {

  }
  out: ;
#line 1119
  return (rc);
}
}
#line 1128 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_validate_marker(char *data ) 
{ 
  u32 m_1 ;
  u32 m_2 ;

  {
#line 1132
  m_1 = get_unaligned_be32((void const   *)data);
#line 1133
  m_2 = get_unaligned_be32((void const   *)data + 4U);
#line 1134
  if ((m_1 ^ 1015134197U) == m_2) {
#line 1135
    return (0);
  } else {

  }
#line 1136
  __ecryptfs_printk("\017%s: m_1 = [0x%.8x]; m_2 = [0x%.8x]; MAGIC_ECRYPTFS_MARKER = [0x%.8x]\n",
                    "ecryptfs_validate_marker", m_1, m_2, 1015134197);
#line 1139
  __ecryptfs_printk("\017%s: (m_1 ^ MAGIC_ECRYPTFS_MARKER) = [0x%.8x]\n", "ecryptfs_validate_marker",
                    m_1 ^ 1015134197U);
#line 1141
  return (-22);
}
}
#line 1150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static struct ecryptfs_flag_map_elem ecryptfs_flag_map[4U]  = {      {1U, 16U}, 
        {2U, 4U}, 
        {4U, 128U}, 
        {8U, 1024U}};
#line 1165 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_process_flags(struct ecryptfs_crypt_stat *crypt_stat , char *page_virt ,
                                  int *bytes_read ) 
{ 
  int rc ;
  int i ;
  u32 flags ;

  {
#line 1168
  rc = 0;
#line 1172
  flags = get_unaligned_be32((void const   *)page_virt);
#line 1173
  i = 0;
#line 1173
  goto ldv_27713;
  ldv_27712: ;
#line 1175
  if ((ecryptfs_flag_map[i].file_flag & flags) != 0U) {
#line 1176
    crypt_stat->flags = crypt_stat->flags | ecryptfs_flag_map[i].local_flag;
  } else {
#line 1178
    crypt_stat->flags = crypt_stat->flags & ~ ecryptfs_flag_map[i].local_flag;
  }
#line 1174
  i = i + 1;
  ldv_27713: ;
#line 1173
  if ((unsigned int )i <= 3U) {
#line 1174
    goto ldv_27712;
  } else {

  }
#line 1180
  crypt_stat->file_version = flags >> 24;
#line 1181
  *bytes_read = 4;
#line 1182
  return (rc);
}
}
#line 1192 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static void write_ecryptfs_marker(char *page_virt , size_t *written ) 
{ 
  u32 m_1 ;
  u32 m_2 ;

  {
#line 1196
  get_random_bytes((void *)(& m_1), 4);
#line 1197
  m_2 = m_1 ^ 1015134197U;
#line 1198
  put_unaligned_be32(m_1, (void *)page_virt);
#line 1199
  page_virt = page_virt + 4UL;
#line 1200
  put_unaligned_be32(m_2, (void *)page_virt);
#line 1201
  *written = 8UL;
#line 1202
  return;
}
}
#line 1204 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_write_crypt_stat_flags(char *page_virt , struct ecryptfs_crypt_stat *crypt_stat ,
                                     size_t *written ) 
{ 
  u32 flags ;
  int i ;

  {
#line 1208
  flags = 0U;
#line 1211
  i = 0;
#line 1211
  goto ldv_27729;
  ldv_27728: ;
#line 1213
  if ((crypt_stat->flags & ecryptfs_flag_map[i].local_flag) != 0U) {
#line 1214
    flags = ecryptfs_flag_map[i].file_flag | flags;
  } else {

  }
#line 1212
  i = i + 1;
  ldv_27729: ;
#line 1211
  if ((unsigned int )i <= 3U) {
#line 1212
    goto ldv_27728;
  } else {

  }
#line 1216
  flags = (u32 )((int )((unsigned char )crypt_stat->file_version) << 24) | flags;
#line 1217
  put_unaligned_be32(flags, (void *)page_virt);
#line 1218
  *written = 4UL;
#line 1219
  return;
}
}
#line 1230 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static struct ecryptfs_cipher_code_str_map_elem ecryptfs_cipher_code_str_map[8U]  = 
#line 1230
  {      {{'a', 'e', 's', '\000'}, 7U}, 
        {{'b', 'l', 'o', 'w', 'f', 'i', 's', 'h', '\000'}, 4U}, 
        {{'d', 'e', 's', '3', '_', 'e', 'd', 'e', '\000'}, 2U}, 
        {{'c', 'a', 's', 't', '5', '\000'}, 3U}, 
        {{'t', 'w', 'o', 'f', 'i', 's', 'h', '\000'}, 10U}, 
        {{'c', 'a', 's', 't', '6', '\000'}, 11U}, 
        {{'a', 'e', 's', '\000'}, 8U}, 
        {{'a', 'e', 's', '\000'}, 9U}};
#line 1248 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
u8 ecryptfs_code_for_cipher_string(char *cipher_name , size_t key_bytes ) 
{ 
  int i ;
  u8 code ;
  struct ecryptfs_cipher_code_str_map_elem *map ;
  int tmp ;
  int tmp___0 ;

  {
#line 1251
  code = 0U;
#line 1252
  map = (struct ecryptfs_cipher_code_str_map_elem *)(& ecryptfs_cipher_code_str_map);
#line 1255
  tmp___0 = strcmp((char const   *)cipher_name, "aes");
#line 1255
  if (tmp___0 == 0) {
#line 1256
    switch (key_bytes) {
    case 16UL: 
#line 1258
    code = 7U;
#line 1259
    goto ldv_27743;
    case 24UL: 
#line 1261
    code = 8U;
#line 1262
    goto ldv_27743;
    case 32UL: 
#line 1264
    code = 9U;
    }
    ldv_27743: ;
  } else {
#line 1267
    i = 0;
#line 1267
    goto ldv_27750;
    ldv_27749: 
#line 1268
    tmp = strcmp((char const   *)cipher_name, (char const   *)(& (map + (unsigned long )i)->cipher_str));
#line 1268
    if (tmp == 0) {
#line 1269
      code = (map + (unsigned long )i)->cipher_code;
#line 1270
      goto ldv_27748;
    } else {

    }
#line 1267
    i = i + 1;
    ldv_27750: ;
#line 1267
    if ((unsigned int )i <= 7U) {
#line 1268
      goto ldv_27749;
    } else {

    }
    ldv_27748: ;
  }
#line 1273
  return (code);
}
}
#line 1283 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_cipher_code_to_string(char *str , u8 cipher_code ) 
{ 
  int rc ;
  int i ;

  {
#line 1285
  rc = 0;
#line 1288
  *str = 0;
#line 1289
  i = 0;
#line 1289
  goto ldv_27760;
  ldv_27759: ;
#line 1290
  if ((int )ecryptfs_cipher_code_str_map[i].cipher_code == (int )cipher_code) {
#line 1291
    strcpy(str, (char const   *)(& ecryptfs_cipher_code_str_map[i].cipher_str));
  } else {

  }
#line 1289
  i = i + 1;
  ldv_27760: ;
#line 1289
  if ((unsigned int )i <= 7U) {
#line 1290
    goto ldv_27759;
  } else {

  }

#line 1292
  if ((int )((signed char )*str) == 0) {
#line 1293
    __ecryptfs_printk("\f%s: Cipher code not recognized: [%d]\n", "ecryptfs_cipher_code_to_string",
                      (int )cipher_code);
#line 1295
    rc = -22;
  } else {

  }
#line 1297
  return (rc);
}
}
#line 1300 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_read_and_validate_header_region(struct inode *inode ) 
{ 
  u8 file_size[16U] ;
  u8 *marker ;
  int rc ;

  {
#line 1303
  marker = (u8 *)(& file_size) + 8UL;
#line 1306
  rc = ecryptfs_read_lower((char *)(& file_size), 0LL, 16UL, inode);
#line 1308
  if ((unsigned int )rc <= 15U) {
#line 1309
    return (rc < 0 ? rc : -22);
  } else {

  }
#line 1310
  rc = ecryptfs_validate_marker((char *)marker);
#line 1311
  if (rc == 0) {
#line 1312
    ecryptfs_i_size_init((char const   *)(& file_size), inode);
  } else {

  }
#line 1313
  return (rc);
}
}
#line 1317 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_write_header_metadata(char *virt , struct ecryptfs_crypt_stat *crypt_stat ,
                                    size_t *written ) 
{ 
  u32 header_extent_size ;
  u16 num_header_extents_at_front ;

  {
#line 1324
  header_extent_size = (unsigned int )crypt_stat->extent_size;
#line 1325
  num_header_extents_at_front = (unsigned short )(crypt_stat->metadata_size / crypt_stat->extent_size);
#line 1327
  put_unaligned_be32(header_extent_size, (void *)virt);
#line 1328
  virt = virt + 4UL;
#line 1329
  put_unaligned_be16((int )num_header_extents_at_front, (void *)virt);
#line 1330
  *written = 6UL;
#line 1331
  return;
}
}
#line 1366 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_write_headers_virt(char *page_virt , size_t max , size_t *size ,
                                       struct ecryptfs_crypt_stat *crypt_stat , struct dentry *ecryptfs_dentry ) 
{ 
  int rc ;
  size_t written ;
  size_t offset ;

  {
#line 1375
  offset = 8UL;
#line 1376
  write_ecryptfs_marker(page_virt + offset, & written);
#line 1377
  offset = offset + written;
#line 1378
  ecryptfs_write_crypt_stat_flags(page_virt + offset, crypt_stat, & written);
#line 1380
  offset = offset + written;
#line 1381
  ecryptfs_write_header_metadata(page_virt + offset, crypt_stat, & written);
#line 1383
  offset = offset + written;
#line 1384
  rc = ecryptfs_generate_key_packet_set(page_virt + offset, crypt_stat, ecryptfs_dentry,
                                        & written, max - offset);
#line 1387
  if (rc != 0) {
#line 1388
    __ecryptfs_printk("\f%s: Error generating key packet set; rc = [%d]\n", "ecryptfs_write_headers_virt",
                      rc);
  } else {

  }
#line 1390
  if ((unsigned long )size != (unsigned long )((size_t *)0)) {
#line 1391
    offset = offset + written;
#line 1392
    *size = offset;
  } else {

  }
#line 1394
  return (rc);
}
}
#line 1398 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_write_metadata_to_contents(struct inode *ecryptfs_inode , char *virt ,
                                               size_t virt_len ) 
{ 
  int rc ;

  {
#line 1403
  rc = ecryptfs_write_lower(ecryptfs_inode, virt, 0LL, virt_len);
#line 1405
  if (rc < 0) {
#line 1406
    printk("\v%s: Error attempting to write header information to lower file; rc = [%d]\n",
           "ecryptfs_write_metadata_to_contents", rc);
  } else {
#line 1409
    rc = 0;
  }
#line 1410
  return (rc);
}
}
#line 1414 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry , char *page_virt ,
                                            size_t size ) 
{ 
  int rc ;

  {
#line 1419
  rc = ecryptfs_setxattr(ecryptfs_dentry, "user.ecryptfs", (void const   *)page_virt,
                         size, 0);
#line 1421
  return (rc);
}
}
#line 1424 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static unsigned long ecryptfs_get_zeroed_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *page ;
  void *tmp ;

  {
#line 1429
  page = alloc_pages(gfp_mask | 32768U, order);
#line 1430
  if ((unsigned long )page != (unsigned long )((struct page *)0)) {
#line 1431
    tmp = lowmem_page_address((struct page  const  *)page);
#line 1431
    return ((unsigned long )tmp);
  } else {

  }
#line 1432
  return (0UL);
}
}
#line 1448 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry , struct inode *ecryptfs_inode ) 
{ 
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_inode_info *tmp ;
  unsigned int order ;
  char *virt ;
  size_t virt_len ;
  size_t size ;
  int rc ;
  long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;

  {
#line 1451
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 1451
  crypt_stat = & tmp->crypt_stat;
#line 1456
  size = 0UL;
#line 1457
  rc = 0;
#line 1459
  tmp___0 = __builtin_expect((crypt_stat->flags & 4U) != 0U, 1L);
#line 1459
  if (tmp___0 != 0L) {
#line 1460
    if ((crypt_stat->flags & 64U) == 0U) {
#line 1461
      printk("\vKey is invalid; bailing out\n");
#line 1462
      rc = -22;
#line 1463
      goto out;
    } else {
#line 1466
      printk("\f%s: Encrypted flag not set\n", "ecryptfs_write_metadata");
#line 1468
      rc = -22;
#line 1469
      goto out;
    }
  } else {

  }
#line 1471
  virt_len = crypt_stat->metadata_size;
#line 1472
  tmp___1 = __get_order(virt_len);
#line 1472
  order = (unsigned int )tmp___1;
#line 1474
  tmp___2 = ecryptfs_get_zeroed_pages(208U, order);
#line 1474
  virt = (char *)tmp___2;
#line 1475
  if ((unsigned long )virt == (unsigned long )((char *)0)) {
#line 1476
    printk("\v%s: Out of memory\n", "ecryptfs_write_metadata");
#line 1477
    rc = -12;
#line 1478
    goto out;
  } else {

  }
#line 1481
  rc = ecryptfs_write_headers_virt(virt, virt_len, & size, crypt_stat, ecryptfs_dentry);
#line 1483
  tmp___3 = __builtin_expect(rc != 0, 0L);
#line 1483
  if (tmp___3 != 0L) {
#line 1484
    printk("\v%s: Error whilst writing headers; rc = [%d]\n", "ecryptfs_write_metadata",
           rc);
#line 1486
    goto out_free;
  } else {

  }
#line 1488
  if ((crypt_stat->flags & 128U) != 0U) {
#line 1489
    rc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt, size);
  } else {
#line 1492
    rc = ecryptfs_write_metadata_to_contents(ecryptfs_inode, virt, virt_len);
  }
#line 1494
  if (rc != 0) {
#line 1495
    printk("\v%s: Error writing metadata out to lower file; rc = [%d]\n", "ecryptfs_write_metadata",
           rc);
#line 1497
    goto out_free;
  } else {

  }
  out_free: 
#line 1500
  free_pages((unsigned long )virt, order);
  out: ;
#line 1502
  return (rc);
}
}
#line 1507 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int parse_header_metadata(struct ecryptfs_crypt_stat *crypt_stat , char *virt ,
                                 int *bytes_read , int validate_header_size ) 
{ 
  int rc ;
  u32 header_extent_size ;
  u16 num_header_extents_at_front ;

  {
#line 1511
  rc = 0;
#line 1515
  header_extent_size = get_unaligned_be32((void const   *)virt);
#line 1516
  virt = virt + 4UL;
#line 1517
  num_header_extents_at_front = get_unaligned_be16((void const   *)virt);
#line 1518
  crypt_stat->metadata_size = (unsigned long )num_header_extents_at_front * (unsigned long )header_extent_size;
#line 1520
  *bytes_read = 6;
#line 1521
  if (validate_header_size == 1 && crypt_stat->metadata_size <= 8191UL) {
#line 1524
    rc = -22;
#line 1525
    printk("\fInvalid header size: [%zd]\n", crypt_stat->metadata_size);
  } else {

  }
#line 1528
  return (rc);
}
}
#line 1539 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static void set_default_header_data(struct ecryptfs_crypt_stat *crypt_stat ) 
{ 


  {
#line 1541
  crypt_stat->metadata_size = 8192UL;
#line 1542
  return;
}
}
#line 1544 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_i_size_init(char const   *page_virt , struct inode *inode ) 
{ 
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  u64 file_size ;
  struct ecryptfs_inode_info *tmp ;
  struct ecryptfs_sb_info *tmp___0 ;
  struct inode *tmp___1 ;
  loff_t tmp___2 ;

  {
#line 1550
  tmp = ecryptfs_inode_to_private(inode);
#line 1550
  crypt_stat = & tmp->crypt_stat;
#line 1551
  tmp___0 = ecryptfs_superblock_to_private(inode->i_sb);
#line 1551
  mount_crypt_stat = & tmp___0->mount_crypt_stat;
#line 1553
  if ((mount_crypt_stat->flags & 4U) != 0U) {
#line 1554
    tmp___1 = ecryptfs_inode_to_lower(inode);
#line 1554
    tmp___2 = i_size_read((struct inode  const  *)tmp___1);
#line 1554
    file_size = (u64 )tmp___2;
#line 1555
    if ((crypt_stat->flags & 128U) != 0U) {
#line 1556
      file_size = (unsigned long long )crypt_stat->metadata_size + file_size;
    } else {

    }
  } else {
#line 1558
    file_size = get_unaligned_be64((void const   *)page_virt);
  }
#line 1559
  i_size_write(inode, (long long )file_size);
#line 1560
  crypt_stat->flags = crypt_stat->flags | 16384U;
#line 1561
  return;
}
}
#line 1575 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_read_headers_virt(char *page_virt , struct ecryptfs_crypt_stat *crypt_stat ,
                                      struct dentry *ecryptfs_dentry , int validate_header_size ) 
{ 
  int rc ;
  int offset ;
  int bytes_read ;
  struct ecryptfs_sb_info *tmp ;

  {
#line 1580
  rc = 0;
#line 1584
  ecryptfs_set_default_sizes(crypt_stat);
#line 1585
  tmp = ecryptfs_superblock_to_private(ecryptfs_dentry->d_sb);
#line 1585
  crypt_stat->mount_crypt_stat = & tmp->mount_crypt_stat;
#line 1587
  offset = 8;
#line 1588
  rc = ecryptfs_validate_marker(page_virt + (unsigned long )offset);
#line 1589
  if (rc != 0) {
#line 1590
    goto out;
  } else {

  }
#line 1591
  if ((crypt_stat->flags & 16384U) == 0U) {
#line 1592
    ecryptfs_i_size_init((char const   *)page_virt, ecryptfs_dentry->d_inode);
  } else {

  }
#line 1593
  offset = offset + 8;
#line 1594
  rc = ecryptfs_process_flags(crypt_stat, page_virt + (unsigned long )offset, & bytes_read);
#line 1596
  if (rc != 0) {
#line 1597
    __ecryptfs_printk("\f%s: Error processing flags\n", "ecryptfs_read_headers_virt");
#line 1598
    goto out;
  } else {

  }
#line 1600
  if (crypt_stat->file_version > 3U) {
#line 1601
    __ecryptfs_printk("\f%s: File version is [%d]; only file version [%d] is supported by this version of eCryptfs\n",
                      "ecryptfs_read_headers_virt", crypt_stat->file_version, 3);
#line 1606
    rc = -22;
#line 1607
    goto out;
  } else {

  }
#line 1609
  offset = offset + bytes_read;
#line 1610
  if (crypt_stat->file_version != 0U) {
#line 1611
    rc = parse_header_metadata(crypt_stat, page_virt + (unsigned long )offset, & bytes_read,
                               validate_header_size);
#line 1613
    if (rc != 0) {
#line 1614
      __ecryptfs_printk("\f%s: Error reading header metadata; rc = [%d]\n", "ecryptfs_read_headers_virt",
                        rc);
    } else {

    }
#line 1617
    offset = offset + bytes_read;
  } else {
#line 1619
    set_default_header_data(crypt_stat);
  }
#line 1620
  rc = ecryptfs_parse_packet_set(crypt_stat, (unsigned char *)page_virt + (unsigned long )offset,
                                 ecryptfs_dentry);
  out: ;
#line 1623
  return (rc);
}
}
#line 1636 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_read_xattr_region(char *page_virt , struct inode *ecryptfs_inode ) 
{ 
  struct dentry *lower_dentry ;
  struct ecryptfs_inode_info *tmp ;
  ssize_t size ;
  int rc ;
  long tmp___0 ;

  {
#line 1638
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 1638
  lower_dentry = (tmp->lower_file)->f_path.dentry;
#line 1641
  rc = 0;
#line 1643
  size = ecryptfs_getxattr_lower(lower_dentry, "user.ecryptfs", (void *)page_virt,
                                 4096UL);
#line 1645
  if (size < 0L) {
#line 1646
    tmp___0 = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 1646
    if (tmp___0 != 0L) {
#line 1647
      printk("\016Error attempting to read the [%s] xattr from the lower file; return value = [%zd]\n",
             (char *)"user.ecryptfs", size);
    } else {

    }
#line 1650
    rc = -22;
#line 1651
    goto out;
  } else {

  }
  out: ;
#line 1654
  return (rc);
}
}
#line 1657 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_read_and_validate_xattr_region(struct dentry *dentry , struct inode *inode ) 
{ 
  u8 file_size[16U] ;
  u8 *marker ;
  int rc ;
  struct dentry *tmp ;
  ssize_t tmp___0 ;

  {
#line 1661
  marker = (u8 *)(& file_size) + 8UL;
#line 1664
  tmp = ecryptfs_dentry_to_lower(dentry);
#line 1664
  tmp___0 = ecryptfs_getxattr_lower(tmp, "user.ecryptfs", (void *)(& file_size), 16UL);
#line 1664
  rc = (int )tmp___0;
#line 1667
  if ((unsigned int )rc <= 15U) {
#line 1668
    return (rc < 0 ? rc : -22);
  } else {

  }
#line 1669
  rc = ecryptfs_validate_marker((char *)marker);
#line 1670
  if (rc == 0) {
#line 1671
    ecryptfs_i_size_init((char const   *)(& file_size), inode);
  } else {

  }
#line 1672
  return (rc);
}
}
#line 1687 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_read_metadata(struct dentry *ecryptfs_dentry ) 
{ 
  int rc ;
  char *page_virt ;
  struct inode *ecryptfs_inode ;
  struct ecryptfs_crypt_stat *crypt_stat ;
  struct ecryptfs_inode_info *tmp ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct ecryptfs_sb_info *tmp___0 ;
  void *tmp___1 ;

  {
#line 1691
  ecryptfs_inode = ecryptfs_dentry->d_inode;
#line 1692
  tmp = ecryptfs_inode_to_private(ecryptfs_inode);
#line 1692
  crypt_stat = & tmp->crypt_stat;
#line 1694
  tmp___0 = ecryptfs_superblock_to_private(ecryptfs_dentry->d_sb);
#line 1694
  mount_crypt_stat = & tmp___0->mount_crypt_stat;
#line 1698
  ecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat, mount_crypt_stat);
#line 1701
  tmp___1 = kmem_cache_alloc(ecryptfs_header_cache, 131280U);
#line 1701
  page_virt = (char *)tmp___1;
#line 1702
  if ((unsigned long )page_virt == (unsigned long )((char *)0)) {
#line 1703
    rc = -12;
#line 1704
    printk("\v%s: Unable to allocate page_virt\n", "ecryptfs_read_metadata");
#line 1706
    goto out;
  } else {

  }
#line 1708
  rc = ecryptfs_read_lower(page_virt, 0LL, crypt_stat->extent_size, ecryptfs_inode);
#line 1710
  if (rc >= 0) {
#line 1711
    rc = ecryptfs_read_headers_virt(page_virt, crypt_stat, ecryptfs_dentry, 1);
  } else {

  }
#line 1714
  if (rc != 0) {
#line 1716
    memset((void *)page_virt, 0, 4096UL);
#line 1717
    rc = ecryptfs_read_xattr_region(page_virt, ecryptfs_inode);
#line 1718
    if (rc != 0) {
#line 1719
      printk("\017Valid eCryptfs headers not found in file header region or xattr region, inode %lu\n",
             ecryptfs_inode->i_ino);
#line 1722
      rc = -22;
#line 1723
      goto out;
    } else {

    }
#line 1725
    rc = ecryptfs_read_headers_virt(page_virt, crypt_stat, ecryptfs_dentry, 0);
#line 1728
    if (rc != 0) {
#line 1729
      printk("\017Valid eCryptfs headers not found in file xattr region either, inode %lu\n",
             ecryptfs_inode->i_ino);
#line 1732
      rc = -22;
    } else {

    }
#line 1734
    if (((crypt_stat->mount_crypt_stat)->flags & 2U) != 0U) {
#line 1736
      crypt_stat->flags = crypt_stat->flags | 128U;
    } else {
#line 1738
      printk("\fAttempt to access file with crypto metadata only in the extended attribute region, but eCryptfs was mounted without xattr support enabled. eCryptfs will not treat this like an encrypted file, inode %lu\n",
             ecryptfs_inode->i_ino);
#line 1744
      rc = -22;
    }
  } else {

  }
  out: ;
#line 1748
  if ((unsigned long )page_virt != (unsigned long )((char *)0)) {
#line 1749
    memset((void *)page_virt, 0, 4096UL);
#line 1750
    kmem_cache_free(ecryptfs_header_cache, (void *)page_virt);
  } else {

  }
#line 1752
  return (rc);
}
}
#line 1765 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_encrypt_filename(struct ecryptfs_filename *filename , struct ecryptfs_crypt_stat *crypt_stat ,
                                     struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) 
{ 
  int rc ;
  size_t packet_size ;
  size_t remaining_bytes ;
  void *tmp ;

  {
#line 1769
  rc = 0;
#line 1771
  filename->encrypted_filename = 0;
#line 1772
  filename->encrypted_filename_size = 0UL;
#line 1773
  if (((unsigned long )crypt_stat != (unsigned long )((struct ecryptfs_crypt_stat *)0) && (crypt_stat->flags & 2048U) != 0U) || ((unsigned long )mount_crypt_stat != (unsigned long )((struct ecryptfs_mount_crypt_stat *)0) && (mount_crypt_stat->flags & 32U) != 0U)) {
#line 1779
    rc = ecryptfs_write_tag_70_packet(0, 0, & filename->encrypted_filename_size, mount_crypt_stat,
                                      0, filename->filename_size);
#line 1784
    if (rc != 0) {
#line 1785
      printk("\v%s: Error attempting to get packet size for tag 72; rc = [%d]\n",
             "ecryptfs_encrypt_filename", rc);
#line 1788
      filename->encrypted_filename_size = 0UL;
#line 1789
      goto out;
    } else {

    }
#line 1791
    tmp = kmalloc(filename->encrypted_filename_size, 208U);
#line 1791
    filename->encrypted_filename = (char *)tmp;
#line 1793
    if ((unsigned long )filename->encrypted_filename == (unsigned long )((char *)0)) {
#line 1794
      printk("\v%s: Out of memory whilst attempting to kmalloc [%zd] bytes\n", "ecryptfs_encrypt_filename",
             filename->encrypted_filename_size);
#line 1797
      rc = -12;
#line 1798
      goto out;
    } else {

    }
#line 1800
    remaining_bytes = filename->encrypted_filename_size;
#line 1801
    rc = ecryptfs_write_tag_70_packet(filename->encrypted_filename, & remaining_bytes,
                                      & packet_size, mount_crypt_stat, filename->filename,
                                      filename->filename_size);
#line 1807
    if (rc != 0) {
#line 1808
      printk("\v%s: Error attempting to generate tag 70 packet; rc = [%d]\n", "ecryptfs_encrypt_filename",
             rc);
#line 1811
      kfree((void const   *)filename->encrypted_filename);
#line 1812
      filename->encrypted_filename = 0;
#line 1813
      filename->encrypted_filename_size = 0UL;
#line 1814
      goto out;
    } else {

    }
#line 1816
    filename->encrypted_filename_size = packet_size;
  } else {
#line 1818
    printk("\v%s: No support for requested filename encryption method in this release\n",
           "ecryptfs_encrypt_filename");
#line 1820
    rc = -95;
#line 1821
    goto out;
  }
  out: ;
#line 1824
  return (rc);
}
}
#line 1827 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_copy_filename(char **copied_name , size_t *copied_name_size ,
                                  char const   *name , size_t name_size ) 
{ 
  int rc ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1830
  rc = 0;
#line 1832
  tmp = kmalloc(name_size + 1UL, 208U);
#line 1832
  *copied_name = (char *)tmp;
#line 1833
  if ((unsigned long )*copied_name == (unsigned long )((char *)0)) {
#line 1834
    rc = -12;
#line 1835
    goto out;
  } else {

  }
#line 1837
  __len = name_size;
#line 1837
  __ret = __builtin_memcpy((void *)*copied_name, (void const   *)name, __len);
#line 1838
  *(*copied_name + name_size) = 0;
#line 1842
  *copied_name_size = name_size;
  out: ;
#line 1844
  return (rc);
}
}
#line 1858 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static int ecryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm , char *cipher_name ,
                                       size_t *key_size ) 
{ 
  char dummy_key[64U] ;
  char *full_alg_name ;
  int rc ;
  long tmp ;
  long tmp___0 ;
  struct blkcipher_alg *alg ;
  struct blkcipher_alg *tmp___1 ;

  {
#line 1862
  full_alg_name = 0;
#line 1865
  *key_tfm = 0;
#line 1866
  if (*key_size > 64UL) {
#line 1867
    rc = -22;
#line 1868
    printk("\vRequested key size is [%zd] bytes; maximum allowable is [%d]\n", *key_size,
           64);
#line 1870
    goto out;
  } else {

  }
#line 1872
  rc = ecryptfs_crypto_api_algify_cipher_name(& full_alg_name, cipher_name, (char *)"ecb");
#line 1874
  if (rc != 0) {
#line 1875
    goto out;
  } else {

  }
#line 1876
  *key_tfm = crypto_alloc_blkcipher((char const   *)full_alg_name, 0U, 128U);
#line 1877
  tmp___0 = IS_ERR((void const   *)*key_tfm);
#line 1877
  if (tmp___0 != 0L) {
#line 1878
    tmp = PTR_ERR((void const   *)*key_tfm);
#line 1878
    rc = (int )tmp;
#line 1879
    printk("\vUnable to allocate crypto cipher with name [%s]; rc = [%d]\n", full_alg_name,
           rc);
#line 1881
    goto out;
  } else {

  }
#line 1883
  crypto_blkcipher_set_flags(*key_tfm, 256U);
#line 1884
  if (*key_size == 0UL) {
#line 1885
    tmp___1 = crypto_blkcipher_alg(*key_tfm);
#line 1885
    alg = tmp___1;
#line 1887
    *key_size = (size_t )alg->max_keysize;
  } else {

  }
#line 1889
  get_random_bytes((void *)(& dummy_key), (int )*key_size);
#line 1890
  rc = crypto_blkcipher_setkey(*key_tfm, (u8 const   *)(& dummy_key), (unsigned int )*key_size);
#line 1891
  if (rc != 0) {
#line 1892
    printk("\vError attempting to set key of size [%zd] for cipher [%s]; rc = [%d]\n",
           *key_size, full_alg_name, rc);
#line 1895
    rc = -22;
#line 1896
    goto out;
  } else {

  }
  out: 
#line 1899
  kfree((void const   *)full_alg_name);
#line 1900
  return (rc);
}
}
#line 1904 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static struct list_head key_tfm_list  ;
#line 1907 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_init_crypto(void) 
{ 
  struct lock_class_key __key ;

  {
#line 1909
  __mutex_init(& key_tfm_list_mutex, "&key_tfm_list_mutex", & __key);
#line 1910
  INIT_LIST_HEAD(& key_tfm_list);
#line 1911
  return (0);
}
}
#line 1919 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_destroy_crypto(void) 
{ 
  struct ecryptfs_key_tfm *key_tfm ;
  struct ecryptfs_key_tfm *key_tfm_tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1923
  ldv_mutex_lock_155(& key_tfm_list_mutex);
#line 1924
  __mptr = (struct list_head  const  *)key_tfm_list.next;
#line 1924
  key_tfm = (struct ecryptfs_key_tfm *)__mptr + 0xffffffffffffff48UL;
#line 1924
  __mptr___0 = (struct list_head  const  *)key_tfm->key_tfm_list.next;
#line 1924
  key_tfm_tmp = (struct ecryptfs_key_tfm *)__mptr___0 + 0xffffffffffffff48UL;
#line 1924
  goto ldv_27924;
  ldv_27923: 
#line 1926
  list_del(& key_tfm->key_tfm_list);
#line 1927
  if ((unsigned long )key_tfm->key_tfm != (unsigned long )((struct crypto_blkcipher *)0)) {
#line 1928
    crypto_free_blkcipher(key_tfm->key_tfm);
  } else {

  }
#line 1929
  kmem_cache_free(ecryptfs_key_tfm_cache, (void *)key_tfm);
#line 1924
  key_tfm = key_tfm_tmp;
#line 1924
  __mptr___1 = (struct list_head  const  *)key_tfm_tmp->key_tfm_list.next;
#line 1924
  key_tfm_tmp = (struct ecryptfs_key_tfm *)__mptr___1 + 0xffffffffffffff48UL;
  ldv_27924: ;
#line 1924
  if ((unsigned long )(& key_tfm->key_tfm_list) != (unsigned long )(& key_tfm_list)) {
#line 1925
    goto ldv_27923;
  } else {

  }
#line 1931
  ldv_mutex_unlock_156(& key_tfm_list_mutex);
#line 1932
  return (0);
}
}
#line 1936 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm , char *cipher_name ,
                             size_t key_size ) 
{ 
  struct ecryptfs_key_tfm *tmp_tfm ;
  int rc ;
  int tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  struct lock_class_key __key ;

  {
#line 1940
  rc = 0;
#line 1942
  tmp = mutex_is_locked(& key_tfm_list_mutex);
#line 1942
  tmp___0 = __builtin_expect(tmp == 0, 0L);
#line 1942
  if (tmp___0 != 0L) {
#line 1942
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"),
                         "i" (1942), "i" (12UL));
    ldv_27933: ;
#line 1942
    goto ldv_27933;
  } else {

  }
#line 1944
  tmp___1 = kmem_cache_alloc(ecryptfs_key_tfm_cache, 208U);
#line 1944
  tmp_tfm = (struct ecryptfs_key_tfm *)tmp___1;
#line 1945
  if ((unsigned long )key_tfm != (unsigned long )((struct ecryptfs_key_tfm **)0)) {
#line 1946
    *key_tfm = tmp_tfm;
  } else {

  }
#line 1947
  if ((unsigned long )tmp_tfm == (unsigned long )((struct ecryptfs_key_tfm *)0)) {
#line 1948
    rc = -12;
#line 1949
    printk("\vError attempting to allocate from ecryptfs_key_tfm_cache\n");
#line 1951
    goto out;
  } else {

  }
#line 1953
  __mutex_init(& tmp_tfm->key_tfm_mutex, "&tmp_tfm->key_tfm_mutex", & __key);
#line 1954
  strncpy((char *)(& tmp_tfm->cipher_name), (char const   *)cipher_name, 32UL);
#line 1956
  tmp_tfm->cipher_name[32] = 0U;
#line 1957
  tmp_tfm->key_size = key_size;
#line 1958
  rc = ecryptfs_process_key_cipher(& tmp_tfm->key_tfm, (char *)(& tmp_tfm->cipher_name),
                                   & tmp_tfm->key_size);
#line 1961
  if (rc != 0) {
#line 1962
    printk("\vError attempting to initialize key TFM cipher with name = [%s]; rc = [%d]\n",
           (unsigned char *)(& tmp_tfm->cipher_name), rc);
#line 1965
    kmem_cache_free(ecryptfs_key_tfm_cache, (void *)tmp_tfm);
#line 1966
    if ((unsigned long )key_tfm != (unsigned long )((struct ecryptfs_key_tfm **)0)) {
#line 1967
      *key_tfm = 0;
    } else {

    }
#line 1968
    goto out;
  } else {

  }
#line 1970
  list_add(& tmp_tfm->key_tfm_list, & key_tfm_list);
  out: ;
#line 1972
  return (rc);
}
}
#line 1985 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_tfm_exists(char *cipher_name , struct ecryptfs_key_tfm **key_tfm ) 
{ 
  struct ecryptfs_key_tfm *tmp_key_tfm ;
  int tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;
  int tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1989
  tmp = mutex_is_locked(& key_tfm_list_mutex);
#line 1989
  tmp___0 = __builtin_expect(tmp == 0, 0L);
#line 1989
  if (tmp___0 != 0L) {
#line 1989
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"),
                         "i" (1989), "i" (12UL));
    ldv_27941: ;
#line 1989
    goto ldv_27941;
  } else {

  }
#line 1991
  __mptr = (struct list_head  const  *)key_tfm_list.next;
#line 1991
  tmp_key_tfm = (struct ecryptfs_key_tfm *)__mptr + 0xffffffffffffff48UL;
#line 1991
  goto ldv_27947;
  ldv_27946: 
#line 1992
  tmp___1 = strcmp((char const   *)(& tmp_key_tfm->cipher_name), (char const   *)cipher_name);
#line 1992
  if (tmp___1 == 0) {
#line 1993
    if ((unsigned long )key_tfm != (unsigned long )((struct ecryptfs_key_tfm **)0)) {
#line 1994
      *key_tfm = tmp_key_tfm;
    } else {

    }
#line 1995
    return (1);
  } else {

  }
#line 1991
  __mptr___0 = (struct list_head  const  *)tmp_key_tfm->key_tfm_list.next;
#line 1991
  tmp_key_tfm = (struct ecryptfs_key_tfm *)__mptr___0 + 0xffffffffffffff48UL;
  ldv_27947: ;
#line 1991
  if ((unsigned long )(& tmp_key_tfm->key_tfm_list) != (unsigned long )(& key_tfm_list)) {
#line 1992
    goto ldv_27946;
  } else {

  }

#line 1998
  if ((unsigned long )key_tfm != (unsigned long )((struct ecryptfs_key_tfm **)0)) {
#line 1999
    *key_tfm = 0;
  } else {

  }
#line 2000
  return (0);
}
}
#line 2014 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm , struct mutex **tfm_mutex ,
                                               char *cipher_name ) 
{ 
  struct ecryptfs_key_tfm *key_tfm ;
  int rc ;
  int tmp ;

  {
#line 2019
  rc = 0;
#line 2021
  *tfm = 0;
#line 2022
  *tfm_mutex = 0;
#line 2024
  ldv_mutex_lock_157(& key_tfm_list_mutex);
#line 2025
  tmp = ecryptfs_tfm_exists(cipher_name, & key_tfm);
#line 2025
  if (tmp == 0) {
#line 2026
    rc = ecryptfs_add_new_key_tfm(& key_tfm, cipher_name, 0UL);
#line 2027
    if (rc != 0) {
#line 2028
      printk("\vError adding new key_tfm to list; rc = [%d]\n", rc);
#line 2030
      goto out;
    } else {

    }
  } else {

  }
#line 2033
  *tfm = key_tfm->key_tfm;
#line 2034
  *tfm_mutex = & key_tfm->key_tfm_mutex;
  out: 
#line 2036
  ldv_mutex_unlock_158(& key_tfm_list_mutex);
#line 2037
  return (rc);
}
}
#line 2041 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static unsigned char *portable_filename_chars  =    (unsigned char *)"-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
#line 2048 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static unsigned char const   filename_rev_map[256U]  = 
#line 2048
  {      0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      1U,      0U, 
        2U,      3U,      4U,      5U, 
        6U,      7U,      8U,      9U, 
        10U,      11U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      12U,      13U,      14U, 
        15U,      16U,      17U,      18U, 
        19U,      20U,      21U,      22U, 
        23U,      24U,      25U,      26U, 
        27U,      28U,      29U,      30U, 
        31U,      32U,      33U,      34U, 
        35U,      36U,      37U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      38U,      39U,      40U, 
        41U,      42U,      43U,      44U, 
        45U,      46U,      47U,      48U, 
        49U,      50U,      51U,      52U, 
        53U,      54U,      55U,      56U, 
        57U,      58U,      59U,      60U, 
        61U,      62U,      63U};
#line 2074 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ecryptfs_encode_for_filename(unsigned char *dst , size_t *dst_size , unsigned char *src ,
                                  size_t src_size ) 
{ 
  size_t num_blocks ;
  size_t block_num ;
  size_t dst_offset ;
  unsigned char last_block[3U] ;
  size_t __len ;
  void *__ret ;
  unsigned char *src_block ;
  unsigned char dst_block[4U] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 2078
  block_num = 0UL;
#line 2079
  dst_offset = 0UL;
#line 2082
  if (src_size == 0UL) {
#line 2083
    *dst_size = 0UL;
#line 2084
    goto out;
  } else {

  }
#line 2086
  num_blocks = src_size / 3UL;
#line 2087
  if (src_size % 3UL == 0UL) {
#line 2088
    __len = 3UL;
#line 2088
    if (__len > 63UL) {
#line 2088
      __ret = __memcpy((void *)(& last_block), (void const   *)(src + (src_size + 0xfffffffffffffffdUL)),
                       __len);
    } else {
#line 2088
      __ret = __builtin_memcpy((void *)(& last_block), (void const   *)(src + (src_size + 0xfffffffffffffffdUL)),
                               __len);
    }
  } else {
#line 2090
    num_blocks = num_blocks + 1UL;
#line 2091
    last_block[2] = 0U;
#line 2092
    switch (src_size % 3UL) {
    case 1UL: 
#line 2094
    last_block[0] = *(src + (src_size + 0xffffffffffffffffUL));
#line 2095
    last_block[1] = 0U;
#line 2096
    goto ldv_27974;
    case 2UL: 
#line 2098
    last_block[0] = *(src + (src_size + 0xfffffffffffffffeUL));
#line 2099
    last_block[1] = *(src + (src_size + 0xffffffffffffffffUL));
    }
    ldv_27974: ;
  }
#line 2102
  *dst_size = num_blocks * 4UL;
#line 2103
  if ((unsigned long )dst == (unsigned long )((unsigned char *)0)) {
#line 2104
    goto out;
  } else {

  }
#line 2105
  goto ldv_27979;
  ldv_27978: ;
#line 2109
  if (num_blocks - 1UL == block_num) {
#line 2110
    src_block = (unsigned char *)(& last_block);
  } else {
#line 2112
    src_block = src + block_num * 3UL;
  }
#line 2113
  dst_block[0] = (int )*src_block >> 2;
#line 2114
  dst_block[1] = (unsigned char )(((int )((signed char )((int )*src_block << 4)) & 48) | (int )((signed char )((int )*(src_block + 1UL) >> 4)));
#line 2116
  dst_block[2] = (unsigned char )(((int )((signed char )((int )*(src_block + 1UL) << 2)) & 60) | (int )((signed char )((int )*(src_block + 2UL) >> 6)));
#line 2118
  dst_block[3] = (unsigned int )*(src_block + 2UL) & 63U;
#line 2119
  tmp = dst_offset;
#line 2119
  dst_offset = dst_offset + 1UL;
#line 2119
  *(dst + tmp) = *(portable_filename_chars + (unsigned long )dst_block[0]);
#line 2120
  tmp___0 = dst_offset;
#line 2120
  dst_offset = dst_offset + 1UL;
#line 2120
  *(dst + tmp___0) = *(portable_filename_chars + (unsigned long )dst_block[1]);
#line 2121
  tmp___1 = dst_offset;
#line 2121
  dst_offset = dst_offset + 1UL;
#line 2121
  *(dst + tmp___1) = *(portable_filename_chars + (unsigned long )dst_block[2]);
#line 2122
  tmp___2 = dst_offset;
#line 2122
  dst_offset = dst_offset + 1UL;
#line 2122
  *(dst + tmp___2) = *(portable_filename_chars + (unsigned long )dst_block[3]);
#line 2123
  block_num = block_num + 1UL;
  ldv_27979: ;
#line 2105
  if (block_num < num_blocks) {
#line 2106
    goto ldv_27978;
  } else {

  }

  out: ;
#line 2126
  return;
}
}
#line 2129 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static size_t ecryptfs_max_decoded_size(size_t encoded_size ) 
{ 


  {
#line 2137
  return (((encoded_size + 1UL) * 3UL) / 4UL);
}
}
#line 2150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
static void ecryptfs_decode_from_filename(unsigned char *dst , size_t *dst_size ,
                                          unsigned char const   *src , size_t src_size ) 
{ 
  u8 current_bit_offset ;
  size_t src_byte_offset ;
  size_t dst_byte_offset ;
  unsigned char src_byte ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 2153
  current_bit_offset = 0U;
#line 2154
  src_byte_offset = 0UL;
#line 2155
  dst_byte_offset = 0UL;
#line 2157
  if ((unsigned long )dst == (unsigned long )((unsigned char *)0)) {
#line 2158
    *dst_size = ecryptfs_max_decoded_size(src_size);
#line 2159
    goto out;
  } else {

  }
#line 2161
  goto ldv_28001;
  ldv_28000: 
#line 2162
  src_byte = filename_rev_map[(int )*(src + src_byte_offset)];
#line 2165
  switch ((int )current_bit_offset) {
  case 0: 
#line 2167
  *(dst + dst_byte_offset) = (int )src_byte << 2U;
#line 2168
  current_bit_offset = 6U;
#line 2169
  goto ldv_27996;
  case 6: 
#line 2171
  tmp = dst_byte_offset;
#line 2171
  dst_byte_offset = dst_byte_offset + 1UL;
#line 2171
  *(dst + tmp) = (int )*(dst + tmp) | ((int )src_byte >> 4);
#line 2172
  *(dst + dst_byte_offset) = (unsigned char )((int )src_byte << 4);
#line 2174
  current_bit_offset = 4U;
#line 2175
  goto ldv_27996;
  case 4: 
#line 2177
  tmp___0 = dst_byte_offset;
#line 2177
  dst_byte_offset = dst_byte_offset + 1UL;
#line 2177
  *(dst + tmp___0) = (int )*(dst + tmp___0) | ((int )src_byte >> 2);
#line 2178
  *(dst + dst_byte_offset) = (int )src_byte << 6U;
#line 2179
  current_bit_offset = 2U;
#line 2180
  goto ldv_27996;
  case 2: 
#line 2182
  tmp___1 = dst_byte_offset;
#line 2182
  dst_byte_offset = dst_byte_offset + 1UL;
#line 2182
  *(dst + tmp___1) = (int )*(dst + tmp___1) | (int )src_byte;
#line 2183
  *(dst + dst_byte_offset) = 0U;
#line 2184
  current_bit_offset = 0U;
#line 2185
  goto ldv_27996;
  }
  ldv_27996: 
#line 2187
  src_byte_offset = src_byte_offset + 1UL;
  ldv_28001: ;
#line 2161
  if (src_byte_offset < src_size) {
#line 2162
    goto ldv_28000;
  } else {

  }
#line 2189
  *dst_size = dst_byte_offset;
  out: ;
#line 2191
  return;
}
}
#line 2209 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_encrypt_and_encode_filename(char **encoded_name , size_t *encoded_name_size ,
                                         struct ecryptfs_crypt_stat *crypt_stat ,
                                         struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                         char const   *name , size_t name_size ) 
{ 
  size_t encoded_name_no_prefix_size ;
  int rc ;
  struct ecryptfs_filename *filename ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 2217
  rc = 0;
#line 2219
  *encoded_name = 0;
#line 2220
  *encoded_name_size = 0UL;
#line 2221
  if (((unsigned long )crypt_stat != (unsigned long )((struct ecryptfs_crypt_stat *)0) && (crypt_stat->flags & 1024U) != 0U) || ((unsigned long )mount_crypt_stat != (unsigned long )((struct ecryptfs_mount_crypt_stat *)0) && (mount_crypt_stat->flags & 16U) != 0U)) {
#line 2226
    tmp = kzalloc(136UL, 208U);
#line 2226
    filename = (struct ecryptfs_filename *)tmp;
#line 2227
    if ((unsigned long )filename == (unsigned long )((struct ecryptfs_filename *)0)) {
#line 2228
      printk("\v%s: Out of memory whilst attempting to kzalloc [%zd] bytes\n", "ecryptfs_encrypt_and_encode_filename",
             136UL);
#line 2231
      rc = -12;
#line 2232
      goto out;
    } else {

    }
#line 2234
    filename->filename = (char *)name;
#line 2235
    filename->filename_size = name_size;
#line 2236
    rc = ecryptfs_encrypt_filename(filename, crypt_stat, mount_crypt_stat);
#line 2238
    if (rc != 0) {
#line 2239
      printk("\v%s: Error attempting to encrypt filename; rc = [%d]\n", "ecryptfs_encrypt_and_encode_filename",
             rc);
#line 2241
      kfree((void const   *)filename);
#line 2242
      goto out;
    } else {

    }
#line 2244
    ecryptfs_encode_for_filename(0, & encoded_name_no_prefix_size, (unsigned char *)filename->encrypted_filename,
                                 filename->encrypted_filename_size);
#line 2248
    if (((unsigned long )crypt_stat != (unsigned long )((struct ecryptfs_crypt_stat *)0) && (crypt_stat->flags & 2048U) != 0U) || ((unsigned long )mount_crypt_stat != (unsigned long )((struct ecryptfs_mount_crypt_stat *)0) && (mount_crypt_stat->flags & 32U) != 0U)) {
#line 2253
      *encoded_name_size = encoded_name_no_prefix_size + 24UL;
    } else {
#line 2257
      *encoded_name_size = encoded_name_no_prefix_size + 23UL;
    }
#line 2260
    tmp___0 = kmalloc(*encoded_name_size + 1UL, 208U);
#line 2260
    *encoded_name = (char *)tmp___0;
#line 2261
    if ((unsigned long )*encoded_name == (unsigned long )((char *)0)) {
#line 2262
      printk("\v%s: Out of memory whilst attempting to kzalloc [%zd] bytes\n", "ecryptfs_encrypt_and_encode_filename",
             *encoded_name_size);
#line 2265
      rc = -12;
#line 2266
      kfree((void const   *)filename->encrypted_filename);
#line 2267
      kfree((void const   *)filename);
#line 2268
      goto out;
    } else {

    }
#line 2270
    if (((unsigned long )crypt_stat != (unsigned long )((struct ecryptfs_crypt_stat *)0) && (crypt_stat->flags & 2048U) != 0U) || ((unsigned long )mount_crypt_stat != (unsigned long )((struct ecryptfs_mount_crypt_stat *)0) && (mount_crypt_stat->flags & 32U) != 0U)) {
#line 2275
      __len = 24UL;
#line 2275
      if (__len > 63UL) {
#line 2275
        __ret = __memcpy((void *)*encoded_name, (void const   *)"ECRYPTFS_FNEK_ENCRYPTED.",
                         __len);
      } else {
#line 2275
        __ret = __builtin_memcpy((void *)*encoded_name, (void const   *)"ECRYPTFS_FNEK_ENCRYPTED.",
                                 __len);
      }
#line 2278
      ecryptfs_encode_for_filename((unsigned char *)*encoded_name + 24U, & encoded_name_no_prefix_size,
                                   (unsigned char *)filename->encrypted_filename,
                                   filename->encrypted_filename_size);
#line 2284
      *encoded_name_size = encoded_name_no_prefix_size + 24UL;
#line 2287
      *(*encoded_name + *encoded_name_size) = 0;
    } else {
#line 2289
      rc = -95;
    }
#line 2291
    if (rc != 0) {
#line 2292
      printk("\v%s: Error attempting to encode encrypted filename; rc = [%d]\n", "ecryptfs_encrypt_and_encode_filename",
             rc);
#line 2295
      kfree((void const   *)*encoded_name);
#line 2296
      *encoded_name = 0;
#line 2297
      *encoded_name_size = 0UL;
    } else {

    }
#line 2299
    kfree((void const   *)filename->encrypted_filename);
#line 2300
    kfree((void const   *)filename);
  } else {
#line 2302
    rc = ecryptfs_copy_filename(encoded_name, encoded_name_size, name, name_size);
  }
  out: ;
#line 2307
  return (rc);
}
}
#line 2322 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_decode_and_decrypt_filename(char **plaintext_name , size_t *plaintext_name_size ,
                                         struct dentry *ecryptfs_dir_dentry , char const   *name ,
                                         size_t name_size ) 
{ 
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct ecryptfs_sb_info *tmp ;
  char *decoded_name ;
  size_t decoded_name_size ;
  size_t packet_size ;
  int rc ;
  char const   *orig_name ;
  size_t orig_name_size ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2327
  tmp = ecryptfs_superblock_to_private(ecryptfs_dir_dentry->d_sb);
#line 2327
  mount_crypt_stat = & tmp->mount_crypt_stat;
#line 2333
  rc = 0;
#line 2335
  if (((mount_crypt_stat->flags & 16U) != 0U && (mount_crypt_stat->flags & 4U) == 0U) && name_size > 24UL) {
#line 2335
    tmp___1 = strncmp(name, "ECRYPTFS_FNEK_ENCRYPTED.", 24UL);
#line 2335
    if (tmp___1 == 0) {
#line 2340
      orig_name = name;
#line 2341
      orig_name_size = name_size;
#line 2343
      name = name + 24UL;
#line 2344
      name_size = name_size - 24UL;
#line 2345
      ecryptfs_decode_from_filename(0, & decoded_name_size, (unsigned char const   *)name,
                                    name_size);
#line 2347
      tmp___0 = kmalloc(decoded_name_size, 208U);
#line 2347
      decoded_name = (char *)tmp___0;
#line 2348
      if ((unsigned long )decoded_name == (unsigned long )((char *)0)) {
#line 2349
        printk("\v%s: Out of memory whilst attempting to kmalloc [%zd] bytes\n", "ecryptfs_decode_and_decrypt_filename",
               decoded_name_size);
#line 2352
        rc = -12;
#line 2353
        goto out;
      } else {

      }
#line 2355
      ecryptfs_decode_from_filename((unsigned char *)decoded_name, & decoded_name_size,
                                    (unsigned char const   *)name, name_size);
#line 2357
      rc = ecryptfs_parse_tag_70_packet(plaintext_name, plaintext_name_size, & packet_size,
                                        mount_crypt_stat, decoded_name, decoded_name_size);
#line 2363
      if (rc != 0) {
#line 2364
        printk("\016%s: Could not parse tag 70 packet from filename; copying through filename as-is\n",
               "ecryptfs_decode_and_decrypt_filename");
#line 2367
        rc = ecryptfs_copy_filename(plaintext_name, plaintext_name_size, orig_name,
                                    orig_name_size);
#line 2370
        goto out_free;
      } else {

      }
    } else {
#line 2373
      rc = ecryptfs_copy_filename(plaintext_name, plaintext_name_size, name, name_size);
#line 2376
      goto out;
    }
  } else {
#line 2373
    rc = ecryptfs_copy_filename(plaintext_name, plaintext_name_size, name, name_size);
#line 2376
    goto out;
  }
  out_free: 
#line 2379
  kfree((void const   *)decoded_name);
  out: ;
#line 2381
  return (rc);
}
}
#line 2386 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
int ecryptfs_set_f_namelen(long *namelen , long lower_namelen , struct ecryptfs_mount_crypt_stat *mount_crypt_stat ) 
{ 
  struct blkcipher_desc desc ;
  struct mutex *tfm_mutex ;
  size_t cipher_blocksize ;
  int rc ;
  long tmp ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;

  {
#line 2394
  if ((mount_crypt_stat->flags & 16U) == 0U) {
#line 2395
    *namelen = lower_namelen;
#line 2396
    return (0);
  } else {

  }
#line 2399
  rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(& desc.tfm, & tfm_mutex, (char *)(& mount_crypt_stat->global_default_fn_cipher_name));
#line 2401
  tmp = __builtin_expect(rc != 0, 0L);
#line 2401
  if (tmp != 0L) {
#line 2402
    *namelen = 0L;
#line 2403
    return (rc);
  } else {

  }
#line 2406
  ldv_mutex_lock_159(tfm_mutex);
#line 2407
  tmp___0 = crypto_blkcipher_blocksize(desc.tfm);
#line 2407
  cipher_blocksize = (size_t )tmp___0;
#line 2408
  ldv_mutex_unlock_160(tfm_mutex);
#line 2411
  if (lower_namelen == 255L && (cipher_blocksize == 8UL || cipher_blocksize == 16UL)) {
#line 2413
    *namelen = 143L;
#line 2414
    return (0);
  } else {

  }
#line 2418
  *namelen = lower_namelen;
#line 2419
  *namelen = *namelen + -24L;
#line 2421
  tmp___1 = ecryptfs_max_decoded_size((size_t )*namelen);
#line 2421
  *namelen = (long )(tmp___1 - 3UL);
#line 2422
  *namelen = *namelen + -13L;
#line 2423
  *namelen = *namelen + -16L;
#line 2425
  *namelen = (long )(((unsigned long )*namelen - cipher_blocksize) + 1UL);
#line 2427
  if (*namelen < 0L) {
#line 2428
    *namelen = 0L;
  } else {

  }
#line 2430
  return (0);
}
}
#line 2470 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_main7_sequence_infinite_withcheck_stateful(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2482
  LDV_IN_INTERRUPT = 1;
#line 2491
  ldv_initialize();
#line 2493
  goto ldv_28064;
  ldv_28063: 
#line 2496
  tmp = __VERIFIER_nondet_int();
#line 2496
  switch (tmp) {
  default: ;
#line 2498
  goto ldv_28062;
  }
  ldv_28062: ;
  ldv_28064: 
#line 2493
  tmp___0 = __VERIFIER_nondet_int();
#line 2493
  if (tmp___0 != 0) {
#line 2494
    goto ldv_28063;
  } else {

  }


#line 2507
  ldv_check_final_state();
#line 2510
  return;
}
}
#line 2514 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_135(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2519
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2521
  mutex_lock(ldv_func_arg1);
#line 2522
  return;
}
}
#line 2524 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2529
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2531
  mutex_unlock(ldv_func_arg1);
#line 2532
  return;
}
}
#line 2534 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_137(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2539
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 2541
  mutex_lock(ldv_func_arg1);
#line 2542
  return;
}
}
#line 2544 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2549
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 2551
  mutex_unlock(ldv_func_arg1);
#line 2552
  return;
}
}
#line 2554 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2559
  ldv_mutex_lock_cs_hash_tfm_mutex(ldv_func_arg1);
#line 2561
  mutex_lock(ldv_func_arg1);
#line 2562
  return;
}
}
#line 2564 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2569
  ldv_mutex_unlock_cs_hash_tfm_mutex(ldv_func_arg1);
#line 2571
  mutex_unlock(ldv_func_arg1);
#line 2572
  return;
}
}
#line 2574 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2579
  ldv_mutex_lock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 2581
  mutex_lock(ldv_func_arg1);
#line 2582
  return;
}
}
#line 2584 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2589
  ldv_mutex_unlock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 2591
  mutex_unlock(ldv_func_arg1);
#line 2592
  return;
}
}
#line 2594 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_143(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2599
  ldv_mutex_lock_cs_tfm_mutex(ldv_func_arg1);
#line 2601
  mutex_lock(ldv_func_arg1);
#line 2602
  return;
}
}
#line 2604 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2609
  ldv_mutex_unlock_cs_tfm_mutex(ldv_func_arg1);
#line 2611
  mutex_unlock(ldv_func_arg1);
#line 2612
  return;
}
}
#line 2614 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2619
  ldv_mutex_unlock_cs_tfm_mutex(ldv_func_arg1);
#line 2621
  mutex_unlock(ldv_func_arg1);
#line 2622
  return;
}
}
#line 2624 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2629
  ldv_mutex_lock_cs_tfm_mutex(ldv_func_arg1);
#line 2631
  mutex_lock(ldv_func_arg1);
#line 2632
  return;
}
}
#line 2634 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_147(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2639
  ldv_mutex_unlock_cs_tfm_mutex(ldv_func_arg1);
#line 2641
  mutex_unlock(ldv_func_arg1);
#line 2642
  return;
}
}
#line 2644 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_148(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2649
  ldv_mutex_unlock_cs_tfm_mutex(ldv_func_arg1);
#line 2651
  mutex_unlock(ldv_func_arg1);
#line 2652
  return;
}
}
#line 2654 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_149(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2659
  ldv_mutex_lock_cs_tfm_mutex(ldv_func_arg1);
#line 2661
  mutex_lock(ldv_func_arg1);
#line 2662
  return;
}
}
#line 2664 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2669
  ldv_mutex_unlock_cs_tfm_mutex(ldv_func_arg1);
#line 2671
  mutex_unlock(ldv_func_arg1);
#line 2672
  return;
}
}
#line 2674 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_151(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2679
  ldv_mutex_lock_keysig_list_mutex(ldv_func_arg1);
#line 2681
  mutex_lock(ldv_func_arg1);
#line 2682
  return;
}
}
#line 2684 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_152(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2689
  ldv_mutex_lock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 2691
  mutex_lock(ldv_func_arg1);
#line 2692
  return;
}
}
#line 2694 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_153(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2699
  ldv_mutex_unlock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 2701
  mutex_unlock(ldv_func_arg1);
#line 2702
  return;
}
}
#line 2704 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_154(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2709
  ldv_mutex_unlock_keysig_list_mutex(ldv_func_arg1);
#line 2711
  mutex_unlock(ldv_func_arg1);
#line 2712
  return;
}
}
#line 2714 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_155(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2719
  ldv_mutex_lock_key_tfm_list_mutex(ldv_func_arg1);
#line 2721
  mutex_lock(ldv_func_arg1);
#line 2722
  return;
}
}
#line 2724 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_156(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2729
  ldv_mutex_unlock_key_tfm_list_mutex(ldv_func_arg1);
#line 2731
  mutex_unlock(ldv_func_arg1);
#line 2732
  return;
}
}
#line 2734 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_157(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2739
  ldv_mutex_lock_key_tfm_list_mutex(ldv_func_arg1);
#line 2741
  mutex_lock(ldv_func_arg1);
#line 2742
  return;
}
}
#line 2744 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_158(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2749
  ldv_mutex_unlock_key_tfm_list_mutex(ldv_func_arg1);
#line 2751
  mutex_unlock(ldv_func_arg1);
#line 2752
  return;
}
}
#line 2754 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_lock_159(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2759
  ldv_mutex_lock_tfm_mutex(ldv_func_arg1);
#line 2761
  mutex_lock(ldv_func_arg1);
#line 2762
  return;
}
}
#line 2764 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/crypto.c.prepared"
void ldv_mutex_unlock_160(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2769
  ldv_mutex_unlock_tfm_mutex(ldv_func_arg1);
#line 2771
  mutex_unlock(ldv_func_arg1);
#line 2772
  return;
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 60 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 93 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 95
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 97
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_192(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_188(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_190(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_193(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_195(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_197(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_202(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_205(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_207(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_187(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_189(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_191(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_194(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_196(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_198(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_203(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_206(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_208(struct mutex *ldv_func_arg1 ) ;
#line 90 "include/linux/rwsem.h"
extern void down_write(struct rw_semaphore * ) ;
#line 211 "include/linux/key.h"
__inline static struct key *key_get(struct key *key ) 
{ 


  {
#line 213
  if ((unsigned long )key != (unsigned long )((struct key *)0)) {
#line 214
    atomic_inc(& key->usage);
  } else {

  }
#line 215
  return (key);
}
}
#line 223
extern struct key *request_key(struct key_type * , char const   * , char const   * ) ;
#line 246
extern int key_validate(struct key  const  * ) ;
#line 233 "include/linux/slab.h"
extern void kzfree(void const   * ) ;
#line 972 "include/linux/crypto.h"
__inline static int crypto_blkcipher_encrypt(struct blkcipher_desc *desc , struct scatterlist *dst ,
                                             struct scatterlist *src , unsigned int nbytes ) 
{ 
  struct blkcipher_tfm *tmp ;
  struct blkcipher_tfm *tmp___0 ;
  int tmp___1 ;

  {
#line 977
  tmp = crypto_blkcipher_crt(desc->tfm);
#line 977
  desc->info = tmp->iv;
#line 978
  tmp___0 = crypto_blkcipher_crt(desc->tfm);
#line 978
  tmp___1 = (*(tmp___0->encrypt))(desc, dst, src, nbytes);
#line 978
  return (tmp___1);
}
}
#line 989 "include/linux/crypto.h"
__inline static int crypto_blkcipher_decrypt(struct blkcipher_desc *desc , struct scatterlist *dst ,
                                             struct scatterlist *src , unsigned int nbytes ) 
{ 
  struct blkcipher_tfm *tmp ;
  struct blkcipher_tfm *tmp___0 ;
  int tmp___1 ;

  {
#line 994
  tmp = crypto_blkcipher_crt(desc->tfm);
#line 994
  desc->info = tmp->iv;
#line 995
  tmp___0 = crypto_blkcipher_crt(desc->tfm);
#line 995
  tmp___1 = (*(tmp___0->decrypt))(desc, dst, src, nbytes);
#line 995
  return (tmp___1);
}
}
#line 35 "include/keys/user-type.h"
extern struct key_type key_type_user ;
#line 36 "include/keys/encrypted-type.h"
extern struct key_type key_type_encrypted ;
#line 52 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
void ecryptfs_dump_auth_tok(struct ecryptfs_auth_tok *auth_tok ) ;
#line 84 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct ecryptfs_auth_tok *ecryptfs_get_encrypted_key_payload_data(struct key *key ) 
{ 


  {
#line 86
  if ((unsigned long )key->type == (unsigned long )(& key_type_encrypted)) {
#line 87
    return ((struct ecryptfs_auth_tok *)(& ((struct encrypted_key_payload *)key->payload.data)->payload_data));
  } else {
#line 90
    return (0);
  }
}
}
#line 93 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct key *ecryptfs_get_encrypted_key(char *sig ) 
{ 
  struct key *tmp ;

  {
#line 95
  tmp = request_key(& key_type_encrypted, (char const   *)sig, 0);
#line 95
  return (tmp);
}
}
#line 113 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
__inline static struct ecryptfs_auth_tok *ecryptfs_get_key_payload_data(struct key *key ) 
{ 
  struct ecryptfs_auth_tok *auth_tok ;

  {
#line 117
  auth_tok = ecryptfs_get_encrypted_key_payload_data(key);
#line 118
  if ((unsigned long )auth_tok == (unsigned long )((struct ecryptfs_auth_tok *)0)) {
#line 119
    return ((struct ecryptfs_auth_tok *)(& ((struct user_key_payload *)key->payload.data)->data));
  } else {
#line 122
    return (auth_tok);
  }
}
}
#line 537 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_auth_tok_list_item_cache  ;
#line 544 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_key_record_cache  ;
#line 545 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_key_sig_cache  ;
#line 546 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct kmem_cache *ecryptfs_global_auth_tok_cache  ;
#line 609
int ecryptfs_send_message(char *data , int data_len , struct ecryptfs_msg_ctx **msg_ctx ) ;
#line 611
int ecryptfs_wait_for_response(struct ecryptfs_msg_ctx *msg_ctx , struct ecryptfs_message **msg ) ;
#line 654
int ecryptfs_parse_packet_length(unsigned char *data , size_t *size , size_t *length_size ) ;
#line 656
int ecryptfs_write_packet_length(char *dest , size_t size , size_t *packet_size_length ) ;
#line 179 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int process_request_key_err(long err_code ) 
{ 
  int rc ;

  {
#line 181
  rc = 0;
#line 183
  switch (err_code) {
  case -126L: 
#line 185
  __ecryptfs_printk("\f%s: No key\n", "process_request_key_err");
#line 186
  rc = -2;
#line 187
  goto ldv_32185;
  case -127L: 
#line 189
  __ecryptfs_printk("\f%s: Key expired\n", "process_request_key_err");
#line 190
  rc = -62;
#line 191
  goto ldv_32185;
  case -128L: 
#line 193
  __ecryptfs_printk("\f%s: Key revoked\n", "process_request_key_err");
#line 194
  rc = -22;
#line 195
  goto ldv_32185;
  default: 
#line 197
  __ecryptfs_printk("\f%s: Unknown error code: [0x%.16lx]\n", "process_request_key_err",
                    err_code);
#line 199
  rc = -22;
  }
  ldv_32185: ;
#line 201
  return (rc);
}
}
#line 204 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int process_find_global_auth_tok_for_sig_err(int err_code ) 
{ 
  int rc ;

  {
#line 206
  rc = err_code;
#line 208
  switch (err_code) {
  case -2: 
#line 210
  __ecryptfs_printk("\f%s: Missing auth tok\n", "process_find_global_auth_tok_for_sig_err");
#line 211
  goto ldv_32195;
  case -22: 
#line 213
  __ecryptfs_printk("\f%s: Invalid auth tok\n", "process_find_global_auth_tok_for_sig_err");
#line 214
  goto ldv_32195;
  default: 
#line 216
  rc = process_request_key_err((long )err_code);
#line 217
  goto ldv_32195;
  }
  ldv_32195: ;
#line 219
  return (rc);
}
}
#line 231 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ecryptfs_parse_packet_length(unsigned char *data , size_t *size , size_t *length_size ) 
{ 
  int rc ;

  {
#line 234
  rc = 0;
#line 236
  *length_size = 0UL;
#line 237
  *size = 0UL;
#line 238
  if ((unsigned int )*data <= 191U) {
#line 240
    *size = (size_t )*data;
#line 241
    *length_size = 1UL;
  } else
#line 242
  if ((unsigned int )*data <= 223U) {
#line 244
    *size = (size_t )(((int )*data + -192) * 256);
#line 245
    *size = *size + (size_t )((int )*(data + 1UL) + 192);
#line 246
    *length_size = 2UL;
  } else
#line 247
  if ((unsigned int )*data == 255U) {
#line 249
    __ecryptfs_printk("\v%s: Five-byte packet length not supported\n", "ecryptfs_parse_packet_length");
#line 251
    rc = -22;
#line 252
    goto out;
  } else {
#line 254
    __ecryptfs_printk("\v%s: Error parsing packet length\n", "ecryptfs_parse_packet_length");
#line 255
    rc = -22;
#line 256
    goto out;
  }
  out: ;
#line 259
  return (rc);
}
}
#line 272 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ecryptfs_write_packet_length(char *dest , size_t size , size_t *packet_size_length ) 
{ 
  int rc ;

  {
#line 275
  rc = 0;
#line 277
  if (size <= 191UL) {
#line 278
    *dest = (char )size;
#line 279
    *packet_size_length = 1UL;
  } else
#line 280
  if (size <= 65535UL) {
#line 281
    *dest = (char )((unsigned int )((unsigned char )((size - 192UL) / 256UL)) + 192U);
#line 282
    *(dest + 1UL) = (char )((unsigned int )((unsigned char )size) - 192U);
#line 283
    *packet_size_length = 2UL;
  } else {
#line 286
    rc = -22;
#line 287
    __ecryptfs_printk("\f%s: Unsupported packet size: [%zd]\n", "ecryptfs_write_packet_length",
                      size);
  }
#line 290
  return (rc);
}
}
#line 294 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int write_tag_64_packet(char *signature , struct ecryptfs_session_key *session_key ,
                               char **packet , size_t *packet_len ) 
{ 
  size_t i ;
  size_t data_len ;
  size_t packet_size_len ;
  char *message ;
  int rc ;
  void *tmp ;
  size_t tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 297
  i = 0UL;
#line 311
  data_len = (size_t )(session_key->encrypted_key_size + 21U);
#line 313
  tmp = kmalloc(data_len, 208U);
#line 313
  *packet = (char *)tmp;
#line 314
  message = *packet;
#line 315
  if ((unsigned long )message == (unsigned long )((char *)0)) {
#line 316
    __ecryptfs_printk("\v%s: Unable to allocate memory\n", "write_tag_64_packet");
#line 317
    rc = -12;
#line 318
    goto out;
  } else {

  }
#line 320
  tmp___0 = i;
#line 320
  i = i + 1UL;
#line 320
  *(message + tmp___0) = 64;
#line 321
  rc = ecryptfs_write_packet_length(message + i, 16UL, & packet_size_len);
#line 323
  if (rc != 0) {
#line 324
    __ecryptfs_printk("\v%s: Error generating tag 64 packet header; cannot generate packet length\n",
                      "write_tag_64_packet");
#line 326
    goto out;
  } else {

  }
#line 328
  i = i + packet_size_len;
#line 329
  __len = 16UL;
#line 329
  if (__len > 63UL) {
#line 329
    __ret = __memcpy((void *)(message + i), (void const   *)signature, __len);
  } else {
#line 329
    __ret = __builtin_memcpy((void *)(message + i), (void const   *)signature, __len);
  }
#line 330
  i = i + 16UL;
#line 331
  rc = ecryptfs_write_packet_length(message + i, (size_t )session_key->encrypted_key_size,
                                    & packet_size_len);
#line 334
  if (rc != 0) {
#line 335
    __ecryptfs_printk("\v%s: Error generating tag 64 packet header; cannot generate packet length\n",
                      "write_tag_64_packet");
#line 337
    goto out;
  } else {

  }
#line 339
  i = i + packet_size_len;
#line 340
  __len___0 = (size_t )session_key->encrypted_key_size;
#line 340
  __ret___0 = __builtin_memcpy((void *)(message + i), (void const   *)(& session_key->encrypted_key),
                               __len___0);
#line 342
  i = (size_t )session_key->encrypted_key_size + i;
#line 343
  *packet_len = i;
  out: ;
#line 345
  return (rc);
}
}
#line 349 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int parse_tag_65_packet(struct ecryptfs_session_key *session_key , u8 *cipher_code ,
                               struct ecryptfs_message *msg ) 
{ 
  size_t i ;
  char *data ;
  size_t data_len ;
  size_t m_size ;
  size_t message_len ;
  u16 checksum ;
  u16 expected_checksum ;
  int rc ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 352
  i = 0UL;
#line 357
  checksum = 0U;
#line 358
  expected_checksum = 0U;
#line 368
  message_len = (size_t )msg->data_len;
#line 369
  data = (char *)(& msg->data);
#line 370
  if (message_len <= 3UL) {
#line 371
    rc = -5;
#line 372
    goto out;
  } else {

  }
#line 374
  tmp = i;
#line 374
  i = i + 1UL;
#line 374
  if ((int )((signed char )*(data + tmp)) != 65) {
#line 375
    __ecryptfs_printk("\v%s: Type should be ECRYPTFS_TAG_65\n", "parse_tag_65_packet");
#line 376
    rc = -5;
#line 377
    goto out;
  } else {

  }
#line 379
  tmp___0 = i;
#line 379
  i = i + 1UL;
#line 379
  if ((int )((signed char )*(data + tmp___0)) != 0) {
#line 380
    __ecryptfs_printk("\v%s: Status indicator has non-zero value [%d]\n", "parse_tag_65_packet",
                      (int )*(data + (i + 0xffffffffffffffffUL)));
#line 382
    rc = -5;
#line 383
    goto out;
  } else {

  }
#line 385
  rc = ecryptfs_parse_packet_length((unsigned char *)(data + i), & m_size, & data_len);
#line 386
  if (rc != 0) {
#line 387
    __ecryptfs_printk("\f%s: Error parsing packet length; rc = [%d]\n", "parse_tag_65_packet",
                      rc);
#line 389
    goto out;
  } else {

  }
#line 391
  i = i + data_len;
#line 392
  if (i + m_size > message_len) {
#line 393
    __ecryptfs_printk("\v%s: The message received from ecryptfsd is shorter than expected\n",
                      "parse_tag_65_packet");
#line 395
    rc = -5;
#line 396
    goto out;
  } else {

  }
#line 398
  if (m_size <= 2UL) {
#line 399
    __ecryptfs_printk("\v%s: The decrypted key is not long enough to include a cipher code and checksum\n",
                      "parse_tag_65_packet");
#line 402
    rc = -5;
#line 403
    goto out;
  } else {

  }
#line 405
  tmp___1 = i;
#line 405
  i = i + 1UL;
#line 405
  *cipher_code = (u8 )*(data + tmp___1);
#line 407
  session_key->decrypted_key_size = (u32 )m_size - 3U;
#line 408
  if (session_key->decrypted_key_size > 64U) {
#line 409
    __ecryptfs_printk("\v%s: key_size [%d] larger than the maximum key size [%d]\n",
                      "parse_tag_65_packet", session_key->decrypted_key_size, 512);
#line 413
    rc = -5;
#line 414
    goto out;
  } else {

  }
#line 416
  __len = (size_t )session_key->decrypted_key_size;
#line 416
  __ret = __builtin_memcpy((void *)(& session_key->decrypted_key), (void const   *)(data + i),
                           __len);
#line 418
  i = (size_t )session_key->decrypted_key_size + i;
#line 419
  tmp___2 = i;
#line 419
  i = i + 1UL;
#line 419
  expected_checksum = ((int )((u16 )((unsigned char )*(data + tmp___2))) << 8U) + (int )expected_checksum;
#line 420
  tmp___3 = i;
#line 420
  i = i + 1UL;
#line 420
  expected_checksum = (int )((u16 )((unsigned char )*(data + tmp___3))) + (int )expected_checksum;
#line 421
  i = 0UL;
#line 421
  goto ldv_32251;
  ldv_32250: 
#line 422
  checksum = (int )((u16 )session_key->decrypted_key[i]) + (int )checksum;
#line 421
  i = i + 1UL;
  ldv_32251: ;
#line 421
  if ((size_t )session_key->decrypted_key_size > i) {
#line 422
    goto ldv_32250;
  } else {

  }

#line 423
  if ((int )expected_checksum != (int )checksum) {
#line 424
    __ecryptfs_printk("\v%s: Invalid checksum for file encryption  key; expected [%x]; calculated [%x]\n",
                      "parse_tag_65_packet", (int )expected_checksum, (int )checksum);
#line 427
    rc = -5;
  } else {

  }
  out: ;
#line 430
  return (rc);
}
}
#line 435 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int write_tag_66_packet(char *signature , u8 cipher_code , struct ecryptfs_crypt_stat *crypt_stat ,
                               char **packet , size_t *packet_len ) 
{ 
  size_t i ;
  size_t j ;
  size_t data_len ;
  size_t checksum ;
  size_t packet_size_len ;
  char *message ;
  int rc ;
  void *tmp ;
  size_t tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t tmp___1 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 439
  i = 0UL;
#line 442
  checksum = 0UL;
#line 455
  data_len = crypt_stat->key_size + 21UL;
#line 456
  tmp = kmalloc(data_len, 208U);
#line 456
  *packet = (char *)tmp;
#line 457
  message = *packet;
#line 458
  if ((unsigned long )message == (unsigned long )((char *)0)) {
#line 459
    __ecryptfs_printk("\v%s: Unable to allocate memory\n", "write_tag_66_packet");
#line 460
    rc = -12;
#line 461
    goto out;
  } else {

  }
#line 463
  tmp___0 = i;
#line 463
  i = i + 1UL;
#line 463
  *(message + tmp___0) = 66;
#line 464
  rc = ecryptfs_write_packet_length(message + i, 16UL, & packet_size_len);
#line 466
  if (rc != 0) {
#line 467
    __ecryptfs_printk("\v%s: Error generating tag 66 packet header; cannot generate packet length\n",
                      "write_tag_66_packet");
#line 469
    goto out;
  } else {

  }
#line 471
  i = i + packet_size_len;
#line 472
  __len = 16UL;
#line 472
  if (__len > 63UL) {
#line 472
    __ret = __memcpy((void *)(message + i), (void const   *)signature, __len);
  } else {
#line 472
    __ret = __builtin_memcpy((void *)(message + i), (void const   *)signature, __len);
  }
#line 473
  i = i + 16UL;
#line 475
  rc = ecryptfs_write_packet_length(message + i, crypt_stat->key_size + 3UL, & packet_size_len);
#line 477
  if (rc != 0) {
#line 478
    __ecryptfs_printk("\v%s: Error generating tag 66 packet header; cannot generate packet length\n",
                      "write_tag_66_packet");
#line 480
    goto out;
  } else {

  }
#line 482
  i = i + packet_size_len;
#line 483
  tmp___1 = i;
#line 483
  i = i + 1UL;
#line 483
  *(message + tmp___1) = (char )cipher_code;
#line 484
  __len___0 = crypt_stat->key_size;
#line 484
  __ret___0 = __builtin_memcpy((void *)(message + i), (void const   *)(& crypt_stat->key),
                               __len___0);
#line 485
  i = crypt_stat->key_size + i;
#line 486
  j = 0UL;
#line 486
  goto ldv_32276;
  ldv_32275: 
#line 487
  checksum = (size_t )crypt_stat->key[j] + checksum;
#line 486
  j = j + 1UL;
  ldv_32276: ;
#line 486
  if (crypt_stat->key_size > j) {
#line 487
    goto ldv_32275;
  } else {

  }
#line 488
  tmp___2 = i;
#line 488
  i = i + 1UL;
#line 488
  *(message + tmp___2) = (char )(checksum / 256UL);
#line 489
  tmp___3 = i;
#line 489
  i = i + 1UL;
#line 489
  *(message + tmp___3) = (char )checksum;
#line 490
  *packet_len = i;
  out: ;
#line 492
  return (rc);
}
}
#line 496 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int parse_tag_67_packet(struct ecryptfs_key_record *key_rec , struct ecryptfs_message *msg ) 
{ 
  size_t i ;
  char *data ;
  size_t data_len ;
  size_t message_len ;
  int rc ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 499
  i = 0UL;
#line 512
  message_len = (size_t )msg->data_len;
#line 513
  data = (char *)(& msg->data);
#line 515
  if (message_len <= 3UL) {
#line 516
    rc = -5;
#line 517
    printk("\v%s: message_len is [%zd]; minimum acceptable message length is [%d]\n",
           "parse_tag_67_packet", message_len, 4);
#line 519
    goto out;
  } else {

  }
#line 521
  tmp = i;
#line 521
  i = i + 1UL;
#line 521
  if ((int )((signed char )*(data + tmp)) != 67) {
#line 522
    rc = -5;
#line 523
    printk("\v%s: Type should be ECRYPTFS_TAG_67\n", "parse_tag_67_packet");
#line 525
    goto out;
  } else {

  }
#line 527
  tmp___0 = i;
#line 527
  i = i + 1UL;
#line 527
  if ((int )((signed char )*(data + tmp___0)) != 0) {
#line 528
    rc = -5;
#line 529
    printk("\v%s: Status indicator has non zero value [%d]\n", "parse_tag_67_packet",
           (int )*(data + (i + 0xffffffffffffffffUL)));
#line 532
    goto out;
  } else {

  }
#line 534
  rc = ecryptfs_parse_packet_length((unsigned char *)(data + i), & key_rec->enc_key_size,
                                    & data_len);
#line 536
  if (rc != 0) {
#line 537
    __ecryptfs_printk("\f%s: Error parsing packet length; rc = [%d]\n", "parse_tag_67_packet",
                      rc);
#line 539
    goto out;
  } else {

  }
#line 541
  i = i + data_len;
#line 542
  if (key_rec->enc_key_size + i > message_len) {
#line 543
    rc = -5;
#line 544
    printk("\v%s: message_len [%zd]; max len is [%zd]\n", "parse_tag_67_packet", message_len,
           key_rec->enc_key_size + i);
#line 546
    goto out;
  } else {

  }
#line 548
  if (key_rec->enc_key_size > 512UL) {
#line 549
    rc = -5;
#line 550
    printk("\v%s: Encrypted key_size [%zd] larger than the maximum key size [%d]\n",
           "parse_tag_67_packet", key_rec->enc_key_size, 512);
#line 554
    goto out;
  } else {

  }
#line 556
  __len = key_rec->enc_key_size;
#line 556
  __ret = __builtin_memcpy((void *)(& key_rec->enc_key), (void const   *)(data + i),
                           __len);
  out: ;
#line 558
  return (rc);
}
}
#line 567 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int ecryptfs_verify_version(u16 version ) 
{ 
  int rc ;
  unsigned char major ;
  unsigned char minor ;

  {
#line 569
  rc = 0;
#line 573
  major = (unsigned char )((int )version >> 8);
#line 574
  minor = (unsigned char )version;
#line 575
  if ((unsigned int )major != 0U) {
#line 576
    __ecryptfs_printk("\v%s: Major version number mismatch. Expected [%d]; got [%d]\n",
                      "ecryptfs_verify_version", 0, (int )major);
#line 579
    rc = -22;
#line 580
    goto out;
  } else {

  }
#line 582
  if ((unsigned int )minor != 4U) {
#line 583
    __ecryptfs_printk("\v%s: Minor version number mismatch. Expected [%d]; got [%d]\n",
                      "ecryptfs_verify_version", 4, (int )minor);
#line 586
    rc = -22;
#line 587
    goto out;
  } else {

  }
  out: ;
#line 590
  return (rc);
}
}
#line 601 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int ecryptfs_verify_auth_tok_from_key(struct key *auth_tok_key , struct ecryptfs_auth_tok **auth_tok ) 
{ 
  int rc ;
  int tmp ;

  {
#line 604
  rc = 0;
#line 606
  *auth_tok = ecryptfs_get_key_payload_data(auth_tok_key);
#line 607
  tmp = ecryptfs_verify_version((int )(*auth_tok)->version);
#line 607
  if (tmp != 0) {
#line 608
    printk("\vData structure version mismatch. Userspace tools must match eCryptfs kernel module with major version [%d] and minor version [%d]\n",
           0, 4);
#line 612
    rc = -22;
#line 613
    goto out;
  } else {

  }
#line 615
  if ((unsigned int )(*auth_tok)->token_type != 0U && (unsigned int )(*auth_tok)->token_type != 1U) {
#line 617
    printk("\vInvalid auth_tok structure returned from key query\n");
#line 619
    rc = -22;
#line 620
    goto out;
  } else {

  }
  out: ;
#line 623
  return (rc);
}
}
#line 627 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int ecryptfs_find_global_auth_tok_for_sig(struct key **auth_tok_key , struct ecryptfs_auth_tok **auth_tok ,
                                                 struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                                 char *sig ) 
{ 
  struct ecryptfs_global_auth_tok *walker ;
  int rc ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 633
  rc = 0;
#line 635
  *auth_tok_key = 0;
#line 636
  *auth_tok = 0;
#line 637
  ldv_mutex_lock_194(& mount_crypt_stat->global_auth_tok_list_mutex);
#line 638
  __mptr = (struct list_head  const  *)mount_crypt_stat->global_auth_tok_list.next;
#line 638
  walker = (struct ecryptfs_global_auth_tok *)__mptr + 0xfffffffffffffff8UL;
#line 638
  goto ldv_32323;
  ldv_32322: 
#line 641
  tmp = memcmp((void const   *)(& walker->sig), (void const   *)sig, 16UL);
#line 641
  if (tmp != 0) {
#line 642
    goto ldv_32318;
  } else {

  }
#line 644
  if ((int )walker->flags & 1) {
#line 645
    rc = -22;
#line 646
    goto out;
  } else {

  }
#line 649
  rc = key_validate((struct key  const  *)walker->global_auth_tok_key);
#line 650
  if (rc != 0) {
#line 651
    if (rc == -127) {
#line 652
      goto out;
    } else {

    }
#line 653
    goto out_invalid_auth_tok;
  } else {

  }
#line 656
  down_write(& (walker->global_auth_tok_key)->sem);
#line 657
  rc = ecryptfs_verify_auth_tok_from_key(walker->global_auth_tok_key, auth_tok);
#line 659
  if (rc != 0) {
#line 660
    goto out_invalid_auth_tok_unlock;
  } else {

  }
#line 662
  *auth_tok_key = walker->global_auth_tok_key;
#line 663
  key_get(*auth_tok_key);
#line 664
  goto out;
  ldv_32318: 
#line 638
  __mptr___0 = (struct list_head  const  *)walker->mount_crypt_stat_list.next;
#line 638
  walker = (struct ecryptfs_global_auth_tok *)__mptr___0 + 0xfffffffffffffff8UL;
  ldv_32323: ;
#line 638
  if ((unsigned long )walker != (unsigned long )mount_crypt_stat) {
#line 639
    goto ldv_32322;
  } else {

  }
#line 666
  rc = -2;
#line 667
  goto out;
  out_invalid_auth_tok_unlock: 
#line 669
  up_write(& (walker->global_auth_tok_key)->sem);
  out_invalid_auth_tok: 
#line 671
  printk("\fInvalidating auth tok with sig = [%s]\n", sig);
#line 672
  walker->flags = walker->flags | 1U;
#line 673
  key_put(walker->global_auth_tok_key);
#line 674
  walker->global_auth_tok_key = 0;
  out: 
#line 676
  ldv_mutex_unlock_195(& mount_crypt_stat->global_auth_tok_list_mutex);
#line 677
  return (rc);
}
}
#line 696 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int ecryptfs_find_auth_tok_for_sig(struct key **auth_tok_key , struct ecryptfs_auth_tok **auth_tok ,
                                          struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                          char *sig ) 
{ 
  int rc ;

  {
#line 702
  rc = 0;
#line 704
  rc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok, mount_crypt_stat,
                                             sig);
#line 706
  if (rc == -2) {
#line 712
    if ((mount_crypt_stat->flags & 128U) != 0U) {
#line 714
      return (-22);
    } else {

    }
#line 716
    rc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok, sig);
  } else {

  }
#line 719
  return (rc);
}
}
#line 760 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ecryptfs_write_tag_70_packet(char *dest , size_t *remaining_bytes , size_t *packet_size ,
                                 struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                 char *filename , size_t filename_size ) 
{ 
  struct ecryptfs_write_tag_70_packet_silly_stack *s ;
  struct key *auth_tok_key ;
  int rc ;
  void *tmp ;
  long tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 766
  auth_tok_key = 0;
#line 767
  rc = 0;
#line 769
  tmp = kmalloc(376UL, 208U);
#line 769
  s = (struct ecryptfs_write_tag_70_packet_silly_stack *)tmp;
#line 770
  if ((unsigned long )s == (unsigned long )((struct ecryptfs_write_tag_70_packet_silly_stack *)0)) {
#line 771
    printk("\v%s: Out of memory whilst trying to kmalloc [%zd] bytes of kernel memory\n",
           "ecryptfs_write_tag_70_packet", 376UL);
#line 773
    rc = -12;
#line 774
    goto out;
  } else {

  }
#line 776
  s->desc.flags = 512U;
#line 777
  *packet_size = 0UL;
#line 778
  rc = ecryptfs_find_auth_tok_for_sig(& auth_tok_key, & s->auth_tok, mount_crypt_stat,
                                      (char *)(& mount_crypt_stat->global_default_fnek_sig));
#line 782
  if (rc != 0) {
#line 783
    printk("\v%s: Error attempting to find auth tok for fnek sig [%s]; rc = [%d]\n",
           "ecryptfs_write_tag_70_packet", (char *)(& mount_crypt_stat->global_default_fnek_sig),
           rc);
#line 786
    goto out;
  } else {

  }
#line 788
  rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(& s->desc.tfm, & s->tfm_mutex, (char *)(& mount_crypt_stat->global_default_fn_cipher_name));
#line 791
  tmp___0 = __builtin_expect(rc != 0, 0L);
#line 791
  if (tmp___0 != 0L) {
#line 792
    printk("\vInternal error whilst attempting to get tfm and mutex for cipher name [%s]; rc = [%d]\n",
           (unsigned char *)(& mount_crypt_stat->global_default_fn_cipher_name), rc);
#line 795
    goto out;
  } else {

  }
#line 797
  ldv_mutex_lock_196(s->tfm_mutex);
#line 798
  tmp___1 = crypto_blkcipher_blocksize(s->desc.tfm);
#line 798
  s->block_size = (size_t )tmp___1;
#line 801
  s->num_rand_bytes = 17UL;
#line 802
  s->block_aligned_filename_size = s->num_rand_bytes + filename_size;
#line 803
  if (s->block_aligned_filename_size % s->block_size != 0UL) {
#line 804
    s->num_rand_bytes = s->num_rand_bytes + (s->block_size - s->block_aligned_filename_size % s->block_size);
#line 807
    s->block_aligned_filename_size = s->num_rand_bytes + filename_size;
  } else {

  }
#line 818
  s->max_packet_size = s->block_aligned_filename_size + 13UL;
#line 820
  if ((unsigned long )dest == (unsigned long )((char *)0)) {
#line 821
    *packet_size = s->max_packet_size;
#line 822
    goto out_unlock;
  } else {

  }
#line 824
  if (s->max_packet_size > *remaining_bytes) {
#line 825
    printk("\f%s: Require [%zd] bytes to write; only [%zd] available\n", "ecryptfs_write_tag_70_packet",
           s->max_packet_size, *remaining_bytes);
#line 828
    rc = -22;
#line 829
    goto out_unlock;
  } else {

  }
#line 831
  tmp___2 = kzalloc(s->block_aligned_filename_size, 208U);
#line 831
  s->block_aligned_filename = (char *)tmp___2;
#line 833
  if ((unsigned long )s->block_aligned_filename == (unsigned long )((char *)0)) {
#line 834
    printk("\v%s: Out of kernel memory whilst attempting to kzalloc [%zd] bytes\n",
           "ecryptfs_write_tag_70_packet", s->block_aligned_filename_size);
#line 837
    rc = -12;
#line 838
    goto out_unlock;
  } else {

  }
#line 840
  s->i = 0UL;
#line 841
  tmp___3 = s->i;
#line 841
  s->i = s->i + 1UL;
#line 841
  *(dest + tmp___3) = 70;
#line 842
  rc = ecryptfs_write_packet_length(dest + s->i, s->block_aligned_filename_size + 9UL,
                                    & s->packet_size_len);
#line 847
  if (rc != 0) {
#line 848
    printk("\v%s: Error generating tag 70 packet header; cannot generate packet length; rc = [%d]\n",
           "ecryptfs_write_tag_70_packet", rc);
#line 851
    goto out_free_unlock;
  } else {

  }
#line 853
  s->i = s->i + s->packet_size_len;
#line 854
  ecryptfs_from_hex(dest + s->i, (char *)(& mount_crypt_stat->global_default_fnek_sig),
                    8);
#line 857
  s->i = s->i + 8UL;
#line 858
  s->cipher_code = ecryptfs_code_for_cipher_string((char *)(& mount_crypt_stat->global_default_fn_cipher_name),
                                                   mount_crypt_stat->global_default_fn_cipher_key_bytes);
#line 861
  if ((unsigned int )s->cipher_code == 0U) {
#line 862
    printk("\f%s: Unable to generate code for cipher [%s] with key bytes [%zd]\n",
           "ecryptfs_write_tag_70_packet", (unsigned char *)(& mount_crypt_stat->global_default_fn_cipher_name),
           mount_crypt_stat->global_default_fn_cipher_key_bytes);
#line 866
    rc = -22;
#line 867
    goto out_free_unlock;
  } else {

  }
#line 869
  tmp___4 = s->i;
#line 869
  s->i = s->i + 1UL;
#line 869
  *(dest + tmp___4) = (char )s->cipher_code;
#line 872
  if ((unsigned int )(s->auth_tok)->token_type != 0U) {
#line 873
    rc = -95;
#line 874
    printk("\016%s: Filename encryption only supports password tokens\n", "ecryptfs_write_tag_70_packet");
#line 876
    goto out_free_unlock;
  } else {

  }
#line 878
  sg_init_one(& s->hash_sg, (void const   *)(& (s->auth_tok)->token.password.session_key_encryption_key),
              (s->auth_tok)->token.password.session_key_encryption_key_bytes);
#line 882
  s->hash_desc.flags = 512U;
#line 883
  s->hash_desc.tfm = crypto_alloc_hash("md5", 0U, 128U);
#line 885
  tmp___6 = IS_ERR((void const   *)s->hash_desc.tfm);
#line 885
  if (tmp___6 != 0L) {
#line 886
    tmp___5 = PTR_ERR((void const   *)s->hash_desc.tfm);
#line 886
    rc = (int )tmp___5;
#line 887
    printk("\v%s: Error attempting to allocate hash crypto context; rc = [%d]\n",
           "ecryptfs_write_tag_70_packet", rc);
#line 890
    goto out_free_unlock;
  } else {

  }
#line 892
  rc = crypto_hash_init(& s->hash_desc);
#line 893
  if (rc != 0) {
#line 894
    printk("\v%s: Error initializing crypto hash; rc = [%d]\n", "ecryptfs_write_tag_70_packet",
           rc);
#line 897
    goto out_release_free_unlock;
  } else {

  }
#line 899
  rc = crypto_hash_update(& s->hash_desc, & s->hash_sg, (s->auth_tok)->token.password.session_key_encryption_key_bytes);
#line 902
  if (rc != 0) {
#line 903
    printk("\v%s: Error updating crypto hash; rc = [%d]\n", "ecryptfs_write_tag_70_packet",
           rc);
#line 906
    goto out_release_free_unlock;
  } else {

  }
#line 908
  rc = crypto_hash_final(& s->hash_desc, (u8 *)(& s->hash));
#line 909
  if (rc != 0) {
#line 910
    printk("\v%s: Error finalizing crypto hash; rc = [%d]\n", "ecryptfs_write_tag_70_packet",
           rc);
#line 913
    goto out_release_free_unlock;
  } else {

  }
#line 915
  s->j = 0UL;
#line 915
  goto ldv_32372;
  ldv_32371: 
#line 916
  *(s->block_aligned_filename + s->j) = s->hash[s->j & 15UL];
#line 918
  if ((s->j & 15UL) == 15UL) {
#line 920
    sg_init_one(& s->hash_sg, (void const   *)(& s->hash), 16U);
#line 922
    rc = crypto_hash_init(& s->hash_desc);
#line 923
    if (rc != 0) {
#line 924
      printk("\v%s: Error initializing crypto hash; rc = [%d]\n", "ecryptfs_write_tag_70_packet",
             rc);
#line 927
      goto out_release_free_unlock;
    } else {

    }
#line 929
    rc = crypto_hash_update(& s->hash_desc, & s->hash_sg, 16U);
#line 931
    if (rc != 0) {
#line 932
      printk("\v%s: Error updating crypto hash; rc = [%d]\n", "ecryptfs_write_tag_70_packet",
             rc);
#line 935
      goto out_release_free_unlock;
    } else {

    }
#line 937
    rc = crypto_hash_final(& s->hash_desc, (u8 *)(& s->tmp_hash));
#line 938
    if (rc != 0) {
#line 939
      printk("\v%s: Error finalizing crypto hash; rc = [%d]\n", "ecryptfs_write_tag_70_packet",
             rc);
#line 942
      goto out_release_free_unlock;
    } else {

    }
#line 944
    __len = 16UL;
#line 944
    if (__len > 63UL) {
#line 944
      __ret = __memcpy((void *)(& s->hash), (void const   *)(& s->tmp_hash), __len);
    } else {
#line 944
      __ret = __builtin_memcpy((void *)(& s->hash), (void const   *)(& s->tmp_hash),
                               __len);
    }
  } else {

  }
#line 947
  if ((int )((signed char )*(s->block_aligned_filename + s->j)) == 0) {
#line 948
    *(s->block_aligned_filename + s->j) = 66;
  } else {

  }
#line 915
  s->j = s->j + 1UL;
  ldv_32372: ;
#line 915
  if (s->j < s->num_rand_bytes - 1UL) {
#line 916
    goto ldv_32371;
  } else {

  }
#line 950
  __len___0 = filename_size;
#line 950
  __ret___0 = __builtin_memcpy((void *)(s->block_aligned_filename + s->num_rand_bytes),
                               (void const   *)filename, __len___0);
#line 952
  rc = virt_to_scatterlist((void const   *)s->block_aligned_filename, (int )s->block_aligned_filename_size,
                           (struct scatterlist *)(& s->src_sg), 2);
#line 954
  if (rc <= 0) {
#line 955
    printk("\v%s: Internal error whilst attempting to convert filename memory to scatterlist; rc = [%d]. block_aligned_filename_size = [%zd]\n",
           "ecryptfs_write_tag_70_packet", rc, s->block_aligned_filename_size);
#line 959
    goto out_release_free_unlock;
  } else {

  }
#line 961
  rc = virt_to_scatterlist((void const   *)(dest + s->i), (int )s->block_aligned_filename_size,
                           (struct scatterlist *)(& s->dst_sg), 2);
#line 963
  if (rc <= 0) {
#line 964
    printk("\v%s: Internal error whilst attempting to convert encrypted filename memory to scatterlist; rc = [%d]. block_aligned_filename_size = [%zd]\n",
           "ecryptfs_write_tag_70_packet", rc, s->block_aligned_filename_size);
#line 968
    goto out_release_free_unlock;
  } else {

  }
#line 974
  memset((void *)(& s->iv), 0, 16UL);
#line 975
  s->desc.info = (void *)(& s->iv);
#line 976
  rc = crypto_blkcipher_setkey(s->desc.tfm, (u8 const   *)(& (s->auth_tok)->token.password.session_key_encryption_key),
                               (unsigned int )mount_crypt_stat->global_default_fn_cipher_key_bytes);
#line 980
  if (rc < 0) {
#line 981
    printk("\v%s: Error setting key for crypto context; rc = [%d]. s->auth_tok->token.password.session_key_encryption_key = [0x%p]; mount_crypt_stat->global_default_fn_cipher_key_bytes = [%zd]\n",
           "ecryptfs_write_tag_70_packet", rc, (u8 *)(& (s->auth_tok)->token.password.session_key_encryption_key),
           mount_crypt_stat->global_default_fn_cipher_key_bytes);
#line 988
    goto out_release_free_unlock;
  } else {

  }
#line 990
  rc = crypto_blkcipher_encrypt_iv(& s->desc, (struct scatterlist *)(& s->dst_sg),
                                   (struct scatterlist *)(& s->src_sg), (unsigned int )s->block_aligned_filename_size);
#line 992
  if (rc != 0) {
#line 993
    printk("\v%s: Error attempting to encrypt filename; rc = [%d]\n", "ecryptfs_write_tag_70_packet",
           rc);
#line 995
    goto out_release_free_unlock;
  } else {

  }
#line 997
  s->i = s->i + s->block_aligned_filename_size;
#line 998
  *packet_size = s->i;
#line 999
  *remaining_bytes = *remaining_bytes - *packet_size;
  out_release_free_unlock: 
#line 1001
  crypto_free_hash(s->hash_desc.tfm);
  out_free_unlock: 
#line 1003
  kzfree((void const   *)s->block_aligned_filename);
  out_unlock: 
#line 1005
  ldv_mutex_unlock_197(s->tfm_mutex);
  out: ;
#line 1007
  if ((unsigned long )auth_tok_key != (unsigned long )((struct key *)0)) {
#line 1008
    up_write(& auth_tok_key->sem);
#line 1009
    key_put(auth_tok_key);
  } else {

  }
#line 1011
  kfree((void const   *)s);
#line 1012
  return (rc);
}
}
#line 1050 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ecryptfs_parse_tag_70_packet(char **filename , size_t *filename_size , size_t *packet_size ,
                                 struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                 char *data , size_t max_packet_size ) 
{ 
  struct ecryptfs_parse_tag_70_packet_silly_stack *s ;
  struct key *auth_tok_key ;
  int rc ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t __len ;
  void *__ret ;

  {
#line 1056
  auth_tok_key = 0;
#line 1057
  rc = 0;
#line 1059
  *packet_size = 0UL;
#line 1060
  *filename_size = 0UL;
#line 1061
  *filename = 0;
#line 1062
  tmp = kmalloc(336UL, 208U);
#line 1062
  s = (struct ecryptfs_parse_tag_70_packet_silly_stack *)tmp;
#line 1063
  if ((unsigned long )s == (unsigned long )((struct ecryptfs_parse_tag_70_packet_silly_stack *)0)) {
#line 1064
    printk("\v%s: Out of memory whilst trying to kmalloc [%zd] bytes of kernel memory\n",
           "ecryptfs_parse_tag_70_packet", 336UL);
#line 1066
    rc = -12;
#line 1067
    goto out;
  } else {

  }
#line 1069
  s->desc.flags = 512U;
#line 1070
  if (max_packet_size <= 11UL) {
#line 1071
    printk("\f%s: max_packet_size is [%zd]; it must be at least [%d]\n", "ecryptfs_parse_tag_70_packet",
           max_packet_size, 12);
#line 1074
    rc = -22;
#line 1075
    goto out;
  } else {

  }
#line 1085
  tmp___0 = *packet_size;
#line 1085
  *packet_size = *packet_size + 1UL;
#line 1085
  if ((int )((signed char )*(data + tmp___0)) != 70) {
#line 1086
    printk("\f%s: Invalid packet tag [0x%.2x]; must be tag [0x%.2x]\n", "ecryptfs_parse_tag_70_packet",
           (int )*(data + (*packet_size + 0xffffffffffffffffUL)), 70);
#line 1089
    rc = -22;
#line 1090
    goto out;
  } else {

  }
#line 1092
  rc = ecryptfs_parse_packet_length((unsigned char *)(data + *packet_size), & s->parsed_tag_70_packet_size,
                                    & s->packet_size_len);
#line 1095
  if (rc != 0) {
#line 1096
    printk("\f%s: Error parsing packet length; rc = [%d]\n", "ecryptfs_parse_tag_70_packet",
           rc);
#line 1098
    goto out;
  } else {

  }
#line 1100
  s->block_aligned_filename_size = s->parsed_tag_70_packet_size - 9UL;
#line 1102
  if ((s->packet_size_len + s->parsed_tag_70_packet_size) + 1UL > max_packet_size) {
#line 1104
    printk("\f%s: max_packet_size is [%zd]; real packet size is [%zd]\n", "ecryptfs_parse_tag_70_packet",
           max_packet_size, (s->packet_size_len + s->block_aligned_filename_size) + 2UL);
#line 1108
    rc = -22;
#line 1109
    goto out;
  } else {

  }
#line 1111
  *packet_size = *packet_size + s->packet_size_len;
#line 1112
  ecryptfs_to_hex((char *)(& s->fnek_sig_hex), data + *packet_size, 8UL);
#line 1114
  s->fnek_sig_hex[16] = 0;
#line 1115
  *packet_size = *packet_size + 8UL;
#line 1116
  tmp___1 = *packet_size;
#line 1116
  *packet_size = *packet_size + 1UL;
#line 1116
  s->cipher_code = (u8 )*(data + tmp___1);
#line 1117
  rc = ecryptfs_cipher_code_to_string((char *)(& s->cipher_string), (int )s->cipher_code);
#line 1118
  if (rc != 0) {
#line 1119
    printk("\f%s: Cipher code [%d] is invalid\n", "ecryptfs_parse_tag_70_packet",
           (int )s->cipher_code);
#line 1121
    goto out;
  } else {

  }
#line 1123
  rc = ecryptfs_find_auth_tok_for_sig(& auth_tok_key, & s->auth_tok, mount_crypt_stat,
                                      (char *)(& s->fnek_sig_hex));
#line 1126
  if (rc != 0) {
#line 1127
    printk("\v%s: Error attempting to find auth tok for fnek sig [%s]; rc = [%d]\n",
           "ecryptfs_parse_tag_70_packet", (char *)(& s->fnek_sig_hex), rc);
#line 1130
    goto out;
  } else {

  }
#line 1132
  rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(& s->desc.tfm, & s->tfm_mutex, (char *)(& s->cipher_string));
#line 1135
  tmp___2 = __builtin_expect(rc != 0, 0L);
#line 1135
  if (tmp___2 != 0L) {
#line 1136
    printk("\vInternal error whilst attempting to get tfm and mutex for cipher name [%s]; rc = [%d]\n",
           (char *)(& s->cipher_string), rc);
#line 1139
    goto out;
  } else {

  }
#line 1141
  ldv_mutex_lock_198(s->tfm_mutex);
#line 1142
  rc = virt_to_scatterlist((void const   *)(data + *packet_size), (int )s->block_aligned_filename_size,
                           (struct scatterlist *)(& s->src_sg), 2);
#line 1144
  if (rc <= 0) {
#line 1145
    printk("\v%s: Internal error whilst attempting to convert encrypted filename memory to scatterlist; rc = [%d]. block_aligned_filename_size = [%zd]\n",
           "ecryptfs_parse_tag_70_packet", rc, s->block_aligned_filename_size);
#line 1149
    goto out_unlock;
  } else {

  }
#line 1151
  *packet_size = *packet_size + s->block_aligned_filename_size;
#line 1152
  tmp___3 = kmalloc(s->block_aligned_filename_size, 208U);
#line 1152
  s->decrypted_filename = (char *)tmp___3;
#line 1154
  if ((unsigned long )s->decrypted_filename == (unsigned long )((char *)0)) {
#line 1155
    printk("\v%s: Out of memory whilst attempting to kmalloc [%zd] bytes\n", "ecryptfs_parse_tag_70_packet",
           s->block_aligned_filename_size);
#line 1158
    rc = -12;
#line 1159
    goto out_unlock;
  } else {

  }
#line 1161
  rc = virt_to_scatterlist((void const   *)s->decrypted_filename, (int )s->block_aligned_filename_size,
                           (struct scatterlist *)(& s->dst_sg), 2);
#line 1163
  if (rc <= 0) {
#line 1164
    printk("\v%s: Internal error whilst attempting to convert decrypted filename memory to scatterlist; rc = [%d]. block_aligned_filename_size = [%zd]\n",
           "ecryptfs_parse_tag_70_packet", rc, s->block_aligned_filename_size);
#line 1168
    goto out_free_unlock;
  } else {

  }
#line 1174
  memset((void *)(& s->iv), 0, 16UL);
#line 1175
  s->desc.info = (void *)(& s->iv);
#line 1178
  if ((unsigned int )(s->auth_tok)->token_type != 0U) {
#line 1179
    rc = -95;
#line 1180
    printk("\016%s: Filename encryption only supports password tokens\n", "ecryptfs_parse_tag_70_packet");
#line 1182
    goto out_free_unlock;
  } else {

  }
#line 1184
  rc = crypto_blkcipher_setkey(s->desc.tfm, (u8 const   *)(& (s->auth_tok)->token.password.session_key_encryption_key),
                               (unsigned int )mount_crypt_stat->global_default_fn_cipher_key_bytes);
#line 1188
  if (rc < 0) {
#line 1189
    printk("\v%s: Error setting key for crypto context; rc = [%d]. s->auth_tok->token.password.session_key_encryption_key = [0x%p]; mount_crypt_stat->global_default_fn_cipher_key_bytes = [%zd]\n",
           "ecryptfs_parse_tag_70_packet", rc, (u8 *)(& (s->auth_tok)->token.password.session_key_encryption_key),
           mount_crypt_stat->global_default_fn_cipher_key_bytes);
#line 1196
    goto out_free_unlock;
  } else {

  }
#line 1198
  rc = crypto_blkcipher_decrypt_iv(& s->desc, (struct scatterlist *)(& s->dst_sg),
                                   (struct scatterlist *)(& s->src_sg), (unsigned int )s->block_aligned_filename_size);
#line 1200
  if (rc != 0) {
#line 1201
    printk("\v%s: Error attempting to decrypt filename; rc = [%d]\n", "ecryptfs_parse_tag_70_packet",
           rc);
#line 1203
    goto out_free_unlock;
  } else {

  }
#line 1205
  s->i = 0UL;
#line 1206
  goto ldv_32410;
  ldv_32409: 
#line 1208
  s->i = s->i + 1UL;
  ldv_32410: ;
#line 1206
  if ((int )((signed char )*(s->decrypted_filename + s->i)) != 0 && s->i < s->block_aligned_filename_size) {
#line 1208
    goto ldv_32409;
  } else {

  }

#line 1209
  if (s->i == s->block_aligned_filename_size) {
#line 1210
    printk("\f%s: Invalid tag 70 packet; could not find valid separator between random characters and the filename\n",
           "ecryptfs_parse_tag_70_packet");
#line 1213
    rc = -22;
#line 1214
    goto out_free_unlock;
  } else {

  }
#line 1216
  s->i = s->i + 1UL;
#line 1217
  *filename_size = s->block_aligned_filename_size - s->i;
#line 1218
  if (*filename_size == 0UL || *filename_size > 4095UL) {
#line 1219
    printk("\f%s: Filename size is [%zd], which is invalid\n", "ecryptfs_parse_tag_70_packet",
           *filename_size);
#line 1221
    rc = -22;
#line 1222
    goto out_free_unlock;
  } else {

  }
#line 1224
  tmp___4 = kmalloc(*filename_size + 1UL, 208U);
#line 1224
  *filename = (char *)tmp___4;
#line 1225
  if ((unsigned long )*filename == (unsigned long )((char *)0)) {
#line 1226
    printk("\v%s: Out of memory whilst attempting to kmalloc [%zd] bytes\n", "ecryptfs_parse_tag_70_packet",
           *filename_size + 1UL);
#line 1229
    rc = -12;
#line 1230
    goto out_free_unlock;
  } else {

  }
#line 1232
  __len = *filename_size;
#line 1232
  __ret = __builtin_memcpy((void *)*filename, (void const   *)(s->decrypted_filename + s->i),
                           __len);
#line 1233
  *(*filename + *filename_size) = 0;
  out_free_unlock: 
#line 1235
  kfree((void const   *)s->decrypted_filename);
  out_unlock: 
#line 1237
  ldv_mutex_unlock_199(s->tfm_mutex);
  out: ;
#line 1239
  if (rc != 0) {
#line 1240
    *packet_size = 0UL;
#line 1241
    *filename_size = 0UL;
#line 1242
    *filename = 0;
  } else {

  }
#line 1244
  if ((unsigned long )auth_tok_key != (unsigned long )((struct key *)0)) {
#line 1245
    up_write(& auth_tok_key->sem);
#line 1246
    key_put(auth_tok_key);
  } else {

  }
#line 1248
  kfree((void const   *)s);
#line 1249
  return (rc);
}
}
#line 1253 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int ecryptfs_get_auth_tok_sig(char **sig , struct ecryptfs_auth_tok *auth_tok ) 
{ 
  int rc ;

  {
#line 1255
  rc = 0;
#line 1257
  *sig = 0;
#line 1258
  switch ((int )auth_tok->token_type) {
  case 0: 
#line 1260
  *sig = (char *)(& auth_tok->token.password.signature);
#line 1261
  goto ldv_32421;
  case 1: 
#line 1263
  *sig = (char *)(& auth_tok->token.private_key.signature);
#line 1264
  goto ldv_32421;
  default: 
#line 1266
  printk("\vCannot get sig for auth_tok of type [%d]\n", (int )auth_tok->token_type);
#line 1268
  rc = -22;
  }
  ldv_32421: ;
#line 1270
  return (rc);
}
}
#line 1281 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int decrypt_pki_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok ,
                                             struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  u8 cipher_code ;
  struct ecryptfs_msg_ctx *msg_ctx ;
  struct ecryptfs_message *msg ;
  char *auth_tok_sig ;
  char *payload ;
  size_t payload_len ;
  int rc ;
  size_t __len ;
  void *__ret ;

  {
#line 1284
  cipher_code = 0U;
#line 1286
  msg = 0;
#line 1292
  rc = ecryptfs_get_auth_tok_sig(& auth_tok_sig, auth_tok);
#line 1293
  if (rc != 0) {
#line 1294
    printk("\vUnrecognized auth tok type: [%d]\n", (int )auth_tok->token_type);
#line 1296
    goto out;
  } else {

  }
#line 1298
  rc = write_tag_64_packet(auth_tok_sig, & auth_tok->session_key, & payload, & payload_len);
#line 1300
  if (rc != 0) {
#line 1301
    __ecryptfs_printk("\v%s: Failed to write tag 64 packet\n", "decrypt_pki_encrypted_session_key");
#line 1302
    goto out;
  } else {

  }
#line 1304
  rc = ecryptfs_send_message(payload, (int )payload_len, & msg_ctx);
#line 1305
  if (rc != 0) {
#line 1306
    __ecryptfs_printk("\v%s: Error sending message to ecryptfsd\n", "decrypt_pki_encrypted_session_key");
#line 1308
    goto out;
  } else {

  }
#line 1310
  rc = ecryptfs_wait_for_response(msg_ctx, & msg);
#line 1311
  if (rc != 0) {
#line 1312
    __ecryptfs_printk("\v%s: Failed to receive tag 65 packet from the user space daemon\n",
                      "decrypt_pki_encrypted_session_key");
#line 1314
    rc = -5;
#line 1315
    goto out;
  } else {

  }
#line 1317
  rc = parse_tag_65_packet(& auth_tok->session_key, & cipher_code, msg);
#line 1319
  if (rc != 0) {
#line 1320
    printk("\vFailed to parse tag 65 packet; rc = [%d]\n", rc);
#line 1322
    goto out;
  } else {

  }
#line 1324
  auth_tok->session_key.flags = auth_tok->session_key.flags | 4U;
#line 1325
  __len = (size_t )auth_tok->session_key.decrypted_key_size;
#line 1325
  __ret = __builtin_memcpy((void *)(& crypt_stat->key), (void const   *)(& auth_tok->session_key.decrypted_key),
                           __len);
#line 1327
  crypt_stat->key_size = (size_t )auth_tok->session_key.decrypted_key_size;
#line 1328
  rc = ecryptfs_cipher_code_to_string((char *)(& crypt_stat->cipher), (int )cipher_code);
#line 1329
  if (rc != 0) {
#line 1330
    __ecryptfs_printk("\v%s: Cipher code [%d] is invalid\n", "decrypt_pki_encrypted_session_key",
                      (int )cipher_code);
#line 1332
    goto out;
  } else {

  }
#line 1334
  crypt_stat->flags = crypt_stat->flags | 64U;
#line 1335
  if (ecryptfs_verbosity > 0) {
#line 1336
    __ecryptfs_printk("\017%s: Decrypted session key:\n", "decrypt_pki_encrypted_session_key");
#line 1337
    ecryptfs_dump_hex((char *)(& crypt_stat->key), (int )crypt_stat->key_size);
  } else {

  }
  out: ;
#line 1341
  if ((unsigned long )msg != (unsigned long )((struct ecryptfs_message *)0)) {
#line 1342
    kfree((void const   *)msg);
  } else {

  }
#line 1343
  return (rc);
}
}
#line 1346 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static void wipe_auth_tok_list(struct list_head *auth_tok_list_head ) 
{ 
  struct ecryptfs_auth_tok_list_item *auth_tok_list_item ;
  struct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1351
  __mptr = (struct list_head  const  *)auth_tok_list_head->next;
#line 1351
  auth_tok_list_item = (struct ecryptfs_auth_tok_list_item *)__mptr + 0xffffffffffffffc0UL;
#line 1351
  __mptr___0 = (struct list_head  const  *)auth_tok_list_item->list.next;
#line 1351
  auth_tok_list_item_tmp = (struct ecryptfs_auth_tok_list_item *)__mptr___0 + 0xffffffffffffffc0UL;
#line 1351
  goto ldv_32452;
  ldv_32451: 
#line 1353
  list_del(& auth_tok_list_item->list);
#line 1354
  kmem_cache_free(ecryptfs_auth_tok_list_item_cache, (void *)auth_tok_list_item);
#line 1351
  auth_tok_list_item = auth_tok_list_item_tmp;
#line 1351
  __mptr___1 = (struct list_head  const  *)auth_tok_list_item_tmp->list.next;
#line 1351
  auth_tok_list_item_tmp = (struct ecryptfs_auth_tok_list_item *)__mptr___1 + 0xffffffffffffffc0UL;
  ldv_32452: ;
#line 1351
  if ((unsigned long )(& auth_tok_list_item->list) != (unsigned long )auth_tok_list_head) {
#line 1352
    goto ldv_32451;
  } else {

  }

#line 1356
  return;
}
}
#line 1379 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int parse_tag_1_packet(struct ecryptfs_crypt_stat *crypt_stat , unsigned char *data ,
                              struct list_head *auth_tok_list , struct ecryptfs_auth_tok **new_auth_tok ,
                              size_t *packet_size , size_t max_packet_size ) 
{ 
  size_t body_size ;
  struct ecryptfs_auth_tok_list_item *auth_tok_list_item ;
  size_t length_size ;
  int rc ;
  long tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  size_t tmp___4 ;
  long tmp___5 ;
  size_t __len ;
  void *__ret ;

  {
#line 1387
  rc = 0;
#line 1389
  *packet_size = 0UL;
#line 1390
  *new_auth_tok = 0;
#line 1404
  tmp = __builtin_expect(max_packet_size <= 11UL, 0L);
#line 1404
  if (tmp != 0L) {
#line 1405
    printk("\vInvalid max packet size; must be >=12\n");
#line 1406
    rc = -22;
#line 1407
    goto out;
  } else {

  }
#line 1409
  tmp___0 = *packet_size;
#line 1409
  *packet_size = *packet_size + 1UL;
#line 1409
  if ((unsigned int )*(data + tmp___0) != 1U) {
#line 1410
    printk("\vEnter w/ first byte != 0x%.2x\n", 1);
#line 1412
    rc = -22;
#line 1413
    goto out;
  } else {

  }
#line 1417
  tmp___1 = kmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, 208U);
#line 1417
  auth_tok_list_item = (struct ecryptfs_auth_tok_list_item *)tmp___1;
#line 1420
  if ((unsigned long )auth_tok_list_item == (unsigned long )((struct ecryptfs_auth_tok_list_item *)0)) {
#line 1421
    printk("\vUnable to allocate memory\n");
#line 1422
    rc = -12;
#line 1423
    goto out;
  } else {

  }
#line 1425
  *new_auth_tok = & auth_tok_list_item->auth_tok;
#line 1426
  rc = ecryptfs_parse_packet_length(data + *packet_size, & body_size, & length_size);
#line 1428
  if (rc != 0) {
#line 1429
    printk("\fError parsing packet length; rc = [%d]\n", rc);
#line 1431
    goto out_free;
  } else {

  }
#line 1433
  tmp___2 = __builtin_expect(body_size <= 9UL, 0L);
#line 1433
  if (tmp___2 != 0L) {
#line 1434
    printk("\fInvalid body size ([%td])\n", body_size);
#line 1435
    rc = -22;
#line 1436
    goto out_free;
  } else {

  }
#line 1438
  *packet_size = *packet_size + length_size;
#line 1439
  tmp___3 = __builtin_expect(*packet_size + body_size > max_packet_size, 0L);
#line 1439
  if (tmp___3 != 0L) {
#line 1440
    printk("\fPacket size exceeds max\n");
#line 1441
    rc = -22;
#line 1442
    goto out_free;
  } else {

  }
#line 1444
  tmp___4 = *packet_size;
#line 1444
  *packet_size = *packet_size + 1UL;
#line 1444
  tmp___5 = __builtin_expect((unsigned int )*(data + tmp___4) != 3U, 0L);
#line 1444
  if (tmp___5 != 0L) {
#line 1445
    printk("\fUnknown version number [%d]\n", (int )*(data + (*packet_size + 0xffffffffffffffffUL)));
#line 1447
    rc = -22;
#line 1448
    goto out_free;
  } else {

  }
#line 1450
  ecryptfs_to_hex((char *)(& (*new_auth_tok)->token.private_key.signature), (char *)(data + *packet_size),
                  8UL);
#line 1452
  *packet_size = *packet_size + 8UL;
#line 1455
  *packet_size = *packet_size + 1UL;
#line 1456
  (*new_auth_tok)->session_key.encrypted_key_size = (u32 )body_size - 10U;
#line 1458
  if ((*new_auth_tok)->session_key.encrypted_key_size > 512U) {
#line 1460
    printk("\fTag 1 packet contains key larger than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES");
#line 1462
    rc = -22;
#line 1463
    goto out;
  } else {

  }
#line 1465
  __len = body_size - 10UL;
#line 1465
  __ret = __builtin_memcpy((void *)(& (*new_auth_tok)->session_key.encrypted_key),
                           (void const   *)(data + *packet_size), __len);
#line 1467
  *packet_size = *packet_size + (size_t )(*new_auth_tok)->session_key.encrypted_key_size;
#line 1468
  (*new_auth_tok)->session_key.flags = (*new_auth_tok)->session_key.flags & 4294967291U;
#line 1470
  (*new_auth_tok)->session_key.flags = (*new_auth_tok)->session_key.flags | 8U;
#line 1472
  (*new_auth_tok)->token_type = 1U;
#line 1473
  (*new_auth_tok)->flags = 0U;
#line 1474
  (*new_auth_tok)->session_key.flags = (*new_auth_tok)->session_key.flags & 4294967294U;
#line 1476
  (*new_auth_tok)->session_key.flags = (*new_auth_tok)->session_key.flags & 4294967293U;
#line 1478
  list_add(& auth_tok_list_item->list, auth_tok_list);
#line 1479
  goto out;
  out_free: 
#line 1481
  *new_auth_tok = 0;
#line 1482
  memset((void *)auth_tok_list_item, 0, 824UL);
#line 1484
  kmem_cache_free(ecryptfs_auth_tok_list_item_cache, (void *)auth_tok_list_item);
  out: ;
#line 1487
  if (rc != 0) {
#line 1488
    *packet_size = 0UL;
  } else {

  }
#line 1489
  return (rc);
}
}
#line 1511 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int parse_tag_3_packet(struct ecryptfs_crypt_stat *crypt_stat , unsigned char *data ,
                              struct list_head *auth_tok_list , struct ecryptfs_auth_tok **new_auth_tok ,
                              size_t *packet_size , size_t max_packet_size ) 
{ 
  size_t body_size ;
  struct ecryptfs_auth_tok_list_item *auth_tok_list_item ;
  size_t length_size ;
  int rc ;
  size_t tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  long tmp___7 ;
  size_t tmp___8 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1519
  rc = 0;
#line 1521
  *packet_size = 0UL;
#line 1522
  *new_auth_tok = 0;
#line 1539
  if (max_packet_size <= 14UL) {
#line 1540
    printk("\vMax packet size too large\n");
#line 1541
    rc = -22;
#line 1542
    goto out;
  } else {

  }
#line 1544
  tmp = *packet_size;
#line 1544
  *packet_size = *packet_size + 1UL;
#line 1544
  if ((unsigned int )*(data + tmp) != 140U) {
#line 1545
    printk("\vFirst byte != 0x%.2x; invalid packet\n", 140);
#line 1547
    rc = -22;
#line 1548
    goto out;
  } else {

  }
#line 1552
  tmp___0 = kmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, 208U);
#line 1552
  auth_tok_list_item = (struct ecryptfs_auth_tok_list_item *)tmp___0;
#line 1554
  if ((unsigned long )auth_tok_list_item == (unsigned long )((struct ecryptfs_auth_tok_list_item *)0)) {
#line 1555
    printk("\vUnable to allocate memory\n");
#line 1556
    rc = -12;
#line 1557
    goto out;
  } else {

  }
#line 1559
  *new_auth_tok = & auth_tok_list_item->auth_tok;
#line 1560
  rc = ecryptfs_parse_packet_length(data + *packet_size, & body_size, & length_size);
#line 1562
  if (rc != 0) {
#line 1563
    printk("\fError parsing packet length; rc = [%d]\n", rc);
#line 1565
    goto out_free;
  } else {

  }
#line 1567
  tmp___1 = __builtin_expect(body_size <= 12UL, 0L);
#line 1567
  if (tmp___1 != 0L) {
#line 1568
    printk("\fInvalid body size ([%td])\n", body_size);
#line 1569
    rc = -22;
#line 1570
    goto out_free;
  } else {

  }
#line 1572
  *packet_size = *packet_size + length_size;
#line 1573
  tmp___2 = __builtin_expect(*packet_size + body_size > max_packet_size, 0L);
#line 1573
  if (tmp___2 != 0L) {
#line 1574
    printk("\vPacket size exceeds max\n");
#line 1575
    rc = -22;
#line 1576
    goto out_free;
  } else {

  }
#line 1578
  (*new_auth_tok)->session_key.encrypted_key_size = (u32 )body_size - 13U;
#line 1580
  if ((*new_auth_tok)->session_key.encrypted_key_size > 512U) {
#line 1582
    printk("\fTag 3 packet contains key larger than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\n");
#line 1584
    rc = -22;
#line 1585
    goto out_free;
  } else {

  }
#line 1587
  tmp___3 = *packet_size;
#line 1587
  *packet_size = *packet_size + 1UL;
#line 1587
  tmp___4 = __builtin_expect((unsigned int )*(data + tmp___3) != 4U, 0L);
#line 1587
  if (tmp___4 != 0L) {
#line 1588
    printk("\fUnknown version number [%d]\n", (int )*(data + (*packet_size + 0xffffffffffffffffUL)));
#line 1590
    rc = -22;
#line 1591
    goto out_free;
  } else {

  }
#line 1593
  rc = ecryptfs_cipher_code_to_string((char *)(& crypt_stat->cipher), (int )*(data + *packet_size));
#line 1595
  if (rc != 0) {
#line 1596
    goto out_free;
  } else {

  }
#line 1599
  tmp___5 = *packet_size;
#line 1599
  *packet_size = *packet_size + 1UL;
#line 1599
  switch ((int )*(data + tmp___5)) {
  case 8: 
#line 1601
  crypt_stat->key_size = 24UL;
#line 1602
  goto ldv_32487;
  default: 
#line 1604
  crypt_stat->key_size = (size_t )(*new_auth_tok)->session_key.encrypted_key_size;
  }
  ldv_32487: 
#line 1607
  rc = ecryptfs_init_crypt_ctx(crypt_stat);
#line 1608
  if (rc != 0) {
#line 1609
    goto out_free;
  } else {

  }
#line 1610
  tmp___6 = *packet_size;
#line 1610
  *packet_size = *packet_size + 1UL;
#line 1610
  tmp___7 = __builtin_expect((unsigned int )*(data + tmp___6) != 3U, 0L);
#line 1610
  if (tmp___7 != 0L) {
#line 1611
    printk("\fOnly S2K ID 3 is currently supported\n");
#line 1612
    rc = -38;
#line 1613
    goto out_free;
  } else {

  }
#line 1616
  tmp___8 = *packet_size;
#line 1616
  *packet_size = *packet_size + 1UL;
#line 1616
  switch ((int )*(data + tmp___8)) {
  case 1: 
#line 1619
  __len = 8UL;
#line 1619
  if (__len > 63UL) {
#line 1619
    __ret = __memcpy((void *)(& (*new_auth_tok)->token.password.salt), (void const   *)(data + *packet_size),
                     __len);
  } else {
#line 1619
    __ret = __builtin_memcpy((void *)(& (*new_auth_tok)->token.password.salt), (void const   *)(data + *packet_size),
                             __len);
  }
#line 1621
  *packet_size = *packet_size + 8UL;
#line 1623
  (*new_auth_tok)->token.password.hash_iterations = (((unsigned int )*(data + *packet_size) & 15U) + 16U) << (((int )*(data + *packet_size) >> 4) + 6);
#line 1626
  *packet_size = *packet_size + 1UL;
#line 1630
  __len___0 = (size_t )(*new_auth_tok)->session_key.encrypted_key_size;
#line 1630
  __ret___0 = __builtin_memcpy((void *)(& (*new_auth_tok)->session_key.encrypted_key),
                               (void const   *)(data + *packet_size), __len___0);
#line 1633
  *packet_size = *packet_size + (size_t )(*new_auth_tok)->session_key.encrypted_key_size;
#line 1635
  (*new_auth_tok)->session_key.flags = (*new_auth_tok)->session_key.flags & 4294967291U;
#line 1637
  (*new_auth_tok)->session_key.flags = (*new_auth_tok)->session_key.flags | 8U;
#line 1639
  (*new_auth_tok)->token.password.hash_algo = 1;
#line 1640
  goto ldv_32496;
  default: 
#line 1642
  __ecryptfs_printk("\v%s: Unsupported hash algorithm: [%d]\n", "parse_tag_3_packet",
                    (int )*(data + (*packet_size + 0xffffffffffffffffUL)));
#line 1644
  rc = -38;
#line 1645
  goto out_free;
  }
  ldv_32496: 
#line 1647
  (*new_auth_tok)->token_type = 0U;
#line 1650
  (*new_auth_tok)->session_key.flags = (*new_auth_tok)->session_key.flags & 4294967294U;
#line 1652
  (*new_auth_tok)->session_key.flags = (*new_auth_tok)->session_key.flags & 4294967293U;
#line 1654
  list_add(& auth_tok_list_item->list, auth_tok_list);
#line 1655
  goto out;
  out_free: 
#line 1657
  *new_auth_tok = 0;
#line 1658
  memset((void *)auth_tok_list_item, 0, 824UL);
#line 1660
  kmem_cache_free(ecryptfs_auth_tok_list_item_cache, (void *)auth_tok_list_item);
  out: ;
#line 1663
  if (rc != 0) {
#line 1664
    *packet_size = 0UL;
  } else {

  }
#line 1665
  return (rc);
}
}
#line 1685 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int parse_tag_11_packet(unsigned char *data , unsigned char *contents , size_t max_contents_bytes ,
                               size_t *tag_11_contents_size , size_t *packet_size ,
                               size_t max_packet_size ) 
{ 
  size_t body_size ;
  size_t length_size ;
  int rc ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t __len ;
  void *__ret ;

  {
#line 1691
  rc = 0;
#line 1693
  *packet_size = 0UL;
#line 1694
  *tag_11_contents_size = 0UL;
#line 1709
  if (max_packet_size <= 15UL) {
#line 1710
    printk("\vMaximum packet size too small\n");
#line 1711
    rc = -22;
#line 1712
    goto out;
  } else {

  }
#line 1714
  tmp = *packet_size;
#line 1714
  *packet_size = *packet_size + 1UL;
#line 1714
  if ((unsigned int )*(data + tmp) != 237U) {
#line 1715
    printk("\fInvalid tag 11 packet format\n");
#line 1716
    rc = -22;
#line 1717
    goto out;
  } else {

  }
#line 1719
  rc = ecryptfs_parse_packet_length(data + *packet_size, & body_size, & length_size);
#line 1721
  if (rc != 0) {
#line 1722
    printk("\fInvalid tag 11 packet format\n");
#line 1723
    goto out;
  } else {

  }
#line 1725
  if (body_size <= 13UL) {
#line 1726
    printk("\fInvalid body size ([%td])\n", body_size);
#line 1727
    rc = -22;
#line 1728
    goto out;
  } else {

  }
#line 1730
  *packet_size = *packet_size + length_size;
#line 1731
  *tag_11_contents_size = body_size - 14UL;
#line 1732
  tmp___0 = __builtin_expect((*packet_size + body_size) + 1UL > max_packet_size, 0L);
#line 1732
  if (tmp___0 != 0L) {
#line 1733
    printk("\vPacket size exceeds max\n");
#line 1734
    rc = -22;
#line 1735
    goto out;
  } else {

  }
#line 1737
  tmp___1 = __builtin_expect(*tag_11_contents_size > max_contents_bytes, 0L);
#line 1737
  if (tmp___1 != 0L) {
#line 1738
    printk("\vLiteral data section in tag 11 packet exceeds expected size\n");
#line 1740
    rc = -22;
#line 1741
    goto out;
  } else {

  }
#line 1743
  tmp___2 = *packet_size;
#line 1743
  *packet_size = *packet_size + 1UL;
#line 1743
  if ((unsigned int )*(data + tmp___2) != 98U) {
#line 1744
    printk("\fUnrecognizable packet\n");
#line 1745
    rc = -22;
#line 1746
    goto out;
  } else {

  }
#line 1748
  tmp___3 = *packet_size;
#line 1748
  *packet_size = *packet_size + 1UL;
#line 1748
  if ((unsigned int )*(data + tmp___3) != 8U) {
#line 1749
    printk("\fUnrecognizable packet\n");
#line 1750
    rc = -22;
#line 1751
    goto out;
  } else {

  }
#line 1753
  *packet_size = *packet_size + 12UL;
#line 1754
  __len = *tag_11_contents_size;
#line 1754
  __ret = __builtin_memcpy((void *)contents, (void const   *)(data + *packet_size),
                           __len);
#line 1755
  *packet_size = *packet_size + *tag_11_contents_size;
  out: ;
#line 1757
  if (rc != 0) {
#line 1758
    *packet_size = 0UL;
#line 1759
    *tag_11_contents_size = 0UL;
  } else {

  }
#line 1761
  return (rc);
}
}
#line 1764 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key , struct ecryptfs_auth_tok **auth_tok ,
                                      char *sig ) 
{ 
  int rc ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 1768
  rc = 0;
#line 1770
  *auth_tok_key = request_key(& key_type_user, (char const   *)sig, 0);
#line 1771
  if ((unsigned long )*auth_tok_key == (unsigned long )((struct key *)0)) {
#line 1771
    goto _L;
  } else {
#line 1771
    tmp___1 = IS_ERR((void const   *)*auth_tok_key);
#line 1771
    if (tmp___1 != 0L) {
      _L: /* CIL Label */ 
#line 1772
      *auth_tok_key = ecryptfs_get_encrypted_key(sig);
#line 1773
      if ((unsigned long )*auth_tok_key == (unsigned long )((struct key *)0)) {
#line 1774
        printk("\vCould not find key with description: [%s]\n", sig);
#line 1776
        tmp = PTR_ERR((void const   *)*auth_tok_key);
#line 1776
        rc = process_request_key_err(tmp);
#line 1777
        *auth_tok_key = 0;
#line 1778
        goto out;
      } else {
#line 1773
        tmp___0 = IS_ERR((void const   *)*auth_tok_key);
#line 1773
        if (tmp___0 != 0L) {
#line 1774
          printk("\vCould not find key with description: [%s]\n", sig);
#line 1776
          tmp = PTR_ERR((void const   *)*auth_tok_key);
#line 1776
          rc = process_request_key_err(tmp);
#line 1777
          *auth_tok_key = 0;
#line 1778
          goto out;
        } else {

        }
      }
    } else {

    }
  }
#line 1781
  down_write(& (*auth_tok_key)->sem);
#line 1782
  rc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);
#line 1783
  if (rc != 0) {
#line 1784
    up_write(& (*auth_tok_key)->sem);
#line 1785
    key_put(*auth_tok_key);
#line 1786
    *auth_tok_key = 0;
#line 1787
    goto out;
  } else {

  }
  out: ;
#line 1790
  return (rc);
}
}
#line 1801 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int decrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok ,
                                                    struct ecryptfs_crypt_stat *crypt_stat ) 
{ 
  struct scatterlist dst_sg[2U] ;
  struct scatterlist src_sg[2U] ;
  struct mutex *tfm_mutex ;
  struct blkcipher_desc desc ;
  int rc ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  size_t __len ;
  void *__ret ;
  long tmp___3 ;

  {
#line 1807
  desc.tfm = 0;
#line 1807
  desc.info = 0;
#line 1807
  desc.flags = 512U;
#line 1810
  rc = 0;
#line 1812
  tmp = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 1812
  if (tmp != 0L) {
#line 1813
    __ecryptfs_printk("\017%s: Session key encryption key (size [%d]):\n", "decrypt_passphrase_encrypted_session_key",
                      auth_tok->token.password.session_key_encryption_key_bytes);
#line 1816
    ecryptfs_dump_hex((char *)(& auth_tok->token.password.session_key_encryption_key),
                      (int )auth_tok->token.password.session_key_encryption_key_bytes);
  } else {

  }
#line 1820
  rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(& desc.tfm, & tfm_mutex, (char *)(& crypt_stat->cipher));
#line 1822
  tmp___0 = __builtin_expect(rc != 0, 0L);
#line 1822
  if (tmp___0 != 0L) {
#line 1823
    printk("\vInternal error whilst attempting to get tfm and mutex for cipher name [%s]; rc = [%d]\n",
           (unsigned char *)(& crypt_stat->cipher), rc);
#line 1826
    goto out;
  } else {

  }
#line 1828
  rc = virt_to_scatterlist((void const   *)(& auth_tok->session_key.encrypted_key),
                           (int )auth_tok->session_key.encrypted_key_size, (struct scatterlist *)(& src_sg),
                           2);
#line 1831
  if (rc <= 0 || rc > 2) {
#line 1832
    printk("\vInternal error whilst attempting to convert auth_tok->session_key.encrypted_key to scatterlist; expected rc = 1; got rc = [%d]. auth_tok->session_key.encrypted_key_size = [%d]\n",
           rc, auth_tok->session_key.encrypted_key_size);
#line 1837
    goto out;
  } else {

  }
#line 1839
  auth_tok->session_key.decrypted_key_size = auth_tok->session_key.encrypted_key_size;
#line 1841
  rc = virt_to_scatterlist((void const   *)(& auth_tok->session_key.decrypted_key),
                           (int )auth_tok->session_key.decrypted_key_size, (struct scatterlist *)(& dst_sg),
                           2);
#line 1844
  if (rc <= 0 || rc > 2) {
#line 1845
    printk("\vInternal error whilst attempting to convert auth_tok->session_key.decrypted_key to scatterlist; expected rc = 1; got rc = [%d]\n",
           rc);
#line 1848
    goto out;
  } else {

  }
#line 1850
  ldv_mutex_lock_200(tfm_mutex);
#line 1851
  rc = crypto_blkcipher_setkey(desc.tfm, (u8 const   *)(& auth_tok->token.password.session_key_encryption_key),
                               (unsigned int )crypt_stat->key_size);
#line 1854
  tmp___1 = __builtin_expect(rc < 0, 0L);
#line 1854
  if (tmp___1 != 0L) {
#line 1855
    ldv_mutex_unlock_201(tfm_mutex);
#line 1856
    printk("\vError setting key for crypto context\n");
#line 1857
    rc = -22;
#line 1858
    goto out;
  } else {

  }
#line 1860
  rc = crypto_blkcipher_decrypt(& desc, (struct scatterlist *)(& dst_sg), (struct scatterlist *)(& src_sg),
                                auth_tok->session_key.encrypted_key_size);
#line 1862
  ldv_mutex_unlock_202(tfm_mutex);
#line 1863
  tmp___2 = __builtin_expect(rc != 0, 0L);
#line 1863
  if (tmp___2 != 0L) {
#line 1864
    printk("\vError decrypting; rc = [%d]\n", rc);
#line 1865
    goto out;
  } else {

  }
#line 1867
  auth_tok->session_key.flags = auth_tok->session_key.flags | 4U;
#line 1868
  __len = (size_t )auth_tok->session_key.decrypted_key_size;
#line 1868
  __ret = __builtin_memcpy((void *)(& crypt_stat->key), (void const   *)(& auth_tok->session_key.decrypted_key),
                           __len);
#line 1870
  crypt_stat->flags = crypt_stat->flags | 64U;
#line 1871
  tmp___3 = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 1871
  if (tmp___3 != 0L) {
#line 1872
    __ecryptfs_printk("\017%s: FEK of size [%zd]:\n", "decrypt_passphrase_encrypted_session_key",
                      crypt_stat->key_size);
#line 1874
    ecryptfs_dump_hex((char *)(& crypt_stat->key), (int )crypt_stat->key_size);
  } else {

  }
  out: ;
#line 1878
  return (rc);
}
}
#line 1894 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat , unsigned char *src ,
                              struct dentry *ecryptfs_dentry ) 
{ 
  size_t i ;
  size_t found_auth_tok ;
  size_t next_packet_is_auth_tok_packet ;
  struct list_head auth_tok_list ;
  struct ecryptfs_auth_tok *matching_auth_tok ;
  struct ecryptfs_auth_tok *candidate_auth_tok ;
  char *candidate_auth_tok_sig ;
  size_t packet_size ;
  struct ecryptfs_auth_tok *new_auth_tok ;
  unsigned char sig_tmp_space[8U] ;
  struct ecryptfs_auth_tok_list_item *auth_tok_list_item ;
  size_t tag_11_contents_size ;
  size_t tag_11_packet_size ;
  struct key *auth_tok_key ;
  int rc ;
  size_t max_packet_size ;
  int tmp ;
  struct list_head  const  *__mptr ;
  long tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;

  {
#line 1898
  i = 0UL;
#line 1911
  auth_tok_key = 0;
#line 1912
  rc = 0;
#line 1914
  INIT_LIST_HEAD(& auth_tok_list);
#line 1917
  next_packet_is_auth_tok_packet = 1UL;
#line 1918
  goto ldv_32564;
  ldv_32563: 
#line 1919
  max_packet_size = 4088UL - i;
#line 1921
  switch ((int )*(src + i)) {
  case 140: 
#line 1923
  rc = parse_tag_3_packet(crypt_stat, src + i, & auth_tok_list, & new_auth_tok, & packet_size,
                          max_packet_size);
#line 1927
  if (rc != 0) {
#line 1928
    __ecryptfs_printk("\v%s: Error parsing tag 3 packet\n", "ecryptfs_parse_packet_set");
#line 1930
    rc = -5;
#line 1931
    goto out_wipe_list;
  } else {

  }
#line 1933
  i = i + packet_size;
#line 1934
  rc = parse_tag_11_packet(src + i, (unsigned char *)(& sig_tmp_space), 8UL, & tag_11_contents_size,
                           & tag_11_packet_size, max_packet_size);
#line 1940
  if (rc != 0) {
#line 1941
    __ecryptfs_printk("\v%s: No valid (ecryptfs-specific) literal packet containing authentication token signature found after tag 3 packet\n",
                      "ecryptfs_parse_packet_set");
#line 1947
    rc = -5;
#line 1948
    goto out_wipe_list;
  } else {

  }
#line 1950
  i = i + tag_11_packet_size;
#line 1951
  if (tag_11_contents_size != 8UL) {
#line 1952
    __ecryptfs_printk("\v%s: Expected signature of size [%d]; read size [%zd]\n",
                      "ecryptfs_parse_packet_set", 8, tag_11_contents_size);
#line 1957
    rc = -5;
#line 1958
    goto out_wipe_list;
  } else {

  }
#line 1960
  ecryptfs_to_hex((char *)(& new_auth_tok->token.password.signature), (char *)(& sig_tmp_space),
                  tag_11_contents_size);
#line 1962
  new_auth_tok->token.password.signature[16] = 0U;
#line 1964
  crypt_stat->flags = crypt_stat->flags | 4U;
#line 1965
  goto ldv_32559;
  case 1: 
#line 1967
  rc = parse_tag_1_packet(crypt_stat, src + i, & auth_tok_list, & new_auth_tok, & packet_size,
                          max_packet_size);
#line 1971
  if (rc != 0) {
#line 1972
    __ecryptfs_printk("\v%s: Error parsing tag 1 packet\n", "ecryptfs_parse_packet_set");
#line 1974
    rc = -5;
#line 1975
    goto out_wipe_list;
  } else {

  }
#line 1977
  i = i + packet_size;
#line 1978
  crypt_stat->flags = crypt_stat->flags | 4U;
#line 1979
  goto ldv_32559;
  case 237: 
#line 1981
  __ecryptfs_printk("\f%s: Invalid packet set (Tag 11 not allowed by itself)\n", "ecryptfs_parse_packet_set");
#line 1983
  rc = -5;
#line 1984
  goto out_wipe_list;
  default: 
#line 1987
  __ecryptfs_printk("\017%s: No packet at offset [%zd] of the file header; hex value of character is [0x%.2x]\n",
                    "ecryptfs_parse_packet_set", i, (int )*(src + i));
#line 1990
  next_packet_is_auth_tok_packet = 0UL;
  }
  ldv_32559: ;
  ldv_32564: ;
#line 1918
  if (next_packet_is_auth_tok_packet != 0UL) {
#line 1919
    goto ldv_32563;
  } else {

  }
#line 1993
  tmp = list_empty((struct list_head  const  *)(& auth_tok_list));
#line 1993
  if (tmp != 0) {
#line 1994
    printk("\vThe lower file appears to be a non-encrypted eCryptfs file; this is not supported in this version of the eCryptfs kernel module\n");
#line 1997
    rc = -22;
#line 1998
    goto out;
  } else {

  }
  find_next_matching_auth_tok: 
#line 2007
  found_auth_tok = 0UL;
#line 2008
  __mptr = (struct list_head  const  *)auth_tok_list.next;
#line 2008
  auth_tok_list_item = (struct ecryptfs_auth_tok_list_item *)__mptr + 0xffffffffffffffc0UL;
#line 2008
  goto ldv_32574;
  ldv_32573: 
#line 2009
  candidate_auth_tok = & auth_tok_list_item->auth_tok;
#line 2010
  tmp___0 = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 2010
  if (tmp___0 != 0L) {
#line 2011
    __ecryptfs_printk("\017%s: Considering cadidate auth tok:\n", "ecryptfs_parse_packet_set");
#line 2013
    ecryptfs_dump_auth_tok(candidate_auth_tok);
  } else {

  }
#line 2015
  rc = ecryptfs_get_auth_tok_sig(& candidate_auth_tok_sig, candidate_auth_tok);
#line 2017
  if (rc != 0) {
#line 2018
    printk("\vUnrecognized candidate auth tok type: [%d]\n", (int )candidate_auth_tok->token_type);
#line 2021
    rc = -22;
#line 2022
    goto out_wipe_list;
  } else {

  }
#line 2024
  rc = ecryptfs_find_auth_tok_for_sig(& auth_tok_key, & matching_auth_tok, crypt_stat->mount_crypt_stat,
                                      candidate_auth_tok_sig);
#line 2028
  if (rc == 0) {
#line 2029
    found_auth_tok = 1UL;
#line 2030
    goto found_matching_auth_tok;
  } else {

  }
#line 2008
  __mptr___0 = (struct list_head  const  *)auth_tok_list_item->list.next;
#line 2008
  auth_tok_list_item = (struct ecryptfs_auth_tok_list_item *)__mptr___0 + 0xffffffffffffffc0UL;
  ldv_32574: ;
#line 2008
  if ((unsigned long )(& auth_tok_list_item->list) != (unsigned long )(& auth_tok_list)) {
#line 2009
    goto ldv_32573;
  } else {

  }

#line 2033
  if (found_auth_tok == 0UL) {
#line 2034
    __ecryptfs_printk("\v%s: Could not find a usable authentication token\n", "ecryptfs_parse_packet_set");
#line 2036
    rc = -5;
#line 2037
    goto out_wipe_list;
  } else {

  }
  found_matching_auth_tok: ;
#line 2040
  if ((unsigned int )candidate_auth_tok->token_type == 1U) {
#line 2041
    __len = 44UL;
#line 2041
    if (__len > 63UL) {
#line 2041
      __ret = __memcpy((void *)(& candidate_auth_tok->token.private_key), (void const   *)(& matching_auth_tok->token.private_key),
                       __len);
    } else {
#line 2041
      __ret = __builtin_memcpy((void *)(& candidate_auth_tok->token.private_key),
                               (void const   *)(& matching_auth_tok->token.private_key),
                               __len);
    }
#line 2044
    up_write(& auth_tok_key->sem);
#line 2045
    key_put(auth_tok_key);
#line 2046
    rc = decrypt_pki_encrypted_session_key(candidate_auth_tok, crypt_stat);
  } else
#line 2048
  if ((unsigned int )candidate_auth_tok->token_type == 0U) {
#line 2049
    __len___0 = 112UL;
#line 2049
    if (__len___0 > 63UL) {
#line 2049
      __ret___0 = __memcpy((void *)(& candidate_auth_tok->token.password), (void const   *)(& matching_auth_tok->token.password),
                           __len___0);
    } else {
#line 2049
      __ret___0 = __builtin_memcpy((void *)(& candidate_auth_tok->token.password),
                                   (void const   *)(& matching_auth_tok->token.password),
                                   __len___0);
    }
#line 2052
    up_write(& auth_tok_key->sem);
#line 2053
    key_put(auth_tok_key);
#line 2054
    rc = decrypt_passphrase_encrypted_session_key(candidate_auth_tok, crypt_stat);
  } else {
#line 2057
    up_write(& auth_tok_key->sem);
#line 2058
    key_put(auth_tok_key);
#line 2059
    rc = -22;
  }
#line 2061
  if (rc != 0) {
#line 2064
    __ecryptfs_printk("\f%s: Error decrypting the session key for authentication token with sig [%.*s]; rc = [%d]. Removing auth tok candidate from the list and searching for the next match.\n",
                      "ecryptfs_parse_packet_set", 16, candidate_auth_tok_sig, rc);
#line 2070
    __mptr___1 = (struct list_head  const  *)auth_tok_list.next;
#line 2070
    auth_tok_list_item = (struct ecryptfs_auth_tok_list_item *)__mptr___1 + 0xffffffffffffffc0UL;
#line 2070
    __mptr___2 = (struct list_head  const  *)auth_tok_list_item->list.next;
#line 2070
    auth_tok_list_item_tmp = (struct ecryptfs_auth_tok_list_item *)__mptr___2 + 0xffffffffffffffc0UL;
#line 2070
    goto ldv_32590;
    ldv_32589: ;
#line 2073
    if ((unsigned long )(& auth_tok_list_item->auth_tok) == (unsigned long )candidate_auth_tok) {
#line 2075
      list_del(& auth_tok_list_item->list);
#line 2076
      kmem_cache_free(ecryptfs_auth_tok_list_item_cache, (void *)auth_tok_list_item);
#line 2079
      goto find_next_matching_auth_tok;
    } else {

    }
#line 2070
    auth_tok_list_item = auth_tok_list_item_tmp;
#line 2070
    __mptr___3 = (struct list_head  const  *)auth_tok_list_item_tmp->list.next;
#line 2070
    auth_tok_list_item_tmp = (struct ecryptfs_auth_tok_list_item *)__mptr___3 + 0xffffffffffffffc0UL;
    ldv_32590: ;
#line 2070
    if ((unsigned long )(& auth_tok_list_item->list) != (unsigned long )(& auth_tok_list)) {
#line 2071
      goto ldv_32589;
    } else {

    }
#line 2082
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"),
                         "i" (2082), "i" (12UL));
    ldv_32592: ;
#line 2082
    goto ldv_32592;
  } else {

  }
#line 2084
  rc = ecryptfs_compute_root_iv(crypt_stat);
#line 2085
  if (rc != 0) {
#line 2086
    __ecryptfs_printk("\v%s: Error computing the root IV\n", "ecryptfs_parse_packet_set");
#line 2088
    goto out_wipe_list;
  } else {

  }
#line 2090
  rc = ecryptfs_init_crypt_ctx(crypt_stat);
#line 2091
  if (rc != 0) {
#line 2092
    __ecryptfs_printk("\v%s: Error initializing crypto context for cipher [%s]; rc = [%d]\n",
                      "ecryptfs_parse_packet_set", (unsigned char *)(& crypt_stat->cipher),
                      rc);
  } else {

  }
  out_wipe_list: 
#line 2097
  wipe_auth_tok_list(& auth_tok_list);
  out: ;
#line 2099
  return (rc);
}
}
#line 2103 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int pki_encrypt_session_key(struct key *auth_tok_key , struct ecryptfs_auth_tok *auth_tok ,
                                   struct ecryptfs_crypt_stat *crypt_stat , struct ecryptfs_key_record *key_rec ) 
{ 
  struct ecryptfs_msg_ctx *msg_ctx ;
  char *payload ;
  size_t payload_len ;
  struct ecryptfs_message *msg ;
  int rc ;
  u8 tmp ;

  {
#line 2108
  msg_ctx = 0;
#line 2109
  payload = 0;
#line 2110
  payload_len = 0UL;
#line 2114
  tmp = ecryptfs_code_for_cipher_string((char *)(& crypt_stat->cipher), crypt_stat->key_size);
#line 2114
  rc = write_tag_66_packet((char *)(& auth_tok->token.private_key.signature), (int )tmp,
                           crypt_stat, & payload, & payload_len);
#line 2119
  up_write(& auth_tok_key->sem);
#line 2120
  key_put(auth_tok_key);
#line 2121
  if (rc != 0) {
#line 2122
    __ecryptfs_printk("\v%s: Error generating tag 66 packet\n", "pki_encrypt_session_key");
#line 2123
    goto out;
  } else {

  }
#line 2125
  rc = ecryptfs_send_message(payload, (int )payload_len, & msg_ctx);
#line 2126
  if (rc != 0) {
#line 2127
    __ecryptfs_printk("\v%s: Error sending message to ecryptfsd\n", "pki_encrypt_session_key");
#line 2129
    goto out;
  } else {

  }
#line 2131
  rc = ecryptfs_wait_for_response(msg_ctx, & msg);
#line 2132
  if (rc != 0) {
#line 2133
    __ecryptfs_printk("\v%s: Failed to receive tag 67 packet from the user space daemon\n",
                      "pki_encrypt_session_key");
#line 2135
    rc = -5;
#line 2136
    goto out;
  } else {

  }
#line 2138
  rc = parse_tag_67_packet(key_rec, msg);
#line 2139
  if (rc != 0) {
#line 2140
    __ecryptfs_printk("\v%s: Error parsing tag 67 packet\n", "pki_encrypt_session_key");
  } else {

  }
#line 2141
  kfree((void const   *)msg);
  out: 
#line 2143
  kfree((void const   *)payload);
#line 2144
  return (rc);
}
}
#line 2161 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int write_tag_1_packet(char *dest , size_t *remaining_bytes , struct key *auth_tok_key ,
                              struct ecryptfs_auth_tok *auth_tok , struct ecryptfs_crypt_stat *crypt_stat ,
                              struct ecryptfs_key_record *key_rec , size_t *packet_size ) 
{ 
  size_t i ;
  size_t encrypted_session_key_valid ;
  size_t packet_size_length ;
  size_t max_packet_size ;
  int rc ;
  size_t __len ;
  void *__ret ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t tmp___1 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 2167
  encrypted_session_key_valid = 0UL;
#line 2170
  rc = 0;
#line 2172
  *packet_size = 0UL;
#line 2173
  ecryptfs_from_hex((char *)(& key_rec->sig), (char *)(& auth_tok->token.private_key.signature),
                    8);
#line 2175
  encrypted_session_key_valid = 0UL;
#line 2176
  i = 0UL;
#line 2176
  goto ldv_32621;
  ldv_32620: 
#line 2177
  encrypted_session_key_valid = (size_t )auth_tok->session_key.encrypted_key[i] | encrypted_session_key_valid;
#line 2176
  i = i + 1UL;
  ldv_32621: ;
#line 2176
  if (crypt_stat->key_size > i) {
#line 2177
    goto ldv_32620;
  } else {

  }

#line 2179
  if (encrypted_session_key_valid != 0UL) {
#line 2180
    __len = (size_t )auth_tok->session_key.encrypted_key_size;
#line 2180
    __ret = __builtin_memcpy((void *)(& key_rec->enc_key), (void const   *)(& auth_tok->session_key.encrypted_key),
                             __len);
#line 2183
    up_write(& auth_tok_key->sem);
#line 2184
    key_put(auth_tok_key);
#line 2185
    goto encrypted_session_key_set;
  } else {

  }
#line 2187
  if (auth_tok->session_key.encrypted_key_size == 0U) {
#line 2188
    auth_tok->session_key.encrypted_key_size = auth_tok->token.private_key.key_size;
  } else {

  }
#line 2190
  rc = pki_encrypt_session_key(auth_tok_key, auth_tok, crypt_stat, key_rec);
#line 2192
  if (rc != 0) {
#line 2193
    printk("\vFailed to encrypt session key via a key module; rc = [%d]\n", rc);
#line 2195
    goto out;
  } else {

  }
#line 2197
  if (ecryptfs_verbosity > 0) {
#line 2198
    __ecryptfs_printk("\017%s: Encrypted key:\n", "write_tag_1_packet");
#line 2199
    ecryptfs_dump_hex((char *)(& key_rec->enc_key), (int )key_rec->enc_key_size);
  } else {

  }
  encrypted_session_key_set: 
#line 2204
  max_packet_size = key_rec->enc_key_size + 14UL;
#line 2210
  if (*remaining_bytes < max_packet_size) {
#line 2211
    printk("\vPacket length larger than maximum allowable; need up to [%td] bytes, but there are only [%td] available\n",
           max_packet_size, *remaining_bytes);
#line 2214
    rc = -22;
#line 2215
    goto out;
  } else {

  }
#line 2217
  tmp = *packet_size;
#line 2217
  *packet_size = *packet_size + 1UL;
#line 2217
  *(dest + tmp) = 1;
#line 2218
  rc = ecryptfs_write_packet_length(dest + *packet_size, max_packet_size - 4UL, & packet_size_length);
#line 2221
  if (rc != 0) {
#line 2222
    __ecryptfs_printk("\v%s: Error generating tag 1 packet header; cannot generate packet length\n",
                      "write_tag_1_packet");
#line 2224
    goto out;
  } else {

  }
#line 2226
  *packet_size = *packet_size + packet_size_length;
#line 2227
  tmp___0 = *packet_size;
#line 2227
  *packet_size = *packet_size + 1UL;
#line 2227
  *(dest + tmp___0) = 3;
#line 2228
  __len___0 = 8UL;
#line 2228
  if (__len___0 > 63UL) {
#line 2228
    __ret___0 = __memcpy((void *)(dest + *packet_size), (void const   *)(& key_rec->sig),
                         __len___0);
  } else {
#line 2228
    __ret___0 = __builtin_memcpy((void *)(dest + *packet_size), (void const   *)(& key_rec->sig),
                                 __len___0);
  }
#line 2229
  *packet_size = *packet_size + 8UL;
#line 2230
  tmp___1 = *packet_size;
#line 2230
  *packet_size = *packet_size + 1UL;
#line 2230
  *(dest + tmp___1) = 1;
#line 2231
  __len___1 = key_rec->enc_key_size;
#line 2231
  __ret___1 = __builtin_memcpy((void *)(dest + *packet_size), (void const   *)(& key_rec->enc_key),
                               __len___1);
#line 2233
  *packet_size = *packet_size + key_rec->enc_key_size;
  out: ;
#line 2235
  if (rc != 0) {
#line 2236
    *packet_size = 0UL;
  } else {
#line 2238
    *remaining_bytes = *remaining_bytes - *packet_size;
  }
#line 2239
  return (rc);
}
}
#line 2253 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int write_tag_11_packet(char *dest , size_t *remaining_bytes , char *contents ,
                               size_t contents_length , size_t *packet_length ) 
{ 
  size_t packet_size_length ;
  size_t max_packet_size ;
  int rc ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 2258
  rc = 0;
#line 2260
  *packet_length = 0UL;
#line 2263
  max_packet_size = contents_length + 18UL;
#line 2270
  if (*remaining_bytes < max_packet_size) {
#line 2271
    printk("\vPacket length larger than maximum allowable; need up to [%td] bytes, but there are only [%td] available\n",
           max_packet_size, *remaining_bytes);
#line 2274
    rc = -22;
#line 2275
    goto out;
  } else {

  }
#line 2277
  tmp = *packet_length;
#line 2277
  *packet_length = *packet_length + 1UL;
#line 2277
  *(dest + tmp) = -19;
#line 2278
  rc = ecryptfs_write_packet_length(dest + *packet_length, max_packet_size - 4UL,
                                    & packet_size_length);
#line 2281
  if (rc != 0) {
#line 2282
    printk("\vError generating tag 11 packet header; cannot generate packet length. rc = [%d]\n",
           rc);
#line 2284
    goto out;
  } else {

  }
#line 2286
  *packet_length = *packet_length + packet_size_length;
#line 2287
  tmp___0 = *packet_length;
#line 2287
  *packet_length = *packet_length + 1UL;
#line 2287
  *(dest + tmp___0) = 98;
#line 2288
  tmp___1 = *packet_length;
#line 2288
  *packet_length = *packet_length + 1UL;
#line 2288
  *(dest + tmp___1) = 8;
#line 2289
  __len = 8UL;
#line 2289
  if (__len > 63UL) {
#line 2289
    __ret = __memcpy((void *)(dest + *packet_length), (void const   *)"_CONSOLE",
                     __len);
  } else {
#line 2289
    __ret = __builtin_memcpy((void *)(dest + *packet_length), (void const   *)"_CONSOLE",
                             __len);
  }
#line 2290
  *packet_length = *packet_length + 8UL;
#line 2291
  memset((void *)(dest + *packet_length), 0, 4UL);
#line 2292
  *packet_length = *packet_length + 4UL;
#line 2293
  __len___0 = contents_length;
#line 2293
  __ret___0 = __builtin_memcpy((void *)(dest + *packet_length), (void const   *)contents,
                               __len___0);
#line 2294
  *packet_length = *packet_length + contents_length;
  out: ;
#line 2296
  if (rc != 0) {
#line 2297
    *packet_length = 0UL;
  } else {
#line 2299
    *remaining_bytes = *remaining_bytes - *packet_length;
  }
#line 2300
  return (rc);
}
}
#line 2316 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
static int write_tag_3_packet(char *dest , size_t *remaining_bytes , struct ecryptfs_auth_tok *auth_tok ,
                              struct ecryptfs_crypt_stat *crypt_stat , struct ecryptfs_key_record *key_rec ,
                              size_t *packet_size ) 
{ 
  size_t i ;
  size_t encrypted_session_key_valid ;
  char session_key_encryption_key[64U] ;
  struct scatterlist dst_sg[2U] ;
  struct scatterlist src_sg[2U] ;
  struct mutex *tfm_mutex ;
  u8 cipher_code ;
  size_t packet_size_length ;
  size_t max_packet_size ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct blkcipher_desc desc ;
  int rc ;
  long tmp ;
  struct blkcipher_alg *alg ;
  struct blkcipher_alg *tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  long tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t tmp___8 ;
  size_t __len___2 ;
  void *__ret___2 ;

  {
#line 2322
  encrypted_session_key_valid = 0UL;
#line 2326
  tfm_mutex = 0;
#line 2330
  mount_crypt_stat = crypt_stat->mount_crypt_stat;
#line 2332
  desc.tfm = 0;
#line 2332
  desc.info = 0;
#line 2332
  desc.flags = 512U;
#line 2336
  rc = 0;
#line 2338
  *packet_size = 0UL;
#line 2339
  ecryptfs_from_hex((char *)(& key_rec->sig), (char *)(& auth_tok->token.password.signature),
                    8);
#line 2341
  rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(& desc.tfm, & tfm_mutex, (char *)(& crypt_stat->cipher));
#line 2343
  tmp = __builtin_expect(rc != 0, 0L);
#line 2343
  if (tmp != 0L) {
#line 2344
    printk("\vInternal error whilst attempting to get tfm and mutex for cipher name [%s]; rc = [%d]\n",
           (unsigned char *)(& crypt_stat->cipher), rc);
#line 2347
    goto out;
  } else {

  }
#line 2349
  if (mount_crypt_stat->global_default_cipher_key_size == 0UL) {
#line 2350
    tmp___0 = crypto_blkcipher_alg(desc.tfm);
#line 2350
    alg = tmp___0;
#line 2352
    printk("\fNo key size specified at mount; defaulting to [%d]\n", alg->max_keysize);
#line 2354
    mount_crypt_stat->global_default_cipher_key_size = (size_t )alg->max_keysize;
  } else {

  }
#line 2357
  if (crypt_stat->key_size == 0UL) {
#line 2358
    crypt_stat->key_size = mount_crypt_stat->global_default_cipher_key_size;
  } else {

  }
#line 2360
  if (auth_tok->session_key.encrypted_key_size == 0U) {
#line 2361
    auth_tok->session_key.encrypted_key_size = (u32 )crypt_stat->key_size;
  } else {

  }
#line 2363
  if (crypt_stat->key_size == 24UL) {
#line 2363
    tmp___1 = strcmp("aes", (char const   *)(& crypt_stat->cipher));
#line 2363
    if (tmp___1 == 0) {
#line 2365
      memset((void *)(& crypt_stat->key) + 24U, 0, 8UL);
#line 2366
      auth_tok->session_key.encrypted_key_size = 32U;
    } else {
#line 2368
      auth_tok->session_key.encrypted_key_size = (u32 )crypt_stat->key_size;
    }
  } else {
#line 2368
    auth_tok->session_key.encrypted_key_size = (u32 )crypt_stat->key_size;
  }
#line 2369
  key_rec->enc_key_size = (size_t )auth_tok->session_key.encrypted_key_size;
#line 2371
  encrypted_session_key_valid = 0UL;
#line 2372
  i = 0UL;
#line 2372
  goto ldv_32675;
  ldv_32674: 
#line 2373
  encrypted_session_key_valid = (size_t )auth_tok->session_key.encrypted_key[i] | encrypted_session_key_valid;
#line 2372
  i = i + 1UL;
  ldv_32675: ;
#line 2372
  if ((size_t )auth_tok->session_key.encrypted_key_size > i) {
#line 2373
    goto ldv_32674;
  } else {

  }

#line 2375
  if (encrypted_session_key_valid != 0UL) {
#line 2376
    __ecryptfs_printk("\017%s: encrypted_session_key_valid != 0; using auth_tok->session_key.encrypted_key, where key_rec->enc_key_size = [%zd]\n",
                      "write_tag_3_packet", key_rec->enc_key_size);
#line 2380
    __len = key_rec->enc_key_size;
#line 2380
    __ret = __builtin_memcpy((void *)(& key_rec->enc_key), (void const   *)(& auth_tok->session_key.encrypted_key),
                             __len);
#line 2383
    goto encrypted_session_key_set;
  } else {

  }
#line 2385
  if ((auth_tok->token.password.flags & 2U) != 0U) {
#line 2387
    __ecryptfs_printk("\017%s: Using previously generated session key encryption key of size [%d]\n",
                      "write_tag_3_packet", auth_tok->token.password.session_key_encryption_key_bytes);
#line 2391
    __len___0 = crypt_stat->key_size;
#line 2391
    __ret___0 = __builtin_memcpy((void *)(& session_key_encryption_key), (void const   *)(& auth_tok->token.password.session_key_encryption_key),
                                 __len___0);
#line 2394
    __ecryptfs_printk("\017%s: Cached session key encryption key:\n", "write_tag_3_packet");
#line 2396
    if (ecryptfs_verbosity > 0) {
#line 2397
      ecryptfs_dump_hex((char *)(& session_key_encryption_key), 16);
    } else {

    }
  } else {

  }
#line 2399
  tmp___2 = __builtin_expect(ecryptfs_verbosity > 0, 0L);
#line 2399
  if (tmp___2 != 0L) {
#line 2400
    __ecryptfs_printk("\017%s: Session key encryption key:\n", "write_tag_3_packet");
#line 2401
    ecryptfs_dump_hex((char *)(& session_key_encryption_key), 16);
  } else {

  }
#line 2403
  rc = virt_to_scatterlist((void const   *)(& crypt_stat->key), (int )key_rec->enc_key_size,
                           (struct scatterlist *)(& src_sg), 2);
#line 2405
  if (rc <= 0 || rc > 2) {
#line 2406
    __ecryptfs_printk("\v%s: Error generating scatterlist for crypt_stat session key; expected rc = 1; got rc = [%d]. key_rec->enc_key_size = [%zd]\n",
                      "write_tag_3_packet", rc, key_rec->enc_key_size);
#line 2410
    rc = -12;
#line 2411
    goto out;
  } else {

  }
#line 2413
  rc = virt_to_scatterlist((void const   *)(& key_rec->enc_key), (int )key_rec->enc_key_size,
                           (struct scatterlist *)(& dst_sg), 2);
#line 2415
  if (rc <= 0 || rc > 2) {
#line 2416
    __ecryptfs_printk("\v%s: Error generating scatterlist for crypt_stat encrypted session key; expected rc = 1; got rc = [%d]. key_rec->enc_key_size = [%zd]\n",
                      "write_tag_3_packet", rc, key_rec->enc_key_size);
#line 2421
    rc = -12;
#line 2422
    goto out;
  } else {

  }
#line 2424
  ldv_mutex_lock_203(tfm_mutex);
#line 2425
  rc = crypto_blkcipher_setkey(desc.tfm, (u8 const   *)(& session_key_encryption_key),
                               (unsigned int )crypt_stat->key_size);
#line 2427
  if (rc < 0) {
#line 2428
    ldv_mutex_unlock_204(tfm_mutex);
#line 2429
    __ecryptfs_printk("\v%s: Error setting key for crypto context; rc = [%d]\n", "write_tag_3_packet",
                      rc);
#line 2431
    goto out;
  } else {

  }
#line 2433
  rc = 0;
#line 2434
  __ecryptfs_printk("\017%s: Encrypting [%zd] bytes of the key\n", "write_tag_3_packet",
                    crypt_stat->key_size);
#line 2436
  rc = crypto_blkcipher_encrypt(& desc, (struct scatterlist *)(& dst_sg), (struct scatterlist *)(& src_sg),
                                (unsigned int )key_rec->enc_key_size);
#line 2438
  ldv_mutex_unlock_205(tfm_mutex);
#line 2439
  if (rc != 0) {
#line 2440
    printk("\vError encrypting; rc = [%d]\n", rc);
#line 2441
    goto out;
  } else {

  }
#line 2443
  __ecryptfs_printk("\017%s: This should be the encrypted key:\n", "write_tag_3_packet");
#line 2444
  if (ecryptfs_verbosity > 0) {
#line 2445
    __ecryptfs_printk("\017%s: EFEK of size [%zd]:\n", "write_tag_3_packet", key_rec->enc_key_size);
#line 2447
    ecryptfs_dump_hex((char *)(& key_rec->enc_key), (int )key_rec->enc_key_size);
  } else {

  }
  encrypted_session_key_set: 
#line 2453
  max_packet_size = key_rec->enc_key_size + 17UL;
#line 2462
  if (*remaining_bytes < max_packet_size) {
#line 2463
    printk("\vPacket too large; need up to [%td] bytes, but there are only [%td] available\n",
           max_packet_size, *remaining_bytes);
#line 2466
    rc = -22;
#line 2467
    goto out;
  } else {

  }
#line 2469
  tmp___3 = *packet_size;
#line 2469
  *packet_size = *packet_size + 1UL;
#line 2469
  *(dest + tmp___3) = -116;
#line 2472
  rc = ecryptfs_write_packet_length(dest + *packet_size, max_packet_size - 4UL, & packet_size_length);
#line 2475
  if (rc != 0) {
#line 2476
    printk("\vError generating tag 3 packet header; cannot generate packet length. rc = [%d]\n",
           rc);
#line 2478
    goto out;
  } else {

  }
#line 2480
  *packet_size = *packet_size + packet_size_length;
#line 2481
  tmp___4 = *packet_size;
#line 2481
  *packet_size = *packet_size + 1UL;
#line 2481
  *(dest + tmp___4) = 4;
#line 2484
  cipher_code = ecryptfs_code_for_cipher_string((char *)(& crypt_stat->cipher), crypt_stat->key_size);
#line 2486
  if ((unsigned int )cipher_code == 0U) {
#line 2487
    __ecryptfs_printk("\f%s: Unable to generate code for cipher [%s]\n", "write_tag_3_packet",
                      (unsigned char *)(& crypt_stat->cipher));
#line 2489
    rc = -22;
#line 2490
    goto out;
  } else {

  }
#line 2492
  tmp___5 = *packet_size;
#line 2492
  *packet_size = *packet_size + 1UL;
#line 2492
  *(dest + tmp___5) = (char )cipher_code;
#line 2493
  tmp___6 = *packet_size;
#line 2493
  *packet_size = *packet_size + 1UL;
#line 2493
  *(dest + tmp___6) = 3;
#line 2494
  tmp___7 = *packet_size;
#line 2494
  *packet_size = *packet_size + 1UL;
#line 2494
  *(dest + tmp___7) = 1;
#line 2495
  __len___1 = 8UL;
#line 2495
  if (__len___1 > 63UL) {
#line 2495
    __ret___1 = __memcpy((void *)(dest + *packet_size), (void const   *)(& auth_tok->token.password.salt),
                         __len___1);
  } else {
#line 2495
    __ret___1 = __builtin_memcpy((void *)(dest + *packet_size), (void const   *)(& auth_tok->token.password.salt),
                                 __len___1);
  }
#line 2497
  *packet_size = *packet_size + 8UL;
#line 2498
  tmp___8 = *packet_size;
#line 2498
  *packet_size = *packet_size + 1UL;
#line 2498
  *(dest + tmp___8) = 96;
#line 2499
  __len___2 = key_rec->enc_key_size;
#line 2499
  __ret___2 = __builtin_memcpy((void *)(dest + *packet_size), (void const   *)(& key_rec->enc_key),
                               __len___2);
#line 2501
  *packet_size = *packet_size + key_rec->enc_key_size;
  out: ;
#line 2503
  if (rc != 0) {
#line 2504
    *packet_size = 0UL;
  } else {
#line 2506
    *remaining_bytes = *remaining_bytes - *packet_size;
  }
#line 2507
  return (rc);
}
}
#line 2528 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ecryptfs_generate_key_packet_set(char *dest_base , struct ecryptfs_crypt_stat *crypt_stat ,
                                     struct dentry *ecryptfs_dentry , size_t *len ,
                                     size_t max ) 
{ 
  struct ecryptfs_auth_tok *auth_tok ;
  struct key *auth_tok_key ;
  struct ecryptfs_mount_crypt_stat *mount_crypt_stat ;
  struct ecryptfs_sb_info *tmp ;
  size_t written ;
  struct ecryptfs_key_record *key_rec ;
  struct ecryptfs_key_sig *key_sig ;
  int rc ;
  void *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  long tmp___1 ;

  {
#line 2534
  auth_tok_key = 0;
#line 2535
  tmp = ecryptfs_superblock_to_private(ecryptfs_dentry->d_sb);
#line 2535
  mount_crypt_stat = & tmp->mount_crypt_stat;
#line 2541
  rc = 0;
#line 2543
  *len = 0UL;
#line 2544
  ldv_mutex_lock_206(& crypt_stat->keysig_list_mutex);
#line 2545
  tmp___0 = kmem_cache_alloc(ecryptfs_key_record_cache, 208U);
#line 2545
  key_rec = (struct ecryptfs_key_record *)tmp___0;
#line 2546
  if ((unsigned long )key_rec == (unsigned long )((struct ecryptfs_key_record *)0)) {
#line 2547
    rc = -12;
#line 2548
    goto out;
  } else {

  }
#line 2550
  __mptr = (struct list_head  const  *)crypt_stat->keysig_list.next;
#line 2550
  key_sig = (struct ecryptfs_key_sig *)__mptr;
#line 2550
  goto ldv_32714;
  ldv_32713: 
#line 2552
  memset((void *)key_rec, 0, 536UL);
#line 2553
  rc = ecryptfs_find_global_auth_tok_for_sig(& auth_tok_key, & auth_tok, mount_crypt_stat,
                                             (char *)(& key_sig->keysig));
#line 2557
  if (rc != 0) {
#line 2558
    printk("\fUnable to retrieve auth tok with sig = [%s]\n", (char *)(& key_sig->keysig));
#line 2560
    rc = process_find_global_auth_tok_for_sig_err(rc);
#line 2561
    goto out_free;
  } else {

  }
#line 2563
  if ((unsigned int )auth_tok->token_type == 0U) {
#line 2564
    rc = write_tag_3_packet(dest_base + *len, & max, auth_tok, crypt_stat, key_rec,
                            & written);
#line 2568
    up_write(& auth_tok_key->sem);
#line 2569
    key_put(auth_tok_key);
#line 2570
    if (rc != 0) {
#line 2571
      __ecryptfs_printk("\f%s: Error writing tag 3 packet\n", "ecryptfs_generate_key_packet_set");
#line 2573
      goto out_free;
    } else {

    }
#line 2575
    *len = *len + written;
#line 2577
    rc = write_tag_11_packet(dest_base + *len, & max, (char *)(& key_rec->sig), 8UL,
                             & written);
#line 2580
    if (rc != 0) {
#line 2581
      __ecryptfs_printk("\v%s: Error writing auth tok signature packet\n", "ecryptfs_generate_key_packet_set");
#line 2583
      goto out_free;
    } else {

    }
#line 2585
    *len = *len + written;
  } else
#line 2586
  if ((unsigned int )auth_tok->token_type == 1U) {
#line 2587
    rc = write_tag_1_packet(dest_base + *len, & max, auth_tok_key, auth_tok, crypt_stat,
                            key_rec, & written);
#line 2590
    if (rc != 0) {
#line 2591
      __ecryptfs_printk("\f%s: Error writing tag 1 packet\n", "ecryptfs_generate_key_packet_set");
#line 2593
      goto out_free;
    } else {

    }
#line 2595
    *len = *len + written;
  } else {
#line 2597
    up_write(& auth_tok_key->sem);
#line 2598
    key_put(auth_tok_key);
#line 2599
    __ecryptfs_printk("\f%s: Unsupported authentication token type\n", "ecryptfs_generate_key_packet_set");
#line 2601
    rc = -22;
#line 2602
    goto out_free;
  }
#line 2550
  __mptr___0 = (struct list_head  const  *)key_sig->crypt_stat_list.next;
#line 2550
  key_sig = (struct ecryptfs_key_sig *)__mptr___0;
  ldv_32714: ;
#line 2550
  if ((unsigned long )(& key_sig->crypt_stat_list) != (unsigned long )(& crypt_stat->keysig_list)) {
#line 2551
    goto ldv_32713;
  } else {

  }
#line 2605
  tmp___1 = __builtin_expect(max != 0UL, 1L);
#line 2605
  if (tmp___1 != 0L) {
#line 2606
    *(dest_base + *len) = 0;
  } else {
#line 2608
    __ecryptfs_printk("\v%s: Error writing boundary byte\n", "ecryptfs_generate_key_packet_set");
#line 2609
    rc = -5;
  }
  out_free: 
#line 2612
  kmem_cache_free(ecryptfs_key_record_cache, (void *)key_rec);
  out: ;
#line 2614
  if (rc != 0) {
#line 2615
    *len = 0UL;
  } else {

  }
#line 2616
  ldv_mutex_unlock_207(& crypt_stat->keysig_list_mutex);
#line 2617
  return (rc);
}
}
#line 2622 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ecryptfs_add_keysig(struct ecryptfs_crypt_stat *crypt_stat , char *sig ) 
{ 
  struct ecryptfs_key_sig *new_key_sig ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 2626
  tmp = kmem_cache_alloc(ecryptfs_key_sig_cache, 208U);
#line 2626
  new_key_sig = (struct ecryptfs_key_sig *)tmp;
#line 2627
  if ((unsigned long )new_key_sig == (unsigned long )((struct ecryptfs_key_sig *)0)) {
#line 2628
    printk("\vError allocating from ecryptfs_key_sig_cache\n");
#line 2630
    return (-12);
  } else {

  }
#line 2632
  __len = 16UL;
#line 2632
  if (__len > 63UL) {
#line 2632
    __ret = __memcpy((void *)(& new_key_sig->keysig), (void const   *)sig, __len);
  } else {
#line 2632
    __ret = __builtin_memcpy((void *)(& new_key_sig->keysig), (void const   *)sig,
                             __len);
  }
#line 2633
  new_key_sig->keysig[16] = 0;
#line 2635
  list_add(& new_key_sig->crypt_stat_list, & crypt_stat->keysig_list);
#line 2637
  return (0);
}
}
#line 2643 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ecryptfs_add_global_auth_tok(struct ecryptfs_mount_crypt_stat *mount_crypt_stat ,
                                 char *sig , u32 global_auth_tok_flags ) 
{ 
  struct ecryptfs_global_auth_tok *new_auth_tok ;
  int rc ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 2647
  rc = 0;
#line 2649
  tmp = kmem_cache_zalloc(ecryptfs_global_auth_tok_cache, 208U);
#line 2649
  new_auth_tok = (struct ecryptfs_global_auth_tok *)tmp;
#line 2651
  if ((unsigned long )new_auth_tok == (unsigned long )((struct ecryptfs_global_auth_tok *)0)) {
#line 2652
    rc = -12;
#line 2653
    printk("\vError allocating from ecryptfs_global_auth_tok_cache\n");
#line 2655
    goto out;
  } else {

  }
#line 2657
  __len = 16UL;
#line 2657
  if (__len > 63UL) {
#line 2657
    __ret = __memcpy((void *)(& new_auth_tok->sig), (void const   *)sig, __len);
  } else {
#line 2657
    __ret = __builtin_memcpy((void *)(& new_auth_tok->sig), (void const   *)sig, __len);
  }
#line 2658
  new_auth_tok->flags = global_auth_tok_flags;
#line 2659
  new_auth_tok->sig[16] = 0U;
#line 2660
  ldv_mutex_lock_208(& mount_crypt_stat->global_auth_tok_list_mutex);
#line 2661
  list_add(& new_auth_tok->mount_crypt_stat_list, & mount_crypt_stat->global_auth_tok_list);
#line 2663
  ldv_mutex_unlock_209(& mount_crypt_stat->global_auth_tok_list_mutex);
  out: ;
#line 2665
  return (rc);
}
}
#line 2706 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_main8_sequence_infinite_withcheck_stateful(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2718
  LDV_IN_INTERRUPT = 1;
#line 2727
  ldv_initialize();
#line 2729
  goto ldv_32756;
  ldv_32755: 
#line 2732
  tmp = __VERIFIER_nondet_int();
#line 2732
  switch (tmp) {
  default: ;
#line 2734
  goto ldv_32754;
  }
  ldv_32754: ;
  ldv_32756: 
#line 2729
  tmp___0 = __VERIFIER_nondet_int();
#line 2729
  if (tmp___0 != 0) {
#line 2730
    goto ldv_32755;
  } else {

  }


#line 2743
  ldv_check_final_state();
#line 2746
  return;
}
}
#line 2750 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_187(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2755
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 2757
  mutex_lock(ldv_func_arg1);
#line 2758
  return;
}
}
#line 2760 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_188(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2765
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 2767
  mutex_unlock(ldv_func_arg1);
#line 2768
  return;
}
}
#line 2770 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_189(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2775
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 2777
  mutex_lock(ldv_func_arg1);
#line 2778
  return;
}
}
#line 2780 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_190(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2785
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 2787
  mutex_unlock(ldv_func_arg1);
#line 2788
  return;
}
}
#line 2790 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_191(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2795
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 2797
  mutex_lock(ldv_func_arg1);
#line 2798
  return;
}
}
#line 2800 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
int ldv_mutex_trylock_192(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 2805
  tmp = mutex_trylock(ldv_func_arg1);
#line 2805
  ldv_func_res = tmp;
#line 2807
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 2807
  return (tmp___0);
#line 2809
  return (ldv_func_res);
}
}
#line 2812 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_193(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2817
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 2819
  mutex_unlock(ldv_func_arg1);
#line 2820
  return;
}
}
#line 2822 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_194(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2827
  ldv_mutex_lock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 2829
  mutex_lock(ldv_func_arg1);
#line 2830
  return;
}
}
#line 2832 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_195(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2837
  ldv_mutex_unlock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 2839
  mutex_unlock(ldv_func_arg1);
#line 2840
  return;
}
}
#line 2842 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_196(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2847
  ldv_mutex_lock_tfm_mutex(ldv_func_arg1);
#line 2849
  mutex_lock(ldv_func_arg1);
#line 2850
  return;
}
}
#line 2852 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_197(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2857
  ldv_mutex_unlock_tfm_mutex(ldv_func_arg1);
#line 2859
  mutex_unlock(ldv_func_arg1);
#line 2860
  return;
}
}
#line 2862 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_198(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2867
  ldv_mutex_lock_tfm_mutex(ldv_func_arg1);
#line 2869
  mutex_lock(ldv_func_arg1);
#line 2870
  return;
}
}
#line 2872 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_199(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2877
  ldv_mutex_unlock_tfm_mutex(ldv_func_arg1);
#line 2879
  mutex_unlock(ldv_func_arg1);
#line 2880
  return;
}
}
#line 2882 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2887
  ldv_mutex_lock_tfm_mutex(ldv_func_arg1);
#line 2889
  mutex_lock(ldv_func_arg1);
#line 2890
  return;
}
}
#line 2892 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2897
  ldv_mutex_unlock_tfm_mutex(ldv_func_arg1);
#line 2899
  mutex_unlock(ldv_func_arg1);
#line 2900
  return;
}
}
#line 2902 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_202(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2907
  ldv_mutex_unlock_tfm_mutex(ldv_func_arg1);
#line 2909
  mutex_unlock(ldv_func_arg1);
#line 2910
  return;
}
}
#line 2912 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_203(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2917
  ldv_mutex_lock_tfm_mutex(ldv_func_arg1);
#line 2919
  mutex_lock(ldv_func_arg1);
#line 2920
  return;
}
}
#line 2922 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2927
  ldv_mutex_unlock_tfm_mutex(ldv_func_arg1);
#line 2929
  mutex_unlock(ldv_func_arg1);
#line 2930
  return;
}
}
#line 2932 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_205(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2937
  ldv_mutex_unlock_tfm_mutex(ldv_func_arg1);
#line 2939
  mutex_unlock(ldv_func_arg1);
#line 2940
  return;
}
}
#line 2942 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_206(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2947
  ldv_mutex_lock_keysig_list_mutex(ldv_func_arg1);
#line 2949
  mutex_lock(ldv_func_arg1);
#line 2950
  return;
}
}
#line 2952 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_207(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2957
  ldv_mutex_unlock_keysig_list_mutex(ldv_func_arg1);
#line 2959
  mutex_unlock(ldv_func_arg1);
#line 2960
  return;
}
}
#line 2962 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_lock_208(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2967
  ldv_mutex_lock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 2969
  mutex_lock(ldv_func_arg1);
#line 2970
  return;
}
}
#line 2972 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/keystore.c.prepared"
void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 2977
  ldv_mutex_unlock_global_auth_tok_list_mutex(ldv_func_arg1);
#line 2979
  mutex_unlock(ldv_func_arg1);
#line 2980
  return;
}
}
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head * ) ;
#line 153 "include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 


  {
#line 155
  __list_del_entry(list);
#line 156
  list_add(list, head);
#line 157
  return;
}
}
#line 586 "include/linux/list.h"
__inline static void __hlist_del(struct hlist_node *n ) 
{ 
  struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
#line 588
  next = n->next;
#line 589
  pprev = n->pprev;
#line 590
  *pprev = next;
#line 591
  if ((unsigned long )next != (unsigned long )((struct hlist_node *)0)) {
#line 592
    next->pprev = pprev;
  } else {

  }
#line 593
  return;
}
}
#line 595 "include/linux/list.h"
__inline static void hlist_del(struct hlist_node *n ) 
{ 


  {
#line 597
  __hlist_del(n);
#line 598
  n->next = 0xdead000000100100UL;
#line 599
  n->pprev = 0xdead000000200200UL;
#line 600
  return;
}
}
#line 610 "include/linux/list.h"
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h ) 
{ 
  struct hlist_node *first ;

  {
#line 612
  first = h->first;
#line 613
  n->next = first;
#line 614
  if ((unsigned long )first != (unsigned long )((struct hlist_node *)0)) {
#line 615
    first->pprev = & n->next;
  } else {

  }
#line 616
  h->first = n;
#line 617
  n->pprev = & h->first;
#line 618
  return;
}
}
#line 171 "include/linux/mutex.h"
int ldv_mutex_trylock_237(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_234(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_236(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_239(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_240(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_242(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_244(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_245(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_246(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_248(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_251(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_252(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_253(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_254(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_256(struct mutex *ldv_func_arg1 ) ;
#line 232
void ldv_mutex_unlock_257(struct mutex *ldv_func_arg1 ) ;
#line 236
void ldv_mutex_unlock_260(struct mutex *ldv_func_arg1 ) ;
#line 240
void ldv_mutex_unlock_261(struct mutex *ldv_func_arg1 ) ;
#line 244
void ldv_mutex_unlock_264(struct mutex *ldv_func_arg1 ) ;
#line 248
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) ;
#line 252
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_233(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_235(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_238(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_241(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_243(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_247(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_249(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_250(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_255(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_258(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_262(struct mutex *ldv_func_arg1 ) ;
#line 58
void ldv_mutex_lock_263(struct mutex *ldv_func_arg1 ) ;
#line 62
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) ;
#line 99
void ldv_mutex_lock_ecryptfs_daemon_hash_mux(struct mutex *lock ) ;
#line 103
void ldv_mutex_unlock_ecryptfs_daemon_hash_mux(struct mutex *lock ) ;
#line 107
void ldv_mutex_lock_ecryptfs_msg_ctx_lists_mux(struct mutex *lock ) ;
#line 111
void ldv_mutex_unlock_ecryptfs_msg_ctx_lists_mux(struct mutex *lock ) ;
#line 179
void ldv_mutex_lock_mux(struct mutex *lock ) ;
#line 180
int ldv_mutex_trylock_mux(struct mutex *lock ) ;
#line 183
void ldv_mutex_unlock_mux(struct mutex *lock ) ;
#line 63 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 331 "include/linux/sched.h"
extern long schedule_timeout_interruptible(long  ) ;
#line 2209
extern int wake_up_process(struct task_struct * ) ;
#line 34 "include/linux/hash.h"
__inline static u64 hash_64(u64 val , unsigned int bits ) 
{ 
  u64 hash ;
  u64 n ;

  {
#line 36
  hash = val;
#line 39
  n = hash;
#line 40
  n = n << 18;
#line 41
  hash = hash - n;
#line 42
  n = n << 33;
#line 43
  hash = hash - n;
#line 44
  n = n << 3;
#line 45
  hash = hash + n;
#line 46
  n = n << 3;
#line 47
  hash = hash - n;
#line 48
  n = n << 4;
#line 49
  hash = hash + n;
#line 50
  n = n << 2;
#line 51
  hash = hash + n;
#line 54
  return (hash >> (int )(64U - bits));
}
}
#line 402 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/fs/ecryptfs/ecryptfs_kernel.h"
struct mutex ecryptfs_daemon_hash_mux  ;
#line 607
int ecryptfs_process_response(struct ecryptfs_daemon *daemon , struct ecryptfs_message *msg ,
                              u32 seq ) ;
#line 652
int ecryptfs_exorcise_daemon(struct ecryptfs_daemon *daemon ) ;
#line 653
int ecryptfs_find_daemon_by_euid(struct ecryptfs_daemon **daemon ) ;
#line 658
int ecryptfs_init_ecryptfs_miscdev(void) ;
#line 659
void ecryptfs_destroy_ecryptfs_miscdev(void) ;
#line 660
int ecryptfs_send_miscdev(char *data , size_t data_size , struct ecryptfs_msg_ctx *msg_ctx ,
                          u8 msg_type , u16 msg_flags , struct ecryptfs_daemon *daemon ) ;
#line 663
void ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx ) ;
#line 665
int ecryptfs_spawn_daemon(struct ecryptfs_daemon **daemon , struct file *file ) ;
#line 163 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static struct list_head ecryptfs_msg_ctx_free_list  =    {& ecryptfs_msg_ctx_free_list, & ecryptfs_msg_ctx_free_list};
#line 164 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static struct list_head ecryptfs_msg_ctx_alloc_list  =    {& ecryptfs_msg_ctx_alloc_list, & ecryptfs_msg_ctx_alloc_list};
#line 165 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static struct mutex ecryptfs_msg_ctx_lists_mux  ;
#line 167 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static struct hlist_head *ecryptfs_daemon_hash  ;
#line 169 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static int ecryptfs_hash_bits  ;
#line 173 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static u32 ecryptfs_msg_counter  ;
#line 174 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr  ;
#line 186 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static int ecryptfs_acquire_free_msg_ctx(struct ecryptfs_msg_ctx **msg_ctx ) 
{ 
  struct list_head *p ;
  int rc ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 191
  tmp = list_empty((struct list_head  const  *)(& ecryptfs_msg_ctx_free_list));
#line 191
  if (tmp != 0) {
#line 192
    printk("\f%s: The eCryptfs free context list is empty.  It may be helpful to specify the ecryptfs_message_buf_len parameter to be greater than the current value of [%d]\n",
           "ecryptfs_acquire_free_msg_ctx", ecryptfs_message_buf_len);
#line 197
    rc = -12;
#line 198
    goto out;
  } else {

  }
#line 200
  p = ecryptfs_msg_ctx_free_list.next;
#line 200
  goto ldv_24775;
  ldv_24774: 
#line 201
  __mptr = (struct list_head  const  *)p;
#line 201
  *msg_ctx = (struct ecryptfs_msg_ctx *)__mptr + 0xffffffffffffffd8UL;
#line 202
  tmp___0 = ldv_mutex_trylock_237(& (*msg_ctx)->mux);
#line 202
  if (tmp___0 != 0) {
#line 203
    (*msg_ctx)->task = get_current();
#line 204
    rc = 0;
#line 205
    goto out;
  } else {

  }
#line 200
  p = p->next;
  ldv_24775: ;
#line 200
  if ((unsigned long )p != (unsigned long )(& ecryptfs_msg_ctx_free_list)) {
#line 201
    goto ldv_24774;
  } else {

  }
#line 208
  rc = -12;
  out: ;
#line 210
  return (rc);
}
}
#line 219 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static void ecryptfs_msg_ctx_free_to_alloc(struct ecryptfs_msg_ctx *msg_ctx ) 
{ 


  {
#line 221
  list_move(& msg_ctx->node, & ecryptfs_msg_ctx_alloc_list);
#line 222
  msg_ctx->state = 2U;
#line 223
  ecryptfs_msg_counter = ecryptfs_msg_counter + 1U;
#line 223
  msg_ctx->counter = ecryptfs_msg_counter;
#line 224
  return;
}
}
#line 232 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx ) 
{ 


  {
#line 234
  list_move(& msg_ctx->node, & ecryptfs_msg_ctx_free_list);
#line 235
  if ((unsigned long )msg_ctx->msg != (unsigned long )((struct ecryptfs_message *)0)) {
#line 236
    kfree((void const   *)msg_ctx->msg);
  } else {

  }
#line 237
  msg_ctx->msg = 0;
#line 238
  msg_ctx->state = 1U;
#line 239
  return;
}
}
#line 251 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
int ecryptfs_find_daemon_by_euid(struct ecryptfs_daemon **daemon ) 
{ 
  struct hlist_node *elem ;
  int rc ;
  int tmp ;
  struct task_struct *tmp___0 ;
  uid_t tmp___1 ;
  u64 tmp___2 ;
  int tmp___3 ;
  struct task_struct *tmp___4 ;
  bool tmp___5 ;
  struct hlist_node  const  *__mptr ;

  {
#line 256
  tmp = debug_lockdep_rcu_enabled();
#line 256
  tmp___0 = get_current();
#line 256
  tmp___1 = from_kuid(& init_user_ns, (tmp___0->cred)->euid);
#line 256
  tmp___2 = hash_64((u64 )tmp___1, (unsigned int )ecryptfs_hash_bits);
#line 256
  elem = (ecryptfs_daemon_hash + tmp___2)->first;
#line 256
  goto ldv_24797;
  ldv_24796: 
#line 259
  tmp___3 = debug_lockdep_rcu_enabled();
#line 259
  tmp___4 = get_current();
#line 259
  tmp___5 = uid_eq((((*daemon)->file)->f_cred)->euid, (tmp___4->cred)->euid);
#line 259
  if ((int )tmp___5) {
#line 260
    rc = 0;
#line 261
    goto out;
  } else {

  }
#line 256
  elem = elem->next;
  ldv_24797: ;
#line 256
  if ((unsigned long )elem != (unsigned long )((struct hlist_node *)0)) {
#line 256
    __mptr = (struct hlist_node  const  *)elem;
#line 256
    *daemon = (struct ecryptfs_daemon *)__mptr + 0xfffffffffffffee0UL;
#line 257
    goto ldv_24796;
  } else {

  }
#line 264
  rc = -22;
  out: ;
#line 266
  return (rc);
}
}
#line 280 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
int ecryptfs_spawn_daemon(struct ecryptfs_daemon **daemon , struct file *file ) 
{ 
  int rc ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  int tmp___0 ;
  struct task_struct *tmp___1 ;
  uid_t tmp___2 ;
  u64 tmp___3 ;

  {
#line 282
  rc = 0;
#line 284
  tmp = kzalloc(304UL, 208U);
#line 284
  *daemon = (struct ecryptfs_daemon *)tmp;
#line 285
  if ((unsigned long )*daemon == (unsigned long )((struct ecryptfs_daemon *)0)) {
#line 286
    rc = -12;
#line 287
    printk("\v%s: Failed to allocate [%zd] bytes of GFP_KERNEL memory\n", "ecryptfs_spawn_daemon",
           304UL);
#line 289
    goto out;
  } else {

  }
#line 291
  (*daemon)->file = file;
#line 292
  __mutex_init(& (*daemon)->mux, "&(*daemon)->mux", & __key);
#line 293
  INIT_LIST_HEAD(& (*daemon)->msg_ctx_out_queue);
#line 294
  __init_waitqueue_head(& (*daemon)->wait, "&(*daemon)->wait", & __key___0);
#line 295
  (*daemon)->num_queued_msg_ctx = 0U;
#line 297
  tmp___0 = debug_lockdep_rcu_enabled();
#line 297
  tmp___1 = get_current();
#line 297
  tmp___2 = from_kuid(& init_user_ns, (tmp___1->cred)->euid);
#line 297
  tmp___3 = hash_64((u64 )tmp___2, (unsigned int )ecryptfs_hash_bits);
#line 297
  hlist_add_head(& (*daemon)->euid_chain, ecryptfs_daemon_hash + tmp___3);
  out: ;
#line 299
  return (rc);
}
}
#line 308 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
int ecryptfs_exorcise_daemon(struct ecryptfs_daemon *daemon ) 
{ 
  struct ecryptfs_msg_ctx *msg_ctx ;
  struct ecryptfs_msg_ctx *msg_ctx_tmp ;
  int rc ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 311
  rc = 0;
#line 313
  ldv_mutex_lock_238(& daemon->mux);
#line 314
  if ((int )daemon->flags & 1 || (daemon->flags & 2U) != 0U) {
#line 316
    rc = -16;
#line 317
    ldv_mutex_unlock_239(& daemon->mux);
#line 318
    goto out;
  } else {

  }
#line 320
  __mptr = (struct list_head  const  *)daemon->msg_ctx_out_queue.next;
#line 320
  msg_ctx = (struct ecryptfs_msg_ctx *)__mptr + 0xffffffffffffffc8UL;
#line 320
  __mptr___0 = (struct list_head  const  *)msg_ctx->daemon_out_list.next;
#line 320
  msg_ctx_tmp = (struct ecryptfs_msg_ctx *)__mptr___0 + 0xffffffffffffffc8UL;
#line 320
  goto ldv_24825;
  ldv_24824: 
#line 322
  list_del(& msg_ctx->daemon_out_list);
#line 323
  daemon->num_queued_msg_ctx = daemon->num_queued_msg_ctx - 1U;
#line 324
  printk("\f%s: Warning: dropping message that is in the out queue of a dying daemon\n",
         "ecryptfs_exorcise_daemon");
#line 326
  ecryptfs_msg_ctx_alloc_to_free(msg_ctx);
#line 320
  msg_ctx = msg_ctx_tmp;
#line 320
  __mptr___1 = (struct list_head  const  *)msg_ctx_tmp->daemon_out_list.next;
#line 320
  msg_ctx_tmp = (struct ecryptfs_msg_ctx *)__mptr___1 + 0xffffffffffffffc8UL;
  ldv_24825: ;
#line 320
  if ((unsigned long )(& msg_ctx->daemon_out_list) != (unsigned long )(& daemon->msg_ctx_out_queue)) {
#line 321
    goto ldv_24824;
  } else {

  }
#line 328
  hlist_del(& daemon->euid_chain);
#line 329
  ldv_mutex_unlock_240(& daemon->mux);
#line 330
  kzfree((void const   *)daemon);
  out: ;
#line 332
  return (rc);
}
}
#line 357 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
int ecryptfs_process_response(struct ecryptfs_daemon *daemon , struct ecryptfs_message *msg ,
                              u32 seq ) 
{ 
  struct ecryptfs_msg_ctx *msg_ctx ;
  size_t msg_size ;
  int rc ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 364
  if (msg->index >= ecryptfs_message_buf_len) {
#line 365
    rc = -22;
#line 366
    printk("\v%s: Attempt to reference context buffer at index [%d]; maximum allowable is [%d]\n",
           "ecryptfs_process_response", msg->index, ecryptfs_message_buf_len - 1U);
#line 370
    goto out;
  } else {

  }
#line 372
  msg_ctx = ecryptfs_msg_ctx_arr + (unsigned long )msg->index;
#line 373
  ldv_mutex_lock_241(& msg_ctx->mux);
#line 374
  if ((unsigned int )msg_ctx->state != 2U) {
#line 375
    rc = -22;
#line 376
    printk("\f%s: Desired context element is not pending a response\n", "ecryptfs_process_response");
#line 378
    goto unlock;
  } else
#line 379
  if (msg_ctx->counter != seq) {
#line 380
    rc = -22;
#line 381
    printk("\f%s: Invalid message sequence; expected [%d]; received [%d]\n", "ecryptfs_process_response",
           msg_ctx->counter, seq);
#line 384
    goto unlock;
  } else {

  }
#line 386
  msg_size = (unsigned long )msg->data_len + 8UL;
#line 387
  tmp = kmalloc(msg_size, 208U);
#line 387
  msg_ctx->msg = (struct ecryptfs_message *)tmp;
#line 388
  if ((unsigned long )msg_ctx->msg == (unsigned long )((struct ecryptfs_message *)0)) {
#line 389
    rc = -12;
#line 390
    printk("\v%s: Failed to allocate [%zd] bytes of GFP_KERNEL memory\n", "ecryptfs_process_response",
           msg_size);
#line 392
    goto unlock;
  } else {

  }
#line 394
  __len = msg_size;
#line 394
  __ret = __builtin_memcpy((void *)msg_ctx->msg, (void const   *)msg, __len);
#line 395
  msg_ctx->state = 3U;
#line 396
  wake_up_process(msg_ctx->task);
#line 397
  rc = 0;
  unlock: 
#line 399
  ldv_mutex_unlock_242(& msg_ctx->mux);
  out: ;
#line 401
  return (rc);
}
}
#line 415 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
static int ecryptfs_send_message_locked(char *data , int data_len , u8 msg_type ,
                                        struct ecryptfs_msg_ctx **msg_ctx ) 
{ 
  struct ecryptfs_daemon *daemon ;
  int rc ;

  {
#line 421
  rc = ecryptfs_find_daemon_by_euid(& daemon);
#line 422
  if (rc != 0 || (unsigned long )daemon == (unsigned long )((struct ecryptfs_daemon *)0)) {
#line 423
    rc = -107;
#line 424
    goto out;
  } else {

  }
#line 426
  ldv_mutex_lock_243(& ecryptfs_msg_ctx_lists_mux);
#line 427
  rc = ecryptfs_acquire_free_msg_ctx(msg_ctx);
#line 428
  if (rc != 0) {
#line 429
    ldv_mutex_unlock_244(& ecryptfs_msg_ctx_lists_mux);
#line 430
    printk("\f%s: Could not claim a free context element\n", "ecryptfs_send_message_locked");
#line 432
    goto out;
  } else {

  }
#line 434
  ecryptfs_msg_ctx_free_to_alloc(*msg_ctx);
#line 435
  ldv_mutex_unlock_245(& (*msg_ctx)->mux);
#line 436
  ldv_mutex_unlock_246(& ecryptfs_msg_ctx_lists_mux);
#line 437
  rc = ecryptfs_send_miscdev(data, (size_t )data_len, *msg_ctx, (int )msg_type, 0,
                             daemon);
#line 439
  if (rc != 0) {
#line 440
    printk("\v%s: Error attempting to send message to userspace daemon; rc = [%d]\n",
           "ecryptfs_send_message_locked", rc);
  } else {

  }
  out: ;
#line 443
  return (rc);
}
}
#line 456 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
int ecryptfs_send_message(char *data , int data_len , struct ecryptfs_msg_ctx **msg_ctx ) 
{ 
  int rc ;

  {
#line 461
  ldv_mutex_lock_247(& ecryptfs_daemon_hash_mux);
#line 462
  rc = ecryptfs_send_message_locked(data, data_len, 102, msg_ctx);
#line 464
  ldv_mutex_unlock_248(& ecryptfs_daemon_hash_mux);
#line 465
  return (rc);
}
}
#line 479 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
int ecryptfs_wait_for_response(struct ecryptfs_msg_ctx *msg_ctx , struct ecryptfs_message **msg ) 
{ 
  long timeout ;
  int rc ;

  {
#line 482
  timeout = ecryptfs_message_wait_timeout * 250L;
#line 483
  rc = 0;
  sleep: 
#line 486
  timeout = schedule_timeout_interruptible(timeout);
#line 487
  ldv_mutex_lock_249(& ecryptfs_msg_ctx_lists_mux);
#line 488
  ldv_mutex_lock_250(& msg_ctx->mux);
#line 489
  if ((unsigned int )msg_ctx->state != 3U) {
#line 490
    if (timeout != 0L) {
#line 491
      ldv_mutex_unlock_251(& msg_ctx->mux);
#line 492
      ldv_mutex_unlock_252(& ecryptfs_msg_ctx_lists_mux);
#line 493
      goto sleep;
    } else {

    }
#line 495
    rc = -42;
  } else {
#line 497
    *msg = msg_ctx->msg;
#line 498
    msg_ctx->msg = 0;
  }
#line 500
  ecryptfs_msg_ctx_alloc_to_free(msg_ctx);
#line 501
  ldv_mutex_unlock_253(& msg_ctx->mux);
#line 502
  ldv_mutex_unlock_254(& ecryptfs_msg_ctx_lists_mux);
#line 503
  return (rc);
}
}
#line 506 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
int ecryptfs_init_messaging(void) 
{ 
  int i ;
  int rc ;
  struct lock_class_key __key ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
#line 509
  rc = 0;
#line 511
  if (ecryptfs_number_of_users > 32768U) {
#line 512
    ecryptfs_number_of_users = 32768U;
#line 513
    printk("\f%s: Specified number of users is too large, defaulting to [%d] users\n",
           "ecryptfs_init_messaging", ecryptfs_number_of_users);
  } else {

  }
#line 517
  __mutex_init(& ecryptfs_daemon_hash_mux, "&ecryptfs_daemon_hash_mux", & __key);
#line 518
  ldv_mutex_lock_255(& ecryptfs_daemon_hash_mux);
#line 519
  ecryptfs_hash_bits = 1;
#line 520
  goto ldv_24872;
  ldv_24871: 
#line 521
  ecryptfs_hash_bits = ecryptfs_hash_bits + 1;
  ldv_24872: ;
#line 520
  if (ecryptfs_number_of_users >> ecryptfs_hash_bits != 0U) {
#line 521
    goto ldv_24871;
  } else {

  }
#line 522
  tmp = kmalloc((unsigned long )(1 << ecryptfs_hash_bits) * 8UL, 208U);
#line 522
  ecryptfs_daemon_hash = (struct hlist_head *)tmp;
#line 525
  if ((unsigned long )ecryptfs_daemon_hash == (unsigned long )((struct hlist_head *)0)) {
#line 526
    rc = -12;
#line 527
    printk("\v%s: Failed to allocate memory\n", "ecryptfs_init_messaging");
#line 528
    ldv_mutex_unlock_256(& ecryptfs_daemon_hash_mux);
#line 529
    goto out;
  } else {

  }
#line 531
  i = 0;
#line 531
  goto ldv_24876;
  ldv_24875: 
#line 532
  (ecryptfs_daemon_hash + (unsigned long )i)->first = 0;
#line 531
  i = i + 1;
  ldv_24876: ;
#line 531
  if (1 << ecryptfs_hash_bits > i) {
#line 532
    goto ldv_24875;
  } else {

  }
#line 533
  ldv_mutex_unlock_257(& ecryptfs_daemon_hash_mux);
#line 534
  tmp___0 = kmalloc((unsigned long )ecryptfs_message_buf_len * 240UL, 208U);
#line 534
  ecryptfs_msg_ctx_arr = (struct ecryptfs_msg_ctx *)tmp___0;
#line 537
  if ((unsigned long )ecryptfs_msg_ctx_arr == (unsigned long )((struct ecryptfs_msg_ctx *)0)) {
#line 538
    rc = -12;
#line 539
    printk("\v%s: Failed to allocate memory\n", "ecryptfs_init_messaging");
#line 540
    goto out;
  } else {

  }
#line 542
  __mutex_init(& ecryptfs_msg_ctx_lists_mux, "&ecryptfs_msg_ctx_lists_mux", & __key___0);
#line 543
  ldv_mutex_lock_258(& ecryptfs_msg_ctx_lists_mux);
#line 544
  ecryptfs_msg_counter = 0U;
#line 545
  i = 0;
#line 545
  goto ldv_24881;
  ldv_24880: 
#line 546
  INIT_LIST_HEAD(& (ecryptfs_msg_ctx_arr + (unsigned long )i)->node);
#line 547
  INIT_LIST_HEAD(& (ecryptfs_msg_ctx_arr + (unsigned long )i)->daemon_out_list);
#line 548
  __mutex_init(& (ecryptfs_msg_ctx_arr + (unsigned long )i)->mux, "&ecryptfs_msg_ctx_arr[i].mux",
               & __key___1);
#line 549
  ldv_mutex_lock_259(& (ecryptfs_msg_ctx_arr + (unsigned long )i)->mux);
#line 550
  (ecryptfs_msg_ctx_arr + (unsigned long )i)->index = (u32 )i;
#line 551
  (ecryptfs_msg_ctx_arr + (unsigned long )i)->state = 1U;
#line 552
  (ecryptfs_msg_ctx_arr + (unsigned long )i)->counter = 0U;
#line 553
  (ecryptfs_msg_ctx_arr + (unsigned long )i)->task = 0;
#line 554
  (ecryptfs_msg_ctx_arr + (unsigned long )i)->msg = 0;
#line 555
  list_add_tail(& (ecryptfs_msg_ctx_arr + (unsigned long )i)->node, & ecryptfs_msg_ctx_free_list);
#line 557
  ldv_mutex_unlock_260(& (ecryptfs_msg_ctx_arr + (unsigned long )i)->mux);
#line 545
  i = i + 1;
  ldv_24881: ;
#line 545
  if ((unsigned int )i < ecryptfs_message_buf_len) {
#line 546
    goto ldv_24880;
  } else {

  }
#line 559
  ldv_mutex_unlock_261(& ecryptfs_msg_ctx_lists_mux);
#line 560
  rc = ecryptfs_init_ecryptfs_miscdev();
#line 561
  if (rc != 0) {
#line 562
    ecryptfs_release_messaging();
  } else {

  }
  out: ;
#line 564
  return (rc);
}
}
#line 567 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ecryptfs_release_messaging(void) 
{ 
  int i ;
  struct hlist_node *elem ;
  struct ecryptfs_daemon *daemon ;
  int i___0 ;
  int rc ;
  struct hlist_node  const  *__mptr ;

  {
#line 569
  if ((unsigned long )ecryptfs_msg_ctx_arr != (unsigned long )((struct ecryptfs_msg_ctx *)0)) {
#line 572
    ldv_mutex_lock_262(& ecryptfs_msg_ctx_lists_mux);
#line 573
    i = 0;
#line 573
    goto ldv_24888;
    ldv_24887: 
#line 574
    ldv_mutex_lock_263(& (ecryptfs_msg_ctx_arr + (unsigned long )i)->mux);
#line 575
    if ((unsigned long )(ecryptfs_msg_ctx_arr + (unsigned long )i)->msg != (unsigned long )((struct ecryptfs_message *)0)) {
#line 576
      kfree((void const   *)(ecryptfs_msg_ctx_arr + (unsigned long )i)->msg);
    } else {

    }
#line 577
    ldv_mutex_unlock_264(& (ecryptfs_msg_ctx_arr + (unsigned long )i)->mux);
#line 573
    i = i + 1;
    ldv_24888: ;
#line 573
    if ((unsigned int )i < ecryptfs_message_buf_len) {
#line 574
      goto ldv_24887;
    } else {

    }
#line 579
    kfree((void const   *)ecryptfs_msg_ctx_arr);
#line 580
    ldv_mutex_unlock_265(& ecryptfs_msg_ctx_lists_mux);
  } else {

  }
#line 582
  if ((unsigned long )ecryptfs_daemon_hash != (unsigned long )((struct hlist_head *)0)) {
#line 587
    ldv_mutex_lock_266(& ecryptfs_daemon_hash_mux);
#line 588
    i___0 = 0;
#line 588
    goto ldv_24902;
    ldv_24901: 
#line 591
    elem = (ecryptfs_daemon_hash + (unsigned long )i___0)->first;
#line 591
    goto ldv_24899;
    ldv_24898: 
#line 594
    rc = ecryptfs_exorcise_daemon(daemon);
#line 595
    if (rc != 0) {
#line 596
      printk("\v%s: Error whilst attempting to destroy daemon; rc = [%d]. Dazed and confused, but trying to continue.\n",
             "ecryptfs_release_messaging", rc);
    } else {

    }
#line 591
    elem = elem->next;
    ldv_24899: ;
#line 591
    if ((unsigned long )elem != (unsigned long )((struct hlist_node *)0)) {
#line 591
      __mptr = (struct hlist_node  const  *)elem;
#line 591
      daemon = (struct ecryptfs_daemon *)__mptr + 0xfffffffffffffee0UL;
#line 592
      goto ldv_24898;
    } else {

    }
#line 588
    i___0 = i___0 + 1;
    ldv_24902: ;
#line 588
    if (1 << ecryptfs_hash_bits > i___0) {
#line 589
      goto ldv_24901;
    } else {

    }
#line 603
    kfree((void const   *)ecryptfs_daemon_hash);
#line 604
    ldv_mutex_unlock_267(& ecryptfs_daemon_hash_mux);
  } else {

  }
#line 606
  ecryptfs_destroy_ecryptfs_miscdev();
#line 607
  return;
}
}
#line 610 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_233(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 615
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 617
  mutex_lock(ldv_func_arg1);
#line 618
  return;
}
}
#line 620 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_234(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 625
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 627
  mutex_unlock(ldv_func_arg1);
#line 628
  return;
}
}
#line 630 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_235(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 635
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 637
  mutex_lock(ldv_func_arg1);
#line 638
  return;
}
}
#line 640 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_236(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 645
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 647
  mutex_unlock(ldv_func_arg1);
#line 648
  return;
}
}
#line 650 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
int ldv_mutex_trylock_237(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 655
  tmp = mutex_trylock(ldv_func_arg1);
#line 655
  ldv_func_res = tmp;
#line 657
  tmp___0 = ldv_mutex_trylock_mux(ldv_func_arg1);
#line 657
  return (tmp___0);
#line 659
  return (ldv_func_res);
}
}
#line 662 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_238(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 667
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 669
  mutex_lock(ldv_func_arg1);
#line 670
  return;
}
}
#line 672 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_239(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 677
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 679
  mutex_unlock(ldv_func_arg1);
#line 680
  return;
}
}
#line 682 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_240(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 687
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 689
  mutex_unlock(ldv_func_arg1);
#line 690
  return;
}
}
#line 692 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_241(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 697
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 699
  mutex_lock(ldv_func_arg1);
#line 700
  return;
}
}
#line 702 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_242(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 707
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 709
  mutex_unlock(ldv_func_arg1);
#line 710
  return;
}
}
#line 712 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_243(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 717
  ldv_mutex_lock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 719
  mutex_lock(ldv_func_arg1);
#line 720
  return;
}
}
#line 722 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_244(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 727
  ldv_mutex_unlock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 729
  mutex_unlock(ldv_func_arg1);
#line 730
  return;
}
}
#line 732 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_245(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 737
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 739
  mutex_unlock(ldv_func_arg1);
#line 740
  return;
}
}
#line 742 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_246(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 747
  ldv_mutex_unlock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 749
  mutex_unlock(ldv_func_arg1);
#line 750
  return;
}
}
#line 752 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_247(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 757
  ldv_mutex_lock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 759
  mutex_lock(ldv_func_arg1);
#line 760
  return;
}
}
#line 762 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_248(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 767
  ldv_mutex_unlock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 769
  mutex_unlock(ldv_func_arg1);
#line 770
  return;
}
}
#line 772 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_249(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 777
  ldv_mutex_lock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 779
  mutex_lock(ldv_func_arg1);
#line 780
  return;
}
}
#line 782 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_250(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 787
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 789
  mutex_lock(ldv_func_arg1);
#line 790
  return;
}
}
#line 792 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_251(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 797
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 799
  mutex_unlock(ldv_func_arg1);
#line 800
  return;
}
}
#line 802 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_252(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 807
  ldv_mutex_unlock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 809
  mutex_unlock(ldv_func_arg1);
#line 810
  return;
}
}
#line 812 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_253(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 817
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 819
  mutex_unlock(ldv_func_arg1);
#line 820
  return;
}
}
#line 822 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_254(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 827
  ldv_mutex_unlock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 829
  mutex_unlock(ldv_func_arg1);
#line 830
  return;
}
}
#line 832 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_255(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 837
  ldv_mutex_lock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 839
  mutex_lock(ldv_func_arg1);
#line 840
  return;
}
}
#line 842 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_256(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 847
  ldv_mutex_unlock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 849
  mutex_unlock(ldv_func_arg1);
#line 850
  return;
}
}
#line 852 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_257(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 857
  ldv_mutex_unlock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 859
  mutex_unlock(ldv_func_arg1);
#line 860
  return;
}
}
#line 862 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_258(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 867
  ldv_mutex_lock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 869
  mutex_lock(ldv_func_arg1);
#line 870
  return;
}
}
#line 872 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 877
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 879
  mutex_lock(ldv_func_arg1);
#line 880
  return;
}
}
#line 882 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_260(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 887
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 889
  mutex_unlock(ldv_func_arg1);
#line 890
  return;
}
}
#line 892 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_261(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 897
  ldv_mutex_unlock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 899
  mutex_unlock(ldv_func_arg1);
#line 900
  return;
}
}
#line 902 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_262(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 907
  ldv_mutex_lock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 909
  mutex_lock(ldv_func_arg1);
#line 910
  return;
}
}
#line 912 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_263(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 917
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 919
  mutex_lock(ldv_func_arg1);
#line 920
  return;
}
}
#line 922 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_264(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 927
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 929
  mutex_unlock(ldv_func_arg1);
#line 930
  return;
}
}
#line 932 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 937
  ldv_mutex_unlock_ecryptfs_msg_ctx_lists_mux(ldv_func_arg1);
#line 939
  mutex_unlock(ldv_func_arg1);
#line 940
  return;
}
}
#line 942 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 947
  ldv_mutex_lock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 949
  mutex_lock(ldv_func_arg1);
#line 950
  return;
}
}
#line 952 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/messaging.c.prepared"
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 957
  ldv_mutex_unlock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 959
  mutex_unlock(ldv_func_arg1);
#line 960
  return;
}
}
#line 1 "<compiler builtins>"
unsigned long __builtin_object_size(void * , int  ) ;
#line 197 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 12 "include/linux/string.h"
extern void *memdup_user(void const   * , size_t  ) ;
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 105 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 107
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 109
  return;
}
}
#line 172 "include/linux/mutex.h"
void ldv_mutex_unlock_304(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_308(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_310(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_313(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_316(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_318(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_320(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_322(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_324(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_327(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_328(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_305(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_307(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_309(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_311(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_315(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_317(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_319(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_321(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_323(struct mutex *ldv_func_arg1 ) ;
#line 54
void ldv_mutex_lock_325(struct mutex *ldv_func_arg1 ) ;
#line 58
void ldv_mutex_lock_326(struct mutex *ldv_func_arg1 ) ;
#line 139 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 732
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 734
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 737
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 2397 "include/linux/fs.h"
extern loff_t noop_llseek(struct file * , loff_t  , int  ) ;
#line 63 "include/linux/miscdevice.h"
extern int misc_register(struct miscdevice * ) ;
#line 64
extern int misc_deregister(struct miscdevice * ) ;
#line 49 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 51
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 55 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 59
  tmp = __builtin_object_size((void const   *)to, 0);
#line 59
  sz = (int )tmp;
#line 61
  might_fault();
#line 62
  tmp___1 = __builtin_expect(sz == -1, 1L);
#line 62
  if (tmp___1 != 0L) {
#line 63
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 62
    tmp___2 = __builtin_expect((unsigned long )sz >= n, 1L);
#line 62
    if (tmp___2 != 0L) {
#line 63
      n = _copy_from_user(to, from, (unsigned int )n);
    } else {
#line 66
      __ret_warn_on = 1;
#line 66
      tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
#line 66
      if (tmp___0 != 0L) {
#line 66
        warn_slowpath_fmt("/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h",
                          66, "Buffer overflow detected!\n");
      } else {

      }
#line 66
      __builtin_expect(__ret_warn_on != 0, 0L);
    }
  }
#line 68
  return (n);
}
}
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void const   *src , unsigned int size ) 
{ 
  unsigned long tmp ;

  {
#line 74
  might_fault();
#line 76
  tmp = _copy_to_user(dst, src, size);
#line 76
  return ((int )tmp);
}
}
#line 42 "include/linux/poll.h"
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 


  {
#line 44
  if (((unsigned long )p != (unsigned long )((poll_table *)0) && (unsigned long )p->_qproc != (unsigned long )((void (*)(struct file * ,
                                                                                                                         wait_queue_head_t * ,
                                                                                                                         struct poll_table_struct * ))0)) && (unsigned long )wait_address != (unsigned long )((wait_queue_head_t *)0)) {
#line 45
    (*(p->_qproc))(filp, wait_address, p);
  } else {

  }
#line 46
  return;
}
}
#line 465 "include/linux/module.h"
extern bool try_module_get(struct module * ) ;
#line 467
extern void module_put(struct module * ) ;
#line 334 "include/linux/sched.h"
extern void schedule(void) ;
#line 168 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
static atomic_t ecryptfs_num_miscdev_opens  ;
#line 178 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
static unsigned int ecryptfs_miscdev_poll(struct file *file , poll_table *pt ) 
{ 
  struct ecryptfs_daemon *daemon ;
  unsigned int mask ;
  int tmp ;

  {
#line 180
  daemon = (struct ecryptfs_daemon *)file->private_data;
#line 181
  mask = 0U;
#line 183
  ldv_mutex_lock_307(& daemon->mux);
#line 184
  if ((daemon->flags & 4U) != 0U) {
#line 185
    printk("\f%s: Attempt to poll on zombified daemon\n", "ecryptfs_miscdev_poll");
#line 187
    goto out_unlock_daemon;
  } else {

  }
#line 189
  if ((int )daemon->flags & 1) {
#line 190
    goto out_unlock_daemon;
  } else {

  }
#line 191
  if ((daemon->flags & 2U) != 0U) {
#line 192
    goto out_unlock_daemon;
  } else {

  }
#line 193
  daemon->flags = daemon->flags | 2U;
#line 194
  ldv_mutex_unlock_308(& daemon->mux);
#line 195
  poll_wait(file, & daemon->wait, pt);
#line 196
  ldv_mutex_lock_309(& daemon->mux);
#line 197
  tmp = list_empty((struct list_head  const  *)(& daemon->msg_ctx_out_queue));
#line 197
  if (tmp == 0) {
#line 198
    mask = mask | 65U;
  } else {

  }
  out_unlock_daemon: 
#line 200
  daemon->flags = daemon->flags & 4294967293U;
#line 201
  ldv_mutex_unlock_310(& daemon->mux);
#line 202
  return (mask);
}
}
#line 213 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
static int ecryptfs_miscdev_open(struct inode *inode , struct file *file ) 
{ 
  struct ecryptfs_daemon *daemon ;
  int rc ;
  bool tmp ;

  {
#line 215
  daemon = 0;
#line 218
  ldv_mutex_lock_311(& ecryptfs_daemon_hash_mux);
#line 219
  tmp = try_module_get(& __this_module);
#line 219
  rc = (int )tmp;
#line 220
  if (rc == 0) {
#line 221
    rc = -5;
#line 222
    printk("\v%s: Error attempting to increment module use count; rc = [%d]\n", "ecryptfs_miscdev_open",
           rc);
#line 224
    goto out_unlock_daemon_list;
  } else {

  }
#line 226
  rc = ecryptfs_find_daemon_by_euid(& daemon);
#line 227
  if (rc == 0) {
#line 228
    rc = -22;
#line 229
    goto out_unlock_daemon_list;
  } else {

  }
#line 231
  rc = ecryptfs_spawn_daemon(& daemon, file);
#line 232
  if (rc != 0) {
#line 233
    printk("\v%s: Error attempting to spawn daemon; rc = [%d]\n", "ecryptfs_miscdev_open",
           rc);
#line 235
    goto out_module_put_unlock_daemon_list;
  } else {

  }
#line 237
  ldv_mutex_lock_312(& daemon->mux);
#line 238
  if ((daemon->flags & 8U) != 0U) {
#line 239
    rc = -16;
#line 240
    goto out_unlock_daemon;
  } else {

  }
#line 242
  daemon->flags = daemon->flags | 8U;
#line 243
  file->private_data = (void *)daemon;
#line 244
  atomic_inc(& ecryptfs_num_miscdev_opens);
  out_unlock_daemon: 
#line 246
  ldv_mutex_unlock_313(& daemon->mux);
  out_module_put_unlock_daemon_list: ;
#line 248
  if (rc != 0) {
#line 249
    module_put(& __this_module);
  } else {

  }
  out_unlock_daemon_list: 
#line 251
  ldv_mutex_unlock_314(& ecryptfs_daemon_hash_mux);
#line 252
  return (rc);
}
}
#line 266 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
static int ecryptfs_miscdev_release(struct inode *inode , struct file *file ) 
{ 
  struct ecryptfs_daemon *daemon ;
  int rc ;
  long tmp ;

  {
#line 268
  daemon = (struct ecryptfs_daemon *)file->private_data;
#line 271
  ldv_mutex_lock_315(& daemon->mux);
#line 272
  tmp = __builtin_expect((daemon->flags & 8U) == 0U, 0L);
#line 272
  if (tmp != 0L) {
#line 272
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"),
                         "i" (272), "i" (12UL));
    ldv_25898: ;
#line 272
    goto ldv_25898;
  } else {

  }
#line 273
  daemon->flags = daemon->flags & 4294967287U;
#line 274
  atomic_dec(& ecryptfs_num_miscdev_opens);
#line 275
  ldv_mutex_unlock_316(& daemon->mux);
#line 277
  ldv_mutex_lock_317(& ecryptfs_daemon_hash_mux);
#line 278
  rc = ecryptfs_exorcise_daemon(daemon);
#line 279
  ldv_mutex_unlock_318(& ecryptfs_daemon_hash_mux);
#line 280
  if (rc != 0) {
#line 281
    printk("\n%s: Fatal error whilst attempting to shut down daemon; rc = [%d]. Please report this bug.\n",
           "ecryptfs_miscdev_release", rc);
#line 284
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"),
                         "i" (284), "i" (12UL));
    ldv_25900: ;
#line 284
    goto ldv_25900;
  } else {

  }
#line 286
  module_put(& __this_module);
#line 287
  return (rc);
}
}
#line 306 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
int ecryptfs_send_miscdev(char *data , size_t data_size , struct ecryptfs_msg_ctx *msg_ctx ,
                          u8 msg_type , u16 msg_flags , struct ecryptfs_daemon *daemon ) 
{ 
  struct ecryptfs_message *msg ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 312
  tmp = kmalloc(data_size + 8UL, 208U);
#line 312
  msg = (struct ecryptfs_message *)tmp;
#line 313
  if ((unsigned long )msg == (unsigned long )((struct ecryptfs_message *)0)) {
#line 314
    printk("\v%s: Out of memory whilst attempting to kmalloc(%zd, GFP_KERNEL)\n",
           "ecryptfs_send_miscdev", data_size + 8UL);
#line 317
    return (-12);
  } else {

  }
#line 320
  ldv_mutex_lock_319(& msg_ctx->mux);
#line 321
  msg_ctx->msg = msg;
#line 322
  (msg_ctx->msg)->index = msg_ctx->index;
#line 323
  (msg_ctx->msg)->data_len = (u32 )data_size;
#line 324
  msg_ctx->type = msg_type;
#line 325
  __len = data_size;
#line 325
  __ret = __builtin_memcpy((void *)(& (msg_ctx->msg)->data), (void const   *)data,
                           __len);
#line 326
  msg_ctx->msg_size = data_size + 8UL;
#line 327
  list_add_tail(& msg_ctx->daemon_out_list, & daemon->msg_ctx_out_queue);
#line 328
  ldv_mutex_unlock_320(& msg_ctx->mux);
#line 330
  ldv_mutex_lock_321(& daemon->mux);
#line 331
  daemon->num_queued_msg_ctx = daemon->num_queued_msg_ctx + 1U;
#line 332
  __wake_up(& daemon->wait, 1U, 1, 0);
#line 333
  ldv_mutex_unlock_322(& daemon->mux);
#line 335
  return (0);
}
}
#line 374 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
static ssize_t ecryptfs_miscdev_read(struct file *file , char *buf , size_t count ,
                                     loff_t *ppos ) 
{ 
  struct ecryptfs_daemon *daemon ;
  struct ecryptfs_msg_ctx *msg_ctx ;
  size_t packet_length_size ;
  char packet_length[2U] ;
  size_t i ;
  size_t total_length ;
  int rc ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  int tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct list_head  const  *__mptr ;
  long tmp___6 ;
  int __ret_pu ;
  char __pu_val ;
  int __ret_pu___0 ;
  __be32 __pu_val___0 ;
  __u32 tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 377
  daemon = (struct ecryptfs_daemon *)file->private_data;
#line 385
  ldv_mutex_lock_323(& daemon->mux);
#line 386
  if ((daemon->flags & 4U) != 0U) {
#line 387
    rc = 0;
#line 388
    printk("\f%s: Attempt to read from zombified daemon\n", "ecryptfs_miscdev_read");
#line 390
    goto out_unlock_daemon;
  } else {

  }
#line 392
  if ((int )daemon->flags & 1) {
#line 393
    rc = 0;
#line 394
    goto out_unlock_daemon;
  } else {

  }
#line 397
  daemon->flags = daemon->flags | 1U;
  check_list: 
#line 399
  tmp___4 = list_empty((struct list_head  const  *)(& daemon->msg_ctx_out_queue));
#line 399
  if (tmp___4 != 0) {
#line 400
    ldv_mutex_unlock_324(& daemon->mux);
#line 401
    __ret = 0;
#line 401
    tmp___3 = list_empty((struct list_head  const  *)(& daemon->msg_ctx_out_queue));
#line 401
    if (tmp___3 != 0) {
#line 401
      tmp = get_current();
#line 401
      __wait.flags = 0U;
#line 401
      __wait.private = (void *)tmp;
#line 401
      __wait.func = & autoremove_wake_function;
#line 401
      __wait.task_list.next = & __wait.task_list;
#line 401
      __wait.task_list.prev = & __wait.task_list;
      ldv_25934: 
#line 401
      prepare_to_wait(& daemon->wait, & __wait, 1);
#line 401
      tmp___0 = list_empty((struct list_head  const  *)(& daemon->msg_ctx_out_queue));
#line 401
      if (tmp___0 == 0) {
#line 401
        goto ldv_25932;
      } else {

      }
#line 401
      tmp___1 = get_current();
#line 401
      tmp___2 = signal_pending(tmp___1);
#line 401
      if (tmp___2 == 0) {
#line 401
        schedule();
#line 401
        goto ldv_25933;
      } else {

      }
#line 401
      __ret = -512;
#line 401
      goto ldv_25932;
      ldv_25933: ;
#line 401
      goto ldv_25934;
      ldv_25932: 
#line 401
      finish_wait(& daemon->wait, & __wait);
    } else {

    }
#line 401
    rc = __ret;
#line 403
    ldv_mutex_lock_325(& daemon->mux);
#line 404
    if (rc < 0) {
#line 405
      rc = 0;
#line 406
      goto out_unlock_daemon;
    } else {

    }
  } else {

  }
#line 409
  if ((daemon->flags & 4U) != 0U) {
#line 410
    rc = 0;
#line 411
    goto out_unlock_daemon;
  } else {

  }
#line 413
  tmp___5 = list_empty((struct list_head  const  *)(& daemon->msg_ctx_out_queue));
#line 413
  if (tmp___5 != 0) {
#line 417
    goto check_list;
  } else {

  }
#line 419
  __mptr = (struct list_head  const  *)daemon->msg_ctx_out_queue.next;
#line 419
  msg_ctx = (struct ecryptfs_msg_ctx *)__mptr + 0xffffffffffffffc8UL;
#line 421
  tmp___6 = __builtin_expect((unsigned long )msg_ctx == (unsigned long )((struct ecryptfs_msg_ctx *)0),
                             0L);
#line 421
  if (tmp___6 != 0L) {
#line 421
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"),
                         "i" (421), "i" (12UL));
    ldv_25938: ;
#line 421
    goto ldv_25938;
  } else {

  }
#line 422
  ldv_mutex_lock_326(& msg_ctx->mux);
#line 423
  if ((unsigned long )msg_ctx->msg != (unsigned long )((struct ecryptfs_message *)0)) {
#line 424
    rc = ecryptfs_write_packet_length((char *)(& packet_length), msg_ctx->msg_size,
                                      & packet_length_size);
#line 427
    if (rc != 0) {
#line 428
      rc = 0;
#line 429
      printk("\f%s: Error writing packet length; rc = [%d]\n", "ecryptfs_miscdev_read",
             rc);
#line 431
      goto out_unlock_msg_ctx;
    } else {

    }
  } else {
#line 434
    packet_length_size = 0UL;
#line 435
    msg_ctx->msg_size = 0UL;
  }
#line 437
  total_length = (msg_ctx->msg_size + packet_length_size) + 5UL;
#line 439
  if (count < total_length) {
#line 440
    rc = 0;
#line 441
    printk("\f%s: Only given user buffer of size [%zd], but we need [%zd] to read the pending message\n",
           "ecryptfs_miscdev_read", count, total_length);
#line 444
    goto out_unlock_msg_ctx;
  } else {

  }
#line 446
  rc = -14;
#line 447
  might_fault();
#line 447
  __pu_val = (char )msg_ctx->type;
#line 447
  switch (1UL) {
  case 1UL: 
#line 447
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
#line 447
  goto ldv_25943;
  case 2UL: 
#line 447
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
#line 447
  goto ldv_25943;
  case 4UL: 
#line 447
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
#line 447
  goto ldv_25943;
  case 8UL: 
#line 447
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
#line 447
  goto ldv_25943;
  default: 
#line 447
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
#line 447
  goto ldv_25943;
  }
  ldv_25943: ;
#line 447
  if (__ret_pu != 0) {
#line 448
    goto out_unlock_msg_ctx;
  } else {

  }
#line 449
  might_fault();
#line 449
  tmp___7 = __fswab32(msg_ctx->counter);
#line 449
  __pu_val___0 = tmp___7;
#line 449
  switch (4UL) {
  case 1UL: 
#line 449
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((__be32 *)buf + 1U): "ebx");
#line 449
  goto ldv_25952;
  case 2UL: 
#line 449
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((__be32 *)buf + 1U): "ebx");
#line 449
  goto ldv_25952;
  case 4UL: 
#line 449
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((__be32 *)buf + 1U): "ebx");
#line 449
  goto ldv_25952;
  case 8UL: 
#line 449
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((__be32 *)buf + 1U): "ebx");
#line 449
  goto ldv_25952;
  default: 
#line 449
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___0): "0" (__pu_val___0),
                       "c" ((__be32 *)buf + 1U): "ebx");
#line 449
  goto ldv_25952;
  }
  ldv_25952: ;
#line 449
  if (__ret_pu___0 != 0) {
#line 451
    goto out_unlock_msg_ctx;
  } else {

  }
#line 452
  i = 5UL;
#line 453
  if ((unsigned long )msg_ctx->msg != (unsigned long )((struct ecryptfs_message *)0)) {
#line 454
    tmp___8 = copy_to_user((void *)(buf + i), (void const   *)(& packet_length), (unsigned int )packet_length_size);
#line 454
    if (tmp___8 != 0) {
#line 455
      goto out_unlock_msg_ctx;
    } else {

    }
#line 456
    i = i + packet_length_size;
#line 457
    tmp___9 = copy_to_user((void *)(buf + i), (void const   *)msg_ctx->msg, (unsigned int )msg_ctx->msg_size);
#line 457
    if (tmp___9 != 0) {
#line 458
      goto out_unlock_msg_ctx;
    } else {

    }
#line 459
    i = msg_ctx->msg_size + i;
  } else {

  }
#line 461
  rc = (int )i;
#line 462
  list_del(& msg_ctx->daemon_out_list);
#line 463
  kfree((void const   *)msg_ctx->msg);
#line 464
  msg_ctx->msg = 0;
#line 467
  if ((unsigned int )msg_ctx->type != 102U) {
#line 468
    ecryptfs_msg_ctx_alloc_to_free(msg_ctx);
  } else {

  }
  out_unlock_msg_ctx: 
#line 470
  ldv_mutex_unlock_327(& msg_ctx->mux);
  out_unlock_daemon: 
#line 472
  daemon->flags = daemon->flags & 4294967294U;
#line 473
  ldv_mutex_unlock_328(& daemon->mux);
#line 474
  return ((ssize_t )rc);
}
}
#line 485 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
static int ecryptfs_miscdev_response(struct ecryptfs_daemon *daemon , char *data ,
                                     size_t data_size , u32 seq ) 
{ 
  struct ecryptfs_message *msg ;
  int rc ;

  {
#line 488
  msg = (struct ecryptfs_message *)data;
#line 491
  if ((unsigned long )msg->data_len + 8UL != data_size) {
#line 492
    printk("\f%s: (sizeof(*msg) + msg->data_len) = [%zd]; data_size = [%zd]. Invalid packet.\n",
           "ecryptfs_miscdev_response", (unsigned long )msg->data_len + 8UL, data_size);
#line 495
    rc = -22;
#line 496
    goto out;
  } else {

  }
#line 498
  rc = ecryptfs_process_response(daemon, msg, seq);
#line 499
  if (rc != 0) {
#line 500
    printk("\vError processing response message; rc = [%d]\n", rc);
  } else {

  }
  out: ;
#line 503
  return (rc);
}
}
#line 516 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
static ssize_t ecryptfs_miscdev_write(struct file *file , char const   *buf , size_t count ,
                                      loff_t *ppos ) 
{ 
  __be32 counter_nbo ;
  u32 seq ;
  size_t packet_size ;
  size_t packet_size_length ;
  char *data ;
  unsigned char packet_size_peek[2U] ;
  ssize_t rc ;
  unsigned long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  size_t __len ;
  void *__ret ;
  __u32 tmp___5 ;
  int tmp___6 ;

  {
#line 526
  if (count == 0UL) {
#line 527
    return (0L);
  } else
#line 528
  if (count == 5UL) {
#line 530
    goto memdup;
  } else
#line 531
  if (count <= 5UL || count > 531UL) {
#line 532
    printk("\f%s: Acceptable packet size range is [%d-%zu], but amount of data written is [%zu].",
           "ecryptfs_miscdev_write", 6, 531UL, count);
#line 535
    return (-22L);
  } else {

  }
#line 538
  tmp = copy_from_user((void *)(& packet_size_peek), (void const   *)buf + 5U, 2UL);
#line 538
  if (tmp != 0UL) {
#line 540
    printk("\f%s: Error while inspecting packet size\n", "ecryptfs_miscdev_write");
#line 542
    return (-14L);
  } else {

  }
#line 545
  tmp___0 = ecryptfs_parse_packet_length((unsigned char *)(& packet_size_peek), & packet_size,
                                         & packet_size_length);
#line 545
  rc = (ssize_t )tmp___0;
#line 547
  if (rc != 0L) {
#line 548
    printk("\f%s: Error parsing packet length; rc = [%zd]\n", "ecryptfs_miscdev_write",
           rc);
#line 550
    return (rc);
  } else {

  }
#line 553
  if ((packet_size_length + packet_size) + 5UL != count) {
#line 555
    printk("\f%s: Invalid packet size [%zu]\n", "ecryptfs_miscdev_write", packet_size);
#line 557
    return (-22L);
  } else {

  }
  memdup: 
#line 561
  tmp___1 = memdup_user((void const   *)buf, count);
#line 561
  data = (char *)tmp___1;
#line 562
  tmp___4 = IS_ERR((void const   *)data);
#line 562
  if (tmp___4 != 0L) {
#line 563
    tmp___2 = PTR_ERR((void const   *)data);
#line 563
    printk("\v%s: memdup_user returned error [%ld]\n", "ecryptfs_miscdev_write", tmp___2);
#line 565
    tmp___3 = PTR_ERR((void const   *)data);
#line 565
    return (tmp___3);
  } else {

  }
#line 567
  switch ((int )*data) {
  case 103: ;
#line 569
  if (count <= 13UL) {
#line 571
    printk("\f%s: Minimum acceptable packet size is [%zd], but amount of data written is only [%zd]. Discarding response packet.\n",
           "ecryptfs_miscdev_write", 14UL, count);
#line 577
    rc = -22L;
#line 578
    goto out_free;
  } else {

  }
#line 580
  __len = 4UL;
#line 580
  if (__len > 63UL) {
#line 580
    __ret = __memcpy((void *)(& counter_nbo), (void const   *)data + 1U, __len);
  } else {
#line 580
    __ret = __builtin_memcpy((void *)(& counter_nbo), (void const   *)data + 1U, __len);
  }
#line 581
  tmp___5 = __fswab32(counter_nbo);
#line 581
  seq = tmp___5;
#line 582
  tmp___6 = ecryptfs_miscdev_response((struct ecryptfs_daemon *)file->private_data,
                                      data + (packet_size_length + 5UL), packet_size,
                                      seq);
#line 582
  rc = (ssize_t )tmp___6;
#line 585
  if (rc != 0L) {
#line 586
    printk("\f%s: Failed to deliver miscdev response to requesting operation; rc = [%zd]\n",
           "ecryptfs_miscdev_write", rc);
#line 589
    goto out_free;
  } else {

  }
#line 591
  goto ldv_25988;
  case 100: ;
  case 101: ;
#line 594
  goto ldv_25988;
  default: 
#line 596
  __ecryptfs_printk("\f%s: Dropping miscdev message of unrecognized type [%d]\n",
                    "ecryptfs_miscdev_write", (int )*data);
#line 599
  rc = -22L;
#line 600
  goto out_free;
  }
  ldv_25988: 
#line 602
  rc = (ssize_t )count;
  out_free: 
#line 604
  kfree((void const   *)data);
#line 605
  return (rc);
}
}
#line 609 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
static struct file_operations  const  ecryptfs_miscdev_fops  = 
#line 609
     {0, & noop_llseek, & ecryptfs_miscdev_read, & ecryptfs_miscdev_write, 0, 0, 0,
    & ecryptfs_miscdev_poll, 0, 0, 0, & ecryptfs_miscdev_open, 0, & ecryptfs_miscdev_release,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 618 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
static struct miscdevice ecryptfs_miscdev  = 
#line 618
     {255, "ecryptfs", & ecryptfs_miscdev_fops, {0, 0}, 0, 0, 0, (unsigned short)0};
#line 634 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
int ecryptfs_init_ecryptfs_miscdev(void) 
{ 
  int rc ;

  {
#line 638
  atomic_set(& ecryptfs_num_miscdev_opens, 0);
#line 639
  rc = misc_register(& ecryptfs_miscdev);
#line 640
  if (rc != 0) {
#line 641
    printk("\v%s: Failed to register miscellaneous device for communications with userspace daemons; rc = [%d]\n",
           "ecryptfs_init_ecryptfs_miscdev", rc);
  } else {

  }
#line 644
  return (rc);
}
}
#line 653 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ecryptfs_destroy_ecryptfs_miscdev(void) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 655
  tmp = atomic_read((atomic_t const   *)(& ecryptfs_num_miscdev_opens));
#line 655
  tmp___0 = __builtin_expect(tmp != 0, 0L);
#line 655
  if (tmp___0 != 0L) {
#line 655
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"),
                         "i" (655), "i" (12UL));
    ldv_26002: ;
#line 655
    goto ldv_26002;
  } else {

  }
#line 656
  misc_deregister(& ecryptfs_miscdev);
#line 657
  return;
}
}
#line 696 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_main10_sequence_infinite_withcheck_stateful(void) 
{ 
  struct inode *var_group1 ;
  struct file *var_group2 ;
  int res_ecryptfs_miscdev_open_1 ;
  poll_table *var_ecryptfs_miscdev_poll_0_p1 ;
  char *var_ecryptfs_miscdev_read_4_p1 ;
  size_t var_ecryptfs_miscdev_read_4_p2 ;
  loff_t *var_ecryptfs_miscdev_read_4_p3 ;
  ssize_t res_ecryptfs_miscdev_read_4 ;
  char const   *var_ecryptfs_miscdev_write_6_p1 ;
  size_t var_ecryptfs_miscdev_write_6_p2 ;
  loff_t *var_ecryptfs_miscdev_write_6_p3 ;
  ssize_t res_ecryptfs_miscdev_write_6 ;
  int ldv_s_ecryptfs_miscdev_fops_file_operations ;
  int tmp ;
  int tmp___0 ;

  {
#line 822
  ldv_s_ecryptfs_miscdev_fops_file_operations = 0;
#line 812
  LDV_IN_INTERRUPT = 1;
#line 821
  ldv_initialize();
#line 826
  goto ldv_26041;
  ldv_26040: 
#line 830
  tmp = __VERIFIER_nondet_int();
#line 830
  switch (tmp) {
  case 0: ;
#line 835
  if (ldv_s_ecryptfs_miscdev_fops_file_operations == 0) {
#line 840
    ldv_handler_precall();
#line 841
    res_ecryptfs_miscdev_open_1 = ecryptfs_miscdev_open(var_group1, var_group2);
#line 842
    ldv_check_return_value(res_ecryptfs_miscdev_open_1);
#line 843
    if (res_ecryptfs_miscdev_open_1 != 0) {
#line 844
      goto ldv_module_exit;
    } else {

    }
#line 859
    ldv_s_ecryptfs_miscdev_fops_file_operations = ldv_s_ecryptfs_miscdev_fops_file_operations + 1;
  } else {

  }
#line 865
  goto ldv_26034;
  case 1: ;
#line 869
  if (ldv_s_ecryptfs_miscdev_fops_file_operations == 1) {
#line 887
    ldv_handler_precall();
#line 888
    res_ecryptfs_miscdev_read_4 = ecryptfs_miscdev_read(var_group2, var_ecryptfs_miscdev_read_4_p1,
                                                        var_ecryptfs_miscdev_read_4_p2,
                                                        var_ecryptfs_miscdev_read_4_p3);
#line 889
    ldv_check_return_value((int )res_ecryptfs_miscdev_read_4);
#line 890
    if (res_ecryptfs_miscdev_read_4 < 0L) {
#line 891
      goto ldv_module_exit;
    } else {

    }
#line 892
    ldv_s_ecryptfs_miscdev_fops_file_operations = ldv_s_ecryptfs_miscdev_fops_file_operations + 1;
  } else {

  }
#line 898
  goto ldv_26034;
  case 2: ;
#line 902
  if (ldv_s_ecryptfs_miscdev_fops_file_operations == 2) {
#line 920
    ldv_handler_precall();
#line 921
    res_ecryptfs_miscdev_write_6 = ecryptfs_miscdev_write(var_group2, var_ecryptfs_miscdev_write_6_p1,
                                                          var_ecryptfs_miscdev_write_6_p2,
                                                          var_ecryptfs_miscdev_write_6_p3);
#line 922
    ldv_check_return_value((int )res_ecryptfs_miscdev_write_6);
#line 923
    if (res_ecryptfs_miscdev_write_6 < 0L) {
#line 924
      goto ldv_module_exit;
    } else {

    }
#line 925
    ldv_s_ecryptfs_miscdev_fops_file_operations = ldv_s_ecryptfs_miscdev_fops_file_operations + 1;
  } else {

  }
#line 931
  goto ldv_26034;
  case 3: ;
#line 935
  if (ldv_s_ecryptfs_miscdev_fops_file_operations == 3) {
#line 940
    ldv_handler_precall();
#line 941
    ecryptfs_miscdev_release(var_group1, var_group2);
#line 956
    ldv_s_ecryptfs_miscdev_fops_file_operations = 0;
  } else {

  }
#line 962
  goto ldv_26034;
  case 4: 
#line 971
  ldv_handler_precall();
#line 972
  ecryptfs_miscdev_poll(var_group2, var_ecryptfs_miscdev_poll_0_p1);
#line 993
  goto ldv_26034;
  default: ;
#line 994
  goto ldv_26034;
  }
  ldv_26034: ;
  ldv_26041: 
#line 826
  tmp___0 = __VERIFIER_nondet_int();
#line 826
  if (tmp___0 != 0 || ldv_s_ecryptfs_miscdev_fops_file_operations != 0) {
#line 828
    goto ldv_26040;
  } else {

  }

  ldv_module_exit: ;
#line 1003
  ldv_check_final_state();
#line 1006
  return;
}
}
#line 1010 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_303(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1015
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1017
  mutex_lock(ldv_func_arg1);
#line 1018
  return;
}
}
#line 1020 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_304(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1025
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1027
  mutex_unlock(ldv_func_arg1);
#line 1028
  return;
}
}
#line 1030 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_305(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1035
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 1037
  mutex_lock(ldv_func_arg1);
#line 1038
  return;
}
}
#line 1040 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1045
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 1047
  mutex_unlock(ldv_func_arg1);
#line 1048
  return;
}
}
#line 1050 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_307(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1055
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 1057
  mutex_lock(ldv_func_arg1);
#line 1058
  return;
}
}
#line 1060 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_308(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1065
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 1067
  mutex_unlock(ldv_func_arg1);
#line 1068
  return;
}
}
#line 1070 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_309(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1075
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 1077
  mutex_lock(ldv_func_arg1);
#line 1078
  return;
}
}
#line 1080 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_310(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1085
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 1087
  mutex_unlock(ldv_func_arg1);
#line 1088
  return;
}
}
#line 1090 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_311(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1095
  ldv_mutex_lock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 1097
  mutex_lock(ldv_func_arg1);
#line 1098
  return;
}
}
#line 1100 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_312(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1105
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 1107
  mutex_lock(ldv_func_arg1);
#line 1108
  return;
}
}
#line 1110 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_313(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1115
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 1117
  mutex_unlock(ldv_func_arg1);
#line 1118
  return;
}
}
#line 1120 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_314(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1125
  ldv_mutex_unlock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 1127
  mutex_unlock(ldv_func_arg1);
#line 1128
  return;
}
}
#line 1130 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_315(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1135
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 1137
  mutex_lock(ldv_func_arg1);
#line 1138
  return;
}
}
#line 1140 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_316(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1145
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 1147
  mutex_unlock(ldv_func_arg1);
#line 1148
  return;
}
}
#line 1150 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_317(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1155
  ldv_mutex_lock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 1157
  mutex_lock(ldv_func_arg1);
#line 1158
  return;
}
}
#line 1160 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_318(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1165
  ldv_mutex_unlock_ecryptfs_daemon_hash_mux(ldv_func_arg1);
#line 1167
  mutex_unlock(ldv_func_arg1);
#line 1168
  return;
}
}
#line 1170 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_319(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1175
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 1177
  mutex_lock(ldv_func_arg1);
#line 1178
  return;
}
}
#line 1180 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_320(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1185
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 1187
  mutex_unlock(ldv_func_arg1);
#line 1188
  return;
}
}
#line 1190 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_321(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1195
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 1197
  mutex_lock(ldv_func_arg1);
#line 1198
  return;
}
}
#line 1200 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_322(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1205
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 1207
  mutex_unlock(ldv_func_arg1);
#line 1208
  return;
}
}
#line 1210 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_323(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1215
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 1217
  mutex_lock(ldv_func_arg1);
#line 1218
  return;
}
}
#line 1220 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_324(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1225
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 1227
  mutex_unlock(ldv_func_arg1);
#line 1228
  return;
}
}
#line 1230 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_325(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1235
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 1237
  mutex_lock(ldv_func_arg1);
#line 1238
  return;
}
}
#line 1240 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_lock_326(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1245
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 1247
  mutex_lock(ldv_func_arg1);
#line 1248
  return;
}
}
#line 1250 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_327(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1255
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 1257
  mutex_unlock(ldv_func_arg1);
#line 1258
  return;
}
}
#line 1260 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/miscdev.c.prepared"
void ldv_mutex_unlock_328(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1265
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 1267
  mutex_unlock(ldv_func_arg1);
#line 1268
  return;
}
}
#line 172 "include/linux/mutex.h"
void ldv_mutex_unlock_356(struct mutex *ldv_func_arg1 ) ;
#line 176
void ldv_mutex_unlock_358(struct mutex *ldv_func_arg1 ) ;
#line 180
void ldv_mutex_unlock_360(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_361(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_363(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_365(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_366(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_lock_355(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_357(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_359(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_362(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_364(struct mutex *ldv_func_arg1 ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 79
extern void wait_for_completion(struct completion * ) ;
#line 91
extern void complete(struct completion * ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 42
extern bool kthread_should_stop(void) ;
#line 11 "include/linux/freezer.h"
extern atomic_t system_freezing_cnt ;
#line 23
extern bool freezing_slow_path(struct task_struct * ) ;
#line 28 "include/linux/freezer.h"
__inline static bool freezing(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 30
  tmp = atomic_read((atomic_t const   *)(& system_freezing_cnt));
#line 30
  tmp___0 = __builtin_expect(tmp == 0, 1L);
#line 30
  if (tmp___0 != 0L) {
#line 31
    return (0);
  } else {

  }
#line 32
  tmp___1 = freezing_slow_path(p);
#line 32
  return (tmp___1);
}
}
#line 38
extern bool __refrigerator(bool  ) ;
#line 44 "include/linux/freezer.h"
__inline static bool try_to_freeze(void) 
{ 
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;

  {
#line 46
  __might_sleep("include/linux/freezer.h", 46, 0);
#line 47
  tmp = get_current();
#line 47
  tmp___0 = freezing(tmp);
#line 47
  if (tmp___0) {
#line 47
    tmp___1 = 0;
  } else {
#line 47
    tmp___1 = 1;
  }
#line 47
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
#line 47
  if (tmp___2 != 0L) {
#line 48
    return (0);
  } else {

  }
#line 49
  tmp___3 = __refrigerator(0);
#line 49
  return (tmp___3);
}
}
#line 53
extern bool set_freezable(void) ;
#line 2008 "include/linux/fs.h"
extern struct file *dentry_open(struct path  const  * , int  , struct cred  const  * ) ;
#line 178 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
static struct ecryptfs_kthread_ctl ecryptfs_kthread_ctl  ;
#line 180 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
static struct task_struct *ecryptfs_kthread  ;
#line 191 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
static int ecryptfs_threadfn(void *ignored ) 
{ 
  struct ecryptfs_open_req *req ;
  int __retval ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct task_struct *tmp___2 ;
  bool tmp___3 ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  struct task_struct *tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  struct list_head  const  *__mptr ;
  int tmp___14 ;
  struct task_struct *tmp___15 ;
  int tmp___16 ;

  {
#line 193
  set_freezable();
  ldv_24807: ;
  ldv_24797: 
#line 197
  __ret = 0;
#line 197
  tmp___6 = list_empty((struct list_head  const  *)(& ecryptfs_kthread_ctl.req_list));
#line 197
  if (tmp___6 != 0) {
#line 197
    tmp___7 = kthread_should_stop();
#line 197
    if (tmp___7) {
#line 197
      tmp___8 = 0;
    } else {
#line 197
      tmp___8 = 1;
    }
#line 197
    if (tmp___8) {
#line 197
      tmp___9 = get_current();
#line 197
      tmp___10 = freezing(tmp___9);
#line 197
      if (tmp___10) {
#line 197
        tmp___11 = 0;
      } else {
#line 197
        tmp___11 = 1;
      }
#line 197
      if (tmp___11) {
#line 197
        tmp = get_current();
#line 197
        __wait.flags = 0U;
#line 197
        __wait.private = (void *)tmp;
#line 197
        __wait.func = & autoremove_wake_function;
#line 197
        __wait.task_list.next = & __wait.task_list;
#line 197
        __wait.task_list.prev = & __wait.task_list;
        ldv_24794: 
#line 197
        prepare_to_wait(& ecryptfs_kthread_ctl.wait, & __wait, 1);
#line 197
        tmp___0 = list_empty((struct list_head  const  *)(& ecryptfs_kthread_ctl.req_list));
#line 197
        if (tmp___0 == 0) {
#line 197
          goto ldv_24792;
        } else {
#line 197
          tmp___1 = kthread_should_stop();
#line 197
          if ((int )tmp___1) {
#line 197
            goto ldv_24792;
          } else {
#line 197
            tmp___2 = get_current();
#line 197
            tmp___3 = freezing(tmp___2);
#line 197
            if ((int )tmp___3) {
#line 197
              goto ldv_24792;
            } else {

            }
          }
        }
#line 197
        tmp___4 = get_current();
#line 197
        tmp___5 = signal_pending(tmp___4);
#line 197
        if (tmp___5 == 0) {
#line 197
          schedule();
#line 197
          goto ldv_24793;
        } else {

        }
#line 197
        __ret = -512;
#line 197
        goto ldv_24792;
        ldv_24793: ;
#line 197
        goto ldv_24794;
        ldv_24792: 
#line 197
        finish_wait(& ecryptfs_kthread_ctl.wait, & __wait);
      } else {

      }
    } else {

    }
  } else {

  }
#line 197
  __retval = __ret;
#line 197
  if (__retval != 0) {
#line 197
    goto ldv_24796;
  } else {
#line 197
    tmp___12 = list_empty((struct list_head  const  *)(& ecryptfs_kthread_ctl.req_list));
#line 197
    if (tmp___12 == 0) {
#line 197
      goto ldv_24796;
    } else {
#line 197
      tmp___13 = kthread_should_stop();
#line 197
      if ((int )tmp___13) {
#line 197
        goto ldv_24796;
      } else {

      }
    }
  }
#line 197
  try_to_freeze();
#line 197
  goto ldv_24797;
  ldv_24796: 
#line 201
  ldv_mutex_lock_359(& ecryptfs_kthread_ctl.mux);
#line 202
  if ((int )ecryptfs_kthread_ctl.flags & 1) {
#line 203
    ldv_mutex_unlock_360(& ecryptfs_kthread_ctl.mux);
#line 204
    goto out;
  } else {

  }
#line 206
  goto ldv_24805;
  ldv_24804: 
#line 207
  __mptr = (struct list_head  const  *)ecryptfs_kthread_ctl.req_list.next;
#line 207
  req = (struct ecryptfs_open_req *)__mptr + 0xffffffffffffff88UL;
#line 210
  list_del(& req->kthread_ctl_list);
#line 212
  tmp___14 = debug_lockdep_rcu_enabled();
#line 212
  tmp___15 = get_current();
#line 212
  *(req->lower_file) = dentry_open((struct path  const  *)(& req->path), 32770, tmp___15->cred);
#line 213
  complete(& req->done);
  ldv_24805: 
#line 206
  tmp___16 = list_empty((struct list_head  const  *)(& ecryptfs_kthread_ctl.req_list));
#line 206
  if (tmp___16 == 0) {
#line 207
    goto ldv_24804;
  } else {

  }
#line 215
  ldv_mutex_unlock_361(& ecryptfs_kthread_ctl.mux);
#line 216
  goto ldv_24807;
  out: ;
#line 218
  return (0);
}
}
#line 221 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
int ecryptfs_init_kthread(void) 
{ 
  int rc ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct task_struct *__k ;
  struct task_struct *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 223
  rc = 0;
#line 225
  __mutex_init(& ecryptfs_kthread_ctl.mux, "&ecryptfs_kthread_ctl.mux", & __key);
#line 226
  __init_waitqueue_head(& ecryptfs_kthread_ctl.wait, "&ecryptfs_kthread_ctl.wait",
                        & __key___0);
#line 227
  INIT_LIST_HEAD(& ecryptfs_kthread_ctl.req_list);
#line 228
  tmp = kthread_create_on_node(& ecryptfs_threadfn, 0, -1, "ecryptfs-kthread");
#line 228
  __k = tmp;
#line 228
  tmp___0 = IS_ERR((void const   *)__k);
#line 228
  if (tmp___0 == 0L) {
#line 228
    wake_up_process(__k);
  } else {

  }
#line 228
  ecryptfs_kthread = __k;
#line 230
  tmp___2 = IS_ERR((void const   *)ecryptfs_kthread);
#line 230
  if (tmp___2 != 0L) {
#line 231
    tmp___1 = PTR_ERR((void const   *)ecryptfs_kthread);
#line 231
    rc = (int )tmp___1;
#line 232
    printk("\v%s: Failed to create kernel thread; rc = [%d]\n", "ecryptfs_init_kthread",
           rc);
  } else {

  }
#line 235
  return (rc);
}
}
#line 238 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ecryptfs_destroy_kthread(void) 
{ 
  struct ecryptfs_open_req *req ;
  struct list_head  const  *__mptr ;
  void *tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 242
  ldv_mutex_lock_362(& ecryptfs_kthread_ctl.mux);
#line 243
  ecryptfs_kthread_ctl.flags = ecryptfs_kthread_ctl.flags | 1U;
#line 244
  __mptr = (struct list_head  const  *)ecryptfs_kthread_ctl.req_list.next;
#line 244
  req = (struct ecryptfs_open_req *)__mptr + 0xffffffffffffff88UL;
#line 244
  goto ldv_24826;
  ldv_24825: 
#line 246
  list_del(& req->kthread_ctl_list);
#line 247
  tmp = ERR_PTR(-5L);
#line 247
  *(req->lower_file) = (struct file *)tmp;
#line 248
  complete(& req->done);
#line 244
  __mptr___0 = (struct list_head  const  *)req->kthread_ctl_list.next;
#line 244
  req = (struct ecryptfs_open_req *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_24826: ;
#line 244
  if ((unsigned long )(& req->kthread_ctl_list) != (unsigned long )(& ecryptfs_kthread_ctl.req_list)) {
#line 245
    goto ldv_24825;
  } else {

  }
#line 250
  ldv_mutex_unlock_363(& ecryptfs_kthread_ctl.mux);
#line 251
  kthread_stop(ecryptfs_kthread);
#line 252
  __wake_up(& ecryptfs_kthread_ctl.wait, 3U, 1, 0);
#line 253
  return;
}
}
#line 265 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
int ecryptfs_privileged_open(struct file **lower_file , struct dentry *lower_dentry ,
                             struct vfsmount *lower_mnt , struct cred  const  *cred ) 
{ 
  struct ecryptfs_open_req req ;
  int flags ;
  int rc ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 271
  flags = 32768;
#line 272
  rc = 0;
#line 274
  init_completion(& req.done);
#line 275
  req.lower_file = lower_file;
#line 276
  req.path.dentry = lower_dentry;
#line 277
  req.path.mnt = lower_mnt;
#line 282
  flags = ((int )((lower_dentry->d_inode)->i_sb)->s_flags & 1 ? 0 : 2) | flags;
#line 283
  *lower_file = dentry_open((struct path  const  *)(& req.path), flags, cred);
#line 284
  tmp = IS_ERR((void const   *)*lower_file);
#line 284
  if (tmp == 0L) {
#line 285
    goto out;
  } else {

  }
#line 286
  if ((flags & 3) == 0) {
#line 287
    tmp___0 = PTR_ERR((void const   *)*lower_file);
#line 287
    rc = (int )tmp___0;
#line 288
    goto out;
  } else {

  }
#line 290
  ldv_mutex_lock_364(& ecryptfs_kthread_ctl.mux);
#line 291
  if ((int )ecryptfs_kthread_ctl.flags & 1) {
#line 292
    rc = -5;
#line 293
    ldv_mutex_unlock_365(& ecryptfs_kthread_ctl.mux);
#line 294
    printk("\v%s: We are in the middle of shutting down; aborting privileged request to open lower file\n",
           "ecryptfs_privileged_open");
#line 297
    goto out;
  } else {

  }
#line 299
  list_add_tail(& req.kthread_ctl_list, & ecryptfs_kthread_ctl.req_list);
#line 300
  ldv_mutex_unlock_366(& ecryptfs_kthread_ctl.mux);
#line 301
  __wake_up(& ecryptfs_kthread_ctl.wait, 3U, 1, 0);
#line 302
  wait_for_completion(& req.done);
#line 303
  tmp___2 = IS_ERR((void const   *)*lower_file);
#line 303
  if (tmp___2 != 0L) {
#line 304
    tmp___1 = PTR_ERR((void const   *)*lower_file);
#line 304
    rc = (int )tmp___1;
  } else {

  }
  out: ;
#line 306
  return (rc);
}
}
#line 309 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_lock_355(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 314
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 316
  mutex_lock(ldv_func_arg1);
#line 317
  return;
}
}
#line 319 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_unlock_356(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 324
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 326
  mutex_unlock(ldv_func_arg1);
#line 327
  return;
}
}
#line 329 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_lock_357(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 334
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 336
  mutex_lock(ldv_func_arg1);
#line 337
  return;
}
}
#line 339 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_unlock_358(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 344
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 346
  mutex_unlock(ldv_func_arg1);
#line 347
  return;
}
}
#line 349 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_lock_359(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 354
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 356
  mutex_lock(ldv_func_arg1);
#line 357
  return;
}
}
#line 359 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_unlock_360(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 364
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 366
  mutex_unlock(ldv_func_arg1);
#line 367
  return;
}
}
#line 369 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_unlock_361(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 374
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 376
  mutex_unlock(ldv_func_arg1);
#line 377
  return;
}
}
#line 379 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_lock_362(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 384
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 386
  mutex_lock(ldv_func_arg1);
#line 387
  return;
}
}
#line 389 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_unlock_363(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 394
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 396
  mutex_unlock(ldv_func_arg1);
#line 397
  return;
}
}
#line 399 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_lock_364(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 404
  ldv_mutex_lock_mux(ldv_func_arg1);
#line 406
  mutex_lock(ldv_func_arg1);
#line 407
  return;
}
}
#line 409 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_unlock_365(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 414
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 416
  mutex_unlock(ldv_func_arg1);
#line 417
  return;
}
}
#line 419 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/kthread.c.prepared"
void ldv_mutex_unlock_366(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 424
  ldv_mutex_unlock_mux(ldv_func_arg1);
#line 426
  mutex_unlock(ldv_func_arg1);
#line 427
  return;
}
}
#line 172 "include/linux/mutex.h"
void ldv_mutex_unlock_380(struct mutex *ldv_func_arg1 ) ;
#line 10 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/debug.c.prepared"
void ldv_mutex_lock_379(struct mutex *ldv_func_arg1 ) ;
#line 167 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/debug.c.prepared"
void ecryptfs_dump_auth_tok(struct ecryptfs_auth_tok *auth_tok ) 
{ 
  char salt[17U] ;
  char sig[17U] ;
  size_t __len ;
  void *__ret ;

  {
#line 172
  __ecryptfs_printk("\017%s: Auth tok at mem loc [%p]:\n", "ecryptfs_dump_auth_tok",
                    auth_tok);
#line 174
  if ((int )auth_tok->flags & 1) {
#line 175
    __ecryptfs_printk("\017%s:  * private key type\n", "ecryptfs_dump_auth_tok");
  } else {
#line 177
    __ecryptfs_printk("\017%s:  * passphrase type\n", "ecryptfs_dump_auth_tok");
#line 178
    ecryptfs_to_hex((char *)(& salt), (char *)(& auth_tok->token.password.salt), 8UL);
#line 180
    salt[16] = 0;
#line 181
    __ecryptfs_printk("\017%s:  * salt = [%s]\n", "ecryptfs_dump_auth_tok", (char *)(& salt));
#line 182
    if ((int )auth_tok->token.password.flags & 1) {
#line 184
      __ecryptfs_printk("\017%s:  * persistent\n", "ecryptfs_dump_auth_tok");
    } else {

    }
#line 186
    __len = 16UL;
#line 186
    if (__len > 63UL) {
#line 186
      __ret = __memcpy((void *)(& sig), (void const   *)(& auth_tok->token.password.signature),
                       __len);
    } else {
#line 186
      __ret = __builtin_memcpy((void *)(& sig), (void const   *)(& auth_tok->token.password.signature),
                               __len);
    }
#line 188
    sig[16] = 0;
#line 189
    __ecryptfs_printk("\017%s:  * signature = [%s]\n", "ecryptfs_dump_auth_tok", (char *)(& sig));
  }
#line 191
  __ecryptfs_printk("\017%s:  * session_key.flags = [0x%x]\n", "ecryptfs_dump_auth_tok",
                    auth_tok->session_key.flags);
#line 193
  if ((int )auth_tok->session_key.flags & 1) {
#line 195
    __ecryptfs_printk("\017%s:  * Userspace decrypt request set\n", "ecryptfs_dump_auth_tok");
  } else {

  }
#line 197
  if ((auth_tok->session_key.flags & 2U) != 0U) {
#line 199
    __ecryptfs_printk("\017%s:  * Userspace encrypt request set\n", "ecryptfs_dump_auth_tok");
  } else {

  }
#line 201
  if ((auth_tok->session_key.flags & 4U) != 0U) {
#line 202
    __ecryptfs_printk("\017%s:  * Contains decrypted key\n", "ecryptfs_dump_auth_tok");
#line 203
    __ecryptfs_printk("\017%s:  * session_key.decrypted_key_size = [0x%x]\n", "ecryptfs_dump_auth_tok",
                      auth_tok->session_key.decrypted_key_size);
#line 206
    __ecryptfs_printk("\017%s:  * Decrypted session key dump:\n", "ecryptfs_dump_auth_tok");
#line 208
    if (ecryptfs_verbosity > 0) {
#line 209
      ecryptfs_dump_hex((char *)(& auth_tok->session_key.decrypted_key), 16);
    } else {

    }
  } else {

  }
#line 212
  if ((auth_tok->session_key.flags & 8U) != 0U) {
#line 213
    __ecryptfs_printk("\017%s:  * Contains encrypted key\n", "ecryptfs_dump_auth_tok");
#line 214
    __ecryptfs_printk("\017%s:  * session_key.encrypted_key_size = [0x%x]\n", "ecryptfs_dump_auth_tok",
                      auth_tok->session_key.encrypted_key_size);
#line 217
    __ecryptfs_printk("\017%s:  * Encrypted session key dump:\n", "ecryptfs_dump_auth_tok");
#line 219
    if (ecryptfs_verbosity > 0) {
#line 220
      ecryptfs_dump_hex((char *)(& auth_tok->session_key.encrypted_key), (int )auth_tok->session_key.encrypted_key_size);
    } else {

    }
  } else {

  }
#line 223
  return;
}
}
#line 233 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/debug.c.prepared"
void ecryptfs_dump_hex(char *data , int bytes ) 
{ 
  int i ;
  int add_newline ;

  {
#line 235
  i = 0;
#line 236
  add_newline = 1;
#line 238
  if (ecryptfs_verbosity <= 0) {
#line 239
    return;
  } else {

  }
#line 240
  if (bytes != 0) {
#line 241
    printk("xx%.2x.", (int )((unsigned char )*(data + (unsigned long )i)));
#line 242
    i = i + 1;
  } else {

  }
#line 244
  goto ldv_23976;
  ldv_23975: 
#line 245
  printk("0x%.2x.", (int )((unsigned char )*(data + (unsigned long )i)));
#line 246
  i = i + 1;
#line 247
  if (((unsigned int )i & 15U) == 0U) {
#line 248
    printk("\n");
#line 249
    add_newline = 0;
  } else {
#line 251
    add_newline = 1;
  }
  ldv_23976: ;
#line 244
  if (i < bytes) {
#line 245
    goto ldv_23975;
  } else {

  }

#line 253
  if (add_newline != 0) {
#line 254
    printk("\n");
  } else {

  }
#line 255
  return;
}
}
#line 257 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/debug.c.prepared"
void ldv_mutex_lock_379(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 262
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 264
  mutex_lock(ldv_func_arg1);
#line 265
  return;
}
}
#line 267 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/dscv/ri/32_7a/fs/ecryptfs/debug.c.prepared"
void ldv_mutex_unlock_380(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 272
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 274
  mutex_unlock(ldv_func_arg1);
#line 275
  return;
}
}
#line 10 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: 
#line 12
  goto ERROR;
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 51
  return (exp);
}
}
#line 8 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cred_guard_mutex  ;
#line 11 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_cred_guard_mutex = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_cred_guard_mutex = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cred_guard_mutex(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_cred_guard_mutex = 2;
#line 69
  return;
}
}
#line 72 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cred_guard_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_cred_guard_mutex = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cred_guard_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_cred_guard_mutex = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_cred_guard_mutex == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cred_guard_mutex(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_cred_guard_mutex == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_cred_guard_mutex = 1;
#line 158
  return;
}
}
#line 160 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cs_hash_tfm_mutex  ;
#line 163 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cs_hash_tfm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 168
  if (ldv_mutex_cs_hash_tfm_mutex == 1) {

  } else {
#line 168
    ldv_error();
  }
#line 171
  nondetermined = __VERIFIER_nondet_int();
#line 174
  if (nondetermined) {
#line 177
    ldv_mutex_cs_hash_tfm_mutex = 2;
#line 179
    return (0);
  } else {
#line 184
    return (-4);
  }
}
}
#line 189 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cs_hash_tfm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 194
  if (ldv_mutex_cs_hash_tfm_mutex == 1) {

  } else {
#line 194
    ldv_error();
  }
#line 197
  nondetermined = __VERIFIER_nondet_int();
#line 200
  if (nondetermined) {
#line 203
    ldv_mutex_cs_hash_tfm_mutex = 2;
#line 205
    return (0);
  } else {
#line 210
    return (-4);
  }
}
}
#line 215 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cs_hash_tfm_mutex(struct mutex *lock ) 
{ 


  {
#line 218
  if (ldv_mutex_cs_hash_tfm_mutex == 1) {

  } else {
#line 218
    ldv_error();
  }
#line 220
  ldv_mutex_cs_hash_tfm_mutex = 2;
#line 221
  return;
}
}
#line 224 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cs_hash_tfm_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 229
  if (ldv_mutex_cs_hash_tfm_mutex == 1) {

  } else {
#line 229
    ldv_error();
  }
#line 232
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 235
  if (is_mutex_held_by_another_thread) {
#line 238
    return (0);
  } else {
#line 243
    ldv_mutex_cs_hash_tfm_mutex = 2;
#line 245
    return (1);
  }
}
}
#line 250 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cs_hash_tfm_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 255
  if (ldv_mutex_cs_hash_tfm_mutex == 1) {

  } else {
#line 255
    ldv_error();
  }
#line 258
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 261
  if (atomic_value_after_dec == 0) {
#line 264
    ldv_mutex_cs_hash_tfm_mutex = 2;
#line 266
    return (1);
  } else {

  }
#line 270
  return (0);
}
}
#line 275 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cs_hash_tfm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 279
  if (ldv_mutex_cs_hash_tfm_mutex == 1) {
#line 282
    nondetermined = __VERIFIER_nondet_int();
#line 285
    if (nondetermined) {
#line 288
      return (0);
    } else {
#line 293
      return (1);
    }
  } else {
#line 299
    return (1);
  }
}
}
#line 304 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cs_hash_tfm_mutex(struct mutex *lock ) 
{ 


  {
#line 307
  if (ldv_mutex_cs_hash_tfm_mutex == 2) {

  } else {
#line 307
    ldv_error();
  }
#line 309
  ldv_mutex_cs_hash_tfm_mutex = 1;
#line 310
  return;
}
}
#line 312 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cs_mutex  ;
#line 315 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cs_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 320
  if (ldv_mutex_cs_mutex == 1) {

  } else {
#line 320
    ldv_error();
  }
#line 323
  nondetermined = __VERIFIER_nondet_int();
#line 326
  if (nondetermined) {
#line 329
    ldv_mutex_cs_mutex = 2;
#line 331
    return (0);
  } else {
#line 336
    return (-4);
  }
}
}
#line 341 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cs_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 346
  if (ldv_mutex_cs_mutex == 1) {

  } else {
#line 346
    ldv_error();
  }
#line 349
  nondetermined = __VERIFIER_nondet_int();
#line 352
  if (nondetermined) {
#line 355
    ldv_mutex_cs_mutex = 2;
#line 357
    return (0);
  } else {
#line 362
    return (-4);
  }
}
}
#line 367 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cs_mutex(struct mutex *lock ) 
{ 


  {
#line 370
  if (ldv_mutex_cs_mutex == 1) {

  } else {
#line 370
    ldv_error();
  }
#line 372
  ldv_mutex_cs_mutex = 2;
#line 373
  return;
}
}
#line 376 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cs_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 381
  if (ldv_mutex_cs_mutex == 1) {

  } else {
#line 381
    ldv_error();
  }
#line 384
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 387
  if (is_mutex_held_by_another_thread) {
#line 390
    return (0);
  } else {
#line 395
    ldv_mutex_cs_mutex = 2;
#line 397
    return (1);
  }
}
}
#line 402 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cs_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 407
  if (ldv_mutex_cs_mutex == 1) {

  } else {
#line 407
    ldv_error();
  }
#line 410
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 413
  if (atomic_value_after_dec == 0) {
#line 416
    ldv_mutex_cs_mutex = 2;
#line 418
    return (1);
  } else {

  }
#line 422
  return (0);
}
}
#line 427 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cs_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 431
  if (ldv_mutex_cs_mutex == 1) {
#line 434
    nondetermined = __VERIFIER_nondet_int();
#line 437
    if (nondetermined) {
#line 440
      return (0);
    } else {
#line 445
      return (1);
    }
  } else {
#line 451
    return (1);
  }
}
}
#line 456 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cs_mutex(struct mutex *lock ) 
{ 


  {
#line 459
  if (ldv_mutex_cs_mutex == 2) {

  } else {
#line 459
    ldv_error();
  }
#line 461
  ldv_mutex_cs_mutex = 1;
#line 462
  return;
}
}
#line 464 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cs_tfm_mutex  ;
#line 467 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cs_tfm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 472
  if (ldv_mutex_cs_tfm_mutex == 1) {

  } else {
#line 472
    ldv_error();
  }
#line 475
  nondetermined = __VERIFIER_nondet_int();
#line 478
  if (nondetermined) {
#line 481
    ldv_mutex_cs_tfm_mutex = 2;
#line 483
    return (0);
  } else {
#line 488
    return (-4);
  }
}
}
#line 493 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cs_tfm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 498
  if (ldv_mutex_cs_tfm_mutex == 1) {

  } else {
#line 498
    ldv_error();
  }
#line 501
  nondetermined = __VERIFIER_nondet_int();
#line 504
  if (nondetermined) {
#line 507
    ldv_mutex_cs_tfm_mutex = 2;
#line 509
    return (0);
  } else {
#line 514
    return (-4);
  }
}
}
#line 519 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cs_tfm_mutex(struct mutex *lock ) 
{ 


  {
#line 522
  if (ldv_mutex_cs_tfm_mutex == 1) {

  } else {
#line 522
    ldv_error();
  }
#line 524
  ldv_mutex_cs_tfm_mutex = 2;
#line 525
  return;
}
}
#line 528 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cs_tfm_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 533
  if (ldv_mutex_cs_tfm_mutex == 1) {

  } else {
#line 533
    ldv_error();
  }
#line 536
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 539
  if (is_mutex_held_by_another_thread) {
#line 542
    return (0);
  } else {
#line 547
    ldv_mutex_cs_tfm_mutex = 2;
#line 549
    return (1);
  }
}
}
#line 554 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cs_tfm_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 559
  if (ldv_mutex_cs_tfm_mutex == 1) {

  } else {
#line 559
    ldv_error();
  }
#line 562
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 565
  if (atomic_value_after_dec == 0) {
#line 568
    ldv_mutex_cs_tfm_mutex = 2;
#line 570
    return (1);
  } else {

  }
#line 574
  return (0);
}
}
#line 579 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cs_tfm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 583
  if (ldv_mutex_cs_tfm_mutex == 1) {
#line 586
    nondetermined = __VERIFIER_nondet_int();
#line 589
    if (nondetermined) {
#line 592
      return (0);
    } else {
#line 597
      return (1);
    }
  } else {
#line 603
    return (1);
  }
}
}
#line 608 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cs_tfm_mutex(struct mutex *lock ) 
{ 


  {
#line 611
  if (ldv_mutex_cs_tfm_mutex == 2) {

  } else {
#line 611
    ldv_error();
  }
#line 613
  ldv_mutex_cs_tfm_mutex = 1;
#line 614
  return;
}
}
#line 616 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_ecryptfs_daemon_hash_mux  ;
#line 619 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_ecryptfs_daemon_hash_mux(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 624
  if (ldv_mutex_ecryptfs_daemon_hash_mux == 1) {

  } else {
#line 624
    ldv_error();
  }
#line 627
  nondetermined = __VERIFIER_nondet_int();
#line 630
  if (nondetermined) {
#line 633
    ldv_mutex_ecryptfs_daemon_hash_mux = 2;
#line 635
    return (0);
  } else {
#line 640
    return (-4);
  }
}
}
#line 645 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_ecryptfs_daemon_hash_mux(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 650
  if (ldv_mutex_ecryptfs_daemon_hash_mux == 1) {

  } else {
#line 650
    ldv_error();
  }
#line 653
  nondetermined = __VERIFIER_nondet_int();
#line 656
  if (nondetermined) {
#line 659
    ldv_mutex_ecryptfs_daemon_hash_mux = 2;
#line 661
    return (0);
  } else {
#line 666
    return (-4);
  }
}
}
#line 671 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_ecryptfs_daemon_hash_mux(struct mutex *lock ) 
{ 


  {
#line 674
  if (ldv_mutex_ecryptfs_daemon_hash_mux == 1) {

  } else {
#line 674
    ldv_error();
  }
#line 676
  ldv_mutex_ecryptfs_daemon_hash_mux = 2;
#line 677
  return;
}
}
#line 680 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_ecryptfs_daemon_hash_mux(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 685
  if (ldv_mutex_ecryptfs_daemon_hash_mux == 1) {

  } else {
#line 685
    ldv_error();
  }
#line 688
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 691
  if (is_mutex_held_by_another_thread) {
#line 694
    return (0);
  } else {
#line 699
    ldv_mutex_ecryptfs_daemon_hash_mux = 2;
#line 701
    return (1);
  }
}
}
#line 706 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_ecryptfs_daemon_hash_mux(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 711
  if (ldv_mutex_ecryptfs_daemon_hash_mux == 1) {

  } else {
#line 711
    ldv_error();
  }
#line 714
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 717
  if (atomic_value_after_dec == 0) {
#line 720
    ldv_mutex_ecryptfs_daemon_hash_mux = 2;
#line 722
    return (1);
  } else {

  }
#line 726
  return (0);
}
}
#line 731 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_ecryptfs_daemon_hash_mux(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 735
  if (ldv_mutex_ecryptfs_daemon_hash_mux == 1) {
#line 738
    nondetermined = __VERIFIER_nondet_int();
#line 741
    if (nondetermined) {
#line 744
      return (0);
    } else {
#line 749
      return (1);
    }
  } else {
#line 755
    return (1);
  }
}
}
#line 760 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_ecryptfs_daemon_hash_mux(struct mutex *lock ) 
{ 


  {
#line 763
  if (ldv_mutex_ecryptfs_daemon_hash_mux == 2) {

  } else {
#line 763
    ldv_error();
  }
#line 765
  ldv_mutex_ecryptfs_daemon_hash_mux = 1;
#line 766
  return;
}
}
#line 768 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_ecryptfs_msg_ctx_lists_mux  ;
#line 771 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_ecryptfs_msg_ctx_lists_mux(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 776
  if (ldv_mutex_ecryptfs_msg_ctx_lists_mux == 1) {

  } else {
#line 776
    ldv_error();
  }
#line 779
  nondetermined = __VERIFIER_nondet_int();
#line 782
  if (nondetermined) {
#line 785
    ldv_mutex_ecryptfs_msg_ctx_lists_mux = 2;
#line 787
    return (0);
  } else {
#line 792
    return (-4);
  }
}
}
#line 797 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_ecryptfs_msg_ctx_lists_mux(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 802
  if (ldv_mutex_ecryptfs_msg_ctx_lists_mux == 1) {

  } else {
#line 802
    ldv_error();
  }
#line 805
  nondetermined = __VERIFIER_nondet_int();
#line 808
  if (nondetermined) {
#line 811
    ldv_mutex_ecryptfs_msg_ctx_lists_mux = 2;
#line 813
    return (0);
  } else {
#line 818
    return (-4);
  }
}
}
#line 823 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_ecryptfs_msg_ctx_lists_mux(struct mutex *lock ) 
{ 


  {
#line 826
  if (ldv_mutex_ecryptfs_msg_ctx_lists_mux == 1) {

  } else {
#line 826
    ldv_error();
  }
#line 828
  ldv_mutex_ecryptfs_msg_ctx_lists_mux = 2;
#line 829
  return;
}
}
#line 832 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_ecryptfs_msg_ctx_lists_mux(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 837
  if (ldv_mutex_ecryptfs_msg_ctx_lists_mux == 1) {

  } else {
#line 837
    ldv_error();
  }
#line 840
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 843
  if (is_mutex_held_by_another_thread) {
#line 846
    return (0);
  } else {
#line 851
    ldv_mutex_ecryptfs_msg_ctx_lists_mux = 2;
#line 853
    return (1);
  }
}
}
#line 858 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_ecryptfs_msg_ctx_lists_mux(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 863
  if (ldv_mutex_ecryptfs_msg_ctx_lists_mux == 1) {

  } else {
#line 863
    ldv_error();
  }
#line 866
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 869
  if (atomic_value_after_dec == 0) {
#line 872
    ldv_mutex_ecryptfs_msg_ctx_lists_mux = 2;
#line 874
    return (1);
  } else {

  }
#line 878
  return (0);
}
}
#line 883 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_ecryptfs_msg_ctx_lists_mux(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 887
  if (ldv_mutex_ecryptfs_msg_ctx_lists_mux == 1) {
#line 890
    nondetermined = __VERIFIER_nondet_int();
#line 893
    if (nondetermined) {
#line 896
      return (0);
    } else {
#line 901
      return (1);
    }
  } else {
#line 907
    return (1);
  }
}
}
#line 912 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_ecryptfs_msg_ctx_lists_mux(struct mutex *lock ) 
{ 


  {
#line 915
  if (ldv_mutex_ecryptfs_msg_ctx_lists_mux == 2) {

  } else {
#line 915
    ldv_error();
  }
#line 917
  ldv_mutex_ecryptfs_msg_ctx_lists_mux = 1;
#line 918
  return;
}
}
#line 920 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_global_auth_tok_list_mutex  ;
#line 923 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_global_auth_tok_list_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 928
  if (ldv_mutex_global_auth_tok_list_mutex == 1) {

  } else {
#line 928
    ldv_error();
  }
#line 931
  nondetermined = __VERIFIER_nondet_int();
#line 934
  if (nondetermined) {
#line 937
    ldv_mutex_global_auth_tok_list_mutex = 2;
#line 939
    return (0);
  } else {
#line 944
    return (-4);
  }
}
}
#line 949 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_global_auth_tok_list_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 954
  if (ldv_mutex_global_auth_tok_list_mutex == 1) {

  } else {
#line 954
    ldv_error();
  }
#line 957
  nondetermined = __VERIFIER_nondet_int();
#line 960
  if (nondetermined) {
#line 963
    ldv_mutex_global_auth_tok_list_mutex = 2;
#line 965
    return (0);
  } else {
#line 970
    return (-4);
  }
}
}
#line 975 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_global_auth_tok_list_mutex(struct mutex *lock ) 
{ 


  {
#line 978
  if (ldv_mutex_global_auth_tok_list_mutex == 1) {

  } else {
#line 978
    ldv_error();
  }
#line 980
  ldv_mutex_global_auth_tok_list_mutex = 2;
#line 981
  return;
}
}
#line 984 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_global_auth_tok_list_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 989
  if (ldv_mutex_global_auth_tok_list_mutex == 1) {

  } else {
#line 989
    ldv_error();
  }
#line 992
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 995
  if (is_mutex_held_by_another_thread) {
#line 998
    return (0);
  } else {
#line 1003
    ldv_mutex_global_auth_tok_list_mutex = 2;
#line 1005
    return (1);
  }
}
}
#line 1010 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_global_auth_tok_list_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1015
  if (ldv_mutex_global_auth_tok_list_mutex == 1) {

  } else {
#line 1015
    ldv_error();
  }
#line 1018
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1021
  if (atomic_value_after_dec == 0) {
#line 1024
    ldv_mutex_global_auth_tok_list_mutex = 2;
#line 1026
    return (1);
  } else {

  }
#line 1030
  return (0);
}
}
#line 1035 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_global_auth_tok_list_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1039
  if (ldv_mutex_global_auth_tok_list_mutex == 1) {
#line 1042
    nondetermined = __VERIFIER_nondet_int();
#line 1045
    if (nondetermined) {
#line 1048
      return (0);
    } else {
#line 1053
      return (1);
    }
  } else {
#line 1059
    return (1);
  }
}
}
#line 1064 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_global_auth_tok_list_mutex(struct mutex *lock ) 
{ 


  {
#line 1067
  if (ldv_mutex_global_auth_tok_list_mutex == 2) {

  } else {
#line 1067
    ldv_error();
  }
#line 1069
  ldv_mutex_global_auth_tok_list_mutex = 1;
#line 1070
  return;
}
}
#line 1072 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i_mutex  ;
#line 1075 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1080
  if (ldv_mutex_i_mutex == 1) {

  } else {
#line 1080
    ldv_error();
  }
#line 1083
  nondetermined = __VERIFIER_nondet_int();
#line 1086
  if (nondetermined) {
#line 1089
    ldv_mutex_i_mutex = 2;
#line 1091
    return (0);
  } else {
#line 1096
    return (-4);
  }
}
}
#line 1101 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1106
  if (ldv_mutex_i_mutex == 1) {

  } else {
#line 1106
    ldv_error();
  }
#line 1109
  nondetermined = __VERIFIER_nondet_int();
#line 1112
  if (nondetermined) {
#line 1115
    ldv_mutex_i_mutex = 2;
#line 1117
    return (0);
  } else {
#line 1122
    return (-4);
  }
}
}
#line 1127 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i_mutex(struct mutex *lock ) 
{ 


  {
#line 1130
  if (ldv_mutex_i_mutex == 1) {

  } else {
#line 1130
    ldv_error();
  }
#line 1132
  ldv_mutex_i_mutex = 2;
#line 1133
  return;
}
}
#line 1136 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1141
  if (ldv_mutex_i_mutex == 1) {

  } else {
#line 1141
    ldv_error();
  }
#line 1144
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1147
  if (is_mutex_held_by_another_thread) {
#line 1150
    return (0);
  } else {
#line 1155
    ldv_mutex_i_mutex = 2;
#line 1157
    return (1);
  }
}
}
#line 1162 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1167
  if (ldv_mutex_i_mutex == 1) {

  } else {
#line 1167
    ldv_error();
  }
#line 1170
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1173
  if (atomic_value_after_dec == 0) {
#line 1176
    ldv_mutex_i_mutex = 2;
#line 1178
    return (1);
  } else {

  }
#line 1182
  return (0);
}
}
#line 1187 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1191
  if (ldv_mutex_i_mutex == 1) {
#line 1194
    nondetermined = __VERIFIER_nondet_int();
#line 1197
    if (nondetermined) {
#line 1200
      return (0);
    } else {
#line 1205
      return (1);
    }
  } else {
#line 1211
    return (1);
  }
}
}
#line 1216 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i_mutex(struct mutex *lock ) 
{ 


  {
#line 1219
  if (ldv_mutex_i_mutex == 2) {

  } else {
#line 1219
    ldv_error();
  }
#line 1221
  ldv_mutex_i_mutex = 1;
#line 1222
  return;
}
}
#line 1224 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_key_tfm_list_mutex  ;
#line 1227 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_key_tfm_list_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1232
  if (ldv_mutex_key_tfm_list_mutex == 1) {

  } else {
#line 1232
    ldv_error();
  }
#line 1235
  nondetermined = __VERIFIER_nondet_int();
#line 1238
  if (nondetermined) {
#line 1241
    ldv_mutex_key_tfm_list_mutex = 2;
#line 1243
    return (0);
  } else {
#line 1248
    return (-4);
  }
}
}
#line 1253 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_key_tfm_list_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1258
  if (ldv_mutex_key_tfm_list_mutex == 1) {

  } else {
#line 1258
    ldv_error();
  }
#line 1261
  nondetermined = __VERIFIER_nondet_int();
#line 1264
  if (nondetermined) {
#line 1267
    ldv_mutex_key_tfm_list_mutex = 2;
#line 1269
    return (0);
  } else {
#line 1274
    return (-4);
  }
}
}
#line 1279 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_key_tfm_list_mutex(struct mutex *lock ) 
{ 


  {
#line 1282
  if (ldv_mutex_key_tfm_list_mutex == 1) {

  } else {
#line 1282
    ldv_error();
  }
#line 1284
  ldv_mutex_key_tfm_list_mutex = 2;
#line 1285
  return;
}
}
#line 1288 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_key_tfm_list_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1293
  if (ldv_mutex_key_tfm_list_mutex == 1) {

  } else {
#line 1293
    ldv_error();
  }
#line 1296
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1299
  if (is_mutex_held_by_another_thread) {
#line 1302
    return (0);
  } else {
#line 1307
    ldv_mutex_key_tfm_list_mutex = 2;
#line 1309
    return (1);
  }
}
}
#line 1314 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_key_tfm_list_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1319
  if (ldv_mutex_key_tfm_list_mutex == 1) {

  } else {
#line 1319
    ldv_error();
  }
#line 1322
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1325
  if (atomic_value_after_dec == 0) {
#line 1328
    ldv_mutex_key_tfm_list_mutex = 2;
#line 1330
    return (1);
  } else {

  }
#line 1334
  return (0);
}
}
#line 1339 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_key_tfm_list_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1343
  if (ldv_mutex_key_tfm_list_mutex == 1) {
#line 1346
    nondetermined = __VERIFIER_nondet_int();
#line 1349
    if (nondetermined) {
#line 1352
      return (0);
    } else {
#line 1357
      return (1);
    }
  } else {
#line 1363
    return (1);
  }
}
}
#line 1368 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_key_tfm_list_mutex(struct mutex *lock ) 
{ 


  {
#line 1371
  if (ldv_mutex_key_tfm_list_mutex == 2) {

  } else {
#line 1371
    ldv_error();
  }
#line 1373
  ldv_mutex_key_tfm_list_mutex = 1;
#line 1374
  return;
}
}
#line 1376 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_keysig_list_mutex  ;
#line 1379 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_keysig_list_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1384
  if (ldv_mutex_keysig_list_mutex == 1) {

  } else {
#line 1384
    ldv_error();
  }
#line 1387
  nondetermined = __VERIFIER_nondet_int();
#line 1390
  if (nondetermined) {
#line 1393
    ldv_mutex_keysig_list_mutex = 2;
#line 1395
    return (0);
  } else {
#line 1400
    return (-4);
  }
}
}
#line 1405 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_keysig_list_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1410
  if (ldv_mutex_keysig_list_mutex == 1) {

  } else {
#line 1410
    ldv_error();
  }
#line 1413
  nondetermined = __VERIFIER_nondet_int();
#line 1416
  if (nondetermined) {
#line 1419
    ldv_mutex_keysig_list_mutex = 2;
#line 1421
    return (0);
  } else {
#line 1426
    return (-4);
  }
}
}
#line 1431 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_keysig_list_mutex(struct mutex *lock ) 
{ 


  {
#line 1434
  if (ldv_mutex_keysig_list_mutex == 1) {

  } else {
#line 1434
    ldv_error();
  }
#line 1436
  ldv_mutex_keysig_list_mutex = 2;
#line 1437
  return;
}
}
#line 1440 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_keysig_list_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1445
  if (ldv_mutex_keysig_list_mutex == 1) {

  } else {
#line 1445
    ldv_error();
  }
#line 1448
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1451
  if (is_mutex_held_by_another_thread) {
#line 1454
    return (0);
  } else {
#line 1459
    ldv_mutex_keysig_list_mutex = 2;
#line 1461
    return (1);
  }
}
}
#line 1466 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_keysig_list_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1471
  if (ldv_mutex_keysig_list_mutex == 1) {

  } else {
#line 1471
    ldv_error();
  }
#line 1474
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1477
  if (atomic_value_after_dec == 0) {
#line 1480
    ldv_mutex_keysig_list_mutex = 2;
#line 1482
    return (1);
  } else {

  }
#line 1486
  return (0);
}
}
#line 1491 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_keysig_list_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1495
  if (ldv_mutex_keysig_list_mutex == 1) {
#line 1498
    nondetermined = __VERIFIER_nondet_int();
#line 1501
    if (nondetermined) {
#line 1504
      return (0);
    } else {
#line 1509
      return (1);
    }
  } else {
#line 1515
    return (1);
  }
}
}
#line 1520 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_keysig_list_mutex(struct mutex *lock ) 
{ 


  {
#line 1523
  if (ldv_mutex_keysig_list_mutex == 2) {

  } else {
#line 1523
    ldv_error();
  }
#line 1525
  ldv_mutex_keysig_list_mutex = 1;
#line 1526
  return;
}
}
#line 1528 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 1531 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1536
  if (ldv_mutex_lock == 1) {

  } else {
#line 1536
    ldv_error();
  }
#line 1539
  nondetermined = __VERIFIER_nondet_int();
#line 1542
  if (nondetermined) {
#line 1545
    ldv_mutex_lock = 2;
#line 1547
    return (0);
  } else {
#line 1552
    return (-4);
  }
}
}
#line 1557 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1562
  if (ldv_mutex_lock == 1) {

  } else {
#line 1562
    ldv_error();
  }
#line 1565
  nondetermined = __VERIFIER_nondet_int();
#line 1568
  if (nondetermined) {
#line 1571
    ldv_mutex_lock = 2;
#line 1573
    return (0);
  } else {
#line 1578
    return (-4);
  }
}
}
#line 1583 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 1586
  if (ldv_mutex_lock == 1) {

  } else {
#line 1586
    ldv_error();
  }
#line 1588
  ldv_mutex_lock = 2;
#line 1589
  return;
}
}
#line 1592 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1597
  if (ldv_mutex_lock == 1) {

  } else {
#line 1597
    ldv_error();
  }
#line 1600
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1603
  if (is_mutex_held_by_another_thread) {
#line 1606
    return (0);
  } else {
#line 1611
    ldv_mutex_lock = 2;
#line 1613
    return (1);
  }
}
}
#line 1618 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1623
  if (ldv_mutex_lock == 1) {

  } else {
#line 1623
    ldv_error();
  }
#line 1626
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1629
  if (atomic_value_after_dec == 0) {
#line 1632
    ldv_mutex_lock = 2;
#line 1634
    return (1);
  } else {

  }
#line 1638
  return (0);
}
}
#line 1643 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1647
  if (ldv_mutex_lock == 1) {
#line 1650
    nondetermined = __VERIFIER_nondet_int();
#line 1653
    if (nondetermined) {
#line 1656
      return (0);
    } else {
#line 1661
      return (1);
    }
  } else {
#line 1667
    return (1);
  }
}
}
#line 1672 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 1675
  if (ldv_mutex_lock == 2) {

  } else {
#line 1675
    ldv_error();
  }
#line 1677
  ldv_mutex_lock = 1;
#line 1678
  return;
}
}
#line 1680 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lower_file_count  ;
#line 1683 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lower_file_count(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1688
  if (ldv_mutex_lower_file_count == 1) {

  } else {
#line 1688
    ldv_error();
  }
#line 1691
  nondetermined = __VERIFIER_nondet_int();
#line 1694
  if (nondetermined) {
#line 1697
    ldv_mutex_lower_file_count = 2;
#line 1699
    return (0);
  } else {
#line 1704
    return (-4);
  }
}
}
#line 1709 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lower_file_count(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1714
  if (ldv_mutex_lower_file_count == 1) {

  } else {
#line 1714
    ldv_error();
  }
#line 1717
  nondetermined = __VERIFIER_nondet_int();
#line 1720
  if (nondetermined) {
#line 1723
    ldv_mutex_lower_file_count = 2;
#line 1725
    return (0);
  } else {
#line 1730
    return (-4);
  }
}
}
#line 1735 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lower_file_count(struct mutex *lock ) 
{ 


  {
#line 1738
  if (ldv_mutex_lower_file_count == 1) {

  } else {
#line 1738
    ldv_error();
  }
#line 1740
  ldv_mutex_lower_file_count = 2;
#line 1741
  return;
}
}
#line 1744 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lower_file_count(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1749
  if (ldv_mutex_lower_file_count == 1) {

  } else {
#line 1749
    ldv_error();
  }
#line 1752
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1755
  if (is_mutex_held_by_another_thread) {
#line 1758
    return (0);
  } else {
#line 1763
    ldv_mutex_lower_file_count = 2;
#line 1765
    return (1);
  }
}
}
#line 1770 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lower_file_count(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1775
  if (ldv_mutex_lower_file_count == 1) {

  } else {
#line 1775
    ldv_error();
  }
#line 1778
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1781
  if (atomic_value_after_dec == 0) {
#line 1784
    ldv_mutex_lower_file_count = 2;
#line 1786
    return (1);
  } else {

  }
#line 1790
  return (0);
}
}
#line 1795 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lower_file_count(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1799
  if (ldv_mutex_lower_file_count == 1) {
#line 1802
    nondetermined = __VERIFIER_nondet_int();
#line 1805
    if (nondetermined) {
#line 1808
      return (0);
    } else {
#line 1813
      return (1);
    }
  } else {
#line 1819
    return (1);
  }
}
}
#line 1824 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lower_file_count(struct mutex *lock ) 
{ 


  {
#line 1827
  if (ldv_mutex_lower_file_count == 2) {

  } else {
#line 1827
    ldv_error();
  }
#line 1829
  ldv_mutex_lower_file_count = 1;
#line 1830
  return;
}
}
#line 1832 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lower_file_mutex  ;
#line 1835 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lower_file_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1840
  if (ldv_mutex_lower_file_mutex == 1) {

  } else {
#line 1840
    ldv_error();
  }
#line 1843
  nondetermined = __VERIFIER_nondet_int();
#line 1846
  if (nondetermined) {
#line 1849
    ldv_mutex_lower_file_mutex = 2;
#line 1851
    return (0);
  } else {
#line 1856
    return (-4);
  }
}
}
#line 1861 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lower_file_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1866
  if (ldv_mutex_lower_file_mutex == 1) {

  } else {
#line 1866
    ldv_error();
  }
#line 1869
  nondetermined = __VERIFIER_nondet_int();
#line 1872
  if (nondetermined) {
#line 1875
    ldv_mutex_lower_file_mutex = 2;
#line 1877
    return (0);
  } else {
#line 1882
    return (-4);
  }
}
}
#line 1887 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lower_file_mutex(struct mutex *lock ) 
{ 


  {
#line 1890
  if (ldv_mutex_lower_file_mutex == 1) {

  } else {
#line 1890
    ldv_error();
  }
#line 1892
  ldv_mutex_lower_file_mutex = 2;
#line 1893
  return;
}
}
#line 1896 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lower_file_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1901
  if (ldv_mutex_lower_file_mutex == 1) {

  } else {
#line 1901
    ldv_error();
  }
#line 1904
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 1907
  if (is_mutex_held_by_another_thread) {
#line 1910
    return (0);
  } else {
#line 1915
    ldv_mutex_lower_file_mutex = 2;
#line 1917
    return (1);
  }
}
}
#line 1922 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lower_file_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1927
  if (ldv_mutex_lower_file_mutex == 1) {

  } else {
#line 1927
    ldv_error();
  }
#line 1930
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 1933
  if (atomic_value_after_dec == 0) {
#line 1936
    ldv_mutex_lower_file_mutex = 2;
#line 1938
    return (1);
  } else {

  }
#line 1942
  return (0);
}
}
#line 1947 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lower_file_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1951
  if (ldv_mutex_lower_file_mutex == 1) {
#line 1954
    nondetermined = __VERIFIER_nondet_int();
#line 1957
    if (nondetermined) {
#line 1960
      return (0);
    } else {
#line 1965
      return (1);
    }
  } else {
#line 1971
    return (1);
  }
}
}
#line 1976 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lower_file_mutex(struct mutex *lock ) 
{ 


  {
#line 1979
  if (ldv_mutex_lower_file_mutex == 2) {

  } else {
#line 1979
    ldv_error();
  }
#line 1981
  ldv_mutex_lower_file_mutex = 1;
#line 1982
  return;
}
}
#line 1984 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex  ;
#line 1987 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1992
  if (ldv_mutex_mutex == 1) {

  } else {
#line 1992
    ldv_error();
  }
#line 1995
  nondetermined = __VERIFIER_nondet_int();
#line 1998
  if (nondetermined) {
#line 2001
    ldv_mutex_mutex = 2;
#line 2003
    return (0);
  } else {
#line 2008
    return (-4);
  }
}
}
#line 2013 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2018
  if (ldv_mutex_mutex == 1) {

  } else {
#line 2018
    ldv_error();
  }
#line 2021
  nondetermined = __VERIFIER_nondet_int();
#line 2024
  if (nondetermined) {
#line 2027
    ldv_mutex_mutex = 2;
#line 2029
    return (0);
  } else {
#line 2034
    return (-4);
  }
}
}
#line 2039 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex(struct mutex *lock ) 
{ 


  {
#line 2042
  if (ldv_mutex_mutex == 1) {

  } else {
#line 2042
    ldv_error();
  }
#line 2044
  ldv_mutex_mutex = 2;
#line 2045
  return;
}
}
#line 2048 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 2053
  if (ldv_mutex_mutex == 1) {

  } else {
#line 2053
    ldv_error();
  }
#line 2056
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 2059
  if (is_mutex_held_by_another_thread) {
#line 2062
    return (0);
  } else {
#line 2067
    ldv_mutex_mutex = 2;
#line 2069
    return (1);
  }
}
}
#line 2074 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 2079
  if (ldv_mutex_mutex == 1) {

  } else {
#line 2079
    ldv_error();
  }
#line 2082
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 2085
  if (atomic_value_after_dec == 0) {
#line 2088
    ldv_mutex_mutex = 2;
#line 2090
    return (1);
  } else {

  }
#line 2094
  return (0);
}
}
#line 2099 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2103
  if (ldv_mutex_mutex == 1) {
#line 2106
    nondetermined = __VERIFIER_nondet_int();
#line 2109
    if (nondetermined) {
#line 2112
      return (0);
    } else {
#line 2117
      return (1);
    }
  } else {
#line 2123
    return (1);
  }
}
}
#line 2128 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex(struct mutex *lock ) 
{ 


  {
#line 2131
  if (ldv_mutex_mutex == 2) {

  } else {
#line 2131
    ldv_error();
  }
#line 2133
  ldv_mutex_mutex = 1;
#line 2134
  return;
}
}
#line 2136 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mux  ;
#line 2139 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mux(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2144
  if (ldv_mutex_mux == 1) {

  } else {
#line 2144
    ldv_error();
  }
#line 2147
  nondetermined = __VERIFIER_nondet_int();
#line 2150
  if (nondetermined) {
#line 2153
    ldv_mutex_mux = 2;
#line 2155
    return (0);
  } else {
#line 2160
    return (-4);
  }
}
}
#line 2165 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mux(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2170
  if (ldv_mutex_mux == 1) {

  } else {
#line 2170
    ldv_error();
  }
#line 2173
  nondetermined = __VERIFIER_nondet_int();
#line 2176
  if (nondetermined) {
#line 2179
    ldv_mutex_mux = 2;
#line 2181
    return (0);
  } else {
#line 2186
    return (-4);
  }
}
}
#line 2191 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mux(struct mutex *lock ) 
{ 


  {
#line 2194
  if (ldv_mutex_mux == 1) {

  } else {
#line 2194
    ldv_error();
  }
#line 2196
  ldv_mutex_mux = 2;
#line 2197
  return;
}
}
#line 2200 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mux(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 2205
  if (ldv_mutex_mux == 1) {

  } else {
#line 2205
    ldv_error();
  }
#line 2208
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 2211
  if (is_mutex_held_by_another_thread) {
#line 2214
    return (0);
  } else {
#line 2219
    ldv_mutex_mux = 2;
#line 2221
    return (1);
  }
}
}
#line 2226 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mux(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 2231
  if (ldv_mutex_mux == 1) {

  } else {
#line 2231
    ldv_error();
  }
#line 2234
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 2237
  if (atomic_value_after_dec == 0) {
#line 2240
    ldv_mutex_mux = 2;
#line 2242
    return (1);
  } else {

  }
#line 2246
  return (0);
}
}
#line 2251 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mux(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2255
  if (ldv_mutex_mux == 1) {
#line 2258
    nondetermined = __VERIFIER_nondet_int();
#line 2261
    if (nondetermined) {
#line 2264
      return (0);
    } else {
#line 2269
      return (1);
    }
  } else {
#line 2275
    return (1);
  }
}
}
#line 2280 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mux(struct mutex *lock ) 
{ 


  {
#line 2283
  if (ldv_mutex_mux == 2) {

  } else {
#line 2283
    ldv_error();
  }
#line 2285
  ldv_mutex_mux = 1;
#line 2286
  return;
}
}
#line 2288 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_tfm_mutex  ;
#line 2291 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_tfm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2296
  if (ldv_mutex_tfm_mutex == 1) {

  } else {
#line 2296
    ldv_error();
  }
#line 2299
  nondetermined = __VERIFIER_nondet_int();
#line 2302
  if (nondetermined) {
#line 2305
    ldv_mutex_tfm_mutex = 2;
#line 2307
    return (0);
  } else {
#line 2312
    return (-4);
  }
}
}
#line 2317 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_tfm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2322
  if (ldv_mutex_tfm_mutex == 1) {

  } else {
#line 2322
    ldv_error();
  }
#line 2325
  nondetermined = __VERIFIER_nondet_int();
#line 2328
  if (nondetermined) {
#line 2331
    ldv_mutex_tfm_mutex = 2;
#line 2333
    return (0);
  } else {
#line 2338
    return (-4);
  }
}
}
#line 2343 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_tfm_mutex(struct mutex *lock ) 
{ 


  {
#line 2346
  if (ldv_mutex_tfm_mutex == 1) {

  } else {
#line 2346
    ldv_error();
  }
#line 2348
  ldv_mutex_tfm_mutex = 2;
#line 2349
  return;
}
}
#line 2352 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_tfm_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 2357
  if (ldv_mutex_tfm_mutex == 1) {

  } else {
#line 2357
    ldv_error();
  }
#line 2360
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 2363
  if (is_mutex_held_by_another_thread) {
#line 2366
    return (0);
  } else {
#line 2371
    ldv_mutex_tfm_mutex = 2;
#line 2373
    return (1);
  }
}
}
#line 2378 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_tfm_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 2383
  if (ldv_mutex_tfm_mutex == 1) {

  } else {
#line 2383
    ldv_error();
  }
#line 2386
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 2389
  if (atomic_value_after_dec == 0) {
#line 2392
    ldv_mutex_tfm_mutex = 2;
#line 2394
    return (1);
  } else {

  }
#line 2398
  return (0);
}
}
#line 2403 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_tfm_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2407
  if (ldv_mutex_tfm_mutex == 1) {
#line 2410
    nondetermined = __VERIFIER_nondet_int();
#line 2413
    if (nondetermined) {
#line 2416
      return (0);
    } else {
#line 2421
      return (1);
    }
  } else {
#line 2427
    return (1);
  }
}
}
#line 2432 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_tfm_mutex(struct mutex *lock ) 
{ 


  {
#line 2435
  if (ldv_mutex_tfm_mutex == 2) {

  } else {
#line 2435
    ldv_error();
  }
#line 2437
  ldv_mutex_tfm_mutex = 1;
#line 2438
  return;
}
}
#line 2442 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 


  {
#line 2445
  ldv_mutex_cred_guard_mutex = 1;
#line 2447
  ldv_mutex_cs_hash_tfm_mutex = 1;
#line 2449
  ldv_mutex_cs_mutex = 1;
#line 2451
  ldv_mutex_cs_tfm_mutex = 1;
#line 2453
  ldv_mutex_ecryptfs_daemon_hash_mux = 1;
#line 2455
  ldv_mutex_ecryptfs_msg_ctx_lists_mux = 1;
#line 2457
  ldv_mutex_global_auth_tok_list_mutex = 1;
#line 2459
  ldv_mutex_i_mutex = 1;
#line 2461
  ldv_mutex_key_tfm_list_mutex = 1;
#line 2463
  ldv_mutex_keysig_list_mutex = 1;
#line 2465
  ldv_mutex_lock = 1;
#line 2467
  ldv_mutex_lower_file_count = 1;
#line 2469
  ldv_mutex_lower_file_mutex = 1;
#line 2471
  ldv_mutex_mutex = 1;
#line 2473
  ldv_mutex_mux = 1;
#line 2475
  ldv_mutex_tfm_mutex = 1;
#line 2476
  return;
}
}
#line 2479 "/home/mikhail/launches/cpachecker-regression/launcher-working-dir/ldv-manager-work-dir/work/current--X--fs/ecryptfs/ecryptfs.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/24/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 2482
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 2482
    ldv_error();
  }
#line 2484
  if (ldv_mutex_cs_hash_tfm_mutex == 1) {

  } else {
#line 2484
    ldv_error();
  }
#line 2486
  if (ldv_mutex_cs_mutex == 1) {

  } else {
#line 2486
    ldv_error();
  }
#line 2488
  if (ldv_mutex_cs_tfm_mutex == 1) {

  } else {
#line 2488
    ldv_error();
  }
#line 2490
  if (ldv_mutex_ecryptfs_daemon_hash_mux == 1) {

  } else {
#line 2490
    ldv_error();
  }
#line 2492
  if (ldv_mutex_ecryptfs_msg_ctx_lists_mux == 1) {

  } else {
#line 2492
    ldv_error();
  }
#line 2494
  if (ldv_mutex_global_auth_tok_list_mutex == 1) {

  } else {
#line 2494
    ldv_error();
  }
#line 2496
  if (ldv_mutex_i_mutex == 1) {

  } else {
#line 2496
    ldv_error();
  }
#line 2498
  if (ldv_mutex_key_tfm_list_mutex == 1) {

  } else {
#line 2498
    ldv_error();
  }
#line 2500
  if (ldv_mutex_keysig_list_mutex == 1) {

  } else {
#line 2500
    ldv_error();
  }
#line 2502
  if (ldv_mutex_lock == 1) {

  } else {
#line 2502
    ldv_error();
  }
#line 2504
  if (ldv_mutex_lower_file_count == 1) {

  } else {
#line 2504
    ldv_error();
  }
#line 2506
  if (ldv_mutex_lower_file_mutex == 1) {

  } else {
#line 2506
    ldv_error();
  }
#line 2508
  if (ldv_mutex_mutex == 1) {

  } else {
#line 2508
    ldv_error();
  }
#line 2510
  if (ldv_mutex_mux == 1) {

  } else {
#line 2510
    ldv_error();
  }
#line 2512
  if (ldv_mutex_tfm_mutex == 1) {

  } else {
#line 2512
    ldv_error();
  }
#line 2513
  return;
}
}
