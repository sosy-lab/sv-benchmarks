/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 86 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 87 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 19 "include/linux/types.h"
typedef __u32 nlink_t;
#line 20 "include/linux/types.h"
typedef __kernel_off_t off_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 92 "include/linux/types.h"
typedef unsigned long ulong;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 146 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 55 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/alternative.h"
struct module;
#line 153 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 310 "include/linux/printk.h"
struct file_operations;
#line 325 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 23 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/sysinfo.h"
struct completion;
#line 24
struct pt_regs;
#line 386 "include/linux/kernel.h"
struct pid;
#line 14 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 15 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 16 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 26 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_2024_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 26 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_2024_8 ldv_2024 ;
};
#line 27 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
struct __anonstruct_ldv_2031_10 {
   u32 read ;
   s32 write ;
};
#line 33 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_9 {
   s64 lock ;
   struct __anonstruct_ldv_2031_10 ldv_2031 ;
};
#line 33 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_9 arch_rwlock_t;
#line 34
struct task_struct;
#line 35
struct lockdep_map;
#line 18 "include/linux/lockdep.h"
struct mm_struct;
#line 58 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2096_12 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_2111_13 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_2112_11 {
   struct __anonstruct_ldv_2096_12 ldv_2096 ;
   struct __anonstruct_ldv_2111_13 ldv_2111 ;
};
#line 59 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_2112_11 ldv_2112 ;
};
#line 13 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 14 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 212 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 214 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
#line 214 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_15 pgd_t;
#line 302
struct page;
#line 302 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 310
struct file;
#line 325
struct seq_file;
#line 355
struct thread_struct;
#line 357
struct cpumask;
#line 358 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 195 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 127 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2767_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2767_18 ldv_2767 ;
};
#line 306 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 97 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[64U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 648 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 195 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 166 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 298 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5125_23 {
   u64 rip ;
   u64 rdp ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5131_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5132_22 {
   struct __anonstruct_ldv_5125_23 ldv_5125 ;
   struct __anonstruct_ldv_5131_24 ldv_5131 ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union __anonunion_ldv_5141_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 316 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5132_22 ldv_5132 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5141_25 ldv_5141 ;
};
#line 350 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 371 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 376 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 382 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
};
#line 388 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 396 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 443
struct kmem_cache;
#line 444
struct perf_event;
#line 445 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 2 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 11 ;
};
#line 574 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_5960_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_5961_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_5960_29 ldv_5960 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_5961_28 ldv_5961 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 63 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 133 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/stat.h"
struct timespec;
#line 110 "include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 254 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 46 "include/linux/uidgid.h"
typedef uid_t kuid_t;
#line 47 "include/linux/uidgid.h"
typedef gid_t kgid_t;
#line 197 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 32 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 37 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 752 "include/linux/mmzone.h"
struct rw_semaphore;
#line 753 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 128 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 314 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 353
struct tvec_base;
#line 354 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 50 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 96 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   int cpu ;
};
#line 113 "include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 886 "include/linux/mmzone.h"
struct ctl_table;
#line 72 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 182 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 46 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 52 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 53 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 289
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 296
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 304
struct wakeup_source;
#line 494 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
};
#line 499
struct dev_pm_qos;
#line 499 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool ignore_children ;
   bool early_init ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 557 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 135 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct vm_area_struct;
#line 67 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/xen/hypervisor.h"
struct bio_vec;
#line 18 "include/linux/smp.h"
struct call_single_data {
   struct list_head list ;
   void (*func)(void * ) ;
   void *info ;
   u16 flags ;
   u16 priv ;
};
#line 398 "include/linux/gfp.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "include/linux/sysctl.h"
struct __anonstruct_ldv_13178_129 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "include/linux/sysctl.h"
union __anonunion_ldv_13180_128 {
   struct __anonstruct_ldv_13178_129 ldv_13178 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_ldv_13180_128 ldv_13180 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 44 "include/linux/elf.h"
struct sock;
#line 45
struct kobject;
#line 46
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 52 "include/linux/elf.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 57 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 110 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct kobject * , struct attribute  const  * ) ;
};
#line 129
struct sysfs_dirent;
#line 194 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "include/linux/kobject.h"
struct kset;
#line 49
struct kobj_type;
#line 49 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 107 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 115 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 122 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 139 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 214
struct kernel_param;
#line 215 "include/linux/kobject.h"
struct kernel_param_ops {
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 47 "include/linux/moduleparam.h"
struct kparam_string;
#line 47
struct kparam_array;
#line 47 "include/linux/moduleparam.h"
union __anonunion_ldv_13958_134 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 47 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_13958_134 ldv_13958 ;
};
#line 59 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 65 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 457 "include/linux/moduleparam.h"
struct static_key {
   atomic_t enabled ;
};
#line 210 "include/linux/jump_label.h"
struct tracepoint;
#line 211 "include/linux/jump_label.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 86 "include/linux/tracepoint.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 27 "include/linux/export.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 201
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 207 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 222
struct module_sect_attrs;
#line 222
struct module_notes_attrs;
#line 222
struct ftrace_event_call;
#line 222 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct list_head source_list ;
   struct list_head target_list ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 648
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 342 "include/linux/irq.h"
struct proc_dir_entry;
#line 72 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/smap.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 180 "include/linux/hardirq.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 162 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[3U] ;
};
#line 12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 13 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 191 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[16U] ;
   kernel_ulong_t driver_data ;
};
#line 225 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 610
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 23 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 53 "include/linux/device.h"
struct device_attribute;
#line 53
struct driver_attribute;
#line 53 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
};
#line 127
struct device_type;
#line 184 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 249 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char * ) ;
   ssize_t (*store)(struct device_driver * , char const   * , size_t  ) ;
};
#line 303
struct class_attribute;
#line 303 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct bin_attribute *dev_bin_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 398 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
   void const   *(*namespace)(struct class * , struct class_attribute  const  * ) ;
};
#line 451 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 478 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 577 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 587 "include/linux/device.h"
struct acpi_dev_node {
   void *handle ;
};
#line 592
struct dma_coherent_mem;
#line 592 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
};
#line 720 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 69 "include/linux/io.h"
struct hotplug_slot;
#line 69 "include/linux/io.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 95 "include/linux/pci.h"
typedef int pci_power_t;
#line 122 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 123
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 148 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 165 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 208
struct pcie_link_state;
#line 209
struct pci_vpd;
#line 210
struct pci_sriov;
#line 211
struct pci_ats;
#line 212
struct pci_driver;
#line 212 "include/linux/pci.h"
union __anonunion_ldv_17362_137 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 212 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char is_pcie : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct kset *msi_kset ;
   struct pci_vpd *vpd ;
   union __anonunion_ldv_17362_137 ldv_17362 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
#line 401
struct pci_ops;
#line 401 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 492 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 513 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 526 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 536 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 566 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1070 "include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 39 "include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 1223 "include/linux/pci.h"
struct inode;
#line 42 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 48 "include/linux/uprobes.h"
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 55
struct uprobe;
#line 55 "include/linux/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   struct arch_uprobe_task autask ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   unsigned long vaddr ;
};
#line 69 "include/linux/uprobes.h"
struct xol_area {
   wait_queue_head_t wq ;
   atomic_t slot_count ;
   unsigned long *bitmap ;
   struct page *page ;
   unsigned long vaddr ;
};
#line 88 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 112
struct address_space;
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18393_139 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_18403_143 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18405_142 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_18403_143 ldv_18403 ;
   int units ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_18407_141 {
   union __anonunion_ldv_18405_142 ldv_18405 ;
   atomic_t _count ;
};
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18408_140 {
   unsigned long counters ;
   struct __anonstruct_ldv_18407_141 ldv_18407 ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_18409_138 {
   union __anonunion_ldv_18393_139 ldv_18393 ;
   union __anonunion_ldv_18408_140 ldv_18408 ;
};
#line 113 "include/linux/uprobes.h"
struct __anonstruct_ldv_18416_145 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 113
struct slab;
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18420_144 {
   struct list_head lru ;
   struct __anonstruct_ldv_18416_145 ldv_18416 ;
   struct list_head list ;
   struct slab *slab_page ;
};
#line 113 "include/linux/uprobes.h"
union __anonunion_ldv_18425_146 {
   unsigned long private ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 113 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   struct address_space *mapping ;
   struct __anonstruct_ldv_18409_138 ldv_18409 ;
   union __anonunion_ldv_18420_144 ldv_18420 ;
   union __anonunion_ldv_18425_146 ldv_18425 ;
   unsigned long debug_flags ;
   int _last_nid ;
};
#line 179 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 219 "include/linux/mm_types.h"
struct __anonstruct_linear_148 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 219 "include/linux/mm_types.h"
union __anonunion_shared_147 {
   struct __anonstruct_linear_148 linear ;
   struct list_head nonlinear ;
};
#line 219
struct anon_vma;
#line 219
struct vm_operations_struct;
#line 219
struct mempolicy;
#line 219 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_147 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 291 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 297 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 310 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 323
struct linux_binfmt;
#line 323
struct mmu_notifier_mm;
#line 323 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   void (*unmap_area)(struct mm_struct * , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   pgtable_t pmd_huge_pte ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_next_reset ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   int first_nid ;
   struct uprobes_state uprobes_state ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
};
#line 14 "include/linux/shrinker.h"
struct shrinker {
   int (*shrink)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   struct list_head list ;
   atomic_long_t nr_in_batch ;
};
#line 43
struct file_ra_state;
#line 44
struct user_struct;
#line 45
struct writeback_control;
#line 157 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 181 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 1751
struct mem_cgroup;
#line 137 "include/linux/slab.h"
struct __anonstruct_ldv_21184_150 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 137 "include/linux/slab.h"
union __anonunion_ldv_21185_149 {
   struct kmem_cache *memcg_caches[0U] ;
   struct __anonstruct_ldv_21184_150 ldv_21184 ;
};
#line 137 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_21185_149 ldv_21185 ;
};
#line 88 "include/linux/kmemleak.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 54 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 65 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 75 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 447 "include/linux/slab.h"
struct pci_sysdata {
   int domain ;
   int node ;
   void *iommu ;
};
#line 34 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 273 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 440 "include/linux/rculist.h"
struct hlist_bl_node;
#line 440 "include/linux/rculist.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct nameidata;
#line 115
struct path;
#line 116
struct vfsmount;
#line 117 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_22844_152 {
   u32 hash ;
   u32 len ;
};
#line 117 "include/linux/rculist_bl.h"
union __anonunion_ldv_22846_151 {
   struct __anonstruct_ldv_22844_152 ldv_22844 ;
   u64 hash_len ;
};
#line 117 "include/linux/rculist_bl.h"
struct qstr {
   union __anonunion_ldv_22846_151 ldv_22846 ;
   unsigned char const   *name ;
};
#line 87 "include/linux/dcache.h"
struct dentry_operations;
#line 87
struct super_block;
#line 87 "include/linux/dcache.h"
union __anonunion_d_u_153 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 87 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   unsigned int d_count ;
   spinlock_t d_lock ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_153 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 138 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct inode  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct inode  const  * , struct dentry  const  * ,
                    struct inode  const  * , unsigned int  , char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 411 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 380
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 387
struct pid_namespace;
#line 387 "include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 27 "include/linux/percpu-rwsem.h"
struct bio_set;
#line 28
struct bio;
#line 29
struct bio_integrity_payload;
#line 30
struct block_device;
#line 31
struct io_context;
#line 32
struct cgroup_subsys_state;
#line 19 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 21 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 30 "include/linux/blk_types.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned int bi_phys_segments ;
   unsigned int bi_size ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   struct bio_integrity_payload *bi_integrity ;
   unsigned int bi_max_vecs ;
   atomic_t bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 56 "include/uapi/linux/fs.h"
struct export_operations;
#line 57
struct hd_geometry;
#line 58
struct iovec;
#line 59
struct kiocb;
#line 60
struct pipe_inode_info;
#line 61
struct poll_table_struct;
#line 62
struct kstatfs;
#line 63
struct swap_info_struct;
#line 65 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 241 "include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 75 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 150 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 151 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 165
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 36 "include/linux/projid.h"
typedef projid_t kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_23850_155 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_23850_155 ldv_23850 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
};
#line 332 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 378 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 340 "include/linux/fs.h"
union __anonunion_arg_157 {
   char *buf ;
   void *data ;
};
#line 340 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_156 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_157 arg ;
   int error ;
};
#line 340 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_156 read_descriptor_t;
#line 343 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 402
struct backing_dev_info;
#line 403 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 424
struct request_queue;
#line 425
struct hd_struct;
#line 425
struct gendisk;
#line 425 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 497
struct posix_acl;
#line 498
struct inode_operations;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_24284_158 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 498 "include/linux/fs.h"
union __anonunion_ldv_24304_159 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 498
struct file_lock;
#line 498
struct cdev;
#line 498 "include/linux/fs.h"
union __anonunion_ldv_24320_160 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 498 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_24284_158 ldv_24284 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_24304_159 ldv_24304 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_24320_160 ldv_24320 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 726 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 734 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 757 "include/linux/fs.h"
union __anonunion_f_u_161 {
   struct list_head fu_list ;
   struct callback_head fu_rcuhead ;
};
#line 757 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_161 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   int f_sb_list_cpu ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 900
struct files_struct;
#line 900 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 901 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 906 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 923
struct nlm_lockowner;
#line 924 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_163 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_162 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_163 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_162 fl_u ;
};
#line 1010 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1216 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1232
struct file_system_type;
#line 1232
struct super_operations;
#line 1232
struct xattr_handler;
#line 1232
struct mtd_info;
#line 1232 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head *s_files ;
   struct list_head s_mounts ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   spinlock_t s_inode_lru_lock ;
   struct list_head s_inode_lru ;
   int s_nr_inodes_unused ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
};
#line 1469 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1507
struct block_device_operations;
#line 1508 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1545 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
};
#line 1588 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   int (*nr_cached_objects)(struct super_block * ) ;
   void (*free_cached_objects)(struct super_block * , int  ) ;
};
#line 1801 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 23 "include/linux/sem.h"
struct sem_undo_list;
#line 23 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 24 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_164 {
   unsigned long sig[1U] ;
};
#line 24 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_164 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 22 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/asm-generic/signal-defs.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 124 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 34 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_166 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_167 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_169 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_170 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_165 {
   int _pad[28U] ;
   struct __anonstruct__kill_166 _kill ;
   struct __anonstruct__timer_167 _timer ;
   struct __anonstruct__rt_168 _rt ;
   struct __anonstruct__sigchld_169 _sigchld ;
   struct __anonstruct__sigfault_170 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_165 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 80 "include/linux/seccomp.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/seccomp.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 11 "include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 30 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 33 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 35
struct signal_struct;
#line 36
struct key_type;
#line 38
struct keyring_list;
#line 116 "include/linux/key.h"
union __anonunion_ldv_27285_175 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 116
struct key_user;
#line 116 "include/linux/key.h"
union __anonunion_ldv_27294_176 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 116 "include/linux/key.h"
union __anonunion_type_data_177 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 116 "include/linux/key.h"
union __anonunion_payload_178 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 116 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_27285_175 ldv_27285 ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_27294_176 ldv_27294 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_177 type_data ;
   union __anonunion_payload_178 payload ;
};
#line 323
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct thread_group_cred;
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 345
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 185
struct futex_pi_state;
#line 186
struct robust_list_head;
#line 187
struct bio_list;
#line 188
struct fs_struct;
#line 189
struct perf_event_context;
#line 190
struct blk_plug;
#line 121 "include/linux/sched.h"
struct cfs_rq;
#line 122
struct task_group;
#line 44 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 106 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/aio_abi.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 38 "include/linux/uio.h"
struct kioctx;
#line 39 "include/linux/uio.h"
union __anonunion_ki_obj_179 {
   void *user ;
   struct task_struct *tsk ;
};
#line 39
struct eventfd_ctx;
#line 39 "include/linux/uio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_179 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct list_head ki_batch ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 161 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8U] ;
};
#line 181 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct callback_head callback_head ;
};
#line 378 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 430 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 438 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 445 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 457 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 477 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 513
struct autogroup;
#line 514
struct tty_struct;
#line 514
struct taskstats;
#line 514
struct tty_audit_buf;
#line 514 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 690 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 734
struct reclaim_state;
#line 735 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 750 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1051
struct rq;
#line 1052 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*dequeue_task)(struct rq * , struct task_struct * , int  ) ;
   void (*yield_task)(struct rq * ) ;
   bool (*yield_to_task)(struct rq * , struct task_struct * , bool  ) ;
   void (*check_preempt_curr)(struct rq * , struct task_struct * , int  ) ;
   struct task_struct *(*pick_next_task)(struct rq * ) ;
   void (*put_prev_task)(struct rq * , struct task_struct * ) ;
   int (*select_task_rq)(struct task_struct * , int  , int  ) ;
   void (*migrate_task_rq)(struct task_struct * , int  ) ;
   void (*pre_schedule)(struct rq * , struct task_struct * ) ;
   void (*post_schedule)(struct rq * ) ;
   void (*task_waking)(struct task_struct * ) ;
   void (*task_woken)(struct rq * , struct task_struct * ) ;
   void (*set_cpus_allowed)(struct task_struct * , struct cpumask  const  * ) ;
   void (*rq_online)(struct rq * ) ;
   void (*rq_offline)(struct rq * ) ;
   void (*set_curr_task)(struct rq * ) ;
   void (*task_tick)(struct rq * , struct task_struct * , int  ) ;
   void (*task_fork)(struct task_struct * ) ;
   void (*switched_from)(struct rq * , struct task_struct * ) ;
   void (*switched_to)(struct rq * , struct task_struct * ) ;
   void (*prio_changed)(struct rq * , struct task_struct * , int  ) ;
   unsigned int (*get_rr_interval)(struct rq * , struct task_struct * ) ;
   void (*task_move_group)(struct task_struct * , int  ) ;
};
#line 1119 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1124 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1136 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1171 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1206
struct rt_rq;
#line 1206 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1229 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1600
struct css_set;
#line 1600
struct compat_robust_list_head;
#line 1600 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct hlist_head preempt_notifiers ;
   unsigned char fpu_counter ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char did_exec : 1 ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   int numa_migrate_seq ;
   unsigned int numa_scan_period ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   atomic_t ptrace_bp_refcnt ;
   struct uprobe_task *utask ;
};
#line 2853 "include/linux/sched.h"
union __anonunion_ldv_29188_181 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 2853 "include/linux/sched.h"
union __anonunion_ldv_29192_182 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 2853 "include/linux/sched.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion_ldv_29188_181 ldv_29188 ;
   union __anonunion_ldv_29192_182 ldv_29192 ;
   unsigned int flags ;
};
#line 92 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 91 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   sector_t bip_sector ;
   void *bip_buf ;
   bio_end_io_t *bip_end_io ;
   unsigned int bip_size ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_idx ;
   struct work_struct bip_work ;
   struct bio_vec bip_vec[0U] ;
};
#line 296 "include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_pool ;
};
#line 415 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 50 "include/linux/proc_fs.h"
typedef int read_proc_t(char * , char ** , off_t  , int  , int * , void * );
#line 52 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file * , char const   * , unsigned long  , void * );
#line 53 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   umode_t mode ;
   nlink_t nlink ;
   kuid_t uid ;
   kgid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
   spinlock_t pde_unload_lock ;
   u8 namelen ;
   char name[] ;
};
#line 261 "include/linux/proc_fs.h"
struct proc_ns_operations {
   char const   *name ;
   int type ;
   void *(*get)(struct task_struct * ) ;
   void (*put)(void * ) ;
   int (*install)(struct nsproxy * , void * ) ;
   unsigned int (*inum)(void * ) ;
};
#line 278 "include/linux/proc_fs.h"
union proc_op {
   int (*proc_get_link)(struct dentry * , struct path * ) ;
   int (*proc_read)(struct task_struct * , char * ) ;
   int (*proc_show)(struct seq_file * , struct pid_namespace * , struct pid * , struct task_struct * ) ;
};
#line 284 "include/linux/proc_fs.h"
struct proc_inode {
   struct pid *pid ;
   int fd ;
   union proc_op op ;
   struct proc_dir_entry *pde ;
   struct ctl_table_header *sysctl ;
   struct ctl_table *sysctl_entry ;
   void *ns ;
   struct proc_ns_operations  const  *ns_ops ;
   struct inode vfs_inode ;
};
#line 320 "include/linux/proc_fs.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   void *private ;
};
#line 34 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 82 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/hdreg.h"
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 39 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 275 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 279 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 80 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 71 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 11 "include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 54 "include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned char for_kupdate : 1 ;
   unsigned char for_background : 1 ;
   unsigned char tagged_writepages : 1 ;
   unsigned char for_reclaim : 1 ;
   unsigned char range_cyclic : 1 ;
};
#line 81
struct bdi_writeback;
#line 39 "include/linux/backing-dev.h"
typedef int congested_fn(void * , int  );
#line 48 "include/linux/backing-dev.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned int nr ;
   unsigned long last_old_flush ;
   unsigned long last_active ;
   struct task_struct *task ;
   struct timer_list wakeup_timer ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   spinlock_t list_lock ;
};
#line 65 "include/linux/backing-dev.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct percpu_counter bdi_stat[4U] ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   struct bdi_writeback wb ;
   spinlock_t wb_lock ;
   struct list_head work_list ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 63 "include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 22 "include/linux/bsg.h"
struct elevator_queue;
#line 25
struct request;
#line 27
struct bsg_job;
#line 28
struct blkcg_gq;
#line 47 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 48 "include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 67
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_SPECIAL = 7,
    REQ_TYPE_ATA_TASKFILE = 8,
    REQ_TYPE_ATA_PC = 9
} ;
#line 79 "include/linux/blkdev.h"
union __anonunion_ldv_32500_209 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 79 "include/linux/blkdev.h"
struct __anonstruct_elv_211 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 79 "include/linux/blkdev.h"
struct __anonstruct_flush_212 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 79 "include/linux/blkdev.h"
union __anonunion_ldv_32511_210 {
   struct __anonstruct_elv_211 elv ;
   struct __anonstruct_flush_212 flush ;
};
#line 79 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct call_single_data csd ;
   struct request_queue *q ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   struct hlist_node hash ;
   union __anonunion_ldv_32500_209 ldv_32500 ;
   union __anonunion_ldv_32511_210 ldv_32511 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   int ref_count ;
   void *special ;
   char *buffer ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 10 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 13 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 17 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 19 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 22 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 24 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 25 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 26 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 29 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 30 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 31 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 33 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 34 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 35 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 37 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * );
#line 38 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 39 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
};
#line 69 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 77 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 98 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   struct hlist_head *hash ;
   unsigned char registered : 1 ;
};
#line 217 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 218 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 219 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 220 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 221 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 229 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 231 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 232 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 233 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 234 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 235
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 242 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 248 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
};
#line 257 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
};
#line 286
struct throtl_data;
#line 286 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   unsigned char flush_queue_delayed : 1 ;
   unsigned char flush_pending_idx : 1 ;
   unsigned char flush_running_idx : 1 ;
   unsigned long flush_pending_since ;
   struct list_head flush_queue[2U] ;
   struct list_head flush_data_in_flight ;
   struct request flush_rq ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct list_head all_q_node ;
   struct throtl_data *td ;
};
#line 960 "include/linux/blkdev.h"
struct blk_plug {
   unsigned long magic ;
   struct list_head list ;
   struct list_head cb_list ;
   unsigned int should_sort ;
};
#line 1319 "include/linux/blkdev.h"
struct blk_integrity_exchg {
   void *prot_buf ;
   void *data_buf ;
   sector_t sector ;
   unsigned int data_size ;
   unsigned short sector_size ;
   char const   *disk_name ;
};
#line 1351 "include/linux/blkdev.h"
typedef void integrity_gen_fn(struct blk_integrity_exchg * );
#line 1352 "include/linux/blkdev.h"
typedef int integrity_vrfy_fn(struct blk_integrity_exchg * );
#line 1353 "include/linux/blkdev.h"
typedef void integrity_set_tag_fn(void * , void * , unsigned int  );
#line 1354 "include/linux/blkdev.h"
typedef void integrity_get_tag_fn(void * , void * , unsigned int  );
#line 1355 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_gen_fn *generate_fn ;
   integrity_vrfy_fn *verify_fn ;
   integrity_set_tag_fn *set_tag_fn ;
   integrity_get_tag_fn *get_tag_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short sector_size ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1414 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   int (*release)(struct gendisk * , fmode_t  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 1504
struct scsi_cmnd;
#line 274 "include/scsi/sg.h"
struct scsi_device;
#line 136 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct __anonstruct_PeripDev_221 {
   __u8 Dev ;
   unsigned char Bus : 6 ;
   unsigned char Mode : 2 ;
};
#line 136 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct __anonstruct_LogDev_222 {
   __u8 DevLSB ;
   unsigned char DevMSB : 6 ;
   unsigned char Mode : 2 ;
};
#line 136 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct __anonstruct_LogUnit_223 {
   unsigned char Dev : 5 ;
   unsigned char Bus : 3 ;
   unsigned char Targ : 6 ;
   unsigned char Mode : 2 ;
};
#line 136 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
union _SCSI3Addr_struct {
   struct __anonstruct_PeripDev_221 PeripDev ;
   struct __anonstruct_LogDev_222 LogDev ;
   struct __anonstruct_LogUnit_223 LogUnit ;
};
#line 73 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef union _SCSI3Addr_struct SCSI3Addr_struct;
#line 74 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _PhysDevAddr_struct {
   unsigned int TargetId : 24 ;
   unsigned char Bus : 6 ;
   unsigned char Mode : 2 ;
   SCSI3Addr_struct Target[2U] ;
};
#line 80 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef struct _PhysDevAddr_struct PhysDevAddr_struct;
#line 81 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _LogDevAddr_struct {
   unsigned int VolId : 30 ;
   unsigned char Mode : 2 ;
   __u8 reserved[4U] ;
};
#line 86 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef struct _LogDevAddr_struct LogDevAddr_struct;
#line 87 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
union _LUNAddr_struct {
   __u8 LunAddrBytes[8U] ;
   SCSI3Addr_struct SCSI3Lun[4U] ;
   PhysDevAddr_struct PhysDev ;
   LogDevAddr_struct LogDev ;
};
#line 93 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef union _LUNAddr_struct LUNAddr_struct;
#line 94 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct __anonstruct_Type_224 {
   unsigned char Type : 3 ;
   unsigned char Attribute : 3 ;
   unsigned char Direction : 2 ;
};
#line 94 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _RequestBlock_struct {
   __u8 CDBLen ;
   struct __anonstruct_Type_224 Type ;
   __u16 Timeout ;
   __u8 CDB[16U] ;
};
#line 104 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef struct _RequestBlock_struct RequestBlock_struct;
#line 105 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct __anonstruct_Common_Info_225 {
   __u8 Reserved[3U] ;
   __u8 Type ;
   __u32 ErrorInfo ;
};
#line 105 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct __anonstruct_Invalid_Cmd_226 {
   __u8 Reserved[2U] ;
   __u8 offense_size ;
   __u8 offense_num ;
   __u32 offense_value ;
};
#line 105 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
union _MoreErrInfo_struct {
   struct __anonstruct_Common_Info_225 Common_Info ;
   struct __anonstruct_Invalid_Cmd_226 Invalid_Cmd ;
};
#line 118 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef union _MoreErrInfo_struct MoreErrInfo_struct;
#line 119 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _ErrorInfo_struct {
   __u8 ScsiStatus ;
   __u8 SenseLen ;
   __u16 CommandStatus ;
   __u32 ResidualCnt ;
   MoreErrInfo_struct MoreErrInfo ;
   __u8 SenseInfo[32U] ;
};
#line 126 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
typedef struct _ErrorInfo_struct ErrorInfo_struct;
#line 127 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/include/uapi/linux/cciss_defs.h"
struct _vals32 {
   __u32 lower ;
   __u32 upper ;
};
#line 70 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _vals32 vals32;
#line 71 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
union _u64bit {
   vals32 val32 ;
   __u64 val ;
};
#line 76 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef union _u64bit u64bit;
#line 77 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _InquiryData_struct {
   __u8 data_byte[36U] ;
};
#line 92 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _InquiryData_struct InquiryData_struct;
#line 93 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _ReportLUNdata_struct {
   __u8 LUNListLength[4U] ;
   __u32 reserved ;
   __u8 LUN[1024U][8U] ;
};
#line 102 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _ReportLUNdata_struct ReportLunData_struct;
#line 103 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _ReadCapdata_struct {
   __u8 total_size[4U] ;
   __u8 block_size[4U] ;
};
#line 109 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _ReadCapdata_struct ReadCapdata_struct;
#line 110 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _ReadCapdata_struct_16 {
   __u8 total_size[8U] ;
   __u8 block_size[4U] ;
   unsigned char prot_en : 1 ;
   unsigned char rto_en : 1 ;
   unsigned char reserved : 6 ;
   __u8 reserved2[18U] ;
};
#line 126 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _ReadCapdata_struct_16 ReadCapdata_struct_16;
#line 127 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _CommandListHeader_struct {
   __u8 ReplyQueue ;
   __u8 SGList ;
   __u16 SGTotal ;
   vals32 Tag ;
   LUNAddr_struct LUN ;
};
#line 163 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _CommandListHeader_struct CommandListHeader_struct;
#line 164 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _ErrDescriptor_struct {
   vals32 Addr ;
   __u32 Len ;
};
#line 167 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _ErrDescriptor_struct ErrDescriptor_struct;
#line 168 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _SGDescriptor_struct {
   vals32 Addr ;
   __u32 Len ;
   __u32 Ext ;
};
#line 172 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _SGDescriptor_struct SGDescriptor_struct;
#line 173 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _CommandList_struct {
   CommandListHeader_struct Header ;
   RequestBlock_struct Request ;
   ErrDescriptor_struct ErrDesc ;
   SGDescriptor_struct SG[32U] ;
   __u32 busaddr ;
   ErrorInfo_struct *err_info ;
   int ctlr ;
   int cmd_type ;
   long cmdindex ;
   struct list_head list ;
   struct request *rq ;
   struct completion *waiting ;
   int retry_count ;
   void *scsi_cmd ;
   char pad[4U] ;
};
#line 214 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _CommandList_struct CommandList_struct;
#line 215 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _HostWrite_struct {
   __u32 TransportRequest ;
   __u32 Reserved ;
   __u32 CoalIntDelay ;
   __u32 CoalIntCount ;
};
#line 222 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _HostWrite_struct HostWrite_struct;
#line 223 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct _CfgTable_struct {
   __u8 Signature[4U] ;
   __u32 SpecValence ;
   __u32 TransportSupport ;
   __u32 TransportActive ;
   HostWrite_struct HostWrite ;
   __u32 CmdsOutMax ;
   __u32 BusTypes ;
   __u32 TransMethodOffset ;
   __u8 ServerName[16U] ;
   __u32 HeartBeat ;
   __u32 SCSI_Prefetch ;
   __u32 MaxSGElements ;
   __u32 MaxLogicalUnits ;
   __u32 MaxPhysicalDrives ;
   __u32 MaxPhysicalDrivesPerLogicalUnit ;
   __u32 MaxPerformantModeCommands ;
   u8 reserved[32U] ;
   u32 misc_fw_support ;
   u8 driver_version[32U] ;
};
#line 249 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
typedef struct _CfgTable_struct CfgTable_struct;
#line 250 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_cmd.h"
struct TransTable_struct {
   u32 BlockFetch0 ;
   u32 BlockFetch1 ;
   u32 BlockFetch2 ;
   u32 BlockFetch3 ;
   u32 BlockFetch4 ;
   u32 BlockFetch5 ;
   u32 BlockFetch6 ;
   u32 BlockFetch7 ;
   u32 RepQSize ;
   u32 RepQCount ;
   u32 RepQCtrAddrLow32 ;
   u32 RepQCtrAddrHigh32 ;
   u32 RepQAddr0Low32 ;
   u32 RepQAddr0High32 ;
};
#line 267
struct ctlr_info;
#line 22 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
typedef struct ctlr_info ctlr_info_t;
#line 23 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct access_method {
   void (*submit_command)(ctlr_info_t * , CommandList_struct * ) ;
   void (*set_intr_mask)(ctlr_info_t * , unsigned long  ) ;
   unsigned long (*fifo_full)(ctlr_info_t * ) ;
   bool (*intr_pending)(ctlr_info_t * ) ;
   unsigned long (*command_completed)(ctlr_info_t * ) ;
};
#line 31 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct _drive_info_struct {
   unsigned char LunID[8U] ;
   int usage_count ;
   struct request_queue *queue ;
   sector_t nr_blocks ;
   int block_size ;
   int heads ;
   int sectors ;
   int cylinders ;
   int raid_level ;
   int busy_configuring ;
   struct device dev ;
   __u8 serial_no[16U] ;
   char vendor[9U] ;
   char model[17U] ;
   char rev[5U] ;
   char device_initialized ;
};
#line 56 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
typedef struct _drive_info_struct drive_info_struct;
#line 57
struct cciss_scsi_adapter_data_t;
#line 57 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct ctlr_info {
   int ctlr ;
   char devname[8U] ;
   char *product_name ;
   char firm_ver[4U] ;
   struct pci_dev *pdev ;
   __u32 board_id ;
   void *vaddr ;
   unsigned long paddr ;
   int nr_cmds ;
   CfgTable_struct *cfgtable ;
   int interrupts_enabled ;
   int major ;
   int max_commands ;
   int commands_outstanding ;
   int max_outstanding ;
   int num_luns ;
   int highest_lun ;
   int usage_count ;
   struct scatterlist **scatter_list ;
   int maxsgentries ;
   int chainsize ;
   int max_cmd_sgentries ;
   SGDescriptor_struct **cmd_sg_list ;
   unsigned int intr[4U] ;
   unsigned int msix_vector ;
   unsigned int msi_vector ;
   int intr_mode ;
   int cciss_max_sectors ;
   __u8 cciss_read ;
   __u8 cciss_write ;
   __u8 cciss_read_capacity ;
   drive_info_struct *drv[1024U] ;
   struct access_method access ;
   struct list_head reqQ ;
   struct list_head cmpQ ;
   unsigned int Qdepth ;
   unsigned int maxQsinceinit ;
   unsigned int maxSG ;
   spinlock_t lock ;
   CommandList_struct *cmd_pool ;
   dma_addr_t cmd_pool_dhandle ;
   ErrorInfo_struct *errinfo_pool ;
   dma_addr_t errinfo_pool_dhandle ;
   unsigned long *cmd_pool_bits ;
   int nr_allocs ;
   int nr_frees ;
   int busy_configuring ;
   int busy_initializing ;
   int busy_scanning ;
   struct mutex busy_shutting_down ;
   int next_to_run ;
   struct gendisk *gendisk[1024U] ;
   struct cciss_scsi_adapter_data_t *scsi_ctlr ;
   unsigned char alive ;
   struct list_head scan_list ;
   struct completion scan_wait ;
   struct device dev ;
   u32 trans_support ;
   u32 trans_offset ;
   struct TransTable_struct *transtable ;
   unsigned long transMethod ;
   u64 *reply_pool ;
   dma_addr_t reply_pool_dhandle ;
   u64 *reply_pool_head ;
   size_t reply_pool_size ;
   unsigned char reply_pool_wraparound ;
   u32 *blockFetchTable ;
};
#line 426 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct board_type {
   __u32 board_id ;
   char *product_name ;
   struct access_method *access ;
   int nr_cmds ;
};
#line 434 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
struct _cciss_pci_info_struct {
   unsigned char bus ;
   unsigned char dev_fn ;
   unsigned short domain ;
   __u32 board_id ;
};
#line 17 "include/uapi/linux/cciss_ioctl.h"
typedef struct _cciss_pci_info_struct cciss_pci_info_struct;
#line 18 "include/uapi/linux/cciss_ioctl.h"
struct _cciss_coalint_struct {
   __u32 delay ;
   __u32 count ;
};
#line 23 "include/uapi/linux/cciss_ioctl.h"
typedef struct _cciss_coalint_struct cciss_coalint_struct;
#line 25 "include/uapi/linux/cciss_ioctl.h"
typedef char NodeName_type[16U];
#line 27 "include/uapi/linux/cciss_ioctl.h"
typedef __u32 Heartbeat_type;
#line 33 "include/uapi/linux/cciss_ioctl.h"
typedef __u32 BusTypes_type;
#line 35 "include/uapi/linux/cciss_ioctl.h"
typedef char FirmwareVer_type[4U];
#line 36 "include/uapi/linux/cciss_ioctl.h"
typedef __u32 DriverVer_type;
#line 37 "include/uapi/linux/cciss_ioctl.h"
struct _IOCTL_Command_struct {
   LUNAddr_struct LUN_info ;
   RequestBlock_struct Request ;
   ErrorInfo_struct error_info ;
   __u16 buf_size ;
   __u8 *buf ;
};
#line 46 "include/uapi/linux/cciss_ioctl.h"
typedef struct _IOCTL_Command_struct IOCTL_Command_struct;
#line 47 "include/uapi/linux/cciss_ioctl.h"
struct _BIG_IOCTL_Command_struct {
   LUNAddr_struct LUN_info ;
   RequestBlock_struct Request ;
   ErrorInfo_struct error_info ;
   __u32 malloc_size ;
   __u32 buf_size ;
   __u8 *buf ;
};
#line 56 "include/uapi/linux/cciss_ioctl.h"
typedef struct _BIG_IOCTL_Command_struct BIG_IOCTL_Command_struct;
#line 57 "include/uapi/linux/cciss_ioctl.h"
struct _LogvolInfo_struct {
   __u32 LunID ;
   int num_opens ;
   int num_parts ;
};
#line 62 "include/uapi/linux/cciss_ioctl.h"
typedef struct _LogvolInfo_struct LogvolInfo_struct;
#line 63 "include/uapi/linux/cciss_ioctl.h"
struct _IOCTL32_Command_struct {
   LUNAddr_struct LUN_info ;
   RequestBlock_struct Request ;
   ErrorInfo_struct error_info ;
   __u16 buf_size ;
   __u32 buf ;
};
#line 15 "include/linux/cciss_ioctl.h"
typedef struct _IOCTL32_Command_struct IOCTL32_Command_struct;
#line 16 "include/linux/cciss_ioctl.h"
struct _BIG_IOCTL32_Command_struct {
   LUNAddr_struct LUN_info ;
   RequestBlock_struct Request ;
   ErrorInfo_struct error_info ;
   __u32 malloc_size ;
   __u32 buf_size ;
   __u32 buf ;
};
#line 25 "include/linux/cciss_ioctl.h"
typedef struct _BIG_IOCTL32_Command_struct BIG_IOCTL32_Command_struct;
#line 419 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct Scsi_Host;
#line 421 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 37 "include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 53 "include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   unsigned char tag ;
};
#line 311
struct scsi_sense_hdr;
#line 25 "include/scsi/scsi_device.h"
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
#line 64
struct scsi_target;
#line 64
struct scsi_dh_data;
#line 64 "include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   unsigned int device_busy ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int lun ;
   unsigned int channel ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned char writeable : 1 ;
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char ordered_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char can_power_off : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   unsigned long supported_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int device_blocked ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
#line 187 "include/scsi/scsi_device.h"
struct scsi_dh_devlist {
   char *vendor ;
   char *model ;
};
#line 194 "include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   struct scsi_dh_devlist  const  *devlist ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   int (*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
#line 210 "include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
   char buf[0U] ;
};
#line 217
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 223 "include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   unsigned int reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned int target_busy ;
   unsigned int can_queue ;
   unsigned int target_blocked ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   struct execute_work ew ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
#line 495
struct scsi_host_cmd_pool;
#line 496
struct scsi_transport_template;
#line 504 "include/scsi/scsi_device.h"
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*transfer_response)(struct scsi_cmnd * , void (*)(struct scsi_cmnd * ) ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  , int  ) ;
   int (*change_queue_type)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*proc_info)(struct Scsi_Host * , char * , char ** , off_t  , int  , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char ordered_tag : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
};
#line 518 "include/scsi/scsi_host.h"
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 528 "include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   struct blk_queue_tag *bqt ;
   unsigned int host_busy ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int resetting ;
   unsigned long last_reset ;
   unsigned int max_id ;
   unsigned int max_lun ;
   unsigned int max_channel ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned short max_sectors ;
   unsigned long dma_boundary ;
   unsigned long cmd_serial_number ;
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char use_blk_tcq : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char ordered_tag : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   unsigned int host_blocked ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
#line 19 "include/scsi/scsicam.h"
struct cciss_scsi_dev_t {
   int devtype ;
   int bus ;
   int target ;
   int lun ;
   unsigned char scsi3addr[8U] ;
   unsigned char device_id[16U] ;
   unsigned char vendor[8U] ;
   unsigned char model[16U] ;
   unsigned char revision[4U] ;
};
#line 70 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.h"
struct cciss_scsi_hba_t {
   char *name ;
   int ndevices ;
   struct cciss_scsi_dev_t dev[16U] ;
};
#line 85 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
struct cciss_scsi_cmd_stack_elem_t {
   CommandList_struct cmd ;
   ErrorInfo_struct Err ;
   __u32 busaddr ;
   int cmdindex ;
   u8 pad[8U] ;
};
#line 107 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
struct cciss_scsi_cmd_stack_t {
   struct cciss_scsi_cmd_stack_elem_t *pool ;
   struct cciss_scsi_cmd_stack_elem_t **elem ;
   dma_addr_t cmd_pool_handle ;
   int top ;
   int nelems ;
};
#line 118 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
struct cciss_scsi_adapter_data_t {
   struct Scsi_Host *scsi_host ;
   struct cciss_scsi_cmd_stack_t cmd_stack ;
   SGDescriptor_struct **cmd_sg_list ;
   int registered ;
   spinlock_t lock ;
};
#line 372 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
struct scsi2map {
   char scsi3addr[8U] ;
   int bus ;
   int target ;
   int lun ;
};
#line 4489 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct __anonstruct_Command_237 {
   CommandListHeader_struct CommandHeader ;
   RequestBlock_struct Request ;
   ErrDescriptor_struct ErrorDescriptor ;
};
#line 4489 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
typedef struct __anonstruct_Command_237 Command;
#line 8568 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
typedef int ldv_func_ret_type___2;
#line 8670 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
typedef int ldv_func_ret_type___12;
#line 1 "<compiler builtins>"
#line 1
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 100 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(int nr , unsigned long volatile   *addr ) 
{ 


  {
#line 107
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 109
  return;
}
}
#line 197 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 201
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2,%1\n\tsbb %0,%0": "=r" (oldbit),
                       "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 204
  return (oldbit);
}
}
#line 45 "include/asm-generic/bitops/find.h"
extern unsigned long find_first_zero_bit(unsigned long const   * , unsigned long  ) ;
#line 7 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 14 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 159 "include/linux/init.h"
extern unsigned int reset_devices ;
#line 119 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 53 "include/linux/dynamic_debug.h"
extern int __dynamic_dev_dbg(struct _ddebug * , struct device  const  * , char const   * 
                             , ...) ;
#line 197 "include/linux/kernel.h"
extern void might_fault(void) ;
#line 358
extern int sprintf(char * , char const   *  , ...) ;
#line 361
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 111
extern void __list_del_entry(struct list_head * ) ;
#line 112
extern void list_del(struct list_head * ) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
#line 146
  return;
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 61 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/page_64_types.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 355 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 88 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2861;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2861: ;
#line 14
  return (pfo_ret__);
}
}
#line 34 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 60
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 61
extern size_t strlen(char const   * ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 41
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 159 "include/linux/bitmap.h"
__inline static void bitmap_zero(unsigned long *dst , int nbits ) 
{ 
  int len ;

  {
#line 164
  len = (int )((unsigned int )(((unsigned long )nbits + 63UL) / 64UL) * 8U);
#line 165
  memset((void *)dst, 0, (size_t )len);
#line 167
  return;
}
}
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 71
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 823 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 825
  __edi = __edi;
#line 825
  __esi = __esi;
#line 825
  __edx = __edx;
#line 825
  __ecx = __ecx;
#line 825
  __eax = __eax;
#line 825
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 825
  if (tmp != 0L) {
#line 825
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/paravirt.h"),
                         "i" (825), "i" (12UL));
    ldv_4725: ;
#line 825
    goto ldv_4725;
  } else {

  }
#line 825
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 825
  __ret = __eax;
#line 825
  return (__ret);
}
}
#line 22 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 


  {
#line 24
  return ((void *)error);
}
}
#line 27 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 


  {
#line 29
  return ((long )ptr);
}
}
#line 32 "include/linux/err.h"
__inline static long IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 34
  tmp = ldv__builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
#line 34
  return (tmp);
}
}
#line 155 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 11 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 115 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 168
extern int mutex_trylock(struct mutex * ) ;
#line 171
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) ;
#line 175
int ldv_mutex_trylock_14(struct mutex *ldv_func_arg1 ) ;
#line 177
extern void mutex_unlock(struct mutex * ) ;
#line 180
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) ;
#line 184
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) ;
#line 188
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) ;
#line 192
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) ;
#line 196
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) ;
#line 200
void ldv_mutex_unlock_13(struct mutex *ldv_func_arg1 ) ;
#line 204
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
#line 208
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) ;
#line 212
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) ;
#line 216
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) ;
#line 220
void ldv_mutex_unlock_21(struct mutex *ldv_func_arg1 ) ;
#line 224
void ldv_mutex_unlock_23(struct mutex *ldv_func_arg1 ) ;
#line 228
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) ;
#line 232
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) ;
#line 236
void ldv_mutex_unlock_28(struct mutex *ldv_func_arg1 ) ;
#line 7 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 10
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) ;
#line 14
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) ;
#line 18
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) ;
#line 22
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) ;
#line 26
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) ;
#line 30
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_15(struct mutex *ldv_func_arg1 ) ;
#line 38
void ldv_mutex_lock_18(struct mutex *ldv_func_arg1 ) ;
#line 42
void ldv_mutex_lock_22(struct mutex *ldv_func_arg1 ) ;
#line 46
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) ;
#line 50
void ldv_mutex_lock_27(struct mutex *ldv_func_arg1 ) ;
#line 55
void ldv_mutex_lock_busy_shutting_down(struct mutex *lock ) ;
#line 56
int ldv_mutex_trylock_busy_shutting_down(struct mutex *lock ) ;
#line 59
void ldv_mutex_unlock_busy_shutting_down(struct mutex *lock ) ;
#line 63
void ldv_mutex_lock_cciss_mutex(struct mutex *lock ) ;
#line 67
void ldv_mutex_unlock_cciss_mutex(struct mutex *lock ) ;
#line 71
void ldv_mutex_lock_cred_guard_mutex(struct mutex *lock ) ;
#line 75
void ldv_mutex_unlock_cred_guard_mutex(struct mutex *lock ) ;
#line 79
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 83
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 87
void ldv_mutex_lock_mutex(struct mutex *lock ) ;
#line 88
int ldv_mutex_trylock_mutex(struct mutex *lock ) ;
#line 91
void ldv_mutex_unlock_mutex(struct mutex *lock ) ;
#line 95
void ldv_mutex_lock_scan_mutex(struct mutex *lock ) ;
#line 99
void ldv_mutex_unlock_scan_mutex(struct mutex *lock ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 29 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 32
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 272 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 274
  return (& lock->ldv_5961.rlock);
}
}
#line 308 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 310
  _raw_spin_lock_irq(& lock->ldv_5961.rlock);
#line 311
  return;
}
}
#line 333 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 335
  _raw_spin_unlock_irq(& lock->ldv_5961.rlock);
#line 336
  return;
}
}
#line 338 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 340
  _raw_spin_unlock_irqrestore(& lock->ldv_5961.rlock, flags);
#line 341
  return;
}
}
#line 63 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 79
extern void wait_for_completion(struct completion * ) ;
#line 80
extern int wait_for_completion_interruptible(struct completion * ) ;
#line 91
extern void complete(struct completion * ) ;
#line 92
extern void complete_all(struct completion * ) ;
#line 53 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ 
  unsigned char ret ;

  {
#line 53
  __asm__  volatile   ("movb %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
#line 53
  return (ret);
}
}
#line 55 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 55
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 55
  return (ret);
}
}
#line 61 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 


  {
#line 61
  __asm__  volatile   ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
#line 62
  return;
}
}
#line 63 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 63
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 64
  return;
}
}
#line 174
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 182 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
#line 184
  tmp = ioremap_nocache(offset, size);
#line 184
  return (tmp);
}
}
#line 187
extern void iounmap(void volatile   * ) ;
#line 351 "include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t  , unsigned int  ) ;
#line 366
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 80 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 82
  return ((char const   *)kobj->name);
}
}
#line 26 "include/linux/export.h"
extern struct module __this_module ;
#line 49 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 51
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 53
extern unsigned long copy_in_user(void * , void const   * , unsigned int  ) ;
#line 55 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 59
  tmp = __builtin_object_size((void const   *)to, 0);
#line 59
  sz = (int )tmp;
#line 61
  might_fault();
#line 62
  tmp___1 = ldv__builtin_expect(sz == -1, 1L);
#line 62
  if (tmp___1 != 0L) {
#line 63
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
#line 62
    tmp___2 = ldv__builtin_expect((unsigned long )sz >= n, 1L);
#line 62
    if (tmp___2 != 0L) {
#line 63
      n = _copy_from_user(to, from, (unsigned int )n);
    } else {
#line 66
      __ret_warn_on = 1;
#line 66
      tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 66
      if (tmp___0 != 0L) {
#line 66
        warn_slowpath_fmt("/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h",
                          66, "Buffer overflow detected!\n");
      } else {

      }
#line 66
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
    }
  }
#line 68
  return (n);
}
}
#line 72 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/uaccess_64.h"
__inline static int copy_to_user(void *dst , void const   *src , unsigned int size ) 
{ 
  unsigned long tmp ;

  {
#line 74
  might_fault();
#line 76
  tmp = _copy_to_user(dst, src, size);
#line 76
  return ((int )tmp);
}
}
#line 125 "include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 130 "include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
#line 133
  tmp = request_threaded_irq(irq, handler, 0, flags, name, dev);
#line 133
  return (tmp);
}
}
#line 178
extern void free_irq(unsigned int  , void * ) ;
#line 122 "include/linux/device.h"
extern int __bus_register(struct bus_type * , struct lock_class_key * ) ;
#line 124
extern void bus_unregister(struct bus_type * ) ;
#line 731 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 734
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 735
    return ((char const   *)dev->init_name);
  } else {

  }
#line 737
  tmp = kobject_name(& dev->kobj);
#line 737
  return (tmp);
}
}
#line 741
extern int dev_set_name(struct device * , char const   *  , ...) ;
#line 833
extern void device_initialize(struct device * ) ;
#line 834
extern int device_add(struct device * ) ;
#line 835
extern void device_del(struct device * ) ;
#line 845
extern void *dev_get_drvdata(struct device  const  * ) ;
#line 846
extern int dev_set_drvdata(struct device * , void * ) ;
#line 909
extern void put_device(struct device * ) ;
#line 946
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 948
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 952
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 66 "include/linux/io.h"
extern int check_signature(void const volatile   * , unsigned char const   * , int  ) ;
#line 752 "include/linux/pci.h"
extern int pci_find_capability(struct pci_dev * , int  ) ;
#line 778
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 780
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 784
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 786
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 794 "include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
#line 796
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 796
  return (tmp);
}
}
#line 798 "include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
#line 801
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 801
  return (tmp);
}
}
#line 807 "include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
#line 809
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
#line 809
  return (tmp);
}
}
#line 811 "include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
#line 814
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 814
  return (tmp);
}
}
#line 858
extern int pci_enable_device(struct pci_dev * ) ;
#line 875
extern void pci_disable_device(struct pci_dev * ) ;
#line 917
extern int pci_save_state(struct pci_dev * ) ;
#line 918
extern void pci_restore_state(struct pci_dev * ) ;
#line 987
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 989
extern void pci_release_regions(struct pci_dev * ) ;
#line 1023
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1032
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1134
extern int pci_enable_msi_block(struct pci_dev * , unsigned int  ) ;
#line 1136
extern void pci_disable_msi(struct pci_dev * ) ;
#line 1138
extern int pci_enable_msix(struct pci_dev * , struct msix_entry * , int  ) ;
#line 1141
extern void pci_disable_msix(struct pci_dev * ) ;
#line 771 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 773
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 80L) << 12) + 0xffff880000000000UL));
}
}
#line 232 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 224 "include/linux/slub_def.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 274 "include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 289
  tmp___2 = __kmalloc(size, flags);
#line 289
  return (tmp___2);
}
}
#line 422 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 424
  tmp = kmalloc(size, flags | 32768U);
#line 424
  return (tmp);
}
}
#line 34 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/pci.h"
__inline static int pci_domain_nr(struct pci_bus *bus ) 
{ 
  struct pci_sysdata *sd ;

  {
#line 36
  sd = (struct pci_sysdata *)bus->sysdata;
#line 37
  return (sd->domain);
}
}
#line 95 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 98
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 98
  if (tmp != 0L) {
#line 98
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (98), "i" (12UL));
    ldv_21576: ;
#line 98
    goto ldv_21576;
  } else {

  }
#line 99
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 99
  if (tmp___0 != 0L) {
#line 99
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (99), "i" (12UL));
    ldv_21577: ;
#line 99
    goto ldv_21577;
  } else {

  }
#line 101
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 205
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 207
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 63 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 65
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 70 "include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 


  {
#line 72
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0) && *(dev->dma_mask) != 0ULL);
}
}
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 53
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 27 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 19
  if (tmp___1 != 0L) {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_22051: ;
#line 19
    goto ldv_22051;
  } else {

  }
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, 0xffffea0000000000UL + (tmp___2 >> 12), (unsigned long )ptr & 4095UL,
                            size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, 0xffffea0000000000UL + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
#line 26
  return (addr);
}
}
#line 29 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 36
  if (tmp___1 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_22060: ;
#line 36
    goto ldv_22060;
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
#line 40
  return;
}
}
#line 71 "include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 75
  tmp = get_dma_ops(dev);
#line 75
  ops = tmp;
#line 78
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 78
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 79
  tmp___1 = valid_dma_direction((int )dir);
#line 79
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 79
  if (tmp___2 != 0L) {
#line 79
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (79), "i" (12UL));
    ldv_22094: ;
#line 79
    goto ldv_22094;
  } else {

  }
#line 80
  addr = (*(ops->map_page))(dev, page, offset, size, dir, 0);
#line 81
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
#line 83
  return (addr);
}
}
#line 86 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 89
  tmp = get_dma_ops(dev);
#line 89
  ops = tmp;
#line 91
  tmp___0 = valid_dma_direction((int )dir);
#line 91
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 91
  if (tmp___1 != 0L) {
#line 91
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (91), "i" (12UL));
    ldv_22102: ;
#line 91
    goto ldv_22102;
  } else {

  }
#line 92
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
#line 93
    (*(ops->unmap_page))(dev, addr, size, dir, 0);
  } else {

  }
#line 94
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
#line 95
  return;
}
}
#line 60 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 103 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp ;

  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
#line 145
  tmp___0 = is_device_dma_capable(dev);
#line 145
  if (tmp___0 == 0) {
#line 146
    return (0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return (0);
  } else {

  }
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
#line 155
  return (memory);
}
}
#line 160 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 166
  if (tmp___1 != 0L) {
#line 166
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/dma-mapping.h",
                       166);
  } else {

  }
#line 166
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
  } else {

  }
#line 174
  return;
}
}
#line 91 "include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 93
  tmp = dma_supported(dev, mask);
#line 93
  if (tmp == 0) {
#line 94
    return (-5);
  } else {

  }
#line 95
  dev->coherent_dma_mask = mask;
#line 96
  return (0);
}
}
#line 16 "include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
#line 19
  tmp = dma_alloc_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : 0,
                        size, dma_handle, 32U, 0);
#line 19
  return (tmp);
}
}
#line 23 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ 


  {
#line 26
  dma_free_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : 0,
                 size, vaddr, dma_handle, 0);
#line 27
  return;
}
}
#line 30 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ 
  dma_addr_t tmp ;

  {
#line 32
  tmp = dma_map_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : 0,
                             ptr, size, (enum dma_data_direction )direction, 0);
#line 32
  return (tmp);
}
}
#line 36 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ 


  {
#line 39
  dma_unmap_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : 0,
                         dma_addr, size, (enum dma_data_direction )direction, 0);
#line 40
  return;
}
}
#line 43 "include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page ,
                                        unsigned long offset , size_t size , int direction ) 
{ 
  dma_addr_t tmp ;

  {
#line 46
  tmp = dma_map_page((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : 0,
                     page, offset, size, (enum dma_data_direction )direction);
#line 46
  return (tmp);
}
}
#line 50 "include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction ) 
{ 


  {
#line 53
  dma_unmap_page((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : 0,
                 dma_address, size, (enum dma_data_direction )direction);
#line 54
  return;
}
}
#line 105 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 107
  tmp = dma_set_mask(& dev->dev, mask);
#line 107
  return (tmp);
}
}
#line 110 "include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
#line 112
  tmp = dma_set_coherent_mask(& dev->dev, mask);
#line 112
  return (tmp);
}
}
#line 1445 "include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 1447
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
#line 1447
  return (tmp);
}
}
#line 1450 "include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 1452
  dev_set_drvdata(& pdev->dev, data);
#line 1453
  return;
}
}
#line 1458 "include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
#line 1460
  tmp = dev_name(& pdev->dev);
#line 1460
  return (tmp);
}
}
#line 30 "include/linux/pci-aspm.h"
extern void pci_disable_link_state(struct pci_dev * , int  ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 48
extern void usleep_range(unsigned long  , unsigned long  ) ;
#line 210 "include/linux/capability.h"
extern bool capable(int  ) ;
#line 2043 "include/linux/fs.h"
extern int register_blkdev(unsigned int  , char const   * ) ;
#line 2044
extern void unregister_blkdev(unsigned int  , char const   * ) ;
#line 333 "include/linux/sched.h"
extern long schedule_timeout_uninterruptible(long  ) ;
#line 334
extern void schedule(void) ;
#line 2209
extern int wake_up_process(struct task_struct * ) ;
#line 115 "include/linux/proc_fs.h"
extern struct proc_dir_entry *proc_create_data(char const   * , umode_t  , struct proc_dir_entry * ,
                                               struct file_operations  const  * ,
                                               void * ) ;
#line 119
extern void remove_proc_entry(char const   * , struct proc_dir_entry * ) ;
#line 152
extern struct proc_dir_entry *proc_mkdir(char const   * , struct proc_dir_entry * ) ;
#line 302 "include/linux/proc_fs.h"
__inline static struct proc_inode *PROC_I(struct inode  const  *inode ) 
{ 
  struct inode  const  *__mptr ;

  {
#line 304
  __mptr = inode;
#line 304
  return ((struct proc_inode *)__mptr + 0xffffffffffffffc0UL);
}
}
#line 307 "include/linux/proc_fs.h"
__inline static struct proc_dir_entry *PDE(struct inode  const  *inode ) 
{ 
  struct proc_inode *tmp ;

  {
#line 309
  tmp = PROC_I(inode);
#line 309
  return (tmp->pde);
}
}
#line 83 "include/linux/seq_file.h"
extern int seq_open(struct file * , struct seq_operations  const  * ) ;
#line 84
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 85
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 86
extern int seq_release(struct inode * , struct file * ) ;
#line 92
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 286 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/arch/x86/include/asm/compat.h"
__inline static void *compat_ptr(compat_uptr_t uptr ) 
{ 


  {
#line 288
  return ((void *)((unsigned long )uptr));
}
}
#line 632 "include/linux/compat.h"
extern void *compat_alloc_user_space(unsigned long  ) ;
#line 413 "include/linux/genhd.h"
extern void add_disk(struct gendisk * ) ;
#line 414
extern void del_gendisk(struct gendisk * ) ;
#line 443 "include/linux/genhd.h"
__inline static void set_capacity(struct gendisk *disk , sector_t size ) 
{ 


  {
#line 445
  disk->part0.nr_sects = size;
#line 446
  return;
}
}
#line 613
extern struct gendisk *alloc_disk(int  ) ;
#line 615
extern void put_disk(struct gendisk * ) ;
#line 747 "include/linux/blkdev.h"
extern int scsi_cmd_blk_ioctl(struct block_device * , fmode_t  , unsigned int  , void * ) ;
#line 775
extern void blk_start_queue(struct request_queue * ) ;
#line 776
extern void blk_stop_queue(struct request_queue * ) ;
#line 808 "include/linux/blkdev.h"
__inline static sector_t blk_rq_pos(struct request  const  *rq ) 
{ 


  {
#line 810
  return ((sector_t )rq->__sector);
}
}
#line 813 "include/linux/blkdev.h"
__inline static unsigned int blk_rq_bytes(struct request  const  *rq ) 
{ 


  {
#line 815
  return ((unsigned int )rq->__data_len);
}
}
#line 825 "include/linux/blkdev.h"
__inline static unsigned int blk_rq_sectors(struct request  const  *rq ) 
{ 
  unsigned int tmp ;

  {
#line 827
  tmp = blk_rq_bytes(rq);
#line 827
  return (tmp >> 9);
}
}
#line 860
extern struct request *blk_peek_request(struct request_queue * ) ;
#line 861
extern void blk_start_request(struct request * ) ;
#line 881
extern void blk_end_request_all(struct request * , int  ) ;
#line 890
extern void blk_complete_request(struct request * ) ;
#line 900
extern struct request_queue *blk_init_queue(request_fn_proc * , spinlock_t * ) ;
#line 903
extern void blk_cleanup_queue(struct request_queue * ) ;
#line 905
extern void blk_queue_bounce_limit(struct request_queue * , u64  ) ;
#line 907
extern void blk_queue_max_hw_sectors(struct request_queue * , unsigned int  ) ;
#line 908
extern void blk_queue_max_segments(struct request_queue * , unsigned short  ) ;
#line 914
extern void blk_queue_logical_block_size(struct request_queue * , unsigned short  ) ;
#line 943
extern void blk_queue_softirq_done(struct request_queue * , softirq_done_fn * ) ;
#line 950
extern int blk_rq_map_sg(struct request_queue * , struct request * , struct scatterlist * ) ;
#line 345 "include/scsi/scsi.h"
extern char const   *scsi_device_type(unsigned int  ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 42
extern bool kthread_should_stop(void) ;
#line 125 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_tape_cmds  =    6;
#line 129 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_simple_mode  ;
#line 134 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct mutex cciss_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, 0xffffffffffffffffUL, {0, {0, 0}, "cciss_mutex.wait_lock",
                                                                     0, 0UL}}}}, {& cciss_mutex.wait_list,
                                                                                  & cciss_mutex.wait_list},
    0, 0, (void *)(& cciss_mutex), {0, {0, 0}, "cciss_mutex", 0, 0UL}};
#line 135 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct proc_dir_entry *proc_cciss  ;
#line 220 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static void SA5_submit_command(ctlr_info_t *h , CommandList_struct *c ) 
{ 


  {
#line 226
  writel(c->busaddr, (void volatile   *)h->vaddr + 64U);
#line 227
  readl((void const volatile   *)h->vaddr + 176U);
#line 228
  h->commands_outstanding = h->commands_outstanding + 1;
#line 229
  if (h->commands_outstanding > h->max_outstanding) {
#line 230
    h->max_outstanding = h->commands_outstanding;
  } else {

  }
#line 231
  return;
}
}
#line 238 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static void SA5_intr_mask(ctlr_info_t *h , unsigned long val ) 
{ 


  {
#line 240
  if (val != 0UL) {
#line 242
    h->interrupts_enabled = 1;
#line 243
    writel(0U, (void volatile   *)h->vaddr + 52U);
#line 244
    readl((void const volatile   *)h->vaddr + 52U);
  } else {
#line 247
    h->interrupts_enabled = 0;
#line 248
    writel(8U, (void volatile   *)h->vaddr + 52U);
#line 250
    readl((void const volatile   *)h->vaddr + 52U);
  }
#line 252
  return;
}
}
#line 258 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static void SA5B_intr_mask(ctlr_info_t *h , unsigned long val ) 
{ 


  {
#line 260
  if (val != 0UL) {
#line 262
    h->interrupts_enabled = 1;
#line 263
    writel(0U, (void volatile   *)h->vaddr + 52U);
#line 264
    readl((void const volatile   *)h->vaddr + 52U);
  } else {
#line 267
    h->interrupts_enabled = 0;
#line 268
    writel(4U, (void volatile   *)h->vaddr + 52U);
#line 270
    readl((void const volatile   *)h->vaddr + 52U);
  }
#line 272
  return;
}
}
#line 275 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static void SA5_performant_intr_mask(ctlr_info_t *h , unsigned long val ) 
{ 


  {
#line 277
  if (val != 0UL) {
#line 278
    h->interrupts_enabled = 1;
#line 279
    writel(0U, (void volatile   *)h->vaddr + 52U);
#line 280
    readl((void const volatile   *)h->vaddr + 52U);
  } else {
#line 282
    h->interrupts_enabled = 0;
#line 283
    writel(5U, (void volatile   *)h->vaddr + 52U);
#line 285
    readl((void const volatile   *)h->vaddr + 52U);
  }
#line 287
  return;
}
}
#line 293 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static unsigned long SA5_fifo_full(ctlr_info_t *h ) 
{ 


  {
#line 295
  if (h->commands_outstanding >= h->max_commands) {
#line 296
    return (1UL);
  } else {
#line 298
    return (0UL);
  }
}
}
#line 305 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static unsigned long SA5_completed(ctlr_info_t *h ) 
{ 
  unsigned long register_value ;
  unsigned int tmp ;

  {
#line 307
  tmp = readl((void const volatile   *)h->vaddr + 68U);
#line 307
  register_value = (unsigned long )tmp;
#line 309
  if (register_value != 4294967295UL) {
#line 311
    h->commands_outstanding = h->commands_outstanding - 1;
  } else {

  }
#line 322
  return (register_value);
}
}
#line 327 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static unsigned long SA5_performant_completed(ctlr_info_t *h ) 
{ 
  unsigned long register_value ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 329
  register_value = 4294967295UL;
#line 334
  tmp = readl((void const volatile   *)h->vaddr + 156U);
#line 334
  register_value = (unsigned long )tmp;
#line 336
  if (h->msi_vector == 0U && h->msix_vector == 0U) {
#line 337
    writel(1U, (void volatile   *)h->vaddr + 160U);
#line 341
    tmp___0 = readl((void const volatile   *)h->vaddr + 156U);
#line 341
    register_value = (unsigned long )tmp___0;
  } else {

  }
#line 344
  if ((*(h->reply_pool_head) & 1ULL) == (u64 )h->reply_pool_wraparound) {
#line 345
    register_value = (unsigned long )*(h->reply_pool_head);
#line 346
    h->reply_pool_head = h->reply_pool_head + 1;
#line 347
    h->commands_outstanding = h->commands_outstanding - 1;
  } else {
#line 349
    register_value = 4294967295UL;
  }
#line 352
  if ((unsigned long )h->reply_pool_head == (unsigned long )(h->reply_pool + (unsigned long )h->max_commands)) {
#line 353
    h->reply_pool_head = h->reply_pool;
#line 354
    h->reply_pool_wraparound = (unsigned int )h->reply_pool_wraparound ^ 1U;
  } else {

  }
#line 357
  return (register_value);
}
}
#line 362 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static bool SA5_intr_pending(ctlr_info_t *h ) 
{ 
  unsigned long register_value ;
  unsigned int tmp ;

  {
#line 364
  tmp = readl((void const volatile   *)h->vaddr + 48U);
#line 364
  register_value = (unsigned long )tmp;
#line 369
  if ((register_value & 8UL) != 0UL) {
#line 370
    return (1);
  } else {

  }
#line 371
  return (0);
}
}
#line 377 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static bool SA5B_intr_pending(ctlr_info_t *h ) 
{ 
  unsigned long register_value ;
  unsigned int tmp ;

  {
#line 379
  tmp = readl((void const volatile   *)h->vaddr + 48U);
#line 379
  register_value = (unsigned long )tmp;
#line 384
  if ((register_value & 4UL) != 0UL) {
#line 385
    return (1);
  } else {

  }
#line 386
  return (0);
}
}
#line 389 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static bool SA5_performant_intr_pending(ctlr_info_t *h ) 
{ 
  unsigned long register_value ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 391
  tmp = readl((void const volatile   *)h->vaddr + 48U);
#line 391
  register_value = (unsigned long )tmp;
#line 393
  if (register_value == 0UL) {
#line 394
    return (0);
  } else {

  }
#line 396
  if (h->msi_vector != 0U || h->msix_vector != 0U) {
#line 397
    return (1);
  } else {

  }
#line 400
  tmp___0 = readl((void const volatile   *)h->vaddr + 156U);
#line 400
  register_value = (unsigned long )tmp___0;
#line 401
  return ((register_value & 1UL) != 0UL);
}
}
#line 404 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static struct access_method SA5_access  =    {& SA5_submit_command, & SA5_intr_mask, & SA5_fifo_full, & SA5_intr_pending, & SA5_completed};
#line 412 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static struct access_method SA5B_access  =    {& SA5_submit_command, & SA5B_intr_mask, & SA5_fifo_full, & SA5B_intr_pending,
    & SA5_completed};
#line 420 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss.h"
static struct access_method SA5_performant_access  =    {& SA5_submit_command, & SA5_performant_intr_mask, & SA5_fifo_full, & SA5_performant_intr_pending,
    & SA5_performant_completed};
#line 142 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct pci_device_id  const  cciss_pci_device_id[21U]  = 
#line 142 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
  {      {3601U, 45152U, 3601U, 16496U, 0U, 0U, 0UL}, 
        {3601U, 45432U, 3601U, 16512U, 0U, 0U, 0UL}, 
        {3601U, 45432U, 3601U, 16514U, 0U, 0U, 0UL}, 
        {3601U, 45432U, 3601U, 16515U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16529U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16538U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16539U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16540U, 0U, 0U, 0UL}, 
        {3601U, 70U, 3601U, 16541U, 0U, 0U, 0UL}, 
        {4156U, 12832U, 4156U, 12837U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12835U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12852U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12853U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12817U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12818U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12819U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12820U, 0U, 0U, 0UL}, 
        {4156U, 12856U, 4156U, 12821U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12855U, 0U, 0U, 0UL}, 
        {4156U, 12848U, 4156U, 12861U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 166 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 172 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct board_type products[22U]  = 
#line 172
  {      {1081085457U, (char *)"Smart Array 5300", & SA5_access, 0}, 
        {1082134033U, (char *)"Smart Array 5i", & SA5B_access, 0}, 
        {1082265105U, (char *)"Smart Array 532", & SA5B_access, 0}, 
        {1082330641U, (char *)"Smart Array 5312", & SA5B_access, 0}, 
        {1083837969U, (char *)"Smart Array 641", & SA5_access, 0}, 
        {1083903505U, (char *)"Smart Array 642", & SA5_access, 0}, 
        {1083969041U, (char *)"Smart Array 6400", & SA5_access, 0}, 
        {1084034577U, (char *)"Smart Array 6400 EM", & SA5_access, 0}, 
        {1083248145U, (char *)"Smart Array 6i", & SA5_access, 0}, 
        {841289788U, (char *)"Smart Array P600", & SA5_access, 0}, 
        {841158716U, (char *)"Smart Array P800", & SA5_access, 0}, 
        {842272828U, (char *)"Smart Array P400", & SA5_access, 0}, 
        {842338364U, (char *)"Smart Array P400i", & SA5_access, 0}, 
        {839979068U, (char *)"Smart Array E200i", & SA5_access, 0}, 
        {840044604U, (char *)"Smart Array E200", & SA5_access, 0}, 
        {840110140U, (char *)"Smart Array E200i", & SA5_access, 0}, 
        {840175676U, (char *)"Smart Array E200i", & SA5_access, 0}, 
        {840241212U, (char *)"Smart Array E200i", & SA5_access, 0}, 
        {842469436U, (char *)"Smart Array E500", & SA5_access, 0}, 
        {841158716U, (char *)"Smart Array P800", & SA5_access, 0}, 
        {842272828U, (char *)"Smart Array P400", & SA5_access, 0}, 
        {842862652U, (char *)"Smart Array P700m", & SA5_access, 0}};
#line 209 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ctlr_info_t *hba[32U]  ;
#line 211 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct task_struct *cciss_scan_thread  ;
#line 212 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct mutex scan_mutex  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, 0xffffffffffffffffUL, {0, {0, 0}, "scan_mutex.wait_lock",
                                                                     0, 0UL}}}}, {& scan_mutex.wait_list,
                                                                                  & scan_mutex.wait_list},
    0, 0, (void *)(& scan_mutex), {0, {0, 0}, "scan_mutex", 0, 0UL}};
#line 213 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct list_head scan_q  =    {& scan_q, & scan_q};
#line 215
static void do_cciss_request(struct request_queue *q ) ;
#line 216
static irqreturn_t do_cciss_intx(int irq , void *dev_id ) ;
#line 217
static irqreturn_t do_cciss_msix_intr(int irq , void *dev_id ) ;
#line 218
static int cciss_open(struct block_device *bdev , fmode_t mode ) ;
#line 219
static int cciss_unlocked_open(struct block_device *bdev , fmode_t mode ) ;
#line 220
static int cciss_release(struct gendisk *disk , fmode_t mode ) ;
#line 221
static int do_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                    unsigned long arg ) ;
#line 223
static int cciss_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                       unsigned long arg ) ;
#line 225
static int cciss_getgeo(struct block_device *bdev , struct hd_geometry *geo ) ;
#line 227
static int cciss_revalidate(struct gendisk *disk ) ;
#line 228
static int rebuild_lun_table(ctlr_info_t *h , int first_time , int via_ioctl ) ;
#line 229
static int deregister_disk(ctlr_info_t *h , int drv_index , int clear_all , int via_ioctl ) ;
#line 232
static void cciss_read_capacity(ctlr_info_t *h , int logvol , sector_t *total_size ,
                                unsigned int *block_size___0 ) ;
#line 234
static void cciss_read_capacity_16(ctlr_info_t *h , int logvol , sector_t *total_size ,
                                   unsigned int *block_size___0 ) ;
#line 236
static void cciss_geometry_inquiry(ctlr_info_t *h , int logvol , sector_t total_size ,
                                   unsigned int block_size___0 , InquiryData_struct *inq_buff ,
                                   drive_info_struct *drv ) ;
#line 240
static void cciss_interrupt_mode(ctlr_info_t *h ) ;
#line 241
static int cciss_enter_simple_mode(struct ctlr_info *h ) ;
#line 242
static void start_io(ctlr_info_t *h ) ;
#line 243
static int sendcmd_withirq(ctlr_info_t *h , __u8 cmd , void *buff , size_t size ,
                           __u8 page_code , unsigned char *scsi3addr , int cmd_type ) ;
#line 246
static int sendcmd_withirq_core(ctlr_info_t *h , CommandList_struct *c , int attempt_retry ) ;
#line 248
static int process_sendcmd_error(ctlr_info_t *h , CommandList_struct *c ) ;
#line 250
static int add_to_scan_list(struct ctlr_info *h ) ;
#line 251
static int scan_thread(void *data ) ;
#line 252
static int check_for_unit_attention(ctlr_info_t *h , CommandList_struct *c ) ;
#line 253
static void cciss_hba_release(struct device *dev ) ;
#line 254
static void cciss_device_release(struct device *dev ) ;
#line 255
static void cciss_free_gendisk(ctlr_info_t *h , int drv_index ) ;
#line 256
static void cciss_free_drive_info(ctlr_info_t *h , int drv_index ) ;
#line 257
__inline static u32 next_command(ctlr_info_t *h ) ;
#line 258
static int cciss_find_cfg_addrs(struct pci_dev *pdev , void *vaddr , u32 *cfg_base_addr ,
                                u64 *cfg_base_addr_index , u64 *cfg_offset ) ;
#line 261
static int cciss_pci_find_memory_BAR(struct pci_dev *pdev , unsigned long *memory_bar ) ;
#line 263
__inline static u32 cciss_tag_discard_error_bits(ctlr_info_t *h , u32 tag ) ;
#line 264
static int write_driver_ver_to_cfgtable(CfgTable_struct *cfgtable ) ;
#line 268
static void calc_bucket_map(int *bucket , int num_buckets , int nsgs , int *bucket_map ) ;
#line 270
static void cciss_put_controller_into_performant_mode(ctlr_info_t *h ) ;
#line 273
static void cciss_procinit(ctlr_info_t *h ) ;
#line 281
static int cciss_compat_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                              unsigned long arg ) ;
#line 285 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct block_device_operations  const  cciss_fops  = 
#line 285
     {& cciss_unlocked_open, & cciss_release, & do_ioctl, & cciss_compat_ioctl, 0, 0,
    0, 0, & cciss_revalidate, & cciss_getgeo, 0, & __this_module};
#line 301 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void set_performant_mode(ctlr_info_t *h , CommandList_struct *c ) 
{ 
  long tmp ;

  {
#line 303
  tmp = ldv__builtin_expect((h->transMethod & 4UL) != 0UL, 1L);
#line 303
  if (tmp != 0L) {
#line 304
    c->busaddr = (c->busaddr | (*(h->blockFetchTable + (unsigned long )c->Header.SGList) << 1)) | 1U;
  } else {

  }
#line 305
  return;
}
}
#line 310 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void addQ(struct list_head *list , CommandList_struct *c ) 
{ 


  {
#line 312
  list_add_tail(& c->list, list);
#line 313
  return;
}
}
#line 315 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void removeQ(CommandList_struct *c ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 325
  tmp = list_empty((struct list_head  const  *)(& c->list));
#line 325
  __ret_warn_on = tmp != 0;
#line 325
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 325
  if (tmp___0 != 0L) {
#line 325
    warn_slowpath_null("/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared",
                       325);
  } else {

  }
#line 325
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 325
  if (tmp___1 != 0L) {
#line 326
    c->cmd_type = 255;
#line 327
    return;
  } else {

  }
#line 330
  list_del_init(& c->list);
#line 331
  return;
}
}
#line 333 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void enqueue_cmd_and_start_io(ctlr_info_t *h , CommandList_struct *c ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 337
  set_performant_mode(h, c);
#line 338
  tmp = spinlock_check(& h->lock);
#line 338
  flags = _raw_spin_lock_irqsave(tmp);
#line 339
  addQ(& h->reqQ, c);
#line 340
  h->Qdepth = h->Qdepth + 1U;
#line 341
  if (h->Qdepth > h->maxQsinceinit) {
#line 342
    h->maxQsinceinit = h->Qdepth;
  } else {

  }
#line 343
  start_io(h);
#line 344
  spin_unlock_irqrestore(& h->lock, flags);
#line 345
  return;
}
}
#line 347 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_sg_chain_blocks(SGDescriptor_struct **cmd_sg_list , int nr_cmds ) 
{ 
  int i ;

  {
#line 352
  if ((unsigned long )cmd_sg_list == (unsigned long )((SGDescriptor_struct **)0)) {
#line 353
    return;
  } else {

  }
#line 354
  i = 0;
#line 354
  goto ldv_34936;
  ldv_34935: 
#line 355
  kfree((void const   *)*(cmd_sg_list + (unsigned long )i));
#line 356
  *(cmd_sg_list + (unsigned long )i) = 0;
#line 354
  i = i + 1;
  ldv_34936: ;
#line 354
  if (i < nr_cmds) {
#line 355
    goto ldv_34935;
  } else {

  }
#line 358
  kfree((void const   *)cmd_sg_list);
#line 359
  return;
}
}
#line 361 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static SGDescriptor_struct **cciss_allocate_sg_chain_blocks(ctlr_info_t *h , int chainsize ,
                                                            int nr_cmds ) 
{ 
  int j ;
  SGDescriptor_struct **cmd_sg_list ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 367
  if (chainsize <= 0) {
#line 368
    return (0);
  } else {

  }
#line 370
  tmp = kmalloc((unsigned long )nr_cmds * 8UL, 208U);
#line 370
  cmd_sg_list = (SGDescriptor_struct **)tmp;
#line 371
  if ((unsigned long )cmd_sg_list == (unsigned long )((SGDescriptor_struct **)0)) {
#line 372
    return (0);
  } else {

  }
#line 375
  j = 0;
#line 375
  goto ldv_34947;
  ldv_34946: 
#line 377
  tmp___0 = kmalloc((unsigned long )chainsize * 16UL, 208U);
#line 377
  *(cmd_sg_list + (unsigned long )j) = (SGDescriptor_struct *)tmp___0;
#line 379
  if ((unsigned long )*(cmd_sg_list + (unsigned long )j) == (unsigned long )((SGDescriptor_struct *)0)) {
#line 380
    dev_err((struct device  const  *)(& (h->pdev)->dev), "Cannot get memory for s/g chains.\n");
#line 382
    goto clean;
  } else {

  }
#line 375
  j = j + 1;
  ldv_34947: ;
#line 375
  if (j < nr_cmds) {
#line 376
    goto ldv_34946;
  } else {

  }

#line 385
  return (cmd_sg_list);
  clean: 
#line 387
  cciss_free_sg_chain_blocks(cmd_sg_list, nr_cmds);
#line 388
  return (0);
}
}
#line 391 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_unmap_sg_chain_block(ctlr_info_t *h , CommandList_struct *c ) 
{ 
  SGDescriptor_struct *chain_sg ;
  u64bit temp64 ;

  {
#line 396
  if ((int )c->Header.SGTotal <= h->max_cmd_sgentries) {
#line 397
    return;
  } else {

  }
#line 399
  chain_sg = (SGDescriptor_struct *)(& c->SG) + ((unsigned long )h->max_cmd_sgentries + 0xffffffffffffffffUL);
#line 400
  temp64.val32.lower = chain_sg->Addr.lower;
#line 401
  temp64.val32.upper = chain_sg->Addr.upper;
#line 402
  pci_unmap_single(h->pdev, temp64.val, (size_t )chain_sg->Len, 1);
#line 403
  return;
}
}
#line 405 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_map_sg_chain_block(ctlr_info_t *h , CommandList_struct *c , SGDescriptor_struct *chain_block ,
                                     int len ) 
{ 
  SGDescriptor_struct *chain_sg ;
  u64bit temp64 ;

  {
#line 411
  chain_sg = (SGDescriptor_struct *)(& c->SG) + ((unsigned long )h->max_cmd_sgentries + 0xffffffffffffffffUL);
#line 412
  chain_sg->Ext = 2147483648U;
#line 413
  chain_sg->Len = (__u32 )len;
#line 414
  temp64.val = pci_map_single(h->pdev, (void *)chain_block, (size_t )len, 1);
#line 416
  chain_sg->Addr.lower = temp64.val32.lower;
#line 417
  chain_sg->Addr.upper = temp64.val32.upper;
#line 418
  return;
}
}
#line 155 "include/scsi/scsi_cmnd.h"
extern int scsi_dma_map(struct scsi_cmnd * ) ;
#line 156
extern void scsi_dma_unmap(struct scsi_cmnd * ) ;
#line 161 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_sg_count(struct scsi_cmnd *cmd ) 
{ 


  {
#line 163
  return (cmd->sdb.table.nents);
}
}
#line 166 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
#line 168
  return (cmd->sdb.table.sgl);
}
}
#line 176 "include/scsi/scsi_cmnd.h"
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 


  {
#line 178
  cmd->sdb.resid = resid;
#line 179
  return;
}
}
#line 294 "include/scsi/scsi_device.h"
extern int scsi_add_device(struct Scsi_Host * , uint  , uint  , uint  ) ;
#line 297
extern void scsi_remove_device(struct scsi_device * ) ;
#line 301
extern void scsi_device_put(struct scsi_device * ) ;
#line 302
extern struct scsi_device *scsi_device_lookup(struct Scsi_Host * , uint  , uint  ,
                                              uint  ) ;
#line 778 "include/scsi/scsi_host.h"
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
#line 779
extern int scsi_add_host_with_dma(struct Scsi_Host * , struct device * , struct device * ) ;
#line 782
extern void scsi_scan_host(struct Scsi_Host * ) ;
#line 784
extern void scsi_remove_host(struct Scsi_Host * ) ;
#line 786
extern void scsi_host_put(struct Scsi_Host * ) ;
#line 789
extern void scsi_cmd_get_serial(struct Scsi_Host * , struct scsi_cmnd * ) ;
#line 793 "include/scsi/scsi_host.h"
__inline static int scsi_add_host(struct Scsi_Host *host , struct device *dev ) 
{ 
  int tmp ;

  {
#line 796
  tmp = scsi_add_host_with_dma(host, dev, dev);
#line 796
  return (tmp);
}
}
#line 47 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int fill_cmd(ctlr_info_t *h , CommandList_struct *c , __u8 cmd , void *buff ,
                    size_t size , __u8 page_code , unsigned char *scsi3addr , int cmd_type ) ;
#line 52
static CommandList_struct *cmd_alloc(ctlr_info_t *h ) ;
#line 53
static CommandList_struct *cmd_special_alloc(ctlr_info_t *h ) ;
#line 54
static void cmd_free(ctlr_info_t *h , CommandList_struct *c ) ;
#line 55
static void cmd_special_free(ctlr_info_t *h , CommandList_struct *c ) ;
#line 57
static int cciss_scsi_proc_info(struct Scsi_Host *sh , char *buffer , char **start ,
                                off_t offset , int length , int func ) ;
#line 65
static int cciss_scsi_queue_command(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) ;
#line 67
static int cciss_eh_device_reset_handler(struct scsi_cmnd *scsicmd ) ;
#line 68
static int cciss_eh_abort_handler(struct scsi_cmnd *scsicmd ) ;
#line 70 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static struct cciss_scsi_hba_t ccissscsi[32U]  = 
#line 70
  {      {(char *)"cciss0", 0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}},
                            {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                          (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0, (unsigned char)0}, {(unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0},
                             {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                              (unsigned char)0}}, {0, 0, 0, 0, {(unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0},
                                                   {(unsigned char)0, (unsigned char)0,
                                                    (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss1",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss2",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss3",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss4",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss5",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss6",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}, 
        {(char *)"cciss7",
      0, {{0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
          {0, 0, 0, 0, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
           {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}}}}};
#line 81 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static struct scsi_host_template cciss_driver_template  = 
#line 81
     {& __this_module, "cciss", 0, 0, 0, 0, 0, & cciss_scsi_queue_command, 0, & cciss_eh_abort_handler,
    & cciss_eh_device_reset_handler, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cciss_scsi_proc_info,
    0, 0, "cciss", 0, 0, 7, (unsigned short)0, (unsigned short)0, (unsigned short)0,
    0UL, 1, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, 0U, 0, 0, {0, 0}, 0ULL};
#line 134 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static CommandList_struct *scsi_cmd_alloc(ctlr_info_t *h ) 
{ 
  struct cciss_scsi_cmd_stack_elem_t *c ;
  struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;
  u64bit temp64 ;

  {
#line 147
  sa = h->scsi_ctlr;
#line 148
  stk = & sa->cmd_stack;
#line 150
  if (stk->top < 0) {
#line 151
    return (0);
  } else {

  }
#line 152
  c = *(stk->elem + (unsigned long )stk->top);
#line 154
  memset((void *)(& c->cmd), 0, 640UL);
#line 155
  memset((void *)(& c->Err), 0, 48UL);
#line 157
  c->cmd.busaddr = c->busaddr;
#line 158
  c->cmd.cmdindex = (long )c->cmdindex;
#line 162
  temp64.val = (unsigned long long )((unsigned long )c->busaddr + 640UL);
#line 166
  stk->top = stk->top - 1;
#line 167
  c->cmd.ErrDesc.Addr.lower = temp64.val32.lower;
#line 168
  c->cmd.ErrDesc.Addr.upper = temp64.val32.upper;
#line 169
  c->cmd.ErrDesc.Len = 48U;
#line 171
  c->cmd.ctlr = h->ctlr;
#line 172
  c->cmd.err_info = & c->Err;
#line 174
  return ((CommandList_struct *)c);
}
}
#line 178 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void scsi_cmd_free(ctlr_info_t *h , CommandList_struct *c ) 
{ 
  struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;

  {
#line 187
  sa = h->scsi_ctlr;
#line 188
  stk = & sa->cmd_stack;
#line 189
  stk->top = stk->top + 1;
#line 190
  if (stk->top >= stk->nelems) {
#line 191
    dev_err((struct device  const  *)(& (h->pdev)->dev), "scsi_cmd_free called too many times.\n");
#line 193
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                         "i" (193), "i" (12UL));
    ldv_35907: ;
#line 193
    goto ldv_35907;
  } else {

  }
#line 195
  *(stk->elem + (unsigned long )stk->top) = (struct cciss_scsi_cmd_stack_elem_t *)c;
#line 196
  return;
}
}
#line 199 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int scsi_cmd_stack_setup(ctlr_info_t *h , struct cciss_scsi_adapter_data_t *sa ) 
{ 
  int i ;
  struct cciss_scsi_cmd_stack_t *stk ;
  size_t size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 205
  stk = & sa->cmd_stack;
#line 206
  stk->nelems = cciss_tape_cmds + 2;
#line 207
  sa->cmd_sg_list = cciss_allocate_sg_chain_blocks(h, h->chainsize, stk->nelems);
#line 209
  if ((unsigned long )sa->cmd_sg_list == (unsigned long )((SGDescriptor_struct **)0) && h->chainsize > 0) {
#line 210
    return (-12);
  } else {

  }
#line 212
  size = (unsigned long )stk->nelems * 704UL;
#line 217
  tmp = pci_alloc_consistent(h->pdev, size, & stk->cmd_pool_handle);
#line 217
  stk->pool = (struct cciss_scsi_cmd_stack_elem_t *)tmp;
#line 220
  if ((unsigned long )stk->pool == (unsigned long )((struct cciss_scsi_cmd_stack_elem_t *)0)) {
#line 221
    cciss_free_sg_chain_blocks(sa->cmd_sg_list, stk->nelems);
#line 222
    sa->cmd_sg_list = 0;
#line 223
    return (-12);
  } else {

  }
#line 225
  tmp___0 = kmalloc((unsigned long )stk->nelems * 8UL, 208U);
#line 225
  stk->elem = (struct cciss_scsi_cmd_stack_elem_t **)tmp___0;
#line 226
  if ((unsigned long )stk->elem == (unsigned long )((struct cciss_scsi_cmd_stack_elem_t **)0)) {
#line 227
    pci_free_consistent(h->pdev, size, (void *)stk->pool, stk->cmd_pool_handle);
#line 229
    return (-1);
  } else {

  }
#line 231
  i = 0;
#line 231
  goto ldv_35916;
  ldv_35915: 
#line 232
  *(stk->elem + (unsigned long )i) = stk->pool + (unsigned long )i;
#line 233
  (*(stk->elem + (unsigned long )i))->busaddr = (unsigned int )stk->cmd_pool_handle + (unsigned int )((unsigned long )i) * 704U;
#line 235
  (*(stk->elem + (unsigned long )i))->cmdindex = i;
#line 231
  i = i + 1;
  ldv_35916: ;
#line 231
  if (stk->nelems > i) {
#line 232
    goto ldv_35915;
  } else {

  }
#line 237
  stk->top = stk->nelems + -1;
#line 238
  return (0);
}
}
#line 242 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void scsi_cmd_stack_free(ctlr_info_t *h ) 
{ 
  struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;
  size_t size ;

  {
#line 248
  sa = h->scsi_ctlr;
#line 249
  stk = & sa->cmd_stack;
#line 250
  if (stk->top != stk->nelems + -1) {
#line 251
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "bug: %d scsi commands are still outstanding.\n",
             stk->nelems - stk->top);
  } else {

  }
#line 255
  size = (unsigned long )stk->nelems * 704UL;
#line 257
  pci_free_consistent(h->pdev, size, (void *)stk->pool, stk->cmd_pool_handle);
#line 258
  stk->pool = 0;
#line 259
  cciss_free_sg_chain_blocks(sa->cmd_sg_list, stk->nelems);
#line 260
  kfree((void const   *)stk->elem);
#line 261
  stk->elem = 0;
#line 262
  return;
}
}
#line 351 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int find_bus_target_lun(ctlr_info_t *h , int *bus , int *target , int *lun ) 
{ 
  int i ;
  int found ;
  unsigned char target_taken[16U] ;

  {
#line 355
  found = 0;
#line 358
  memset((void *)(& target_taken), 0, 16UL);
#line 360
  target_taken[15] = 1U;
#line 361
  i = 0;
#line 361
  goto ldv_35934;
  ldv_35933: 
#line 362
  target_taken[ccissscsi[h->ctlr].dev[i].target] = 1U;
#line 361
  i = i + 1;
  ldv_35934: ;
#line 361
  if (ccissscsi[h->ctlr].ndevices > i) {
#line 362
    goto ldv_35933;
  } else {

  }
#line 364
  i = 0;
#line 364
  goto ldv_35938;
  ldv_35937: ;
#line 365
  if ((unsigned int )target_taken[i] == 0U) {
#line 366
    *bus = 0;
#line 366
    *target = i;
#line 366
    *lun = 0;
#line 366
    found = 1;
#line 367
    goto ldv_35936;
  } else {

  }
#line 364
  i = i + 1;
  ldv_35938: ;
#line 364
  if (i <= 15) {
#line 365
    goto ldv_35937;
  } else {

  }
  ldv_35936: ;
#line 370
  return (found == 0);
}
}
#line 378 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_add_entry(ctlr_info_t *h , int hostno , struct cciss_scsi_dev_t *device ,
                                struct scsi2map *added , int *nadded ) 
{ 
  int n ;
  struct cciss_scsi_dev_t *sd ;
  int i ;
  int bus ;
  int target ;
  int lun ;
  unsigned char addr1[8U] ;
  unsigned char addr2[8U] ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp ;
  int tmp___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  char const   *tmp___1 ;

  {
#line 383
  n = ccissscsi[h->ctlr].ndevices;
#line 388
  if (n > 15) {
#line 389
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Too many devices, some will be inaccessible.\n");
#line 391
    return (-1);
  } else {

  }
#line 394
  target = -1;
#line 394
  bus = target;
#line 395
  lun = 0;
#line 398
  if ((unsigned int )device->scsi3addr[4] != 0U) {
#line 403
    __len = 8UL;
#line 403
    if (__len > 63UL) {
#line 403
      __ret = __memcpy((void *)(& addr1), (void const   *)(& device->scsi3addr), __len);
    } else {
#line 403
      __ret = __builtin_memcpy((void *)(& addr1), (void const   *)(& device->scsi3addr),
                               __len);
    }
#line 404
    addr1[4] = 0U;
#line 405
    i = 0;
#line 405
    goto ldv_35967;
    ldv_35966: 
#line 406
    sd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )i;
#line 407
    __len___0 = 8UL;
#line 407
    if (__len___0 > 63UL) {
#line 407
      __ret___0 = __memcpy((void *)(& addr2), (void const   *)(& sd->scsi3addr), __len___0);
    } else {
#line 407
      __ret___0 = __builtin_memcpy((void *)(& addr2), (void const   *)(& sd->scsi3addr),
                                   __len___0);
    }
#line 408
    addr2[4] = 0U;
#line 410
    tmp = memcmp((void const   *)(& addr1), (void const   *)(& addr2), 8UL);
#line 410
    if (tmp == 0) {
#line 411
      bus = sd->bus;
#line 412
      target = sd->target;
#line 413
      lun = (int )device->scsi3addr[4];
#line 414
      goto ldv_35965;
    } else {

    }
#line 405
    i = i + 1;
    ldv_35967: ;
#line 405
    if (i < n) {
#line 406
      goto ldv_35966;
    } else {

    }
    ldv_35965: ;
  } else {

  }
#line 419
  sd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )n;
#line 420
  if (lun == 0) {
#line 421
    tmp___0 = find_bus_target_lun(h, & sd->bus, & sd->target, & sd->lun);
#line 421
    if (tmp___0 != 0) {
#line 423
      return (-1);
    } else {
#line 425
      sd->bus = bus;
#line 426
      sd->target = target;
#line 427
      sd->lun = lun;
    }
  } else {

  }
#line 429
  (added + (unsigned long )*nadded)->bus = sd->bus;
#line 430
  (added + (unsigned long )*nadded)->target = sd->target;
#line 431
  (added + (unsigned long )*nadded)->lun = sd->lun;
#line 432
  *nadded = *nadded + 1;
#line 434
  __len___1 = 8UL;
#line 434
  if (__len___1 > 63UL) {
#line 434
    __ret___1 = __memcpy((void *)(& sd->scsi3addr), (void const   *)(& device->scsi3addr),
                         __len___1);
  } else {
#line 434
    __ret___1 = __builtin_memcpy((void *)(& sd->scsi3addr), (void const   *)(& device->scsi3addr),
                                 __len___1);
  }
#line 435
  __len___2 = 8UL;
#line 435
  if (__len___2 > 63UL) {
#line 435
    __ret___2 = __memcpy((void *)(& sd->vendor), (void const   *)(& device->vendor),
                         __len___2);
  } else {
#line 435
    __ret___2 = __builtin_memcpy((void *)(& sd->vendor), (void const   *)(& device->vendor),
                                 __len___2);
  }
#line 436
  __len___3 = 4UL;
#line 436
  if (__len___3 > 63UL) {
#line 436
    __ret___3 = __memcpy((void *)(& sd->revision), (void const   *)(& device->revision),
                         __len___3);
  } else {
#line 436
    __ret___3 = __builtin_memcpy((void *)(& sd->revision), (void const   *)(& device->revision),
                                 __len___3);
  }
#line 437
  __len___4 = 16UL;
#line 437
  if (__len___4 > 63UL) {
#line 437
    __ret___4 = __memcpy((void *)(& sd->device_id), (void const   *)(& device->device_id),
                         __len___4);
  } else {
#line 437
    __ret___4 = __builtin_memcpy((void *)(& sd->device_id), (void const   *)(& device->device_id),
                                 __len___4);
  }
#line 438
  sd->devtype = device->devtype;
#line 440
  ccissscsi[h->ctlr].ndevices = ccissscsi[h->ctlr].ndevices + 1;
#line 445
  if (hostno != -1) {
#line 446
    tmp___1 = scsi_device_type((unsigned int )sd->devtype);
#line 446
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "%s device c%db%dt%dl%d added.\n",
              tmp___1, hostno, sd->bus, sd->target, sd->lun);
  } else {

  }
#line 449
  return (0);
}
}
#line 453 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_scsi_remove_entry(ctlr_info_t *h , int hostno , int entry , struct scsi2map *removed ,
                                    int *nremoved ) 
{ 
  int i ;
  struct cciss_scsi_dev_t sd ;
  char const   *tmp ;

  {
#line 460
  if (entry < 0 || entry > 15) {
#line 460
    return;
  } else {

  }
#line 461
  sd = ccissscsi[h->ctlr].dev[entry];
#line 462
  (removed + (unsigned long )*nremoved)->bus = sd.bus;
#line 463
  (removed + (unsigned long )*nremoved)->target = sd.target;
#line 464
  (removed + (unsigned long )*nremoved)->lun = sd.lun;
#line 465
  *nremoved = *nremoved + 1;
#line 466
  i = entry;
#line 466
  goto ldv_35990;
  ldv_35989: 
#line 467
  ccissscsi[h->ctlr].dev[i] = ccissscsi[h->ctlr].dev[i + 1];
#line 466
  i = i + 1;
  ldv_35990: ;
#line 466
  if (ccissscsi[h->ctlr].ndevices + -1 > i) {
#line 467
    goto ldv_35989;
  } else {

  }
#line 468
  ccissscsi[h->ctlr].ndevices = ccissscsi[h->ctlr].ndevices - 1;
#line 469
  tmp = scsi_device_type((unsigned int )sd.devtype);
#line 469
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "%s device c%db%dt%dl%d removed.\n",
            tmp, hostno, sd.bus, sd.target, sd.lun);
#line 470
  return;
}
}
#line 485 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void fixup_botched_add(ctlr_info_t *h , char *scsi3addr ) 
{ 
  unsigned long flags ;
  int i ;
  int j ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 491
  tmp = spinlock_check(& (h->scsi_ctlr)->lock);
#line 491
  flags = _raw_spin_lock_irqsave(tmp);
#line 492
  i = 0;
#line 492
  goto ldv_36007;
  ldv_36006: 
#line 493
  tmp___0 = memcmp((void const   *)scsi3addr, (void const   *)(& ccissscsi[h->ctlr].dev[i].scsi3addr),
                   8UL);
#line 493
  if (tmp___0 == 0) {
#line 495
    j = i;
#line 495
    goto ldv_36003;
    ldv_36002: 
#line 496
    ccissscsi[h->ctlr].dev[j] = ccissscsi[h->ctlr].dev[j + 1];
#line 495
    j = j + 1;
    ldv_36003: ;
#line 495
    if (ccissscsi[h->ctlr].ndevices + -1 > j) {
#line 496
      goto ldv_36002;
    } else {

    }
#line 498
    ccissscsi[h->ctlr].ndevices = ccissscsi[h->ctlr].ndevices - 1;
#line 499
    goto ldv_36005;
  } else {

  }
#line 492
  i = i + 1;
  ldv_36007: ;
#line 492
  if (ccissscsi[h->ctlr].ndevices > i) {
#line 493
    goto ldv_36006;
  } else {

  }
  ldv_36005: 
#line 502
  spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 503
  return;
}
}
#line 505 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int device_is_the_same(struct cciss_scsi_dev_t *dev1 , struct cciss_scsi_dev_t *dev2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 508
  if (dev1->devtype == dev2->devtype) {
#line 508
    tmp = memcmp((void const   *)(& dev1->scsi3addr), (void const   *)(& dev2->scsi3addr),
                 8UL);
#line 508
    if (tmp == 0) {
#line 508
      tmp___0 = memcmp((void const   *)(& dev1->device_id), (void const   *)(& dev2->device_id),
                       16UL);
#line 508
      if (tmp___0 == 0) {
#line 508
        tmp___1 = memcmp((void const   *)(& dev1->vendor), (void const   *)(& dev2->vendor),
                         8UL);
#line 508
        if (tmp___1 == 0) {
#line 508
          tmp___2 = memcmp((void const   *)(& dev1->model), (void const   *)(& dev2->model),
                           16UL);
#line 508
          if (tmp___2 == 0) {
#line 508
            tmp___3 = memcmp((void const   *)(& dev1->revision), (void const   *)(& dev2->revision),
                             4UL);
#line 508
            if (tmp___3 == 0) {
#line 508
              tmp___4 = 1;
            } else {
#line 508
              tmp___4 = 0;
            }
          } else {
#line 508
            tmp___4 = 0;
          }
        } else {
#line 508
          tmp___4 = 0;
        }
      } else {
#line 508
        tmp___4 = 0;
      }
    } else {
#line 508
      tmp___4 = 0;
    }
  } else {
#line 508
    tmp___4 = 0;
  }
#line 508
  return (tmp___4);
}
}
#line 522 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int adjust_cciss_scsi_table(ctlr_info_t *h , int hostno , struct cciss_scsi_dev_t *sd ,
                                   int nsds ) 
{ 
  int i ;
  int j ;
  int found ;
  int changes ;
  struct cciss_scsi_dev_t *csd ;
  unsigned long flags ;
  struct scsi2map *added ;
  struct scsi2map *removed ;
  int nadded ;
  int nremoved ;
  struct Scsi_Host *sh ;
  void *tmp ;
  void *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  int tmp___4 ;
  int tmp___5 ;
  struct scsi_device *sdev ;
  struct scsi_device *tmp___6 ;
  int rc ;

  {
#line 530
  changes = 0;
#line 535
  sh = 0;
#line 537
  tmp = kzalloc(320UL, 208U);
#line 537
  added = (struct scsi2map *)tmp;
#line 539
  tmp___0 = kzalloc(320UL, 208U);
#line 539
  removed = (struct scsi2map *)tmp___0;
#line 542
  if ((unsigned long )added == (unsigned long )((struct scsi2map *)0) || (unsigned long )removed == (unsigned long )((struct scsi2map *)0)) {
#line 543
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Out of memory in adjust_cciss_scsi_table\n");
#line 545
    goto free_and_out;
  } else {

  }
#line 548
  tmp___1 = spinlock_check(& (h->scsi_ctlr)->lock);
#line 548
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 550
  if (hostno != -1) {
#line 551
    sh = (h->scsi_ctlr)->scsi_host;
  } else {

  }
#line 556
  i = 0;
#line 557
  nremoved = 0;
#line 558
  nadded = 0;
#line 559
  goto ldv_36050;
  ldv_36049: 
#line 560
  csd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )i;
#line 561
  found = 0;
#line 562
  j = 0;
#line 562
  goto ldv_36035;
  ldv_36034: ;
#line 563
  if ((((((((int )(sd + (unsigned long )j)->scsi3addr[7] == (int )csd->scsi3addr[7] && (int )(sd + (unsigned long )j)->scsi3addr[6] == (int )csd->scsi3addr[6]) && (int )(sd + (unsigned long )j)->scsi3addr[5] == (int )csd->scsi3addr[5]) && (int )(sd + (unsigned long )j)->scsi3addr[4] == (int )csd->scsi3addr[4]) && (int )(sd + (unsigned long )j)->scsi3addr[3] == (int )csd->scsi3addr[3]) && (int )(sd + (unsigned long )j)->scsi3addr[2] == (int )csd->scsi3addr[2]) && (int )(sd + (unsigned long )j)->scsi3addr[1] == (int )csd->scsi3addr[1]) && (int )(sd + (unsigned long )j)->scsi3addr[0] == (int )csd->scsi3addr[0]) {
#line 565
    tmp___2 = device_is_the_same(sd + (unsigned long )j, csd);
#line 565
    if (tmp___2 != 0) {
#line 566
      found = 2;
    } else {
#line 568
      found = 1;
    }
#line 569
    goto ldv_36033;
  } else {

  }
#line 562
  j = j + 1;
  ldv_36035: ;
#line 562
  if (j < nsds) {
#line 563
    goto ldv_36034;
  } else {

  }
  ldv_36033: ;
#line 573
  if (found == 0) {
#line 574
    changes = changes + 1;
#line 575
    cciss_scsi_remove_entry(h, hostno, i, removed, & nremoved);
  } else
#line 578
  if (found == 1) {
#line 579
    changes = changes + 1;
#line 580
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "device c%db%dt%dl%d has changed.\n",
              hostno, csd->bus, csd->target, csd->lun);
#line 583
    cciss_scsi_remove_entry(h, hostno, i, removed, & nremoved);
#line 586
    tmp___3 = cciss_scsi_add_entry(h, hostno, sd + (unsigned long )j, added, & nadded);
#line 586
    if (tmp___3 != 0) {
#line 589
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                           "i" (589), "i" (12UL));
      ldv_36036: ;
#line 589
      goto ldv_36036;
    } else {

    }
#line 590
    csd->devtype = (sd + (unsigned long )j)->devtype;
#line 591
    __len = 16UL;
#line 591
    if (__len > 63UL) {
#line 591
      __ret = __memcpy((void *)(& csd->device_id), (void const   *)(& (sd + (unsigned long )j)->device_id),
                       __len);
    } else {
#line 591
      __ret = __builtin_memcpy((void *)(& csd->device_id), (void const   *)(& (sd + (unsigned long )j)->device_id),
                               __len);
    }
#line 593
    __len___0 = 8UL;
#line 593
    if (__len___0 > 63UL) {
#line 593
      __ret___0 = __memcpy((void *)(& csd->vendor), (void const   *)(& (sd + (unsigned long )j)->vendor),
                           __len___0);
    } else {
#line 593
      __ret___0 = __builtin_memcpy((void *)(& csd->vendor), (void const   *)(& (sd + (unsigned long )j)->vendor),
                                   __len___0);
    }
#line 595
    __len___1 = 16UL;
#line 595
    if (__len___1 > 63UL) {
#line 595
      __ret___1 = __memcpy((void *)(& csd->model), (void const   *)(& (sd + (unsigned long )j)->model),
                           __len___1);
    } else {
#line 595
      __ret___1 = __builtin_memcpy((void *)(& csd->model), (void const   *)(& (sd + (unsigned long )j)->model),
                                   __len___1);
    }
#line 597
    __len___2 = 4UL;
#line 597
    if (__len___2 > 63UL) {
#line 597
      __ret___2 = __memcpy((void *)(& csd->revision), (void const   *)(& (sd + (unsigned long )j)->revision),
                           __len___2);
    } else {
#line 597
      __ret___2 = __builtin_memcpy((void *)(& csd->revision), (void const   *)(& (sd + (unsigned long )j)->revision),
                                   __len___2);
    }
  } else {
#line 600
    i = i + 1;
  }
  ldv_36050: ;
#line 559
  if (ccissscsi[h->ctlr].ndevices > i) {
#line 560
    goto ldv_36049;
  } else {

  }
#line 606
  i = 0;
#line 606
  goto ldv_36057;
  ldv_36056: 
#line 607
  found = 0;
#line 608
  j = 0;
#line 608
  goto ldv_36054;
  ldv_36053: 
#line 609
  csd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )j;
#line 610
  if ((((((((int )(sd + (unsigned long )i)->scsi3addr[7] == (int )csd->scsi3addr[7] && (int )(sd + (unsigned long )i)->scsi3addr[6] == (int )csd->scsi3addr[6]) && (int )(sd + (unsigned long )i)->scsi3addr[5] == (int )csd->scsi3addr[5]) && (int )(sd + (unsigned long )i)->scsi3addr[4] == (int )csd->scsi3addr[4]) && (int )(sd + (unsigned long )i)->scsi3addr[3] == (int )csd->scsi3addr[3]) && (int )(sd + (unsigned long )i)->scsi3addr[2] == (int )csd->scsi3addr[2]) && (int )(sd + (unsigned long )i)->scsi3addr[1] == (int )csd->scsi3addr[1]) && (int )(sd + (unsigned long )i)->scsi3addr[0] == (int )csd->scsi3addr[0]) {
#line 612
    tmp___4 = device_is_the_same(sd + (unsigned long )i, csd);
#line 612
    if (tmp___4 != 0) {
#line 613
      found = 2;
    } else {
#line 615
      found = 1;
    }
#line 616
    goto ldv_36052;
  } else {

  }
#line 608
  j = j + 1;
  ldv_36054: ;
#line 608
  if (ccissscsi[h->ctlr].ndevices > j) {
#line 609
    goto ldv_36053;
  } else {

  }
  ldv_36052: ;
#line 619
  if (found == 0) {
#line 620
    changes = changes + 1;
#line 621
    tmp___5 = cciss_scsi_add_entry(h, hostno, sd + (unsigned long )i, added, & nadded);
#line 621
    if (tmp___5 != 0) {
#line 623
      goto ldv_36055;
    } else {

    }
  } else
#line 624
  if (found == 1) {
#line 626
    changes = changes + 1;
#line 627
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "device unexpectedly changed\n");
  } else {

  }
#line 606
  i = i + 1;
  ldv_36057: ;
#line 606
  if (i < nsds) {
#line 607
    goto ldv_36056;
  } else {

  }
  ldv_36055: 
#line 632
  spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 637
  if (hostno == -1 || changes == 0) {
#line 638
    goto free_and_out;
  } else {

  }
#line 641
  i = 0;
#line 641
  goto ldv_36060;
  ldv_36059: 
#line 642
  tmp___6 = scsi_device_lookup(sh, (uint )(removed + (unsigned long )i)->bus, (uint )(removed + (unsigned long )i)->target,
                               (uint )(removed + (unsigned long )i)->lun);
#line 642
  sdev = tmp___6;
#line 645
  if ((unsigned long )sdev != (unsigned long )((struct scsi_device *)0)) {
#line 646
    scsi_remove_device(sdev);
#line 647
    scsi_device_put(sdev);
  } else {
#line 652
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "didn\'t find c%db%dt%dl%d\n for removal.",
             hostno, (removed + (unsigned long )i)->bus, (removed + (unsigned long )i)->target,
             (removed + (unsigned long )i)->lun);
  }
#line 641
  i = i + 1;
  ldv_36060: ;
#line 641
  if (i < nremoved) {
#line 642
    goto ldv_36059;
  } else {

  }
#line 660
  i = 0;
#line 660
  goto ldv_36065;
  ldv_36064: 
#line 662
  rc = scsi_add_device(sh, (uint )(added + (unsigned long )i)->bus, (uint )(added + (unsigned long )i)->target,
                       (uint )(added + (unsigned long )i)->lun);
#line 664
  if (rc == 0) {
#line 665
    goto ldv_36063;
  } else {

  }
#line 666
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "scsi_add_device c%db%dt%dl%d failed, device not added.\n",
           hostno, (added + (unsigned long )i)->bus, (added + (unsigned long )i)->target,
           (added + (unsigned long )i)->lun);
#line 671
  fixup_botched_add(h, (char *)(& (added + (unsigned long )i)->scsi3addr));
  ldv_36063: 
#line 660
  i = i + 1;
  ldv_36065: ;
#line 660
  if (i < nadded) {
#line 661
    goto ldv_36064;
  } else {

  }

  free_and_out: 
#line 675
  kfree((void const   *)added);
#line 676
  kfree((void const   *)removed);
#line 677
  return (0);
}
}
#line 681 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int lookup_scsi3addr(ctlr_info_t *h , int bus , int target , int lun , char *scsi3addr ) 
{ 
  int i ;
  struct cciss_scsi_dev_t *sd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 687
  tmp = spinlock_check(& (h->scsi_ctlr)->lock);
#line 687
  flags = _raw_spin_lock_irqsave(tmp);
#line 688
  i = 0;
#line 688
  goto ldv_36084;
  ldv_36083: 
#line 689
  sd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )i;
#line 690
  if ((sd->bus == bus && sd->target == target) && sd->lun == lun) {
#line 693
    __len = 8UL;
#line 693
    if (__len > 63UL) {
#line 693
      __ret = __memcpy((void *)scsi3addr, (void const   *)(& sd->scsi3addr), __len);
    } else {
#line 693
      __ret = __builtin_memcpy((void *)scsi3addr, (void const   *)(& sd->scsi3addr),
                               __len);
    }
#line 694
    spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 695
    return (0);
  } else {

  }
#line 688
  i = i + 1;
  ldv_36084: ;
#line 688
  if (ccissscsi[h->ctlr].ndevices > i) {
#line 689
    goto ldv_36083;
  } else {

  }
#line 698
  spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 699
  return (-1);
}
}
#line 703 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_scsi_setup(ctlr_info_t *h ) 
{ 
  struct cciss_scsi_adapter_data_t *shba ;
  void *tmp ;
  struct lock_class_key __key ;
  int tmp___0 ;

  {
#line 707
  ccissscsi[h->ctlr].ndevices = 0;
#line 708
  tmp = kmalloc(128UL, 208U);
#line 708
  shba = (struct cciss_scsi_adapter_data_t *)tmp;
#line 710
  if ((unsigned long )shba == (unsigned long )((struct cciss_scsi_adapter_data_t *)0)) {
#line 711
    return;
  } else {

  }
#line 712
  shba->scsi_host = 0;
#line 713
  spinlock_check(& shba->lock);
#line 713
  __raw_spin_lock_init(& shba->lock.ldv_5961.rlock, "&(&shba->lock)->rlock", & __key);
#line 714
  shba->registered = 0;
#line 715
  tmp___0 = scsi_cmd_stack_setup(h, shba);
#line 715
  if (tmp___0 != 0) {
#line 716
    kfree((void const   *)shba);
#line 717
    shba = 0;
  } else {

  }
#line 719
  h->scsi_ctlr = shba;
#line 720
  return;
}
}
#line 723 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void complete_scsi_command(CommandList_struct *c , int timeout , __u32 tag ) 
{ 
  struct scsi_cmnd *cmd ;
  ctlr_info_t *h ;
  ErrorInfo_struct *ei ;
  size_t __len ;
  void *__ret ;

  {
#line 730
  ei = c->err_info;
#line 733
  if ((unsigned int )*((unsigned char *)c + 21UL) == 1U) {
#line 734
    c->cmd_type = 4;
#line 735
    return;
  } else {

  }
#line 738
  cmd = (struct scsi_cmnd *)c->scsi_cmd;
#line 739
  h = hba[c->ctlr];
#line 741
  scsi_dma_unmap(cmd);
#line 742
  if ((int )c->Header.SGTotal > h->max_cmd_sgentries) {
#line 743
    cciss_unmap_sg_chain_block(h, c);
  } else {

  }
#line 745
  cmd->result = 0;
#line 746
  cmd->result = cmd->result;
#line 749
  cmd->result = cmd->result | (int )ei->ScsiStatus;
#line 754
  __len = (unsigned int )ei->SenseLen <= 96U ? (size_t )ei->SenseLen : 96UL;
#line 754
  __ret = __builtin_memcpy((void *)cmd->sense_buffer, (void const   *)(& ei->SenseInfo),
                           __len);
#line 758
  scsi_set_resid(cmd, (int )ei->ResidualCnt);
#line 760
  if ((unsigned int )ei->CommandStatus != 0U) {
#line 762
    switch ((int )ei->CommandStatus) {
    case 1: ;
#line 766
    if ((unsigned int )ei->ScsiStatus == 0U) {
#line 776
      cmd->result = 65536;
    } else {

    }
#line 778
    goto ldv_36103;
    case 2: ;
#line 780
    goto ldv_36103;
    case 3: 
#line 782
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p has completed with data overrun reported\n",
             c);
#line 785
    goto ldv_36103;
    case 4: 
#line 794
    cmd->result = 65536;
#line 796
    goto ldv_36103;
    case 5: 
#line 798
    cmd->result = 458752;
#line 799
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p has protocol error\n",
             c);
#line 801
    goto ldv_36103;
    case 6: 
#line 803
    cmd->result = 458752;
#line 804
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p had hardware error\n",
             c);
#line 806
    goto ldv_36103;
    case 7: 
#line 808
    cmd->result = 458752;
#line 809
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p had connection lost\n",
             c);
#line 811
    goto ldv_36103;
    case 8: 
#line 813
    cmd->result = 327680;
#line 814
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p was aborted\n", c);
#line 815
    goto ldv_36103;
    case 9: 
#line 817
    cmd->result = 458752;
#line 818
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p reports abort failed\n",
             c);
#line 820
    goto ldv_36103;
    case 10: 
#line 822
    cmd->result = 327680;
#line 823
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p aborted due to an unsolicited abort\n",
             c);
#line 825
    goto ldv_36103;
    case 11: 
#line 827
    cmd->result = 196608;
#line 828
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p timedout\n", c);
#line 829
    goto ldv_36103;
    case 12: 
#line 831
    cmd->result = 458752;
#line 832
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "c %p command unabortable\n",
             c);
#line 834
    goto ldv_36103;
    default: 
#line 836
    cmd->result = 458752;
#line 837
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p returned unknown status %x\n",
             c, (int )ei->CommandStatus);
    }
    ldv_36103: ;
  } else {

  }
#line 842
  (*(cmd->scsi_done))(cmd);
#line 843
  scsi_cmd_free(h, c);
#line 844
  return;
}
}
#line 847 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_detect(ctlr_info_t *h ) 
{ 
  struct Scsi_Host *sh ;
  int error ;

  {
#line 852
  sh = scsi_host_alloc(& cciss_driver_template, 8);
#line 853
  if ((unsigned long )sh == (unsigned long )((struct Scsi_Host *)0)) {
#line 854
    goto fail;
  } else {

  }
#line 855
  sh->io_port = 0UL;
#line 856
  sh->n_io_port = 0U;
#line 857
  sh->this_id = 15;
#line 858
  sh->can_queue = cciss_tape_cmds;
#line 859
  sh->sg_tablesize = (unsigned short )h->maxsgentries;
#line 860
  sh->max_cmd_len = 16U;
#line 861
  sh->max_sectors = (unsigned short )h->cciss_max_sectors;
#line 864
  (h->scsi_ctlr)->scsi_host = sh;
#line 865
  sh->hostdata[0] = (unsigned long )h;
#line 866
  sh->irq = h->intr[2];
#line 867
  sh->unique_id = sh->irq;
#line 868
  error = scsi_add_host(sh, & (h->pdev)->dev);
#line 869
  if (error != 0) {
#line 870
    goto fail_host_put;
  } else {

  }
#line 871
  scsi_scan_host(sh);
#line 872
  return (1);
  fail_host_put: 
#line 875
  scsi_host_put(sh);
  fail: ;
#line 877
  return (0);
}
}
#line 881 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_unmap_one(struct pci_dev *pdev , CommandList_struct *c , size_t buflen ,
                            int data_direction ) 
{ 
  u64bit addr64 ;

  {
#line 888
  addr64.val32.lower = c->SG[0].Addr.lower;
#line 889
  addr64.val32.upper = c->SG[0].Addr.upper;
#line 890
  pci_unmap_single(pdev, addr64.val, buflen, data_direction);
#line 891
  return;
}
}
#line 894 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_map_one(struct pci_dev *pdev , CommandList_struct *c , unsigned char *buf ,
                          size_t buflen , int data_direction ) 
{ 
  __u64 addr64 ;

  {
#line 902
  addr64 = pci_map_single(pdev, (void *)buf, buflen, data_direction);
#line 903
  c->SG[0].Addr.lower = (unsigned int )addr64;
#line 905
  c->SG[0].Addr.upper = (unsigned int )(addr64 >> 32);
#line 907
  c->SG[0].Len = (__u32 )buflen;
#line 908
  c->Header.SGList = 1U;
#line 909
  c->Header.SGTotal = 1U;
#line 910
  return;
}
}
#line 913 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_do_simple_cmd(ctlr_info_t *h , CommandList_struct *c , unsigned char *scsi3addr ,
                                    unsigned char *cdb , unsigned char cdblen , unsigned char *buf ,
                                    int bufsize , int direction ) 
{ 
  struct completion wait ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 921
  init_completion(& wait);
#line 921
  wait = wait;
#line 923
  c->cmd_type = 1;
#line 924
  c->scsi_cmd = 0;
#line 925
  c->Header.ReplyQueue = 0U;
#line 926
  __len = 8UL;
#line 926
  if (__len > 63UL) {
#line 926
    __ret = __memcpy((void *)(& c->Header.LUN), (void const   *)scsi3addr, __len);
  } else {
#line 926
    __ret = __builtin_memcpy((void *)(& c->Header.LUN), (void const   *)scsi3addr,
                             __len);
  }
#line 927
  c->Header.Tag.lower = c->busaddr;
#line 934
  memset((void *)(& c->Request.CDB), 0, 16UL);
#line 935
  __len___0 = (size_t )cdblen;
#line 935
  __ret___0 = __builtin_memcpy((void *)(& c->Request.CDB), (void const   *)cdb, __len___0);
#line 936
  c->Request.Timeout = 0U;
#line 937
  c->Request.CDBLen = cdblen;
#line 938
  c->Request.Type.Type = 0U;
#line 939
  c->Request.Type.Attribute = 4U;
#line 940
  c->Request.Type.Direction = (unsigned char )direction;
#line 943
  cciss_map_one(h->pdev, c, buf, (size_t )bufsize, 2);
#line 946
  c->waiting = & wait;
#line 947
  enqueue_cmd_and_start_io(h, c);
#line 948
  wait_for_completion(& wait);
#line 951
  cciss_unmap_one(h->pdev, c, (size_t )bufsize, 2);
#line 952
  return (0);
}
}
#line 956 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_scsi_interpret_error(ctlr_info_t *h , CommandList_struct *c ) 
{ 
  ErrorInfo_struct *ei ;

  {
#line 960
  ei = c->err_info;
#line 961
  switch ((int )ei->CommandStatus) {
  case 1: 
#line 964
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has completed with errors\n",
           c);
#line 966
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has SCSI Status = %x\n",
           c, (int )ei->ScsiStatus);
#line 969
  if ((unsigned int )ei->ScsiStatus == 0U) {
#line 970
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "SCSI status is abnormally zero.  (probably indicates selection timeout reported incorrectly due to a known firmware bug, circa July, 2001.)\n");
  } else {

  }
#line 975
  goto ldv_36162;
  case 2: 
#line 977
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "UNDERRUN\n");
#line 978
  goto ldv_36162;
  case 3: 
#line 980
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p has completed with data overrun reported\n",
           c);
#line 983
  goto ldv_36162;
  case 4: 
#line 987
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p is reported invalid (probably means target device no longer present)\n",
           c);
#line 993
  goto ldv_36162;
  case 5: 
#line 995
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p has protocol error\n",
           c);
#line 996
  goto ldv_36162;
  case 6: 
#line 999
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p had hardware error\n",
           c);
#line 1000
  goto ldv_36162;
  case 7: 
#line 1002
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p had connection lost\n",
           c);
#line 1003
  goto ldv_36162;
  case 8: 
#line 1005
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p was aborted\n", c);
#line 1006
  goto ldv_36162;
  case 9: 
#line 1008
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p reports abort failed\n",
           c);
#line 1010
  goto ldv_36162;
  case 10: 
#line 1012
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p aborted due to an unsolicited abort\n",
           c);
#line 1014
  goto ldv_36162;
  case 11: 
#line 1016
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p timedout\n", c);
#line 1017
  goto ldv_36162;
  case 12: 
#line 1019
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p unabortable\n", c);
#line 1021
  goto ldv_36162;
  default: 
#line 1023
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p returned unknown status %x\n",
           c, (int )ei->CommandStatus);
  }
  ldv_36162: ;
#line 1028
  return;
}
}
#line 1030 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_do_inquiry(ctlr_info_t *h , unsigned char *scsi3addr , unsigned char page ,
                                 unsigned char *buf , unsigned char bufsize ) 
{ 
  int rc ;
  CommandList_struct *c ;
  char cdb[6U] ;
  ErrorInfo_struct *ei ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1040
  tmp = spinlock_check(& h->lock);
#line 1040
  flags = _raw_spin_lock_irqsave(tmp);
#line 1041
  c = scsi_cmd_alloc(h);
#line 1042
  spin_unlock_irqrestore(& h->lock, flags);
#line 1044
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1045
    printk("cmd_alloc returned NULL!\n");
#line 1046
    return (-1);
  } else {

  }
#line 1049
  ei = c->err_info;
#line 1051
  cdb[0] = 18;
#line 1052
  cdb[1] = (unsigned int )page != 0U;
#line 1053
  cdb[2] = (char )page;
#line 1054
  cdb[3] = 0;
#line 1055
  cdb[4] = (char )bufsize;
#line 1056
  cdb[5] = 0;
#line 1057
  rc = cciss_scsi_do_simple_cmd(h, c, scsi3addr, (unsigned char *)(& cdb), 6, buf,
                                (int )bufsize, 2);
#line 1060
  if (rc != 0) {
#line 1060
    return (rc);
  } else {

  }
#line 1062
  if ((unsigned int )ei->CommandStatus != 0U && (unsigned int )ei->CommandStatus != 2U) {
#line 1064
    cciss_scsi_interpret_error(h, c);
#line 1065
    rc = -1;
  } else {

  }
#line 1067
  tmp___0 = spinlock_check(& h->lock);
#line 1067
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1068
  scsi_cmd_free(h, c);
#line 1069
  spin_unlock_irqrestore(& h->lock, flags);
#line 1070
  return (rc);
}
}
#line 1074 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_get_device_id(ctlr_info_t *h , unsigned char *scsi3addr , unsigned char *device_id ,
                                    int buflen ) 
{ 
  int rc ;
  unsigned char *buf ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1080
  if (buflen > 16) {
#line 1081
    buflen = 16;
  } else {

  }
#line 1082
  tmp = kzalloc(64UL, 208U);
#line 1082
  buf = (unsigned char *)tmp;
#line 1083
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0)) {
#line 1084
    return (-1);
  } else {

  }
#line 1085
  rc = cciss_scsi_do_inquiry(h, scsi3addr, 131, buf, 64);
#line 1086
  if (rc == 0) {
#line 1087
    __len = (size_t )buflen;
#line 1087
    __ret = __builtin_memcpy((void *)device_id, (void const   *)buf + 8U, __len);
  } else {

  }
#line 1088
  kfree((void const   *)buf);
#line 1089
  return (rc != 0);
}
}
#line 1093 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_do_report_phys_luns(ctlr_info_t *h , ReportLunData_struct *buf ,
                                          int bufsize ) 
{ 
  int rc ;
  CommandList_struct *c ;
  unsigned char cdb[12U] ;
  unsigned char scsi3addr[8U] ;
  ErrorInfo_struct *ei ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1103
  tmp = spinlock_check(& h->lock);
#line 1103
  flags = _raw_spin_lock_irqsave(tmp);
#line 1104
  c = scsi_cmd_alloc(h);
#line 1105
  spin_unlock_irqrestore(& h->lock, flags);
#line 1106
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1107
    printk("cmd_alloc returned NULL!\n");
#line 1108
    return (-1);
  } else {

  }
#line 1111
  memset((void *)(& scsi3addr), 0, 8UL);
#line 1112
  cdb[0] = 195U;
#line 1113
  cdb[1] = 0U;
#line 1114
  cdb[2] = 0U;
#line 1115
  cdb[3] = 0U;
#line 1116
  cdb[4] = 0U;
#line 1117
  cdb[5] = 0U;
#line 1118
  cdb[6] = (unsigned char )((unsigned int )bufsize >> 24);
#line 1119
  cdb[7] = (unsigned char )(bufsize >> 16);
#line 1120
  cdb[8] = (unsigned char )(bufsize >> 8);
#line 1121
  cdb[9] = (unsigned char )bufsize;
#line 1122
  cdb[10] = 0U;
#line 1123
  cdb[11] = 0U;
#line 1125
  rc = cciss_scsi_do_simple_cmd(h, c, (unsigned char *)(& scsi3addr), (unsigned char *)(& cdb),
                                12, (unsigned char *)buf, bufsize, 2);
#line 1130
  if (rc != 0) {
#line 1130
    return (rc);
  } else {

  }
#line 1132
  ei = c->err_info;
#line 1133
  if ((unsigned int )ei->CommandStatus != 0U && (unsigned int )ei->CommandStatus != 2U) {
#line 1135
    cciss_scsi_interpret_error(h, c);
#line 1136
    rc = -1;
  } else {

  }
#line 1138
  tmp___0 = spinlock_check(& h->lock);
#line 1138
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1139
  scsi_cmd_free(h, c);
#line 1140
  spin_unlock_irqrestore(& h->lock, flags);
#line 1141
  return (rc);
}
}
#line 1145 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_update_non_disk_devices(ctlr_info_t *h , int hostno ) 
{ 
  ReportLunData_struct *ld_buff ;
  unsigned char *inq_buff ;
  unsigned char scsi3addr[8U] ;
  __u32 num_luns ;
  unsigned char *ch ;
  struct cciss_scsi_dev_t *currentsd ;
  struct cciss_scsi_dev_t *this_device ;
  int ncurrent ;
  int reportlunsize ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;
  int tmp___3 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  char obdr_sig[7U] ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 1178
  num_luns = 0U;
#line 1181
  ncurrent = 0;
#line 1182
  reportlunsize = 16392;
#line 1185
  tmp = kzalloc((size_t )reportlunsize, 208U);
#line 1185
  ld_buff = (ReportLunData_struct *)tmp;
#line 1186
  tmp___0 = kmalloc(49UL, 208U);
#line 1186
  inq_buff = (unsigned char *)tmp___0;
#line 1187
  tmp___1 = kzalloc(1156UL, 208U);
#line 1187
  currentsd = (struct cciss_scsi_dev_t *)tmp___1;
#line 1189
  if (((unsigned long )ld_buff == (unsigned long )((ReportLunData_struct *)0) || (unsigned long )inq_buff == (unsigned long )((unsigned char *)0)) || (unsigned long )currentsd == (unsigned long )((struct cciss_scsi_dev_t *)0)) {
#line 1190
    printk("\vcciss: out of memory\n");
#line 1191
    goto out;
  } else {

  }
#line 1193
  this_device = currentsd + 16UL;
#line 1194
  tmp___2 = cciss_scsi_do_report_phys_luns(h, ld_buff, reportlunsize);
#line 1194
  if (tmp___2 == 0) {
#line 1195
    ch = (unsigned char *)(& ld_buff->LUNListLength);
#line 1196
    num_luns = (__u32 )((((((int )*ch << 24) | ((int )*(ch + 1UL) << 16)) | ((int )*(ch + 2UL) << 8)) | (int )*(ch + 3UL)) / 8);
#line 1197
    if (num_luns > 1024U) {
#line 1198
      printk("\fcciss: Maximum physical LUNs (%d) exceeded.  %d LUNs ignored.\n",
             1024, num_luns - 1024U);
#line 1202
      num_luns = 1024U;
    } else {

    }
  } else {
#line 1206
    printk("\vcciss: Report physical LUNs failed.\n");
#line 1207
    goto out;
  }
#line 1212
  i = 0;
#line 1212
  goto ldv_36259;
  ldv_36258: ;
#line 1214
  if (((int )ld_buff->LUN[i][3] & 192) != 0) {
#line 1214
    goto ldv_36236;
  } else {

  }
#line 1215
  memset((void *)inq_buff, 0, 49UL);
#line 1216
  __len = 8UL;
#line 1216
  if (__len > 63UL) {
#line 1216
    __ret = __memcpy((void *)(& scsi3addr), (void const   *)(& ld_buff->LUN) + (unsigned long )i,
                     __len);
  } else {
#line 1216
    __ret = __builtin_memcpy((void *)(& scsi3addr), (void const   *)(& ld_buff->LUN) + (unsigned long )i,
                             __len);
  }
#line 1218
  tmp___3 = cciss_scsi_do_inquiry(h, (unsigned char *)(& scsi3addr), 0, inq_buff,
                                  49);
#line 1218
  if (tmp___3 != 0) {
#line 1221
    goto ldv_36236;
  } else {

  }
#line 1223
  this_device->devtype = (int )*inq_buff & 31;
#line 1224
  this_device->bus = -1;
#line 1225
  this_device->target = -1;
#line 1226
  this_device->lun = -1;
#line 1227
  __len___0 = 8UL;
#line 1227
  if (__len___0 > 63UL) {
#line 1227
    __ret___0 = __memcpy((void *)(& this_device->scsi3addr), (void const   *)(& scsi3addr),
                         __len___0);
  } else {
#line 1227
    __ret___0 = __builtin_memcpy((void *)(& this_device->scsi3addr), (void const   *)(& scsi3addr),
                                 __len___0);
  }
#line 1228
  __len___1 = 8UL;
#line 1228
  if (__len___1 > 63UL) {
#line 1228
    __ret___1 = __memcpy((void *)(& this_device->vendor), (void const   *)inq_buff + 8U,
                         __len___1);
  } else {
#line 1228
    __ret___1 = __builtin_memcpy((void *)(& this_device->vendor), (void const   *)inq_buff + 8U,
                                 __len___1);
  }
#line 1230
  __len___2 = 16UL;
#line 1230
  if (__len___2 > 63UL) {
#line 1230
    __ret___2 = __memcpy((void *)(& this_device->model), (void const   *)inq_buff + 16U,
                         __len___2);
  } else {
#line 1230
    __ret___2 = __builtin_memcpy((void *)(& this_device->model), (void const   *)inq_buff + 16U,
                                 __len___2);
  }
#line 1232
  __len___3 = 4UL;
#line 1232
  if (__len___3 > 63UL) {
#line 1232
    __ret___3 = __memcpy((void *)(& this_device->revision), (void const   *)inq_buff + 32U,
                         __len___3);
  } else {
#line 1232
    __ret___3 = __builtin_memcpy((void *)(& this_device->revision), (void const   *)inq_buff + 32U,
                                 __len___3);
  }
#line 1234
  memset((void *)(& this_device->device_id), 0, 16UL);
#line 1236
  cciss_scsi_get_device_id(h, (unsigned char *)(& scsi3addr), (unsigned char *)(& this_device->device_id),
                           16);
#line 1239
  switch (this_device->devtype) {
  case 5: 
#line 1252
  strncpy((char *)(& obdr_sig), (char const   *)inq_buff + 43U, 6UL);
#line 1253
  obdr_sig[6] = 0;
#line 1254
  tmp___4 = strncmp((char const   *)(& obdr_sig), "$DR-10", 6UL);
#line 1254
  if (tmp___4 != 0) {
#line 1256
    goto ldv_36254;
  } else {

  }
  case 1: ;
  case 8: ;
#line 1261
  if (ncurrent > 15) {
#line 1262
    tmp___5 = scsi_device_type((unsigned int )this_device->devtype);
#line 1262
    printk("\016cciss%d: %s ignored, too many devices.\n", h->ctlr, tmp___5);
#line 1265
    goto ldv_36254;
  } else {

  }
#line 1267
  *(currentsd + (unsigned long )ncurrent) = *this_device;
#line 1268
  ncurrent = ncurrent + 1;
#line 1269
  goto ldv_36254;
  default: ;
#line 1271
  goto ldv_36254;
  }
  ldv_36254: ;
  ldv_36236: 
#line 1212
  i = i + 1;
  ldv_36259: ;
#line 1212
  if ((__u32 )i < num_luns) {
#line 1213
    goto ldv_36258;
  } else {

  }
#line 1275
  adjust_cciss_scsi_table(h, hostno, currentsd, ncurrent);
  out: 
#line 1277
  kfree((void const   *)inq_buff);
#line 1278
  kfree((void const   *)ld_buff);
#line 1279
  kfree((void const   *)currentsd);
#line 1280
  return;
}
}
#line 1284 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int is_keyword(char *ptr , int len , char *verb ) 
{ 
  int verb_len ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1286
  tmp = strlen((char const   *)verb);
#line 1286
  verb_len = (int )tmp;
#line 1287
  if (len >= verb_len) {
#line 1287
    tmp___0 = memcmp((void const   *)verb, (void const   *)ptr, (size_t )verb_len);
#line 1287
    if (tmp___0 == 0) {
#line 1288
      return (verb_len);
    } else {
#line 1290
      return (0);
    }
  } else {
#line 1290
    return (0);
  }
}
}
#line 1294 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_user_command(ctlr_info_t *h , int hostno , char *buffer , int length ) 
{ 
  int arg_len ;

  {
#line 1298
  arg_len = is_keyword(buffer, length, (char *)"rescan");
#line 1298
  if (arg_len != 0) {
#line 1299
    cciss_update_non_disk_devices(h, hostno);
  } else {
#line 1301
    return (-22);
  }
#line 1302
  return (length);
}
}
#line 1307 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_proc_info(struct Scsi_Host *sh , char *buffer , char **start ,
                                off_t offset , int length , int func ) 
{ 
  int buflen ;
  int datalen ;
  ctlr_info_t *h ;
  int i ;
  struct cciss_scsi_dev_t *sd ;
  int tmp ;
  int tmp___0 ;

  {
#line 1319
  h = (ctlr_info_t *)sh->hostdata[0];
#line 1320
  if ((unsigned long )h == (unsigned long )((ctlr_info_t *)0)) {
#line 1321
    return (-22);
  } else {

  }
#line 1323
  if (func == 0) {
#line 1324
    buflen = sprintf(buffer, "cciss%d: SCSI host: %d\n", h->ctlr, sh->host_no);
#line 1335
    i = 0;
#line 1335
    goto ldv_36288;
    ldv_36287: 
#line 1336
    sd = (struct cciss_scsi_dev_t *)(& ccissscsi[h->ctlr].dev) + (unsigned long )i;
#line 1338
    tmp = sprintf(buffer + (unsigned long )buflen, "c%db%dt%dl%d %02d 0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
                  sh->host_no, sd->bus, sd->target, sd->lun, sd->devtype, (int )sd->scsi3addr[0],
                  (int )sd->scsi3addr[1], (int )sd->scsi3addr[2], (int )sd->scsi3addr[3],
                  (int )sd->scsi3addr[4], (int )sd->scsi3addr[5], (int )sd->scsi3addr[6],
                  (int )sd->scsi3addr[7]);
#line 1338
    buflen = tmp + buflen;
#line 1335
    i = i + 1;
    ldv_36288: ;
#line 1335
    if (ccissscsi[h->ctlr].ndevices > i) {
#line 1336
      goto ldv_36287;
    } else {

    }
#line 1347
    datalen = (int )((unsigned int )buflen - (unsigned int )offset);
#line 1348
    if (datalen < 0) {
#line 1349
      datalen = 0;
#line 1350
      *start = buffer + (unsigned long )buflen;
    } else {
#line 1352
      *start = buffer + (unsigned long )offset;
    }
#line 1353
    return (datalen);
  } else {
#line 1355
    tmp___0 = cciss_scsi_user_command(h, (int )sh->host_no, buffer, length);
#line 1355
    return (tmp___0);
  }
}
}
#line 1363 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_scatter_gather(ctlr_info_t *h , CommandList_struct *c , struct scsi_cmnd *cmd ) 
{ 
  unsigned int len ;
  struct scatterlist *sg ;
  __u64 addr64 ;
  int request_nsgs ;
  int i ;
  int chained ;
  int sg_index ;
  struct cciss_scsi_adapter_data_t *sa ;
  SGDescriptor_struct *curr_sg ;
  unsigned int tmp ;
  long tmp___0 ;

  {
#line 1370
  sa = h->scsi_ctlr;
#line 1373
  tmp = scsi_sg_count(cmd);
#line 1373
  tmp___0 = ldv__builtin_expect(tmp > (unsigned int )h->maxsgentries, 0L);
#line 1373
  if (tmp___0 != 0L) {
#line 1373
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                         "i" (1373), "i" (12UL));
    ldv_36304: ;
#line 1373
    goto ldv_36304;
  } else {

  }
#line 1375
  chained = 0;
#line 1376
  sg_index = 0;
#line 1377
  curr_sg = (SGDescriptor_struct *)(& c->SG);
#line 1378
  request_nsgs = scsi_dma_map(cmd);
#line 1379
  if (request_nsgs != 0) {
#line 1380
    i = 0;
#line 1380
    sg = scsi_sglist(cmd);
#line 1380
    goto ldv_36306;
    ldv_36305: ;
#line 1381
    if ((sg_index + 1 == h->max_cmd_sgentries && chained == 0) && request_nsgs - i > 1) {
#line 1383
      chained = 1;
#line 1384
      sg_index = 0;
#line 1385
      curr_sg = *(sa->cmd_sg_list + (unsigned long )c->cmdindex);
    } else {

    }
#line 1387
    addr64 = sg->dma_address;
#line 1388
    len = sg->dma_length;
#line 1389
    (curr_sg + (unsigned long )sg_index)->Addr.lower = (unsigned int )addr64;
#line 1391
    (curr_sg + (unsigned long )sg_index)->Addr.upper = (unsigned int )(addr64 >> 32);
#line 1393
    (curr_sg + (unsigned long )sg_index)->Len = len;
#line 1394
    (curr_sg + (unsigned long )sg_index)->Ext = 0U;
#line 1395
    sg_index = sg_index + 1;
#line 1380
    i = i + 1;
#line 1380
    sg = sg_next(sg);
    ldv_36306: ;
#line 1380
    if (i < request_nsgs) {
#line 1381
      goto ldv_36305;
    } else {

    }

#line 1397
    if (chained != 0) {
#line 1398
      cciss_map_sg_chain_block(h, c, *(sa->cmd_sg_list + (unsigned long )c->cmdindex),
                               (int )((unsigned int )((1 - h->max_cmd_sgentries) + request_nsgs) * 16U));
    } else {

    }
  } else {

  }
#line 1404
  if ((unsigned int )request_nsgs > h->maxSG) {
#line 1405
    h->maxSG = (unsigned int )request_nsgs;
  } else {

  }
#line 1406
  c->Header.SGTotal = (int )((__u16 )request_nsgs) + (int )((__u16 )chained);
#line 1407
  if (h->max_cmd_sgentries < request_nsgs) {
#line 1408
    c->Header.SGList = (__u8 )h->max_cmd_sgentries;
  } else {
#line 1410
    c->Header.SGList = (__u8 )c->Header.SGTotal;
  }
#line 1411
  return;
}
}
#line 1416 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_queue_command_lck(struct scsi_cmnd *cmd , void (*done)(struct scsi_cmnd * ) ) 
{ 
  ctlr_info_t *h ;
  int rc ;
  unsigned char scsi3addr[8U] ;
  CommandList_struct *c ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  long tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1426
  h = (ctlr_info_t *)((cmd->device)->host)->hostdata[0];
#line 1428
  rc = lookup_scsi3addr(h, (int )(cmd->device)->channel, (int )(cmd->device)->id,
                        (int )(cmd->device)->lun, (char *)(& scsi3addr));
#line 1430
  if (rc != 0) {
#line 1433
    cmd->result = 65536;
#line 1434
    (*done)(cmd);
#line 1437
    return (0);
  } else {

  }
#line 1443
  tmp = spinlock_check(& h->lock);
#line 1443
  flags = _raw_spin_lock_irqsave(tmp);
#line 1444
  c = scsi_cmd_alloc(h);
#line 1445
  spin_unlock_irqrestore(& h->lock, flags);
#line 1446
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1447
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "scsi_cmd_alloc returned NULL!\n");
#line 1449
    cmd->result = 65536;
#line 1450
    (*done)(cmd);
#line 1451
    return (0);
  } else {

  }
#line 1456
  cmd->scsi_done = done;
#line 1459
  cmd->host_scribble = (unsigned char *)c;
#line 1461
  c->cmd_type = 3;
#line 1462
  c->scsi_cmd = (void *)cmd;
#line 1463
  c->Header.ReplyQueue = 0U;
#line 1464
  __len = 8UL;
#line 1464
  if (__len > 63UL) {
#line 1464
    __ret = __memcpy((void *)(& c->Header.LUN.LunAddrBytes), (void const   *)(& scsi3addr),
                     __len);
  } else {
#line 1464
    __ret = __builtin_memcpy((void *)(& c->Header.LUN.LunAddrBytes), (void const   *)(& scsi3addr),
                             __len);
  }
#line 1465
  c->Header.Tag.lower = c->busaddr;
#line 1469
  c->Request.Timeout = 0U;
#line 1470
  memset((void *)(& c->Request.CDB), 0, 16UL);
#line 1471
  tmp___0 = ldv__builtin_expect((unsigned int )cmd->cmd_len > 16U, 0L);
#line 1471
  if (tmp___0 != 0L) {
#line 1471
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                         "i" (1471), "i" (12UL));
    ldv_36324: ;
#line 1471
    goto ldv_36324;
  } else {

  }
#line 1472
  c->Request.CDBLen = (__u8 )cmd->cmd_len;
#line 1473
  __len___0 = (size_t )cmd->cmd_len;
#line 1473
  __ret___0 = __builtin_memcpy((void *)(& c->Request.CDB), (void const   *)cmd->cmnd,
                               __len___0);
#line 1474
  c->Request.Type.Type = 0U;
#line 1475
  c->Request.Type.Attribute = 4U;
#line 1476
  switch ((unsigned int )cmd->sc_data_direction) {
  case 1U: 
#line 1479
  c->Request.Type.Direction = 1U;
#line 1480
  goto ldv_36329;
  case 2U: 
#line 1482
  c->Request.Type.Direction = 2U;
#line 1483
  goto ldv_36329;
  case 3U: 
#line 1485
  c->Request.Type.Direction = 0U;
#line 1486
  goto ldv_36329;
  case 0U: 
#line 1492
  c->Request.Type.Direction = 3U;
#line 1500
  goto ldv_36329;
  default: 
#line 1503
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "unknown data direction: %d\n",
           (unsigned int )cmd->sc_data_direction);
#line 1505
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"),
                       "i" (1505), "i" (12UL));
  ldv_36334: ;
#line 1505
  goto ldv_36334;
  }
  ldv_36329: 
#line 1508
  cciss_scatter_gather(h, c, cmd);
#line 1509
  enqueue_cmd_and_start_io(h, c);
#line 1511
  return (0);
}
}
#line 1514 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_scsi_queue_command(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) 
{ 
  unsigned long irq_flags ;
  int rc ;
  raw_spinlock_t *tmp ;

  {
#line 1514
  tmp = spinlock_check(shost->host_lock);
#line 1514
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 1514
  scsi_cmd_get_serial(shost, cmd);
#line 1514
  rc = cciss_scsi_queue_command_lck(cmd, cmd->scsi_done);
#line 1514
  spin_unlock_irqrestore(shost->host_lock, irq_flags);
#line 1514
  return (rc);
}
}
#line 1516 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_unregister_scsi(ctlr_info_t *h ) 
{ 
  struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1524
  tmp = spinlock_check(& h->lock);
#line 1524
  flags = _raw_spin_lock_irqsave(tmp);
#line 1525
  sa = h->scsi_ctlr;
#line 1526
  stk = & sa->cmd_stack;
#line 1529
  if (sa->registered != 0) {
#line 1530
    spin_unlock_irqrestore(& h->lock, flags);
#line 1531
    scsi_remove_host(sa->scsi_host);
#line 1532
    scsi_host_put(sa->scsi_host);
#line 1533
    tmp___0 = spinlock_check(& h->lock);
#line 1533
    flags = _raw_spin_lock_irqsave(tmp___0);
  } else {

  }
#line 1538
  sa->scsi_host = 0;
#line 1539
  spin_unlock_irqrestore(& h->lock, flags);
#line 1540
  scsi_cmd_stack_free(h);
#line 1541
  kfree((void const   *)sa);
#line 1542
  return;
}
}
#line 1544 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_engage_scsi(ctlr_info_t *h ) 
{ 
  struct cciss_scsi_adapter_data_t *sa ;
  struct cciss_scsi_cmd_stack_t *stk ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 1550
  tmp = spinlock_check(& h->lock);
#line 1550
  flags = _raw_spin_lock_irqsave(tmp);
#line 1551
  sa = h->scsi_ctlr;
#line 1552
  stk = & sa->cmd_stack;
#line 1554
  if (sa->registered != 0) {
#line 1555
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "SCSI subsystem already engaged.\n");
#line 1556
    spin_unlock_irqrestore(& h->lock, flags);
#line 1557
    return (-6);
  } else {

  }
#line 1559
  sa->registered = 1;
#line 1560
  spin_unlock_irqrestore(& h->lock, flags);
#line 1561
  cciss_update_non_disk_devices(h, -1);
#line 1562
  cciss_scsi_detect(h);
#line 1563
  return (0);
}
}
#line 1567 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static void cciss_seq_tape_report(struct seq_file *seq , ctlr_info_t *h ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 1571
  tmp = spinlock_check(& (h->scsi_ctlr)->lock);
#line 1571
  flags = _raw_spin_lock_irqsave(tmp);
#line 1572
  seq_printf(seq, "Sequential access devices: %d\n\n", ccissscsi[h->ctlr].ndevices);
#line 1575
  spin_unlock_irqrestore(& (h->scsi_ctlr)->lock, flags);
#line 1576
  return;
}
}
#line 1578 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int wait_for_device_to_become_ready(ctlr_info_t *h , unsigned char *lunaddr ) 
{ 
  int rc ;
  int count ;
  int waittime ;
  CommandList_struct *c ;
  unsigned char asc ;

  {
#line 1582
  count = 0;
#line 1583
  waittime = 250;
#line 1586
  c = cmd_alloc(h);
#line 1587
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1588
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "out of memory in wait_for_device_to_become_ready.\n");
#line 1590
    return (1);
  } else {

  }
#line 1594
  goto ldv_36385;
  ldv_36384: 
#line 1599
  schedule_timeout_uninterruptible((long )waittime);
#line 1600
  count = count + 1;
#line 1603
  if (waittime <= 7499) {
#line 1604
    waittime = waittime * 2;
  } else {

  }
#line 1607
  rc = fill_cmd(h, c, 0, 0, 0UL, 0, lunaddr, 0);
#line 1609
  if (rc == 0) {
#line 1610
    rc = sendcmd_withirq_core(h, c, 0);
  } else {

  }
#line 1612
  process_sendcmd_error(h, c);
#line 1614
  if (rc != 0) {
#line 1615
    goto retry_tur;
  } else {

  }
#line 1617
  if ((unsigned int )(c->err_info)->CommandStatus == 0U) {
#line 1618
    goto ldv_36382;
  } else {

  }
#line 1620
  if ((unsigned int )(c->err_info)->CommandStatus == 1U && (unsigned int )(c->err_info)->ScsiStatus == 2U) {
#line 1622
    if ((unsigned int )(c->err_info)->SenseInfo[2] == 0U) {
#line 1623
      goto ldv_36382;
    } else {

    }
#line 1624
    if ((unsigned int )(c->err_info)->SenseInfo[2] == 6U) {
#line 1626
      asc = (c->err_info)->SenseInfo[12];
#line 1627
      check_for_unit_attention(h, c);
#line 1628
      if ((unsigned int )asc == 41U) {
#line 1629
        goto ldv_36382;
      } else {

      }
    } else {

    }
  } else {

  }
  retry_tur: 
#line 1633
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "Waiting %d secs for device to become ready.\n",
           waittime / 250);
#line 1636
  rc = 1;
  ldv_36385: ;
#line 1594
  if (count <= 19) {
#line 1595
    goto ldv_36384;
  } else {

  }
  ldv_36382: ;
#line 1639
  if (rc != 0) {
#line 1640
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "giving up on device.\n");
  } else {
#line 1642
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "device is ready.\n");
  }
#line 1644
  cmd_free(h, c);
#line 1645
  return (rc);
}
}
#line 1659 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_eh_device_reset_handler(struct scsi_cmnd *scsicmd ) 
{ 
  int rc ;
  CommandList_struct *cmd_in_trouble ;
  unsigned char lunaddr[8U] ;
  ctlr_info_t *h ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 1667
  h = (ctlr_info_t *)((scsicmd->device)->host)->hostdata[0];
#line 1668
  if ((unsigned long )h == (unsigned long )((ctlr_info_t *)0)) {
#line 1669
    return (8195);
  } else {

  }
#line 1670
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "resetting tape drive or medium changer.\n");
#line 1672
  cmd_in_trouble = (CommandList_struct *)scsicmd->host_scribble;
#line 1673
  if ((unsigned long )cmd_in_trouble == (unsigned long )((CommandList_struct *)0)) {
#line 1674
    return (8195);
  } else {

  }
#line 1675
  __len = 8UL;
#line 1675
  if (__len > 63UL) {
#line 1675
    __ret = __memcpy((void *)(& lunaddr), (void const   *)(& cmd_in_trouble->Header.LUN.LunAddrBytes),
                     __len);
  } else {
#line 1675
    __ret = __builtin_memcpy((void *)(& lunaddr), (void const   *)(& cmd_in_trouble->Header.LUN.LunAddrBytes),
                             __len);
  }
#line 1677
  rc = sendcmd_withirq(h, 1, 0, 0UL, 0, (unsigned char *)(& lunaddr), 1);
#line 1679
  if (rc == 0) {
#line 1679
    tmp = wait_for_device_to_become_ready(h, (unsigned char *)(& lunaddr));
#line 1679
    if (tmp == 0) {
#line 1680
      return (8194);
    } else {

    }
  } else {

  }
#line 1681
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "resetting device failed.\n");
#line 1682
  return (8195);
}
}
#line 1685 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/inst/current/envs/linux-3.8-rc1/linux-3.8-rc1/drivers/block/cciss_scsi.c"
static int cciss_eh_abort_handler(struct scsi_cmnd *scsicmd ) 
{ 
  int rc ;
  CommandList_struct *cmd_to_abort ;
  unsigned char lunaddr[8U] ;
  ctlr_info_t *h ;
  size_t __len ;
  void *__ret ;

  {
#line 1693
  h = (ctlr_info_t *)((scsicmd->device)->host)->hostdata[0];
#line 1694
  if ((unsigned long )h == (unsigned long )((ctlr_info_t *)0)) {
#line 1695
    return (8195);
  } else {

  }
#line 1696
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "aborting tardy SCSI cmd\n");
#line 1699
  cmd_to_abort = (CommandList_struct *)scsicmd->host_scribble;
#line 1700
  if ((unsigned long )cmd_to_abort == (unsigned long )((CommandList_struct *)0)) {
#line 1701
    return (8195);
  } else {

  }
#line 1702
  __len = 8UL;
#line 1702
  if (__len > 63UL) {
#line 1702
    __ret = __memcpy((void *)(& lunaddr), (void const   *)(& cmd_to_abort->Header.LUN.LunAddrBytes),
                     __len);
  } else {
#line 1702
    __ret = __builtin_memcpy((void *)(& lunaddr), (void const   *)(& cmd_to_abort->Header.LUN.LunAddrBytes),
                             __len);
  }
#line 1703
  rc = sendcmd_withirq(h, 0, (void *)(& cmd_to_abort->Header.Tag), 0UL, 0, (unsigned char *)(& lunaddr),
                       1);
#line 1705
  if (rc == 0) {
#line 1706
    return (8194);
  } else {

  }
#line 1707
  return (8195);
}
}
#line 422 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static char const   *raid_label[7U]  = {      "0",      "4",      "1(1+0)",      "5", 
        "5+1",      "ADG",      "UNKNOWN"};
#line 436 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_seq_show_header(struct seq_file *seq ) 
{ 
  ctlr_info_t *h ;

  {
#line 438
  h = (ctlr_info_t *)seq->private;
#line 440
  seq_printf(seq, "%s: HP %s Controller\nBoard ID: 0x%08lx\nFirmware Version: %c%c%c%c\nIRQ: %d\nLogical drives: %d\nCurrent Q depth: %d\nCurrent # commands on controller: %d\nMax Q depth since init: %d\nMax # commands on controller since init: %d\nMax SG entries since init: %d\n",
             (char *)(& h->devname), h->product_name, (unsigned long )h->board_id,
             (int )h->firm_ver[0], (int )h->firm_ver[1], (int )h->firm_ver[2], (int )h->firm_ver[3],
             h->intr[h->intr_mode], h->num_luns, h->Qdepth, h->commands_outstanding,
             h->maxQsinceinit, h->max_outstanding, h->maxSG);
#line 460
  cciss_seq_tape_report(seq, h);
#line 461
  return;
}
}
#line 464 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void *cciss_seq_start(struct seq_file *seq , loff_t *pos ) 
{ 
  ctlr_info_t *h ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  void *tmp___0 ;

  {
#line 466
  h = (ctlr_info_t *)seq->private;
#line 472
  tmp = spinlock_check(& h->lock);
#line 472
  flags = _raw_spin_lock_irqsave(tmp);
#line 473
  if (h->busy_configuring != 0) {
#line 474
    spin_unlock_irqrestore(& h->lock, flags);
#line 475
    tmp___0 = ERR_PTR(-16L);
#line 475
    return (tmp___0);
  } else {

  }
#line 477
  h->busy_configuring = 1;
#line 478
  spin_unlock_irqrestore(& h->lock, flags);
#line 480
  if (*pos == 0LL) {
#line 481
    cciss_seq_show_header(seq);
  } else {

  }
#line 483
  return ((void *)pos);
}
}
#line 486 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_seq_show(struct seq_file *seq , void *v ) 
{ 
  sector_t vol_sz ;
  sector_t vol_sz_frac ;
  ctlr_info_t *h ;
  unsigned int ctlr ;
  loff_t *pos ;
  drive_info_struct *drv ;
  int _res ;
  int _res___0 ;

  {
#line 489
  h = (ctlr_info_t *)seq->private;
#line 490
  ctlr = (unsigned int )h->ctlr;
#line 491
  pos = (loff_t *)v;
#line 492
  drv = h->drv[*pos];
#line 494
  if (*pos > (loff_t )h->highest_lun) {
#line 495
    return (0);
  } else {

  }
#line 497
  if ((unsigned long )drv == (unsigned long )((drive_info_struct *)0)) {
#line 498
    return (0);
  } else {

  }
#line 500
  if (drv->heads == 0) {
#line 501
    return (0);
  } else {

  }
#line 503
  vol_sz = drv->nr_blocks;
#line 504
  _res = (int )(vol_sz % 1953125UL);
#line 504
  vol_sz = vol_sz / 1953125UL;
#line 504
  vol_sz_frac = (sector_t )_res;
#line 505
  vol_sz_frac = vol_sz_frac * 100UL;
#line 506
  _res___0 = (int )(vol_sz_frac % 1953125UL);
#line 506
  vol_sz_frac = vol_sz_frac / 1953125UL;
#line 508
  if (drv->raid_level < 0 || (unsigned int )drv->raid_level > 6U) {
#line 509
    drv->raid_level = 6;
  } else {

  }
#line 510
  seq_printf(seq, "cciss/c%dd%d:\t%4u.%02uGB\tRAID %s\n", ctlr, (int )*pos, (int )vol_sz,
             (int )vol_sz_frac, raid_label[drv->raid_level]);
#line 514
  return (0);
}
}
#line 517 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void *cciss_seq_next(struct seq_file *seq , void *v , loff_t *pos ) 
{ 
  ctlr_info_t *h ;

  {
#line 519
  h = (ctlr_info_t *)seq->private;
#line 521
  if (*pos > (loff_t )h->highest_lun) {
#line 522
    return (0);
  } else {

  }
#line 523
  *pos = *pos + 1LL;
#line 525
  return ((void *)pos);
}
}
#line 528 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_seq_stop(struct seq_file *seq , void *v ) 
{ 
  ctlr_info_t *h ;
  void *tmp ;

  {
#line 530
  h = (ctlr_info_t *)seq->private;
#line 534
  tmp = ERR_PTR(-16L);
#line 534
  if ((unsigned long )tmp == (unsigned long )v) {
#line 535
    return;
  } else {

  }
#line 537
  h->busy_configuring = 0;
#line 538
  return;
}
}
#line 540 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct seq_operations  const  cciss_seq_ops  =    {& cciss_seq_start, & cciss_seq_stop, & cciss_seq_next, & cciss_seq_show};
#line 547 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_seq_open(struct inode *inode , struct file *file ) 
{ 
  int ret ;
  int tmp ;
  struct seq_file *seq ;
  struct proc_dir_entry *tmp___0 ;

  {
#line 549
  tmp = seq_open(file, & cciss_seq_ops);
#line 549
  ret = tmp;
#line 550
  seq = (struct seq_file *)file->private_data;
#line 552
  if (ret == 0) {
#line 553
    tmp___0 = PDE((struct inode  const  *)inode);
#line 553
    seq->private = tmp___0->data;
  } else {

  }
#line 555
  return (ret);
}
}
#line 559 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t cciss_proc_write(struct file *file , char const   *buf , size_t length ,
                                loff_t *ppos ) 
{ 
  int err ;
  char *buffer ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  struct seq_file *seq ;
  ctlr_info_t *h ;
  int tmp___1 ;

  {
#line 569
  if ((unsigned long )buf == (unsigned long )((char const   *)0) || length > 4095UL) {
#line 570
    return (-22L);
  } else {

  }
#line 572
  tmp = __get_free_pages(208U, 0U);
#line 572
  buffer = (char *)tmp;
#line 573
  if ((unsigned long )buffer == (unsigned long )((char *)0)) {
#line 574
    return (-12L);
  } else {

  }
#line 576
  err = -14;
#line 577
  tmp___0 = copy_from_user((void *)buffer, (void const   *)buf, length);
#line 577
  if (tmp___0 != 0UL) {
#line 578
    goto out;
  } else {

  }
#line 579
  *(buffer + length) = 0;
#line 582
  tmp___1 = strncmp("engage scsi", (char const   *)buffer, 11UL);
#line 582
  if (tmp___1 == 0) {
#line 583
    seq = (struct seq_file *)file->private_data;
#line 584
    h = (ctlr_info_t *)seq->private;
#line 586
    err = cciss_engage_scsi(h);
#line 587
    if (err == 0) {
#line 588
      err = (int )length;
    } else {

    }
  } else {
#line 591
    err = -22;
  }
  out: 
#line 596
  free_pages((unsigned long )buffer, 0U);
#line 597
  return ((ssize_t )err);
}
}
#line 600 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct file_operations  const  cciss_proc_fops  = 
#line 600
     {& __this_module, & seq_lseek, & seq_read, & cciss_proc_write, 0, 0, 0, 0, 0, 0,
    0, & cciss_seq_open, 0, & seq_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 609 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_procinit(ctlr_info_t *h ) 
{ 
  struct proc_dir_entry *pde ;

  {
#line 613
  if ((unsigned long )proc_cciss == (unsigned long )((struct proc_dir_entry *)0)) {
#line 614
    proc_cciss = proc_mkdir("driver/cciss", 0);
  } else {

  }
#line 615
  if ((unsigned long )proc_cciss == (unsigned long )((struct proc_dir_entry *)0)) {
#line 616
    return;
  } else {

  }
#line 617
  pde = proc_create_data((char const   *)(& h->devname), 420, proc_cciss, & cciss_proc_fops,
                         (void *)h);
#line 620
  return;
}
}
#line 629 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static u32 unresettable_controller[14U]  = 
#line 629
  {      843714620U,      843780156U,      841158716U,      842272828U, 
        842338364U,      839979068U,      840044604U,      840110140U, 
        840175676U,      840241212U,      842469436U,      842862652U, 
        1083969041U,      1084034577U};
#line 647 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static u32 soft_unresettable_controller[2U]  = {      1083969041U,      1084034577U};
#line 652 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int ctlr_is_hard_resettable(u32 board_id ) 
{ 
  int i ;

  {
#line 656
  i = 0;
#line 656
  goto ldv_36481;
  ldv_36480: ;
#line 657
  if (unresettable_controller[i] == board_id) {
#line 658
    return (0);
  } else {

  }
#line 656
  i = i + 1;
  ldv_36481: ;
#line 656
  if ((unsigned int )i <= 13U) {
#line 657
    goto ldv_36480;
  } else {

  }

#line 659
  return (1);
}
}
#line 662 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int ctlr_is_soft_resettable(u32 board_id ) 
{ 
  int i ;

  {
#line 666
  i = 0;
#line 666
  goto ldv_36490;
  ldv_36489: ;
#line 667
  if (soft_unresettable_controller[i] == board_id) {
#line 668
    return (0);
  } else {

  }
#line 666
  i = i + 1;
  ldv_36490: ;
#line 666
  if ((unsigned int )i <= 1U) {
#line 667
    goto ldv_36489;
  } else {

  }

#line 669
  return (1);
}
}
#line 672 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int ctlr_is_resettable(u32 board_id ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 674
  tmp = ctlr_is_hard_resettable(board_id);
#line 674
  if (tmp != 0) {
#line 674
    tmp___1 = 1;
  } else {
#line 674
    tmp___0 = ctlr_is_soft_resettable(board_id);
#line 674
    if (tmp___0 != 0) {
#line 674
      tmp___1 = 1;
    } else {
#line 674
      tmp___1 = 0;
    }
  }
#line 674
  return (tmp___1);
}
}
#line 678 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t host_show_resettable(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ 
  struct ctlr_info *h ;
  struct device  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 682
  __mptr = (struct device  const  *)dev;
#line 682
  h = (struct ctlr_info *)__mptr + 0xffffffffffffbd38UL;
#line 684
  tmp = ctlr_is_resettable(h->board_id);
#line 684
  tmp___0 = snprintf(buf, 20UL, "%d\n", tmp);
#line 684
  return ((ssize_t )tmp___0);
}
}
#line 686 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_resettable  =    {{"resettable", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & host_show_resettable, 0};
#line 688 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t host_store_rescan(struct device *dev , struct device_attribute *attr ,
                                 char const   *buf , size_t count ) 
{ 
  struct ctlr_info *h ;
  struct device  const  *__mptr ;

  {
#line 692
  __mptr = (struct device  const  *)dev;
#line 692
  h = (struct ctlr_info *)__mptr + 0xffffffffffffbd38UL;
#line 694
  add_to_scan_list(h);
#line 695
  wake_up_process(cciss_scan_thread);
#line 696
  wait_for_completion_interruptible(& h->scan_wait);
#line 698
  return ((ssize_t )count);
}
}
#line 700 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_rescan  =    {{"rescan", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, 0, & host_store_rescan};
#line 702 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t host_show_transport_mode(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ 
  struct ctlr_info *h ;
  struct device  const  *__mptr ;
  int tmp ;

  {
#line 706
  __mptr = (struct device  const  *)dev;
#line 706
  h = (struct ctlr_info *)__mptr + 0xffffffffffffbd38UL;
#line 708
  tmp = snprintf(buf, 20UL, "%s\n", (h->transMethod & 4UL) != 0UL ? (char *)"performant" : (char *)"simple");
#line 708
  return ((ssize_t )tmp);
}
}
#line 712 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_transport_mode  =    {{"transport_mode", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & host_show_transport_mode, 0};
#line 714 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t dev_show_unique_id(struct device *dev , struct device_attribute *attr ,
                                  char *buf ) 
{ 
  drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  __u8 sn[16U] ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 718
  __mptr = (struct device  const  *)dev;
#line 718
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 719
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 719
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 722
  ret = 0;
#line 724
  tmp = spinlock_check(& h->lock);
#line 724
  flags = _raw_spin_lock_irqsave(tmp);
#line 725
  if (h->busy_configuring != 0) {
#line 726
    ret = -16;
  } else {
#line 728
    __len = 16UL;
#line 728
    if (__len > 63UL) {
#line 728
      __ret = __memcpy((void *)(& sn), (void const   *)(& drv->serial_no), __len);
    } else {
#line 728
      __ret = __builtin_memcpy((void *)(& sn), (void const   *)(& drv->serial_no),
                               __len);
    }
  }
#line 729
  spin_unlock_irqrestore(& h->lock, flags);
#line 731
  if (ret != 0) {
#line 732
    return ((ssize_t )ret);
  } else {
#line 734
    tmp___0 = snprintf(buf, 34UL, "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n",
                       (int )sn[0], (int )sn[1], (int )sn[2], (int )sn[3], (int )sn[4],
                       (int )sn[5], (int )sn[6], (int )sn[7], (int )sn[8], (int )sn[9],
                       (int )sn[10], (int )sn[11], (int )sn[12], (int )sn[13], (int )sn[14],
                       (int )sn[15]);
#line 734
    return ((ssize_t )tmp___0);
  }
}
}
#line 742 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_unique_id  =    {{"unique_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & dev_show_unique_id, 0};
#line 744 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t dev_show_vendor(struct device *dev , struct device_attribute *attr ,
                               char *buf ) 
{ 
  drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  char vendor[9U] ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 748
  __mptr = (struct device  const  *)dev;
#line 748
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 749
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 749
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 752
  ret = 0;
#line 754
  tmp = spinlock_check(& h->lock);
#line 754
  flags = _raw_spin_lock_irqsave(tmp);
#line 755
  if (h->busy_configuring != 0) {
#line 756
    ret = -16;
  } else {
#line 758
    __len = 9UL;
#line 758
    if (__len > 63UL) {
#line 758
      __ret = __memcpy((void *)(& vendor), (void const   *)(& drv->vendor), __len);
    } else {
#line 758
      __ret = __builtin_memcpy((void *)(& vendor), (void const   *)(& drv->vendor),
                               __len);
    }
  }
#line 759
  spin_unlock_irqrestore(& h->lock, flags);
#line 761
  if (ret != 0) {
#line 762
    return ((ssize_t )ret);
  } else {
#line 764
    tmp___0 = snprintf(buf, 10UL, "%s\n", (char *)(& drv->vendor));
#line 764
    return ((ssize_t )tmp___0);
  }
}
}
#line 766 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_vendor  =    {{"vendor", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & dev_show_vendor,
    0};
#line 768 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t dev_show_model(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ 
  drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  char model[17U] ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 772
  __mptr = (struct device  const  *)dev;
#line 772
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 773
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 773
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 776
  ret = 0;
#line 778
  tmp = spinlock_check(& h->lock);
#line 778
  flags = _raw_spin_lock_irqsave(tmp);
#line 779
  if (h->busy_configuring != 0) {
#line 780
    ret = -16;
  } else {
#line 782
    __len = 17UL;
#line 782
    if (__len > 63UL) {
#line 782
      __ret = __memcpy((void *)(& model), (void const   *)(& drv->model), __len);
    } else {
#line 782
      __ret = __builtin_memcpy((void *)(& model), (void const   *)(& drv->model),
                               __len);
    }
  }
#line 783
  spin_unlock_irqrestore(& h->lock, flags);
#line 785
  if (ret != 0) {
#line 786
    return ((ssize_t )ret);
  } else {
#line 788
    tmp___0 = snprintf(buf, 18UL, "%s\n", (char *)(& drv->model));
#line 788
    return ((ssize_t )tmp___0);
  }
}
}
#line 790 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_model  =    {{"model", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, & dev_show_model,
    0};
#line 792 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t dev_show_rev(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  char rev[5U] ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 796
  __mptr = (struct device  const  *)dev;
#line 796
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 797
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 797
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 800
  ret = 0;
#line 802
  tmp = spinlock_check(& h->lock);
#line 802
  flags = _raw_spin_lock_irqsave(tmp);
#line 803
  if (h->busy_configuring != 0) {
#line 804
    ret = -16;
  } else {
#line 806
    __len = 5UL;
#line 806
    if (__len > 63UL) {
#line 806
      __ret = __memcpy((void *)(& rev), (void const   *)(& drv->rev), __len);
    } else {
#line 806
      __ret = __builtin_memcpy((void *)(& rev), (void const   *)(& drv->rev), __len);
    }
  }
#line 807
  spin_unlock_irqrestore(& h->lock, flags);
#line 809
  if (ret != 0) {
#line 810
    return ((ssize_t )ret);
  } else {
#line 812
    tmp___0 = snprintf(buf, 6UL, "%s\n", (char *)(& drv->rev));
#line 812
    return ((ssize_t )tmp___0);
  }
}
}
#line 814 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_rev  =    {{"rev", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, & dev_show_rev,
    0};
#line 816 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t cciss_show_lunid(struct device *dev , struct device_attribute *attr ,
                                char *buf ) 
{ 
  drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  unsigned long flags ;
  unsigned char lunid[8U] ;
  raw_spinlock_t *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 819
  __mptr = (struct device  const  *)dev;
#line 819
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 820
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 820
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 824
  tmp = spinlock_check(& h->lock);
#line 824
  flags = _raw_spin_lock_irqsave(tmp);
#line 825
  if (h->busy_configuring != 0) {
#line 826
    spin_unlock_irqrestore(& h->lock, flags);
#line 827
    return (-16L);
  } else {

  }
#line 829
  if (drv->heads == 0) {
#line 830
    spin_unlock_irqrestore(& h->lock, flags);
#line 831
    return (-25L);
  } else {

  }
#line 833
  __len = 8UL;
#line 833
  if (__len > 63UL) {
#line 833
    __ret = __memcpy((void *)(& lunid), (void const   *)(& drv->LunID), __len);
  } else {
#line 833
    __ret = __builtin_memcpy((void *)(& lunid), (void const   *)(& drv->LunID), __len);
  }
#line 834
  spin_unlock_irqrestore(& h->lock, flags);
#line 835
  tmp___0 = snprintf(buf, 20UL, "0x%02x%02x%02x%02x%02x%02x%02x%02x\n", (int )lunid[0],
                     (int )lunid[1], (int )lunid[2], (int )lunid[3], (int )lunid[4],
                     (int )lunid[5], (int )lunid[6], (int )lunid[7]);
#line 835
  return ((ssize_t )tmp___0);
}
}
#line 839 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_lunid  =    {{"lunid", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, & cciss_show_lunid,
    0};
#line 841 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t cciss_show_raid_level(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  int raid ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 844
  __mptr = (struct device  const  *)dev;
#line 844
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 845
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 845
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 849
  tmp = spinlock_check(& h->lock);
#line 849
  flags = _raw_spin_lock_irqsave(tmp);
#line 850
  if (h->busy_configuring != 0) {
#line 851
    spin_unlock_irqrestore(& h->lock, flags);
#line 852
    return (-16L);
  } else {

  }
#line 854
  raid = drv->raid_level;
#line 855
  spin_unlock_irqrestore(& h->lock, flags);
#line 856
  if (raid < 0 || (unsigned int )raid > 6U) {
#line 857
    raid = 6;
  } else {

  }
#line 859
  tmp___0 = strlen(raid_label[raid]);
#line 859
  tmp___1 = snprintf(buf, tmp___0 + 7UL, "RAID %s\n", raid_label[raid]);
#line 859
  return ((ssize_t )tmp___1);
}
}
#line 862 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_raid_level  =    {{"raid_level", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                        {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & cciss_show_raid_level, 0};
#line 864 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static ssize_t cciss_show_usage_count(struct device *dev , struct device_attribute *attr ,
                                      char *buf ) 
{ 
  drive_info_struct *drv ;
  struct device  const  *__mptr ;
  struct ctlr_info *h ;
  struct device  const  *__mptr___0 ;
  unsigned long flags ;
  int count ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
#line 867
  __mptr = (struct device  const  *)dev;
#line 867
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 868
  __mptr___0 = (struct device  const  *)drv->dev.parent;
#line 868
  h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbd38UL;
#line 872
  tmp = spinlock_check(& h->lock);
#line 872
  flags = _raw_spin_lock_irqsave(tmp);
#line 873
  if (h->busy_configuring != 0) {
#line 874
    spin_unlock_irqrestore(& h->lock, flags);
#line 875
    return (-16L);
  } else {

  }
#line 877
  count = drv->usage_count;
#line 878
  spin_unlock_irqrestore(& h->lock, flags);
#line 879
  tmp___0 = snprintf(buf, 20UL, "%d\n", count);
#line 879
  return ((ssize_t )tmp___0);
}
}
#line 881 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_attribute dev_attr_usage_count  =    {{"usage_count", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & cciss_show_usage_count, 0};
#line 883 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute *cciss_host_attrs[4U]  = {      & dev_attr_rescan.attr,      & dev_attr_resettable.attr,      & dev_attr_transport_mode.attr,      0};
#line 890 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute_group cciss_host_attr_group  =    {0, 0, (struct attribute **)(& cciss_host_attrs)};
#line 894 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute_group  const  *cciss_host_attr_groups[2U]  = {      (struct attribute_group  const  *)(& cciss_host_attr_group),      0};
#line 899 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_type cciss_host_type  =    {"cciss_host", (struct attribute_group  const  **)(& cciss_host_attr_groups), 0,
    0, & cciss_hba_release, 0};
#line 905 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute *cciss_dev_attrs[8U]  = 
#line 905
  {      & dev_attr_unique_id.attr,      & dev_attr_model.attr,      & dev_attr_vendor.attr,      & dev_attr_rev.attr, 
        & dev_attr_lunid.attr,      & dev_attr_raid_level.attr,      & dev_attr_usage_count.attr,      0};
#line 916 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute_group cciss_dev_attr_group  =    {0, 0, (struct attribute **)(& cciss_dev_attrs)};
#line 920 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct attribute_group  const  *cciss_dev_attr_groups[2U]  = {      (struct attribute_group  const  *)(& cciss_dev_attr_group),      0};
#line 925 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct device_type cciss_dev_type  =    {"cciss_device", (struct attribute_group  const  **)(& cciss_dev_attr_groups),
    0, 0, & cciss_device_release, 0};
#line 931 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct bus_type cciss_bus_type  = 
#line 931
     {"cciss", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 939 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_hba_release(struct device *dev ) 
{ 


  {
#line 941
  return;
}
}
#line 952 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_create_hba_sysfs_entry(struct ctlr_info *h ) 
{ 
  int tmp ;

  {
#line 954
  device_initialize(& h->dev);
#line 955
  h->dev.type = (struct device_type  const  *)(& cciss_host_type);
#line 956
  h->dev.bus = & cciss_bus_type;
#line 957
  dev_set_name(& h->dev, "%s", (char *)(& h->devname));
#line 958
  h->dev.parent = & (h->pdev)->dev;
#line 960
  tmp = device_add(& h->dev);
#line 960
  return (tmp);
}
}
#line 966 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_destroy_hba_sysfs_entry(struct ctlr_info *h ) 
{ 


  {
#line 968
  device_del(& h->dev);
#line 969
  put_device(& h->dev);
#line 970
  return;
}
}
#line 975 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_device_release(struct device *dev ) 
{ 
  drive_info_struct *drv ;
  struct device  const  *__mptr ;

  {
#line 977
  __mptr = (struct device  const  *)dev;
#line 977
  drv = (drive_info_struct *)__mptr + 0xffffffffffffffc8UL;
#line 978
  kfree((void const   *)drv);
#line 979
  return;
}
}
#line 987 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static long cciss_create_ld_sysfs_entry(struct ctlr_info *h , int drv_index ) 
{ 
  struct device *dev ;
  int tmp ;

  {
#line 992
  if ((int )((signed char )(h->drv[drv_index])->device_initialized) != 0) {
#line 993
    return (0L);
  } else {

  }
#line 995
  dev = & (h->drv[drv_index])->dev;
#line 996
  device_initialize(dev);
#line 997
  dev->type = (struct device_type  const  *)(& cciss_dev_type);
#line 998
  dev->bus = & cciss_bus_type;
#line 999
  dev_set_name(dev, "c%dd%d", h->ctlr, drv_index);
#line 1000
  dev->parent = & h->dev;
#line 1001
  (h->drv[drv_index])->device_initialized = 1;
#line 1002
  tmp = device_add(dev);
#line 1002
  return ((long )tmp);
}
}
#line 1008 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_destroy_ld_sysfs_entry(struct ctlr_info *h , int drv_index , int ctlr_exiting ) 
{ 
  struct device *dev ;

  {
#line 1011
  dev = & (h->drv[drv_index])->dev;
#line 1014
  if (drv_index == 0 && ctlr_exiting == 0) {
#line 1015
    return;
  } else {

  }
#line 1017
  device_del(dev);
#line 1018
  put_device(dev);
#line 1019
  h->drv[drv_index] = 0;
#line 1020
  return;
}
}
#line 1027 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static CommandList_struct *cmd_alloc(ctlr_info_t *h ) 
{ 
  CommandList_struct *c ;
  int i ;
  u64bit temp64 ;
  dma_addr_t cmd_dma_handle ;
  dma_addr_t err_dma_handle ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  ldv_36708: 
#line 1035
  tmp = find_first_zero_bit((unsigned long const   *)h->cmd_pool_bits, (unsigned long )h->nr_cmds);
#line 1035
  i = (int )tmp;
#line 1036
  if (h->nr_cmds == i) {
#line 1037
    return (0);
  } else {

  }
#line 1038
  tmp___0 = test_and_set_bit(i, (unsigned long volatile   *)h->cmd_pool_bits);
#line 1038
  if (tmp___0 != 0) {
#line 1039
    goto ldv_36708;
  } else {

  }
#line 1039
  c = h->cmd_pool + (unsigned long )i;
#line 1040
  memset((void *)c, 0, 640UL);
#line 1041
  cmd_dma_handle = h->cmd_pool_dhandle + (unsigned long long )((unsigned long )i * 640UL);
#line 1042
  c->err_info = h->errinfo_pool + (unsigned long )i;
#line 1043
  memset((void *)c->err_info, 0, 48UL);
#line 1044
  err_dma_handle = h->errinfo_pool_dhandle + (unsigned long long )((unsigned long )i * 48UL);
#line 1046
  h->nr_allocs = h->nr_allocs + 1;
#line 1048
  c->cmdindex = (long )i;
#line 1050
  INIT_LIST_HEAD(& c->list);
#line 1051
  c->busaddr = (unsigned int )cmd_dma_handle;
#line 1052
  temp64.val = err_dma_handle;
#line 1053
  c->ErrDesc.Addr.lower = temp64.val32.lower;
#line 1054
  c->ErrDesc.Addr.upper = temp64.val32.upper;
#line 1055
  c->ErrDesc.Len = 48U;
#line 1057
  c->ctlr = h->ctlr;
#line 1058
  return (c);
}
}
#line 1064 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static CommandList_struct *cmd_special_alloc(ctlr_info_t *h ) 
{ 
  CommandList_struct *c ;
  u64bit temp64 ;
  dma_addr_t cmd_dma_handle ;
  dma_addr_t err_dma_handle ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1070
  tmp = pci_alloc_consistent(h->pdev, 640UL, & cmd_dma_handle);
#line 1070
  c = (CommandList_struct *)tmp;
#line 1072
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1073
    return (0);
  } else {

  }
#line 1074
  memset((void *)c, 0, 640UL);
#line 1076
  c->cmdindex = -1L;
#line 1078
  tmp___0 = pci_alloc_consistent(h->pdev, 48UL, & err_dma_handle);
#line 1078
  c->err_info = (ErrorInfo_struct *)tmp___0;
#line 1082
  if ((unsigned long )c->err_info == (unsigned long )((ErrorInfo_struct *)0)) {
#line 1083
    pci_free_consistent(h->pdev, 640UL, (void *)c, cmd_dma_handle);
#line 1085
    return (0);
  } else {

  }
#line 1087
  memset((void *)c->err_info, 0, 48UL);
#line 1089
  INIT_LIST_HEAD(& c->list);
#line 1090
  c->busaddr = (unsigned int )cmd_dma_handle;
#line 1091
  temp64.val = err_dma_handle;
#line 1092
  c->ErrDesc.Addr.lower = temp64.val32.lower;
#line 1093
  c->ErrDesc.Addr.upper = temp64.val32.upper;
#line 1094
  c->ErrDesc.Len = 48U;
#line 1096
  c->ctlr = h->ctlr;
#line 1097
  return (c);
}
}
#line 1100 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cmd_free(ctlr_info_t *h , CommandList_struct *c ) 
{ 
  int i ;

  {
#line 1104
  i = (int )(((long )c - (long )h->cmd_pool) / 640L);
#line 1105
  clear_bit(i, (unsigned long volatile   *)h->cmd_pool_bits);
#line 1106
  h->nr_frees = h->nr_frees + 1;
#line 1107
  return;
}
}
#line 1109 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cmd_special_free(ctlr_info_t *h , CommandList_struct *c ) 
{ 
  u64bit temp64 ;
  u32 tmp ;

  {
#line 1113
  temp64.val32.lower = c->ErrDesc.Addr.lower;
#line 1114
  temp64.val32.upper = c->ErrDesc.Addr.upper;
#line 1115
  pci_free_consistent(h->pdev, 48UL, (void *)c->err_info, temp64.val);
#line 1117
  tmp = cciss_tag_discard_error_bits(h, c->busaddr);
#line 1117
  pci_free_consistent(h->pdev, 640UL, (void *)c, (unsigned long long )tmp);
#line 1119
  return;
}
}
#line 1121 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static ctlr_info_t *get_host(struct gendisk *disk ) 
{ 


  {
#line 1123
  return ((ctlr_info_t *)(disk->queue)->queuedata);
}
}
#line 1126 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static drive_info_struct *get_drv(struct gendisk *disk ) 
{ 


  {
#line 1128
  return ((drive_info_struct *)disk->private_data);
}
}
#line 1134 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_open(struct block_device *bdev , fmode_t mode ) 
{ 
  ctlr_info_t *h ;
  ctlr_info_t *tmp ;
  drive_info_struct *drv ;
  drive_info_struct *tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
#line 1136
  tmp = get_host(bdev->bd_disk);
#line 1136
  h = tmp;
#line 1137
  tmp___0 = get_drv(bdev->bd_disk);
#line 1137
  drv = tmp___0;
#line 1139
  descriptor.modname = "cciss";
#line 1139
  descriptor.function = "cciss_open";
#line 1139
  descriptor.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 1139
  descriptor.format = "cciss_open %s\n";
#line 1139
  descriptor.lineno = 1139U;
#line 1139
  descriptor.flags = 0U;
#line 1139
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1139
  if (tmp___1 != 0L) {
#line 1139
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "cciss_open %s\n",
                      (char *)(& (bdev->bd_disk)->disk_name));
  } else {

  }
#line 1140
  if (drv->busy_configuring != 0) {
#line 1141
    return (-16);
  } else {

  }
#line 1150
  if (drv->heads == 0) {
#line 1151
    if ((bdev->bd_dev & 1048575U) != 0U) {
#line 1153
      if ((bdev->bd_dev & 15U) != 0U) {
#line 1154
        return (-6);
      } else {
#line 1156
        tmp___2 = memcmp((void const   *)(& drv->LunID), (void const   *)"", 8UL);
#line 1156
        if (tmp___2 != 0) {
#line 1158
          return (-6);
        } else {

        }
      }
    } else {

    }
#line 1161
    tmp___3 = capable(21);
#line 1161
    if (tmp___3) {
#line 1161
      tmp___4 = 0;
    } else {
#line 1161
      tmp___4 = 1;
    }
#line 1161
    if (tmp___4) {
#line 1162
      return (-1);
    } else {

    }
  } else {

  }
#line 1164
  drv->usage_count = drv->usage_count + 1;
#line 1165
  h->usage_count = h->usage_count + 1;
#line 1166
  return (0);
}
}
#line 1169 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_unlocked_open(struct block_device *bdev , fmode_t mode ) 
{ 
  int ret ;

  {
#line 1173
  ldv_mutex_lock_8(& cciss_mutex);
#line 1174
  ret = cciss_open(bdev, mode);
#line 1175
  ldv_mutex_unlock_9(& cciss_mutex);
#line 1177
  return (ret);
}
}
#line 1183 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_release(struct gendisk *disk , fmode_t mode ) 
{ 
  ctlr_info_t *h ;
  drive_info_struct *drv ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1188
  ldv_mutex_lock_10(& cciss_mutex);
#line 1189
  h = get_host(disk);
#line 1190
  drv = get_drv(disk);
#line 1191
  descriptor.modname = "cciss";
#line 1191
  descriptor.function = "cciss_release";
#line 1191
  descriptor.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 1191
  descriptor.format = "cciss_release %s\n";
#line 1191
  descriptor.lineno = 1191U;
#line 1191
  descriptor.flags = 0U;
#line 1191
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1191
  if (tmp != 0L) {
#line 1191
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "cciss_release %s\n",
                      (char *)(& disk->disk_name));
  } else {

  }
#line 1192
  drv->usage_count = drv->usage_count - 1;
#line 1193
  h->usage_count = h->usage_count - 1;
#line 1194
  ldv_mutex_unlock_11(& cciss_mutex);
#line 1195
  return (0);
}
}
#line 1198 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int do_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                    unsigned long arg ) 
{ 
  int ret ;

  {
#line 1202
  ldv_mutex_lock_12(& cciss_mutex);
#line 1203
  ret = cciss_ioctl(bdev, mode, cmd, arg);
#line 1204
  ldv_mutex_unlock_13(& cciss_mutex);
#line 1205
  return (ret);
}
}
#line 1210
static int cciss_ioctl32_passthru(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                                  unsigned long arg ) ;
#line 1212
static int cciss_ioctl32_big_passthru(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                                      unsigned long arg ) ;
#line 1215 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_compat_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                              unsigned long arg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1218
  switch (cmd) {
  case 2148024833U: ;
  case 2148024834U: ;
  case 1074283011U: ;
  case 2148549124U: ;
  case 1074807301U: ;
  case 2147762694U: ;
  case 2147762695U: ;
  case 2147762696U: ;
  case 2147762697U: ;
  case 16906U: ;
  case 16908U: ;
  case 1074020877U: ;
  case 16910U: ;
  case 16912U: ;
  case 2148286993U: 
#line 1234
  tmp = do_ioctl(bdev, mode, cmd, arg);
#line 1234
  return (tmp);
  case 3226747403U: 
#line 1237
  tmp___0 = cciss_ioctl32_passthru(bdev, mode, cmd, arg);
#line 1237
  return (tmp___0);
  case 3227009554U: 
#line 1239
  tmp___1 = cciss_ioctl32_big_passthru(bdev, mode, cmd, arg);
#line 1239
  return (tmp___1);
  default: ;
#line 1242
  return (-515);
  }
}
}
#line 1246 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_ioctl32_passthru(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                                  unsigned long arg ) 
{ 
  IOCTL32_Command_struct *arg32 ;
  IOCTL_Command_struct arg64 ;
  IOCTL_Command_struct *p ;
  void *tmp ;
  int err ;
  u32 cp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int __ret_gu ;
  unsigned long __val_gu ;
  int __ret_gu___0 ;
  unsigned long __val_gu___0 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 1249
  arg32 = (IOCTL32_Command_struct *)arg;
#line 1252
  tmp = compat_alloc_user_space(88UL);
#line 1252
  p = (IOCTL_Command_struct *)tmp;
#line 1256
  err = 0;
#line 1257
  tmp___0 = copy_from_user((void *)(& arg64.LUN_info), (void const   *)(& arg32->LUN_info),
                           8UL);
#line 1257
  err = (int )((unsigned int )tmp___0 | (unsigned int )err);
#line 1260
  tmp___1 = copy_from_user((void *)(& arg64.Request), (void const   *)(& arg32->Request),
                           20UL);
#line 1260
  err = (int )((unsigned int )tmp___1 | (unsigned int )err);
#line 1263
  tmp___2 = copy_from_user((void *)(& arg64.error_info), (void const   *)(& arg32->error_info),
                           48UL);
#line 1263
  err = (int )((unsigned int )tmp___2 | (unsigned int )err);
#line 1266
  might_fault();
#line 1266
  switch (2UL) {
  case 1UL: 
#line 1266
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1266
  goto ldv_36809;
  case 2UL: 
#line 1266
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1266
  goto ldv_36809;
  case 4UL: 
#line 1266
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1266
  goto ldv_36809;
  case 8UL: 
#line 1266
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1266
  goto ldv_36809;
  default: 
#line 1266
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1266
  goto ldv_36809;
  }
  ldv_36809: 
#line 1266
  arg64.buf_size = (unsigned short )__val_gu;
#line 1266
  err = __ret_gu | err;
#line 1267
  might_fault();
#line 1267
  switch (4UL) {
  case 1UL: 
#line 1267
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1267
  goto ldv_36818;
  case 2UL: 
#line 1267
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1267
  goto ldv_36818;
  case 4UL: 
#line 1267
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1267
  goto ldv_36818;
  case 8UL: 
#line 1267
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1267
  goto ldv_36818;
  default: 
#line 1267
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->buf));
#line 1267
  goto ldv_36818;
  }
  ldv_36818: 
#line 1267
  cp = (unsigned int )__val_gu___0;
#line 1267
  err = __ret_gu___0 | err;
#line 1268
  tmp___3 = compat_ptr(cp);
#line 1268
  arg64.buf = (__u8 *)tmp___3;
#line 1269
  tmp___4 = copy_to_user((void *)p, (void const   *)(& arg64), 88U);
#line 1269
  err = tmp___4 | err;
#line 1271
  if (err != 0) {
#line 1272
    return (-14);
  } else {

  }
#line 1274
  err = do_ioctl(bdev, mode, 3227009547U, (unsigned long )p);
#line 1275
  if (err != 0) {
#line 1276
    return (err);
  } else {

  }
#line 1277
  tmp___5 = copy_in_user((void *)(& arg32->error_info), (void const   *)(& p->error_info),
                         48U);
#line 1277
  err = (int )((unsigned int )tmp___5 | (unsigned int )err);
#line 1280
  if (err != 0) {
#line 1281
    return (-14);
  } else {

  }
#line 1282
  return (err);
}
}
#line 1285 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_ioctl32_big_passthru(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                                      unsigned long arg ) 
{ 
  BIG_IOCTL32_Command_struct *arg32 ;
  BIG_IOCTL_Command_struct arg64 ;
  BIG_IOCTL_Command_struct *p ;
  void *tmp ;
  int err ;
  u32 cp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int __ret_gu ;
  unsigned long __val_gu ;
  int __ret_gu___0 ;
  unsigned long __val_gu___0 ;
  int __ret_gu___1 ;
  unsigned long __val_gu___1 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 1288
  arg32 = (BIG_IOCTL32_Command_struct *)arg;
#line 1291
  tmp = compat_alloc_user_space(96UL);
#line 1291
  p = (BIG_IOCTL_Command_struct *)tmp;
#line 1296
  memset((void *)(& arg64), 0, 96UL);
#line 1297
  err = 0;
#line 1298
  tmp___0 = copy_from_user((void *)(& arg64.LUN_info), (void const   *)(& arg32->LUN_info),
                           8UL);
#line 1298
  err = (int )((unsigned int )tmp___0 | (unsigned int )err);
#line 1301
  tmp___1 = copy_from_user((void *)(& arg64.Request), (void const   *)(& arg32->Request),
                           20UL);
#line 1301
  err = (int )((unsigned int )tmp___1 | (unsigned int )err);
#line 1304
  tmp___2 = copy_from_user((void *)(& arg64.error_info), (void const   *)(& arg32->error_info),
                           48UL);
#line 1304
  err = (int )((unsigned int )tmp___2 | (unsigned int )err);
#line 1307
  might_fault();
#line 1307
  switch (4UL) {
  case 1UL: 
#line 1307
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1307
  goto ldv_36838;
  case 2UL: 
#line 1307
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1307
  goto ldv_36838;
  case 4UL: 
#line 1307
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1307
  goto ldv_36838;
  case 8UL: 
#line 1307
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1307
  goto ldv_36838;
  default: 
#line 1307
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu), "=d" (__val_gu): "0" (& arg32->buf_size));
#line 1307
  goto ldv_36838;
  }
  ldv_36838: 
#line 1307
  arg64.buf_size = (unsigned int )__val_gu;
#line 1307
  err = __ret_gu | err;
#line 1308
  might_fault();
#line 1308
  switch (4UL) {
  case 1UL: 
#line 1308
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1308
  goto ldv_36847;
  case 2UL: 
#line 1308
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1308
  goto ldv_36847;
  case 4UL: 
#line 1308
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1308
  goto ldv_36847;
  case 8UL: 
#line 1308
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1308
  goto ldv_36847;
  default: 
#line 1308
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___0), "=d" (__val_gu___0): "0" (& arg32->malloc_size));
#line 1308
  goto ldv_36847;
  }
  ldv_36847: 
#line 1308
  arg64.malloc_size = (unsigned int )__val_gu___0;
#line 1308
  err = __ret_gu___0 | err;
#line 1309
  might_fault();
#line 1309
  switch (4UL) {
  case 1UL: 
#line 1309
  __asm__  volatile   ("call __get_user_1": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1309
  goto ldv_36856;
  case 2UL: 
#line 1309
  __asm__  volatile   ("call __get_user_2": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1309
  goto ldv_36856;
  case 4UL: 
#line 1309
  __asm__  volatile   ("call __get_user_4": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1309
  goto ldv_36856;
  case 8UL: 
#line 1309
  __asm__  volatile   ("call __get_user_8": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1309
  goto ldv_36856;
  default: 
#line 1309
  __asm__  volatile   ("call __get_user_X": "=a" (__ret_gu___1), "=d" (__val_gu___1): "0" (& arg32->buf));
#line 1309
  goto ldv_36856;
  }
  ldv_36856: 
#line 1309
  cp = (unsigned int )__val_gu___1;
#line 1309
  err = __ret_gu___1 | err;
#line 1310
  tmp___3 = compat_ptr(cp);
#line 1310
  arg64.buf = (__u8 *)tmp___3;
#line 1311
  tmp___4 = copy_to_user((void *)p, (void const   *)(& arg64), 96U);
#line 1311
  err = tmp___4 | err;
#line 1313
  if (err != 0) {
#line 1314
    return (-14);
  } else {

  }
#line 1316
  err = do_ioctl(bdev, mode, 3227533842U, (unsigned long )p);
#line 1317
  if (err != 0) {
#line 1318
    return (err);
  } else {

  }
#line 1319
  tmp___5 = copy_in_user((void *)(& arg32->error_info), (void const   *)(& p->error_info),
                         48U);
#line 1319
  err = (int )((unsigned int )tmp___5 | (unsigned int )err);
#line 1322
  if (err != 0) {
#line 1323
    return (-14);
  } else {

  }
#line 1324
  return (err);
}
}
#line 1328 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getgeo(struct block_device *bdev , struct hd_geometry *geo ) 
{ 
  drive_info_struct *drv ;
  drive_info_struct *tmp ;

  {
#line 1330
  tmp = get_drv(bdev->bd_disk);
#line 1330
  drv = tmp;
#line 1332
  if (drv->cylinders == 0) {
#line 1333
    return (-6);
  } else {

  }
#line 1335
  geo->heads = (unsigned char )drv->heads;
#line 1336
  geo->sectors = (unsigned char )drv->sectors;
#line 1337
  geo->cylinders = (unsigned short )drv->cylinders;
#line 1338
  return (0);
}
}
#line 1341 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void check_ioctl_unit_attention(ctlr_info_t *h , CommandList_struct *c ) 
{ 


  {
#line 1343
  if ((unsigned int )(c->err_info)->CommandStatus == 1U && (unsigned int )(c->err_info)->ScsiStatus != 2U) {
#line 1345
    check_for_unit_attention(h, c);
  } else {

  }
#line 1346
  return;
}
}
#line 1348 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getpciinfo(ctlr_info_t *h , void *argp ) 
{ 
  cciss_pci_info_struct pciinfo ;
  int tmp ;
  int tmp___0 ;

  {
#line 1352
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1353
    return (-22);
  } else {

  }
#line 1354
  tmp = pci_domain_nr((h->pdev)->bus);
#line 1354
  pciinfo.domain = (unsigned short )tmp;
#line 1355
  pciinfo.bus = ((h->pdev)->bus)->number;
#line 1356
  pciinfo.dev_fn = (unsigned char )(h->pdev)->devfn;
#line 1357
  pciinfo.board_id = h->board_id;
#line 1358
  tmp___0 = copy_to_user(argp, (void const   *)(& pciinfo), 8U);
#line 1358
  if (tmp___0 != 0) {
#line 1359
    return (-14);
  } else {

  }
#line 1360
  return (0);
}
}
#line 1363 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getintinfo(ctlr_info_t *h , void *argp ) 
{ 
  cciss_coalint_struct intinfo ;
  int tmp ;

  {
#line 1367
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1368
    return (-22);
  } else {

  }
#line 1369
  intinfo.delay = readl((void const volatile   *)(& (h->cfgtable)->HostWrite.CoalIntDelay));
#line 1370
  intinfo.count = readl((void const volatile   *)(& (h->cfgtable)->HostWrite.CoalIntCount));
#line 1371
  tmp = copy_to_user(argp, (void const   *)(& intinfo), 8U);
#line 1371
  if (tmp != 0) {
#line 1373
    return (-14);
  } else {

  }
#line 1374
  return (0);
}
}
#line 1377 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_setintinfo(ctlr_info_t *h , void *argp ) 
{ 
  cciss_coalint_struct intinfo ;
  unsigned long flags ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1383
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1384
    return (-22);
  } else {

  }
#line 1385
  tmp = capable(21);
#line 1385
  if (tmp) {
#line 1385
    tmp___0 = 0;
  } else {
#line 1385
    tmp___0 = 1;
  }
#line 1385
  if (tmp___0) {
#line 1386
    return (-1);
  } else {

  }
#line 1387
  tmp___1 = copy_from_user((void *)(& intinfo), (void const   *)argp, 8UL);
#line 1387
  if (tmp___1 != 0UL) {
#line 1388
    return (-14);
  } else {

  }
#line 1389
  if (intinfo.delay == 0U && intinfo.count == 0U) {
#line 1390
    return (-22);
  } else {

  }
#line 1391
  tmp___2 = spinlock_check(& h->lock);
#line 1391
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 1393
  writel(intinfo.delay, (void volatile   *)(& (h->cfgtable)->HostWrite.CoalIntDelay));
#line 1394
  writel(intinfo.count, (void volatile   *)(& (h->cfgtable)->HostWrite.CoalIntCount));
#line 1395
  writel(1U, (void volatile   *)h->vaddr + 32U);
#line 1397
  i = 0;
#line 1397
  goto ldv_36893;
  ldv_36892: 
#line 1398
  tmp___3 = readl((void const volatile   *)h->vaddr + 32U);
#line 1398
  if (((long )tmp___3 & 1L) == 0L) {
#line 1399
    goto ldv_36891;
  } else {

  }
#line 1400
  __const_udelay(4295000UL);
#line 1397
  i = i + 1;
  ldv_36893: ;
#line 1397
  if (i <= 999) {
#line 1398
    goto ldv_36892;
  } else {

  }
  ldv_36891: 
#line 1402
  spin_unlock_irqrestore(& h->lock, flags);
#line 1403
  if (i > 999) {
#line 1404
    return (-11);
  } else {

  }
#line 1405
  return (0);
}
}
#line 1408 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getnodename(ctlr_info_t *h , void *argp ) 
{ 
  NodeName_type NodeName ;
  int i ;
  unsigned char tmp ;
  int tmp___0 ;

  {
#line 1413
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1414
    return (-22);
  } else {

  }
#line 1415
  i = 0;
#line 1415
  goto ldv_36901;
  ldv_36900: 
#line 1416
  tmp = readb((void const volatile   *)(& (h->cfgtable)->ServerName) + (unsigned long )i);
#line 1416
  NodeName[i] = (char )tmp;
#line 1415
  i = i + 1;
  ldv_36901: ;
#line 1415
  if (i <= 15) {
#line 1416
    goto ldv_36900;
  } else {

  }
#line 1417
  tmp___0 = copy_to_user(argp, (void const   *)(& NodeName), 16U);
#line 1417
  if (tmp___0 != 0) {
#line 1418
    return (-14);
  } else {

  }
#line 1419
  return (0);
}
}
#line 1422 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_setnodename(ctlr_info_t *h , void *argp ) 
{ 
  NodeName_type NodeName ;
  unsigned long flags ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1428
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1429
    return (-22);
  } else {

  }
#line 1430
  tmp = capable(21);
#line 1430
  if (tmp) {
#line 1430
    tmp___0 = 0;
  } else {
#line 1430
    tmp___0 = 1;
  }
#line 1430
  if (tmp___0) {
#line 1431
    return (-1);
  } else {

  }
#line 1432
  tmp___1 = copy_from_user((void *)(& NodeName), (void const   *)argp, 16UL);
#line 1432
  if (tmp___1 != 0UL) {
#line 1433
    return (-14);
  } else {

  }
#line 1434
  tmp___2 = spinlock_check(& h->lock);
#line 1434
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 1436
  i = 0;
#line 1436
  goto ldv_36914;
  ldv_36913: 
#line 1437
  writeb((int )((unsigned char )NodeName[i]), (void volatile   *)(& (h->cfgtable)->ServerName) + (unsigned long )i);
#line 1436
  i = i + 1;
  ldv_36914: ;
#line 1436
  if (i <= 15) {
#line 1437
    goto ldv_36913;
  } else {

  }
#line 1438
  writel(1U, (void volatile   *)h->vaddr + 32U);
#line 1439
  i = 0;
#line 1439
  goto ldv_36918;
  ldv_36917: 
#line 1440
  tmp___3 = readl((void const volatile   *)h->vaddr + 32U);
#line 1440
  if (((long )tmp___3 & 1L) == 0L) {
#line 1441
    goto ldv_36916;
  } else {

  }
#line 1442
  __const_udelay(4295000UL);
#line 1439
  i = i + 1;
  ldv_36918: ;
#line 1439
  if (i <= 999) {
#line 1440
    goto ldv_36917;
  } else {

  }
  ldv_36916: 
#line 1444
  spin_unlock_irqrestore(& h->lock, flags);
#line 1445
  if (i > 999) {
#line 1446
    return (-11);
  } else {

  }
#line 1447
  return (0);
}
}
#line 1450 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getheartbeat(ctlr_info_t *h , void *argp ) 
{ 
  Heartbeat_type heartbeat ;
  int tmp ;

  {
#line 1454
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1455
    return (-22);
  } else {

  }
#line 1456
  heartbeat = readl((void const volatile   *)(& (h->cfgtable)->HeartBeat));
#line 1457
  tmp = copy_to_user(argp, (void const   *)(& heartbeat), 4U);
#line 1457
  if (tmp != 0) {
#line 1458
    return (-14);
  } else {

  }
#line 1459
  return (0);
}
}
#line 1462 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getbustypes(ctlr_info_t *h , void *argp ) 
{ 
  BusTypes_type BusTypes ;
  int tmp ;

  {
#line 1466
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1467
    return (-22);
  } else {

  }
#line 1468
  BusTypes = readl((void const volatile   *)(& (h->cfgtable)->BusTypes));
#line 1469
  tmp = copy_to_user(argp, (void const   *)(& BusTypes), 4U);
#line 1469
  if (tmp != 0) {
#line 1470
    return (-14);
  } else {

  }
#line 1471
  return (0);
}
}
#line 1474 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getfirmver(ctlr_info_t *h , void *argp ) 
{ 
  FirmwareVer_type firmware ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 1478
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1479
    return (-22);
  } else {

  }
#line 1480
  __len = 4UL;
#line 1480
  if (__len > 63UL) {
#line 1480
    __ret = __memcpy((void *)(& firmware), (void const   *)(& h->firm_ver), __len);
  } else {
#line 1480
    __ret = __builtin_memcpy((void *)(& firmware), (void const   *)(& h->firm_ver),
                             __len);
  }
#line 1482
  tmp = copy_to_user(argp, (void const   *)(& firmware), 4U);
#line 1482
  if (tmp != 0) {
#line 1484
    return (-14);
  } else {

  }
#line 1485
  return (0);
}
}
#line 1488 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getdrivver(ctlr_info_t *h , void *argp ) 
{ 
  DriverVer_type DriverVer ;
  int tmp ;

  {
#line 1490
  DriverVer = 198170U;
#line 1492
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1493
    return (-22);
  } else {

  }
#line 1494
  tmp = copy_to_user(argp, (void const   *)(& DriverVer), 4U);
#line 1494
  if (tmp != 0) {
#line 1495
    return (-14);
  } else {

  }
#line 1496
  return (0);
}
}
#line 1499 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_getluninfo(ctlr_info_t *h , struct gendisk *disk , void *argp ) 
{ 
  LogvolInfo_struct luninfo ;
  drive_info_struct *drv ;
  drive_info_struct *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;

  {
#line 1503
  tmp = get_drv(disk);
#line 1503
  drv = tmp;
#line 1505
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1506
    return (-22);
  } else {

  }
#line 1507
  __len = 4UL;
#line 1507
  if (__len > 63UL) {
#line 1507
    __ret = __memcpy((void *)(& luninfo.LunID), (void const   *)(& drv->LunID), __len);
  } else {
#line 1507
    __ret = __builtin_memcpy((void *)(& luninfo.LunID), (void const   *)(& drv->LunID),
                             __len);
  }
#line 1508
  luninfo.num_opens = drv->usage_count;
#line 1509
  luninfo.num_parts = 0;
#line 1510
  tmp___0 = copy_to_user(argp, (void const   *)(& luninfo), 12U);
#line 1510
  if (tmp___0 != 0) {
#line 1511
    return (-14);
  } else {

  }
#line 1512
  return (0);
}
}
#line 1515 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_passthru(ctlr_info_t *h , void *argp ) 
{ 
  IOCTL_Command_struct iocommand ;
  CommandList_struct *c ;
  char *buff ;
  u64bit temp64 ;
  struct completion wait ;
  bool tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1519
  buff = 0;
#line 1521
  init_completion(& wait);
#line 1521
  wait = wait;
#line 1523
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1524
    return (-22);
  } else {

  }
#line 1526
  tmp = capable(17);
#line 1526
  if (tmp) {
#line 1526
    tmp___0 = 0;
  } else {
#line 1526
    tmp___0 = 1;
  }
#line 1526
  if (tmp___0) {
#line 1527
    return (-1);
  } else {

  }
#line 1529
  tmp___1 = copy_from_user((void *)(& iocommand), (void const   *)argp, 88UL);
#line 1529
  if (tmp___1 != 0UL) {
#line 1531
    return (-14);
  } else {

  }
#line 1532
  if ((unsigned int )iocommand.buf_size == 0U && (unsigned int )*((unsigned char *)(& iocommand) + 9UL) != 0U) {
#line 1534
    return (-22);
  } else {

  }
#line 1536
  if ((unsigned int )iocommand.buf_size != 0U) {
#line 1537
    tmp___2 = kmalloc((size_t )iocommand.buf_size, 208U);
#line 1537
    buff = (char *)tmp___2;
#line 1538
    if ((unsigned long )buff == (unsigned long )((char *)0)) {
#line 1539
      return (-14);
    } else {

    }
  } else {

  }
#line 1541
  if ((unsigned int )*((unsigned char *)(& iocommand) + 9UL) == 64U) {
#line 1543
    tmp___3 = copy_from_user((void *)buff, (void const   *)iocommand.buf, (unsigned long )iocommand.buf_size);
#line 1543
    if (tmp___3 != 0UL) {
#line 1544
      kfree((void const   *)buff);
#line 1545
      return (-14);
    } else {
#line 1548
      memset((void *)buff, 0, (size_t )iocommand.buf_size);
    }
  } else {

  }
#line 1550
  c = cmd_special_alloc(h);
#line 1551
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1552
    kfree((void const   *)buff);
#line 1553
    return (-12);
  } else {

  }
#line 1556
  c->cmd_type = 1;
#line 1558
  c->Header.ReplyQueue = 0U;
#line 1559
  if ((unsigned int )iocommand.buf_size != 0U) {
#line 1560
    c->Header.SGList = 1U;
#line 1561
    c->Header.SGTotal = 1U;
  } else {
#line 1563
    c->Header.SGList = 0U;
#line 1564
    c->Header.SGTotal = 0U;
  }
#line 1566
  c->Header.LUN = iocommand.LUN_info;
#line 1568
  c->Header.Tag.lower = c->busaddr;
#line 1571
  c->Request = iocommand.Request;
#line 1574
  if ((unsigned int )iocommand.buf_size != 0U) {
#line 1575
    temp64.val = pci_map_single(h->pdev, (void *)buff, (size_t )iocommand.buf_size,
                                0);
#line 1577
    c->SG[0].Addr.lower = temp64.val32.lower;
#line 1578
    c->SG[0].Addr.upper = temp64.val32.upper;
#line 1579
    c->SG[0].Len = (__u32 )iocommand.buf_size;
#line 1580
    c->SG[0].Ext = 0U;
  } else {

  }
#line 1582
  c->waiting = & wait;
#line 1584
  enqueue_cmd_and_start_io(h, c);
#line 1585
  wait_for_completion(& wait);
#line 1588
  temp64.val32.lower = c->SG[0].Addr.lower;
#line 1589
  temp64.val32.upper = c->SG[0].Addr.upper;
#line 1590
  pci_unmap_single(h->pdev, temp64.val, (size_t )iocommand.buf_size, 0);
#line 1592
  check_ioctl_unit_attention(h, c);
#line 1595
  iocommand.error_info = *(c->err_info);
#line 1596
  tmp___4 = copy_to_user(argp, (void const   *)(& iocommand), 88U);
#line 1596
  if (tmp___4 != 0) {
#line 1597
    kfree((void const   *)buff);
#line 1598
    cmd_special_free(h, c);
#line 1599
    return (-14);
  } else {

  }
#line 1602
  if ((unsigned int )*((unsigned char *)(& iocommand) + 9UL) == 128U) {
#line 1604
    tmp___5 = copy_to_user((void *)iocommand.buf, (void const   *)buff, (unsigned int )iocommand.buf_size);
#line 1604
    if (tmp___5 != 0) {
#line 1605
      kfree((void const   *)buff);
#line 1606
      cmd_special_free(h, c);
#line 1607
      return (-14);
    } else {

    }
  } else {

  }
#line 1610
  kfree((void const   *)buff);
#line 1611
  cmd_special_free(h, c);
#line 1612
  return (0);
}
}
#line 1615 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_bigpassthru(ctlr_info_t *h , void *argp ) 
{ 
  BIG_IOCTL_Command_struct *ioc ;
  CommandList_struct *c ;
  unsigned char **buff ;
  int *buff_size ;
  u64bit temp64 ;
  __u8 sg_used ;
  int status ;
  int i ;
  struct completion wait ;
  __u32 left ;
  __u32 sz ;
  __u8 *data_ptr ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  __u8 *ptr ;
  int tmp___8 ;

  {
#line 1619
  buff = 0;
#line 1620
  buff_size = 0;
#line 1622
  sg_used = 0U;
#line 1623
  status = 0;
#line 1625
  init_completion(& wait);
#line 1625
  wait = wait;
#line 1630
  if ((unsigned long )argp == (unsigned long )((void *)0)) {
#line 1631
    return (-22);
  } else {

  }
#line 1632
  tmp = capable(17);
#line 1632
  if (tmp) {
#line 1632
    tmp___0 = 0;
  } else {
#line 1632
    tmp___0 = 1;
  }
#line 1632
  if (tmp___0) {
#line 1633
    return (-1);
  } else {

  }
#line 1634
  tmp___1 = kmalloc(96UL, 208U);
#line 1634
  ioc = (BIG_IOCTL_Command_struct *)tmp___1;
#line 1635
  if ((unsigned long )ioc == (unsigned long )((BIG_IOCTL_Command_struct *)0)) {
#line 1636
    status = -12;
#line 1637
    goto cleanup1;
  } else {

  }
#line 1639
  tmp___2 = copy_from_user((void *)ioc, (void const   *)argp, 96UL);
#line 1639
  if (tmp___2 != 0UL) {
#line 1640
    status = -14;
#line 1641
    goto cleanup1;
  } else {

  }
#line 1643
  if (ioc->buf_size == 0U && (unsigned int )*((unsigned char *)ioc + 9UL) != 0U) {
#line 1645
    status = -22;
#line 1646
    goto cleanup1;
  } else {

  }
#line 1649
  if (ioc->malloc_size > 128000U) {
#line 1650
    status = -22;
#line 1651
    goto cleanup1;
  } else {

  }
#line 1653
  if (ioc->buf_size > ioc->malloc_size * 32U) {
#line 1654
    status = -22;
#line 1655
    goto cleanup1;
  } else {

  }
#line 1657
  tmp___3 = kzalloc(256UL, 208U);
#line 1657
  buff = (unsigned char **)tmp___3;
#line 1658
  if ((unsigned long )buff == (unsigned long )((unsigned char **)0)) {
#line 1659
    status = -12;
#line 1660
    goto cleanup1;
  } else {

  }
#line 1662
  tmp___4 = kmalloc(128UL, 208U);
#line 1662
  buff_size = (int *)tmp___4;
#line 1663
  if ((unsigned long )buff_size == (unsigned long )((int *)0)) {
#line 1664
    status = -12;
#line 1665
    goto cleanup1;
  } else {

  }
#line 1667
  left = ioc->buf_size;
#line 1668
  data_ptr = ioc->buf;
#line 1669
  goto ldv_36981;
  ldv_36980: 
#line 1670
  sz = left < ioc->malloc_size ? left : ioc->malloc_size;
#line 1671
  *(buff_size + (unsigned long )sg_used) = (int )sz;
#line 1672
  tmp___5 = kmalloc((size_t )sz, 208U);
#line 1672
  *(buff + (unsigned long )sg_used) = (unsigned char *)tmp___5;
#line 1673
  if ((unsigned long )*(buff + (unsigned long )sg_used) == (unsigned long )((unsigned char *)0)) {
#line 1674
    status = -12;
#line 1675
    goto cleanup1;
  } else {

  }
#line 1677
  if ((unsigned int )*((unsigned char *)ioc + 9UL) == 64U) {
#line 1678
    tmp___6 = copy_from_user((void *)*(buff + (unsigned long )sg_used), (void const   *)data_ptr,
                             (unsigned long )sz);
#line 1678
    if (tmp___6 != 0UL) {
#line 1679
      status = -14;
#line 1680
      goto cleanup1;
    } else {
#line 1683
      memset((void *)*(buff + (unsigned long )sg_used), 0, (size_t )sz);
    }
  } else {

  }
#line 1685
  left = left - sz;
#line 1686
  data_ptr = data_ptr + (unsigned long )sz;
#line 1687
  sg_used = (__u8 )((int )sg_used + 1);
  ldv_36981: ;
#line 1669
  if (left != 0U) {
#line 1670
    goto ldv_36980;
  } else {

  }
#line 1689
  c = cmd_special_alloc(h);
#line 1690
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 1691
    status = -12;
#line 1692
    goto cleanup1;
  } else {

  }
#line 1694
  c->cmd_type = 1;
#line 1695
  c->Header.ReplyQueue = 0U;
#line 1696
  c->Header.SGList = sg_used;
#line 1697
  c->Header.SGTotal = (__u16 )sg_used;
#line 1698
  c->Header.LUN = ioc->LUN_info;
#line 1699
  c->Header.Tag.lower = c->busaddr;
#line 1701
  c->Request = ioc->Request;
#line 1702
  i = 0;
#line 1702
  goto ldv_36984;
  ldv_36983: 
#line 1703
  temp64.val = pci_map_single(h->pdev, (void *)*(buff + (unsigned long )i), (size_t )*(buff_size + (unsigned long )i),
                              0);
#line 1705
  c->SG[i].Addr.lower = temp64.val32.lower;
#line 1706
  c->SG[i].Addr.upper = temp64.val32.upper;
#line 1707
  c->SG[i].Len = (__u32 )*(buff_size + (unsigned long )i);
#line 1708
  c->SG[i].Ext = 0U;
#line 1702
  i = i + 1;
  ldv_36984: ;
#line 1702
  if ((int )sg_used > i) {
#line 1703
    goto ldv_36983;
  } else {

  }
#line 1710
  c->waiting = & wait;
#line 1711
  enqueue_cmd_and_start_io(h, c);
#line 1712
  wait_for_completion(& wait);
#line 1714
  i = 0;
#line 1714
  goto ldv_36987;
  ldv_36986: 
#line 1715
  temp64.val32.lower = c->SG[i].Addr.lower;
#line 1716
  temp64.val32.upper = c->SG[i].Addr.upper;
#line 1717
  pci_unmap_single(h->pdev, temp64.val, (size_t )*(buff_size + (unsigned long )i),
                   0);
#line 1714
  i = i + 1;
  ldv_36987: ;
#line 1714
  if ((int )sg_used > i) {
#line 1715
    goto ldv_36986;
  } else {

  }
#line 1721
  check_ioctl_unit_attention(h, c);
#line 1723
  ioc->error_info = *(c->err_info);
#line 1724
  tmp___7 = copy_to_user(argp, (void const   *)ioc, 96U);
#line 1724
  if (tmp___7 != 0) {
#line 1725
    cmd_special_free(h, c);
#line 1726
    status = -14;
#line 1727
    goto cleanup1;
  } else {

  }
#line 1729
  if ((unsigned int )*((unsigned char *)ioc + 9UL) == 128U) {
#line 1731
    ptr = ioc->buf;
#line 1732
    i = 0;
#line 1732
    goto ldv_36991;
    ldv_36990: 
#line 1733
    tmp___8 = copy_to_user((void *)ptr, (void const   *)*(buff + (unsigned long )i),
                           (unsigned int )*(buff_size + (unsigned long )i));
#line 1733
    if (tmp___8 != 0) {
#line 1734
      cmd_special_free(h, c);
#line 1735
      status = -14;
#line 1736
      goto cleanup1;
    } else {

    }
#line 1738
    ptr = ptr + (unsigned long )*(buff_size + (unsigned long )i);
#line 1732
    i = i + 1;
    ldv_36991: ;
#line 1732
    if ((int )sg_used > i) {
#line 1733
      goto ldv_36990;
    } else {

    }

  } else {

  }
#line 1741
  cmd_special_free(h, c);
#line 1742
  status = 0;
  cleanup1: ;
#line 1744
  if ((unsigned long )buff != (unsigned long )((unsigned char **)0)) {
#line 1745
    i = 0;
#line 1745
    goto ldv_36994;
    ldv_36993: 
#line 1746
    kfree((void const   *)*(buff + (unsigned long )i));
#line 1745
    i = i + 1;
    ldv_36994: ;
#line 1745
    if ((int )sg_used > i) {
#line 1746
      goto ldv_36993;
    } else {

    }
#line 1747
    kfree((void const   *)buff);
  } else {

  }
#line 1749
  kfree((void const   *)buff_size);
#line 1750
  kfree((void const   *)ioc);
#line 1751
  return (status);
}
}
#line 1754 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                       unsigned long arg ) 
{ 
  struct gendisk *disk ;
  ctlr_info_t *h ;
  ctlr_info_t *tmp ;
  void *argp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1757
  disk = bdev->bd_disk;
#line 1758
  tmp = get_host(disk);
#line 1758
  h = tmp;
#line 1759
  argp = (void *)arg;
#line 1761
  descriptor.modname = "cciss";
#line 1761
  descriptor.function = "cciss_ioctl";
#line 1761
  descriptor.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 1761
  descriptor.format = "cciss_ioctl: Called with cmd=%x %lx\n";
#line 1761
  descriptor.lineno = 1762U;
#line 1761
  descriptor.flags = 0U;
#line 1761
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1761
  if (tmp___0 != 0L) {
#line 1761
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "cciss_ioctl: Called with cmd=%x %lx\n",
                      cmd, arg);
  } else {

  }
#line 1763
  switch (cmd) {
  case 2148024833U: 
#line 1765
  tmp___1 = cciss_getpciinfo(h, argp);
#line 1765
  return (tmp___1);
  case 2148024834U: 
#line 1767
  tmp___2 = cciss_getintinfo(h, argp);
#line 1767
  return (tmp___2);
  case 1074283011U: 
#line 1769
  tmp___3 = cciss_setintinfo(h, argp);
#line 1769
  return (tmp___3);
  case 2148549124U: 
#line 1771
  tmp___4 = cciss_getnodename(h, argp);
#line 1771
  return (tmp___4);
  case 1074807301U: 
#line 1773
  tmp___5 = cciss_setnodename(h, argp);
#line 1773
  return (tmp___5);
  case 2147762694U: 
#line 1775
  tmp___6 = cciss_getheartbeat(h, argp);
#line 1775
  return (tmp___6);
  case 2147762695U: 
#line 1777
  tmp___7 = cciss_getbustypes(h, argp);
#line 1777
  return (tmp___7);
  case 2147762696U: 
#line 1779
  tmp___8 = cciss_getfirmver(h, argp);
#line 1779
  return (tmp___8);
  case 2147762697U: 
#line 1781
  tmp___9 = cciss_getdrivver(h, argp);
#line 1781
  return (tmp___9);
  case 16908U: ;
  case 16910U: ;
  case 16906U: 
#line 1785
  tmp___10 = rebuild_lun_table(h, 0, 1);
#line 1785
  return (tmp___10);
  case 2148286993U: 
#line 1787
  tmp___11 = cciss_getluninfo(h, disk, argp);
#line 1787
  return (tmp___11);
  case 3227009547U: 
#line 1789
  tmp___12 = cciss_passthru(h, argp);
#line 1789
  return (tmp___12);
  case 3227533842U: 
#line 1791
  tmp___13 = cciss_bigpassthru(h, argp);
#line 1791
  return (tmp___13);
  case 8834U: ;
  case 8705U: ;
  case 8706U: ;
  case 8818U: ;
  case 8821U: ;
  case 8707U: ;
  case 8837U: ;
  case 1U: 
#line 1804
  tmp___14 = scsi_cmd_blk_ioctl(bdev, mode, cmd, argp);
#line 1804
  return (tmp___14);
  case 21395U: ;
  case 21273U: ;
  case 21257U: ;
  case 21378U: ;
  case 21382U: ;
  default: ;
#line 1817
  return (-25);
  }
}
}
#line 1821 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_check_queues(ctlr_info_t *h ) 
{ 
  int start_queue ;
  int i ;
  unsigned long tmp ;
  int curr_queue ;
  unsigned long tmp___0 ;

  {
#line 1823
  start_queue = h->next_to_run;
#line 1831
  tmp = find_first_zero_bit((unsigned long const   *)h->cmd_pool_bits, (unsigned long )h->nr_cmds);
#line 1831
  if (tmp == (unsigned long )h->nr_cmds) {
#line 1832
    return;
  } else {

  }
#line 1838
  i = 0;
#line 1838
  goto ldv_37045;
  ldv_37044: 
#line 1839
  curr_queue = (start_queue + i) % (h->highest_lun + 1);
#line 1843
  if ((unsigned long )h->drv[curr_queue] == (unsigned long )((drive_info_struct *)0)) {
#line 1844
    goto ldv_37042;
  } else {

  }
#line 1845
  if ((unsigned long )(h->drv[curr_queue])->queue == (unsigned long )((struct request_queue *)0) || (h->drv[curr_queue])->heads == 0) {
#line 1847
    goto ldv_37042;
  } else {

  }
#line 1848
  blk_start_queue((h->gendisk[curr_queue])->queue);
#line 1853
  tmp___0 = find_first_zero_bit((unsigned long const   *)h->cmd_pool_bits, (unsigned long )h->nr_cmds);
#line 1853
  if (tmp___0 == (unsigned long )h->nr_cmds) {
#line 1854
    if (curr_queue == start_queue) {
#line 1855
      h->next_to_run = (start_queue + 1) % (h->highest_lun + 1);
#line 1857
      goto ldv_37043;
    } else {
#line 1859
      h->next_to_run = curr_queue;
#line 1860
      goto ldv_37043;
    }
  } else {

  }
  ldv_37042: 
#line 1838
  i = i + 1;
  ldv_37045: ;
#line 1838
  if (h->highest_lun + 1 > i) {
#line 1839
    goto ldv_37044;
  } else {

  }
  ldv_37043: ;
#line 1843
  return;
}
}
#line 1866 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_softirq_done(struct request *rq ) 
{ 
  CommandList_struct *c ;
  ctlr_info_t *h ;
  SGDescriptor_struct *curr_sg ;
  u64bit temp64 ;
  unsigned long flags ;
  int i ;
  int ddir ;
  int sg_index ;
  struct _ddebug descriptor ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;

  {
#line 1868
  c = (CommandList_struct *)rq->ldv_32500.completion_data;
#line 1869
  h = hba[c->ctlr];
#line 1870
  curr_sg = (SGDescriptor_struct *)(& c->SG);
#line 1874
  sg_index = 0;
#line 1876
  if ((unsigned int )*((unsigned char *)c + 21UL) == 128U) {
#line 1877
    ddir = 2;
  } else {
#line 1879
    ddir = 1;
  }
#line 1883
  i = 0;
#line 1883
  goto ldv_37058;
  ldv_37057: ;
#line 1884
  if ((curr_sg + (unsigned long )sg_index)->Ext == 2147483648U) {
#line 1885
    cciss_unmap_sg_chain_block(h, c);
#line 1887
    curr_sg = *(h->cmd_sg_list + (unsigned long )c->cmdindex);
#line 1888
    sg_index = 0;
  } else {

  }
#line 1890
  temp64.val32.lower = (curr_sg + (unsigned long )sg_index)->Addr.lower;
#line 1891
  temp64.val32.upper = (curr_sg + (unsigned long )sg_index)->Addr.upper;
#line 1892
  pci_unmap_page(h->pdev, temp64.val, (size_t )(curr_sg + (unsigned long )sg_index)->Len,
                 ddir);
#line 1894
  sg_index = sg_index + 1;
#line 1883
  i = i + 1;
  ldv_37058: ;
#line 1883
  if ((int )c->Header.SGList > i) {
#line 1884
    goto ldv_37057;
  } else {

  }
#line 1897
  descriptor.modname = "cciss";
#line 1897
  descriptor.function = "cciss_softirq_done";
#line 1897
  descriptor.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 1897
  descriptor.format = "Done with %p\n";
#line 1897
  descriptor.lineno = 1897U;
#line 1897
  descriptor.flags = 0U;
#line 1897
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1897
  if (tmp != 0L) {
#line 1897
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "Done with %p\n",
                      rq);
  } else {

  }
#line 1900
  if ((unsigned int )rq->cmd_type == 2U) {
#line 1901
    rq->resid_len = (c->err_info)->ResidualCnt;
  } else {

  }
#line 1903
  blk_end_request_all(rq, rq->errors == 0 ? 0 : -5);
#line 1905
  tmp___0 = spinlock_check(& h->lock);
#line 1905
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 1906
  cmd_free(h, c);
#line 1907
  cciss_check_queues(h);
#line 1908
  spin_unlock_irqrestore(& h->lock, flags);
#line 1909
  return;
}
}
#line 1911 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void log_unit_to_scsi3addr(ctlr_info_t *h , unsigned char *scsi3addr ,
                                           uint32_t log_unit ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 1914
  __len = 8UL;
#line 1914
  if (__len > 63UL) {
#line 1914
    __ret = __memcpy((void *)scsi3addr, (void const   *)(& (h->drv[log_unit])->LunID),
                     __len);
  } else {
#line 1914
    __ret = __builtin_memcpy((void *)scsi3addr, (void const   *)(& (h->drv[log_unit])->LunID),
                             __len);
  }
#line 1916
  return;
}
}
#line 1922 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_get_device_descr(ctlr_info_t *h , int logvol , char *vendor , char *model ,
                                   char *rev ) 
{ 
  int rc ;
  InquiryData_struct *inq_buf ;
  unsigned char scsi3addr[8U] ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 1929
  *vendor = 0;
#line 1930
  *model = 0;
#line 1931
  *rev = 0;
#line 1933
  tmp = kzalloc(36UL, 208U);
#line 1933
  inq_buf = (InquiryData_struct *)tmp;
#line 1934
  if ((unsigned long )inq_buf == (unsigned long )((InquiryData_struct *)0)) {
#line 1935
    return;
  } else {

  }
#line 1937
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 1938
  rc = sendcmd_withirq(h, 18, (void *)inq_buf, 36UL, 0, (unsigned char *)(& scsi3addr),
                       0);
#line 1940
  if (rc == 0) {
#line 1941
    __len = 8UL;
#line 1941
    if (__len > 63UL) {
#line 1941
      __ret = __memcpy((void *)vendor, (void const   *)(& inq_buf->data_byte) + 8U,
                       __len);
    } else {
#line 1941
      __ret = __builtin_memcpy((void *)vendor, (void const   *)(& inq_buf->data_byte) + 8U,
                               __len);
    }
#line 1942
    *(vendor + 8UL) = 0;
#line 1943
    __len___0 = 16UL;
#line 1943
    if (__len___0 > 63UL) {
#line 1943
      __ret___0 = __memcpy((void *)model, (void const   *)(& inq_buf->data_byte) + 16U,
                           __len___0);
    } else {
#line 1943
      __ret___0 = __builtin_memcpy((void *)model, (void const   *)(& inq_buf->data_byte) + 16U,
                                   __len___0);
    }
#line 1944
    *(model + 16UL) = 0;
#line 1945
    __len___1 = 4UL;
#line 1945
    if (__len___1 > 63UL) {
#line 1945
      __ret___1 = __memcpy((void *)rev, (void const   *)(& inq_buf->data_byte) + 32U,
                           __len___1);
    } else {
#line 1945
      __ret___1 = __builtin_memcpy((void *)rev, (void const   *)(& inq_buf->data_byte) + 32U,
                                   __len___1);
    }
#line 1946
    *(rev + 4UL) = 0;
  } else {

  }
#line 1949
  kfree((void const   *)inq_buf);
#line 1950
  return;
}
}
#line 1958 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_get_serial_no(ctlr_info_t *h , int logvol , unsigned char *serial_no ,
                                int buflen ) 
{ 
  int rc ;
  unsigned char *buf ;
  unsigned char scsi3addr[8U] ;
  void *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 1966
  if (buflen > 16) {
#line 1967
    buflen = 16;
  } else {

  }
#line 1968
  memset((void *)serial_no, 255, (size_t )buflen);
#line 1969
  tmp = kzalloc(64UL, 208U);
#line 1969
  buf = (unsigned char *)tmp;
#line 1970
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0)) {
#line 1971
    return;
  } else {

  }
#line 1972
  memset((void *)serial_no, 0, (size_t )buflen);
#line 1973
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 1974
  rc = sendcmd_withirq(h, 18, (void *)buf, 64UL, 131, (unsigned char *)(& scsi3addr),
                       0);
#line 1976
  if (rc == 0) {
#line 1977
    __len = (size_t )buflen;
#line 1977
    __ret = __builtin_memcpy((void *)serial_no, (void const   *)buf + 8U, __len);
  } else {

  }
#line 1978
  kfree((void const   *)buf);
#line 1979
  return;
}
}
#line 1985 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_add_disk(ctlr_info_t *h , struct gendisk *disk , int drv_index ) 
{ 
  long tmp ;

  {
#line 1988
  disk->queue = blk_init_queue(& do_cciss_request, & h->lock);
#line 1989
  if ((unsigned long )disk->queue == (unsigned long )((struct request_queue *)0)) {
#line 1990
    goto init_queue_failure;
  } else {

  }
#line 1991
  sprintf((char *)(& disk->disk_name), "cciss/c%dd%d", h->ctlr, drv_index);
#line 1992
  disk->major = h->major;
#line 1993
  disk->first_minor = drv_index << 4;
#line 1994
  disk->fops = & cciss_fops;
#line 1995
  tmp = cciss_create_ld_sysfs_entry(h, drv_index);
#line 1995
  if (tmp != 0L) {
#line 1996
    goto cleanup_queue;
  } else {

  }
#line 1997
  disk->private_data = (void *)h->drv[drv_index];
#line 1998
  disk->driverfs_dev = & (h->drv[drv_index])->dev;
#line 2001
  blk_queue_bounce_limit(disk->queue, (h->pdev)->dma_mask);
#line 2004
  blk_queue_max_segments(disk->queue, (int )((unsigned short )h->maxsgentries));
#line 2006
  blk_queue_max_hw_sectors(disk->queue, (unsigned int )h->cciss_max_sectors);
#line 2008
  blk_queue_softirq_done(disk->queue, & cciss_softirq_done);
#line 2010
  (disk->queue)->queuedata = (void *)h;
#line 2012
  blk_queue_logical_block_size(disk->queue, (int )((unsigned short )(h->drv[drv_index])->block_size));
#line 2018
  __asm__  volatile   ("sfence": : : "memory");
#line 2019
  (h->drv[drv_index])->queue = disk->queue;
#line 2020
  add_disk(disk);
#line 2021
  return (0);
  cleanup_queue: 
#line 2024
  blk_cleanup_queue(disk->queue);
#line 2025
  disk->queue = 0;
  init_queue_failure: ;
#line 2027
  return (-1);
}
}
#line 2040 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_update_drive_info(ctlr_info_t *h , int drv_index , int first_time ,
                                    int via_ioctl ) 
{ 
  struct gendisk *disk ;
  InquiryData_struct *inq_buff ;
  unsigned int block_size___0 ;
  sector_t total_size ;
  unsigned long flags ;
  int ret ;
  drive_info_struct *drvinfo ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  int tmp___3 ;

  {
#line 2044
  inq_buff = 0;
#line 2047
  flags = 0UL;
#line 2048
  ret = 0;
#line 2052
  tmp = kmalloc(36UL, 208U);
#line 2052
  inq_buff = (InquiryData_struct *)tmp;
#line 2053
  tmp___0 = kzalloc(1240UL, 208U);
#line 2053
  drvinfo = (drive_info_struct *)tmp___0;
#line 2054
  if ((unsigned long )inq_buff == (unsigned long )((InquiryData_struct *)0) || (unsigned long )drvinfo == (unsigned long )((drive_info_struct *)0)) {
#line 2055
    goto mem_msg;
  } else {

  }
#line 2058
  if ((unsigned int )h->cciss_read == 136U) {
#line 2059
    cciss_read_capacity_16(h, drv_index, & total_size, & block_size___0);
  } else {
#line 2063
    cciss_read_capacity(h, drv_index, & total_size, & block_size___0);
#line 2067
    if ((unsigned long long )total_size == 4294967295ULL) {
#line 2068
      cciss_read_capacity_16(h, drv_index, & total_size, & block_size___0);
#line 2070
      h->cciss_read = 136U;
#line 2071
      h->cciss_write = 138U;
    } else {
#line 2073
      h->cciss_read = 40U;
#line 2074
      h->cciss_write = 42U;
    }
  }
#line 2078
  cciss_geometry_inquiry(h, drv_index, total_size, block_size___0, inq_buff, drvinfo);
#line 2080
  drvinfo->block_size = (int )block_size___0;
#line 2081
  drvinfo->nr_blocks = total_size + 1UL;
#line 2083
  cciss_get_device_descr(h, drv_index, (char *)(& drvinfo->vendor), (char *)(& drvinfo->model),
                         (char *)(& drvinfo->rev));
#line 2085
  cciss_get_serial_no(h, drv_index, (unsigned char *)(& drvinfo->serial_no), 16);
#line 2088
  __len = 8UL;
#line 2088
  if (__len > 63UL) {
#line 2088
    __ret = __memcpy((void *)(& drvinfo->LunID), (void const   *)(& (h->drv[drv_index])->LunID),
                     __len);
  } else {
#line 2088
    __ret = __builtin_memcpy((void *)(& drvinfo->LunID), (void const   *)(& (h->drv[drv_index])->LunID),
                             __len);
  }
#line 2092
  if ((h->drv[drv_index])->raid_level != -1) {
#line 2092
    tmp___1 = memcmp((void const   *)(& drvinfo->serial_no), (void const   *)(& (h->drv[drv_index])->serial_no),
                     16UL);
#line 2092
    if (((((tmp___1 == 0 && drvinfo->block_size == (h->drv[drv_index])->block_size) && drvinfo->nr_blocks == (h->drv[drv_index])->nr_blocks) && drvinfo->heads == (h->drv[drv_index])->heads) && drvinfo->sectors == (h->drv[drv_index])->sectors) && drvinfo->cylinders == (h->drv[drv_index])->cylinders) {
#line 2101
      goto freeret;
    } else {

    }
  } else {

  }
#line 2109
  if ((h->drv[drv_index])->raid_level != -1 && drv_index != 0) {
#line 2110
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "disk %d has changed.\n",
             drv_index);
#line 2111
    tmp___2 = spinlock_check(& h->lock);
#line 2111
    flags = _raw_spin_lock_irqsave(tmp___2);
#line 2112
    (h->drv[drv_index])->busy_configuring = 1;
#line 2113
    spin_unlock_irqrestore(& h->lock, flags);
#line 2119
    ret = deregister_disk(h, drv_index, 0, via_ioctl);
  } else {

  }
#line 2123
  if (ret != 0) {
#line 2124
    goto freeret;
  } else {

  }
#line 2130
  if ((unsigned long )h->drv[drv_index] == (unsigned long )((drive_info_struct *)0)) {
#line 2131
    drvinfo->device_initialized = 0;
#line 2132
    h->drv[drv_index] = drvinfo;
#line 2133
    drvinfo = 0;
  } else {
#line 2136
    (h->drv[drv_index])->block_size = drvinfo->block_size;
#line 2137
    (h->drv[drv_index])->nr_blocks = drvinfo->nr_blocks;
#line 2138
    (h->drv[drv_index])->heads = drvinfo->heads;
#line 2139
    (h->drv[drv_index])->sectors = drvinfo->sectors;
#line 2140
    (h->drv[drv_index])->cylinders = drvinfo->cylinders;
#line 2141
    (h->drv[drv_index])->raid_level = drvinfo->raid_level;
#line 2142
    __len___0 = 16UL;
#line 2142
    if (__len___0 > 63UL) {
#line 2142
      __ret___0 = __memcpy((void *)(& (h->drv[drv_index])->serial_no), (void const   *)(& drvinfo->serial_no),
                           __len___0);
    } else {
#line 2142
      __ret___0 = __builtin_memcpy((void *)(& (h->drv[drv_index])->serial_no), (void const   *)(& drvinfo->serial_no),
                                   __len___0);
    }
#line 2143
    __len___1 = 9UL;
#line 2143
    if (__len___1 > 63UL) {
#line 2143
      __ret___1 = __memcpy((void *)(& (h->drv[drv_index])->vendor), (void const   *)(& drvinfo->vendor),
                           __len___1);
    } else {
#line 2143
      __ret___1 = __builtin_memcpy((void *)(& (h->drv[drv_index])->vendor), (void const   *)(& drvinfo->vendor),
                                   __len___1);
    }
#line 2145
    __len___2 = 17UL;
#line 2145
    if (__len___2 > 63UL) {
#line 2145
      __ret___2 = __memcpy((void *)(& (h->drv[drv_index])->model), (void const   *)(& drvinfo->model),
                           __len___2);
    } else {
#line 2145
      __ret___2 = __builtin_memcpy((void *)(& (h->drv[drv_index])->model), (void const   *)(& drvinfo->model),
                                   __len___2);
    }
#line 2146
    __len___3 = 5UL;
#line 2146
    if (__len___3 > 63UL) {
#line 2146
      __ret___3 = __memcpy((void *)(& (h->drv[drv_index])->rev), (void const   *)(& drvinfo->rev),
                           __len___3);
    } else {
#line 2146
      __ret___3 = __builtin_memcpy((void *)(& (h->drv[drv_index])->rev), (void const   *)(& drvinfo->rev),
                                   __len___3);
    }
  }
#line 2149
  h->num_luns = h->num_luns + 1;
#line 2150
  disk = h->gendisk[drv_index];
#line 2151
  set_capacity(disk, (h->drv[drv_index])->nr_blocks);
#line 2159
  if (drv_index != 0 || first_time != 0) {
#line 2160
    tmp___3 = cciss_add_disk(h, disk, drv_index);
#line 2160
    if (tmp___3 != 0) {
#line 2161
      cciss_free_gendisk(h, drv_index);
#line 2162
      cciss_free_drive_info(h, drv_index);
#line 2163
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "could not update disk %d\n",
               drv_index);
#line 2165
      h->num_luns = h->num_luns - 1;
    } else {

    }
  } else {

  }
  freeret: 
#line 2170
  kfree((void const   *)inq_buff);
#line 2171
  kfree((void const   *)drvinfo);
#line 2172
  return;
  mem_msg: 
#line 2174
  dev_err((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 2175
  goto freeret;
}
}
#line 2188 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_alloc_drive_info(ctlr_info_t *h , int controller_node ) 
{ 
  int i ;
  drive_info_struct *drv ;
  void *tmp ;

  {
#line 2194
  i = 0;
#line 2194
  goto ldv_37152;
  ldv_37151: ;
#line 2197
  if ((unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0) && i != 0) {
#line 2198
    goto ldv_37150;
  } else {

  }
#line 2203
  if ((i == 0 && (unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0)) && (h->drv[i])->raid_level != -1) {
#line 2204
    goto ldv_37150;
  } else {

  }
#line 2210
  if (h->highest_lun < i && controller_node == 0) {
#line 2211
    h->highest_lun = i;
  } else {

  }
#line 2214
  if (i == 0 && (unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0)) {
#line 2215
    return (i);
  } else {

  }
#line 2221
  tmp = kzalloc(1240UL, 208U);
#line 2221
  drv = (drive_info_struct *)tmp;
#line 2222
  if ((unsigned long )drv == (unsigned long )((drive_info_struct *)0)) {
#line 2223
    return (-1);
  } else {

  }
#line 2224
  drv->raid_level = -1;
#line 2225
  h->drv[i] = drv;
#line 2226
  return (i);
  ldv_37150: 
#line 2194
  i = i + 1;
  ldv_37152: ;
#line 2194
  if (i <= 1023) {
#line 2195
    goto ldv_37151;
  } else {

  }

#line 2228
  return (-1);
}
}
#line 2231 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_drive_info(ctlr_info_t *h , int drv_index ) 
{ 


  {
#line 2233
  kfree((void const   *)h->drv[drv_index]);
#line 2234
  h->drv[drv_index] = 0;
#line 2235
  return;
}
}
#line 2237 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_gendisk(ctlr_info_t *h , int drv_index ) 
{ 


  {
#line 2239
  put_disk(h->gendisk[drv_index]);
#line 2240
  h->gendisk[drv_index] = 0;
#line 2241
  return;
}
}
#line 2252 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_add_gendisk(ctlr_info_t *h , unsigned char *lunid , int controller_node ) 
{ 
  int drv_index ;
  size_t __len ;
  void *__ret ;
  long tmp ;

  {
#line 2257
  drv_index = cciss_alloc_drive_info(h, controller_node);
#line 2258
  if (drv_index == -1) {
#line 2259
    return (-1);
  } else {

  }
#line 2262
  if ((unsigned long )h->gendisk[drv_index] == (unsigned long )((struct gendisk *)0)) {
#line 2263
    h->gendisk[drv_index] = alloc_disk(16);
#line 2265
    if ((unsigned long )h->gendisk[drv_index] == (unsigned long )((struct gendisk *)0)) {
#line 2266
      dev_err((struct device  const  *)(& (h->pdev)->dev), "could not allocate a new disk %d\n",
              drv_index);
#line 2269
      goto err_free_drive_info;
    } else {

    }
  } else {

  }
#line 2272
  __len = 8UL;
#line 2272
  if (__len > 63UL) {
#line 2272
    __ret = __memcpy((void *)(& (h->drv[drv_index])->LunID), (void const   *)lunid,
                     __len);
  } else {
#line 2272
    __ret = __builtin_memcpy((void *)(& (h->drv[drv_index])->LunID), (void const   *)lunid,
                             __len);
  }
#line 2274
  tmp = cciss_create_ld_sysfs_entry(h, drv_index);
#line 2274
  if (tmp != 0L) {
#line 2275
    goto err_free_disk;
  } else {

  }
#line 2279
  (h->drv[drv_index])->busy_configuring = 0;
#line 2280
  __asm__  volatile   ("sfence": : : "memory");
#line 2281
  return (drv_index);
  err_free_disk: 
#line 2284
  cciss_free_gendisk(h, drv_index);
  err_free_drive_info: 
#line 2286
  cciss_free_drive_info(h, drv_index);
#line 2287
  return (-1);
}
}
#line 2295 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_add_controller_node(ctlr_info_t *h ) 
{ 
  struct gendisk *disk ;
  int drv_index ;
  int tmp ;

  {
#line 2300
  if ((unsigned long )h->gendisk[0] != (unsigned long )((struct gendisk *)0)) {
#line 2301
    return;
  } else {

  }
#line 2303
  drv_index = cciss_add_gendisk(h, (unsigned char *)"", 1);
#line 2304
  if (drv_index == -1) {
#line 2305
    goto error;
  } else {

  }
#line 2306
  (h->drv[drv_index])->block_size = 512;
#line 2307
  (h->drv[drv_index])->nr_blocks = 0UL;
#line 2308
  (h->drv[drv_index])->heads = 0;
#line 2309
  (h->drv[drv_index])->sectors = 0;
#line 2310
  (h->drv[drv_index])->cylinders = 0;
#line 2311
  (h->drv[drv_index])->raid_level = -1;
#line 2312
  memset((void *)(& (h->drv[drv_index])->serial_no), 0, 16UL);
#line 2313
  disk = h->gendisk[drv_index];
#line 2314
  tmp = cciss_add_disk(h, disk, drv_index);
#line 2314
  if (tmp == 0) {
#line 2315
    return;
  } else {

  }
#line 2316
  cciss_free_gendisk(h, drv_index);
#line 2317
  cciss_free_drive_info(h, drv_index);
  error: 
#line 2319
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "could not add disk 0.\n");
#line 2320
  return;
}
}
#line 2331 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int rebuild_lun_table(ctlr_info_t *h , int first_time , int via_ioctl ) 
{ 
  int num_luns ;
  ReportLunData_struct *ld_buff ;
  int return_code ;
  int listlength ;
  int i ;
  int drv_found ;
  int drv_index ;
  unsigned char lunid[8U] ;
  unsigned int tmp ;
  unsigned long flags ;
  bool tmp___0 ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  void *tmp___3 ;
  __u32 tmp___4 ;
  int j ;
  size_t __len ;
  void *__ret ;
  int tmp___5 ;
  raw_spinlock_t *tmp___6 ;
  int j___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___7 ;

  {
#line 2335
  ld_buff = 0;
#line 2337
  listlength = 0;
#line 2340
  drv_index = 0;
#line 2341
  lunid[0] = '\000';
#line 2341
  tmp = 1U;
#line 2341
  while (1) {
#line 2341
    if (tmp >= 8U) {
#line 2341
      break;
    } else {

    }
#line 2341
    lunid[tmp] = (unsigned char)0;
#line 2341
    tmp = tmp + 1U;
  }
#line 2344
  tmp___0 = capable(17);
#line 2344
  if (tmp___0) {
#line 2344
    tmp___1 = 0;
  } else {
#line 2344
    tmp___1 = 1;
  }
#line 2344
  if (tmp___1) {
#line 2345
    return (-1);
  } else {

  }
#line 2348
  tmp___2 = spinlock_check(& h->lock);
#line 2348
  flags = _raw_spin_lock_irqsave(tmp___2);
#line 2349
  if (h->busy_configuring != 0) {
#line 2350
    spin_unlock_irqrestore(& h->lock, flags);
#line 2351
    return (-16);
  } else {

  }
#line 2353
  h->busy_configuring = 1;
#line 2354
  spin_unlock_irqrestore(& h->lock, flags);
#line 2356
  tmp___3 = kzalloc(8200UL, 208U);
#line 2356
  ld_buff = (ReportLunData_struct *)tmp___3;
#line 2357
  if ((unsigned long )ld_buff == (unsigned long )((ReportLunData_struct *)0)) {
#line 2358
    goto mem_msg;
  } else {

  }
#line 2360
  return_code = sendcmd_withirq(h, 194, (void *)ld_buff, 8200UL, 0, (unsigned char *)"",
                                0);
#line 2364
  if (return_code == 0) {
#line 2365
    tmp___4 = __fswab32(*((__be32 *)(& ld_buff->LUNListLength)));
#line 2365
    listlength = (int )tmp___4;
  } else {
#line 2367
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "report logical volume command failed\n");
#line 2369
    listlength = 0;
#line 2370
    goto freeret;
  }
#line 2373
  num_luns = listlength / 8;
#line 2374
  if (num_luns > 1024) {
#line 2375
    num_luns = 1024;
#line 2376
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "more luns configured on controller than can be handled by this driver.\n");
  } else {

  }
#line 2381
  if (num_luns == 0) {
#line 2382
    cciss_add_controller_node(h);
  } else {

  }
#line 2389
  i = 0;
#line 2389
  goto ldv_37210;
  ldv_37209: 
#line 2391
  drv_found = 0;
#line 2394
  if ((unsigned long )h->drv[i] == (unsigned long )((drive_info_struct *)0)) {
#line 2395
    goto ldv_37199;
  } else {

  }
#line 2397
  j = 0;
#line 2397
  goto ldv_37205;
  ldv_37204: 
#line 2398
  __len = 8UL;
#line 2398
  if (__len > 63UL) {
#line 2398
    __ret = __memcpy((void *)(& lunid), (void const   *)(& ld_buff->LUN) + (unsigned long )j,
                     __len);
  } else {
#line 2398
    __ret = __builtin_memcpy((void *)(& lunid), (void const   *)(& ld_buff->LUN) + (unsigned long )j,
                             __len);
  }
#line 2399
  tmp___5 = memcmp((void const   *)(& (h->drv[i])->LunID), (void const   *)(& lunid),
                   8UL);
#line 2399
  if (tmp___5 == 0) {
#line 2401
    drv_found = 1;
#line 2402
    goto ldv_37203;
  } else {

  }
#line 2397
  j = j + 1;
  ldv_37205: ;
#line 2397
  if (j < num_luns) {
#line 2398
    goto ldv_37204;
  } else {

  }
  ldv_37203: ;
#line 2405
  if (drv_found == 0) {
#line 2407
    tmp___6 = spinlock_check(& h->lock);
#line 2407
    flags = _raw_spin_lock_irqsave(tmp___6);
#line 2408
    (h->drv[i])->busy_configuring = 1;
#line 2409
    spin_unlock_irqrestore(& h->lock, flags);
#line 2410
    return_code = deregister_disk(h, i, 1, via_ioctl);
#line 2411
    if ((unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0)) {
#line 2412
      (h->drv[i])->busy_configuring = 0;
    } else {

    }
  } else {

  }
  ldv_37199: 
#line 2389
  i = i + 1;
  ldv_37210: ;
#line 2389
  if (h->highest_lun >= i) {
#line 2390
    goto ldv_37209;
  } else {

  }
#line 2421
  i = 0;
#line 2421
  goto ldv_37220;
  ldv_37219: 
#line 2424
  drv_found = 0;
#line 2426
  __len___0 = 8UL;
#line 2426
  if (__len___0 > 63UL) {
#line 2426
    __ret___0 = __memcpy((void *)(& lunid), (void const   *)(& ld_buff->LUN) + (unsigned long )i,
                         __len___0);
  } else {
#line 2426
    __ret___0 = __builtin_memcpy((void *)(& lunid), (void const   *)(& ld_buff->LUN) + (unsigned long )i,
                                 __len___0);
  }
#line 2432
  j___0 = 0;
#line 2432
  goto ldv_37218;
  ldv_37217: ;
#line 2433
  if ((unsigned long )h->drv[j___0] != (unsigned long )((drive_info_struct *)0)) {
#line 2433
    tmp___7 = memcmp((void const   *)(& (h->drv[j___0])->LunID), (void const   *)(& lunid),
                     8UL);
#line 2433
    if (tmp___7 == 0) {
#line 2436
      drv_index = j___0;
#line 2437
      drv_found = 1;
#line 2438
      goto ldv_37216;
    } else {

    }
  } else {

  }
#line 2432
  j___0 = j___0 + 1;
  ldv_37218: ;
#line 2432
  if (h->highest_lun >= j___0) {
#line 2433
    goto ldv_37217;
  } else {

  }
  ldv_37216: ;
#line 2443
  if (drv_found == 0) {
#line 2444
    drv_index = cciss_add_gendisk(h, (unsigned char *)(& lunid), 0);
#line 2445
    if (drv_index == -1) {
#line 2446
      goto freeret;
    } else {

    }
  } else {

  }
#line 2448
  cciss_update_drive_info(h, drv_index, first_time, via_ioctl);
#line 2421
  i = i + 1;
  ldv_37220: ;
#line 2421
  if (i < num_luns) {
#line 2422
    goto ldv_37219;
  } else {

  }

  freeret: 
#line 2452
  kfree((void const   *)ld_buff);
#line 2453
  h->busy_configuring = 0;
#line 2458
  return (-1);
  mem_msg: 
#line 2460
  dev_err((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 2461
  h->busy_configuring = 0;
#line 2462
  goto freeret;
}
}
#line 2465 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_clear_drive_info(drive_info_struct *drive_info ) 
{ 


  {
#line 2468
  drive_info->nr_blocks = 0UL;
#line 2469
  drive_info->block_size = 0;
#line 2470
  drive_info->heads = 0;
#line 2471
  drive_info->sectors = 0;
#line 2472
  drive_info->cylinders = 0;
#line 2473
  drive_info->raid_level = -1;
#line 2474
  memset((void *)(& drive_info->serial_no), 0, 16UL);
#line 2475
  memset((void *)(& drive_info->model), 0, 17UL);
#line 2476
  memset((void *)(& drive_info->rev), 0, 5UL);
#line 2477
  memset((void *)(& drive_info->vendor), 0, 9UL);
#line 2478
  return;
}
}
#line 2505 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int deregister_disk(ctlr_info_t *h , int drv_index , int clear_all , int via_ioctl ) 
{ 
  int i ;
  struct gendisk *disk ;
  drive_info_struct *drv ;
  int recalculate_highest_lun ;
  bool tmp ;
  int tmp___0 ;
  struct request_queue *q ;
  int newhighest ;

  {
#line 2513
  tmp = capable(17);
#line 2513
  if (tmp) {
#line 2513
    tmp___0 = 0;
  } else {
#line 2513
    tmp___0 = 1;
  }
#line 2513
  if (tmp___0) {
#line 2514
    return (-1);
  } else {

  }
#line 2516
  drv = h->drv[drv_index];
#line 2517
  disk = h->gendisk[drv_index];
#line 2520
  if (clear_all != 0 || (unsigned long )h->gendisk[0] == (unsigned long )disk) {
#line 2521
    if (drv->usage_count > via_ioctl) {
#line 2522
      return (-16);
    } else
#line 2523
    if (drv->usage_count > 0) {
#line 2524
      return (-16);
    } else {

    }
  } else {

  }
#line 2526
  recalculate_highest_lun = (unsigned long )h->drv[h->highest_lun] == (unsigned long )drv;
#line 2532
  if ((unsigned long )h->gendisk[0] != (unsigned long )disk) {
#line 2533
    q = disk->queue;
#line 2534
    if ((disk->flags & 16) != 0) {
#line 2535
      cciss_destroy_ld_sysfs_entry(h, drv_index, 0);
#line 2536
      del_gendisk(disk);
    } else {

    }
#line 2538
    if ((unsigned long )q != (unsigned long )((struct request_queue *)0)) {
#line 2539
      blk_cleanup_queue(q);
    } else {

    }
#line 2546
    if (clear_all != 0) {
#line 2552
      i = 0;
#line 2552
      goto ldv_37238;
      ldv_37237: ;
#line 2553
      if ((unsigned long )h->gendisk[i] == (unsigned long )disk) {
#line 2554
        h->gendisk[i] = 0;
#line 2555
        goto ldv_37236;
      } else {

      }
#line 2552
      i = i + 1;
      ldv_37238: ;
#line 2552
      if (i <= 1023) {
#line 2553
        goto ldv_37237;
      } else {

      }
      ldv_37236: 
#line 2558
      put_disk(disk);
    } else {

    }
  } else {
#line 2561
    set_capacity(disk, 0UL);
#line 2562
    cciss_clear_drive_info(drv);
  }
#line 2565
  h->num_luns = h->num_luns - 1;
#line 2568
  if (clear_all != 0 && recalculate_highest_lun != 0) {
#line 2569
    newhighest = -1;
#line 2570
    i = 0;
#line 2570
    goto ldv_37241;
    ldv_37240: ;
#line 2572
    if ((unsigned long )h->drv[i] != (unsigned long )((drive_info_struct *)0) && (h->drv[i])->heads != 0) {
#line 2573
      newhighest = i;
    } else {

    }
#line 2570
    i = i + 1;
    ldv_37241: ;
#line 2570
    if (h->highest_lun >= i) {
#line 2571
      goto ldv_37240;
    } else {

    }
#line 2575
    h->highest_lun = newhighest;
  } else {

  }
#line 2577
  return (0);
}
}
#line 2580 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int fill_cmd(ctlr_info_t *h , CommandList_struct *c , __u8 cmd , void *buff ,
                    size_t size , __u8 page_code , unsigned char *scsi3addr , int cmd_type ) 
{ 
  u64bit buff_dma_handle ;
  int status ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 2585
  status = 0;
#line 2587
  c->cmd_type = 1;
#line 2588
  c->Header.ReplyQueue = 0U;
#line 2589
  if ((unsigned long )buff != (unsigned long )((void *)0)) {
#line 2590
    c->Header.SGList = 1U;
#line 2591
    c->Header.SGTotal = 1U;
  } else {
#line 2593
    c->Header.SGList = 0U;
#line 2594
    c->Header.SGTotal = 0U;
  }
#line 2596
  c->Header.Tag.lower = c->busaddr;
#line 2597
  __len = 8UL;
#line 2597
  if (__len > 63UL) {
#line 2597
    __ret = __memcpy((void *)(& c->Header.LUN.LunAddrBytes), (void const   *)scsi3addr,
                     __len);
  } else {
#line 2597
    __ret = __builtin_memcpy((void *)(& c->Header.LUN.LunAddrBytes), (void const   *)scsi3addr,
                             __len);
  }
#line 2599
  c->Request.Type.Type = (unsigned char )cmd_type;
#line 2600
  if (cmd_type == 0) {
#line 2601
    switch ((int )cmd) {
    case 18: ;
#line 2604
    if ((unsigned int )page_code != 0U) {
#line 2605
      c->Request.CDB[1] = 1U;
#line 2606
      c->Request.CDB[2] = page_code;
    } else {

    }
#line 2608
    c->Request.CDBLen = 6U;
#line 2609
    c->Request.Type.Attribute = 4U;
#line 2610
    c->Request.Type.Direction = 2U;
#line 2611
    c->Request.Timeout = 0U;
#line 2612
    c->Request.CDB[0] = 18U;
#line 2613
    c->Request.CDB[4] = (__u8 )size;
#line 2614
    goto ldv_37259;
    case 194: ;
    case 195: 
#line 2620
    c->Request.CDBLen = 12U;
#line 2621
    c->Request.Type.Attribute = 4U;
#line 2622
    c->Request.Type.Direction = 2U;
#line 2623
    c->Request.Timeout = 0U;
#line 2624
    c->Request.CDB[0] = cmd;
#line 2625
    c->Request.CDB[6] = (__u8 )(size >> 24);
#line 2626
    c->Request.CDB[7] = (__u8 )(size >> 16);
#line 2627
    c->Request.CDB[8] = (__u8 )(size >> 8);
#line 2628
    c->Request.CDB[9] = (__u8 )size;
#line 2629
    goto ldv_37259;
    case 37: 
#line 2632
    c->Request.CDBLen = 10U;
#line 2633
    c->Request.Type.Attribute = 4U;
#line 2634
    c->Request.Type.Direction = 2U;
#line 2635
    c->Request.Timeout = 0U;
#line 2636
    c->Request.CDB[0] = cmd;
#line 2637
    goto ldv_37259;
    case 158: 
#line 2639
    c->Request.CDBLen = 16U;
#line 2640
    c->Request.Type.Attribute = 4U;
#line 2641
    c->Request.Type.Direction = 2U;
#line 2642
    c->Request.Timeout = 0U;
#line 2643
    c->Request.CDB[0] = cmd;
#line 2644
    c->Request.CDB[1] = 16U;
#line 2645
    c->Request.CDB[10] = (__u8 )(size >> 24);
#line 2646
    c->Request.CDB[11] = (__u8 )(size >> 16);
#line 2647
    c->Request.CDB[12] = (__u8 )(size >> 8);
#line 2648
    c->Request.CDB[13] = (__u8 )size;
#line 2649
    c->Request.Timeout = 0U;
#line 2650
    c->Request.CDB[0] = cmd;
#line 2651
    goto ldv_37259;
    case 1: 
#line 2653
    c->Request.CDBLen = 12U;
#line 2654
    c->Request.Type.Attribute = 4U;
#line 2655
    c->Request.Type.Direction = 1U;
#line 2656
    c->Request.Timeout = 0U;
#line 2657
    c->Request.CDB[0] = 39U;
#line 2658
    c->Request.CDB[6] = 194U;
#line 2659
    c->Request.CDB[7] = (__u8 )(size >> 8);
#line 2660
    c->Request.CDB[8] = (__u8 )size;
#line 2661
    goto ldv_37259;
    case 0: 
#line 2663
    c->Request.CDBLen = 6U;
#line 2664
    c->Request.Type.Attribute = 4U;
#line 2665
    c->Request.Type.Direction = 0U;
#line 2666
    c->Request.Timeout = 0U;
#line 2667
    goto ldv_37259;
    default: 
#line 2669
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Unknown Command 0x%c\n",
             (int )cmd);
#line 2670
    return (1);
    }
    ldv_37259: ;
  } else
#line 2672
  if (cmd_type == 1) {
#line 2673
    switch ((int )cmd) {
    case 0: 
#line 2675
    c->Request.CDBLen = 12U;
#line 2676
    c->Request.Type.Attribute = 4U;
#line 2677
    c->Request.Type.Direction = 1U;
#line 2678
    c->Request.Timeout = 0U;
#line 2679
    c->Request.CDB[0] = cmd;
#line 2680
    c->Request.CDB[1] = 0U;
#line 2682
    __len___0 = 8UL;
#line 2682
    if (__len___0 > 63UL) {
#line 2682
      __ret___0 = __memcpy((void *)(& c->Request.CDB) + 4U, (void const   *)buff,
                           __len___0);
    } else {
#line 2682
      __ret___0 = __builtin_memcpy((void *)(& c->Request.CDB) + 4U, (void const   *)buff,
                                   __len___0);
    }
#line 2683
    goto ldv_37271;
    case 1: 
#line 2685
    c->Request.CDBLen = 16U;
#line 2686
    c->Request.Type.Attribute = 4U;
#line 2687
    c->Request.Type.Direction = 0U;
#line 2688
    c->Request.Timeout = 0U;
#line 2689
    memset((void *)(& c->Request.CDB), 0, 16UL);
#line 2690
    c->Request.CDB[0] = cmd;
#line 2691
    c->Request.CDB[1] = 3U;
#line 2692
    goto ldv_37271;
    case 3: 
#line 2694
    c->Request.CDBLen = 1U;
#line 2695
    c->Request.Type.Attribute = 4U;
#line 2696
    c->Request.Type.Direction = 1U;
#line 2697
    c->Request.Timeout = 0U;
#line 2698
    c->Request.CDB[0] = cmd;
#line 2699
    goto ldv_37271;
    default: 
#line 2701
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "unknown message type %d\n",
             (int )cmd);
#line 2703
    return (1);
    }
    ldv_37271: ;
  } else {
#line 2706
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "unknown command type %d\n",
             cmd_type);
#line 2707
    return (1);
  }
#line 2710
  if (size != 0UL) {
#line 2711
    buff_dma_handle.val = pci_map_single(h->pdev, buff, size, 0);
#line 2714
    c->SG[0].Addr.lower = buff_dma_handle.val32.lower;
#line 2715
    c->SG[0].Addr.upper = buff_dma_handle.val32.upper;
#line 2716
    c->SG[0].Len = (__u32 )size;
#line 2717
    c->SG[0].Ext = 0U;
  } else {

  }
#line 2719
  return (status);
}
}
#line 2722 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_send_reset(ctlr_info_t *h , unsigned char *scsi3addr , u8 reset_type ) 
{ 
  CommandList_struct *c ;
  int return_status ;

  {
#line 2728
  c = cmd_alloc(h);
#line 2729
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 2730
    return (-12);
  } else {

  }
#line 2731
  return_status = fill_cmd(h, c, 1, 0, 0UL, 0, (unsigned char *)"", 1);
#line 2733
  c->Request.CDB[1] = reset_type;
#line 2734
  if (return_status != 0) {
#line 2735
    cmd_special_free(h, c);
#line 2736
    return (return_status);
  } else {

  }
#line 2738
  c->waiting = 0;
#line 2739
  enqueue_cmd_and_start_io(h, c);
#line 2744
  return (0);
}
}
#line 2747 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int check_target_status(ctlr_info_t *h , CommandList_struct *c ) 
{ 
  int tmp ;

  {
#line 2749
  switch ((int )(c->err_info)->ScsiStatus) {
  case 0: ;
#line 2751
  return (0);
  case 2: ;
#line 2753
  switch ((int )(c->err_info)->SenseInfo[2] & 15) {
  case 0: ;
#line 2754
  return (0);
  case 1: ;
#line 2755
  return (0);
  default: 
#line 2757
  tmp = check_for_unit_attention(h, c);
#line 2757
  if (tmp != 0) {
#line 2758
    return (3);
  } else {

  }
#line 2759
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x check condition, sense key = 0x%02x\n",
           (int )c->Request.CDB[0], (int )(c->err_info)->SenseInfo[2]);
  }
#line 2763
  goto ldv_37291;
  default: 
#line 2765
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02xscsi status = 0x%02x\n",
           (int )c->Request.CDB[0], (int )(c->err_info)->ScsiStatus);
#line 2768
  goto ldv_37291;
  }
  ldv_37291: ;
#line 2770
  return (1);
}
}
#line 2773 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int process_sendcmd_error(ctlr_info_t *h , CommandList_struct *c ) 
{ 
  int return_status ;

  {
#line 2775
  return_status = 0;
#line 2777
  if ((unsigned int )(c->err_info)->CommandStatus == 0U) {
#line 2778
    return (0);
  } else {

  }
#line 2780
  switch ((int )(c->err_info)->CommandStatus) {
  case 1: 
#line 2782
  return_status = check_target_status(h, c);
#line 2783
  goto ldv_37299;
  case 2: ;
  case 3: ;
#line 2787
  goto ldv_37299;
  case 4: 
#line 2789
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x is reported invalid\n",
           (int )c->Request.CDB[0]);
#line 2791
  return_status = 1;
#line 2792
  goto ldv_37299;
  case 5: 
#line 2794
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x has protocol error\n",
           (int )c->Request.CDB[0]);
#line 2796
  return_status = 1;
#line 2797
  goto ldv_37299;
  case 6: 
#line 2799
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x had  hardware error\n",
           (int )c->Request.CDB[0]);
#line 2801
  return_status = 1;
#line 2802
  goto ldv_37299;
  case 7: 
#line 2804
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x had connection lost\n",
           (int )c->Request.CDB[0]);
#line 2806
  return_status = 1;
#line 2807
  goto ldv_37299;
  case 8: 
#line 2809
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x was aborted\n",
           (int )c->Request.CDB[0]);
#line 2811
  return_status = 1;
#line 2812
  goto ldv_37299;
  case 9: 
#line 2814
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x reports abort failed\n",
           (int )c->Request.CDB[0]);
#line 2816
  return_status = 1;
#line 2817
  goto ldv_37299;
  case 10: 
#line 2819
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "unsolicited abort 0x%02x\n",
           (int )c->Request.CDB[0]);
#line 2821
  return_status = 3;
#line 2822
  goto ldv_37299;
  case 12: 
#line 2824
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd unabortable\n");
#line 2825
  return_status = 1;
#line 2826
  goto ldv_37299;
  default: 
#line 2828
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd 0x%02x returned unknown status %x\n",
           (int )c->Request.CDB[0], (int )(c->err_info)->CommandStatus);
#line 2831
  return_status = 1;
  }
  ldv_37299: ;
#line 2833
  return (return_status);
}
}
#line 2836 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int sendcmd_withirq_core(ctlr_info_t *h , CommandList_struct *c , int attempt_retry ) 
{ 
  struct completion wait ;
  u64bit buff_dma_handle ;
  int return_status ;

  {
#line 2839
  init_completion(& wait);
#line 2839
  wait = wait;
#line 2841
  return_status = 0;
  resend_cmd2: 
#line 2844
  c->waiting = & wait;
#line 2845
  enqueue_cmd_and_start_io(h, c);
#line 2847
  wait_for_completion(& wait);
#line 2849
  if ((unsigned int )(c->err_info)->CommandStatus == 0U || attempt_retry == 0) {
#line 2850
    goto command_done;
  } else {

  }
#line 2852
  return_status = process_sendcmd_error(h, c);
#line 2854
  if (return_status == 3 && c->retry_count <= 2) {
#line 2856
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "retrying 0x%02x\n", (int )c->Request.CDB[0]);
#line 2858
    c->retry_count = c->retry_count + 1;
#line 2860
    memset((void *)c->err_info, 0, 48UL);
#line 2861
    return_status = 0;
#line 2862
    wait.done = 0U;
#line 2863
    goto resend_cmd2;
  } else {

  }
  command_done: 
#line 2868
  buff_dma_handle.val32.lower = c->SG[0].Addr.lower;
#line 2869
  buff_dma_handle.val32.upper = c->SG[0].Addr.upper;
#line 2870
  pci_unmap_single(h->pdev, buff_dma_handle.val, (size_t )c->SG[0].Len, 0);
#line 2872
  return (return_status);
}
}
#line 2875 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int sendcmd_withirq(ctlr_info_t *h , __u8 cmd , void *buff , size_t size ,
                           __u8 page_code , unsigned char *scsi3addr , int cmd_type ) 
{ 
  CommandList_struct *c ;
  int return_status ;

  {
#line 2882
  c = cmd_special_alloc(h);
#line 2883
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 2884
    return (-12);
  } else {

  }
#line 2885
  return_status = fill_cmd(h, c, (int )cmd, buff, size, (int )page_code, scsi3addr,
                           cmd_type);
#line 2887
  if (return_status == 0) {
#line 2888
    return_status = sendcmd_withirq_core(h, c, 1);
  } else {

  }
#line 2890
  cmd_special_free(h, c);
#line 2891
  return (return_status);
}
}
#line 2894 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_geometry_inquiry(ctlr_info_t *h , int logvol , sector_t total_size ,
                                   unsigned int block_size___0 , InquiryData_struct *inq_buff ,
                                   drive_info_struct *drv ) 
{ 
  int return_code ;
  unsigned long t ;
  unsigned char scsi3addr[8U] ;
  sector_t real_size ;
  unsigned long rem ;
  int _res ;

  {
#line 2904
  memset((void *)inq_buff, 0, 36UL);
#line 2905
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 2906
  return_code = sendcmd_withirq(h, 18, (void *)inq_buff, 36UL, 193, (unsigned char *)(& scsi3addr),
                                0);
#line 2908
  if (return_code == 0) {
#line 2909
    if ((unsigned int )inq_buff->data_byte[8] == 255U) {
#line 2910
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "reading geometry failed, volume does not support reading geometry\n");
#line 2913
      drv->heads = 255;
#line 2914
      drv->sectors = 32;
#line 2915
      drv->cylinders = (int )((unsigned int )total_size + 1U);
#line 2916
      drv->raid_level = 6;
    } else {
#line 2918
      drv->heads = (int )inq_buff->data_byte[6];
#line 2919
      drv->sectors = (int )inq_buff->data_byte[7];
#line 2920
      drv->cylinders = (int )inq_buff->data_byte[4] << 8;
#line 2921
      drv->cylinders = drv->cylinders + (int )inq_buff->data_byte[5];
#line 2922
      drv->raid_level = (int )inq_buff->data_byte[8];
    }
#line 2924
    drv->block_size = (int )block_size___0;
#line 2925
    drv->nr_blocks = total_size + 1UL;
#line 2926
    t = (unsigned long )(drv->heads * drv->sectors);
#line 2927
    if (t > 1UL) {
#line 2928
      real_size = total_size + 1UL;
#line 2929
      _res = (int )(real_size % t);
#line 2929
      real_size = real_size / t;
#line 2929
      rem = (unsigned long )_res;
#line 2930
      if (rem != 0UL) {
#line 2931
        real_size = real_size + 1UL;
      } else {

      }
#line 2932
      drv->cylinders = (int )real_size;
    } else {

    }
  } else {
#line 2935
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "reading geometry failed\n");
  }
#line 2936
  return;
}
}
#line 2940 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_read_capacity(ctlr_info_t *h , int logvol , sector_t *total_size ,
                                unsigned int *block_size___0 ) 
{ 
  ReadCapdata_struct *buf ;
  int return_code ;
  unsigned char scsi3addr[8U] ;
  void *tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 2947
  tmp = kzalloc(8UL, 208U);
#line 2947
  buf = (ReadCapdata_struct *)tmp;
#line 2948
  if ((unsigned long )buf == (unsigned long )((ReadCapdata_struct *)0)) {
#line 2949
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 2950
    return;
  } else {

  }
#line 2953
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 2954
  return_code = sendcmd_withirq(h, 37, (void *)buf, 8UL, 0, (unsigned char *)(& scsi3addr),
                                0);
#line 2956
  if (return_code == 0) {
#line 2957
    tmp___0 = __fswab32(*((__be32 *)(& buf->total_size)));
#line 2957
    *total_size = (sector_t )tmp___0;
#line 2958
    tmp___1 = __fswab32(*((__be32 *)(& buf->block_size)));
#line 2958
    *block_size___0 = tmp___1;
  } else {
#line 2960
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "read capacity failed\n");
#line 2961
    *total_size = 0UL;
#line 2962
    *block_size___0 = 1024U;
  }
#line 2964
  kfree((void const   *)buf);
#line 2965
  return;
}
}
#line 2967 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_read_capacity_16(ctlr_info_t *h , int logvol , sector_t *total_size ,
                                   unsigned int *block_size___0 ) 
{ 
  ReadCapdata_struct_16 *buf ;
  int return_code ;
  unsigned char scsi3addr[8U] ;
  void *tmp ;
  __u64 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 2974
  tmp = kzalloc(31UL, 208U);
#line 2974
  buf = (ReadCapdata_struct_16 *)tmp;
#line 2975
  if ((unsigned long )buf == (unsigned long )((ReadCapdata_struct_16 *)0)) {
#line 2976
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 2977
    return;
  } else {

  }
#line 2980
  log_unit_to_scsi3addr(h, (unsigned char *)(& scsi3addr), (uint32_t )logvol);
#line 2981
  return_code = sendcmd_withirq(h, 158, (void *)buf, 31UL, 0, (unsigned char *)(& scsi3addr),
                                0);
#line 2984
  if (return_code == 0) {
#line 2985
    tmp___0 = __fswab64(*((__be64 *)(& buf->total_size)));
#line 2985
    *total_size = (sector_t )tmp___0;
#line 2986
    tmp___1 = __fswab32(*((__be32 *)(& buf->block_size)));
#line 2986
    *block_size___0 = tmp___1;
  } else {
#line 2988
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "read capacity failed\n");
#line 2989
    *total_size = 0UL;
#line 2990
    *block_size___0 = 1024U;
  }
#line 2992
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "      blocks= %llu block_size= %d\n",
            (unsigned long long )*total_size + 1ULL, *block_size___0);
#line 2994
  kfree((void const   *)buf);
#line 2995
  return;
}
}
#line 2997 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_revalidate(struct gendisk *disk ) 
{ 
  ctlr_info_t *h ;
  ctlr_info_t *tmp ;
  drive_info_struct *drv ;
  drive_info_struct *tmp___0 ;
  int logvol ;
  int FOUND ;
  unsigned int block_size___0 ;
  sector_t total_size ;
  InquiryData_struct *inq_buff ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 2999
  tmp = get_host(disk);
#line 2999
  h = tmp;
#line 3000
  tmp___0 = get_drv(disk);
#line 3000
  drv = tmp___0;
#line 3002
  FOUND = 0;
#line 3005
  inq_buff = 0;
#line 3007
  logvol = 0;
#line 3007
  goto ldv_37381;
  ldv_37380: ;
#line 3008
  if ((unsigned long )h->drv[logvol] == (unsigned long )((drive_info_struct *)0)) {
#line 3009
    goto ldv_37378;
  } else {

  }
#line 3010
  tmp___1 = memcmp((void const   *)(& (h->drv[logvol])->LunID), (void const   *)(& drv->LunID),
                   8UL);
#line 3010
  if (tmp___1 == 0) {
#line 3012
    FOUND = 1;
#line 3013
    goto ldv_37379;
  } else {

  }
  ldv_37378: 
#line 3007
  logvol = logvol + 1;
  ldv_37381: ;
#line 3007
  if (h->highest_lun >= logvol) {
#line 3008
    goto ldv_37380;
  } else {

  }
  ldv_37379: ;
#line 3017
  if (FOUND == 0) {
#line 3018
    return (1);
  } else {

  }
#line 3020
  tmp___2 = kmalloc(36UL, 208U);
#line 3020
  inq_buff = (InquiryData_struct *)tmp___2;
#line 3021
  if ((unsigned long )inq_buff == (unsigned long )((InquiryData_struct *)0)) {
#line 3022
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 3023
    return (1);
  } else {

  }
#line 3025
  if ((unsigned int )h->cciss_read == 40U) {
#line 3026
    cciss_read_capacity(h, logvol, & total_size, & block_size___0);
  } else {
#line 3029
    cciss_read_capacity_16(h, logvol, & total_size, & block_size___0);
  }
#line 3032
  cciss_geometry_inquiry(h, logvol, total_size, block_size___0, inq_buff, drv);
#line 3035
  blk_queue_logical_block_size(drv->queue, (int )((unsigned short )drv->block_size));
#line 3036
  set_capacity(disk, drv->nr_blocks);
#line 3038
  kfree((void const   *)inq_buff);
#line 3039
  return (0);
}
}
#line 3045 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void *remap_pci_mem(ulong base , ulong size ) 
{ 
  ulong page_base ;
  ulong page_offs ;
  void *page_remapped ;
  void *tmp ;

  {
#line 3047
  page_base = base & 0xfffffffffffff000UL;
#line 3048
  page_offs = base - page_base;
#line 3049
  tmp = ioremap((resource_size_t )page_base, page_offs + size);
#line 3049
  page_remapped = tmp;
#line 3051
  return ((unsigned long )page_remapped != (unsigned long )((void *)0) ? page_remapped + page_offs : 0);
}
}
#line 3058 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void start_io(ctlr_info_t *h ) 
{ 
  CommandList_struct *c ;
  struct list_head  const  *__mptr ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 3062
  goto ldv_37397;
  ldv_37396: 
#line 3063
  __mptr = (struct list_head  const  *)h->reqQ.next;
#line 3063
  c = (CommandList_struct *)__mptr + 0xfffffffffffffdb0UL;
#line 3065
  tmp = (*(h->access.fifo_full))(h);
#line 3065
  if (tmp != 0UL) {
#line 3066
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "fifo full\n");
#line 3067
    goto ldv_37395;
  } else {

  }
#line 3071
  removeQ(c);
#line 3072
  h->Qdepth = h->Qdepth - 1U;
#line 3075
  (*(h->access.submit_command))(h, c);
#line 3078
  addQ(& h->cmpQ, c);
  ldv_37397: 
#line 3062
  tmp___0 = list_empty((struct list_head  const  *)(& h->reqQ));
#line 3062
  if (tmp___0 == 0) {
#line 3063
    goto ldv_37396;
  } else {

  }
  ldv_37395: ;
#line 3067
  return;
}
}
#line 3085 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void resend_cciss_cmd(ctlr_info_t *h , CommandList_struct *c ) 
{ 


  {
#line 3088
  memset((void *)c->err_info, 0, 48UL);
#line 3091
  addQ(& h->reqQ, c);
#line 3092
  h->Qdepth = h->Qdepth + 1U;
#line 3093
  if (h->Qdepth > h->maxQsinceinit) {
#line 3094
    h->maxQsinceinit = h->Qdepth;
  } else {

  }
#line 3096
  start_io(h);
#line 3097
  return;
}
}
#line 3099 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static unsigned int make_status_bytes(unsigned int scsi_status_byte , unsigned int msg_byte ,
                                               unsigned int host_byte , unsigned int driver_byte ) 
{ 


  {
#line 3104
  return ((((scsi_status_byte & 255U) | ((msg_byte << 8) & 65535U)) | ((host_byte & 255U) << 16)) | (driver_byte << 24));
}
}
#line 3110 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static int evaluate_target_status(ctlr_info_t *h , CommandList_struct *cmd ,
                                           int *retry_cmd ) 
{ 
  unsigned char sense_key ;
  unsigned char status_byte ;
  unsigned char msg_byte ;
  unsigned char host_byte ;
  unsigned char driver_byte ;
  int error_value ;
  unsigned int tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 3117
  *retry_cmd = 0;
#line 3119
  status_byte = (cmd->err_info)->ScsiStatus;
#line 3120
  driver_byte = 0U;
#line 3121
  msg_byte = (unsigned char )(cmd->err_info)->CommandStatus;
#line 3123
  if ((unsigned int )(cmd->rq)->cmd_type == 2U) {
#line 3124
    host_byte = 10U;
  } else {
#line 3126
    host_byte = 0U;
  }
#line 3128
  tmp = make_status_bytes((unsigned int )status_byte, (unsigned int )msg_byte, (unsigned int )host_byte,
                          (unsigned int )driver_byte);
#line 3128
  error_value = (int )tmp;
#line 3131
  if ((unsigned int )(cmd->err_info)->ScsiStatus != 2U) {
#line 3132
    if ((unsigned int )(cmd->rq)->cmd_type != 2U) {
#line 3133
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has SCSI Status 0x%x\n",
               cmd, (int )(cmd->err_info)->ScsiStatus);
    } else {

    }
#line 3136
    return (error_value);
  } else {

  }
#line 3140
  sense_key = (unsigned int )(cmd->err_info)->SenseInfo[2] & 15U;
#line 3142
  if (((unsigned int )sense_key == 0U || (unsigned int )sense_key == 1U) && (unsigned int )(cmd->rq)->cmd_type != 2U) {
#line 3144
    error_value = 0;
  } else {

  }
#line 3146
  tmp___0 = check_for_unit_attention(h, cmd);
#line 3146
  if (tmp___0 != 0) {
#line 3147
    *retry_cmd = (unsigned int )(cmd->rq)->cmd_type != 2U;
#line 3148
    return (0);
  } else {

  }
#line 3152
  if ((unsigned int )(cmd->rq)->cmd_type != 2U) {
#line 3153
    if (error_value != 0) {
#line 3154
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has CHECK CONDITION sense key = 0x%x\n",
               cmd, (int )sense_key);
    } else {

    }
#line 3156
    return (error_value);
  } else {

  }
#line 3160
  if ((unsigned long )(cmd->rq)->sense != (unsigned long )((void *)0)) {
#line 3161
    if ((cmd->rq)->sense_len > (unsigned int )(cmd->err_info)->SenseLen) {
#line 3162
      (cmd->rq)->sense_len = (unsigned int )(cmd->err_info)->SenseLen;
    } else {

    }
#line 3163
    __len = (size_t )(cmd->rq)->sense_len;
#line 3163
    __ret = __builtin_memcpy((cmd->rq)->sense, (void const   *)(& (cmd->err_info)->SenseInfo),
                             __len);
  } else {
#line 3166
    (cmd->rq)->sense_len = 0U;
  }
#line 3168
  return (error_value);
}
}
#line 3175 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void complete_command(ctlr_info_t *h , CommandList_struct *cmd , int timeout ) 
{ 
  int retry_cmd ;
  struct request *rq ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 3178
  retry_cmd = 0;
#line 3179
  rq = cmd->rq;
#line 3181
  rq->errors = 0;
#line 3183
  if (timeout != 0) {
#line 3184
    tmp = make_status_bytes(0U, 0U, 0U, 6U);
#line 3184
    rq->errors = (int )tmp;
  } else {

  }
#line 3186
  if ((unsigned int )(cmd->err_info)->CommandStatus == 0U) {
#line 3187
    goto after_error_processing;
  } else {

  }
#line 3189
  switch ((int )(cmd->err_info)->CommandStatus) {
  case 1: 
#line 3191
  rq->errors = evaluate_target_status(h, cmd, & retry_cmd);
#line 3192
  goto ldv_37431;
  case 2: ;
#line 3194
  if ((unsigned int )(cmd->rq)->cmd_type == 1U) {
#line 3195
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p has completed with data underrun reported\n",
             cmd);
#line 3198
    (cmd->rq)->resid_len = (cmd->err_info)->ResidualCnt;
  } else {

  }
#line 3200
  goto ldv_37431;
  case 3: ;
#line 3202
  if ((unsigned int )(cmd->rq)->cmd_type == 1U) {
#line 3203
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p has completed with data overrun reported\n",
             cmd);
  } else {

  }
#line 3206
  goto ldv_37431;
  case 4: 
#line 3208
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p is reported invalid\n",
           cmd);
#line 3210
  tmp___0 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 7U);
#line 3210
  rq->errors = (int )tmp___0;
#line 3214
  goto ldv_37431;
  case 5: 
#line 3216
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p has protocol error\n",
           cmd);
#line 3218
  tmp___1 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 7U);
#line 3218
  rq->errors = (int )tmp___1;
#line 3222
  goto ldv_37431;
  case 6: 
#line 3224
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p had  hardware error\n",
           cmd);
#line 3226
  tmp___2 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 7U);
#line 3226
  rq->errors = (int )tmp___2;
#line 3230
  goto ldv_37431;
  case 7: 
#line 3232
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p had connection lost\n",
           cmd);
#line 3234
  tmp___3 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 7U);
#line 3234
  rq->errors = (int )tmp___3;
#line 3238
  goto ldv_37431;
  case 8: 
#line 3240
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p was aborted\n",
           cmd);
#line 3242
  tmp___4 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 5U);
#line 3242
  rq->errors = (int )tmp___4;
#line 3246
  goto ldv_37431;
  case 9: 
#line 3248
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: cmd %p reports abort failed\n",
           cmd);
#line 3250
  tmp___5 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 7U);
#line 3250
  rq->errors = (int )tmp___5;
#line 3254
  goto ldv_37431;
  case 10: 
#line 3256
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss%d: unsolicited abort %p\n",
           h->ctlr, cmd);
#line 3258
  if (cmd->retry_count <= 2) {
#line 3259
    retry_cmd = 1;
#line 3260
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "retrying %p\n", cmd);
#line 3261
    cmd->retry_count = cmd->retry_count + 1;
  } else {
#line 3263
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "%p retried too many times\n",
             cmd);
  }
#line 3265
  tmp___6 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 5U);
#line 3265
  rq->errors = (int )tmp___6;
#line 3269
  goto ldv_37431;
  case 11: 
#line 3271
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p timedout\n", cmd);
#line 3272
  tmp___7 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 7U);
#line 3272
  rq->errors = (int )tmp___7;
#line 3276
  goto ldv_37431;
  case 12: 
#line 3278
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p unabortable\n", cmd);
#line 3279
  tmp___8 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 7U);
#line 3279
  rq->errors = (int )tmp___8;
#line 3283
  goto ldv_37431;
  default: 
#line 3285
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "cmd %p returned unknown status %x\n",
           cmd, (int )(cmd->err_info)->CommandStatus);
#line 3288
  tmp___9 = make_status_bytes(0U, (unsigned int )(cmd->err_info)->CommandStatus, 0U,
                              (unsigned int )(cmd->rq)->cmd_type == 2U ? 10U : 7U);
#line 3288
  rq->errors = (int )tmp___9;
  }
  ldv_37431: ;
  after_error_processing: ;
#line 3297
  if (retry_cmd != 0) {
#line 3298
    resend_cciss_cmd(h, cmd);
#line 3299
    return;
  } else {

  }
#line 3301
  (cmd->rq)->ldv_32500.completion_data = (void *)cmd;
#line 3302
  blk_complete_request(cmd->rq);
#line 3303
  return;
}
}
#line 3305 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 cciss_tag_contains_index(u32 tag ) 
{ 


  {
#line 3308
  return (tag & 16U);
}
}
#line 3311 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 cciss_tag_to_index(u32 tag ) 
{ 


  {
#line 3314
  return (tag >> 5);
}
}
#line 3317 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 cciss_tag_discard_error_bits(ctlr_info_t *h , u32 tag ) 
{ 
  long tmp ;

  {
#line 3321
  tmp = ldv__builtin_expect((h->transMethod & 4UL) != 0UL, 1L);
#line 3321
  if (tmp != 0L) {
#line 3322
    return (tag & 4294967264U);
  } else {

  }
#line 3323
  return (tag & 4294967292U);
}
}
#line 3326 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void cciss_mark_tag_indexed(u32 *tag ) 
{ 


  {
#line 3328
  *tag = *tag | 16U;
#line 3329
  return;
}
}
#line 3331 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void cciss_set_tag_index(u32 *tag , u32 index ) 
{ 


  {
#line 3333
  *tag = *tag | (index << 5);
#line 3334
  return;
}
}
#line 3339 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void do_cciss_request(struct request_queue *q ) 
{ 
  ctlr_info_t *h ;
  CommandList_struct *c ;
  sector_t start_blk ;
  int seg ;
  struct request *creq ;
  u64bit temp64 ;
  struct scatterlist *tmp_sg ;
  SGDescriptor_struct *curr_sg ;
  drive_info_struct *drv ;
  int i ;
  int dir ;
  int sg_index ;
  int chained ;
  long tmp ;
  size_t __len ;
  void *__ret ;
  struct _ddebug descriptor ;
  unsigned int tmp___0 ;
  sector_t tmp___1 ;
  long tmp___2 ;
  struct page *tmp___3 ;
  struct _ddebug descriptor___0 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  __u8 tmp___8 ;
  __u8 tmp___9 ;
  u32 upper32 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  __u8 tmp___14 ;
  size_t __len___0 ;
  void *__ret___0 ;
  long tmp___15 ;

  {
#line 3341
  h = (ctlr_info_t *)q->queuedata;
#line 3351
  sg_index = 0;
#line 3352
  chained = 0;
  queue: 
#line 3355
  creq = blk_peek_request(q);
#line 3356
  if ((unsigned long )creq == (unsigned long )((struct request *)0)) {
#line 3357
    goto startio;
  } else {

  }
#line 3359
  tmp = ldv__builtin_expect((int )creq->nr_phys_segments > h->maxsgentries, 0L);
#line 3359
  if (tmp != 0L) {
#line 3359
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"),
                         "i" (3359), "i" (12UL));
    ldv_37479: ;
#line 3359
    goto ldv_37479;
  } else {

  }
#line 3361
  c = cmd_alloc(h);
#line 3362
  if ((unsigned long )c == (unsigned long )((CommandList_struct *)0)) {
#line 3363
    goto full;
  } else {

  }
#line 3365
  blk_start_request(creq);
#line 3367
  tmp_sg = *(h->scatter_list + (unsigned long )c->cmdindex);
#line 3368
  spin_unlock_irq(q->queue_lock);
#line 3370
  c->cmd_type = 0;
#line 3371
  c->rq = creq;
#line 3374
  drv = (drive_info_struct *)(creq->rq_disk)->private_data;
#line 3375
  c->Header.ReplyQueue = 0U;
#line 3379
  cciss_set_tag_index(& c->Header.Tag.lower, (u32 )c->cmdindex);
#line 3380
  cciss_mark_tag_indexed(& c->Header.Tag.lower);
#line 3381
  __len = 8UL;
#line 3381
  if (__len > 63UL) {
#line 3381
    __ret = __memcpy((void *)(& c->Header.LUN), (void const   *)(& drv->LunID), __len);
  } else {
#line 3381
    __ret = __builtin_memcpy((void *)(& c->Header.LUN), (void const   *)(& drv->LunID),
                             __len);
  }
#line 3382
  c->Request.CDBLen = 10U;
#line 3383
  c->Request.Type.Type = 0U;
#line 3384
  c->Request.Type.Attribute = 4U;
#line 3385
  c->Request.Type.Direction = (creq->cmd_flags & 1U) == 0U ? 2U : 1U;
#line 3387
  c->Request.Timeout = 0U;
#line 3388
  c->Request.CDB[0] = (creq->cmd_flags & 1U) == 0U ? h->cciss_read : h->cciss_write;
#line 3390
  start_blk = blk_rq_pos((struct request  const  *)creq);
#line 3391
  descriptor.modname = "cciss";
#line 3391
  descriptor.function = "do_cciss_request";
#line 3391
  descriptor.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3391
  descriptor.format = "sector =%d nr_sectors=%d\n";
#line 3391
  descriptor.lineno = 3392U;
#line 3391
  descriptor.flags = 0U;
#line 3391
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3391
  if (tmp___2 != 0L) {
#line 3391
    tmp___0 = blk_rq_sectors((struct request  const  *)creq);
#line 3391
    tmp___1 = blk_rq_pos((struct request  const  *)creq);
#line 3391
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "sector =%d nr_sectors=%d\n",
                      (int )tmp___1, (int )tmp___0);
  } else {

  }
#line 3393
  sg_init_table(tmp_sg, (unsigned int )h->maxsgentries);
#line 3394
  seg = blk_rq_map_sg(q, creq, tmp_sg);
#line 3397
  if ((unsigned int )*((unsigned char *)c + 21UL) == 128U) {
#line 3398
    dir = 2;
  } else {
#line 3400
    dir = 1;
  }
#line 3402
  curr_sg = (SGDescriptor_struct *)(& c->SG);
#line 3403
  sg_index = 0;
#line 3404
  chained = 0;
#line 3406
  i = 0;
#line 3406
  goto ldv_37487;
  ldv_37486: ;
#line 3407
  if ((sg_index + 1 == h->max_cmd_sgentries && chained == 0) && seg - i > 1) {
#line 3410
    curr_sg = *(h->cmd_sg_list + (unsigned long )c->cmdindex);
#line 3411
    sg_index = 0;
#line 3412
    chained = 1;
  } else {

  }
#line 3414
  (curr_sg + (unsigned long )sg_index)->Len = (tmp_sg + (unsigned long )i)->length;
#line 3415
  tmp___3 = sg_page(tmp_sg + (unsigned long )i);
#line 3415
  temp64.val = pci_map_page(h->pdev, tmp___3, (unsigned long )(tmp_sg + (unsigned long )i)->offset,
                            (size_t )(tmp_sg + (unsigned long )i)->length, dir);
#line 3418
  (curr_sg + (unsigned long )sg_index)->Addr.lower = temp64.val32.lower;
#line 3419
  (curr_sg + (unsigned long )sg_index)->Addr.upper = temp64.val32.upper;
#line 3420
  (curr_sg + (unsigned long )sg_index)->Ext = 0U;
#line 3421
  sg_index = sg_index + 1;
#line 3406
  i = i + 1;
  ldv_37487: ;
#line 3406
  if (i < seg) {
#line 3407
    goto ldv_37486;
  } else {

  }

#line 3423
  if (chained != 0) {
#line 3424
    cciss_map_sg_chain_block(h, c, *(h->cmd_sg_list + (unsigned long )c->cmdindex),
                             (int )((unsigned int )((1 - h->max_cmd_sgentries) + seg) * 16U));
  } else {

  }
#line 3429
  if ((unsigned int )seg > h->maxSG) {
#line 3430
    h->maxSG = (unsigned int )seg;
  } else {

  }
#line 3432
  descriptor___0.modname = "cciss";
#line 3432
  descriptor___0.function = "do_cciss_request";
#line 3432
  descriptor___0.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3432
  descriptor___0.format = "Submitting %u sectors in %d segments chained[%d]\n";
#line 3432
  descriptor___0.lineno = 3434U;
#line 3432
  descriptor___0.flags = 0U;
#line 3432
  tmp___5 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 3432
  if (tmp___5 != 0L) {
#line 3432
    tmp___4 = blk_rq_sectors((struct request  const  *)creq);
#line 3432
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)(& (h->pdev)->dev),
                      "Submitting %u sectors in %d segments chained[%d]\n", tmp___4,
                      seg, chained);
  } else {

  }
#line 3436
  c->Header.SGTotal = (int )((__u16 )seg) + (int )((__u16 )chained);
#line 3437
  if (h->max_cmd_sgentries >= seg) {
#line 3438
    c->Header.SGList = (__u8 )c->Header.SGTotal;
  } else {
#line 3440
    c->Header.SGList = (__u8 )h->max_cmd_sgentries;
  }
#line 3441
  set_performant_mode(h, c);
#line 3443
  tmp___15 = ldv__builtin_expect((unsigned int )creq->cmd_type == 1U, 1L);
#line 3443
  if (tmp___15 != 0L) {
#line 3444
    if ((unsigned int )h->cciss_read == 40U) {
#line 3445
      c->Request.CDB[1] = 0U;
#line 3446
      c->Request.CDB[2] = (__u8 )(start_blk >> 24);
#line 3447
      c->Request.CDB[3] = (__u8 )(start_blk >> 16);
#line 3448
      c->Request.CDB[4] = (__u8 )(start_blk >> 8);
#line 3449
      c->Request.CDB[5] = (__u8 )start_blk;
#line 3450
      c->Request.CDB[6] = 0U;
#line 3451
      tmp___6 = blk_rq_sectors((struct request  const  *)creq);
#line 3451
      c->Request.CDB[7] = (__u8 )(tmp___6 >> 8);
#line 3452
      tmp___7 = blk_rq_sectors((struct request  const  *)creq);
#line 3452
      c->Request.CDB[8] = (__u8 )tmp___7;
#line 3453
      tmp___9 = 0U;
#line 3453
      c->Request.CDB[12] = tmp___9;
#line 3453
      tmp___8 = tmp___9;
#line 3453
      c->Request.CDB[11] = tmp___8;
#line 3453
      c->Request.CDB[9] = tmp___8;
    } else {
#line 3455
      upper32 = (unsigned int )(start_blk >> 32UL);
#line 3457
      c->Request.CDBLen = 16U;
#line 3458
      c->Request.CDB[1] = 0U;
#line 3459
      c->Request.CDB[2] = (__u8 )(upper32 >> 24);
#line 3460
      c->Request.CDB[3] = (__u8 )(upper32 >> 16);
#line 3461
      c->Request.CDB[4] = (__u8 )(upper32 >> 8);
#line 3462
      c->Request.CDB[5] = (__u8 )upper32;
#line 3463
      c->Request.CDB[6] = (__u8 )(start_blk >> 24);
#line 3464
      c->Request.CDB[7] = (__u8 )(start_blk >> 16);
#line 3465
      c->Request.CDB[8] = (__u8 )(start_blk >> 8);
#line 3466
      c->Request.CDB[9] = (__u8 )start_blk;
#line 3467
      tmp___10 = blk_rq_sectors((struct request  const  *)creq);
#line 3467
      c->Request.CDB[10] = (__u8 )(tmp___10 >> 24);
#line 3468
      tmp___11 = blk_rq_sectors((struct request  const  *)creq);
#line 3468
      c->Request.CDB[11] = (__u8 )(tmp___11 >> 16);
#line 3469
      tmp___12 = blk_rq_sectors((struct request  const  *)creq);
#line 3469
      c->Request.CDB[12] = (__u8 )(tmp___12 >> 8);
#line 3470
      tmp___13 = blk_rq_sectors((struct request  const  *)creq);
#line 3470
      c->Request.CDB[13] = (__u8 )tmp___13;
#line 3471
      tmp___14 = 0U;
#line 3471
      c->Request.CDB[15] = tmp___14;
#line 3471
      c->Request.CDB[14] = tmp___14;
    }
  } else
#line 3473
  if ((unsigned int )creq->cmd_type == 2U) {
#line 3474
    c->Request.CDBLen = (__u8 )creq->cmd_len;
#line 3475
    __len___0 = 16UL;
#line 3475
    if (__len___0 > 63UL) {
#line 3475
      __ret___0 = __memcpy((void *)(& c->Request.CDB), (void const   *)creq->cmd,
                           __len___0);
    } else {
#line 3475
      __ret___0 = __builtin_memcpy((void *)(& c->Request.CDB), (void const   *)creq->cmd,
                                   __len___0);
    }
  } else {
#line 3477
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "bad request type %d\n",
             (unsigned int )creq->cmd_type);
#line 3479
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"),
                         "i" (3479), "i" (12UL));
    ldv_37494: ;
#line 3479
    goto ldv_37494;
  }
#line 3482
  spin_lock_irq(q->queue_lock);
#line 3484
  addQ(& h->reqQ, c);
#line 3485
  h->Qdepth = h->Qdepth + 1U;
#line 3486
  if (h->Qdepth > h->maxQsinceinit) {
#line 3487
    h->maxQsinceinit = h->Qdepth;
  } else {

  }
#line 3489
  goto queue;
  full: 
#line 3491
  blk_stop_queue(q);
  startio: 
#line 3496
  start_io(h);
#line 3497
  return;
}
}
#line 3499 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static unsigned long get_next_completion(ctlr_info_t *h ) 
{ 
  unsigned long tmp ;

  {
#line 3501
  tmp = (*(h->access.command_completed))(h);
#line 3501
  return (tmp);
}
}
#line 3504 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static int interrupt_pending(ctlr_info_t *h ) 
{ 
  bool tmp ;

  {
#line 3506
  tmp = (*(h->access.intr_pending))(h);
#line 3506
  return ((int )tmp);
}
}
#line 3509 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static long interrupt_not_for_us(ctlr_info_t *h ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 3511
  tmp = (*(h->access.intr_pending))(h);
#line 3511
  if (tmp) {
#line 3511
    tmp___0 = 0;
  } else {
#line 3511
    tmp___0 = 1;
  }
#line 3511
  return ((long )(tmp___0 || h->interrupts_enabled == 0));
}
}
#line 3515 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static int bad_tag(ctlr_info_t *h , u32 tag_index , u32 raw_tag ) 
{ 
  long tmp ;

  {
#line 3518
  tmp = ldv__builtin_expect((u32 )h->nr_cmds <= tag_index, 0L);
#line 3518
  if (tmp != 0L) {
#line 3519
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "bad tag 0x%08x ignored.\n",
             raw_tag);
#line 3520
    return (1);
  } else {

  }
#line 3522
  return (0);
}
}
#line 3525 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void finish_cmd(ctlr_info_t *h , CommandList_struct *c , u32 raw_tag ) 
{ 
  long tmp ;

  {
#line 3528
  removeQ(c);
#line 3529
  tmp = ldv__builtin_expect(c->cmd_type == 0, 1L);
#line 3529
  if (tmp != 0L) {
#line 3530
    complete_command(h, c, 0);
  } else
#line 3531
  if (c->cmd_type == 1) {
#line 3532
    complete(c->waiting);
  } else
#line 3534
  if (c->cmd_type == 3) {
#line 3535
    complete_scsi_command(c, 0, raw_tag);
  } else {

  }
#line 3536
  return;
}
}
#line 3539 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 next_command(ctlr_info_t *h ) 
{ 
  u32 a ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 3543
  tmp___0 = ldv__builtin_expect((h->transMethod & 4UL) == 0UL, 0L);
#line 3543
  if (tmp___0 != 0L) {
#line 3544
    tmp = (*(h->access.command_completed))(h);
#line 3544
    return ((u32 )tmp);
  } else {

  }
#line 3546
  if ((*(h->reply_pool_head) & 1ULL) == (u64 )h->reply_pool_wraparound) {
#line 3547
    a = (u32 )*(h->reply_pool_head);
#line 3548
    h->reply_pool_head = h->reply_pool_head + 1;
#line 3549
    h->commands_outstanding = h->commands_outstanding - 1;
  } else {
#line 3551
    a = 4294967295U;
  }
#line 3554
  if ((unsigned long )h->reply_pool_head == (unsigned long )(h->reply_pool + (unsigned long )h->max_commands)) {
#line 3555
    h->reply_pool_head = h->reply_pool;
#line 3556
    h->reply_pool_wraparound = (unsigned int )h->reply_pool_wraparound ^ 1U;
  } else {

  }
#line 3558
  return (a);
}
}
#line 3562 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 process_indexed_cmd(ctlr_info_t *h , u32 raw_tag ) 
{ 
  u32 tag_index ;
  CommandList_struct *c ;
  u32 tmp ;
  int tmp___0 ;
  u32 tmp___1 ;

  {
#line 3567
  tag_index = cciss_tag_to_index(raw_tag);
#line 3568
  tmp___0 = bad_tag(h, tag_index, raw_tag);
#line 3568
  if (tmp___0 != 0) {
#line 3569
    tmp = next_command(h);
#line 3569
    return (tmp);
  } else {

  }
#line 3570
  c = h->cmd_pool + (unsigned long )tag_index;
#line 3571
  finish_cmd(h, c, raw_tag);
#line 3572
  tmp___1 = next_command(h);
#line 3572
  return (tmp___1);
}
}
#line 3576 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static u32 process_nonindexed_cmd(ctlr_info_t *h , u32 raw_tag ) 
{ 
  CommandList_struct *c ;
  __u32 busaddr_masked ;
  __u32 tag_masked ;
  struct list_head  const  *__mptr ;
  u32 tmp ;
  struct list_head  const  *__mptr___0 ;
  u32 tmp___0 ;

  {
#line 3578
  c = 0;
#line 3581
  tag_masked = cciss_tag_discard_error_bits(h, raw_tag);
#line 3582
  __mptr = (struct list_head  const  *)h->cmpQ.next;
#line 3582
  c = (CommandList_struct *)__mptr + 0xfffffffffffffdb0UL;
#line 3582
  goto ldv_37536;
  ldv_37535: 
#line 3583
  busaddr_masked = cciss_tag_discard_error_bits(h, c->busaddr);
#line 3584
  if (busaddr_masked == tag_masked) {
#line 3585
    finish_cmd(h, c, raw_tag);
#line 3586
    tmp = next_command(h);
#line 3586
    return (tmp);
  } else {

  }
#line 3582
  __mptr___0 = (struct list_head  const  *)c->list.next;
#line 3582
  c = (CommandList_struct *)__mptr___0 + 0xfffffffffffffdb0UL;
  ldv_37536: ;
#line 3582
  if ((unsigned long )(& c->list) != (unsigned long )(& h->cmpQ)) {
#line 3583
    goto ldv_37535;
  } else {

  }
#line 3589
  bad_tag(h, (u32 )(h->nr_cmds + 1), raw_tag);
#line 3590
  tmp___0 = next_command(h);
#line 3590
  return (tmp___0);
}
}
#line 3598 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int ignore_bogus_interrupt(ctlr_info_t *h ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 3600
  tmp = ldv__builtin_expect(reset_devices == 0U, 1L);
#line 3600
  if (tmp != 0L) {
#line 3601
    return (0);
  } else {

  }
#line 3603
  tmp___0 = ldv__builtin_expect(h->interrupts_enabled != 0, 1L);
#line 3603
  if (tmp___0 != 0L) {
#line 3604
    return (0);
  } else {

  }
#line 3606
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "Received interrupt while interrupts disabled (known firmware bug.)  Ignoring.\n");
#line 3609
  return (1);
}
}
#line 3612 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static irqreturn_t cciss_intx_discard_completions(int irq , void *dev_id ) 
{ 
  ctlr_info_t *h ;
  unsigned long flags ;
  u32 raw_tag ;
  int tmp ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 3614
  h = (ctlr_info_t *)dev_id;
#line 3618
  tmp = ignore_bogus_interrupt(h);
#line 3618
  if (tmp != 0) {
#line 3619
    return (0);
  } else {

  }
#line 3621
  tmp___0 = interrupt_not_for_us(h);
#line 3621
  if (tmp___0 != 0L) {
#line 3622
    return (0);
  } else {

  }
#line 3623
  tmp___1 = spinlock_check(& h->lock);
#line 3623
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 3624
  goto ldv_37555;
  ldv_37554: 
#line 3625
  tmp___2 = get_next_completion(h);
#line 3625
  raw_tag = (u32 )tmp___2;
#line 3626
  goto ldv_37552;
  ldv_37551: 
#line 3627
  raw_tag = next_command(h);
  ldv_37552: ;
#line 3626
  if (raw_tag != 4294967295U) {
#line 3627
    goto ldv_37551;
  } else {

  }

  ldv_37555: 
#line 3624
  tmp___3 = interrupt_pending(h);
#line 3624
  if (tmp___3 != 0) {
#line 3625
    goto ldv_37554;
  } else {

  }
#line 3629
  spin_unlock_irqrestore(& h->lock, flags);
#line 3630
  return (1);
}
}
#line 3633 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static irqreturn_t cciss_msix_discard_completions(int irq , void *dev_id ) 
{ 
  ctlr_info_t *h ;
  unsigned long flags ;
  u32 raw_tag ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 3635
  h = (ctlr_info_t *)dev_id;
#line 3639
  tmp = ignore_bogus_interrupt(h);
#line 3639
  if (tmp != 0) {
#line 3640
    return (0);
  } else {

  }
#line 3642
  tmp___0 = spinlock_check(& h->lock);
#line 3642
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3643
  tmp___1 = get_next_completion(h);
#line 3643
  raw_tag = (u32 )tmp___1;
#line 3644
  goto ldv_37568;
  ldv_37567: 
#line 3645
  raw_tag = next_command(h);
  ldv_37568: ;
#line 3644
  if (raw_tag != 4294967295U) {
#line 3645
    goto ldv_37567;
  } else {

  }
#line 3646
  spin_unlock_irqrestore(& h->lock, flags);
#line 3647
  return (1);
}
}
#line 3650 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static irqreturn_t do_cciss_intx(int irq , void *dev_id ) 
{ 
  ctlr_info_t *h ;
  unsigned long flags ;
  u32 raw_tag ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;
  unsigned long tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;

  {
#line 3652
  h = (ctlr_info_t *)dev_id;
#line 3656
  tmp = interrupt_not_for_us(h);
#line 3656
  if (tmp != 0L) {
#line 3657
    return (0);
  } else {

  }
#line 3658
  tmp___0 = spinlock_check(& h->lock);
#line 3658
  flags = _raw_spin_lock_irqsave(tmp___0);
#line 3659
  goto ldv_37584;
  ldv_37583: 
#line 3660
  tmp___1 = get_next_completion(h);
#line 3660
  raw_tag = (u32 )tmp___1;
#line 3661
  goto ldv_37581;
  ldv_37580: 
#line 3662
  tmp___2 = cciss_tag_contains_index(raw_tag);
#line 3662
  if (tmp___2 != 0U) {
#line 3663
    raw_tag = process_indexed_cmd(h, raw_tag);
  } else {
#line 3665
    raw_tag = process_nonindexed_cmd(h, raw_tag);
  }
  ldv_37581: ;
#line 3661
  if (raw_tag != 4294967295U) {
#line 3662
    goto ldv_37580;
  } else {

  }

  ldv_37584: 
#line 3659
  tmp___3 = interrupt_pending(h);
#line 3659
  if (tmp___3 != 0) {
#line 3660
    goto ldv_37583;
  } else {

  }
#line 3668
  spin_unlock_irqrestore(& h->lock, flags);
#line 3669
  return (1);
}
}
#line 3675 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static irqreturn_t do_cciss_msix_intr(int irq , void *dev_id ) 
{ 
  ctlr_info_t *h ;
  unsigned long flags ;
  u32 raw_tag ;
  raw_spinlock_t *tmp ;
  unsigned long tmp___0 ;
  u32 tmp___1 ;

  {
#line 3677
  h = (ctlr_info_t *)dev_id;
#line 3681
  tmp = spinlock_check(& h->lock);
#line 3681
  flags = _raw_spin_lock_irqsave(tmp);
#line 3682
  tmp___0 = get_next_completion(h);
#line 3682
  raw_tag = (u32 )tmp___0;
#line 3683
  goto ldv_37597;
  ldv_37596: 
#line 3684
  tmp___1 = cciss_tag_contains_index(raw_tag);
#line 3684
  if (tmp___1 != 0U) {
#line 3685
    raw_tag = process_indexed_cmd(h, raw_tag);
  } else {
#line 3687
    raw_tag = process_nonindexed_cmd(h, raw_tag);
  }
  ldv_37597: ;
#line 3683
  if (raw_tag != 4294967295U) {
#line 3684
    goto ldv_37596;
  } else {

  }
#line 3689
  spin_unlock_irqrestore(& h->lock, flags);
#line 3690
  return (1);
}
}
#line 3703 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int add_to_scan_list(struct ctlr_info *h ) 
{ 
  struct ctlr_info *test_h ;
  int found ;
  int ret ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 3706
  found = 0;
#line 3707
  ret = 0;
#line 3709
  if (h->busy_initializing != 0) {
#line 3710
    return (0);
  } else {

  }
#line 3712
  tmp = ldv_mutex_trylock_14(& h->busy_shutting_down);
#line 3712
  if (tmp == 0) {
#line 3713
    return (0);
  } else {

  }
#line 3715
  ldv_mutex_lock_15(& scan_mutex);
#line 3716
  __mptr = (struct list_head  const  *)scan_q.next;
#line 3716
  test_h = (struct ctlr_info *)__mptr + 0xffffffffffffbda8UL;
#line 3716
  goto ldv_37611;
  ldv_37610: ;
#line 3717
  if ((unsigned long )test_h == (unsigned long )h) {
#line 3718
    found = 1;
#line 3719
    goto ldv_37609;
  } else {

  }
#line 3716
  __mptr___0 = (struct list_head  const  *)test_h->scan_list.next;
#line 3716
  test_h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbda8UL;
  ldv_37611: ;
#line 3716
  if ((unsigned long )(& test_h->scan_list) != (unsigned long )(& scan_q)) {
#line 3717
    goto ldv_37610;
  } else {

  }
  ldv_37609: ;
#line 3722
  if (found == 0 && h->busy_scanning == 0) {
#line 3723
    h->scan_wait.done = 0U;
#line 3724
    list_add_tail(& h->scan_list, & scan_q);
#line 3725
    ret = 1;
  } else {

  }
#line 3727
  ldv_mutex_unlock_16(& scan_mutex);
#line 3728
  ldv_mutex_unlock_17(& h->busy_shutting_down);
#line 3730
  return (ret);
}
}
#line 3746 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void remove_from_scan_list(struct ctlr_info *h ) 
{ 
  struct ctlr_info *test_h ;
  struct ctlr_info *tmp_h ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 3750
  ldv_mutex_lock_18(& scan_mutex);
#line 3751
  __mptr = (struct list_head  const  *)scan_q.next;
#line 3751
  test_h = (struct ctlr_info *)__mptr + 0xffffffffffffbda8UL;
#line 3751
  __mptr___0 = (struct list_head  const  *)test_h->scan_list.next;
#line 3751
  tmp_h = (struct ctlr_info *)__mptr___0 + 0xffffffffffffbda8UL;
#line 3751
  goto ldv_37624;
  ldv_37623: ;
#line 3752
  if ((unsigned long )test_h == (unsigned long )h) {
#line 3753
    list_del(& h->scan_list);
#line 3754
    complete_all(& h->scan_wait);
#line 3755
    ldv_mutex_unlock_19(& scan_mutex);
#line 3756
    return;
  } else {

  }
#line 3751
  test_h = tmp_h;
#line 3751
  __mptr___1 = (struct list_head  const  *)tmp_h->scan_list.next;
#line 3751
  tmp_h = (struct ctlr_info *)__mptr___1 + 0xffffffffffffbda8UL;
  ldv_37624: ;
#line 3751
  if ((unsigned long )(& test_h->scan_list) != (unsigned long )(& scan_q)) {
#line 3752
    goto ldv_37623;
  } else {

  }

#line 3759
  if (h->busy_scanning != 0) {
#line 3760
    ldv_mutex_unlock_20(& scan_mutex);
#line 3761
    wait_for_completion(& h->scan_wait);
  } else {
#line 3763
    ldv_mutex_unlock_21(& scan_mutex);
  }
#line 3764
  return;
}
}
#line 3779 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int scan_thread(void *data ) 
{ 
  struct ctlr_info *h ;
  long volatile   __ret ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  struct list_head  const  *__mptr ;

  {
  ldv_37643: 
#line 3784
  __ret = 1L;
#line 3784
  switch (8UL) {
  case 1UL: 
#line 3784
  tmp = get_current();
#line 3784
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp->state): : "memory",
                       "cc");
#line 3784
  goto ldv_37632;
  case 2UL: 
#line 3784
  tmp___0 = get_current();
#line 3784
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
#line 3784
  goto ldv_37632;
  case 4UL: 
#line 3784
  tmp___1 = get_current();
#line 3784
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 3784
  goto ldv_37632;
  case 8UL: 
#line 3784
  tmp___2 = get_current();
#line 3784
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 3784
  goto ldv_37632;
  default: 
#line 3784
  __xchg_wrong_size();
  }
  ldv_37632: 
#line 3785
  schedule();
#line 3786
  tmp___3 = kthread_should_stop();
#line 3786
  if ((int )tmp___3) {
#line 3787
    goto ldv_37638;
  } else {

  }
  ldv_37642: 
#line 3790
  ldv_mutex_lock_22(& scan_mutex);
#line 3791
  tmp___4 = list_empty((struct list_head  const  *)(& scan_q));
#line 3791
  if (tmp___4 != 0) {
#line 3792
    ldv_mutex_unlock_23(& scan_mutex);
#line 3793
    goto ldv_37639;
  } else {

  }
#line 3796
  __mptr = (struct list_head  const  *)scan_q.next;
#line 3796
  h = (struct ctlr_info *)__mptr + 0xffffffffffffbda8UL;
#line 3799
  list_del(& h->scan_list);
#line 3800
  h->busy_scanning = 1;
#line 3801
  ldv_mutex_unlock_24(& scan_mutex);
#line 3803
  rebuild_lun_table(h, 0, 0);
#line 3804
  complete_all(& h->scan_wait);
#line 3805
  ldv_mutex_lock_25(& scan_mutex);
#line 3806
  h->busy_scanning = 0;
#line 3807
  ldv_mutex_unlock_26(& scan_mutex);
#line 3808
  goto ldv_37642;
  ldv_37639: ;
#line 3809
  goto ldv_37643;
  ldv_37638: ;
#line 3811
  return (0);
}
}
#line 3814 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int check_for_unit_attention(ctlr_info_t *h , CommandList_struct *c ) 
{ 


  {
#line 3816
  if ((unsigned int )(c->err_info)->SenseInfo[2] != 6U) {
#line 3817
    return (0);
  } else {

  }
#line 3819
  switch ((int )(c->err_info)->SenseInfo[12]) {
  case 42: 
#line 3821
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "a state change detected, command retried\n");
#line 3823
  return (1);
  case 62: 
#line 3826
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "LUN failure detected, action required\n");
#line 3828
  return (1);
  case 63: 
#line 3831
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "report LUN data changed\n");
#line 3848
  return (1);
  case 41: 
#line 3851
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "a power on or device reset detected\n");
#line 3853
  return (1);
  case 47: 
#line 3856
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "unit attention cleared by another initiator\n");
#line 3858
  return (1);
  default: 
#line 3861
  dev_warn((struct device  const  *)(& (h->pdev)->dev), "unknown unit attention detected\n");
#line 3862
  return (1);
  }
}
}
#line 3871 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void print_cfg_table(ctlr_info_t *h ) 
{ 
  int i ;
  char temp_name[17U] ;
  CfgTable_struct *tb ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  unsigned char tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  unsigned int tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___3 ;
  unsigned int tmp___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___4 ;
  unsigned int tmp___7 ;
  long tmp___8 ;
  struct _ddebug descriptor___5 ;
  unsigned int tmp___9 ;
  long tmp___10 ;
  struct _ddebug descriptor___6 ;
  unsigned int tmp___11 ;
  long tmp___12 ;
  struct _ddebug descriptor___7 ;
  unsigned int tmp___13 ;
  long tmp___14 ;
  struct _ddebug descriptor___8 ;
  unsigned int tmp___15 ;
  long tmp___16 ;
  struct _ddebug descriptor___9 ;
  unsigned int tmp___17 ;
  long tmp___18 ;
  unsigned char tmp___19 ;
  struct _ddebug descriptor___10 ;
  long tmp___20 ;
  struct _ddebug descriptor___11 ;
  unsigned int tmp___21 ;
  long tmp___22 ;

  {
#line 3875
  tb = h->cfgtable;
#line 3877
  descriptor.modname = "cciss";
#line 3877
  descriptor.function = "print_cfg_table";
#line 3877
  descriptor.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3877
  descriptor.format = "Controller Configuration information\n";
#line 3877
  descriptor.lineno = 3877U;
#line 3877
  descriptor.flags = 0U;
#line 3877
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3877
  if (tmp != 0L) {
#line 3877
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "Controller Configuration information\n");
  } else {

  }
#line 3878
  descriptor___0.modname = "cciss";
#line 3878
  descriptor___0.function = "print_cfg_table";
#line 3878
  descriptor___0.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3878
  descriptor___0.format = "------------------------------------\n";
#line 3878
  descriptor___0.lineno = 3878U;
#line 3878
  descriptor___0.flags = 0U;
#line 3878
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 3878
  if (tmp___0 != 0L) {
#line 3878
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)(& (h->pdev)->dev),
                      "------------------------------------\n");
  } else {

  }
#line 3879
  i = 0;
#line 3879
  goto ldv_37664;
  ldv_37663: 
#line 3880
  tmp___1 = readb((void const volatile   *)(& tb->Signature) + (unsigned long )i);
#line 3880
  temp_name[i] = (char )tmp___1;
#line 3879
  i = i + 1;
  ldv_37664: ;
#line 3879
  if (i <= 3) {
#line 3880
    goto ldv_37663;
  } else {

  }
#line 3881
  temp_name[4] = 0;
#line 3882
  descriptor___1.modname = "cciss";
#line 3882
  descriptor___1.function = "print_cfg_table";
#line 3882
  descriptor___1.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3882
  descriptor___1.format = "   Signature = %s\n";
#line 3882
  descriptor___1.lineno = 3882U;
#line 3882
  descriptor___1.flags = 0U;
#line 3882
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 3882
  if (tmp___2 != 0L) {
#line 3882
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)(& (h->pdev)->dev),
                      "   Signature = %s\n", (char *)(& temp_name));
  } else {

  }
#line 3883
  descriptor___2.modname = "cciss";
#line 3883
  descriptor___2.function = "print_cfg_table";
#line 3883
  descriptor___2.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3883
  descriptor___2.format = "   Spec Number = %d\n";
#line 3883
  descriptor___2.lineno = 3884U;
#line 3883
  descriptor___2.flags = 0U;
#line 3883
  tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
#line 3883
  if (tmp___4 != 0L) {
#line 3883
    tmp___3 = readl((void const volatile   *)(& tb->SpecValence));
#line 3883
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)(& (h->pdev)->dev),
                      "   Spec Number = %d\n", tmp___3);
  } else {

  }
#line 3885
  descriptor___3.modname = "cciss";
#line 3885
  descriptor___3.function = "print_cfg_table";
#line 3885
  descriptor___3.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3885
  descriptor___3.format = "   Transport methods supported = 0x%x\n";
#line 3885
  descriptor___3.lineno = 3886U;
#line 3885
  descriptor___3.flags = 0U;
#line 3885
  tmp___6 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
#line 3885
  if (tmp___6 != 0L) {
#line 3885
    tmp___5 = readl((void const volatile   *)(& tb->TransportSupport));
#line 3885
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)(& (h->pdev)->dev),
                      "   Transport methods supported = 0x%x\n", tmp___5);
  } else {

  }
#line 3887
  descriptor___4.modname = "cciss";
#line 3887
  descriptor___4.function = "print_cfg_table";
#line 3887
  descriptor___4.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3887
  descriptor___4.format = "   Transport methods active = 0x%x\n";
#line 3887
  descriptor___4.lineno = 3888U;
#line 3887
  descriptor___4.flags = 0U;
#line 3887
  tmp___8 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
#line 3887
  if (tmp___8 != 0L) {
#line 3887
    tmp___7 = readl((void const volatile   *)(& tb->TransportActive));
#line 3887
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)(& (h->pdev)->dev),
                      "   Transport methods active = 0x%x\n", tmp___7);
  } else {

  }
#line 3889
  descriptor___5.modname = "cciss";
#line 3889
  descriptor___5.function = "print_cfg_table";
#line 3889
  descriptor___5.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3889
  descriptor___5.format = "   Requested transport Method = 0x%x\n";
#line 3889
  descriptor___5.lineno = 3890U;
#line 3889
  descriptor___5.flags = 0U;
#line 3889
  tmp___10 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
#line 3889
  if (tmp___10 != 0L) {
#line 3889
    tmp___9 = readl((void const volatile   *)(& tb->HostWrite.TransportRequest));
#line 3889
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)(& (h->pdev)->dev),
                      "   Requested transport Method = 0x%x\n", tmp___9);
  } else {

  }
#line 3891
  descriptor___6.modname = "cciss";
#line 3891
  descriptor___6.function = "print_cfg_table";
#line 3891
  descriptor___6.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3891
  descriptor___6.format = "   Coalesce Interrupt Delay = 0x%x\n";
#line 3891
  descriptor___6.lineno = 3892U;
#line 3891
  descriptor___6.flags = 0U;
#line 3891
  tmp___12 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
#line 3891
  if (tmp___12 != 0L) {
#line 3891
    tmp___11 = readl((void const volatile   *)(& tb->HostWrite.CoalIntDelay));
#line 3891
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)(& (h->pdev)->dev),
                      "   Coalesce Interrupt Delay = 0x%x\n", tmp___11);
  } else {

  }
#line 3893
  descriptor___7.modname = "cciss";
#line 3893
  descriptor___7.function = "print_cfg_table";
#line 3893
  descriptor___7.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3893
  descriptor___7.format = "   Coalesce Interrupt Count = 0x%x\n";
#line 3893
  descriptor___7.lineno = 3894U;
#line 3893
  descriptor___7.flags = 0U;
#line 3893
  tmp___14 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
#line 3893
  if (tmp___14 != 0L) {
#line 3893
    tmp___13 = readl((void const volatile   *)(& tb->HostWrite.CoalIntCount));
#line 3893
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)(& (h->pdev)->dev),
                      "   Coalesce Interrupt Count = 0x%x\n", tmp___13);
  } else {

  }
#line 3895
  descriptor___8.modname = "cciss";
#line 3895
  descriptor___8.function = "print_cfg_table";
#line 3895
  descriptor___8.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3895
  descriptor___8.format = "   Max outstanding commands = 0x%d\n";
#line 3895
  descriptor___8.lineno = 3896U;
#line 3895
  descriptor___8.flags = 0U;
#line 3895
  tmp___16 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
#line 3895
  if (tmp___16 != 0L) {
#line 3895
    tmp___15 = readl((void const volatile   *)(& tb->CmdsOutMax));
#line 3895
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)(& (h->pdev)->dev),
                      "   Max outstanding commands = 0x%d\n", tmp___15);
  } else {

  }
#line 3897
  descriptor___9.modname = "cciss";
#line 3897
  descriptor___9.function = "print_cfg_table";
#line 3897
  descriptor___9.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3897
  descriptor___9.format = "   Bus Types = 0x%x\n";
#line 3897
  descriptor___9.lineno = 3898U;
#line 3897
  descriptor___9.flags = 0U;
#line 3897
  tmp___18 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
#line 3897
  if (tmp___18 != 0L) {
#line 3897
    tmp___17 = readl((void const volatile   *)(& tb->BusTypes));
#line 3897
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)(& (h->pdev)->dev),
                      "   Bus Types = 0x%x\n", tmp___17);
  } else {

  }
#line 3899
  i = 0;
#line 3899
  goto ldv_37676;
  ldv_37675: 
#line 3900
  tmp___19 = readb((void const volatile   *)(& tb->ServerName) + (unsigned long )i);
#line 3900
  temp_name[i] = (char )tmp___19;
#line 3899
  i = i + 1;
  ldv_37676: ;
#line 3899
  if (i <= 15) {
#line 3900
    goto ldv_37675;
  } else {

  }
#line 3901
  temp_name[16] = 0;
#line 3902
  descriptor___10.modname = "cciss";
#line 3902
  descriptor___10.function = "print_cfg_table";
#line 3902
  descriptor___10.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3902
  descriptor___10.format = "   Server Name = %s\n";
#line 3902
  descriptor___10.lineno = 3902U;
#line 3902
  descriptor___10.flags = 0U;
#line 3902
  tmp___20 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
#line 3902
  if (tmp___20 != 0L) {
#line 3902
    __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)(& (h->pdev)->dev),
                      "   Server Name = %s\n", (char *)(& temp_name));
  } else {

  }
#line 3903
  descriptor___11.modname = "cciss";
#line 3903
  descriptor___11.function = "print_cfg_table";
#line 3903
  descriptor___11.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 3903
  descriptor___11.format = "   Heartbeat Counter = 0x%x\n\n\n";
#line 3903
  descriptor___11.lineno = 3904U;
#line 3903
  descriptor___11.flags = 0U;
#line 3903
  tmp___22 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
#line 3903
  if (tmp___22 != 0L) {
#line 3903
    tmp___21 = readl((void const volatile   *)(& tb->HeartBeat));
#line 3903
    __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)(& (h->pdev)->dev),
                      "   Heartbeat Counter = 0x%x\n\n\n", tmp___21);
  } else {

  }
#line 3905
  return;
}
}
#line 3907 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int find_PCI_BAR_index(struct pci_dev *pdev , unsigned long pci_bar_addr ) 
{ 
  int i ;
  int offset ;
  int mem_type ;
  int bar_type ;

  {
#line 3910
  if (pci_bar_addr == 16UL) {
#line 3911
    return (0);
  } else {

  }
#line 3912
  offset = 0;
#line 3913
  i = 0;
#line 3913
  goto ldv_37694;
  ldv_37693: 
#line 3914
  bar_type = (int )pdev->resource[i].flags & 1;
#line 3915
  if (bar_type == 1) {
#line 3916
    offset = offset + 4;
  } else {
#line 3918
    mem_type = (int )pdev->resource[i].flags & 6;
#line 3920
    switch (mem_type) {
    case 0: ;
    case 2: 
#line 3923
    offset = offset + 4;
#line 3924
    goto ldv_37690;
    case 4: 
#line 3926
    offset = offset + 8;
#line 3927
    goto ldv_37690;
    default: 
#line 3929
    dev_warn((struct device  const  *)(& pdev->dev), "Base address is invalid\n");
#line 3931
    return (-1);
    }
    ldv_37690: ;
  }
#line 3935
  if ((unsigned long )offset == pci_bar_addr - 16UL) {
#line 3936
    return (i + 1);
  } else {

  }
#line 3913
  i = i + 1;
  ldv_37694: ;
#line 3913
  if (i <= 16) {
#line 3914
    goto ldv_37693;
  } else {

  }

#line 3938
  return (-1);
}
}
#line 3953 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void calc_bucket_map(int *bucket , int num_buckets , int nsgs , int *bucket_map ) 
{ 
  int i ;
  int j ;
  int b ;
  int size ;

  {
#line 3962
  i = 0;
#line 3962
  goto ldv_37710;
  ldv_37709: 
#line 3964
  size = i + 4;
#line 3965
  b = num_buckets;
#line 3967
  j = 0;
#line 3967
  goto ldv_37708;
  ldv_37707: ;
#line 3968
  if (*(bucket + (unsigned long )j) >= size) {
#line 3969
    b = j;
#line 3970
    goto ldv_37706;
  } else {

  }
#line 3967
  j = j + 1;
  ldv_37708: ;
#line 3967
  if (j <= 7) {
#line 3968
    goto ldv_37707;
  } else {

  }
  ldv_37706: 
#line 3974
  *(bucket_map + (unsigned long )i) = b;
#line 3962
  i = i + 1;
  ldv_37710: ;
#line 3962
  if (i <= nsgs) {
#line 3963
    goto ldv_37709;
  } else {

  }

#line 3967
  return;
}
}
#line 3978 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_wait_for_mode_change_ack(ctlr_info_t *h ) 
{ 
  int i ;
  unsigned int tmp ;

  {
#line 3985
  i = 0;
#line 3985
  goto ldv_37718;
  ldv_37717: 
#line 3986
  tmp = readl((void const volatile   *)h->vaddr + 32U);
#line 3986
  if (((long )tmp & 1L) == 0L) {
#line 3987
    goto ldv_37716;
  } else {

  }
#line 3988
  usleep_range(10000UL, 20000UL);
#line 3985
  i = i + 1;
  ldv_37718: ;
#line 3985
  if (i <= 29999) {
#line 3986
    goto ldv_37717;
  } else {

  }
  ldv_37716: ;
#line 3990
  return;
}
}
#line 3992 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_enter_performant_mode(ctlr_info_t *h , u32 use_short_tags ) 
{ 
  __u32 trans_offset ;
  int bft[8U] ;
  unsigned long register_value ;
  unsigned int tmp ;

  {
#line 4013
  bft[0] = 5;
#line 4013
  bft[1] = 6;
#line 4013
  bft[2] = 8;
#line 4013
  bft[3] = 10;
#line 4013
  bft[4] = 12;
#line 4013
  bft[5] = 20;
#line 4013
  bft[6] = 28;
#line 4013
  bft[7] = 36;
#line 4023
  h->reply_pool_wraparound = 1U;
#line 4026
  memset((void *)h->reply_pool, 0, (unsigned long )h->max_commands * 8UL);
#line 4027
  h->reply_pool_head = h->reply_pool;
#line 4029
  trans_offset = readl((void const volatile   *)(& (h->cfgtable)->TransMethodOffset));
#line 4030
  calc_bucket_map((int *)(& bft), 8, h->maxsgentries, (int *)h->blockFetchTable);
#line 4032
  writel((unsigned int )bft[0], (void volatile   *)(& (h->transtable)->BlockFetch0));
#line 4033
  writel((unsigned int )bft[1], (void volatile   *)(& (h->transtable)->BlockFetch1));
#line 4034
  writel((unsigned int )bft[2], (void volatile   *)(& (h->transtable)->BlockFetch2));
#line 4035
  writel((unsigned int )bft[3], (void volatile   *)(& (h->transtable)->BlockFetch3));
#line 4036
  writel((unsigned int )bft[4], (void volatile   *)(& (h->transtable)->BlockFetch4));
#line 4037
  writel((unsigned int )bft[5], (void volatile   *)(& (h->transtable)->BlockFetch5));
#line 4038
  writel((unsigned int )bft[6], (void volatile   *)(& (h->transtable)->BlockFetch6));
#line 4039
  writel((unsigned int )bft[7], (void volatile   *)(& (h->transtable)->BlockFetch7));
#line 4042
  writel((unsigned int )h->max_commands, (void volatile   *)(& (h->transtable)->RepQSize));
#line 4043
  writel(1U, (void volatile   *)(& (h->transtable)->RepQCount));
#line 4044
  writel(0U, (void volatile   *)(& (h->transtable)->RepQCtrAddrLow32));
#line 4045
  writel(0U, (void volatile   *)(& (h->transtable)->RepQCtrAddrHigh32));
#line 4046
  writel((unsigned int )h->reply_pool_dhandle, (void volatile   *)(& (h->transtable)->RepQAddr0Low32));
#line 4047
  writel(0U, (void volatile   *)(& (h->transtable)->RepQAddr0High32));
#line 4048
  writel(use_short_tags | 4U, (void volatile   *)(& (h->cfgtable)->HostWrite.TransportRequest));
#line 4051
  writel(1U, (void volatile   *)h->vaddr + 32U);
#line 4052
  cciss_wait_for_mode_change_ack(h);
#line 4053
  tmp = readl((void const volatile   *)(& (h->cfgtable)->TransportActive));
#line 4053
  register_value = (unsigned long )tmp;
#line 4054
  if ((register_value & 4UL) == 0UL) {
#line 4055
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "cciss: unable to get board into performant mode\n");
  } else {

  }
#line 4056
  return;
}
}
#line 4059 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_put_controller_into_performant_mode(ctlr_info_t *h ) 
{ 
  __u32 trans_support ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 4063
  if (cciss_simple_mode != 0) {
#line 4064
    return;
  } else {

  }
#line 4066
  descriptor.modname = "cciss";
#line 4066
  descriptor.function = "cciss_put_controller_into_performant_mode";
#line 4066
  descriptor.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4066
  descriptor.format = "Trying to put board into Performant mode\n";
#line 4066
  descriptor.lineno = 4066U;
#line 4066
  descriptor.flags = 0U;
#line 4066
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4066
  if (tmp != 0L) {
#line 4066
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "Trying to put board into Performant mode\n");
  } else {

  }
#line 4069
  trans_support = readl((void const volatile   *)(& (h->cfgtable)->TransportSupport));
#line 4070
  if ((trans_support & 4U) == 0U) {
#line 4071
    return;
  } else {

  }
#line 4073
  descriptor___0.modname = "cciss";
#line 4073
  descriptor___0.function = "cciss_put_controller_into_performant_mode";
#line 4073
  descriptor___0.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4073
  descriptor___0.format = "Placing controller into performant mode\n";
#line 4073
  descriptor___0.lineno = 4073U;
#line 4073
  descriptor___0.flags = 0U;
#line 4073
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4073
  if (tmp___0 != 0L) {
#line 4073
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)(& (h->pdev)->dev),
                      "Placing controller into performant mode\n");
  } else {

  }
#line 4087
  tmp___1 = pci_alloc_consistent(h->pdev, (unsigned long )h->max_commands * 8UL, & h->reply_pool_dhandle);
#line 4087
  h->reply_pool = (u64 *)tmp___1;
#line 4092
  tmp___2 = kmalloc((unsigned long )(h->maxsgentries + 1) * 4UL, 208U);
#line 4092
  h->blockFetchTable = (u32 *)tmp___2;
#line 4095
  if ((unsigned long )h->reply_pool == (unsigned long )((u64 *)0) || (unsigned long )h->blockFetchTable == (unsigned long )((u32 *)0)) {
#line 4096
    goto clean_up;
  } else {

  }
#line 4098
  cciss_enter_performant_mode(h, trans_support & 536870912U);
#line 4102
  h->access = SA5_performant_access;
#line 4103
  h->transMethod = 4UL;
#line 4105
  return;
  clean_up: 
#line 4107
  kfree((void const   *)h->blockFetchTable);
#line 4108
  if ((unsigned long )h->reply_pool != (unsigned long )((u64 *)0)) {
#line 4109
    pci_free_consistent(h->pdev, (unsigned long )h->max_commands * 8UL, (void *)h->reply_pool,
                        h->reply_pool_dhandle);
  } else {

  }
#line 4113
  return;
}
}
#line 4121 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_interrupt_mode(ctlr_info_t *h ) 
{ 
  int err ;
  struct msix_entry cciss_msix_entries[4U] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4125
  cciss_msix_entries[0].vector = 0U;
#line 4125
  cciss_msix_entries[0].entry = 0U;
#line 4125
  cciss_msix_entries[1].vector = 0U;
#line 4125
  cciss_msix_entries[1].entry = 1U;
#line 4125
  cciss_msix_entries[2].vector = 0U;
#line 4125
  cciss_msix_entries[2].entry = 2U;
#line 4125
  cciss_msix_entries[3].vector = 0U;
#line 4125
  cciss_msix_entries[3].entry = 3U;
#line 4130
  if (((h->board_id == 1081085457U || h->board_id == 1082134033U) || h->board_id == 1082265105U) || h->board_id == 1082330641U) {
#line 4132
    goto default_int_mode;
  } else {

  }
#line 4134
  tmp = pci_find_capability(h->pdev, 17);
#line 4134
  if (tmp != 0) {
#line 4135
    err = pci_enable_msix(h->pdev, (struct msix_entry *)(& cciss_msix_entries), 4);
#line 4136
    if (err == 0) {
#line 4137
      h->intr[0] = cciss_msix_entries[0].vector;
#line 4138
      h->intr[1] = cciss_msix_entries[1].vector;
#line 4139
      h->intr[2] = cciss_msix_entries[2].vector;
#line 4140
      h->intr[3] = cciss_msix_entries[3].vector;
#line 4141
      h->msix_vector = 1U;
#line 4142
      return;
    } else {

    }
#line 4144
    if (err > 0) {
#line 4145
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "only %d MSI-X vectors available\n",
               err);
#line 4147
      goto default_int_mode;
    } else {
#line 4149
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "MSI-X init failed %d\n",
               err);
#line 4151
      goto default_int_mode;
    }
  } else {

  }
#line 4154
  tmp___1 = pci_find_capability(h->pdev, 5);
#line 4154
  if (tmp___1 != 0) {
#line 4155
    tmp___0 = pci_enable_msi_block(h->pdev, 1U);
#line 4155
    if (tmp___0 == 0) {
#line 4156
      h->msi_vector = 1U;
    } else {
#line 4158
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "MSI init failed\n");
    }
  } else {

  }
  default_int_mode: 
#line 4163
  h->intr[h->intr_mode] = (h->pdev)->irq;
#line 4164
  return;
}
}
#line 4167 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_lookup_board_id(struct pci_dev *pdev , u32 *board_id ) 
{ 
  int i ;
  u32 subsystem_vendor_id ;
  u32 subsystem_device_id ;

  {
#line 4172
  subsystem_vendor_id = (u32 )pdev->subsystem_vendor;
#line 4173
  subsystem_device_id = (u32 )pdev->subsystem_device;
#line 4174
  *board_id = (subsystem_device_id << 16) | subsystem_vendor_id;
#line 4177
  i = 0;
#line 4177
  goto ldv_37752;
  ldv_37751: ;
#line 4178
  if (*board_id == products[i].board_id) {
#line 4179
    return (i);
  } else {

  }
#line 4177
  i = i + 1;
  ldv_37752: ;
#line 4177
  if ((unsigned int )i <= 21U) {
#line 4178
    goto ldv_37751;
  } else {

  }
#line 4180
  dev_warn((struct device  const  *)(& pdev->dev), "unrecognized board ID: 0x%08x, ignoring.\n",
           *board_id);
#line 4182
  return (-19);
}
}
#line 4185 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static bool cciss_board_disabled(ctlr_info_t *h ) 
{ 
  u16 command ;

  {
#line 4189
  pci_read_config_word((struct pci_dev  const  *)h->pdev, 4, & command);
#line 4190
  return (((int )command & 2) == 0);
}
}
#line 4193 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_pci_find_memory_BAR(struct pci_dev *pdev , unsigned long *memory_bar ) 
{ 
  int i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 4198
  i = 0;
#line 4198
  goto ldv_37766;
  ldv_37765: ;
#line 4199
  if ((pdev->resource[i].flags & 512UL) != 0UL) {
#line 4201
    *memory_bar = (unsigned long )pdev->resource[i].start;
#line 4202
    descriptor.modname = "cciss";
#line 4202
    descriptor.function = "cciss_pci_find_memory_BAR";
#line 4202
    descriptor.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4202
    descriptor.format = "memory BAR = %lx\n";
#line 4202
    descriptor.lineno = 4203U;
#line 4202
    descriptor.flags = 0U;
#line 4202
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4202
    if (tmp != 0L) {
#line 4202
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& pdev->dev), "memory BAR = %lx\n",
                        *memory_bar);
    } else {

    }
#line 4204
    return (0);
  } else {

  }
#line 4198
  i = i + 1;
  ldv_37766: ;
#line 4198
  if (i <= 16) {
#line 4199
    goto ldv_37765;
  } else {

  }
#line 4206
  dev_warn((struct device  const  *)(& pdev->dev), "no memory BAR found\n");
#line 4207
  return (-19);
}
}
#line 4210 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_wait_for_board_state(struct pci_dev *pdev , void *vaddr , int wait_for_ready ) 
{ 
  int i ;
  int iterations ;
  u32 scratchpad ;

  {
#line 4218
  if (wait_for_ready != 0) {
#line 4219
    iterations = 1200;
  } else {
#line 4221
    iterations = 1000;
  }
#line 4223
  i = 0;
#line 4223
  goto ldv_37777;
  ldv_37776: 
#line 4224
  scratchpad = readl((void const volatile   *)vaddr + 176U);
#line 4225
  if (wait_for_ready != 0) {
#line 4226
    if (scratchpad == 4294901760U) {
#line 4227
      return (0);
    } else
#line 4229
    if (scratchpad != 4294901760U) {
#line 4230
      return (0);
    } else {

    }
  } else {

  }
#line 4232
  msleep(100U);
#line 4223
  i = i + 1;
  ldv_37777: ;
#line 4223
  if (i < iterations) {
#line 4224
    goto ldv_37776;
  } else {

  }
#line 4234
  dev_warn((struct device  const  *)(& pdev->dev), "board not ready, timed out.\n");
#line 4235
  return (-19);
}
}
#line 4238 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_find_cfg_addrs(struct pci_dev *pdev , void *vaddr , u32 *cfg_base_addr ,
                                u64 *cfg_base_addr_index , u64 *cfg_offset ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 4242
  *cfg_base_addr = readl((void const volatile   *)vaddr + 180U);
#line 4243
  tmp = readl((void const volatile   *)vaddr + 184U);
#line 4243
  *cfg_offset = (u64 )tmp;
#line 4244
  *cfg_base_addr = *cfg_base_addr & 65535U;
#line 4245
  tmp___0 = find_PCI_BAR_index(pdev, (unsigned long )*cfg_base_addr);
#line 4245
  *cfg_base_addr_index = (u64 )tmp___0;
#line 4246
  if (*cfg_base_addr_index == 0xffffffffffffffffULL) {
#line 4247
    dev_warn((struct device  const  *)(& pdev->dev), "cannot find cfg_base_addr_index, *cfg_base_addr = 0x%08x\n",
             *cfg_base_addr);
#line 4249
    return (-19);
  } else {

  }
#line 4251
  return (0);
}
}
#line 4254 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_find_cfgtables(ctlr_info_t *h ) 
{ 
  u64 cfg_offset ;
  u32 cfg_base_addr ;
  u64 cfg_base_addr_index ;
  u32 trans_offset ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 4262
  rc = cciss_find_cfg_addrs(h->pdev, h->vaddr, & cfg_base_addr, & cfg_base_addr_index,
                            & cfg_offset);
#line 4264
  if (rc != 0) {
#line 4265
    return (rc);
  } else {

  }
#line 4266
  tmp = remap_pci_mem((ulong )((h->pdev)->resource[cfg_base_addr_index].start + cfg_offset),
                      8UL);
#line 4266
  h->cfgtable = (CfgTable_struct *)tmp;
#line 4268
  if ((unsigned long )h->cfgtable == (unsigned long )((CfgTable_struct *)0)) {
#line 4269
    return (-12);
  } else {

  }
#line 4270
  rc = write_driver_ver_to_cfgtable(h->cfgtable);
#line 4271
  if (rc != 0) {
#line 4272
    return (rc);
  } else {

  }
#line 4274
  trans_offset = readl((void const volatile   *)(& (h->cfgtable)->TransMethodOffset));
#line 4275
  tmp___0 = remap_pci_mem((ulong )(((h->pdev)->resource[cfg_base_addr_index].start + cfg_offset) + (unsigned long long )trans_offset),
                          56UL);
#line 4275
  h->transtable = (struct TransTable_struct *)tmp___0;
#line 4278
  if ((unsigned long )h->transtable == (unsigned long )((struct TransTable_struct *)0)) {
#line 4279
    return (-12);
  } else {

  }
#line 4280
  return (0);
}
}
#line 4283 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_get_max_perf_mode_cmds(struct ctlr_info *h ) 
{ 
  unsigned int tmp ;

  {
#line 4285
  tmp = readl((void const volatile   *)(& (h->cfgtable)->MaxPerformantModeCommands));
#line 4285
  h->max_commands = (int )tmp;
#line 4288
  if (reset_devices != 0U && h->max_commands > 32) {
#line 4289
    h->max_commands = 32;
  } else {

  }
#line 4291
  if (h->max_commands <= 15) {
#line 4292
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Controller reports max supported commands of %d, an obvious lie. Using 16.  Ensure that firmware is up to date.\n",
             h->max_commands);
#line 4296
    h->max_commands = 16;
  } else {

  }
#line 4298
  return;
}
}
#line 4304 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_find_board_params(ctlr_info_t *h ) 
{ 
  unsigned int tmp ;

  {
#line 4306
  cciss_get_max_perf_mode_cmds(h);
#line 4307
  h->nr_cmds = (h->max_commands + -4) - cciss_tape_cmds;
#line 4308
  tmp = readl((void const volatile   *)(& (h->cfgtable)->MaxSGElements));
#line 4308
  h->maxsgentries = (int )tmp;
#line 4313
  h->max_cmd_sgentries = 31;
#line 4314
  if (h->maxsgentries > 512) {
#line 4315
    h->max_cmd_sgentries = 32;
#line 4316
    h->chainsize = (h->maxsgentries - h->max_cmd_sgentries) + 1;
#line 4317
    h->maxsgentries = h->maxsgentries - 1;
  } else {
#line 4319
    h->maxsgentries = 31;
#line 4320
    h->chainsize = 0;
  }
#line 4322
  return;
}
}
#line 4324 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static bool CISS_signature_present(ctlr_info_t *h ) 
{ 
  int tmp ;

  {
#line 4326
  tmp = check_signature((void const volatile   *)(& (h->cfgtable)->Signature), (unsigned char const   *)"CISS",
                        4);
#line 4326
  if (tmp == 0) {
#line 4327
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "not a valid CISS config table\n");
#line 4328
    return (0);
  } else {

  }
#line 4330
  return (1);
}
}
#line 4334 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void cciss_enable_scsi_prefetch(ctlr_info_t *h ) 
{ 
  u32 prefetch___0 ;

  {
#line 4339
  prefetch___0 = readl((void const volatile   *)(& (h->cfgtable)->SCSI_Prefetch));
#line 4340
  prefetch___0 = prefetch___0 | 256U;
#line 4341
  writel(prefetch___0, (void volatile   *)(& (h->cfgtable)->SCSI_Prefetch));
#line 4342
  return;
}
}
#line 4348 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
__inline static void cciss_p600_dma_prefetch_quirk(ctlr_info_t *h ) 
{ 
  u32 dma_prefetch ;
  __u32 dma_refetch ;

  {
#line 4353
  if (h->board_id != 841289788U) {
#line 4354
    return;
  } else {

  }
#line 4355
  dma_prefetch = readl((void const volatile   *)h->vaddr + 532U);
#line 4356
  dma_prefetch = dma_prefetch | 32768U;
#line 4357
  writel(dma_prefetch, (void volatile   *)h->vaddr + 532U);
#line 4358
  pci_read_config_dword((struct pci_dev  const  *)h->pdev, 64, & dma_refetch);
#line 4359
  dma_refetch = dma_refetch | 1U;
#line 4360
  pci_write_config_dword((struct pci_dev  const  *)h->pdev, 64, dma_refetch);
#line 4361
  return;
}
}
#line 4363 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_pci_init(ctlr_info_t *h ) 
{ 
  int prod_index ;
  int err ;
  bool tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 4367
  prod_index = cciss_lookup_board_id(h->pdev, & h->board_id);
#line 4368
  if (prod_index < 0) {
#line 4369
    return (-19);
  } else {

  }
#line 4370
  h->product_name = products[prod_index].product_name;
#line 4371
  h->access = *(products[prod_index].access);
#line 4373
  tmp = cciss_board_disabled(h);
#line 4373
  if ((int )tmp) {
#line 4374
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "controller appears to be disabled\n");
#line 4375
    return (-19);
  } else {

  }
#line 4378
  pci_disable_link_state(h->pdev, 7);
#line 4381
  err = pci_enable_device(h->pdev);
#line 4382
  if (err != 0) {
#line 4383
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Unable to Enable PCI device\n");
#line 4384
    return (err);
  } else {

  }
#line 4387
  err = pci_request_regions(h->pdev, "cciss");
#line 4388
  if (err != 0) {
#line 4389
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Cannot obtain PCI resources, aborting\n");
#line 4391
    return (err);
  } else {

  }
#line 4394
  descriptor.modname = "cciss";
#line 4394
  descriptor.function = "cciss_pci_init";
#line 4394
  descriptor.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4394
  descriptor.format = "irq = %x\n";
#line 4394
  descriptor.lineno = 4394U;
#line 4394
  descriptor.flags = 0U;
#line 4394
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4394
  if (tmp___0 != 0L) {
#line 4394
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& (h->pdev)->dev), "irq = %x\n",
                      (h->pdev)->irq);
  } else {

  }
#line 4395
  descriptor___0.modname = "cciss";
#line 4395
  descriptor___0.function = "cciss_pci_init";
#line 4395
  descriptor___0.filename = "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared";
#line 4395
  descriptor___0.format = "board_id = %x\n";
#line 4395
  descriptor___0.lineno = 4395U;
#line 4395
  descriptor___0.flags = 0U;
#line 4395
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4395
  if (tmp___1 != 0L) {
#line 4395
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)(& (h->pdev)->dev),
                      "board_id = %x\n", h->board_id);
  } else {

  }
#line 4400
  cciss_interrupt_mode(h);
#line 4401
  err = cciss_pci_find_memory_BAR(h->pdev, & h->paddr);
#line 4402
  if (err != 0) {
#line 4403
    goto err_out_free_res;
  } else {

  }
#line 4404
  h->vaddr = remap_pci_mem(h->paddr, 592UL);
#line 4405
  if ((unsigned long )h->vaddr == (unsigned long )((void *)0)) {
#line 4406
    err = -12;
#line 4407
    goto err_out_free_res;
  } else {

  }
#line 4409
  err = cciss_wait_for_board_state(h->pdev, h->vaddr, 1);
#line 4410
  if (err != 0) {
#line 4411
    goto err_out_free_res;
  } else {

  }
#line 4412
  err = cciss_find_cfgtables(h);
#line 4413
  if (err != 0) {
#line 4414
    goto err_out_free_res;
  } else {

  }
#line 4415
  print_cfg_table(h);
#line 4416
  cciss_find_board_params(h);
#line 4418
  tmp___2 = CISS_signature_present(h);
#line 4418
  if (tmp___2) {
#line 4418
    tmp___3 = 0;
  } else {
#line 4418
    tmp___3 = 1;
  }
#line 4418
  if (tmp___3) {
#line 4419
    err = -19;
#line 4420
    goto err_out_free_res;
  } else {

  }
#line 4422
  cciss_enable_scsi_prefetch(h);
#line 4423
  cciss_p600_dma_prefetch_quirk(h);
#line 4424
  err = cciss_enter_simple_mode(h);
#line 4425
  if (err != 0) {
#line 4426
    goto err_out_free_res;
  } else {

  }
#line 4427
  cciss_put_controller_into_performant_mode(h);
#line 4428
  return (0);
  err_out_free_res: ;
#line 4435
  if ((unsigned long )h->transtable != (unsigned long )((struct TransTable_struct *)0)) {
#line 4436
    iounmap((void volatile   *)h->transtable);
  } else {

  }
#line 4437
  if ((unsigned long )h->cfgtable != (unsigned long )((CfgTable_struct *)0)) {
#line 4438
    iounmap((void volatile   *)h->cfgtable);
  } else {

  }
#line 4439
  if ((unsigned long )h->vaddr != (unsigned long )((void *)0)) {
#line 4440
    iounmap((void volatile   *)h->vaddr);
  } else {

  }
#line 4441
  pci_release_regions(h->pdev);
#line 4442
  return (err);
}
}
#line 4448 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int alloc_cciss_hba(struct pci_dev *pdev ) 
{ 
  int i ;
  ctlr_info_t *h ;
  void *tmp ;

  {
#line 4452
  i = 0;
#line 4452
  goto ldv_37828;
  ldv_37827: ;
#line 4453
  if ((unsigned long )hba[i] == (unsigned long )((ctlr_info_t *)0)) {
#line 4456
    tmp = kzalloc(18304UL, 208U);
#line 4456
    h = (ctlr_info_t *)tmp;
#line 4457
    if ((unsigned long )h == (unsigned long )((ctlr_info_t *)0)) {
#line 4458
      goto Enomem;
    } else {

    }
#line 4459
    hba[i] = h;
#line 4460
    return (i);
  } else {

  }
#line 4452
  i = i + 1;
  ldv_37828: ;
#line 4452
  if (i <= 31) {
#line 4453
    goto ldv_37827;
  } else {

  }
#line 4463
  dev_warn((struct device  const  *)(& pdev->dev), "This driver supports a maximum of %d controllers.\n",
           32);
#line 4465
  return (-1);
  Enomem: 
#line 4467
  dev_warn((struct device  const  *)(& pdev->dev), "out of memory.\n");
#line 4468
  return (-1);
}
}
#line 4471 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void free_hba(ctlr_info_t *h ) 
{ 
  int i ;

  {
#line 4475
  hba[h->ctlr] = 0;
#line 4476
  i = 0;
#line 4476
  goto ldv_37835;
  ldv_37834: ;
#line 4477
  if ((unsigned long )h->gendisk[i] != (unsigned long )((struct gendisk *)0)) {
#line 4478
    put_disk(h->gendisk[i]);
  } else {

  }
#line 4476
  i = i + 1;
  ldv_37835: ;
#line 4476
  if (h->highest_lun + 1 > i) {
#line 4477
    goto ldv_37834;
  } else {

  }
#line 4479
  kfree((void const   *)h);
#line 4480
  return;
}
}
#line 4483 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_message(struct pci_dev *pdev , unsigned char opcode , unsigned char type ) 
{ 
  size_t cmd_sz ;
  Command *cmd ;
  dma_addr_t paddr64 ;
  uint32_t paddr32 ;
  uint32_t tag ;
  void *vaddr ;
  int i ;
  int err ;
  void *tmp ;

  {
#line 4490
  cmd_sz = 100UL;
#line 4497
  vaddr = ioremap_nocache(pdev->resource[0].start, pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start ? (unsigned long )((pdev->resource[0].end - pdev->resource[0].start) + 1ULL) : 0UL);
#line 4498
  if ((unsigned long )vaddr == (unsigned long )((void *)0)) {
#line 4499
    return (-12);
  } else {

  }
#line 4504
  err = pci_set_consistent_dma_mask(pdev, 4294967295ULL);
#line 4505
  if (err != 0) {
#line 4506
    iounmap((void volatile   *)vaddr);
#line 4507
    return (-12);
  } else {

  }
#line 4510
  tmp = pci_alloc_consistent(pdev, cmd_sz, & paddr64);
#line 4510
  cmd = (Command *)tmp;
#line 4511
  if ((unsigned long )cmd == (unsigned long )((Command *)0)) {
#line 4512
    iounmap((void volatile   *)vaddr);
#line 4513
    return (-12);
  } else {

  }
#line 4519
  paddr32 = (uint32_t )paddr64;
#line 4521
  cmd->CommandHeader.ReplyQueue = 0U;
#line 4522
  cmd->CommandHeader.SGList = 0U;
#line 4523
  cmd->CommandHeader.SGTotal = 0U;
#line 4524
  cmd->CommandHeader.Tag.lower = paddr32;
#line 4525
  cmd->CommandHeader.Tag.upper = 0U;
#line 4526
  memset((void *)(& cmd->CommandHeader.LUN.LunAddrBytes), 0, 8UL);
#line 4528
  cmd->Request.CDBLen = 16U;
#line 4529
  cmd->Request.Type.Type = 1U;
#line 4530
  cmd->Request.Type.Attribute = 5U;
#line 4531
  cmd->Request.Type.Direction = 0U;
#line 4532
  cmd->Request.Timeout = 0U;
#line 4533
  cmd->Request.CDB[0] = opcode;
#line 4534
  cmd->Request.CDB[1] = type;
#line 4535
  memset((void *)(& cmd->Request.CDB) + 2U, 0, 14UL);
#line 4537
  cmd->ErrorDescriptor.Addr.lower = paddr32 + 52U;
#line 4538
  cmd->ErrorDescriptor.Addr.upper = 0U;
#line 4539
  cmd->ErrorDescriptor.Len = 48U;
#line 4541
  writel(paddr32, (void volatile   *)vaddr + 64U);
#line 4543
  i = 0;
#line 4543
  goto ldv_37857;
  ldv_37856: 
#line 4544
  tag = readl((void const volatile   *)vaddr + 68U);
#line 4545
  if ((tag & 4294967292U) == paddr32) {
#line 4546
    goto ldv_37855;
  } else {

  }
#line 4547
  msleep(10000U);
#line 4543
  i = i + 1;
  ldv_37857: ;
#line 4543
  if (i <= 9) {
#line 4544
    goto ldv_37856;
  } else {

  }
  ldv_37855: 
#line 4550
  iounmap((void volatile   *)vaddr);
#line 4554
  if (i == 10) {
#line 4555
    dev_err((struct device  const  *)(& pdev->dev), "controller message %02x:%02x timed out\n",
            (int )opcode, (int )type);
#line 4558
    return (-110);
  } else {

  }
#line 4561
  pci_free_consistent(pdev, cmd_sz, (void *)cmd, paddr64);
#line 4563
  if ((tag & 2U) != 0U) {
#line 4564
    dev_err((struct device  const  *)(& pdev->dev), "controller message %02x:%02x failed\n",
            (int )opcode, (int )type);
#line 4566
    return (-5);
  } else {

  }
#line 4569
  _dev_info((struct device  const  *)(& pdev->dev), "controller message %02x:%02x succeeded\n",
            (int )opcode, (int )type);
#line 4571
  return (0);
}
}
#line 4576 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_controller_hard_reset(struct pci_dev *pdev , void *vaddr , u32 use_doorbell ) 
{ 
  u16 pmcsr ;
  int pos ;

  {
#line 4582
  if (use_doorbell != 0U) {
#line 4587
    _dev_info((struct device  const  *)(& pdev->dev), "using doorbell to reset controller\n");
#line 4588
    writel(use_doorbell, (void volatile   *)vaddr + 32U);
  } else {
#line 4599
    pos = pci_find_capability(pdev, 1);
#line 4600
    if (pos == 0) {
#line 4601
      dev_err((struct device  const  *)(& pdev->dev), "cciss_controller_hard_reset: PCI PM not supported\n");
#line 4604
      return (-19);
    } else {

    }
#line 4606
    _dev_info((struct device  const  *)(& pdev->dev), "using PCI PM to reset controller\n");
#line 4608
    pci_read_config_word((struct pci_dev  const  *)pdev, pos + 4, & pmcsr);
#line 4609
    pmcsr = (unsigned int )pmcsr & 65532U;
#line 4610
    pmcsr = (u16 )((unsigned int )pmcsr | 3U);
#line 4611
    pci_write_config_word((struct pci_dev  const  *)pdev, pos + 4, (int )pmcsr);
#line 4613
    msleep(500U);
#line 4616
    pmcsr = (unsigned int )pmcsr & 65532U;
#line 4617
    pmcsr = pmcsr;
#line 4618
    pci_write_config_word((struct pci_dev  const  *)pdev, pos + 4, (int )pmcsr);
#line 4625
    msleep(500U);
  }
#line 4627
  return (0);
}
}
#line 4630 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void init_driver_version(char *driver_version , int len ) 
{ 


  {
#line 4632
  memset((void *)driver_version, 0, (size_t )len);
#line 4633
  strncpy(driver_version, "cciss HP CISS Driver (v 3.6.26)", (__kernel_size_t )(len + -1));
#line 4634
  return;
}
}
#line 4636 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int write_driver_ver_to_cfgtable(CfgTable_struct *cfgtable ) 
{ 
  char *driver_version ;
  int i ;
  int size ;
  void *tmp ;

  {
#line 4640
  size = 32;
#line 4642
  tmp = kmalloc((size_t )size, 208U);
#line 4642
  driver_version = (char *)tmp;
#line 4643
  if ((unsigned long )driver_version == (unsigned long )((char *)0)) {
#line 4644
    return (-12);
  } else {

  }
#line 4646
  init_driver_version(driver_version, size);
#line 4647
  i = 0;
#line 4647
  goto ldv_37876;
  ldv_37875: 
#line 4648
  writeb((int )((unsigned char )*(driver_version + (unsigned long )i)), (void volatile   *)(& cfgtable->driver_version) + (unsigned long )i);
#line 4647
  i = i + 1;
  ldv_37876: ;
#line 4647
  if (i < size) {
#line 4648
    goto ldv_37875;
  } else {

  }
#line 4649
  kfree((void const   *)driver_version);
#line 4650
  return (0);
}
}
#line 4653 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void read_driver_ver_from_cfgtable(CfgTable_struct *cfgtable , unsigned char *driver_ver ) 
{ 
  int i ;

  {
#line 4658
  i = 0;
#line 4658
  goto ldv_37884;
  ldv_37883: 
#line 4659
  *(driver_ver + (unsigned long )i) = readb((void const volatile   *)(& cfgtable->driver_version) + (unsigned long )i);
#line 4658
  i = i + 1;
  ldv_37884: ;
#line 4658
  if ((unsigned int )i <= 31U) {
#line 4659
    goto ldv_37883;
  } else {

  }

#line 4663
  return;
}
}
#line 4662 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int controller_reset_failed(CfgTable_struct *cfgtable ) 
{ 
  char *driver_ver ;
  char *old_driver_ver ;
  int rc ;
  int size ;
  void *tmp ;
  int tmp___0 ;

  {
#line 4667
  size = 32;
#line 4669
  tmp = kmalloc((size_t )(size * 2), 208U);
#line 4669
  old_driver_ver = (char *)tmp;
#line 4670
  if ((unsigned long )old_driver_ver == (unsigned long )((char *)0)) {
#line 4671
    return (-12);
  } else {

  }
#line 4672
  driver_ver = old_driver_ver + (unsigned long )size;
#line 4677
  init_driver_version(old_driver_ver, size);
#line 4678
  read_driver_ver_from_cfgtable(cfgtable, (unsigned char *)driver_ver);
#line 4679
  tmp___0 = memcmp((void const   *)driver_ver, (void const   *)old_driver_ver, (size_t )size);
#line 4679
  rc = tmp___0 == 0;
#line 4680
  kfree((void const   *)old_driver_ver);
#line 4681
  return (rc);
}
}
#line 4686 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_kdump_hard_reset_controller(struct pci_dev *pdev ) 
{ 
  u64 cfg_offset ;
  u32 cfg_base_addr ;
  u64 cfg_base_addr_index ;
  void *vaddr ;
  unsigned long paddr ;
  u32 misc_fw_support ;
  int rc ;
  CfgTable_struct *cfgtable ;
  u32 use_doorbell ;
  u32 board_id ;
  u16 command_register ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 4719
  cciss_lookup_board_id(pdev, & board_id);
#line 4720
  tmp = ctlr_is_resettable(board_id);
#line 4720
  if (tmp == 0) {
#line 4721
    dev_warn((struct device  const  *)(& pdev->dev), "Cannot reset Smart Array 640x due to shared cache module.");
#line 4723
    return (-19);
  } else {

  }
#line 4727
  tmp___0 = ctlr_is_hard_resettable(board_id);
#line 4727
  if (tmp___0 == 0) {
#line 4728
    return (-524);
  } else {

  }
#line 4731
  pci_read_config_word((struct pci_dev  const  *)pdev, 4, & command_register);
#line 4735
  pci_disable_device(pdev);
#line 4736
  pci_save_state(pdev);
#line 4739
  rc = cciss_pci_find_memory_BAR(pdev, & paddr);
#line 4740
  if (rc != 0) {
#line 4741
    return (rc);
  } else {

  }
#line 4742
  vaddr = remap_pci_mem(paddr, 592UL);
#line 4743
  if ((unsigned long )vaddr == (unsigned long )((void *)0)) {
#line 4744
    return (-12);
  } else {

  }
#line 4747
  rc = cciss_find_cfg_addrs(pdev, vaddr, & cfg_base_addr, & cfg_base_addr_index, & cfg_offset);
#line 4749
  if (rc != 0) {
#line 4750
    goto unmap_vaddr;
  } else {

  }
#line 4751
  tmp___1 = remap_pci_mem((ulong )(pdev->resource[cfg_base_addr_index].start + cfg_offset),
                          156UL);
#line 4751
  cfgtable = (CfgTable_struct *)tmp___1;
#line 4753
  if ((unsigned long )cfgtable == (unsigned long )((CfgTable_struct *)0)) {
#line 4754
    rc = -12;
#line 4755
    goto unmap_vaddr;
  } else {

  }
#line 4757
  rc = write_driver_ver_to_cfgtable(cfgtable);
#line 4758
  if (rc != 0) {
#line 4759
    goto unmap_vaddr;
  } else {

  }
#line 4764
  misc_fw_support = readl((void const volatile   *)(& cfgtable->misc_fw_support));
#line 4765
  use_doorbell = misc_fw_support & 16U;
#line 4766
  if (use_doorbell != 0U) {
#line 4767
    use_doorbell = 32U;
  } else {
#line 4769
    use_doorbell = misc_fw_support & 2U;
#line 4770
    if (use_doorbell != 0U) {
#line 4771
      dev_warn((struct device  const  *)(& pdev->dev), "Controller claims that \'Bit 2 doorbell reset\' is supported, but not \'bit 5 doorbell reset\'.  Firmware update is recommended.\n");
#line 4775
      rc = -524;
#line 4776
      goto unmap_cfgtable;
    } else {

    }
  }
#line 4780
  rc = cciss_controller_hard_reset(pdev, vaddr, use_doorbell);
#line 4781
  if (rc != 0) {
#line 4782
    goto unmap_cfgtable;
  } else {

  }
#line 4783
  pci_restore_state(pdev);
#line 4784
  rc = pci_enable_device(pdev);
#line 4785
  if (rc != 0) {
#line 4786
    dev_warn((struct device  const  *)(& pdev->dev), "failed to enable device.\n");
#line 4787
    goto unmap_cfgtable;
  } else {

  }
#line 4789
  pci_write_config_word((struct pci_dev  const  *)pdev, 4, (int )command_register);
#line 4793
  msleep(3000U);
#line 4796
  _dev_info((struct device  const  *)(& pdev->dev), "Waiting for board to reset.\n");
#line 4797
  rc = cciss_wait_for_board_state(pdev, vaddr, 0);
#line 4798
  if (rc != 0) {
#line 4799
    dev_warn((struct device  const  *)(& pdev->dev), "Failed waiting for board to hard reset.  Will try soft reset.\n");
#line 4801
    rc = -524;
#line 4802
    goto unmap_cfgtable;
  } else {

  }
#line 4804
  rc = cciss_wait_for_board_state(pdev, vaddr, 1);
#line 4805
  if (rc != 0) {
#line 4806
    dev_warn((struct device  const  *)(& pdev->dev), "failed waiting for board to become ready after hard reset\n");
#line 4809
    goto unmap_cfgtable;
  } else {

  }
#line 4812
  rc = controller_reset_failed((CfgTable_struct *)vaddr);
#line 4813
  if (rc < 0) {
#line 4814
    goto unmap_cfgtable;
  } else {

  }
#line 4815
  if (rc != 0) {
#line 4816
    dev_warn((struct device  const  *)(& pdev->dev), "Unable to successfully hard reset controller. Will try soft reset.\n");
#line 4818
    rc = -524;
  } else {
#line 4820
    _dev_info((struct device  const  *)(& pdev->dev), "Board ready after hard reset.\n");
  }
  unmap_cfgtable: 
#line 4824
  iounmap((void volatile   *)cfgtable);
  unmap_vaddr: 
#line 4827
  iounmap((void volatile   *)vaddr);
#line 4828
  return (rc);
}
}
#line 4831 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_init_reset_devices(struct pci_dev *pdev ) 
{ 
  int rc ;
  int i ;
  int tmp ;

  {
#line 4835
  if (reset_devices == 0U) {
#line 4836
    return (0);
  } else {

  }
#line 4839
  rc = cciss_kdump_hard_reset_controller(pdev);
#line 4846
  if (rc == -524) {
#line 4847
    return (rc);
  } else {

  }
#line 4848
  if (rc != 0) {
#line 4849
    return (-19);
  } else {

  }
#line 4852
  dev_warn((struct device  const  *)(& pdev->dev), "Waiting for controller to respond to no-op\n");
#line 4853
  i = 0;
#line 4853
  goto ldv_37916;
  ldv_37915: 
#line 4854
  tmp = cciss_message(pdev, 3, 0);
#line 4854
  if (tmp == 0) {
#line 4855
    goto ldv_37914;
  } else {
#line 4857
    dev_warn((struct device  const  *)(& pdev->dev), "no-op failed%s\n", i <= 10 ? (char *)"; re-trying" : (char *)"");
  }
#line 4860
  msleep(4000U);
#line 4853
  i = i + 1;
  ldv_37916: ;
#line 4853
  if (i <= 11) {
#line 4854
    goto ldv_37915;
  } else {

  }
  ldv_37914: ;
#line 4862
  return (0);
}
}
#line 4865 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_allocate_cmd_pool(ctlr_info_t *h ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4867
  tmp = kmalloc((((unsigned long )h->nr_cmds + 63UL) / 64UL) * 8UL, 208U);
#line 4867
  h->cmd_pool_bits = (unsigned long *)tmp;
#line 4869
  tmp___0 = pci_alloc_consistent(h->pdev, (unsigned long )h->nr_cmds * 640UL, & h->cmd_pool_dhandle);
#line 4869
  h->cmd_pool = (CommandList_struct *)tmp___0;
#line 4872
  tmp___1 = pci_alloc_consistent(h->pdev, (unsigned long )h->nr_cmds * 48UL, & h->errinfo_pool_dhandle);
#line 4872
  h->errinfo_pool = (ErrorInfo_struct *)tmp___1;
#line 4875
  if (((unsigned long )h->cmd_pool_bits == (unsigned long )((unsigned long *)0) || (unsigned long )h->cmd_pool == (unsigned long )((CommandList_struct *)0)) || (unsigned long )h->errinfo_pool == (unsigned long )((ErrorInfo_struct *)0)) {
#line 4878
    dev_err((struct device  const  *)(& (h->pdev)->dev), "out of memory");
#line 4879
    return (-12);
  } else {

  }
#line 4881
  return (0);
}
}
#line 4884 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_allocate_scatterlists(ctlr_info_t *h ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 4889
  tmp = kzalloc((unsigned long )h->max_commands * 8UL, 208U);
#line 4889
  h->scatter_list = (struct scatterlist **)tmp;
#line 4891
  if ((unsigned long )h->scatter_list == (unsigned long )((struct scatterlist **)0)) {
#line 4892
    return (-12);
  } else {

  }
#line 4894
  i = 0;
#line 4894
  goto ldv_37925;
  ldv_37924: 
#line 4895
  tmp___0 = kmalloc((unsigned long )h->maxsgentries * 40UL, 208U);
#line 4895
  *(h->scatter_list + (unsigned long )i) = (struct scatterlist *)tmp___0;
#line 4897
  if ((unsigned long )*(h->scatter_list + (unsigned long )i) == (unsigned long )((struct scatterlist *)0)) {
#line 4898
    dev_err((struct device  const  *)(& (h->pdev)->dev), "could not allocate s/g lists\n");
#line 4900
    return (-12);
  } else {

  }
#line 4894
  i = i + 1;
  ldv_37925: ;
#line 4894
  if (h->nr_cmds > i) {
#line 4895
    goto ldv_37924;
  } else {

  }

#line 4903
  return (0);
}
}
#line 4906 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_scatterlists(ctlr_info_t *h ) 
{ 
  int i ;

  {
#line 4910
  if ((unsigned long )h->scatter_list != (unsigned long )((struct scatterlist **)0)) {
#line 4911
    i = 0;
#line 4911
    goto ldv_37932;
    ldv_37931: 
#line 4912
    kfree((void const   *)*(h->scatter_list + (unsigned long )i));
#line 4911
    i = i + 1;
    ldv_37932: ;
#line 4911
    if (h->nr_cmds > i) {
#line 4912
      goto ldv_37931;
    } else {

    }
#line 4913
    kfree((void const   *)h->scatter_list);
  } else {

  }
#line 4915
  return;
}
}
#line 4917 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_free_cmd_pool(ctlr_info_t *h ) 
{ 


  {
#line 4919
  kfree((void const   *)h->cmd_pool_bits);
#line 4920
  if ((unsigned long )h->cmd_pool != (unsigned long )((CommandList_struct *)0)) {
#line 4921
    pci_free_consistent(h->pdev, (unsigned long )h->nr_cmds * 640UL, (void *)h->cmd_pool,
                        h->cmd_pool_dhandle);
  } else {

  }
#line 4924
  if ((unsigned long )h->errinfo_pool != (unsigned long )((ErrorInfo_struct *)0)) {
#line 4925
    pci_free_consistent(h->pdev, (unsigned long )h->nr_cmds * 48UL, (void *)h->errinfo_pool,
                        h->errinfo_pool_dhandle);
  } else {

  }
#line 4928
  return;
}
}
#line 4930 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_request_irq(ctlr_info_t *h , irqreturn_t (*msixhandler)(int  , void * ) ,
                             irqreturn_t (*intxhandler)(int  , void * ) ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 4934
  if (h->msix_vector != 0U || h->msi_vector != 0U) {
#line 4935
    tmp = request_irq(h->intr[h->intr_mode], msixhandler, 0UL, (char const   *)(& h->devname),
                      (void *)h);
#line 4935
    if (tmp == 0) {
#line 4937
      return (0);
    } else {

    }
#line 4938
    dev_err((struct device  const  *)(& (h->pdev)->dev), "Unable to get msi irq %d for %s\n",
            h->intr[h->intr_mode], (char *)(& h->devname));
#line 4941
    return (-1);
  } else {

  }
#line 4944
  tmp___0 = request_irq(h->intr[h->intr_mode], intxhandler, 128UL, (char const   *)(& h->devname),
                        (void *)h);
#line 4944
  if (tmp___0 == 0) {
#line 4946
    return (0);
  } else {

  }
#line 4947
  dev_err((struct device  const  *)(& (h->pdev)->dev), "Unable to get irq %d for %s\n",
          h->intr[h->intr_mode], (char *)(& h->devname));
#line 4949
  return (-1);
}
}
#line 4952 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_kdump_soft_reset(ctlr_info_t *h ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4954
  tmp = cciss_send_reset(h, (unsigned char *)"", 0);
#line 4954
  if (tmp != 0) {
#line 4955
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Resetting array controller failed.\n");
#line 4956
    return (-5);
  } else {

  }
#line 4959
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "Waiting for board to soft reset.\n");
#line 4960
  tmp___0 = cciss_wait_for_board_state(h->pdev, h->vaddr, 0);
#line 4960
  if (tmp___0 != 0) {
#line 4961
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Soft reset had no effect.\n");
#line 4962
    return (-1);
  } else {

  }
#line 4965
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "Board reset, awaiting READY status.\n");
#line 4966
  tmp___1 = cciss_wait_for_board_state(h->pdev, h->vaddr, 1);
#line 4966
  if (tmp___1 != 0) {
#line 4967
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Board failed to become ready after soft reset.\n");
#line 4969
    return (-1);
  } else {

  }
#line 4972
  return (0);
}
}
#line 4975 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_undo_allocations_after_kdump_soft_reset(ctlr_info_t *h ) 
{ 
  int ctlr ;

  {
#line 4977
  ctlr = h->ctlr;
#line 4979
  free_irq(h->intr[h->intr_mode], (void *)h);
#line 4981
  if (h->msix_vector != 0U) {
#line 4982
    pci_disable_msix(h->pdev);
  } else
#line 4983
  if (h->msi_vector != 0U) {
#line 4984
    pci_disable_msi(h->pdev);
  } else {

  }
#line 4986
  cciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);
#line 4987
  cciss_free_scatterlists(h);
#line 4988
  cciss_free_cmd_pool(h);
#line 4989
  kfree((void const   *)h->blockFetchTable);
#line 4990
  if ((unsigned long )h->reply_pool != (unsigned long )((u64 *)0)) {
#line 4991
    pci_free_consistent(h->pdev, (unsigned long )h->max_commands * 8UL, (void *)h->reply_pool,
                        h->reply_pool_dhandle);
  } else {

  }
#line 4993
  if ((unsigned long )h->transtable != (unsigned long )((struct TransTable_struct *)0)) {
#line 4994
    iounmap((void volatile   *)h->transtable);
  } else {

  }
#line 4995
  if ((unsigned long )h->cfgtable != (unsigned long )((CfgTable_struct *)0)) {
#line 4996
    iounmap((void volatile   *)h->cfgtable);
  } else {

  }
#line 4997
  if ((unsigned long )h->vaddr != (unsigned long )((void *)0)) {
#line 4998
    iounmap((void volatile   *)h->vaddr);
  } else {

  }
#line 4999
  unregister_blkdev((unsigned int )h->major, (char const   *)(& h->devname));
#line 5000
  cciss_destroy_hba_sysfs_entry(h);
#line 5001
  pci_release_regions(h->pdev);
#line 5002
  kfree((void const   *)h);
#line 5003
  hba[ctlr] = 0;
#line 5004
  return;
}
}
#line 5011 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_init_one(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ 
  int i ;
  int j ;
  int rc ;
  int try_soft_reset ;
  int dac ;
  int return_code ;
  InquiryData_struct *inq_buff ;
  ctlr_info_t *h ;
  unsigned long flags ;
  struct lock_class_key __key ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct lock_class_key __key___0 ;
  raw_spinlock_t *tmp___6 ;
  void *tmp___7 ;

  {
#line 5015
  j = 0;
#line 5017
  try_soft_reset = 0;
#line 5023
  rc = cciss_init_reset_devices(pdev);
#line 5024
  if (rc != 0) {
#line 5025
    if (rc != -524) {
#line 5026
      return (rc);
    } else {

    }
#line 5032
    try_soft_reset = 1;
#line 5033
    rc = 0;
  } else {

  }
  reinit_after_soft_reset: 
#line 5038
  i = alloc_cciss_hba(pdev);
#line 5039
  if (i < 0) {
#line 5040
    return (-1);
  } else {

  }
#line 5042
  h = hba[i];
#line 5043
  h->pdev = pdev;
#line 5044
  h->busy_initializing = 1;
#line 5045
  h->intr_mode = cciss_simple_mode != 0 ? 2 : 0;
#line 5046
  INIT_LIST_HEAD(& h->cmpQ);
#line 5047
  INIT_LIST_HEAD(& h->reqQ);
#line 5048
  __mutex_init(& h->busy_shutting_down, "&h->busy_shutting_down", & __key);
#line 5050
  tmp = cciss_pci_init(h);
#line 5050
  if (tmp != 0) {
#line 5051
    goto clean_no_release_regions;
  } else {

  }
#line 5053
  sprintf((char *)(& h->devname), "cciss%d", i);
#line 5054
  h->ctlr = i;
#line 5056
  if (cciss_tape_cmds <= 1) {
#line 5057
    cciss_tape_cmds = 2;
  } else {

  }
#line 5058
  if (cciss_tape_cmds > 16) {
#line 5059
    cciss_tape_cmds = 16;
  } else {

  }
#line 5061
  init_completion(& h->scan_wait);
#line 5063
  tmp___0 = cciss_create_hba_sysfs_entry(h);
#line 5063
  if (tmp___0 != 0) {
#line 5064
    goto clean0;
  } else {

  }
#line 5067
  tmp___2 = pci_set_dma_mask(pdev, 0xffffffffffffffffULL);
#line 5067
  if (tmp___2 == 0) {
#line 5068
    dac = 1;
  } else {
#line 5069
    tmp___1 = pci_set_dma_mask(pdev, 4294967295ULL);
#line 5069
    if (tmp___1 == 0) {
#line 5070
      dac = 0;
    } else {
#line 5072
      dev_err((struct device  const  *)(& (h->pdev)->dev), "no suitable DMA available\n");
#line 5073
      goto clean1;
    }
  }
#line 5081
  if (i <= 7) {
#line 5082
    h->major = i + 104;
  } else {

  }
#line 5083
  rc = register_blkdev((unsigned int )h->major, (char const   *)(& h->devname));
#line 5084
  if (rc == -16 || rc == -22) {
#line 5085
    dev_err((struct device  const  *)(& (h->pdev)->dev), "Unable to get major number %d for %s on hba %d\n",
            h->major, (char *)(& h->devname), i);
#line 5088
    goto clean1;
  } else
#line 5090
  if (i > 7) {
#line 5091
    h->major = rc;
  } else {

  }
#line 5095
  (*(h->access.set_intr_mask))(h, 0UL);
#line 5096
  rc = cciss_request_irq(h, & do_cciss_msix_intr, & do_cciss_intx);
#line 5097
  if (rc != 0) {
#line 5098
    goto clean2;
  } else {

  }
#line 5100
  tmp___3 = pci_name((struct pci_dev  const  *)pdev);
#line 5100
  _dev_info((struct device  const  *)(& (h->pdev)->dev), "%s: <0x%x> at PCI %s IRQ %d%s using DAC\n",
            (char *)(& h->devname), (int )pdev->device, tmp___3, h->intr[h->intr_mode],
            dac != 0 ? (char *)"" : (char *)" not");
#line 5104
  tmp___4 = cciss_allocate_cmd_pool(h);
#line 5104
  if (tmp___4 != 0) {
#line 5105
    goto clean4;
  } else {

  }
#line 5107
  tmp___5 = cciss_allocate_scatterlists(h);
#line 5107
  if (tmp___5 != 0) {
#line 5108
    goto clean4;
  } else {

  }
#line 5110
  h->cmd_sg_list = cciss_allocate_sg_chain_blocks(h, h->chainsize, h->nr_cmds);
#line 5112
  if ((unsigned long )h->cmd_sg_list == (unsigned long )((SGDescriptor_struct **)0) && h->chainsize > 0) {
#line 5113
    goto clean4;
  } else {

  }
#line 5115
  spinlock_check(& h->lock);
#line 5115
  __raw_spin_lock_init(& h->lock.ldv_5961.rlock, "&(&h->lock)->rlock", & __key___0);
#line 5119
  pci_set_drvdata(pdev, (void *)h);
#line 5122
  bitmap_zero(h->cmd_pool_bits, h->nr_cmds);
#line 5124
  h->num_luns = 0;
#line 5125
  h->highest_lun = -1;
#line 5126
  j = 0;
#line 5126
  goto ldv_37975;
  ldv_37974: 
#line 5127
  h->drv[j] = 0;
#line 5128
  h->gendisk[j] = 0;
#line 5126
  j = j + 1;
  ldv_37975: ;
#line 5126
  if (j <= 1023) {
#line 5127
    goto ldv_37974;
  } else {

  }

#line 5135
  if (try_soft_reset != 0) {
#line 5144
    tmp___6 = spinlock_check(& h->lock);
#line 5144
    flags = _raw_spin_lock_irqsave(tmp___6);
#line 5145
    (*(h->access.set_intr_mask))(h, 0UL);
#line 5146
    spin_unlock_irqrestore(& h->lock, flags);
#line 5147
    free_irq(h->intr[h->intr_mode], (void *)h);
#line 5148
    rc = cciss_request_irq(h, & cciss_msix_discard_completions, & cciss_intx_discard_completions);
#line 5150
    if (rc != 0) {
#line 5151
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "Failed to request_irq after soft reset.\n");
#line 5153
      goto clean4;
    } else {

    }
#line 5156
    rc = cciss_kdump_soft_reset(h);
#line 5157
    if (rc != 0) {
#line 5158
      dev_warn((struct device  const  *)(& (h->pdev)->dev), "Soft reset failed.\n");
#line 5159
      goto clean4;
    } else {

    }
#line 5162
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "Board READY.\n");
#line 5163
    _dev_info((struct device  const  *)(& (h->pdev)->dev), "Waiting for stale completions to drain.\n");
#line 5165
    (*(h->access.set_intr_mask))(h, 1UL);
#line 5166
    msleep(10000U);
#line 5167
    (*(h->access.set_intr_mask))(h, 0UL);
#line 5169
    rc = controller_reset_failed(h->cfgtable);
#line 5170
    if (rc != 0) {
#line 5171
      _dev_info((struct device  const  *)(& (h->pdev)->dev), "Soft reset appears to have failed.\n");
    } else {

    }
#line 5178
    cciss_undo_allocations_after_kdump_soft_reset(h);
#line 5179
    try_soft_reset = 0;
#line 5180
    if (rc != 0) {
#line 5182
      return (-19);
    } else {

    }
#line 5184
    goto reinit_after_soft_reset;
  } else {

  }
#line 5187
  cciss_scsi_setup(h);
#line 5190
  (*(h->access.set_intr_mask))(h, 1UL);
#line 5193
  tmp___7 = kzalloc(36UL, 208U);
#line 5193
  inq_buff = (InquiryData_struct *)tmp___7;
#line 5194
  if ((unsigned long )inq_buff == (unsigned long )((InquiryData_struct *)0)) {
#line 5195
    dev_err((struct device  const  *)(& (h->pdev)->dev), "out of memory\n");
#line 5196
    goto clean4;
  } else {

  }
#line 5199
  return_code = sendcmd_withirq(h, 18, (void *)inq_buff, 36UL, 0, (unsigned char *)"",
                                0);
#line 5201
  if (return_code == 0) {
#line 5202
    h->firm_ver[0] = (char )inq_buff->data_byte[32];
#line 5203
    h->firm_ver[1] = (char )inq_buff->data_byte[33];
#line 5204
    h->firm_ver[2] = (char )inq_buff->data_byte[34];
#line 5205
    h->firm_ver[3] = (char )inq_buff->data_byte[35];
  } else {
#line 5207
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "unable to determine firmware version of controller\n");
  }
#line 5210
  kfree((void const   *)inq_buff);
#line 5212
  cciss_procinit(h);
#line 5214
  h->cciss_max_sectors = 8192;
#line 5216
  rebuild_lun_table(h, 1, 0);
#line 5217
  cciss_engage_scsi(h);
#line 5218
  h->busy_initializing = 0;
#line 5219
  return (1);
  clean4: 
#line 5222
  cciss_free_cmd_pool(h);
#line 5223
  cciss_free_scatterlists(h);
#line 5224
  cciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);
#line 5225
  free_irq(h->intr[h->intr_mode], (void *)h);
  clean2: 
#line 5227
  unregister_blkdev((unsigned int )h->major, (char const   *)(& h->devname));
  clean1: 
#line 5229
  cciss_destroy_hba_sysfs_entry(h);
  clean0: 
#line 5231
  pci_release_regions(pdev);
  clean_no_release_regions: 
#line 5233
  h->busy_initializing = 0;
#line 5239
  pci_set_drvdata(pdev, 0);
#line 5240
  free_hba(h);
#line 5241
  return (-1);
}
}
#line 5244 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_shutdown(struct pci_dev *pdev ) 
{ 
  ctlr_info_t *h ;
  char *flush_buf ;
  int return_code ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 5250
  tmp = pci_get_drvdata(pdev);
#line 5250
  h = (ctlr_info_t *)tmp;
#line 5251
  tmp___0 = kzalloc(4UL, 208U);
#line 5251
  flush_buf = (char *)tmp___0;
#line 5252
  if ((unsigned long )flush_buf == (unsigned long )((char *)0)) {
#line 5253
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "cache not flushed, out of memory.\n");
#line 5254
    return;
  } else {

  }
#line 5257
  return_code = sendcmd_withirq(h, 1, (void *)flush_buf, 4UL, 0, (unsigned char *)"",
                                0);
#line 5259
  kfree((void const   *)flush_buf);
#line 5260
  if (return_code != 0) {
#line 5261
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "Error flushing cache\n");
  } else {

  }
#line 5262
  (*(h->access.set_intr_mask))(h, 0UL);
#line 5263
  free_irq(h->intr[h->intr_mode], (void *)h);
#line 5264
  return;
}
}
#line 5266 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_enter_simple_mode(struct ctlr_info *h ) 
{ 
  u32 trans_support ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 5270
  trans_support = readl((void const volatile   *)(& (h->cfgtable)->TransportSupport));
#line 5271
  if ((trans_support & 2U) == 0U) {
#line 5272
    return (-524);
  } else {

  }
#line 5274
  tmp = readl((void const volatile   *)(& (h->cfgtable)->CmdsOutMax));
#line 5274
  h->max_commands = (int )tmp;
#line 5275
  writel(2U, (void volatile   *)(& (h->cfgtable)->HostWrite.TransportRequest));
#line 5276
  writel(1U, (void volatile   *)h->vaddr + 32U);
#line 5277
  cciss_wait_for_mode_change_ack(h);
#line 5278
  print_cfg_table(h);
#line 5279
  tmp___0 = readl((void const volatile   *)(& (h->cfgtable)->TransportActive));
#line 5279
  if (((long )tmp___0 & 2L) == 0L) {
#line 5280
    dev_warn((struct device  const  *)(& (h->pdev)->dev), "unable to get board into simple mode\n");
#line 5281
    return (-19);
  } else {

  }
#line 5283
  h->transMethod = 2UL;
#line 5284
  return (0);
}
}
#line 5288 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_remove_one(struct pci_dev *pdev ) 
{ 
  ctlr_info_t *h ;
  int i ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  struct gendisk *disk ;
  struct request_queue *q ;

  {
#line 5293
  tmp = pci_get_drvdata(pdev);
#line 5293
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 5294
    dev_err((struct device  const  *)(& pdev->dev), "Unable to remove device\n");
#line 5295
    return;
  } else {

  }
#line 5298
  tmp___0 = pci_get_drvdata(pdev);
#line 5298
  h = (ctlr_info_t *)tmp___0;
#line 5299
  i = h->ctlr;
#line 5300
  if ((unsigned long )hba[i] == (unsigned long )((ctlr_info_t *)0)) {
#line 5301
    dev_err((struct device  const  *)(& pdev->dev), "device appears to already be removed\n");
#line 5302
    return;
  } else {

  }
#line 5305
  ldv_mutex_lock_27(& h->busy_shutting_down);
#line 5307
  remove_from_scan_list(h);
#line 5308
  remove_proc_entry((char const   *)(& h->devname), proc_cciss);
#line 5309
  unregister_blkdev((unsigned int )h->major, (char const   *)(& h->devname));
#line 5312
  j = 0;
#line 5312
  goto ldv_37999;
  ldv_37998: 
#line 5313
  disk = h->gendisk[j];
#line 5314
  if ((unsigned long )disk != (unsigned long )((struct gendisk *)0)) {
#line 5315
    q = disk->queue;
#line 5317
    if ((disk->flags & 16) != 0) {
#line 5318
      cciss_destroy_ld_sysfs_entry(h, j, 1);
#line 5319
      del_gendisk(disk);
    } else {

    }
#line 5321
    if ((unsigned long )q != (unsigned long )((struct request_queue *)0)) {
#line 5322
      blk_cleanup_queue(q);
    } else {

    }
  } else {

  }
#line 5312
  j = j + 1;
  ldv_37999: ;
#line 5312
  if (j <= 1023) {
#line 5313
    goto ldv_37998;
  } else {

  }
#line 5327
  cciss_unregister_scsi(h);
#line 5330
  cciss_shutdown(pdev);
#line 5333
  if (h->msix_vector != 0U) {
#line 5334
    pci_disable_msix(h->pdev);
  } else
#line 5335
  if (h->msi_vector != 0U) {
#line 5336
    pci_disable_msi(h->pdev);
  } else {

  }
#line 5339
  iounmap((void volatile   *)h->transtable);
#line 5340
  iounmap((void volatile   *)h->cfgtable);
#line 5341
  iounmap((void volatile   *)h->vaddr);
#line 5343
  cciss_free_cmd_pool(h);
#line 5345
  j = 0;
#line 5345
  goto ldv_38002;
  ldv_38001: 
#line 5346
  kfree((void const   *)*(h->scatter_list + (unsigned long )j));
#line 5345
  j = j + 1;
  ldv_38002: ;
#line 5345
  if (h->nr_cmds > j) {
#line 5346
    goto ldv_38001;
  } else {

  }
#line 5347
  kfree((void const   *)h->scatter_list);
#line 5348
  cciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);
#line 5349
  kfree((void const   *)h->blockFetchTable);
#line 5350
  if ((unsigned long )h->reply_pool != (unsigned long )((u64 *)0)) {
#line 5351
    pci_free_consistent(h->pdev, (unsigned long )h->max_commands * 8UL, (void *)h->reply_pool,
                        h->reply_pool_dhandle);
  } else {

  }
#line 5357
  pci_release_regions(pdev);
#line 5358
  pci_set_drvdata(pdev, 0);
#line 5359
  cciss_destroy_hba_sysfs_entry(h);
#line 5360
  ldv_mutex_unlock_28(& h->busy_shutting_down);
#line 5361
  free_hba(h);
#line 5362
  return;
}
}
#line 5364 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static struct pci_driver cciss_pci_driver  = 
#line 5364
     {{0, 0}, "cciss", (struct pci_device_id  const  *)(& cciss_pci_device_id), & cciss_init_one,
    & cciss_remove_one, 0, 0, 0, 0, & cciss_shutdown, 0, 0, {0, 0, 0, 0, (_Bool)0,
                                                             0, 0, 0, 0, 0, 0, 0,
                                                             0, 0, 0}, {{{{{{0U}},
                                                                           0U, 0U,
                                                                           0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
                                                                        {0, 0}}};
#line 5376 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static int cciss_init(void) 
{ 
  int err ;
  struct lock_class_key __key ;
  int tmp ;
  struct task_struct *__k ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 5386
  printk("\016HP CISS Driver (v 3.6.26)\n");
#line 5388
  tmp = __bus_register(& cciss_bus_type, & __key);
#line 5388
  err = tmp;
#line 5389
  if (err != 0) {
#line 5390
    return (err);
  } else {

  }
#line 5393
  tmp___0 = kthread_create_on_node(& scan_thread, 0, -1, "cciss_scan");
#line 5393
  __k = tmp___0;
#line 5393
  tmp___1 = IS_ERR((void const   *)__k);
#line 5393
  if (tmp___1 == 0L) {
#line 5393
    wake_up_process(__k);
  } else {

  }
#line 5393
  cciss_scan_thread = __k;
#line 5394
  tmp___3 = IS_ERR((void const   *)cciss_scan_thread);
#line 5394
  if (tmp___3 != 0L) {
#line 5395
    tmp___2 = PTR_ERR((void const   *)cciss_scan_thread);
#line 5395
    err = (int )tmp___2;
#line 5396
    goto err_bus_unregister;
  } else {

  }
#line 5400
  err = __pci_register_driver(& cciss_pci_driver, & __this_module, "cciss");
#line 5401
  if (err != 0) {
#line 5402
    goto err_thread_stop;
  } else {

  }
#line 5404
  return (err);
  err_thread_stop: 
#line 5407
  kthread_stop(cciss_scan_thread);
  err_bus_unregister: 
#line 5409
  bus_unregister(& cciss_bus_type);
#line 5411
  return (err);
}
}
#line 5414 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
static void cciss_cleanup(void) 
{ 
  int i ;

  {
#line 5418
  pci_unregister_driver(& cciss_pci_driver);
#line 5420
  i = 0;
#line 5420
  goto ldv_38020;
  ldv_38019: ;
#line 5421
  if ((unsigned long )hba[i] != (unsigned long )((ctlr_info_t *)0)) {
#line 5422
    dev_warn((struct device  const  *)(& ((hba[i])->pdev)->dev), "had to remove controller\n");
#line 5424
    cciss_remove_one((hba[i])->pdev);
  } else {

  }
#line 5420
  i = i + 1;
  ldv_38020: ;
#line 5420
  if (i <= 31) {
#line 5421
    goto ldv_38019;
  } else {

  }
#line 5427
  kthread_stop(cciss_scan_thread);
#line 5428
  if ((unsigned long )proc_cciss != (unsigned long )((struct proc_dir_entry *)0)) {
#line 5429
    remove_proc_entry("driver/cciss", 0);
  } else {

  }
#line 5430
  bus_unregister(& cciss_bus_type);
#line 5431
  return;
}
}
#line 5452
void ldv_check_final_state(void) ;
#line 5455
extern void ldv_check_return_value(int  ) ;
#line 5458
extern void ldv_check_return_value_probe(int  ) ;
#line 5461
void ldv_initialize(void) ;
#line 5464
extern void ldv_handler_precall(void) ;
#line 5467
extern int __VERIFIER_nondet_int(void) ;
#line 5470 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int LDV_IN_INTERRUPT  ;
#line 5473 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void main(void) 
{ 
  struct block_device *var_group1 ;
  fmode_t var_cciss_unlocked_open_42_p1 ;
  int res_cciss_unlocked_open_42 ;
  struct gendisk *var_group2 ;
  fmode_t var_cciss_release_43_p1 ;
  fmode_t var_do_ioctl_44_p1 ;
  unsigned int var_do_ioctl_44_p2 ;
  unsigned long var_do_ioctl_44_p3 ;
  struct hd_geometry *var_group3 ;
  fmode_t var_cciss_compat_ioctl_45_p1 ;
  unsigned int var_cciss_compat_ioctl_45_p2 ;
  unsigned long var_cciss_compat_ioctl_45_p3 ;
  struct seq_file *var_group4 ;
  loff_t *var_cciss_seq_start_9_p1 ;
  void *var_cciss_seq_show_10_p1 ;
  void *var_cciss_seq_next_11_p1 ;
  loff_t *var_cciss_seq_next_11_p2 ;
  void *var_cciss_seq_stop_12_p1 ;
  struct inode *var_group5 ;
  struct file *var_group6 ;
  int res_cciss_seq_open_13 ;
  char const   *var_cciss_proc_write_14_p1 ;
  size_t var_cciss_proc_write_14_p2 ;
  loff_t *var_cciss_proc_write_14_p3 ;
  ssize_t res_cciss_proc_write_14 ;
  struct device *var_group7 ;
  struct pci_dev *var_group8 ;
  struct pci_device_id  const  *var_cciss_init_one_147_p1 ;
  int res_cciss_init_one_147 ;
  int var_cciss_intx_discard_completions_106_p0 ;
  void *var_cciss_intx_discard_completions_106_p1 ;
  int var_cciss_msix_discard_completions_107_p0 ;
  void *var_cciss_msix_discard_completions_107_p1 ;
  int var_do_cciss_intx_108_p0 ;
  void *var_do_cciss_intx_108_p1 ;
  int var_do_cciss_msix_intr_109_p0 ;
  void *var_do_cciss_msix_intr_109_p1 ;
  int ldv_s_cciss_fops_block_device_operations ;
  int ldv_s_cciss_proc_fops_file_operations ;
  int ldv_s_cciss_host_type_device_type ;
  int ldv_s_cciss_dev_type_device_type ;
  int ldv_s_cciss_pci_driver_pci_driver ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6875
  ldv_s_cciss_fops_block_device_operations = 0;
#line 6880
  ldv_s_cciss_proc_fops_file_operations = 0;
#line 6882
  ldv_s_cciss_host_type_device_type = 0;
#line 6884
  ldv_s_cciss_dev_type_device_type = 0;
#line 6886
  ldv_s_cciss_pci_driver_pci_driver = 0;
#line 6802
  LDV_IN_INTERRUPT = 1;
#line 6811
  ldv_initialize();
#line 6872
  ldv_handler_precall();
#line 6873
  tmp = cciss_init();
#line 6873
  if (tmp != 0) {
#line 6874
    goto ldv_final;
  } else {

  }
#line 6892
  goto ldv_38116;
  ldv_38115: 
#line 6900
  tmp___0 = __VERIFIER_nondet_int();
#line 6900
  switch (tmp___0) {
  case 0: ;
#line 6905
  if (ldv_s_cciss_fops_block_device_operations == 0) {
#line 6941
    ldv_handler_precall();
#line 6942
    res_cciss_unlocked_open_42 = cciss_unlocked_open(var_group1, var_cciss_unlocked_open_42_p1);
#line 6943
    ldv_check_return_value(res_cciss_unlocked_open_42);
#line 6944
    if (res_cciss_unlocked_open_42 != 0) {
#line 6945
      goto ldv_module_exit;
    } else {

    }
#line 6972
    ldv_s_cciss_fops_block_device_operations = ldv_s_cciss_fops_block_device_operations + 1;
  } else {

  }
#line 6978
  goto ldv_38093;
  case 1: ;
#line 6982
  if (ldv_s_cciss_fops_block_device_operations == 1) {
#line 7018
    ldv_handler_precall();
#line 7019
    cciss_release(var_group2, var_cciss_release_43_p1);
#line 7046
    ldv_s_cciss_fops_block_device_operations = 0;
  } else {

  }
#line 7052
  goto ldv_38093;
  case 2: 
#line 7092
  ldv_handler_precall();
#line 7093
  do_ioctl(var_group1, var_do_ioctl_44_p1, var_do_ioctl_44_p2, var_do_ioctl_44_p3);
#line 7126
  goto ldv_38093;
  case 3: 
#line 7168
  ldv_handler_precall();
#line 7169
  cciss_getgeo(var_group1, var_group3);
#line 7200
  goto ldv_38093;
  case 4: 
#line 7241
  ldv_handler_precall();
#line 7242
  cciss_compat_ioctl(var_group1, var_cciss_compat_ioctl_45_p1, var_cciss_compat_ioctl_45_p2,
                     var_cciss_compat_ioctl_45_p3);
#line 7274
  goto ldv_38093;
  case 5: 
#line 7317
  ldv_handler_precall();
#line 7318
  cciss_revalidate(var_group2);
#line 7348
  goto ldv_38093;
  case 6: 
#line 7380
  ldv_handler_precall();
#line 7381
  cciss_seq_start(var_group4, var_cciss_seq_start_9_p1);
#line 7422
  goto ldv_38093;
  case 7: 
#line 7454
  ldv_handler_precall();
#line 7455
  cciss_seq_show(var_group4, var_cciss_seq_show_10_p1);
#line 7496
  goto ldv_38093;
  case 8: 
#line 7528
  ldv_handler_precall();
#line 7529
  cciss_seq_next(var_group4, var_cciss_seq_next_11_p1, var_cciss_seq_next_11_p2);
#line 7570
  goto ldv_38093;
  case 9: 
#line 7602
  ldv_handler_precall();
#line 7603
  cciss_seq_stop(var_group4, var_cciss_seq_stop_12_p1);
#line 7644
  goto ldv_38093;
  case 10: ;
#line 7648
  if (ldv_s_cciss_proc_fops_file_operations == 0) {
#line 7676
    ldv_handler_precall();
#line 7677
    res_cciss_seq_open_13 = cciss_seq_open(var_group5, var_group6);
#line 7678
    ldv_check_return_value(res_cciss_seq_open_13);
#line 7679
    if (res_cciss_seq_open_13 != 0) {
#line 7680
      goto ldv_module_exit;
    } else {

    }
#line 7715
    ldv_s_cciss_proc_fops_file_operations = ldv_s_cciss_proc_fops_file_operations + 1;
  } else {

  }
#line 7721
  goto ldv_38093;
  case 11: ;
#line 7725
  if (ldv_s_cciss_proc_fops_file_operations == 1) {
#line 7753
    ldv_handler_precall();
#line 7754
    res_cciss_proc_write_14 = cciss_proc_write(var_group6, var_cciss_proc_write_14_p1,
                                               var_cciss_proc_write_14_p2, var_cciss_proc_write_14_p3);
#line 7755
    ldv_check_return_value((int )res_cciss_proc_write_14);
#line 7756
    if (res_cciss_proc_write_14 < 0L) {
#line 7757
      goto ldv_module_exit;
    } else {

    }
#line 7788
    ldv_s_cciss_proc_fops_file_operations = 0;
  } else {

  }
#line 7794
  goto ldv_38093;
  case 12: ;
#line 7798
  if (ldv_s_cciss_host_type_device_type == 0) {
#line 7834
    ldv_handler_precall();
#line 7835
    cciss_hba_release(var_group7);
#line 7862
    ldv_s_cciss_host_type_device_type = 0;
  } else {

  }
#line 7868
  goto ldv_38093;
  case 13: ;
#line 7872
  if (ldv_s_cciss_dev_type_device_type == 0) {
#line 7908
    ldv_handler_precall();
#line 7909
    cciss_device_release(var_group7);
#line 7936
    ldv_s_cciss_dev_type_device_type = 0;
  } else {

  }
#line 7942
  goto ldv_38093;
  case 14: ;
#line 7946
  if (ldv_s_cciss_pci_driver_pci_driver == 0) {
#line 8002
    res_cciss_init_one_147 = cciss_init_one(var_group8, var_cciss_init_one_147_p1);
#line 8003
    ldv_check_return_value(res_cciss_init_one_147);
#line 8004
    ldv_check_return_value_probe(res_cciss_init_one_147);
#line 8005
    if (res_cciss_init_one_147 != 0) {
#line 8006
      goto ldv_module_exit;
    } else {

    }
#line 8013
    ldv_s_cciss_pci_driver_pci_driver = ldv_s_cciss_pci_driver_pci_driver + 1;
  } else {

  }
#line 8019
  goto ldv_38093;
  case 15: ;
#line 8023
  if (ldv_s_cciss_pci_driver_pci_driver == 1) {
#line 8079
    ldv_handler_precall();
#line 8080
    cciss_remove_one(var_group8);
#line 8081
    ldv_s_cciss_pci_driver_pci_driver = 0;
  } else {

  }
#line 8087
  goto ldv_38093;
  case 16: 
#line 8147
  ldv_handler_precall();
#line 8148
  cciss_shutdown(var_group8);
#line 8161
  goto ldv_38093;
  case 17: 
#line 8165
  LDV_IN_INTERRUPT = 2;
#line 8210
  ldv_handler_precall();
#line 8211
  cciss_intx_discard_completions(var_cciss_intx_discard_completions_106_p0, var_cciss_intx_discard_completions_106_p1);
#line 8229
  LDV_IN_INTERRUPT = 1;
#line 8235
  goto ldv_38093;
  case 18: 
#line 8239
  LDV_IN_INTERRUPT = 2;
#line 8284
  ldv_handler_precall();
#line 8285
  cciss_msix_discard_completions(var_cciss_msix_discard_completions_107_p0, var_cciss_msix_discard_completions_107_p1);
#line 8303
  LDV_IN_INTERRUPT = 1;
#line 8309
  goto ldv_38093;
  case 19: 
#line 8313
  LDV_IN_INTERRUPT = 2;
#line 8358
  ldv_handler_precall();
#line 8359
  do_cciss_intx(var_do_cciss_intx_108_p0, var_do_cciss_intx_108_p1);
#line 8377
  LDV_IN_INTERRUPT = 1;
#line 8383
  goto ldv_38093;
  case 20: 
#line 8387
  LDV_IN_INTERRUPT = 2;
#line 8432
  ldv_handler_precall();
#line 8433
  do_cciss_msix_intr(var_do_cciss_msix_intr_109_p0, var_do_cciss_msix_intr_109_p1);
#line 8451
  LDV_IN_INTERRUPT = 1;
#line 8457
  goto ldv_38093;
  default: ;
#line 8458
  goto ldv_38093;
  }
  ldv_38093: ;
  ldv_38116: 
#line 6892
  tmp___1 = __VERIFIER_nondet_int();
#line 6892
  if (((((tmp___1 != 0 || ldv_s_cciss_fops_block_device_operations != 0) || ldv_s_cciss_proc_fops_file_operations != 0) || ldv_s_cciss_host_type_device_type != 0) || ldv_s_cciss_dev_type_device_type != 0) || ldv_s_cciss_pci_driver_pci_driver != 0) {
#line 6898
    goto ldv_38115;
  } else {

  }

  ldv_module_exit: 
#line 8525
  ldv_handler_precall();
#line 8526
  cciss_cleanup();
  ldv_final: 
#line 8529
  ldv_check_final_state();
#line 8532
  return;
}
}
#line 8536 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_1(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8541
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 8543
  mutex_lock(ldv_func_arg1);
#line 8544
  return;
}
}
#line 8546 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_2(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8551
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 8553
  mutex_unlock(ldv_func_arg1);
#line 8554
  return;
}
}
#line 8556 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_3(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8561
  ldv_mutex_lock_mutex(ldv_func_arg1);
#line 8563
  mutex_lock(ldv_func_arg1);
#line 8564
  return;
}
}
#line 8566 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_mutex_trylock_4(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 8571
  tmp = mutex_trylock(ldv_func_arg1);
#line 8571
  ldv_func_res = tmp;
#line 8573
  tmp___0 = ldv_mutex_trylock_mutex(ldv_func_arg1);
#line 8573
  return (tmp___0);
#line 8575
  return (ldv_func_res);
}
}
#line 8578 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_5(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8583
  ldv_mutex_unlock_mutex(ldv_func_arg1);
#line 8585
  mutex_unlock(ldv_func_arg1);
#line 8586
  return;
}
}
#line 8588 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_6(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8593
  ldv_mutex_lock_cred_guard_mutex(ldv_func_arg1);
#line 8595
  mutex_lock(ldv_func_arg1);
#line 8596
  return;
}
}
#line 8598 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8603
  ldv_mutex_unlock_cred_guard_mutex(ldv_func_arg1);
#line 8605
  mutex_unlock(ldv_func_arg1);
#line 8606
  return;
}
}
#line 8608 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8613
  ldv_mutex_lock_cciss_mutex(ldv_func_arg1);
#line 8615
  mutex_lock(ldv_func_arg1);
#line 8616
  return;
}
}
#line 8618 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8623
  ldv_mutex_unlock_cciss_mutex(ldv_func_arg1);
#line 8625
  mutex_unlock(ldv_func_arg1);
#line 8626
  return;
}
}
#line 8628 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8633
  ldv_mutex_lock_cciss_mutex(ldv_func_arg1);
#line 8635
  mutex_lock(ldv_func_arg1);
#line 8636
  return;
}
}
#line 8638 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8643
  ldv_mutex_unlock_cciss_mutex(ldv_func_arg1);
#line 8645
  mutex_unlock(ldv_func_arg1);
#line 8646
  return;
}
}
#line 8648 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8653
  ldv_mutex_lock_cciss_mutex(ldv_func_arg1);
#line 8655
  mutex_lock(ldv_func_arg1);
#line 8656
  return;
}
}
#line 8658 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8663
  ldv_mutex_unlock_cciss_mutex(ldv_func_arg1);
#line 8665
  mutex_unlock(ldv_func_arg1);
#line 8666
  return;
}
}
#line 8668 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
int ldv_mutex_trylock_14(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 8673
  tmp = mutex_trylock(ldv_func_arg1);
#line 8673
  ldv_func_res = tmp;
#line 8675
  tmp___0 = ldv_mutex_trylock_busy_shutting_down(ldv_func_arg1);
#line 8675
  return (tmp___0);
#line 8677
  return (ldv_func_res);
}
}
#line 8680 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_15(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8685
  ldv_mutex_lock_scan_mutex(ldv_func_arg1);
#line 8687
  mutex_lock(ldv_func_arg1);
#line 8688
  return;
}
}
#line 8690 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8695
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 8697
  mutex_unlock(ldv_func_arg1);
#line 8698
  return;
}
}
#line 8700 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8705
  ldv_mutex_unlock_busy_shutting_down(ldv_func_arg1);
#line 8707
  mutex_unlock(ldv_func_arg1);
#line 8708
  return;
}
}
#line 8710 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8715
  ldv_mutex_lock_scan_mutex(ldv_func_arg1);
#line 8717
  mutex_lock(ldv_func_arg1);
#line 8718
  return;
}
}
#line 8720 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8725
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 8727
  mutex_unlock(ldv_func_arg1);
#line 8728
  return;
}
}
#line 8730 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8735
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 8737
  mutex_unlock(ldv_func_arg1);
#line 8738
  return;
}
}
#line 8740 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_21(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8745
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 8747
  mutex_unlock(ldv_func_arg1);
#line 8748
  return;
}
}
#line 8750 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_22(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8755
  ldv_mutex_lock_scan_mutex(ldv_func_arg1);
#line 8757
  mutex_lock(ldv_func_arg1);
#line 8758
  return;
}
}
#line 8760 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_23(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8765
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 8767
  mutex_unlock(ldv_func_arg1);
#line 8768
  return;
}
}
#line 8770 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8775
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 8777
  mutex_unlock(ldv_func_arg1);
#line 8778
  return;
}
}
#line 8780 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8785
  ldv_mutex_lock_scan_mutex(ldv_func_arg1);
#line 8787
  mutex_lock(ldv_func_arg1);
#line 8788
  return;
}
}
#line 8790 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8795
  ldv_mutex_unlock_scan_mutex(ldv_func_arg1);
#line 8797
  mutex_unlock(ldv_func_arg1);
#line 8798
  return;
}
}
#line 8800 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_lock_27(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8805
  ldv_mutex_lock_busy_shutting_down(ldv_func_arg1);
#line 8807
  mutex_lock(ldv_func_arg1);
#line 8808
  return;
}
}
#line 8810 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/dscv/ri/32_7a/drivers/block/cciss.c.prepared"
void ldv_mutex_unlock_28(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 8815
  ldv_mutex_unlock_busy_shutting_down(ldv_func_arg1);
#line 8817
  mutex_unlock(ldv_func_arg1);
#line 8818
  return;
}
}
#line 10 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void)  __attribute__((__no_instrument_function__)) ;
#line 10 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: 
#line 12
  goto ERROR;
}
}
#line 25
extern int __VERIFIER_nondet_int(void) ;
#line 49 "/home/mikhail/ldv/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 51
  return (exp);
}
}
#line 8 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_busy_shutting_down  ;
#line 11 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_busy_shutting_down(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_busy_shutting_down == 1) {

  } else {
#line 16
    ldv_error();
  }
#line 19
  nondetermined = __VERIFIER_nondet_int();
#line 22
  if (nondetermined) {
#line 25
    ldv_mutex_busy_shutting_down = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_busy_shutting_down(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_busy_shutting_down == 1) {

  } else {
#line 42
    ldv_error();
  }
#line 45
  nondetermined = __VERIFIER_nondet_int();
#line 48
  if (nondetermined) {
#line 51
    ldv_mutex_busy_shutting_down = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_busy_shutting_down(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_busy_shutting_down == 1) {

  } else {
#line 66
    ldv_error();
  }
#line 68
  ldv_mutex_busy_shutting_down = 2;
#line 69
  return;
}
}
#line 72 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_busy_shutting_down(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_busy_shutting_down == 1) {

  } else {
#line 77
    ldv_error();
  }
#line 80
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 83
  if (is_mutex_held_by_another_thread) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_busy_shutting_down = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_busy_shutting_down(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_busy_shutting_down == 1) {

  } else {
#line 103
    ldv_error();
  }
#line 106
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_busy_shutting_down = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_busy_shutting_down(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_busy_shutting_down == 1) {
#line 130
    nondetermined = __VERIFIER_nondet_int();
#line 133
    if (nondetermined) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_busy_shutting_down(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_busy_shutting_down == 2) {

  } else {
#line 155
    ldv_error();
  }
#line 157
  ldv_mutex_busy_shutting_down = 1;
#line 158
  return;
}
}
#line 160 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cciss_mutex  ;
#line 163 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cciss_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 168
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 168
    ldv_error();
  }
#line 171
  nondetermined = __VERIFIER_nondet_int();
#line 174
  if (nondetermined) {
#line 177
    ldv_mutex_cciss_mutex = 2;
#line 179
    return (0);
  } else {
#line 184
    return (-4);
  }
}
}
#line 189 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cciss_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 194
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 194
    ldv_error();
  }
#line 197
  nondetermined = __VERIFIER_nondet_int();
#line 200
  if (nondetermined) {
#line 203
    ldv_mutex_cciss_mutex = 2;
#line 205
    return (0);
  } else {
#line 210
    return (-4);
  }
}
}
#line 215 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cciss_mutex(struct mutex *lock ) 
{ 


  {
#line 218
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 218
    ldv_error();
  }
#line 220
  ldv_mutex_cciss_mutex = 2;
#line 221
  return;
}
}
#line 224 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cciss_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 229
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 229
    ldv_error();
  }
#line 232
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 235
  if (is_mutex_held_by_another_thread) {
#line 238
    return (0);
  } else {
#line 243
    ldv_mutex_cciss_mutex = 2;
#line 245
    return (1);
  }
}
}
#line 250 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cciss_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 255
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 255
    ldv_error();
  }
#line 258
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 261
  if (atomic_value_after_dec == 0) {
#line 264
    ldv_mutex_cciss_mutex = 2;
#line 266
    return (1);
  } else {

  }
#line 270
  return (0);
}
}
#line 275 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cciss_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 279
  if (ldv_mutex_cciss_mutex == 1) {
#line 282
    nondetermined = __VERIFIER_nondet_int();
#line 285
    if (nondetermined) {
#line 288
      return (0);
    } else {
#line 293
      return (1);
    }
  } else {
#line 299
    return (1);
  }
}
}
#line 304 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cciss_mutex(struct mutex *lock ) 
{ 


  {
#line 307
  if (ldv_mutex_cciss_mutex == 2) {

  } else {
#line 307
    ldv_error();
  }
#line 309
  ldv_mutex_cciss_mutex = 1;
#line 310
  return;
}
}
#line 312 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_cred_guard_mutex  ;
#line 315 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 320
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 320
    ldv_error();
  }
#line 323
  nondetermined = __VERIFIER_nondet_int();
#line 326
  if (nondetermined) {
#line 329
    ldv_mutex_cred_guard_mutex = 2;
#line 331
    return (0);
  } else {
#line 336
    return (-4);
  }
}
}
#line 341 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 346
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 346
    ldv_error();
  }
#line 349
  nondetermined = __VERIFIER_nondet_int();
#line 352
  if (nondetermined) {
#line 355
    ldv_mutex_cred_guard_mutex = 2;
#line 357
    return (0);
  } else {
#line 362
    return (-4);
  }
}
}
#line 367 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_cred_guard_mutex(struct mutex *lock ) 
{ 


  {
#line 370
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 370
    ldv_error();
  }
#line 372
  ldv_mutex_cred_guard_mutex = 2;
#line 373
  return;
}
}
#line 376 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_cred_guard_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 381
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 381
    ldv_error();
  }
#line 384
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 387
  if (is_mutex_held_by_another_thread) {
#line 390
    return (0);
  } else {
#line 395
    ldv_mutex_cred_guard_mutex = 2;
#line 397
    return (1);
  }
}
}
#line 402 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_cred_guard_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 407
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 407
    ldv_error();
  }
#line 410
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 413
  if (atomic_value_after_dec == 0) {
#line 416
    ldv_mutex_cred_guard_mutex = 2;
#line 418
    return (1);
  } else {

  }
#line 422
  return (0);
}
}
#line 427 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_cred_guard_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 431
  if (ldv_mutex_cred_guard_mutex == 1) {
#line 434
    nondetermined = __VERIFIER_nondet_int();
#line 437
    if (nondetermined) {
#line 440
      return (0);
    } else {
#line 445
      return (1);
    }
  } else {
#line 451
    return (1);
  }
}
}
#line 456 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_cred_guard_mutex(struct mutex *lock ) 
{ 


  {
#line 459
  if (ldv_mutex_cred_guard_mutex == 2) {

  } else {
#line 459
    ldv_error();
  }
#line 461
  ldv_mutex_cred_guard_mutex = 1;
#line 462
  return;
}
}
#line 464 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  ;
#line 467 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 472
  if (ldv_mutex_lock == 1) {

  } else {
#line 472
    ldv_error();
  }
#line 475
  nondetermined = __VERIFIER_nondet_int();
#line 478
  if (nondetermined) {
#line 481
    ldv_mutex_lock = 2;
#line 483
    return (0);
  } else {
#line 488
    return (-4);
  }
}
}
#line 493 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 498
  if (ldv_mutex_lock == 1) {

  } else {
#line 498
    ldv_error();
  }
#line 501
  nondetermined = __VERIFIER_nondet_int();
#line 504
  if (nondetermined) {
#line 507
    ldv_mutex_lock = 2;
#line 509
    return (0);
  } else {
#line 514
    return (-4);
  }
}
}
#line 519 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 522
  if (ldv_mutex_lock == 1) {

  } else {
#line 522
    ldv_error();
  }
#line 524
  ldv_mutex_lock = 2;
#line 525
  return;
}
}
#line 528 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 533
  if (ldv_mutex_lock == 1) {

  } else {
#line 533
    ldv_error();
  }
#line 536
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 539
  if (is_mutex_held_by_another_thread) {
#line 542
    return (0);
  } else {
#line 547
    ldv_mutex_lock = 2;
#line 549
    return (1);
  }
}
}
#line 554 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 559
  if (ldv_mutex_lock == 1) {

  } else {
#line 559
    ldv_error();
  }
#line 562
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 565
  if (atomic_value_after_dec == 0) {
#line 568
    ldv_mutex_lock = 2;
#line 570
    return (1);
  } else {

  }
#line 574
  return (0);
}
}
#line 579 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 583
  if (ldv_mutex_lock == 1) {
#line 586
    nondetermined = __VERIFIER_nondet_int();
#line 589
    if (nondetermined) {
#line 592
      return (0);
    } else {
#line 597
      return (1);
    }
  } else {
#line 603
    return (1);
  }
}
}
#line 608 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 611
  if (ldv_mutex_lock == 2) {

  } else {
#line 611
    ldv_error();
  }
#line 613
  ldv_mutex_lock = 1;
#line 614
  return;
}
}
#line 616 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex  ;
#line 619 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 624
  if (ldv_mutex_mutex == 1) {

  } else {
#line 624
    ldv_error();
  }
#line 627
  nondetermined = __VERIFIER_nondet_int();
#line 630
  if (nondetermined) {
#line 633
    ldv_mutex_mutex = 2;
#line 635
    return (0);
  } else {
#line 640
    return (-4);
  }
}
}
#line 645 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 650
  if (ldv_mutex_mutex == 1) {

  } else {
#line 650
    ldv_error();
  }
#line 653
  nondetermined = __VERIFIER_nondet_int();
#line 656
  if (nondetermined) {
#line 659
    ldv_mutex_mutex = 2;
#line 661
    return (0);
  } else {
#line 666
    return (-4);
  }
}
}
#line 671 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex(struct mutex *lock ) 
{ 


  {
#line 674
  if (ldv_mutex_mutex == 1) {

  } else {
#line 674
    ldv_error();
  }
#line 676
  ldv_mutex_mutex = 2;
#line 677
  return;
}
}
#line 680 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 685
  if (ldv_mutex_mutex == 1) {

  } else {
#line 685
    ldv_error();
  }
#line 688
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 691
  if (is_mutex_held_by_another_thread) {
#line 694
    return (0);
  } else {
#line 699
    ldv_mutex_mutex = 2;
#line 701
    return (1);
  }
}
}
#line 706 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 711
  if (ldv_mutex_mutex == 1) {

  } else {
#line 711
    ldv_error();
  }
#line 714
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 717
  if (atomic_value_after_dec == 0) {
#line 720
    ldv_mutex_mutex = 2;
#line 722
    return (1);
  } else {

  }
#line 726
  return (0);
}
}
#line 731 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 735
  if (ldv_mutex_mutex == 1) {
#line 738
    nondetermined = __VERIFIER_nondet_int();
#line 741
    if (nondetermined) {
#line 744
      return (0);
    } else {
#line 749
      return (1);
    }
  } else {
#line 755
    return (1);
  }
}
}
#line 760 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex(struct mutex *lock ) 
{ 


  {
#line 763
  if (ldv_mutex_mutex == 2) {

  } else {
#line 763
    ldv_error();
  }
#line 765
  ldv_mutex_mutex = 1;
#line 766
  return;
}
}
#line 768 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_scan_mutex  ;
#line 771 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_scan_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 776
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 776
    ldv_error();
  }
#line 779
  nondetermined = __VERIFIER_nondet_int();
#line 782
  if (nondetermined) {
#line 785
    ldv_mutex_scan_mutex = 2;
#line 787
    return (0);
  } else {
#line 792
    return (-4);
  }
}
}
#line 797 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_scan_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 802
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 802
    ldv_error();
  }
#line 805
  nondetermined = __VERIFIER_nondet_int();
#line 808
  if (nondetermined) {
#line 811
    ldv_mutex_scan_mutex = 2;
#line 813
    return (0);
  } else {
#line 818
    return (-4);
  }
}
}
#line 823 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_scan_mutex(struct mutex *lock ) 
{ 


  {
#line 826
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 826
    ldv_error();
  }
#line 828
  ldv_mutex_scan_mutex = 2;
#line 829
  return;
}
}
#line 832 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_scan_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 837
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 837
    ldv_error();
  }
#line 840
  is_mutex_held_by_another_thread = __VERIFIER_nondet_int();
#line 843
  if (is_mutex_held_by_another_thread) {
#line 846
    return (0);
  } else {
#line 851
    ldv_mutex_scan_mutex = 2;
#line 853
    return (1);
  }
}
}
#line 858 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_scan_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 863
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 863
    ldv_error();
  }
#line 866
  atomic_value_after_dec = __VERIFIER_nondet_int();
#line 869
  if (atomic_value_after_dec == 0) {
#line 872
    ldv_mutex_scan_mutex = 2;
#line 874
    return (1);
  } else {

  }
#line 878
  return (0);
}
}
#line 883 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_scan_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 887
  if (ldv_mutex_scan_mutex == 1) {
#line 890
    nondetermined = __VERIFIER_nondet_int();
#line 893
    if (nondetermined) {
#line 896
      return (0);
    } else {
#line 901
      return (1);
    }
  } else {
#line 907
    return (1);
  }
}
}
#line 912 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_scan_mutex(struct mutex *lock ) 
{ 


  {
#line 915
  if (ldv_mutex_scan_mutex == 2) {

  } else {
#line 915
    ldv_error();
  }
#line 917
  ldv_mutex_scan_mutex = 1;
#line 918
  return;
}
}
#line 922 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_initialize(void) 
{ 


  {
#line 925
  ldv_mutex_busy_shutting_down = 1;
#line 927
  ldv_mutex_cciss_mutex = 1;
#line 929
  ldv_mutex_cred_guard_mutex = 1;
#line 931
  ldv_mutex_lock = 1;
#line 933
  ldv_mutex_mutex = 1;
#line 935
  ldv_mutex_scan_mutex = 1;
#line 936
  return;
}
}
#line 939 "/home/mikhail/launches/cpachecker-regression2/launcher-working-dir/ldv-manager-work-dir/work/current--X--drivers/block/cciss.ko--X--regression-testlinux-3.8-rc1--X--32_7a--X--cpachecker/linux-3.8-rc1/csd_deg_dscv/12/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 942
  if (ldv_mutex_busy_shutting_down == 1) {

  } else {
#line 942
    ldv_error();
  }
#line 944
  if (ldv_mutex_cciss_mutex == 1) {

  } else {
#line 944
    ldv_error();
  }
#line 946
  if (ldv_mutex_cred_guard_mutex == 1) {

  } else {
#line 946
    ldv_error();
  }
#line 948
  if (ldv_mutex_lock == 1) {

  } else {
#line 948
    ldv_error();
  }
#line 950
  if (ldv_mutex_mutex == 1) {

  } else {
#line 950
    ldv_error();
  }
#line 952
  if (ldv_mutex_scan_mutex == 1) {

  } else {
#line 952
    ldv_error();
  }
#line 953
  return;
}
}
