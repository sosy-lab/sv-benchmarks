extern void __VERIFIER_error() __attribute__ ((__noreturn__));

/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 11 "include/asm/posix_types_64.h"
typedef unsigned int __kernel_mode_t;
#line 18 "include/asm/posix_types_64.h"
typedef unsigned long __kernel_size_t;
#line 19 "include/asm/posix_types_64.h"
typedef long __kernel_ssize_t;
#line 21 "include/asm/posix_types_64.h"
typedef long __kernel_time_t;
#line 25 "include/asm/posix_types_64.h"
typedef int __kernel_clockid_t;
#line 21 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 24 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 28 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 47 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 50 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 21 "include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 29 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 66 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 71 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 81 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 192 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 7 "include/asm/processor.h"
struct task_struct;
#line 97 "include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 59 "include/asm/alternative.h"
struct module;
#line 10 "include/asm-generic/bug.h"
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
#line 77 "include/asm/page_64.h"
struct page;
#line 10 "include/linux/personality.h"
struct exec_domain;
#line 88
struct map_segment;
#line 88 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 366 "include/asm/processor.h"
struct kmem_cache;
#line 604 "include/asm/processor.h"
struct __anonstruct_mm_segment_t_23 {
   unsigned long seg ;
};
#line 604 "include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_23 mm_segment_t;
#line 19 "include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 12 "include/linux/thread_info.h"
struct timespec;
#line 13
struct compat_timespec;
#line 18 "include/linux/thread_info.h"
struct __anonstruct____missing_field_name_25 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
#line 18 "include/linux/thread_info.h"
struct __anonstruct_futex_26 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
};
#line 18 "include/linux/thread_info.h"
struct __anonstruct_nanosleep_27 {
   clockid_t index ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 18 "include/linux/thread_info.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField7 ;
   struct __anonstruct_futex_26 futex ;
   struct __anonstruct_nanosleep_27 nanosleep ;
};
#line 18 "include/linux/thread_info.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_24 __annonCompField8 ;
};
#line 26 "include/asm/thread_info_64.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
};
#line 8 "include/asm/spinlock_types.h"
struct __anonstruct_raw_spinlock_t_28 {
   unsigned int slock ;
};
#line 8 "include/asm/spinlock_types.h"
typedef struct __anonstruct_raw_spinlock_t_28 raw_spinlock_t;
#line 340 "include/linux/lockdep.h"
struct lock_class_key {

};
#line 20 "include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_30 {
   raw_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 20 "include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_30 spinlock_t;
#line 25 "include/asm/atomic_64.h"
struct __anonstruct_atomic_t_32 {
   int counter ;
};
#line 25 "include/asm/atomic_64.h"
typedef struct __anonstruct_atomic_t_32 atomic_t;
#line 202 "include/asm/atomic_64.h"
struct __anonstruct_atomic64_t_33 {
   long counter ;
};
#line 202 "include/asm/atomic_64.h"
typedef struct __anonstruct_atomic64_t_33 atomic64_t;
#line 23 "include/asm-generic/atomic.h"
typedef atomic64_t atomic_long_t;
#line 14 "include/linux/time.h"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
#line 27 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 28 "include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 32 "include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 33 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 181 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 181 "include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 20 "include/linux/sysfs.h"
struct kobject;
#line 27 "include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
#line 76 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 21 "include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
#line 60 "include/linux/kobject.h"
struct kset;
#line 60
struct kobj_type;
#line 60
struct sysfs_dirent;
#line 60 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct kref kref ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
#line 105 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
#line 111 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
#line 118 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
#line 152 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
#line 29 "include/linux/moduleparam.h"
struct kernel_param;
#line 36
struct kparam_string;
#line 36
struct kparam_array;
#line 36 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_39 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 36 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_39 __annonCompField9 ;
};
#line 49 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 55 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
#line 18 "include/linux/marker.h"
struct marker;
#line 32 "include/linux/marker.h"
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
#line 35 "include/linux/marker.h"
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
#line 40 "include/linux/marker.h"
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private , char const   *fmt 
                , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
} __attribute__((__aligned__(8))) ;
#line 48 "include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
   char const   *name ;
   void *magic ;
};
#line 9 "include/linux/timer.h"
struct tvec_base;
#line 11 "include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base *base ;
   void *start_site ;
   char start_comm[16] ;
   int start_pid ;
};
#line 14 "include/linux/workqueue.h"
struct workqueue_struct;
#line 16
struct work_struct;
#line 25 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
#line 39 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
#line 14 "include/linux/slub_def.h"
enum stat_item {
    ALLOC_FASTPATH = 0,
    ALLOC_SLOWPATH = 1,
    FREE_FASTPATH = 2,
    FREE_SLOWPATH = 3,
    FREE_FROZEN = 4,
    FREE_ADD_PARTIAL = 5,
    FREE_REMOVE_PARTIAL = 6,
    ALLOC_FROM_PARTIAL = 7,
    ALLOC_SLAB = 8,
    ALLOC_REFILL = 9,
    FREE_SLAB = 10,
    CPUSLAB_FLUSH = 11,
    DEACTIVATE_FULL = 12,
    DEACTIVATE_EMPTY = 13,
    DEACTIVATE_TO_HEAD = 14,
    DEACTIVATE_TO_TAIL = 15,
    DEACTIVATE_REMOTE_FREES = 16,
    ORDER_FALLBACK = 17,
    NR_SLUB_STAT_ITEMS = 18
} ;
#line 35 "include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
   unsigned int stat[NR_SLUB_STAT_ITEMS] ;
};
#line 46 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 62 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 69 "include/linux/slub_def.h"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(struct kmem_cache * , void * ) ;
   int inuse ;
   int align ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 6] ;
   struct kmem_cache_cpu *cpu_slab[8] ;
};
#line 10 "include/asm/local.h"
struct __anonstruct_local_t_94 {
   atomic_long_t a ;
};
#line 10 "include/asm/local.h"
typedef struct __anonstruct_local_t_94 local_t;
#line 5 "include/asm/module.h"
struct mod_arch_specific {

};
#line 33 "include/linux/module.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 57 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
};
#line 69
struct exception_table_entry;
#line 220 "include/linux/module.h"
struct module_ref {
   local_t count ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
#line 225
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 232
struct module_param_attrs;
#line 232
struct module_sect_attrs;
#line 232
struct module_notes_attrs;
#line 232 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_param_attrs *param_attrs ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned int num_syms ;
   unsigned long const   *crcs ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned int num_gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned int num_unused_syms ;
   unsigned long const   *unused_crcs ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned int num_unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned int num_gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_exentries ;
   struct exception_table_entry  const  *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned long init_size ;
   unsigned long core_size ;
   unsigned long init_text_size ;
   unsigned long core_text_size ;
   void *unwind_info ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   unsigned int num_bugs ;
   struct module_ref ref[8] ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   Elf64_Sym *symtab ;
   unsigned long num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
};
#line 67 "include/asm/uaccess_64.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 1 "<compiler builtins>"
void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;
#line 75 "include/asm/bitops.h"
__inline static void ( __attribute__((__always_inline__)) clear_bit)(int nr , void volatile   *addr ) 
{ 


  {
#line 77
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " .balign 8 "
                       "\n"
                       " .quad "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 78
  return;
}
}
#line 185 "include/linux/kernel.h"
extern int ( /* format attribute */  printk)(char const   *fmt  , ...) ;
#line 33 "include/asm/string_64.h"
extern void *__memcpy(void *to , void const   *from , size_t len ) ;
#line 47
extern void *memset(void *s , int c , size_t n ) ;
#line 52
extern int memcmp(void const   *cs , void const   *ct , unsigned long count ) ;
#line 140 "include/linux/moduleparam.h"
extern int param_set_uint(char const   *val , struct kernel_param *kp ) ;
#line 141
extern int param_get_uint(char *buffer , struct kernel_param *kp ) ;
#line 135 "include/linux/mutex.h"
void mutex_lock(struct mutex *lock ) ;
#line 149
void mutex_unlock(struct mutex *lock ) ;
#line 215 "include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 225
extern void free_pages(unsigned long addr , unsigned int order ) ;
#line 100 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 26 "include/linux/timer.h"
extern struct tvec_base boot_tvec_bases ;
#line 171
extern int del_timer_sync(struct timer_list *timer ) ;
#line 150 "include/linux/workqueue.h"
extern struct workqueue_struct *__create_workqueue_key(char const   *name , int singlethread ,
                                                       int freezeable , struct lock_class_key *key ,
                                                       char const   *lock_name ) ;
#line 179
extern void destroy_workqueue(struct workqueue_struct *wq ) ;
#line 182
extern int queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *work ,
                              unsigned long delay ) ;
#line 187
extern void flush_workqueue(struct workqueue_struct *wq ) ;
#line 209 "include/linux/workqueue.h"
__inline static int ( __attribute__((__always_inline__)) cancel_delayed_work)(struct delayed_work *work ) 
{ 
  int ret ;

  {
#line 213
  ret = del_timer_sync(& work->timer);
#line 214
  if (ret) {
#line 215
    clear_bit(0, (unsigned long *)(& work->work.data));
  } else {

  }
#line 216
  return (ret);
}
}
#line 204 "include/linux/slub_def.h"
extern void *__kmalloc(size_t size , gfp_t flags ) ;
#line 211 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 226
  tmp___2 = __kmalloc(size, flags);
#line 226
  return (tmp___2);
}
}
#line 65 "include/linux/module.h"
int init_module(void) ;
#line 66
void cleanup_module(void) ;
#line 29 "include/linux/ks0108.h"
extern void ks0108_writedata(unsigned char byte ) ;
#line 32
extern void ks0108_writecontrol(unsigned char byte ) ;
#line 35
extern void ks0108_displaystate(unsigned char state ) ;
#line 38
extern void ks0108_startline(unsigned char startline ) ;
#line 41
extern void ks0108_address(unsigned char address ) ;
#line 44
extern void ks0108_page(unsigned char page ) ;
#line 47
extern unsigned char ks0108_isinited(void) ;
#line 42 "include/linux/cfag12864b.h"
unsigned char *cfag12864b_buffer  ;
#line 49
unsigned int cfag12864b_getrate(void) ;
#line 57
unsigned char cfag12864b_enable(void) ;
#line 64
void cfag12864b_disable(void) ;
#line 74
unsigned char cfag12864b_isenabled(void) ;
#line 79
unsigned char cfag12864b_isinited(void) ;
#line 49 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned int cfag12864b_rate  =    20;
#line 50 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __param_str_cfag12864b_rate[16]  = 
#line 50
  {      'c',      'f',      'a',      'g', 
        '1',      '2',      '8',      '6', 
        '4',      'b',      '_',      'r', 
        'a',      't',      'e',      '\000'};
#line 50 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct kernel_param  const  __param_cfag12864b_rate  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_cfag12864b_rate, (256 | 32) | 4, & param_set_uint, & param_get_uint,
    {& cfag12864b_rate}};
#line 50 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __mod_cfag12864b_ratetype50[30]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
#line 50
  {      'p',      'a',      'r',      'm', 
        't',      'y',      'p',      'e', 
        '=',      'c',      'f',      'a', 
        'g',      '1',      '2',      '8', 
        '6',      '4',      'b',      '_', 
        'r',      'a',      't',      'e', 
        ':',      'u',      'i',      'n', 
        't',      '\000'};
#line 51 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __mod_cfag12864b_rate52[43]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
#line 51
  {      'p',      'a',      'r',      'm', 
        '=',      'c',      'f',      'a', 
        'g',      '1',      '2',      '8', 
        '6',      '4',      'b',      '_', 
        'r',      'a',      't',      'e', 
        ':',      'R',      'e',      'f', 
        'r',      'e',      's',      'h', 
        ' ',      'r',      'a',      't', 
        'e',      ' ',      '(',      'h', 
        'e',      'r',      't',      'z', 
        's',      ')',      '\000'};
#line 54 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
unsigned int cfag12864b_getrate(void) 
{ 


  {
#line 56
  return (cfag12864b_rate);
}
}
#line 85 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned char cfag12864b_state  ;
#line 87 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_set(void) 
{ 


  {
#line 89
  ks0108_writecontrol(cfag12864b_state);
#line 90
  return;
}
}
#line 92 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_setbit(unsigned char state , unsigned char n ) 
{ 


  {
#line 94
  if (state) {
#line 95
    cfag12864b_state = (int )cfag12864b_state | (1 << (int )n);
  } else {
#line 97
    cfag12864b_state = (int )cfag12864b_state & ~ (1 << (int )n);
  }
#line 98
  return;
}
}
#line 100 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_e(unsigned char state ) 
{ 


  {
#line 102
  cfag12864b_setbit(state, 0);
#line 103
  cfag12864b_set();
#line 104
  return;
}
}
#line 106 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_cs1(unsigned char state ) 
{ 


  {
#line 108
  cfag12864b_setbit(state, 2);
#line 109
  return;
}
}
#line 111 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_cs2(unsigned char state ) 
{ 


  {
#line 113
  cfag12864b_setbit(state, 1);
#line 114
  return;
}
}
#line 116 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_di(unsigned char state ) 
{ 


  {
#line 118
  cfag12864b_setbit(state, 3);
#line 119
  return;
}
}
#line 121 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_setcontrollers(unsigned char first , unsigned char second ) 
{ 


  {
#line 124
  if (first) {
#line 125
    cfag12864b_cs1(0);
  } else {
#line 127
    cfag12864b_cs1(1);
  }
#line 129
  if (second) {
#line 130
    cfag12864b_cs2(0);
  } else {
#line 132
    cfag12864b_cs2(1);
  }
#line 133
  return;
}
}
#line 135 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_controller(unsigned char which ) 
{ 


  {
#line 137
  if ((int )which == 0) {
#line 138
    cfag12864b_setcontrollers(1, 0);
  } else
#line 139
  if ((int )which == 1) {
#line 140
    cfag12864b_setcontrollers(0, 1);
  } else {

  }
#line 141
  return;
}
}
#line 143 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_displaystate(unsigned char state ) 
{ 


  {
#line 145
  cfag12864b_di(0);
#line 146
  cfag12864b_e(1);
#line 147
  ks0108_displaystate(state);
#line 148
  cfag12864b_e(0);
#line 149
  return;
}
}
#line 151 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_address(unsigned char address ) 
{ 


  {
#line 153
  cfag12864b_di(0);
#line 154
  cfag12864b_e(1);
#line 155
  ks0108_address(address);
#line 156
  cfag12864b_e(0);
#line 157
  return;
}
}
#line 159 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_page(unsigned char page ) 
{ 


  {
#line 161
  cfag12864b_di(0);
#line 162
  cfag12864b_e(1);
#line 163
  ks0108_page(page);
#line 164
  cfag12864b_e(0);
#line 165
  return;
}
}
#line 167 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_startline(unsigned char startline ) 
{ 


  {
#line 169
  cfag12864b_di(0);
#line 170
  cfag12864b_e(1);
#line 171
  ks0108_startline(startline);
#line 172
  cfag12864b_e(0);
#line 173
  return;
}
}
#line 175 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_writebyte(unsigned char byte ) 
{ 


  {
#line 177
  cfag12864b_di(1);
#line 178
  cfag12864b_e(1);
#line 179
  ks0108_writedata(byte);
#line 180
  cfag12864b_e(0);
#line 181
  return;
}
}
#line 183 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_nop(void) 
{ 


  {
#line 185
  cfag12864b_startline(0);
#line 186
  return;
}
}
#line 192 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_on(void) 
{ 


  {
#line 194
  cfag12864b_setcontrollers(1, 1);
#line 195
  cfag12864b_displaystate(1);
#line 196
  return;
}
}
#line 198 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_off(void) 
{ 


  {
#line 200
  cfag12864b_setcontrollers(1, 1);
#line 201
  cfag12864b_displaystate(0);
#line 202
  return;
}
}
#line 204 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_clear(void) 
{ 
  unsigned char i ;
  unsigned char j ;

  {
#line 208
  cfag12864b_setcontrollers(1, 1);
#line 209
  i = 0;
#line 209
  while (1) {
#line 209
    if ((int )i < 8) {

    } else {
#line 209
      break;
    }
#line 210
    cfag12864b_page(i);
#line 211
    cfag12864b_address(0);
#line 212
    j = 0;
#line 212
    while (1) {
#line 212
      if ((int )j < 64) {

      } else {
#line 212
        break;
      }
#line 213
      cfag12864b_writebyte(0);
#line 212
      j = (unsigned char )((int )j + 1);
    }
#line 209
    i = (unsigned char )((int )i + 1);
  }
#line 215
  return;
}
}
#line 222 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned char *cfag12864b_cache  ;
#line 223 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct mutex cfag12864b_mutex  =    {{1}, {{0}, 3735899821U, -1, (void *)-1L}, {& cfag12864b_mutex.wait_list, & cfag12864b_mutex.wait_list},
    0, 0, & cfag12864b_mutex};
#line 224 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned char cfag12864b_updating  ;
#line 225
static void cfag12864b_update(struct work_struct *work ) ;
#line 226 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct workqueue_struct *cfag12864b_workqueue  ;
#line 227 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct delayed_work cfag12864b_work  =    {{{0}, {& cfag12864b_work.work.entry, & cfag12864b_work.work.entry}, & cfag12864b_update},
    {{0, (void *)1953723489}, 0, (void *)0, 0, & boot_tvec_bases, 0, {(char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0},
     0}};
#line 229 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_queue(void) 
{ 


  {
#line 231
  queue_delayed_work(cfag12864b_workqueue, & cfag12864b_work, 250U / cfag12864b_rate);
#line 233
  return;
}
}
#line 235 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
unsigned char cfag12864b_enable(void) 
{ 
  unsigned char ret ;

  {
#line 239
  mutex_lock(& cfag12864b_mutex);
#line 241
  if (! cfag12864b_updating) {
#line 242
    cfag12864b_updating = 1;
#line 243
    cfag12864b_queue();
#line 244
    ret = 0;
  } else {
#line 246
    ret = 1;
  }
#line 248
  mutex_unlock(& cfag12864b_mutex);
#line 250
  return (ret);
}
}
#line 253 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
void cfag12864b_disable(void) 
{ 


  {
#line 255
  mutex_lock(& cfag12864b_mutex);
#line 257
  if (cfag12864b_updating) {
#line 258
    cfag12864b_updating = 0;
#line 259
    cancel_delayed_work(& cfag12864b_work);
#line 260
    flush_workqueue(cfag12864b_workqueue);
  } else {

  }
#line 263
  mutex_unlock(& cfag12864b_mutex);
#line 264
  return;
}
}
#line 266 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
unsigned char cfag12864b_isenabled(void) 
{ 


  {
#line 268
  return (cfag12864b_updating);
}
}
#line 271 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_update(struct work_struct *work ) 
{ 
  unsigned char c ;
  unsigned short i ;
  unsigned short j ;
  unsigned short k ;
  unsigned short b ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 276
  tmp = memcmp(cfag12864b_cache, cfag12864b_buffer, (2 * 8) * 64);
#line 276
  if (tmp) {
#line 277
    i = 0;
#line 277
    while (1) {
#line 277
      if ((int )i < 2) {

      } else {
#line 277
        break;
      }
#line 278
      cfag12864b_controller(i);
#line 279
      cfag12864b_nop();
#line 280
      j = 0;
#line 280
      while (1) {
#line 280
        if ((int )j < 8) {

        } else {
#line 280
          break;
        }
#line 281
        cfag12864b_page(j);
#line 282
        cfag12864b_nop();
#line 283
        cfag12864b_address(0);
#line 284
        cfag12864b_nop();
#line 285
        k = 0;
#line 285
        while (1) {
#line 285
          if ((int )k < 64) {

          } else {
#line 285
            break;
          }
#line 286
          c = 0;
#line 286
          b = 0;
#line 286
          while (1) {
#line 286
            if ((int )b < 8) {

            } else {
#line 286
              break;
            }
#line 287
            if ((int )*(cfag12864b_buffer + ((((int )i * 64) / 8 + (int )k / 8) + (((int )j * 8 + (int )b) * 128) / 8)) & (1 << (int )k % 8)) {
#line 292
              c = (int )c | (1 << (int )b);
            } else {

            }
#line 286
            b = (unsigned short )((int )b + 1);
          }
#line 293
          cfag12864b_writebyte(c);
#line 285
          k = (unsigned short )((int )k + 1);
        }
#line 280
        j = (unsigned short )((int )j + 1);
      }
#line 277
      i = (unsigned short )((int )i + 1);
    }
#line 298
    __len = (2 * 8) * 64;
#line 298
    if (__len >= (size_t )64) {
#line 298
      __ret = __memcpy(cfag12864b_cache, cfag12864b_buffer, __len);
    } else {
#line 298
      __ret = __builtin_memcpy(cfag12864b_cache, cfag12864b_buffer, __len);
    }
  } else {

  }
#line 301
  if (cfag12864b_updating) {
#line 302
    cfag12864b_queue();
  } else {

  }
#line 303
  return;
}
}
#line 309
extern void *__crc_cfag12864b_buffer  __attribute__((__weak__)) ;
#line 309 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned long const   __kcrctab_cfag12864b_buffer  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long )(& __crc_cfag12864b_buffer);
#line 309 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __kstrtab_cfag12864b_buffer[18]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
#line 309
  {      'c',      'f',      'a',      'g', 
        '1',      '2',      '8',      '6', 
        '4',      'b',      '_',      'b', 
        'u',      'f',      'f',      'e', 
        'r',      '\000'};
#line 309 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct kernel_symbol  const  __ksymtab_cfag12864b_buffer  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& cfag12864b_buffer), __kstrtab_cfag12864b_buffer};
#line 310
extern void *__crc_cfag12864b_getrate  __attribute__((__weak__)) ;
#line 310 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned long const   __kcrctab_cfag12864b_getrate  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long )(& __crc_cfag12864b_getrate);
#line 310 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __kstrtab_cfag12864b_getrate[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
#line 310
  {      'c',      'f',      'a',      'g', 
        '1',      '2',      '8',      '6', 
        '4',      'b',      '_',      'g', 
        'e',      't',      'r',      'a', 
        't',      'e',      '\000'};
#line 310 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct kernel_symbol  const  __ksymtab_cfag12864b_getrate  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& cfag12864b_getrate), __kstrtab_cfag12864b_getrate};
#line 311
extern void *__crc_cfag12864b_enable  __attribute__((__weak__)) ;
#line 311 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned long const   __kcrctab_cfag12864b_enable  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long )(& __crc_cfag12864b_enable);
#line 311 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __kstrtab_cfag12864b_enable[18]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
#line 311
  {      'c',      'f',      'a',      'g', 
        '1',      '2',      '8',      '6', 
        '4',      'b',      '_',      'e', 
        'n',      'a',      'b',      'l', 
        'e',      '\000'};
#line 311 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct kernel_symbol  const  __ksymtab_cfag12864b_enable  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& cfag12864b_enable), __kstrtab_cfag12864b_enable};
#line 312
extern void *__crc_cfag12864b_disable  __attribute__((__weak__)) ;
#line 312 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned long const   __kcrctab_cfag12864b_disable  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long )(& __crc_cfag12864b_disable);
#line 312 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __kstrtab_cfag12864b_disable[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
#line 312
  {      'c',      'f',      'a',      'g', 
        '1',      '2',      '8',      '6', 
        '4',      'b',      '_',      'd', 
        'i',      's',      'a',      'b', 
        'l',      'e',      '\000'};
#line 312 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct kernel_symbol  const  __ksymtab_cfag12864b_disable  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& cfag12864b_disable), __kstrtab_cfag12864b_disable};
#line 313
extern void *__crc_cfag12864b_isenabled  __attribute__((__weak__)) ;
#line 313 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned long const   __kcrctab_cfag12864b_isenabled  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long )(& __crc_cfag12864b_isenabled);
#line 313 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __kstrtab_cfag12864b_isenabled[21]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
#line 313
  {      'c',      'f',      'a',      'g', 
        '1',      '2',      '8',      '6', 
        '4',      'b',      '_',      'i', 
        's',      'e',      'n',      'a', 
        'b',      'l',      'e',      'd', 
        '\000'};
#line 313 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct kernel_symbol  const  __ksymtab_cfag12864b_isenabled  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& cfag12864b_isenabled), __kstrtab_cfag12864b_isenabled};
#line 319 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned char cfag12864b_inited  ;
#line 320 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
unsigned char cfag12864b_isinited(void) 
{ 


  {
#line 322
  return (cfag12864b_inited);
}
}
#line 324
extern void *__crc_cfag12864b_isinited  __attribute__((__weak__)) ;
#line 324 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static unsigned long const   __kcrctab_cfag12864b_isinited  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long )(& __crc_cfag12864b_isinited);
#line 324 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __kstrtab_cfag12864b_isinited[20]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
#line 324
  {      'c',      'f',      'a',      'g', 
        '1',      '2',      '8',      '6', 
        '4',      'b',      '_',      'i', 
        's',      'i',      'n',      'i', 
        't',      'e',      'd',      '\000'};
#line 324 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static struct kernel_symbol  const  __ksymtab_cfag12864b_isinited  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& cfag12864b_isinited), __kstrtab_cfag12864b_isinited};
#line 330
static int cfag12864b_init(void)  __attribute__((__section__(".init.text"))) ;
#line 330 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static int cfag12864b_init(void) 
{ 
  int ret ;
  unsigned char tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;

  {
#line 332
  ret = -22;
#line 335
  tmp = ks0108_isinited();
#line 335
  if (tmp) {

  } else {
#line 336
    printk("<3>cfag12864b: ERROR: ks0108 is not initialized\n");
#line 338
    goto none;
  }
#line 341
  if (1UL << 12 < (unsigned long )((2 * 8) * 64)) {
#line 342
    printk("<3>cfag12864b: ERROR: page size (%i) < cfag12864b size (%i)\n", (unsigned int )(1UL << 12),
           (2 * 8) * 64);
#line 345
    ret = -12;
#line 346
    goto none;
  } else {

  }
#line 349
  tmp___0 = __get_free_pages((16U | 64U) | 128U, 0);
#line 349
  cfag12864b_buffer = (unsigned char *)tmp___0;
#line 350
  if ((unsigned long )cfag12864b_buffer == (unsigned long )((void *)0)) {
#line 351
    printk("<3>cfag12864b: ERROR: can\'t get a free page\n");
#line 353
    ret = -12;
#line 354
    goto none;
  } else {

  }
#line 357
  tmp___1 = kmalloc(sizeof(unsigned char ) * (unsigned long )((2 * 8) * 64), (16U | 64U) | 128U);
#line 357
  cfag12864b_cache = tmp___1;
#line 359
  if ((unsigned long )cfag12864b_cache == (unsigned long )((void *)0)) {
#line 360
    printk("<3>cfag12864b: ERROR: can\'t alloc cache buffer (%i bytes)\n", (2 * 8) * 64);
#line 363
    ret = -12;
#line 364
    goto bufferalloced;
  } else {

  }
#line 367
  cfag12864b_workqueue = __create_workqueue_key("cfag12864b", 1, 0, (void *)0, (void *)0);
#line 368
  if ((unsigned long )cfag12864b_workqueue == (unsigned long )((void *)0)) {
#line 369
    goto cachealloced;
  } else {

  }
#line 371
  memset(cfag12864b_buffer, 0, (2 * 8) * 64);
#line 373
  cfag12864b_clear();
#line 374
  cfag12864b_on();
#line 376
  cfag12864b_inited = 1;
#line 377
  return (0);
  cachealloced: 
#line 380
  kfree(cfag12864b_cache);
  bufferalloced: 
#line 383
  free_pages((unsigned long )cfag12864b_buffer, 0);
  none: 
#line 386
  return (ret);
}
}
#line 389
static void cfag12864b_exit(void)  __attribute__((__section__(".exit.text"))) ;
#line 389 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static void cfag12864b_exit(void) 
{ 


  {
#line 391
  cfag12864b_disable();
#line 392
  cfag12864b_off();
#line 393
  destroy_workqueue(cfag12864b_workqueue);
#line 394
  kfree(cfag12864b_cache);
#line 395
  free_pages((unsigned long )cfag12864b_buffer, 0);
#line 396
  return;
}
}
#line 398 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
int init_module(void) 
{ 
  int tmp ;

  {
#line 398
  tmp = cfag12864b_init();
#line 398
  return (tmp);
}
}
#line 399 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
void cleanup_module(void) 
{ 


  {
#line 399
  cfag12864b_exit();
#line 399
  return;
}
}
#line 401 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __mod_license401[15]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
#line 401
  {      'l',      'i',      'c',      'e', 
        'n',      's',      'e',      '=', 
        'G',      'P',      'L',      ' ', 
        'v',      '2',      '\000'};
#line 402 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __mod_author402[63]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
#line 402
  {      'a',      'u',      't',      'h', 
        'o',      'r',      '=',      'M', 
        'i',      'g',      'u',      'e', 
        'l',      ' ',      'O',      'j', 
        'e',      'd',      'a',      ' ', 
        'S',      'a',      'n',      'd', 
        'o',      'n',      'i',      's', 
        ' ',      '<',      'm',      'i', 
        'g',      'u',      'e',      'l', 
        '.',      'o',      'j',      'e', 
        'd',      'a',      '.',      's', 
        'a',      'n',      'd',      'o', 
        'n',      'i',      's',      '@', 
        'g',      'm',      'a',      'i', 
        'l',      '.',      'c',      'o', 
        'm',      '>',      '\000'};
#line 403 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
static char const   __mod_description403[34]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
#line 403
  {      'd',      'e',      's',      'c', 
        'r',      'i',      'p',      't', 
        'i',      'o',      'n',      '=', 
        'c',      'f',      'a',      'g', 
        '1',      '2',      '8',      '6', 
        '4',      'b',      ' ',      'L', 
        'C',      'D',      ' ',      'd', 
        'r',      'i',      'v',      'e', 
        'r',      '\000'};
#line 421
void ldv_check_final_state(void) ;
#line 430
extern void ldv_initialize(void) ;
#line 433
extern void ldv_handler_precall(void) ;
#line 436
extern int nondet_int(void) ;
#line 439 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
int LDV_IN_INTERRUPT  ;
#line 442 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/dscv/ri/32_1/drivers/auxdisplay/cfag12864b.c"
void main(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 454
  LDV_IN_INTERRUPT = 1;
#line 463
  ldv_initialize();
#line 476
  ldv_handler_precall();
#line 477
  tmp = cfag12864b_init();
#line 477
  if (tmp) {
#line 478
    goto ldv_final;
  } else {

  }
#line 480
  while (1) {
#line 480
    tmp___1 = nondet_int();
#line 480
    if (tmp___1) {

    } else {
#line 480
      break;
    }
#line 483
    tmp___0 = nondet_int();
#line 483
    switch (tmp___0) {
    default: 
#line 485
    break;
    }
  }
#line 504
  ldv_handler_precall();
#line 505
  cfag12864b_exit();
  ldv_final: 
#line 508
  ldv_check_final_state();
#line 511
  return;
}
}
#line 1 "<compiler builtins>"
long __builtin_expect(long exp , long c ) ;
#line 136 "include/linux/mutex.h"
int ( __attribute__((__warn_unused_result__)) mutex_lock_interruptible)(struct mutex *lock ) ;
#line 137
int ( __attribute__((__warn_unused_result__)) mutex_lock_killable)(struct mutex *lock ) ;
#line 148
int mutex_trylock(struct mutex *lock ) ;
#line 10 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ( __attribute__((__always_inline__)) ldv_error)(void) 
{ 


  {
  LDV_ERROR: __VERIFIER_error();
}
}
#line 25
extern int ldv_undef_int(void) ;
#line 49 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 51
  return (exp);
}
}
#line 15 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/32_1/common-model/ldv_common_model.c"
int ldv_mutex  =    1;
#line 18 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/32_1/common-model/ldv_common_model.c"
int ( __attribute__((__warn_unused_result__)) mutex_lock_interruptible)(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 25
  if (ldv_mutex == 1) {

  } else {
#line 25
    ldv_error();
  }
#line 28
  nondetermined = ldv_undef_int();
#line 31
  if (nondetermined) {
#line 34
    ldv_mutex = 2;
#line 36
    return (0);
  } else {
#line 41
    return (-4);
  }
}
}
#line 46 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/32_1/common-model/ldv_common_model.c"
int ( __attribute__((__warn_unused_result__)) mutex_lock_killable)(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 53
  if (ldv_mutex == 1) {

  } else {
#line 53
    ldv_error();
  }
#line 56
  nondetermined = ldv_undef_int();
#line 59
  if (nondetermined) {
#line 62
    ldv_mutex = 2;
#line 64
    return (0);
  } else {
#line 69
    return (-4);
  }
}
}
#line 74 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/32_1/common-model/ldv_common_model.c"
int atomic_dec_and_mutex_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 79
  if (ldv_mutex == 1) {

  } else {
#line 79
    ldv_error();
  }
#line 82
  atomic_value_after_dec = ldv_undef_int();
#line 85
  if (atomic_value_after_dec == 0) {
#line 88
    ldv_mutex = 2;
#line 90
    return (1);
  } else {

  }
#line 94
  return (0);
}
}
#line 99 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/32_1/common-model/ldv_common_model.c"
void mutex_lock(struct mutex *lock ) 
{ 


  {
#line 104
  if (ldv_mutex == 1) {

  } else {
#line 104
    ldv_error();
  }
#line 106
  ldv_mutex = 2;
#line 107
  return;
}
}
#line 110 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/32_1/common-model/ldv_common_model.c"
int mutex_trylock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 117
  if (ldv_mutex == 1) {

  } else {
#line 117
    ldv_error();
  }
#line 120
  nondetermined = ldv_undef_int();
#line 123
  if (nondetermined) {
#line 126
    ldv_mutex = 2;
#line 128
    return (1);
  } else {
#line 133
    return (0);
  }
}
}
#line 138 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/32_1/common-model/ldv_common_model.c"
void mutex_unlock(struct mutex *lock ) 
{ 


  {
#line 143
  if (ldv_mutex == 2) {

  } else {
#line 143
    ldv_error();
  }
#line 145
  ldv_mutex = 1;
#line 146
  return;
}
}
#line 149 "/work/ldvuser/novikov/work/current--X--drivers/auxdisplay/cfag12864b.ko--X--defaultlinux--X--32_1--X--cpachecker/linux/csd_deg_dscv/11/dscv_tempdir/rule-instrumentor/32_1/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 152
  if (ldv_mutex == 1) {

  } else {
#line 152
    ldv_error();
  }
#line 153
  return;
}
}
