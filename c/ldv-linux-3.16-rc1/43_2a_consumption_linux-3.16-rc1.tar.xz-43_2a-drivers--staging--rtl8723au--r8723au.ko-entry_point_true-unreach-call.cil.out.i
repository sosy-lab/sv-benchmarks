extern void __VERIFIER_error() __attribute__ ((__noreturn__));
struct kernel_symbol {
   unsigned long value ;
   char const *name ;
};
struct module;
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef unsigned long long __u64;
typedef signed char s8;
typedef unsigned char u8;
typedef short s16;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
typedef int __kernel_pid_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u32 __wsum;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef unsigned short umode_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef unsigned int uint;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef unsigned long sector_t;
typedef unsigned long blkcnt_t;
typedef u64 dma_addr_t;
typedef unsigned int gfp_t;
typedef unsigned int fmode_t;
typedef unsigned int oom_flags_t;
struct __anonstruct_atomic_t_6 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_6 atomic_t;
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
struct __anonstruct_ldv_1022_9 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct_ldv_1037_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
union __anonunion_ldv_1038_8 {
   struct __anonstruct_ldv_1022_9 ldv_1022 ;
   struct __anonstruct_ldv_1037_10 ldv_1037 ;
};
struct desc_struct {
   union __anonunion_ldv_1038_8 ldv_1038 ;
};
typedef unsigned long pteval_t;
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
typedef struct __anonstruct_pte_t_11 pte_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_12 pgd_t;
struct page;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
struct thread_struct;
struct mm_struct;
struct task_struct;
struct cpumask;
struct arch_spinlock;
typedef u16 __ticket_t;
typedef u32 __ticketpair_t;
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
union __anonunion_ldv_1458_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
struct arch_spinlock {
   union __anonunion_ldv_1458_15 ldv_1458 ;
};
typedef struct arch_spinlock arch_spinlock_t;
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
typedef struct qrwlock arch_rwlock_t;
typedef void (*ctor_fn_t)(void);
struct device;
struct net_device;
struct file_operations;
struct completion;
struct pid;
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
struct timespec;
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
union __anonunion_ldv_2998_20 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2998_20 ldv_2998 ;
};
struct cpumask {
   unsigned long bits[128U] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct seq_operations;
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
struct __anonstruct_ldv_5289_25 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct_ldv_5295_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion_ldv_5296_24 {
   struct __anonstruct_ldv_5289_25 ldv_5289 ;
   struct __anonstruct_ldv_5295_26 ldv_5295 ;
};
union __anonunion_ldv_5305_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5296_24 ldv_5296 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5305_27 ldv_5305 ;
};
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
struct lwp_struct {
   u8 reserved[128U] ;
};
struct bndregs_struct {
   u64 bndregs[8U] ;
};
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
struct kmem_cache;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
typedef atomic64_t atomic_long_t;
struct lockdep_map;
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const *name ;
   int cpu ;
   unsigned long ip ;
};
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct_ldv_6346_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
union __anonunion_ldv_6347_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6346_31 ldv_6346 ;
};
struct spinlock {
   union __anonunion_ldv_6347_30 ldv_6347 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
typedef struct seqcount seqcount_t;
struct __anonstruct_seqlock_t_33 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_33 seqlock_t;
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct user_namespace;
struct __anonstruct_kuid_t_34 {
   uid_t val ;
};
typedef struct __anonstruct_kuid_t_34 kuid_t;
struct __anonstruct_kgid_t_35 {
   gid_t val ;
};
typedef struct __anonstruct_kgid_t_35 kgid_t;
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
struct optimistic_spin_queue;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct rw_semaphore;
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue *osq ;
   struct lockdep_map dep_map ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct llist_node;
struct llist_node {
   struct llist_node *next ;
};
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct tvec_base;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
struct hrtimer;
enum hrtimer_restart;
struct workqueue_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
struct dev_pm_qos;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32 ) ;
   struct dev_pm_qos *qos ;
};
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct rb_root {
   struct rb_node *rb_node ;
};
struct vm_area_struct;
struct bio_vec;
struct notifier_block;
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
struct ctl_table;
struct nsproxy;
struct ctl_table_root;
struct ctl_table_header;
struct ctl_dir;
typedef int proc_handler(struct ctl_table * , int , void * , size_t * , loff_t * );
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
struct ctl_table {
   char const *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
struct __anonstruct_ldv_13800_129 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
union __anonunion_ldv_13802_128 {
   struct __anonstruct_ldv_13800_129 ldv_13800 ;
   struct callback_head rcu ;
};
struct ctl_table_set;
struct ctl_table_header {
   union __anonunion_ldv_13802_128 ldv_13802 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
struct cred;
struct inode;
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
struct __anonstruct_ldv_14046_136 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
struct __anonstruct_ldv_14050_137 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
union __anonunion_ldv_14051_135 {
   struct __anonstruct_ldv_14046_136 ldv_14046 ;
   struct __anonstruct_ldv_14050_137 ldv_14050 ;
};
struct uprobe;
struct return_instance;
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_ldv_14051_135 ldv_14051 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
struct xol_area;
struct uprobes_state {
   struct xol_area *xol_area ;
};
struct address_space;
union __anonunion_ldv_14160_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
union __anonunion_ldv_14166_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
struct __anonstruct_ldv_14176_144 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
union __anonunion_ldv_14178_143 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_14176_144 ldv_14176 ;
   int units ;
};
struct __anonstruct_ldv_14180_142 {
   union __anonunion_ldv_14178_143 ldv_14178 ;
   atomic_t _count ;
};
union __anonunion_ldv_14182_141 {
   unsigned long counters ;
   struct __anonstruct_ldv_14180_142 ldv_14180 ;
   unsigned int active ;
};
struct __anonstruct_ldv_14183_139 {
   union __anonunion_ldv_14166_140 ldv_14166 ;
   union __anonunion_ldv_14182_141 ldv_14182 ;
};
struct __anonstruct_ldv_14190_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
struct slab;
union __anonunion_ldv_14195_145 {
   struct list_head lru ;
   struct __anonstruct_ldv_14190_146 ldv_14190 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
union __anonunion_ldv_14201_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
struct page {
   unsigned long flags ;
   union __anonunion_ldv_14160_138 ldv_14160 ;
   struct __anonstruct_ldv_14183_139 ldv_14183 ;
   union __anonunion_ldv_14195_145 ldv_14195 ;
   union __anonunion_ldv_14201_147 ldv_14201 ;
   unsigned long debug_flags ;
};
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct const *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
struct kioctx_table;
struct linux_binfmt;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long , unsigned long ,
                                      unsigned long , unsigned long ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
union __anonunion_ldv_14564_153 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_ldv_14564_153 ldv_14564 ;
};
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
struct dentry;
struct iattr;
struct super_block;
struct file_system_type;
struct kernfs_open_node;
struct kernfs_iattrs;
struct kernfs_root;
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
struct kernfs_node;
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
struct kernfs_ops;
struct kernfs_elem_attr {
   struct kernfs_ops const *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
union __anonunion_ldv_14708_154 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const *name ;
   struct rb_node rb ;
   void const *ns ;
   unsigned int hash ;
   union __anonunion_ldv_14708_154 ldv_14708 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const * , umode_t ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const * ) ;
};
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct const *vm_ops ;
};
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t , loff_t ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t , loff_t ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
struct sock;
struct kobject;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const *(*netlink_ns)(struct sock * ) ;
   void const *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
struct bin_attribute;
struct attribute {
   char const *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct attribute_group {
   char const *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t , size_t ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t , size_t ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const * , size_t ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct kobject {
   char const *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops const *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject * ) ;
   void const *(*namespace)(struct kobject * ) ;
};
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (* const filter)(struct kset * , struct kobject * ) ;
   char const *(* const name)(struct kset * , struct kobject * ) ;
   int (* const uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops const *uevent_ops ;
};
struct kernel_param;
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const * , struct kernel_param const * ) ;
   int (*get)(char * , struct kernel_param const * ) ;
   void (*free)(void * ) ;
};
struct kparam_string;
struct kparam_array;
union __anonunion_ldv_15383_155 {
   void *arg ;
   struct kparam_string const *str ;
   struct kparam_array const *arr ;
};
struct kernel_param {
   char const *name ;
   struct kernel_param_ops const *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_15383_155 ldv_15383 ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops const *ops ;
   void *elem ;
};
struct mod_arch_specific {
};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const * ,
                    size_t ) ;
   void (*setup)(struct module * , char const * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
struct module_sect_attrs;
struct module_notes_attrs;
struct tracepoint;
struct ftrace_event_call;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const *version ;
   char const *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol const *syms ;
   unsigned long const *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol const *gpl_syms ;
   unsigned long const *gpl_crcs ;
   struct kernel_symbol const *unused_syms ;
   unsigned long const *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol const *unused_gpl_syms ;
   unsigned long const *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol const *gpl_future_syms ;
   unsigned long const *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
struct mem_cgroup;
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
struct kmem_cache_order_objects {
   unsigned long x ;
};
struct memcg_cache_params;
struct kmem_cache_node;
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
struct __anonstruct_ldv_16003_157 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
struct __anonstruct_ldv_16009_158 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
union __anonunion_ldv_16010_156 {
   struct __anonstruct_ldv_16003_157 ldv_16003 ;
   struct __anonstruct_ldv_16009_158 ldv_16009 ;
};
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_16010_156 ldv_16010 ;
};
struct wiphy;
struct wireless_dev;
struct usb_interface;
struct plist_head {
   struct list_head node_list ;
};
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct klist_node;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct path;
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations const *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
struct pinctrl;
struct pinctrl_state;
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
struct dma_map_ops;
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct device_private;
struct device_driver;
struct driver_private;
struct class;
struct subsys_private;
struct bus_type;
struct device_node;
struct iommu_ops;
struct iommu_group;
struct device_attribute;
struct bus_type {
   char const *name ;
   char const *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group const **bus_groups ;
   struct attribute_group const **dev_groups ;
   struct attribute_group const **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops const *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
struct device_type;
struct of_device_id;
struct acpi_device_id;
struct device_driver {
   char const *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id const *of_match_table ;
   struct acpi_device_id const *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group const **groups ;
   struct dev_pm_ops const *pm ;
   struct driver_private *p ;
};
struct class_attribute;
struct class {
   char const *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group const **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations const *ns_type ;
   void const *(*namespace)(struct device * ) ;
   struct dev_pm_ops const *pm ;
   struct subsys_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const * , size_t ) ;
};
struct device_type {
   char const *name ;
   struct attribute_group const **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops const *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const * ,
                    size_t ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct acpi_device;
struct acpi_dev_node {
   struct acpi_device *companion ;
};
struct dma_coherent_mem;
struct cma;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const *init_name ;
   struct device_type const *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group const **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
struct wakeup_source {
   char const *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
enum dev_pm_qos_req_type {
    DEV_PM_QOS_RESUME_LATENCY = 1,
    DEV_PM_QOS_LATENCY_TOLERANCE = 2,
    DEV_PM_QOS_FLAGS = 3
} ;
union __anonunion_data_159 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_159 data ;
   struct device *dev ;
};
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   s32 no_constraint_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
struct dev_pm_qos {
   struct pm_qos_constraints resume_latency ;
   struct pm_qos_constraints latency_tolerance ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *resume_latency_req ;
   struct dev_pm_qos_request *latency_tolerance_req ;
   struct dev_pm_qos_request *flags_req ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
union __anonunion_ldv_18051_160 {
   struct iovec const *iov ;
   struct bio_vec const *bvec ;
};
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_ldv_18051_160 ldv_18051 ;
   unsigned long nr_segs ;
};
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
struct file_ra_state;
struct user_struct;
struct writeback_control;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long , void * , int , int ) ;
   char const *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const * , nodemask_t const * ,
                  unsigned long ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long , unsigned long ,
                      unsigned long ) ;
};
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
typedef s32 dma_cookie_t;
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
struct sem_undo_list;
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
typedef unsigned short __kernel_sa_family_t;
typedef __kernel_sa_family_t sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
struct __anonstruct_sync_serial_settings_162 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
typedef struct __anonstruct_sync_serial_settings_162 sync_serial_settings;
struct __anonstruct_te1_settings_163 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
typedef struct __anonstruct_te1_settings_163 te1_settings;
struct __anonstruct_raw_hdlc_proto_164 {
   unsigned short encoding ;
   unsigned short parity ;
};
typedef struct __anonstruct_raw_hdlc_proto_164 raw_hdlc_proto;
struct __anonstruct_fr_proto_165 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
typedef struct __anonstruct_fr_proto_165 fr_proto;
struct __anonstruct_fr_proto_pvc_166 {
   unsigned int dlci ;
};
typedef struct __anonstruct_fr_proto_pvc_166 fr_proto_pvc;
struct __anonstruct_fr_proto_pvc_info_167 {
   unsigned int dlci ;
   char master[16U] ;
};
typedef struct __anonstruct_fr_proto_pvc_info_167 fr_proto_pvc_info;
struct __anonstruct_cisco_proto_168 {
   unsigned int interval ;
   unsigned int timeout ;
};
typedef struct __anonstruct_cisco_proto_168 cisco_proto;
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifs_ifsu_169 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_169 ifs_ifsu ;
};
union __anonunion_ifr_ifrn_170 {
   char ifrn_name[16U] ;
};
union __anonunion_ifr_ifru_171 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_170 ifr_ifrn ;
   union __anonunion_ifr_ifru_171 ifr_ifru ;
};
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct __anonstruct_ldv_22130_174 {
   spinlock_t lock ;
   unsigned int count ;
};
union __anonunion_ldv_22131_173 {
   struct __anonstruct_ldv_22130_174 ldv_22130 ;
};
struct lockref {
   union __anonunion_ldv_22131_173 ldv_22131 ;
};
struct nameidata;
struct vfsmount;
struct __anonstruct_ldv_22154_176 {
   u32 hash ;
   u32 len ;
};
union __anonunion_ldv_22156_175 {
   struct __anonstruct_ldv_22154_176 ldv_22154 ;
   u64 hash_len ;
};
struct qstr {
   union __anonunion_ldv_22156_175 ldv_22156 ;
   unsigned char const *name ;
};
struct dentry_operations;
union __anonunion_d_u_177 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations const *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_177 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int ) ;
   int (*d_hash)(struct dentry const * , struct qstr * ) ;
   int (*d_compare)(struct dentry const * , struct dentry const * , unsigned int ,
                    char const * , struct qstr const * ) ;
   int (*d_delete)(struct dentry const * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
struct __anonstruct_ldv_22517_179 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
union __anonunion_ldv_22519_178 {
   struct __anonstruct_ldv_22517_179 ldv_22517 ;
   struct callback_head callback_head ;
};
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_ldv_22519_178 ldv_22519 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
struct block_device;
struct io_context;
struct cgroup_subsys_state;
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
struct export_operations;
struct kiocb;
struct pipe_inode_info;
struct poll_table_struct;
struct kstatfs;
struct swap_info_struct;
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
struct dquot;
typedef __kernel_uid32_t projid_t;
struct __anonstruct_kprojid_t_181 {
   projid_t val ;
};
typedef struct __anonstruct_kprojid_t_181 kprojid_t;
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
typedef long long qsize_t;
union __anonunion_ldv_23316_182 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
struct kqid {
   union __anonunion_ldv_23316_182 ldv_23316 ;
   enum quota_type type ;
};
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int ) ;
   int (*read_file_info)(struct super_block * , int ) ;
   int (*write_file_info)(struct super_block * , int ) ;
   int (*free_file_info)(struct super_block * , int ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int , int , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int , int ) ;
   int (*quota_off)(struct super_block * , int ) ;
   int (*quota_sync)(struct super_block * , int ) ;
   int (*get_info)(struct super_block * , int , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int , int ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops const *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops const *ops[2U] ;
};
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t , unsigned int ,
                      unsigned int , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t , unsigned int ,
                    unsigned int , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t ) ;
   void (*invalidatepage)(struct page * , unsigned int , unsigned int ) ;
   int (*releasepage)(struct page * , gfp_t ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int , struct kiocb * , struct iov_iter * , loff_t ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long , int , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long , unsigned long ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
struct backing_dev_info;
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations const *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
struct request_queue;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct inode_operations;
union __anonunion_ldv_23731_185 {
   unsigned int const i_nlink ;
   unsigned int __i_nlink ;
};
union __anonunion_ldv_23751_186 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
struct file_lock;
struct cdev;
union __anonunion_ldv_23768_187 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations const *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_23731_185 ldv_23731 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_23751_186 ldv_23751 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations const *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_23768_187 ldv_23768 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_188 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_188 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations const *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred const *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
struct files_struct;
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int ) ;
};
struct net;
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_190 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_189 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_190 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations const *fl_ops ;
   struct lock_manager_operations const *fl_lmops ;
   union __anonunion_fl_u_189 fl_u ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations const *s_op ;
   struct dquot_operations const *dq_op ;
   struct quotactl_ops const *s_qcop ;
   struct export_operations const *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler const **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations const *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
struct dir_context {
   int (*actor)(void * , char const * , int , loff_t , u64 , unsigned int ) ;
   loff_t pos ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t , int ) ;
   ssize_t (*read)(struct file * , char * , size_t , loff_t * ) ;
   ssize_t (*write)(struct file * , char const * , size_t , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec const * , unsigned long ,
                       loff_t ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec const * , unsigned long ,
                        loff_t ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int , unsigned long ) ;
   long (*compat_ioctl)(struct file * , unsigned int , unsigned long ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t , loff_t , int ) ;
   int (*aio_fsync)(struct kiocb * , int ) ;
   int (*fasync)(int , struct file * , int ) ;
   int (*lock)(struct file * , int , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int , size_t , loff_t * ,
                       int ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long , unsigned long ,
                                      unsigned long , unsigned long ) ;
   int (*check_flags)(int ) ;
   int (*flock)(struct file * , int , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t ,
                           unsigned int ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t ,
                          unsigned int ) ;
   int (*setlease)(struct file * , long , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int , loff_t , loff_t ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int ) ;
   struct posix_acl *(*get_acl)(struct inode * , int ) ;
   int (*readlink)(struct dentry * , char * , int ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t , bool ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t , dev_t ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const * , void const * , size_t , int ) ;
   ssize_t (*getxattr)(struct dentry * , char const * , void * , size_t ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t ) ;
   int (*removexattr)(struct dentry * , char const * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 , u64 ) ;
   int (*update_time)(struct inode * , struct timespec * , int ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int ,
                      umode_t , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int , char * , size_t , loff_t ) ;
   ssize_t (*quota_write)(struct super_block * , int , char const * , size_t ,
                          loff_t ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t ) ;
   long (*nr_cached_objects)(struct super_block * , int ) ;
   long (*free_cached_objects)(struct super_block * , long , int ) ;
};
struct file_system_type {
   char const *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int , char const * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
typedef unsigned long cputime_t;
struct __anonstruct_sigset_t_191 {
   unsigned long sig[1U] ;
};
typedef struct __anonstruct_sigset_t_191 sigset_t;
struct siginfo;
typedef void __signalfn_t(int );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_193 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_194 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_195 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_196 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__sigfault_197 {
   void *_addr ;
   short _addr_lsb ;
};
struct __anonstruct__sigpoll_198 {
   long _band ;
   int _fd ;
};
struct __anonstruct__sigsys_199 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_192 {
   int _pad[28U] ;
   struct __anonstruct__kill_193 _kill ;
   struct __anonstruct__timer_194 _timer ;
   struct __anonstruct__rt_195 _rt ;
   struct __anonstruct__sigchld_196 _sigchld ;
   struct __anonstruct__sigfault_197 _sigfault ;
   struct __anonstruct__sigpoll_198 _sigpoll ;
   struct __anonstruct__sigsys_199 _sigsys ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_192 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
struct seccomp_filter;
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
struct rt_mutex_waiter;
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
struct assoc_array_ptr;
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct signal_struct;
struct key_type;
struct keyring_index_key {
   struct key_type *type ;
   char const *description ;
   size_t desc_len ;
};
union __anonunion_ldv_26730_202 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
struct key_user;
union __anonunion_ldv_26738_203 {
   time_t expiry ;
   time_t revoked_at ;
};
struct __anonstruct_ldv_26751_205 {
   struct key_type *type ;
   char *description ;
};
union __anonunion_ldv_26752_204 {
   struct keyring_index_key index_key ;
   struct __anonstruct_ldv_26751_205 ldv_26751 ;
};
union __anonunion_type_data_206 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
union __anonunion_payload_208 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
union __anonunion_ldv_26767_207 {
   union __anonunion_payload_208 payload ;
   struct assoc_array keys ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_26730_202 ldv_26730 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_26738_203 ldv_26738 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_ldv_26752_204 ldv_26752 ;
   union __anonunion_type_data_206 type_data ;
   union __anonunion_ldv_26767_207 ldv_26767 ;
};
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct cfs_rq;
struct task_group;
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
struct autogroup;
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct uts_namespace;
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
struct sched_class;
struct css_set;
struct compat_robust_list_head;
struct numa_group;
struct ftrace_ret_stack;
struct task_struct {
   long volatile state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class const *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred const *real_cred ;
   struct cred const *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults_memory ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer_memory ;
   unsigned long *numa_faults_cpu ;
   unsigned long *numa_faults_buffer_cpu ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
typedef s32 compat_long_t;
typedef u32 compat_uptr_t;
struct compat_robust_list {
   compat_uptr_t next ;
};
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
enum ldv_22548 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
typedef enum ldv_22548 socket_state;
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
struct proto_ops;
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops const *ops ;
};
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int ) ;
   int (*connect)(struct socket * , struct sockaddr * , int , int ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int , unsigned long ) ;
   int (*compat_ioctl)(struct socket * , unsigned int , unsigned long ) ;
   int (*listen)(struct socket * , int ) ;
   int (*shutdown)(struct socket * , int ) ;
   int (*setsockopt)(struct socket * , int , int , char * , unsigned int ) ;
   int (*getsockopt)(struct socket * , int , int , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int , int , char * , unsigned int ) ;
   int (*compat_getsockopt)(struct socket * , int , int , char * , int * ) ;
   int (*sendmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t ) ;
   int (*recvmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t , int ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int , size_t , int ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t , unsigned int ) ;
   int (*set_peek_off)(struct sock * , int ) ;
};
struct exception_table_entry {
   int insn ;
   int fixup ;
};
struct sk_buff;
struct dma_attrs {
   unsigned long flags[1U] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t , dma_addr_t * , gfp_t , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t , void * , dma_addr_t , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t ,
               size_t , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t ,
                      size_t , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long , size_t ,
                          enum dma_data_direction , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t , size_t , enum dma_data_direction ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int , enum dma_data_direction ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int , enum dma_data_direction ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t , size_t , enum dma_data_direction ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int , enum dma_data_direction ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int , enum dma_data_direction ) ;
   int (*mapping_error)(struct device * , dma_addr_t ) ;
   int (*dma_supported)(struct device * , u64 ) ;
   int (*set_dma_mask)(struct device * , u64 ) ;
   int is_phys ;
};
typedef u64 netdev_features_t;
struct nf_conntrack {
   atomic_t use ;
};
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
typedef unsigned int sk_buff_data_t;
struct __anonstruct_ldv_31170_227 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
union __anonunion_ldv_31171_226 {
   u64 v64 ;
   struct __anonstruct_ldv_31170_227 ldv_31170 ;
};
struct skb_mstamp {
   union __anonunion_ldv_31171_226 ldv_31171 ;
};
union __anonunion_ldv_31190_228 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
struct sec_path;
struct __anonstruct_ldv_31206_230 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
union __anonunion_ldv_31207_229 {
   __wsum csum ;
   struct __anonstruct_ldv_31206_230 ldv_31206 ;
};
union __anonunion_ldv_31246_231 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
union __anonunion_ldv_31252_232 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_ldv_31190_228 ldv_31190 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion_ldv_31207_229 ldv_31207 ;
   __u32 priority ;
   unsigned char ignore_df : 1 ;
   unsigned char cloned : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char nohdr : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char pkt_type : 3 ;
   unsigned char fclone : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char peeked : 1 ;
   unsigned char nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   union __anonunion_ldv_31246_231 ldv_31246 ;
   __u32 secmark ;
   union __anonunion_ldv_31252_232 ldv_31252 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
struct dst_entry;
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32 ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32 , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32 ) ;
   int (*get_sset_count)(struct net_device * , int ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const * , u8 const * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
struct prot_inuse;
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
struct u64_stats_sync {
};
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
struct icmp_mib {
   unsigned long mibs[28U] ;
};
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
struct tcp_mib {
   unsigned long mibs[16U] ;
};
struct udp_mib {
   unsigned long mibs[8U] ;
};
struct linux_mib {
   unsigned long mibs[103U] ;
};
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
struct proc_dir_entry;
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
struct tcpm_hash_bucket;
struct ipv4_devconf;
struct fib_rules_ops;
struct fib_table;
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
struct inet_peer_base;
struct xt_table;
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
struct neighbour;
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32 ) ;
   unsigned int (*default_advmss)(struct dst_entry const * ) ;
   unsigned int (*mtu)(struct dst_entry const * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32 ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry const * , struct sk_buff * ,
                                     void const * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
};
struct ipv6_devconf;
struct rt6_info;
struct rt6_statistics;
struct fib6_table;
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
   u16 max_dsize ;
};
struct sctp_mib;
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
struct nlattr;
struct nf_logger;
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger const *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
struct ebt_table;
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
struct hlist_nulls_node;
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
struct ip_conntrack_stat;
struct nf_ct_event_notifier;
struct nf_exp_event_notifier;
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
struct nft_af_info;
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   u8 gencursor ;
   u8 genctr ;
};
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long ) ;
   unsigned long data ;
};
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
struct net_generic;
struct netns_ipvs;
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
struct dsa_switch;
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
struct dsa_switch_driver;
struct mii_bus;
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int , int ) ;
   int (*phy_write)(struct dsa_switch * , int , int , u16 ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8 ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int , u8 ) ;
   void (*setpgtccfgrx)(struct net_device * , int , u8 , u8 , u8 , u8 ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int , u8 ) ;
   void (*getpgtccfgtx)(struct net_device * , int , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int , u8 ) ;
   void (*getpfccfg)(struct net_device * , int , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int , u8 ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8 ) ;
   void (*getbcncfg)(struct net_device * , int , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int , u32 ) ;
   void (*getbcnrp)(struct net_device * , int , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int , u8 ) ;
   u8 (*setapp)(struct net_device * , u8 , u16 , u8 ) ;
   u8 (*getapp)(struct net_device * , u8 , u16 ) ;
   u8 (*getfeatcfg)(struct net_device * , int , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int , u8 ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8 ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
struct percpu_ref;
typedef void percpu_ref_func_t(struct percpu_ref * );
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
struct cgroup_root;
struct cgroup_subsys;
struct cgroup;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
};
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64 ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64 ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t , loff_t ) ;
   struct lock_class_key lockdep_key ;
};
struct cgroup_taskset;
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *base_cftypes ;
};
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
struct mnt_namespace;
struct ipc_namespace;
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr const *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
};
struct netpoll_info;
struct phy_device;
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
typedef enum netdev_tx netdev_tx_t;
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
struct neigh_parms;
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short , void const * ,
                 void const * , unsigned int ) ;
   int (*parse)(struct sk_buff const * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour const * , struct hh_cache * , __be16 ) ;
   void (*cache_update)(struct hh_cache * , struct net_device const * , unsigned char const * ) ;
};
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
typedef enum rx_handler_result rx_handler_result_t;
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
struct Qdisc;
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16 , u16 ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16 , u16 ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int , u16 , u8 ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int , int , int ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int , bool ) ;
   int (*ndo_get_vf_config)(struct net_device * , int , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int , int ) ;
   int (*ndo_set_vf_port)(struct net_device * , int , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8 ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16 , struct scatterlist * , unsigned int ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16 ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16 , struct scatterlist * ,
                              unsigned int ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff const * , u16 ,
                            u32 ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const * ,
                      u16 ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32 , u32 , struct net_device * ,
                             u32 ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t , __be16 ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t , __be16 ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
};
struct __anonstruct_adj_list_246 {
   struct list_head upper ;
   struct list_head lower ;
};
struct __anonstruct_all_adj_list_247 {
   struct list_head upper ;
   struct list_head lower ;
};
struct iw_handler_def;
struct iw_public_data;
struct forwarding_accel_ops;
struct vlan_info;
struct tipc_bearer;
struct in_device;
struct dn_dev;
struct inet6_dev;
struct cpu_rmap;
struct pcpu_lstats;
struct pcpu_sw_netstats;
struct pcpu_dstats;
struct pcpu_vstats;
union __anonunion_ldv_40510_248 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
struct garp_port;
struct mrp_port;
struct rtnl_link_ops;
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct __anonstruct_adj_list_246 adj_list ;
   struct __anonstruct_all_adj_list_247 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_t carrier_changes ;
   struct iw_handler_def const *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops const *netdev_ops ;
   struct ethtool_ops const *ethtool_ops ;
   struct forwarding_accel_ops const *fwd_ops ;
   struct header_ops const *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion_ldv_40510_248 ldv_40510 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group const *sysfs_groups[4U] ;
   struct attribute_group const *sysfs_rx_queue_group ;
   struct rtnl_link_ops const *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops const *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NUM_NL80211_IFTYPES = 11,
    NL80211_IFTYPE_MAX = 10
} ;
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
} ;
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
} ;
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
} ;
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
} ;
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
} ;
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
} ;
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
} ;
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
} ;
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
} ;
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};
struct mac_address {
   u8 addr[6U] ;
};
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
} ;
struct cfg80211_ibss_params {
   u8 const *ssid ;
   u8 const *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const *bssid ;
   u8 const *bssid_hint ;
   u8 const *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
struct cfg80211_pkt_pattern {
   u8 const *mask ;
   u8 const *pattern ;
   int pattern_len ;
   int pkt_offset ;
};
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 const *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const *wake_data ;
   u8 const *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
};
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit const *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature const *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   struct wiphy_wowlan_tcp_support const *tcp ;
};
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy * , struct wireless_dev * , void const * , int ) ;
};
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes const *mgmt_stypes ;
   struct ieee80211_iface_combination const *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
   u32 const *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support const *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const *extended_capabilities ;
   u8 const *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy * , struct regulatory_request * ) ;
   struct ieee80211_regdomain const *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap const *ht_capa_mod_mask ;
   struct ieee80211_vht_cap const *vht_capa_mod_mask ;
   struct net *_net ;
   struct iw_handler_def const *wext ;
   struct wiphy_coalesce_support const *coalesce ;
   struct wiphy_vendor_command const *vendor_commands ;
   struct nl80211_vendor_cmd_info const *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};
struct cfg80211_conn;
struct cfg80211_internal_bss;
struct cfg80211_cached_keys;
struct __anonstruct_wext_290 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   u32 owner_nlportid ;
   struct __anonstruct_wext_290 wext ;
};
struct rtw_queue {
   struct list_head queue ;
   spinlock_t lock ;
};
struct wlan_phy_info {
   u8 SignalStrength ;
   u8 SignalQuality ;
   u8 Optimum_antenna ;
   u8 Reserved_0 ;
};
struct wlan_bcn_info {
   u8 encryp_protocol ;
   int group_cipher ;
   int pairwise_cipher ;
   int is_8021x ;
   unsigned short ht_cap_info ;
   unsigned char ht_info_infos_0 ;
};
struct wlan_bssid_ex {
   u32 Length ;
   u8 MacAddress[6U] ;
   u16 reserved ;
   struct cfg80211_ssid Ssid ;
   u32 Privacy ;
   long Rssi ;
   u16 BeaconPeriod ;
   u32 ATIMWindow ;
   u32 DSConfig ;
   enum nl80211_iftype ifmode ;
   unsigned char SupportedRates[16U] ;
   struct wlan_phy_info PhyInfo ;
   u32 IELength ;
   u8 IEs[768U] ;
};
struct wlan_network {
   struct list_head list ;
   int network_type ;
   int fixed ;
   unsigned long last_scanned ;
   int aid ;
   int join_res ;
   struct wlan_bssid_ex network ;
   struct wlan_bcn_info BcnInfo ;
};
struct __anonstruct_HT_cap_element_292 {
   unsigned short HT_caps_info ;
   unsigned char AMPDU_para ;
   unsigned char MCS_rate[16U] ;
   unsigned short HT_ext_caps ;
   unsigned int Beamforming_caps ;
   unsigned char ASEL_caps ;
};
union __anonunion_u_291 {
   struct __anonstruct_HT_cap_element_292 HT_cap_element ;
   unsigned char HT_cap[26U] ;
};
struct HT_caps_element {
   union __anonunion_u_291 u ;
};
struct HT_info_element {
   unsigned char primary_channel ;
   unsigned char infos[5U] ;
   unsigned char MCS_rate[16U] ;
};
struct AC_param {
   unsigned char ACI_AIFSN ;
   unsigned char CW ;
   unsigned short TXOP_limit ;
};
struct WMM_para_element {
   unsigned char QoS_info ;
   unsigned char reserved ;
   struct AC_param ac_param[4U] ;
};
struct ADDBA_request {
   unsigned char dialog_token ;
   unsigned short BA_para_set ;
   unsigned short BA_timeout_value ;
   unsigned short BA_starting_seqctrl ;
};
struct ht_priv {
   u32 ht_option ;
   u32 ampdu_enable ;
   u32 tx_amsdu_enable ;
   u32 tx_amdsu_maxlen ;
   u32 rx_ampdu_maxlen ;
   u8 bwmode ;
   u8 ch_offset ;
   u8 sgi ;
   u16 agg_enable_bitmap ;
   u16 candidate_tid_bitmap ;
   struct ieee80211_ht_cap ht_cap ;
};
enum led_ctl_mode {
    LED_CTL_POWER_ON = 1,
    LED_CTL_LINK = 2,
    LED_CTL_NO_LINK = 3,
    LED_CTL_TX = 4,
    LED_CTL_RX = 5,
    LED_CTL_SITE_SURVEY = 6,
    LED_CTL_POWER_OFF = 7,
    LED_CTL_START_TO_LINK = 8,
    LED_CTL_START_WPS = 9,
    LED_CTL_STOP_WPS = 10,
    LED_CTL_START_WPS_BOTTON = 11,
    LED_CTL_STOP_WPS_FAIL = 12,
    LED_CTL_STOP_WPS_FAIL_OVERLAP = 13,
    LED_CTL_CONNECTION_NO_TRANSFER = 14
} ;
enum led_state_872x {
    LED_UNKNOWN = 0,
    RTW_LED_ON = 1,
    RTW_LED_OFF = 2,
    LED_BLINK_NORMAL = 3,
    LED_BLINK_SLOWLY = 4,
    LED_BLINK_POWER_ON = 5,
    LED_BLINK_SCAN = 6,
    LED_BLINK_NO_LINK = 7,
    LED_BLINK_StartToBlink = 8,
    LED_BLINK_TXRX = 9,
    LED_BLINK_WPS = 10,
    LED_BLINK_WPS_STOP = 11,
    LED_BLINK_WPS_STOP_OVERLAP = 12,
    LED_BLINK_RUNTOP = 13,
    LED_BLINK_CAMEO = 14,
    LED_BLINK_XAVI = 15,
    LED_BLINK_ALWAYS_ON = 16
} ;
enum led_pin_8723a {
    LED_PIN_NULL = 0,
    LED_PIN_LED0 = 1,
    LED_PIN_LED1 = 2,
    LED_PIN_LED2 = 3,
    LED_PIN_GPIO0 = 4
} ;
struct rtw_adapter;
struct led_8723a {
   struct rtw_adapter *padapter ;
   enum led_pin_8723a LedPin ;
   enum led_state_872x CurrLedState ;
   enum led_state_872x BlinkingLedState ;
   u8 bLedOn ;
   u8 bLedBlinkInProgress ;
   u8 bLedWPSBlinkInProgress ;
   u32 BlinkTimes ;
   struct timer_list BlinkTimer ;
   u8 bSWLedCtrl ;
   u8 bLedNoLinkBlinkInProgress ;
   u8 bLedLinkBlinkInProgress ;
   u8 bLedStartToLinkBlinkInProgress ;
   u8 bLedScanBlinkInProgress ;
   struct work_struct BlinkWorkItem ;
};
enum led_strategy_8723a {
    SW_LED_MODE0 = 0,
    SW_LED_MODE1 = 1,
    SW_LED_MODE2 = 2,
    SW_LED_MODE3 = 3,
    SW_LED_MODE4 = 4,
    SW_LED_MODE5 = 5,
    SW_LED_MODE6 = 6,
    HW_LED = 50,
    LED_ST_NONE = 99
} ;
struct led_priv {
   struct led_8723a SwLed0 ;
   struct led_8723a SwLed1 ;
   enum led_strategy_8723a LedStrategy ;
   u8 bRegUseLed ;
   void (*LedControlHandler)(struct rtw_adapter * , enum led_ctl_mode ) ;
};
struct rtw_ieee80211_channel {
   u16 hw_value ;
   u32 flags ;
};
struct registry_priv;
struct cmd_obj {
   struct work_struct work ;
   struct rtw_adapter *padapter ;
   u16 cmdcode ;
   int res ;
   u32 cmdsz ;
   u8 *parmbuf ;
   u8 *rsp ;
   u32 rspsz ;
};
struct cmd_priv {
   struct workqueue_struct *wq ;
   u32 cmd_issued_cnt ;
   u32 cmd_done_cnt ;
   u32 rsp_cnt ;
   struct rtw_adapter *padapter ;
};
struct evt_priv {
   struct workqueue_struct *wq ;
   struct work_struct irq_wk ;
};
struct c2h_evt_hdr {
   unsigned char id : 4 ;
   unsigned char plen : 4 ;
   u8 seq ;
   u8 payload[0U] ;
};
union __anonunion_u_300 {
   struct c2h_evt_hdr c2h_evt ;
   u8 buf[16U] ;
};
struct evt_work {
   union __anonunion_u_300 u ;
   struct work_struct work ;
   struct rtw_adapter *adapter ;
};
struct disconnect_parm {
   u32 deauth_timeout_ms ;
};
struct setopmode_parm {
   enum nl80211_iftype mode ;
};
struct sitesurvey_parm {
   int scan_mode ;
   u8 ssid_num ;
   u8 ch_num ;
   struct cfg80211_ssid ssid[9U] ;
   struct rtw_ieee80211_channel ch[51U] ;
};
struct set_stakey_parm {
   u8 addr[6U] ;
   u8 id ;
   u32 algorithm ;
   u8 key[16U] ;
};
struct set_stakey_rsp {
   u8 addr[6U] ;
   u8 keyid ;
   u8 rsvd ;
};
struct set_assocsta_parm {
   u8 addr[6U] ;
};
struct set_assocsta_rsp {
   u8 cam_id ;
   u8 rsvd[3U] ;
};
struct drvextra_cmd_parm {
   int ec_id ;
   int type_size ;
   unsigned char *pbuf ;
};
struct addBaReq_parm {
   unsigned int tid ;
   u8 addr[6U] ;
};
struct set_ch_parm {
   u8 ch ;
   u8 bw ;
   u8 ch_offset ;
};
struct _cmd_callback {
   u32 cmd_code ;
   void (*callback)(struct rtw_adapter * , struct cmd_obj * ) ;
};
struct hw_xmit {
   struct rtw_queue *sta_queue ;
   int accnt ;
};
struct sta_info;
struct submit_ctx {
   u32 timeout_ms ;
   int status ;
   struct completion done ;
};
struct urb;
struct tx_servq {
   struct list_head tx_pending ;
   struct rtw_queue sta_pending ;
   int qcnt ;
};
struct sta_xmit_priv {
   spinlock_t lock ;
   int option ;
   int apsd_setting ;
   struct tx_servq be_q ;
   struct tx_servq bk_q ;
   struct tx_servq vi_q ;
   struct tx_servq vo_q ;
   struct list_head legacy_dz ;
   struct list_head apsd ;
   u16 txseq_tid[16U] ;
};
struct xmit_priv {
   spinlock_t lock ;
   struct semaphore xmit_sema ;
   struct semaphore terminate_xmitthread_sema ;
   struct rtw_queue be_pending ;
   struct rtw_queue bk_pending ;
   struct rtw_queue vi_pending ;
   struct rtw_queue vo_pending ;
   struct rtw_queue bm_pending ;
   int free_xmitframe_cnt ;
   struct rtw_queue free_xmit_queue ;
   int free_xframe_ext_cnt ;
   struct rtw_queue free_xframe_ext_queue ;
   uint frag_len ;
   struct rtw_adapter *adapter ;
   u8 vcs_setting ;
   u8 vcs ;
   u8 vcs_type ;
   u64 tx_bytes ;
   u64 tx_pkts ;
   u64 tx_drop ;
   u64 last_tx_bytes ;
   u64 last_tx_pkts ;
   struct hw_xmit *hwxmits ;
   u8 hwxmit_entry ;
   u8 wmm_para_seq[4U] ;
   struct semaphore tx_retevt ;
   u8 txirp_cnt ;
   struct tasklet_struct xmit_tasklet ;
   int beq_cnt ;
   int bkq_cnt ;
   int viq_cnt ;
   int voq_cnt ;
   struct rtw_queue free_xmitbuf_queue ;
   struct list_head xmitbuf_list ;
   struct rtw_queue pending_xmitbuf_queue ;
   uint free_xmitbuf_cnt ;
   struct rtw_queue free_xmit_extbuf_queue ;
   struct list_head xmitextbuf_list ;
   uint free_xmit_extbuf_cnt ;
   u16 nqos_ssn ;
   int ack_tx ;
   struct mutex ack_tx_mutex ;
   struct submit_ctx ack_tx_ops ;
   spinlock_t lock_sctx ;
};
struct recv_reorder_ctrl {
   struct rtw_adapter *padapter ;
   u8 enable ;
   u16 indicate_seq ;
   u16 wend_b ;
   u8 wsize_b ;
   struct rtw_queue pending_recvframe_queue ;
   struct timer_list reordering_ctrl_timer ;
};
struct stainfo_rxcache {
   u16 tid_rxseq[16U] ;
};
struct signal_stat {
   u8 update_req ;
   u8 avg_val ;
   u32 total_num ;
   u32 total_val ;
};
struct recv_priv {
   spinlock_t lock ;
   struct rtw_queue free_recv_queue ;
   struct rtw_queue recv_pending_queue ;
   struct rtw_queue uc_swdec_pending_queue ;
   int free_recvframe_cnt ;
   struct rtw_adapter *adapter ;
   u32 bIsAnyNonBEPkts ;
   u64 rx_bytes ;
   u64 rx_pkts ;
   u64 rx_drop ;
   u64 last_rx_bytes ;
   uint rx_icv_err ;
   uint rx_largepacket_crcerr ;
   uint rx_smallpacket_crcerr ;
   uint rx_middlepacket_crcerr ;
   u8 rx_pending_cnt ;
   struct urb *int_in_urb ;
   u8 *int_in_buf ;
   struct tasklet_struct irq_prepare_beacon_tasklet ;
   struct tasklet_struct recv_tasklet ;
   struct sk_buff_head free_recv_skb_queue ;
   struct sk_buff_head rx_skb_queue ;
   u8 *precv_buf ;
   u8 is_signal_dbg ;
   u8 signal_strength_dbg ;
   s8 rssi ;
   s8 rxpwdb ;
   u8 signal_strength ;
   u8 signal_qual ;
   u8 noise ;
   int RxSNRdB[2U] ;
   s8 RxRssi[2U] ;
   int FalseAlmCnt_all ;
   struct timer_list signal_stat_timer ;
   u32 signal_stat_sampling_interval ;
   struct signal_stat signal_qual_data ;
   struct signal_stat signal_strength_data ;
};
struct sta_recv_priv {
   spinlock_t lock ;
   int option ;
   struct rtw_queue defrag_q ;
   struct stainfo_rxcache rxcache ;
};
struct __anonstruct__byte__301 {
   u8 TSC0 ;
   u8 TSC1 ;
   u8 TSC2 ;
   u8 TSC3 ;
   u8 TSC4 ;
   u8 TSC5 ;
   u8 TSC6 ;
   u8 TSC7 ;
};
union pn48 {
   u64 val ;
   struct __anonstruct__byte__301 _byte_ ;
};
union Keytype {
   u8 skey[16U] ;
   u32 lkey[4U] ;
};
struct rtw_wep_key {
   u8 key[14U] ;
   u16 keylen ;
};
struct rt_pmkid_list {
   u8 bUsed ;
   u8 Bssid[6U] ;
   u8 PMKID[16U] ;
   u8 SsidBuf[33U] ;
   u8 *ssid_octet ;
   u16 ssid_length ;
};
struct security_priv {
   u32 dot11AuthAlgrthm ;
   u32 dot11PrivacyAlgrthm ;
   u32 dot11PrivacyKeyIndex ;
   struct rtw_wep_key wep_key[4U] ;
   u32 dot118021XGrpPrivacy ;
   u32 dot118021XGrpKeyid ;
   union Keytype dot118021XGrpKey[4U] ;
   union Keytype dot118021XGrptxmickey[4U] ;
   union Keytype dot118021XGrprxmickey[4U] ;
   union pn48 dot11Grptxpn ;
   union pn48 dot11Grprxpn ;
   unsigned int dot8021xalg ;
   unsigned int wpa_psk ;
   unsigned int wpa_group_cipher ;
   unsigned int wpa2_group_cipher ;
   unsigned int wpa_pairwise_cipher ;
   unsigned int wpa2_pairwise_cipher ;
   u8 wps_ie[512U] ;
   int wps_ie_len ;
   unsigned char binstallGrpkey : 1 ;
   unsigned char busetkipkey : 1 ;
   unsigned char bcheck_grpkey : 1 ;
   unsigned char hw_decrypted : 1 ;
   u32 ndisauthtype ;
   u32 ndisencryptstatus ;
   struct wlan_bssid_ex sec_bss ;
   u8 assoc_info[600U] ;
   u8 szofcapability[256U] ;
   u8 oidassociation[512U] ;
   u8 authenticator_ie[256U] ;
   u8 supplicant_ie[256U] ;
   unsigned long last_mic_err_time ;
   u8 btkip_countermeasure ;
   u8 btkip_wait_report ;
   unsigned long btkip_countermeasure_time ;
   struct rt_pmkid_list PMKIDList[16U] ;
   u8 PMKIDIndex ;
   u8 bWepDefaultKeyIdxSet ;
};
enum rt_rf_power_state {
    rf_on = 0,
    rf_sleep = 1,
    rf_off = 2,
    rf_max = 3
} ;
struct pwrctrl_priv {
   struct semaphore lock ;
   u8 volatile rpwm ;
   u8 volatile cpwm ;
   u8 volatile tog ;
   u8 volatile cpwm_tog ;
   u8 pwr_mode ;
   u8 smart_ps ;
   u8 bcn_ant_mode ;
   u32 alives ;
   struct work_struct cpwm_event ;
   u8 bpower_saving ;
   u8 reg_rfoff ;
   u8 reg_pdnmode ;
   u32 rfoff_reason ;
   u32 cur_ps_level ;
   u32 reg_rfps_level ;
   uint ips_enter23a_cnts ;
   uint ips_leave23a_cnts ;
   u8 ips_mode ;
   u8 ips_mode_req ;
   uint bips_processing ;
   unsigned long ips_deny_time ;
   u8 ps_processing ;
   u8 bLeisurePs ;
   u8 LpsIdleCount ;
   u8 power_mgnt ;
   u8 bFwCurrentInPSMode ;
   unsigned long DelayLPSLastTimeStamp ;
   u8 btcoex_rfon ;
   s32 pnp_current_pwr_state ;
   u8 pnp_bstop_trx ;
   u8 bInSuspend ;
   u8 bAutoResume ;
   u8 autopm_cnt ;
   u8 bSupportRemoteWakeup ;
   struct timer_list pwr_state_check_timer ;
   int pwr_state_check_interval ;
   u8 pwr_state_check_cnts ;
   int ps_flag ;
   enum rt_rf_power_state rf_pwrstate ;
   enum rt_rf_power_state change_rfpwrstate ;
   u8 wepkeymask ;
   u8 bHWPowerdown ;
   u8 bHWPwrPindetect ;
   u8 bkeepfwalive ;
   u8 brfoffbyhw ;
   unsigned long PS_BBRegBackup[4U] ;
};
typedef unsigned long kernel_ulong_t;
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const *data ;
};
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
struct usb_device;
struct wusb_dev;
struct ep_device;
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
   int streams ;
};
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char reset_running : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
struct mon_bus;
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
struct usb_tt;
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
struct eeprom_priv {
   u8 bautoload_fail_flag ;
   u8 bloadfile_fail_flag ;
   u8 bloadmac_fail_flag ;
   u8 mac_addr[6U] ;
   u16 channel_plan ;
   u8 EepromOrEfuse ;
   u8 efuse_eeprom_data[512U] ;
};
struct rtw_wlan_acl_node {
   struct list_head list ;
   u8 addr[6U] ;
   u8 valid ;
};
struct wlan_acl_pool {
   int mode ;
   int num ;
   struct rtw_wlan_acl_node aclnode[16U] ;
   struct rtw_queue acl_node_q ;
};
struct rssi_sta {
   s32 UndecoratedSmoothedPWDB ;
   s32 UndecoratedSmoothedCCK ;
   s32 UndecoratedSmoothedOFDM ;
   u64 PacketMap ;
   u8 ValidBit ;
};
struct stainfo_stats {
   u64 rx_mgnt_pkts ;
   u64 rx_beacon_pkts ;
   u64 rx_probereq_pkts ;
   u64 rx_probersp_pkts ;
   u64 rx_probersp_bm_pkts ;
   u64 rx_probersp_uo_pkts ;
   u64 rx_ctrl_pkts ;
   u64 rx_data_pkts ;
   u64 last_rx_mgnt_pkts ;
   u64 last_rx_beacon_pkts ;
   u64 last_rx_probereq_pkts ;
   u64 last_rx_probersp_pkts ;
   u64 last_rx_probersp_bm_pkts ;
   u64 last_rx_probersp_uo_pkts ;
   u64 last_rx_ctrl_pkts ;
   u64 last_rx_data_pkts ;
   u64 rx_bytes ;
   u64 rx_drops ;
   u64 tx_pkts ;
   u64 tx_bytes ;
   u64 tx_drops ;
};
struct sta_info {
   spinlock_t lock ;
   struct list_head list ;
   struct list_head hash_list ;
   struct rtw_adapter *padapter ;
   struct sta_xmit_priv sta_xmitpriv ;
   struct sta_recv_priv sta_recvpriv ;
   struct rtw_queue sleep_q ;
   unsigned int sleepq_len ;
   uint state ;
   uint aid ;
   uint mac_id ;
   uint qos_option ;
   u8 hwaddr[6U] ;
   uint ieee8021x_blocked ;
   u32 dot118021XPrivacy ;
   union Keytype dot11tkiptxmickey ;
   union Keytype dot11tkiprxmickey ;
   union Keytype dot118021x_UncstKey ;
   union pn48 dot11txpn ;
   union pn48 dot11rxpn ;
   u8 bssrateset[16U] ;
   u32 bssratelen ;
   s32 rssi ;
   s32 signal_quality ;
   u8 cts2self ;
   u8 rtsen ;
   u8 raid ;
   u8 init_rate ;
   u32 ra_mask ;
   u8 wireless_mode ;
   struct stainfo_stats sta_stats ;
   struct timer_list addba_retry_timer ;
   struct recv_reorder_ctrl recvreorder_ctrl[16U] ;
   u16 BA_starting_seqctrl[16U] ;
   struct ht_priv htpriv ;
   struct list_head asoc_list ;
   struct list_head auth_list ;
   unsigned int expire_to ;
   unsigned int auth_seq ;
   unsigned int authalg ;
   unsigned char chg_txt[128U] ;
   u16 capability ;
   int flags ;
   int dot8021xalg ;
   int wpa_psk ;
   int wpa_group_cipher ;
   int wpa2_group_cipher ;
   int wpa_pairwise_cipher ;
   int wpa2_pairwise_cipher ;
   u8 bpairwise_key_installed ;
   u8 wpa_ie[32U] ;
   u8 nonerp_set ;
   u8 no_short_slot_time_set ;
   u8 no_short_preamble_set ;
   u8 no_ht_gf_set ;
   u8 no_ht_set ;
   u8 ht_20mhz_set ;
   unsigned int tx_ra_bitmap ;
   u8 qos_info ;
   u8 max_sp_len ;
   u8 uapsd_bk ;
   u8 uapsd_be ;
   u8 uapsd_vi ;
   u8 uapsd_vo ;
   u8 has_legacy_ac ;
   unsigned int sleepq_ac_len ;
   u8 is_p2p_device ;
   u8 p2p_status_code ;
   u8 keep_alive_trycnt ;
   u8 dev_addr[6U] ;
   u8 dev_cap ;
   u16 config_methods ;
   u8 primary_dev_type[8U] ;
   u8 num_of_secdev_type ;
   u8 secdev_types_list[32U] ;
   u16 dev_name_len ;
   u8 dev_name[32U] ;
   u8 *passoc_req ;
   u32 assoc_req_len ;
   struct rssi_sta rssi_stat ;
   u8 bValid ;
   u8 rssi_level ;
   u8 RSSI_Path[4U] ;
   u8 RSSI_Ave ;
   u8 RXEVM[4U] ;
   u8 RXSNR[4U] ;
   u16 RxMgmtFrameSeqNum ;
};
struct sta_priv {
   spinlock_t sta_hash_lock ;
   struct list_head sta_hash[32U] ;
   int asoc_sta_count ;
   struct rtw_adapter *padapter ;
   struct list_head asoc_list ;
   struct list_head auth_list ;
   spinlock_t asoc_list_lock ;
   spinlock_t auth_list_lock ;
   u8 asoc_list_cnt ;
   u8 auth_list_cnt ;
   unsigned int auth_to ;
   unsigned int assoc_to ;
   unsigned int expire_to ;
   struct sta_info *sta_aid[32U] ;
   u16 sta_dz_bitmap ;
   u16 tim_bitmap ;
   u16 max_num_sta ;
   struct wlan_acl_pool acl_list ;
};
enum rt_scan_type {
    SCAN_PASSIVE = 0,
    SCAN_ACTIVE = 1,
    SCAN_MIX = 2
} ;
struct rt_link_detect {
   u32 NumTxOkInPeriod ;
   u32 NumRxOkInPeriod ;
   u32 NumRxUnicastOkInPeriod ;
   bool bBusyTraffic ;
   bool bTxBusyTraffic ;
   bool bRxBusyTraffic ;
   bool bHigherBusyTraffic ;
   bool bHigherBusyRxTraffic ;
   bool bHigherBusyTxTraffic ;
};
struct mlme_priv {
   spinlock_t lock ;
   int fw_state ;
   u8 bScanInProcess ;
   u8 to_join ;
   u8 to_roaming ;
   struct rtw_adapter *nic_hdl ;
   u8 not_indic_disco ;
   struct rtw_queue scanned_queue ;
   struct cfg80211_ssid assoc_ssid ;
   u8 assoc_bssid[6U] ;
   struct wlan_network cur_network ;
   u32 scan_interval ;
   struct timer_list assoc_timer ;
   uint assoc_by_bssid ;
   uint assoc_by_rssi ;
   struct timer_list scan_to_timer ;
   struct timer_list set_scan_deny_timer ;
   atomic_t set_scan_deny ;
   unsigned int qos_option ;
   int num_sta_no_ht ;
   int num_FortyMHzIntolerant ;
   struct ht_priv htpriv ;
   struct rt_link_detect LinkDetectInfo ;
   struct timer_list dynamic_chk_timer ;
   u8 key_mask ;
   u8 acm_mask ;
   u8 ChannelPlan ;
   enum rt_scan_type scan_mode ;
   u8 *wps_probe_req_ie ;
   u32 wps_probe_req_ie_len ;
   u8 *assoc_req ;
   u32 assoc_req_len ;
   u32 assoc_rsp_len ;
   u8 *assoc_rsp ;
   u32 wps_assoc_resp_ie_len ;
   u8 *wps_assoc_resp_ie ;
   u8 *wps_probe_resp_ie ;
   u32 wps_probe_resp_ie_len ;
   u8 *wps_beacon_ie ;
   u32 wps_beacon_ie_len ;
   u32 p2p_go_probe_resp_ie_len ;
   u32 p2p_assoc_req_ie_len ;
   u8 *p2p_beacon_ie ;
   u8 *p2p_probe_req_ie ;
   u8 *p2p_probe_resp_ie ;
   u8 *p2p_go_probe_resp_ie ;
   u8 *p2p_assoc_req_ie ;
   u32 p2p_beacon_ie_len ;
   u32 p2p_probe_req_ie_len ;
   u32 p2p_probe_resp_ie_len ;
   u8 *wfd_assoc_req_ie ;
   u32 wfd_assoc_req_ie_len ;
   int num_sta_non_erp ;
   int num_sta_no_short_slot_time ;
   int num_sta_no_short_preamble ;
   int olbc ;
   int num_sta_ht_no_gf ;
   int num_sta_ht_20mhz ;
   int olbc_ht ;
   u16 ht_op_mode ;
   spinlock_t bcn_update_lock ;
   u8 update_bcn ;
   u8 *wfd_beacon_ie ;
   u8 *wfd_probe_req_ie ;
   u8 *wfd_probe_resp_ie ;
   u8 *wfd_go_probe_resp_ie ;
   u32 wfd_beacon_ie_len ;
   u32 wfd_probe_req_ie_len ;
   u32 wfd_probe_resp_ie_len ;
   u32 wfd_go_probe_resp_ie_len ;
};
struct ss_res {
   int state ;
   int bss_cnt ;
   int channel_idx ;
   int scan_mode ;
   u8 ssid_num ;
   u8 ch_num ;
   struct cfg80211_ssid ssid[9U] ;
   struct rtw_ieee80211_channel ch[51U] ;
};
struct FW_Sta_Info {
   struct sta_info *psta ;
   u32 status ;
   u32 rx_pkt ;
   u32 retry ;
   unsigned char SupportedRates[16U] ;
};
struct mlme_ext_info {
   u32 state ;
   u32 reauth_count ;
   u32 reassoc_count ;
   u32 link_count ;
   u32 auth_seq ;
   u32 auth_algo ;
   u32 authModeToggle ;
   u32 enc_algo ;
   u32 key_index ;
   u32 iv ;
   u8 chg_txt[128U] ;
   u16 aid ;
   u16 bcn_interval ;
   u16 capability ;
   u8 assoc_AP_vendor ;
   u8 slotTime ;
   u8 preamble_mode ;
   u8 WMM_enable ;
   u8 ERP_enable ;
   u8 ERP_IE ;
   u8 HT_enable ;
   u8 HT_caps_enable ;
   u8 HT_info_enable ;
   u8 HT_protection ;
   u8 turboMode_cts2self ;
   u8 turboMode_rtsen ;
   u8 SM_PS ;
   u8 ADDBA_retry_count ;
   u8 dialogToken ;
   bool bAcceptAddbaReq ;
   u8 bwmode_updated ;
   u8 hidden_ssid_mode ;
   struct ADDBA_request ADDBA_req ;
   struct WMM_para_element WMM_param ;
   struct HT_caps_element HT_caps ;
   struct HT_info_element HT_info ;
   struct wlan_bssid_ex network ;
   struct FW_Sta_Info FW_sta_info[32U] ;
};
struct rt_channel_info {
   u8 ChannelNum ;
   enum rt_scan_type ScanType ;
};
struct p2p_reg_class {
   u8 reg_class ;
   u8 channel[20U] ;
   size_t channels ;
};
struct p2p_channels {
   struct p2p_reg_class reg_class[10U] ;
   size_t reg_classes ;
};
struct mlme_ext_priv {
   struct rtw_adapter *padapter ;
   u8 mlmeext_init ;
   atomic_t event_seq ;
   u16 mgnt_seq ;
   unsigned char cur_channel ;
   unsigned char cur_bwmode ;
   unsigned char cur_ch_offset ;
   unsigned char cur_wireless_mode ;
   unsigned char max_chan_nums ;
   struct rt_channel_info channel_set[38U] ;
   struct p2p_channels channel_list ;
   unsigned char basicrate[13U] ;
   unsigned char datarate[13U] ;
   struct ss_res sitesurvey_res ;
   struct mlme_ext_info mlmext_info ;
   struct timer_list survey_timer ;
   struct timer_list link_timer ;
   u16 chan_scan_time ;
   u8 scan_abort ;
   u8 tx_rate ;
   u32 retry ;
   u64 TSFValue ;
   unsigned char bstart_bss ;
   u8 update_channel_plan_by_ap_done ;
   u8 action_public_dialog_token ;
   u16 action_public_rxseq ;
   u8 active_keep_alive_check ;
};
struct cmd_hdl {
   uint parmsize ;
   int (*h2cfuns)(struct rtw_adapter * , u8 const * ) ;
};
struct registry_priv {
   u8 chip_version ;
   u8 rfintfs ;
   struct cfg80211_ssid ssid ;
   u8 channel ;
   u8 wireless_mode ;
   u8 scan_mode ;
   u8 preamble ;
   u8 vrtl_carrier_sense ;
   u8 vcs_type ;
   u16 rts_thresh ;
   u16 frag_thresh ;
   u8 adhoc_tx_pwr ;
   u8 soft_ap ;
   u8 power_mgnt ;
   u8 ips_mode ;
   u8 smart_ps ;
   u8 long_retry_lmt ;
   u8 short_retry_lmt ;
   u16 busy_thresh ;
   u8 ack_policy ;
   u8 software_encrypt ;
   u8 software_decrypt ;
   u8 acm_method ;
   u8 wmm_enable ;
   u8 uapsd_enable ;
   struct wlan_bssid_ex dev_network ;
   u8 ht_enable ;
   u8 cbw40_enable ;
   u8 ampdu_enable ;
   u8 rx_stbc ;
   u8 ampdu_amsdu ;
   u8 lowrate_two_xmit ;
   u8 rf_config ;
   u8 low_power ;
   u8 wifi_spec ;
   u8 channel_plan ;
   u8 btcoex ;
   u8 bt_iso ;
   u8 bt_sco ;
   u8 bt_ampdu ;
   bool bAcceptAddbaReq ;
   u8 antdiv_cfg ;
   u8 antdiv_type ;
   u8 usbss_enable ;
   u8 hwpdn_mode ;
   u8 hwpwrp_detect ;
   u8 hw_wps_pbc ;
   u8 max_roaming_times ;
   u8 enable80211d ;
   u8 ifname[16U] ;
   u8 if2name[16U] ;
   u8 notch_filter ;
   u8 regulatory_tid ;
};
struct dvobj_priv {
   struct rtw_adapter *if1 ;
   struct rtw_adapter *if2 ;
   struct mutex hw_init_mutex ;
   struct mutex h2c_fwcmd_mutex ;
   struct mutex setch_mutex ;
   struct mutex setbw_mutex ;
   unsigned char oper_channel ;
   unsigned char oper_bwmode ;
   unsigned char oper_ch_offset ;
   struct rtw_adapter *padapters[4U] ;
   u8 iface_nums ;
   u8 InterfaceNumber ;
   u8 NumInterfaces ;
   int RtInPipe[2U] ;
   int RtOutPipe[3U] ;
   u8 Queue2Pipe[8U] ;
   u8 nr_endpoint ;
   u8 ishighspeed ;
   u8 RtNumInPipes ;
   u8 RtNumOutPipes ;
   int ep_num[5U] ;
   struct mutex usb_vendor_req_mutex ;
   u8 *usb_alloc_vendor_req_buf ;
   u8 *usb_vendor_req_buf ;
   struct usb_interface *pusbintf ;
   struct usb_device *pusbdev ;
   atomic_t continual_urb_error ;
};
struct rtw_adapter {
   int pid[3U] ;
   int bDongle ;
   u16 chip_type ;
   u16 HardwareType ;
   struct dvobj_priv *dvobj ;
   struct mlme_priv mlmepriv ;
   struct mlme_ext_priv mlmeextpriv ;
   struct cmd_priv cmdpriv ;
   struct evt_priv evtpriv ;
   struct xmit_priv xmitpriv ;
   struct recv_priv recvpriv ;
   struct sta_priv stapriv ;
   struct security_priv securitypriv ;
   struct registry_priv registrypriv ;
   struct pwrctrl_priv pwrctrlpriv ;
   struct eeprom_priv eeprompriv ;
   struct led_priv ledpriv ;
   u32 setband ;
   void *HalData ;
   s32 bDriverStopped ;
   s32 bSurpriseRemoved ;
   s32 bCardDisableWOHSM ;
   u32 IsrContent ;
   u32 ImrContent ;
   u8 EepromAddressSize ;
   u8 hw_init_completed ;
   u8 bDriverIsGoingToUnload ;
   u8 init_adpt_in_progress ;
   u8 bHaltInProgress ;
   struct net_device *pnetdev ;
   int bup ;
   struct net_device_stats stats ;
   struct wireless_dev *rtw_wdev ;
   int net_closed ;
   u8 bFWReady ;
   u8 bReadPortCancel ;
   u8 bWritePortCancel ;
   u8 bNotifyChannelChange ;
   struct rtw_adapter *pbuddy_adapter ;
   u8 iface_id ;
};
enum rt_media_status;
enum rt_media_status;
enum rt_media_status {
    RT_MEDIA_DISCONNECT = 0,
    RT_MEDIA_CONNECT = 1
} ;
typedef int ldv_func_ret_type___2;
typedef int ldv_func_ret_type___3;
typedef int ldv_func_ret_type___4;
typedef int ldv_func_ret_type___5;
typedef int ldv_func_ret_type___6;
typedef int ldv_func_ret_type___7;
typedef int ldv_func_ret_type___8;
enum hrtimer_restart;
enum hrtimer_restart;
enum ndis_802_11_auth_mode {
    Ndis802_11AuthModeOpen = 0,
    Ndis802_11AuthModeShared = 1,
    Ndis802_11AuthModeAutoSwitch = 2,
    Ndis802_11AuthModeWPA = 3,
    Ndis802_11AuthModeWPAPSK = 4,
    Ndis802_11AuthModeWPANone = 5,
    dis802_11AuthModeMax = 6
} ;
enum hrtimer_restart;
enum hrtimer_restart;
typedef int ldv_func_ret_type___9;
typedef int ldv_func_ret_type___10;
typedef int ldv_func_ret_type___11;
typedef int ldv_func_ret_type___12;
typedef int ldv_func_ret_type___13;
typedef int ldv_func_ret_type___14;
typedef int ldv_func_ret_type___15;
typedef int ldv_func_ret_type___16;
typedef int ldv_func_ret_type___17;
typedef int ldv_func_ret_type___18;
typedef int ldv_func_ret_type___19;
typedef int ldv_func_ret_type___20;
typedef int ldv_func_ret_type___21;
typedef int ldv_func_ret_type___22;
typedef int ldv_func_ret_type___23;
typedef int ldv_func_ret_type___24;
typedef int ldv_func_ret_type___25;
typedef int ldv_func_ret_type___26;
typedef int ldv_func_ret_type___27;
typedef int ldv_func_ret_type___28;
typedef int ldv_func_ret_type___29;
typedef int ldv_func_ret_type___30;
typedef int ldv_func_ret_type___31;
typedef int ldv_func_ret_type___32;
typedef int ldv_func_ret_type___33;
typedef int ldv_func_ret_type___34;
typedef int ldv_func_ret_type___35;
typedef int ldv_func_ret_type___36;
typedef int ldv_func_ret_type___37;
typedef int ldv_func_ret_type___38;
typedef int ldv_func_ret_type___39;
typedef int ldv_func_ret_type___40;
typedef int ldv_func_ret_type___41;
typedef int ldv_func_ret_type___42;
typedef int ldv_func_ret_type___43;
typedef int ldv_func_ret_type___44;
typedef int ldv_func_ret_type___45;
typedef int ldv_func_ret_type___46;
typedef int ldv_func_ret_type___47;
typedef int ldv_func_ret_type___48;
typedef int ldv_func_ret_type___49;
typedef int ldv_func_ret_type___50;
typedef int ldv_func_ret_type___51;
typedef int ldv_func_ret_type___52;
typedef int ldv_func_ret_type___53;
typedef int ldv_func_ret_type___54;
typedef int ldv_func_ret_type___55;
typedef int ldv_func_ret_type___56;
typedef int ldv_func_ret_type___57;
typedef int ldv_func_ret_type___58;
typedef int ldv_func_ret_type___59;
typedef int ldv_func_ret_type___60;
typedef int ldv_func_ret_type___61;
typedef int ldv_func_ret_type___62;
typedef int ldv_func_ret_type___63;
typedef int ldv_func_ret_type___64;
typedef int ldv_func_ret_type___65;
typedef int ldv_func_ret_type___66;
typedef int ldv_func_ret_type___67;
typedef int ldv_func_ret_type___68;
typedef int ldv_func_ret_type___69;
typedef int ldv_func_ret_type___70;
typedef int ldv_func_ret_type___71;
typedef int ldv_func_ret_type___72;
typedef int ldv_func_ret_type___73;
typedef int ldv_func_ret_type___74;
typedef int ldv_func_ret_type___75;
typedef int ldv_func_ret_type___76;
typedef int ldv_func_ret_type___77;
typedef int ldv_func_ret_type___78;
typedef int ldv_func_ret_type___79;
typedef int ldv_func_ret_type___80;
typedef int ldv_func_ret_type___81;
typedef int ldv_func_ret_type___82;
typedef int ldv_func_ret_type___83;
typedef int ldv_func_ret_type___84;
typedef int ldv_func_ret_type___85;
typedef int ldv_func_ret_type___86;
typedef int ldv_func_ret_type___87;
typedef int ldv_func_ret_type___88;
typedef int ldv_func_ret_type___89;
typedef int ldv_func_ret_type___90;
typedef int ldv_func_ret_type___91;
typedef int ldv_func_ret_type___92;
typedef int ldv_func_ret_type___93;
typedef int ldv_func_ret_type___94;
typedef int ldv_func_ret_type___95;
typedef int ldv_func_ret_type___96;
typedef int ldv_func_ret_type___97;
typedef int ldv_func_ret_type___98;
typedef int ldv_func_ret_type___99;
typedef int ldv_func_ret_type___100;
typedef int ldv_func_ret_type___101;
typedef int ldv_func_ret_type___102;
typedef int ldv_func_ret_type___103;
typedef int ldv_func_ret_type___104;
typedef int ldv_func_ret_type___105;
typedef int ldv_func_ret_type___106;
enum hrtimer_restart;
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
} ;
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 const *ie ;
   size_t ie_len ;
   u32 flags ;
   u32 rates[3U] ;
   struct wireless_dev *wdev ;
   struct wiphy *wiphy ;
   unsigned long scan_start ;
   bool aborted ;
   bool notified ;
   bool no_cck ;
   struct ieee80211_channel *channels[0U] ;
};
struct ieee80211_ht_addt_info {
   unsigned char control_chan ;
   unsigned char ht_param ;
   unsigned short operation_mode ;
   unsigned short stbc_param ;
   unsigned char basic_set[16U] ;
};
struct setauth_parm {
   u8 mode ;
   u8 _1x ;
   u8 rsvd[2U] ;
};
struct setkey_parm {
   u32 algorithm ;
   u8 keyid ;
   u8 grpkey ;
   u8 set_tx ;
   u8 key[16U] ;
};
struct pkt_attrib {
   u16 type ;
   u8 bswenc ;
   u8 dhcp_pkt ;
   u16 ether_type ;
   u16 seqnum ;
   u16 pkt_hdrlen ;
   u16 hdrlen ;
   u32 pktlen ;
   u32 last_txcmdsz ;
   u32 encrypt ;
   u8 nr_frags ;
   u8 iv_len ;
   u8 icv_len ;
   u8 iv[18U] ;
   u8 icv[16U] ;
   u8 priority ;
   u8 ack_policy ;
   u8 mac_id ;
   u8 vcs_mode ;
   u8 dst[6U] ;
   u8 src[6U] ;
   u8 ta[6U] ;
   u8 ra[6U] ;
   u8 key_idx ;
   u8 qos_en ;
   u8 ht_en ;
   u8 raid ;
   u8 bwmode ;
   u8 ch_offset ;
   u8 sgi ;
   u8 ampdu_en ;
   u8 mdata ;
   u8 pctrl ;
   u8 triggered ;
   u8 qsel ;
   u8 eosp ;
   u8 rate ;
   u8 retry_ctrl ;
   struct sta_info *psta ;
};
struct xmit_buf {
   struct list_head list ;
   struct list_head list2 ;
   struct rtw_adapter *padapter ;
   u8 *pallocated_buf ;
   u8 *pbuf ;
   void *priv_data ;
   u16 ext_tag ;
   u16 flags ;
   u32 alloc_sz ;
   u32 len ;
   struct submit_ctx *sctx ;
   u32 ff_hwaddr ;
   struct urb *pxmit_urb[8U] ;
   u8 bpending[8U] ;
   int last[8U] ;
};
struct xmit_frame {
   struct list_head list ;
   struct pkt_attrib attrib ;
   struct sk_buff *pkt ;
   int frame_tag ;
   struct rtw_adapter *padapter ;
   u8 *buf_addr ;
   struct xmit_buf *pxmitbuf ;
   s8 pkt_offset ;
   u8 ack_report ;
   u8 ext_tag ;
};
enum hal_def_variable {
    HAL_DEF_UNDERCORATEDSMOOTHEDPWDB = 0,
    HAL_DEF_IS_SUPPORT_ANT_DIV = 1,
    HAL_DEF_CURRENT_ANTENNA = 2,
    HAL_DEF_DRVINFO_SZ = 3,
    HAL_DEF_MAX_RECVBUF_SZ = 4,
    HAL_DEF_RX_PACKET_OFFSET = 5,
    HAL_DEF_DBG_DUMP_RXPKT = 6,
    HAL_DEF_DBG_DM_FUNC = 7,
    HAL_DEF_RA_DECISION_RATE = 8,
    HAL_DEF_RA_SGI = 9,
    HAL_DEF_PT_PWR_STATUS = 10,
    HW_VAR_MAX_RX_AMPDU_FACTOR = 11,
    HW_DEF_RA_INFO_DUMP = 12,
    HAL_DEF_DBG_DUMP_TXPKT = 13,
    HW_DEF_FA_CNT_DUMP = 14,
    HW_DEF_ODM_DBG_FLAG = 15
} ;
enum hal_odm_variable {
    HAL_ODM_STA_INFO = 0,
    HAL_ODM_P2P_STATE = 1,
    HAL_ODM_WIFI_DISPLAY_STATE = 2
} ;
struct stassoc_event {
   unsigned char macaddr[6U] ;
   unsigned char rsvd[2U] ;
   int cam_id ;
};
struct stadel_event {
   unsigned char macaddr[6U] ;
   unsigned char rsvd[2U] ;
   int mac_id ;
};
struct rtw_wdev_priv {
   struct wireless_dev *rtw_wdev ;
   struct rtw_adapter *padapter ;
   struct cfg80211_scan_request *scan_request ;
   spinlock_t scan_req_lock ;
   struct net_device *pmon_ndev ;
   char ifname_mon[17U] ;
   u8 p2p_enabled ;
   bool power_mgmt ;
};
typedef __u64 __le64;
enum hrtimer_restart;
struct ieee80211_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   u8 addr4[6U] ;
};
struct ieee80211_qos_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   __le16 qos_ctrl ;
};
struct ieee80211_msrment_ie {
   u8 token ;
   u8 mode ;
   u8 type ;
   u8 request[0U] ;
};
struct ieee80211_ext_chansw_ie {
   u8 mode ;
   u8 new_operating_class ;
   u8 new_ch_num ;
   u8 count ;
};
struct __anonstruct_auth_254 {
   __le16 auth_alg ;
   __le16 auth_transaction ;
   __le16 status_code ;
   u8 variable[0U] ;
};
struct __anonstruct_deauth_255 {
   __le16 reason_code ;
};
struct __anonstruct_assoc_req_256 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 variable[0U] ;
};
struct __anonstruct_assoc_resp_257 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
struct __anonstruct_reassoc_resp_258 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
struct __anonstruct_reassoc_req_259 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 current_ap[6U] ;
   u8 variable[0U] ;
};
struct __anonstruct_disassoc_260 {
   __le16 reason_code ;
};
struct __anonstruct_beacon_261 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
struct __anonstruct_probe_req_262 {
   u8 variable[0U] ;
};
struct __anonstruct_probe_resp_263 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
struct __anonstruct_wme_action_266 {
   u8 action_code ;
   u8 dialog_token ;
   u8 status_code ;
   u8 variable[0U] ;
};
struct __anonstruct_chan_switch_267 {
   u8 action_code ;
   u8 variable[0U] ;
};
struct __anonstruct_ext_chan_switch_268 {
   u8 action_code ;
   struct ieee80211_ext_chansw_ie data ;
   u8 variable[0U] ;
};
struct __anonstruct_measurement_269 {
   u8 action_code ;
   u8 dialog_token ;
   u8 element_id ;
   u8 length ;
   struct ieee80211_msrment_ie msr_elem ;
};
struct __anonstruct_addba_req_270 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capab ;
   __le16 timeout ;
   __le16 start_seq_num ;
};
struct __anonstruct_addba_resp_271 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 status ;
   __le16 capab ;
   __le16 timeout ;
};
struct __anonstruct_delba_272 {
   u8 action_code ;
   __le16 params ;
   __le16 reason_code ;
};
struct __anonstruct_self_prot_273 {
   u8 action_code ;
   u8 variable[0U] ;
};
struct __anonstruct_mesh_action_274 {
   u8 action_code ;
   u8 variable[0U] ;
};
struct __anonstruct_sa_query_275 {
   u8 action ;
   u8 trans_id[2U] ;
};
struct __anonstruct_ht_smps_276 {
   u8 action ;
   u8 smps_control ;
};
struct __anonstruct_ht_notify_cw_277 {
   u8 action_code ;
   u8 chanwidth ;
};
struct __anonstruct_tdls_discover_resp_278 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capability ;
   u8 variable[0U] ;
};
struct __anonstruct_vht_opmode_notif_279 {
   u8 action_code ;
   u8 operating_mode ;
};
union __anonunion_u_265 {
   struct __anonstruct_wme_action_266 wme_action ;
   struct __anonstruct_chan_switch_267 chan_switch ;
   struct __anonstruct_ext_chan_switch_268 ext_chan_switch ;
   struct __anonstruct_measurement_269 measurement ;
   struct __anonstruct_addba_req_270 addba_req ;
   struct __anonstruct_addba_resp_271 addba_resp ;
   struct __anonstruct_delba_272 delba ;
   struct __anonstruct_self_prot_273 self_prot ;
   struct __anonstruct_mesh_action_274 mesh_action ;
   struct __anonstruct_sa_query_275 sa_query ;
   struct __anonstruct_ht_smps_276 ht_smps ;
   struct __anonstruct_ht_notify_cw_277 ht_notify_cw ;
   struct __anonstruct_tdls_discover_resp_278 tdls_discover_resp ;
   struct __anonstruct_vht_opmode_notif_279 vht_opmode_notif ;
};
struct __anonstruct_action_264 {
   u8 category ;
   union __anonunion_u_265 u ;
};
union __anonunion_u_253 {
   struct __anonstruct_auth_254 auth ;
   struct __anonstruct_deauth_255 deauth ;
   struct __anonstruct_assoc_req_256 assoc_req ;
   struct __anonstruct_assoc_resp_257 assoc_resp ;
   struct __anonstruct_reassoc_resp_258 reassoc_resp ;
   struct __anonstruct_reassoc_req_259 reassoc_req ;
   struct __anonstruct_disassoc_260 disassoc ;
   struct __anonstruct_beacon_261 beacon ;
   struct __anonstruct_probe_req_262 probe_req ;
   struct __anonstruct_probe_resp_263 probe_resp ;
   struct __anonstruct_action_264 action ;
};
struct ieee80211_mgmt {
   __le16 frame_control ;
   __le16 duration ;
   u8 da[6U] ;
   u8 sa[6U] ;
   u8 bssid[6U] ;
   __le16 seq_ctrl ;
   union __anonunion_u_253 u ;
};
struct Tx_Beacon_param {
   struct wlan_bssid_ex network ;
};
struct SetChannelPlan_param {
   u8 channel_plan ;
};
struct LedBlink_param {
   struct led_8723a *pLed ;
};
struct phy_info {
   u8 RxPWDBAll ;
   u8 SignalQuality ;
   u8 RxMIMOSignalQuality[2U] ;
   u8 RxMIMOSignalStrength[2U] ;
   s8 RxPower ;
   s8 RecvSignalPower ;
   u8 BTRxRSSIPercentage ;
   u8 SignalStrength ;
   u8 RxPwr[2U] ;
   u8 RxSNR[2U] ;
};
struct rx_pkt_attrib {
   u16 pkt_len ;
   u8 physt ;
   u8 drvinfo_sz ;
   u8 shift_sz ;
   u8 hdrlen ;
   u8 amsdu ;
   u8 qos ;
   u8 priority ;
   u8 pw_save ;
   u8 mdata ;
   u16 seq_num ;
   u8 frag_num ;
   u8 mfrag ;
   u8 order ;
   u8 privacy ;
   u8 bdecrypted ;
   u32 encrypt ;
   u8 iv_len ;
   u8 icv_len ;
   u8 crc_err ;
   u8 icv_err ;
   u16 eth_type ;
   u8 dst[6U] ;
   u8 src[6U] ;
   u8 ta[6U] ;
   u8 ra[6U] ;
   u8 bssid[6U] ;
   u8 ack_policy ;
   u8 tcpchk_valid ;
   u8 ip_chkrpt ;
   u8 tcp_chkrpt ;
   u8 key_index ;
   u8 mcs_rate ;
   u8 rxht ;
   u8 sgi ;
   u8 pkt_rpt_type ;
   u32 MacIDValidEntry[2U] ;
   struct phy_info phy_info ;
};
struct recv_frame {
   struct list_head list ;
   struct sk_buff *pkt ;
   struct rtw_adapter *adapter ;
   struct rx_pkt_attrib attrib ;
   struct sta_info *psta ;
   struct recv_reorder_ctrl *preorder_ctrl ;
};
struct survey_event {
   struct wlan_bssid_ex bss ;
};
struct surveydone_event {
   unsigned int bss_cnt ;
};
struct joinbss_event {
   struct wlan_network network ;
};
struct fwevent {
   u32 parmsize ;
   void (*event_callback)(struct rtw_adapter * , u8 const * ) ;
};
struct rt_channel_plan {
   unsigned char Channel[38U] ;
   unsigned char Len ;
};
struct rt_channel_plan_2g {
   unsigned char Channel[14U] ;
   unsigned char Len ;
};
struct rt_channel_plan_5g {
   unsigned char Channel[24U] ;
   unsigned char Len ;
};
struct rt_channel_plan_map {
   unsigned char Index2G ;
   unsigned char Index5G ;
};
struct mlme_handler {
   char *str ;
   int (*func)(struct rtw_adapter * , struct recv_frame * ) ;
};
struct action_handler {
   unsigned int num ;
   char *str ;
   int (*func)(struct rtw_adapter * , struct recv_frame * ) ;
};
enum hw_mode {
    IEEE80211G = 0,
    IEEE80211A = 1
} ;
enum ldv_33978 {
    BW20 = 0,
    BW40PLUS = 1,
    BW40MINUS = 2
} ;
struct p2p_oper_class_map {
   enum hw_mode mode ;
   u8 op_class ;
   u8 min_chan ;
   u8 max_chan ;
   u8 inc ;
   enum ldv_33978 bw ;
};
struct C2HEvent_Header {
   unsigned short len ;
   unsigned char ID ;
   unsigned char seq ;
   unsigned int rsvd ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
struct ieee80211_pspoll {
   __le16 frame_control ;
   __le16 aid ;
   u8 bssid[6U] ;
   u8 ta[6U] ;
};
struct recv_buf {
   struct list_head list ;
   struct rtw_adapter *adapter ;
   struct urb *purb ;
   struct sk_buff *pskb ;
};
enum hrtimer_restart;
struct mic_data {
   u32 K0 ;
   u32 K1 ;
   u32 L ;
   u32 R ;
   u32 M ;
   u32 nBytesInM ;
};
struct arc4context {
   u32 x ;
   u32 y ;
   u8 state[256U] ;
};
enum hrtimer_restart;
enum ht_channel_width {
    HT_CHANNEL_WIDTH_20 = 0,
    HT_CHANNEL_WIDTH_40 = 1,
    HT_CHANNEL_WIDTH_80 = 2,
    HT_CHANNEL_WIDTH_160 = 3,
    HT_CHANNEL_WIDTH_10 = 4
} ;
enum WIRELESS_MODE {
    WIRELESS_MODE_UNKNOWN = 0,
    WIRELESS_MODE_A = 4,
    WIRELESS_MODE_B = 1,
    WIRELESS_MODE_G = 2,
    WIRELESS_MODE_AUTO = 32,
    WIRELESS_MODE_N_24G = 8,
    WIRELESS_MODE_N_5G = 16,
    WIRELESS_MODE_AC = 64
} ;
struct bb_reg_define {
   u32 rfintfs ;
   u32 rfintfi ;
   u32 rfintfo ;
   u32 rfintfe ;
   u32 rf3wireOffset ;
   u32 rfLSSI_Select ;
   u32 rfTxGainStage ;
   u32 rfHSSIPara1 ;
   u32 rfHSSIPara2 ;
   u32 rfSwitchControl ;
   u32 rfAGCControl1 ;
   u32 rfAGCControl2 ;
   u32 rfRxIQImbalance ;
   u32 rfRxAFE ;
   u32 rfTxIQImbalance ;
   u32 rfTxAFE ;
   u32 rfLSSIReadBack ;
   u32 rfLSSIReadBackPi ;
};
enum hal_ic_type {
    CHIP_8192S = 0,
    CHIP_8188C = 1,
    CHIP_8192C = 2,
    CHIP_8192D = 3,
    CHIP_8723A = 4,
    CHIP_8188E = 5,
    CHIP_8881A = 6,
    CHIP_8812A = 7,
    CHIP_8821A = 8,
    CHIP_8723B = 9,
    CHIP_8192E = 10
} ;
enum hal_chip_type {
    TEST_CHIP = 0,
    NORMAL_CHIP = 1,
    FPGA = 2
} ;
enum hal_cut_version {
    A_CUT_VERSION = 0,
    B_CUT_VERSION = 1,
    C_CUT_VERSION = 2,
    D_CUT_VERSION = 3,
    E_CUT_VERSION = 4,
    F_CUT_VERSION = 5,
    G_CUT_VERSION = 6
} ;
enum hal_vendor {
    CHIP_VENDOR_TSMC = 0,
    CHIP_VENDOR_UMC = 1
} ;
enum hal_rf_type {
    RF_TYPE_1T1R = 0,
    RF_TYPE_1T2R = 1,
    RF_TYPE_2T2R = 2,
    RF_TYPE_2T3R = 3,
    RF_TYPE_2T4R = 4,
    RF_TYPE_3T3R = 5,
    RF_TYPE_3T4R = 6,
    RF_TYPE_4T4R = 7
} ;
struct hal_version {
   enum hal_ic_type ICType ;
   enum hal_chip_type ChipType ;
   enum hal_cut_version CUTVersion ;
   enum hal_vendor VendorType ;
   enum hal_rf_type RFType ;
   u8 ROMVer ;
};
enum rt_customer_id {
    RT_CID_DEFAULT = 0,
    RT_CID_8187_ALPHA0 = 1,
    RT_CID_8187_SERCOMM_PS = 2,
    RT_CID_8187_HW_LED = 3,
    RT_CID_8187_NETGEAR = 4,
    RT_CID_WHQL = 5,
    RT_CID_819x_CAMEO = 6,
    RT_CID_819x_RUNTOP = 7,
    RT_CID_819x_Senao = 8,
    RT_CID_TOSHIBA = 9,
    RT_CID_819x_Netcore = 10,
    RT_CID_Nettronix = 11,
    RT_CID_DLINK = 12,
    RT_CID_PRONET = 13,
    RT_CID_COREGA = 14,
    RT_CID_CHINA_MOBILE = 15,
    RT_CID_819x_ALPHA = 16,
    RT_CID_819x_Sitecom = 17,
    RT_CID_CCX = 18,
    RT_CID_819x_Lenovo = 19,
    RT_CID_819x_QMI = 20,
    RT_CID_819x_Edimax_Belkin = 21,
    RT_CID_819x_Sercomm_Belkin = 22,
    RT_CID_819x_CAMEO1 = 23,
    RT_CID_819x_MSI = 24,
    RT_CID_819x_Acer = 25,
    RT_CID_819x_AzWave_ASUS = 26,
    RT_CID_819x_AzWave = 27,
    RT_CID_819x_HP = 28,
    RT_CID_819x_WNC_COREGA = 29,
    RT_CID_819x_Arcadyan_Belkin = 30,
    RT_CID_819x_SAMSUNG = 31,
    RT_CID_819x_CLEVO = 32,
    RT_CID_819x_DELL = 33,
    RT_CID_819x_PRONETS = 34,
    RT_CID_819x_Edimax_ASUS = 35,
    RT_CID_819x_CAMEO_NETGEAR = 36,
    RT_CID_PLANEX = 37,
    RT_CID_CC_C = 38,
    RT_CID_819x_Xavi = 39,
    RT_CID_819x_FUNAI_TV = 40,
    RT_CID_819x_ALPHA_WD = 41
} ;
struct sreset_priv {
   struct mutex silentreset_mutex ;
   u8 silent_reset_inprogress ;
   u8 Wifi_Error_Status ;
   unsigned long last_tx_time ;
   unsigned long last_tx_complete_time ;
   s32 dbg_trigger_point ;
};
struct dig_t {
   u8 Dig_Enable_Flag ;
   u8 Dig_Ext_Port_Stage ;
   int RssiLowThresh ;
   int RssiHighThresh ;
   u32 FALowThresh ;
   u32 FAHighThresh ;
   u8 CurSTAConnectState ;
   u8 PreSTAConnectState ;
   u8 CurMultiSTAConnectState ;
   u8 PreIGValue ;
   u8 CurIGValue ;
   u8 BackupIGValue ;
   s8 BackoffVal ;
   s8 BackoffVal_range_max ;
   s8 BackoffVal_range_min ;
   u8 rx_gain_range_max ;
   u8 rx_gain_range_min ;
   u8 Rssi_val_min ;
   u8 PreCCK_CCAThres ;
   u8 CurCCK_CCAThres ;
   u8 PreCCKPDState ;
   u8 CurCCKPDState ;
   u8 LargeFAHit ;
   u8 ForbiddenIGI ;
   u32 Recover_cnt ;
   u8 DIG_Dynamic_MIN_0 ;
   u8 DIG_Dynamic_MIN_1 ;
   bool bMediaConnect_0 ;
   bool bMediaConnect_1 ;
   u32 AntDiv_RSSI_max ;
   u32 RSSI_max ;
};
struct dynamic_pwr_sav {
   u8 PreCCAState ;
   u8 CurCCAState ;
   u8 PreRFState ;
   u8 CurRFState ;
   int Rssi_val_min ;
   u8 initialize ;
   u32 Reg874 ;
   u32 RegC70 ;
   u32 Reg85C ;
   u32 RegA74 ;
};
struct false_alarm_stats {
   u32 Cnt_Parity_Fail ;
   u32 Cnt_Rate_Illegal ;
   u32 Cnt_Crc8_fail ;
   u32 Cnt_Mcs_fail ;
   u32 Cnt_Ofdm_fail ;
   u32 Cnt_Cck_fail ;
   u32 Cnt_all ;
   u32 Cnt_Fast_Fsync ;
   u32 Cnt_SB_Search_fail ;
   u32 Cnt_OFDM_CCA ;
   u32 Cnt_CCK_CCA ;
   u32 Cnt_CCA_all ;
   u32 Cnt_BW_USC ;
   u32 Cnt_BW_LSC ;
};
struct pri_cca {
   u8 PriCCA_flag ;
   u8 intf_flag ;
   u8 intf_type ;
   u8 DupRTS_flag ;
   u8 Monitor_flag ;
};
struct rx_hp {
   u8 RXHP_flag ;
   u8 PSD_func_trigger ;
   u8 PSD_bitmap_RXHP[80U] ;
   u8 Pre_IGI ;
   u8 Cur_IGI ;
   u8 Pre_pw_th ;
   u8 Cur_pw_th ;
   bool First_time_enter ;
   bool RXHP_enable ;
   u8 TP_Mode ;
};
struct sw_ant_sw {
   u8 try_flag ;
   s32 PreRSSI ;
   u8 CurAntenna ;
   u8 PreAntenna ;
   u8 RSSI_Trying ;
   u8 TestMode ;
   u8 bTriggerAntennaSwitch ;
   u8 SelectAntennaMap ;
   u8 RSSI_target ;
   u8 SWAS_NoLink_State ;
   u32 SWAS_NoLink_BK_Reg860 ;
   bool ANTA_ON ;
   bool ANTB_ON ;
   s32 RSSI_sum_A ;
   s32 RSSI_sum_B ;
   s32 RSSI_cnt_A ;
   s32 RSSI_cnt_B ;
   u64 lastTxOkCnt ;
   u64 lastRxOkCnt ;
   u64 TXByteCnt_A ;
   u64 TXByteCnt_B ;
   u64 RXByteCnt_A ;
   u64 RXByteCnt_B ;
   u8 TrafficLoad ;
};
struct edca_turbo {
   bool bCurrentTurboEDCA ;
   bool bIsCurRDLState ;
   u32 prv_traffic_idx ;
};
struct odm_rate_adapt {
   u8 Type ;
   u8 HighRSSIThresh ;
   u8 LowRSSIThresh ;
   u8 RATRState ;
   u32 LastRATR ;
};
struct odm_phy_dbg_info {
   s8 RxSNRdB[2U] ;
   u64 NumQryPhyStatus ;
   u64 NumQryPhyStatusCCK ;
   u64 NumQryPhyStatusOFDM ;
   s32 RxEVM[2U] ;
};
struct iqk_matrix_regs_set {
   bool bIQKDone ;
   s32 Value[1U][8U] ;
};
struct odm_rf_cal_t {
   u32 RegA24 ;
   s32 RegE94 ;
   s32 RegE9C ;
   s32 RegEB4 ;
   s32 RegEBC ;
   u8 TXPowercount ;
   bool bTXPowerTrackingInit ;
   bool bTXPowerTracking ;
   u8 TxPowerTrackControl ;
   u8 TM_Trigger ;
   u8 InternalPA5G[2U] ;
   u8 ThermalMeter[2U] ;
   u8 ThermalValue ;
   u8 ThermalValue_LCK ;
   u8 ThermalValue_IQK ;
   u8 ThermalValue_DPK ;
   u8 ThermalValue_AVG[8U] ;
   u8 ThermalValue_AVG_index ;
   u8 ThermalValue_RxGain ;
   u8 ThermalValue_Crystal ;
   u8 ThermalValue_DPKstore ;
   u8 ThermalValue_DPKtrack ;
   bool TxPowerTrackingInProgress ;
   bool bDPKenable ;
   bool bReloadtxpowerindex ;
   u8 bRfPiEnable ;
   u32 TXPowerTrackingCallbackCnt ;
   u8 bCCKinCH14 ;
   u8 CCK_index ;
   u8 OFDM_index[2U] ;
   bool bDoneTxpower ;
   u8 ThermalValue_HP[8U] ;
   u8 ThermalValue_HP_index ;
   struct iqk_matrix_regs_set IQKMatrixRegSetting[46U] ;
   u8 Delta_IQK ;
   u8 Delta_LCK ;
   u32 RegC04 ;
   u32 Reg874 ;
   u32 RegC08 ;
   u32 RegB68 ;
   u32 RegB6C ;
   u32 Reg870 ;
   u32 Reg860 ;
   u32 Reg864 ;
   bool bIQKInitialized ;
   bool bLCKInProgress ;
   bool bAntennaDetected ;
   u32 ADDA_backup[16U] ;
   u32 IQK_MAC_backup[4U] ;
   u32 IQK_BB_backup_recover[9U] ;
   u32 IQK_BB_backup[9U] ;
   u32 APKoutput[2U][2U] ;
   u8 bAPKdone ;
   u8 bAPKThermalMeterIgnore ;
   u8 bDPdone ;
   u8 bDPPathAOK ;
   u8 bDPPathBOK ;
};
struct odm_fat_t {
   u8 Bssid[6U] ;
   u8 antsel_rx_keep_0 ;
   u8 antsel_rx_keep_1 ;
   u8 antsel_rx_keep_2 ;
   u32 antSumRSSI[7U] ;
   u32 antRSSIcnt[7U] ;
   u32 antAveRSSI[7U] ;
   u8 FAT_State ;
   u32 TrainIdx ;
   u8 antsel_a[32U] ;
   u8 antsel_b[32U] ;
   u8 antsel_c[32U] ;
   u32 MainAnt_Sum[32U] ;
   u32 AuxAnt_Sum[32U] ;
   u32 MainAnt_Cnt[32U] ;
   u32 AuxAnt_Cnt[32U] ;
   u8 RxIdleAnt ;
   bool bBecomeLinked ;
};
struct dm_odm_t {
   struct rtw_adapter *Adapter ;
   u64 DebugComponents ;
   u32 DebugLevel ;
   bool bCckHighPower ;
   u8 RFPathRxEnable ;
   u8 ControlChannel ;
   u32 SupportAbility ;
   u8 SupportInterface ;
   u32 SupportICType ;
   u8 CutVersion ;
   u8 FabVersion ;
   u8 RFType ;
   u8 BoardType ;
   u8 ExtLNA ;
   u8 ExtPA ;
   u8 ExtTRSW ;
   u8 PatchID ;
   bool bInHctTest ;
   bool bWIFITest ;
   bool bDualMacSmartConcurrent ;
   u32 BK_SupportAbility ;
   u8 AntDivType ;
   u8 u8_temp ;
   bool bool_temp ;
   struct rtw_adapter *PADAPTER_temp ;
   u8 *pMacPhyMode ;
   u64 *pNumTxBytesUnicast ;
   u64 *pNumRxBytesUnicast ;
   u8 *pWirelessMode ;
   u8 *pBandType ;
   u8 *pSecChOffset ;
   u8 *pSecurity ;
   u8 *pBandWidth ;
   u8 *pChannel ;
   bool *pbGetValueFromOtherMac ;
   struct rtw_adapter **pBuddyAdapter ;
   bool *pbMasterOfDMSP ;
   bool *pbScanInProcess ;
   bool *pbPowerSaving ;
   u8 *pOnePathCCA ;
   u8 *pAntennaTest ;
   bool *pbNet_closed ;
   bool bWIFI_Direct ;
   bool bWIFI_Display ;
   bool bLinked ;
   u8 RSSI_Min ;
   u8 InterfaceIndex ;
   bool bIsMPChip ;
   bool bOneEntryOnly ;
   bool bBtDisabled ;
   bool bBtHsOperation ;
   u8 btHsDigVal ;
   bool bBtDisableEdcaTurbo ;
   bool bBtBusy ;
   struct sta_info *pODM_StaInfo[32U] ;
   bool RaSupport88E ;
   struct odm_phy_dbg_info PhyDbgInfo ;
   struct odm_fat_t DM_FatTable ;
   struct dig_t DM_DigTable ;
   struct dynamic_pwr_sav DM_PSTable ;
   struct pri_cca DM_PriCCA ;
   struct rx_hp DM_RXHP_Table ;
   struct false_alarm_stats FalseAlmCnt ;
   struct false_alarm_stats FlaseAlmCntBuddyAdapter ;
   struct sw_ant_sw DM_SWAT_Table ;
   bool RSSI_test ;
   struct edca_turbo DM_EDCA_Table ;
   u32 WMMEDCA_BE ;
   bool *pbDriverStopped ;
   bool *pbDriverIsGoingToPnpSetPowerSleep ;
   bool *pinit_adpt_in_progress ;
   bool bUserAssignLevel ;
   u8 RSSI_BT ;
   bool bPSDinProcess ;
   bool bDMInitialGainEnable ;
   u8 bUseRAMask ;
   struct odm_rate_adapt RateAdaptive ;
   struct odm_rf_cal_t RFCalibrateInfo ;
   u8 BbSwingIdxOfdm ;
   u8 BbSwingIdxOfdmCurrent ;
   u8 BbSwingIdxOfdmBase ;
   bool BbSwingFlagOfdm ;
   u8 BbSwingIdxCck ;
   u8 BbSwingIdxCckCurrent ;
   u8 BbSwingIdxCckBase ;
   bool BbSwingFlagCck ;
};
struct octet_string {
   u8 *Octet ;
   u16 Length ;
};
enum hci_status {
    HCI_STATUS_SUCCESS = 0,
    HCI_STATUS_UNKNOW_HCI_CMD = 1,
    HCI_STATUS_UNKNOW_CONNECT_ID = 2,
    HCI_STATUS_HW_FAIL = 3,
    HCI_STATUS_PAGE_TIMEOUT = 4,
    HCI_STATUS_AUTH_FAIL = 5,
    HCI_STATUS_PIN_OR_KEY_MISSING = 6,
    HCI_STATUS_MEM_CAP_EXCEED = 7,
    HCI_STATUS_CONNECT_TIMEOUT = 8,
    HCI_STATUS_CONNECT_LIMIT = 9,
    HCI_STATUS_SYN_CONNECT_LIMIT = 10,
    HCI_STATUS_ACL_CONNECT_EXISTS = 11,
    HCI_STATUS_CMD_DISALLOW = 12,
    HCI_STATUS_CONNECT_RJT_LIMIT_RESOURCE = 13,
    HCI_STATUS_CONNECT_RJT_SEC_REASON = 14,
    HCI_STATUS_CONNECT_RJT_UNACCEPT_BD_ADDR = 15,
    HCI_STATUS_CONNECT_ACCEPT_TIMEOUT = 16,
    HCI_STATUS_UNSUPPORT_FEATURE_PARA_VALUE = 17,
    HCI_STATUS_INVALID_HCI_CMD_PARA_VALUE = 18,
    HCI_STATUS_REMOTE_USER_TERMINATE_CONNECT = 19,
    HCI_STATUS_REMOTE_DEV_TERMINATE_LOW_RESOURCE = 20,
    HCI_STATUS_REMOTE_DEV_TERMINATE_CONNECT_POWER_OFF = 21,
    HCI_STATUS_CONNECT_TERMINATE_LOCAL_HOST = 22,
    HCI_STATUS_REPEATE_ATTEMPT = 23,
    HCI_STATUS_PAIR_NOT_ALLOW = 24,
    HCI_STATUS_UNKNOW_LMP_PDU = 25,
    HCI_STATUS_UNSUPPORT_REMOTE_LMP_FEATURE = 26,
    HCI_STATUS_SOC_OFFSET_REJECT = 27,
    HCI_STATUS_SOC_INTERVAL_REJECT = 28,
    HCI_STATUS_SOC_AIR_MODE_REJECT = 29,
    HCI_STATUS_INVALID_LMP_PARA = 30,
    HCI_STATUS_UNSPECIFIC_ERROR = 31,
    HCI_STATUS_UNSUPPORT_LMP_PARA_VALUE = 32,
    HCI_STATUS_ROLE_CHANGE_NOT_ALLOW = 33,
    HCI_STATUS_LMP_RESPONSE_TIMEOUT = 34,
    HCI_STATUS_LMP_ERROR_TRANSACTION_COLLISION = 35,
    HCI_STATUS_LMP_PDU_NOT_ALLOW = 36,
    HCI_STATUS_ENCRYPTION_MODE_NOT_ALLOW = 37,
    HCI_STATUS_LINK_KEY_CAN_NOT_CHANGE = 38,
    HCI_STATUS_REQUEST_QOS_NOT_SUPPORT = 39,
    HCI_STATUS_INSTANT_PASSED = 40,
    HCI_STATUS_PAIRING_UNIT_KEY_NOT_SUPPORT = 41,
    HCI_STATUS_DIFFERENT_TRANSACTION_COLLISION = 42,
    HCI_STATUS_RESERVE_1 = 43,
    HCI_STATUS_QOS_UNACCEPT_PARA = 44,
    HCI_STATUS_QOS_REJECT = 45,
    HCI_STATUS_CHNL_CLASSIFICATION_NOT_SUPPORT = 46,
    HCI_STATUS_INSUFFICIENT_SECURITY = 47,
    HCI_STATUS_PARA_OUT_OF_RANGE = 48,
    HCI_STATUS_RESERVE_2 = 49,
    HCI_STATUS_ROLE_SWITCH_PENDING = 50,
    HCI_STATUS_RESERVE_3 = 51,
    HCI_STATUS_RESERVE_SOLT_VIOLATION = 52,
    HCI_STATUS_ROLE_SWITCH_FAIL = 53,
    HCI_STATUS_EXTEND_INQUIRY_RSP_TOO_LARGE = 54,
    HCI_STATUS_SEC_SIMPLE_PAIRING_NOT_SUPPORT = 55,
    HCI_STATUS_HOST_BUSY_PAIRING = 56,
    HCI_STATUS_CONNECT_REJ_NOT_SUIT_CHNL_FOUND = 57,
    HCI_STATUS_CONTROLLER_BUSY = 58
} ;
enum amp_btap_type {
    AMP_BTAP_NONE = 0,
    AMP_BTAP_CREATOR = 1,
    AMP_BTAP_JOINER = 2
} ;
enum bt_connect_type {
    BT_CONNECT_AUTH_REQ = 0,
    BT_CONNECT_AUTH_RSP = 1,
    BT_CONNECT_ASOC_REQ = 2,
    BT_CONNECT_ASOC_RSP = 3,
    BT_DISCONNECT = 4
} ;
enum bt_state_wpa_auth {
    STATE_WPA_AUTH_UNINITIALIZED = 0,
    STATE_WPA_AUTH_WAIT_PACKET_1 = 1,
    STATE_WPA_AUTH_WAIT_PACKET_2 = 2,
    STATE_WPA_AUTH_WAIT_PACKET_3 = 3,
    STATE_WPA_AUTH_WAIT_PACKET_4 = 4,
    STATE_WPA_AUTH_SUCCESSED = 5
} ;
struct hci_flow_spec {
   u8 Identifier ;
   u8 ServiceType ;
   u16 MaximumSDUSize ;
   u32 SDUInterArrivalTime ;
   u32 AccessLatency ;
   u32 FlushTimeout ;
};
struct hci_log_link_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 BtLogLinkhandle ;
   u8 BtTxFlowSpecID ;
   struct hci_flow_spec Tx_Flow_Spec ;
   struct hci_flow_spec Rx_Flow_Spec ;
   u32 TxPacketCount ;
   u32 BestEffortFlushTimeout ;
   u8 bLLCompleteEventIsSet ;
   u8 bLLCancelCMDIsSetandComplete ;
};
struct hci_phy_link_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 LinkSuperversionTimeout ;
   u8 BtAMPKeyLen ;
   u8 BtAMPKeyType ;
   u8 BtAMPKey[32U] ;
};
struct amp_assoc_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 LenSoFar ;
   u16 MaxRemoteASSOCLen ;
   u16 AMPAssocRemLen ;
   void *AMPAssocfragment ;
};
struct hci_link_info {
   u16 ConnectHandle ;
   u8 IncomingTrafficMode ;
   u8 OutgoingTrafficMode ;
   u8 BTProfile ;
   u8 BTCoreSpec ;
   s8 BT_RSSI ;
   u8 TrafficProfile ;
   u8 linkRole ;
};
struct hci_ext_config {
   struct hci_link_info linkInfo[2U] ;
   u8 btOperationCode ;
   u16 CurrentConnectHandle ;
   u8 CurrentIncomingTrafficMode ;
   u8 CurrentOutgoingTrafficMode ;
   s8 MIN_BT_RSSI ;
   u8 NumberOfHandle ;
   u8 NumberOfSCO ;
   u8 CurrentBTStatus ;
   u16 HCIExtensionVer ;
   u8 btProfileCase ;
   u8 btProfileAction ;
   u8 bManualControl ;
   u8 bBTBusy ;
   u8 bBTA2DPBusy ;
   u8 bEnableWifiScanNotify ;
   u8 bHoldForBtOperation ;
   u32 bHoldPeriodCnt ;
};
struct hci_acl_packet_data {
   u16 ACLDataPacketLen ;
   u8 SyncDataPacketLen ;
   u16 TotalNumACLDataPackets ;
   u16 TotalSyncNumDataPackets ;
};
struct hci_phy_link_bss_info {
   u16 bdCap ;
};
struct bt_asoc_entry {
   u8 bUsed ;
   u8 mAssoc ;
   u8 b4waySuccess ;
   u8 Bssid[6U] ;
   struct hci_phy_link_cmd_data PhyLinkCmdData ;
   struct hci_log_link_cmd_data LogLinkCmdData[2U] ;
   struct hci_acl_packet_data ACLPacketsData ;
   struct amp_assoc_cmd_data AmpAsocCmdData ;
   struct octet_string BTSsid ;
   u8 BTSsidBuf[33U] ;
   enum hci_status PhyLinkDisconnectReason ;
   u8 bSendSupervisionPacket ;
   u32 NoRxPktCnt ;
   enum amp_btap_type AMPRole ;
   u8 BtCurrentState ;
   u8 BtNextState ;
   u8 bNeedPhysLinkCompleteEvent ;
   enum hci_status PhysLinkCompleteStatus ;
   u8 BTRemoteMACAddr[6U] ;
   u32 BTCapability ;
   u8 SyncDataPacketLen ;
   u16 TotalSyncNumDataPackets ;
   u16 TotalNumACLDataPackets ;
   u8 ShortRangeMode ;
   u8 PTK[64U] ;
   u8 GTK[32U] ;
   u8 ANonce[32U] ;
   u8 SNonce[32U] ;
   u64 KeyReplayCounter ;
   u8 WPAAuthReplayCount ;
   u8 AESKeyBuf[256U] ;
   u8 PMK[32U] ;
   enum bt_state_wpa_auth BTWPAAuthState ;
   s32 UndecoratedSmoothedPWDB ;
   u8 HwCAMIndex ;
   u8 bPeerQosSta ;
   u32 rxSuvpPktCnt ;
};
struct bt_traffic_statistics {
   u8 bTxBusyTraffic ;
   u8 bRxBusyTraffic ;
   u8 bIdle ;
   u32 TxPktCntInPeriod ;
   u32 RxPktCntInPeriod ;
   u64 TxPktLenInPeriod ;
   u64 RxPktLenInPeriod ;
};
struct bt_mgnt {
   u8 bBTConnectInProgress ;
   u8 bLogLinkInProgress ;
   u8 bPhyLinkInProgress ;
   u8 bPhyLinkInProgressStartLL ;
   u8 BtCurrentPhyLinkhandle ;
   u16 BtCurrentLogLinkhandle ;
   u8 CurrentConnectEntryNum ;
   u8 DisconnectEntryNum ;
   u8 CurrentBTConnectionCnt ;
   enum bt_connect_type BTCurrentConnectType ;
   enum bt_connect_type BTReceiveConnectPkt ;
   u8 BTAuthCount ;
   u8 BTAsocCount ;
   u8 bStartSendSupervisionPkt ;
   u8 BtOperationOn ;
   u8 BTNeedAMPStatusChg ;
   u8 JoinerNeedSendAuth ;
   struct hci_phy_link_bss_info bssDesc ;
   struct hci_ext_config ExtConfig ;
   u8 bNeedNotifyAMPNoCap ;
   u8 bCreateSpportQos ;
   u8 bSupportProfile ;
   u8 BTChannel ;
   u8 CheckChnlIsSuit ;
   u8 bBtScan ;
   u8 btLogoTest ;
};
struct bt_hci_dgb_info {
   u32 hciCmdCnt ;
   u32 hciCmdCntUnknown ;
   u32 hciCmdCntCreatePhyLink ;
   u32 hciCmdCntAcceptPhyLink ;
   u32 hciCmdCntDisconnectPhyLink ;
   u32 hciCmdPhyLinkStatus ;
   u32 hciCmdCntCreateLogLink ;
   u32 hciCmdCntAcceptLogLink ;
   u32 hciCmdCntDisconnectLogLink ;
   u32 hciCmdCntReadLocalAmpAssoc ;
   u32 hciCmdCntWriteRemoteAmpAssoc ;
   u32 hciCmdCntSetAclLinkStatus ;
   u32 hciCmdCntSetScoLinkStatus ;
   u32 hciCmdCntExtensionVersionNotify ;
   u32 hciCmdCntLinkStatusNotify ;
};
struct bt_irp_dgb_info {
   u32 irpMJCreate ;
   u32 irpIoControl ;
   u32 irpIoCtrlHciCmd ;
   u32 irpIoCtrlHciEvent ;
   u32 irpIoCtrlHciTxData ;
   u32 irpIoCtrlHciRxData ;
   u32 irpIoCtrlUnknown ;
   u32 irpIoCtrlHciTxData1s ;
};
struct bt_packet_dgb_info {
   u32 btPktTxProbReq ;
   u32 btPktRxProbReq ;
   u32 btPktRxProbReqFail ;
   u32 btPktTxProbRsp ;
   u32 btPktRxProbRsp ;
   u32 btPktTxAuth ;
   u32 btPktRxAuth ;
   u32 btPktRxAuthButDrop ;
   u32 btPktTxAssocReq ;
   u32 btPktRxAssocReq ;
   u32 btPktRxAssocReqButDrop ;
   u32 btPktTxAssocRsp ;
   u32 btPktRxAssocRsp ;
   u32 btPktTxDisassoc ;
   u32 btPktRxDisassoc ;
   u32 btPktRxDeauth ;
   u32 btPktTx4way1st ;
   u32 btPktRx4way1st ;
   u32 btPktTx4way2nd ;
   u32 btPktRx4way2nd ;
   u32 btPktTx4way3rd ;
   u32 btPktRx4way3rd ;
   u32 btPktTx4way4th ;
   u32 btPktRx4way4th ;
   u32 btPktTxLinkSuperReq ;
   u32 btPktRxLinkSuperReq ;
   u32 btPktTxLinkSuperRsp ;
   u32 btPktRxLinkSuperRsp ;
   u32 btPktTxData ;
   u32 btPktRxData ;
};
struct bt_dgb {
   u8 dbgCtrl ;
   u32 dbgProfile ;
   struct bt_hci_dgb_info dbgHciInfo ;
   struct bt_irp_dgb_info dbgIrpInfo ;
   struct bt_packet_dgb_info dbgBtPkt ;
};
struct bt_hci_info {
   u8 BTPalVersion ;
   u16 BTPalCompanyID ;
   u16 BTPalsubversion ;
   u16 BTConnectChnlListLen ;
   u8 BTConnectChnllist[64U] ;
   u16 FailContactCount ;
   u64 BTEventMask ;
   u64 BTEventMaskPage2 ;
   u16 ConnAcceptTimeout ;
   u16 LogicalAcceptTimeout ;
   u16 PageTimeout ;
   u8 LocationDomainAware ;
   u16 LocationDomain ;
   u8 LocationDomainOptions ;
   u8 LocationOptions ;
   u8 FlowControlMode ;
   u16 BtPreChnlListLen ;
   u8 BTPreChnllist[64U] ;
   u16 enFlush_LLH ;
   u16 FLTO_LLH ;
   u8 bInTestMode ;
   u8 bTestIsEnd ;
   u8 bTestNeedReport ;
   u8 TestScenario ;
   u8 TestReportInterval ;
   u8 TestCtrType ;
   u32 TestEventType ;
   u16 TestNumOfFrame ;
   u16 TestNumOfErrFrame ;
   u16 TestNumOfBits ;
   u16 TestNumOfErrBits ;
};
struct bt_traffic {
   u8 LastRxUniFragNum ;
   u16 LastRxUniSeqNum ;
   struct bt_traffic_statistics Bt30TrafficStatistics ;
};
struct bt_security {
   struct octet_string RSNIE ;
   u8 RSNIEBuf[256U] ;
   u8 bRegNoEncrypt ;
   u8 bUsedHwEncrypt ;
};
struct bt_30info {
   struct rtw_adapter *padapter ;
   struct bt_asoc_entry BtAsocEntry[2U] ;
   struct bt_mgnt BtMgnt ;
   struct bt_dgb BtDbg ;
   struct bt_hci_info BtHciInfo ;
   struct bt_traffic BtTraffic ;
   struct bt_security BtSec ;
   struct work_struct HCICmdWorkItem ;
   struct timer_list BTHCICmdTimer ;
   struct work_struct BTPsDisableWorkItem ;
   struct work_struct BTConnectWorkItem ;
   struct timer_list BTHCIDiscardAclDataTimer ;
   struct timer_list BTHCIJoinTimeoutTimer ;
   struct timer_list BTTestSendPacketTimer ;
   struct timer_list BTDisconnectPhyLinkTimer ;
   struct timer_list BTBeaconTimer ;
   u8 BTBeaconTmrOn ;
   struct timer_list BTPsDisableTimer ;
   void *pBtChnlList ;
};
struct btdm_8723a_1ant {
   u8 prePsTdma ;
   u8 curPsTdma ;
   u8 psTdmaDuAdjType ;
   u8 bPrePsTdmaOn ;
   u8 bCurPsTdmaOn ;
   u8 preWifiPara ;
   u8 curWifiPara ;
   u8 preCoexWifiCon ;
   u8 curCoexWifiCon ;
   u8 wifiRssiThresh ;
   u32 psTdmaMonitorCnt ;
   u32 psTdmaGlobalCnt ;
   u32 psTdmaMonitorCntForSCO ;
   u8 psTdmaDuAdjTypeForSCO ;
   u8 RSSI_WiFi_Last ;
   u8 RSSI_BT_Last ;
   u8 bWiFiHalt ;
   u8 bRAChanged ;
};
struct btdm_8723a_2ant {
   u8 bPreDecBtPwr ;
   u8 bCurDecBtPwr ;
   u8 preWlanActHi ;
   u8 curWlanActHi ;
   u8 preWlanActLo ;
   u8 curWlanActLo ;
   u8 preFwDacSwingLvl ;
   u8 curFwDacSwingLvl ;
   u8 bPreRfRxLpfShrink ;
   u8 bCurRfRxLpfShrink ;
   u8 bPreLowPenaltyRa ;
   u8 bCurLowPenaltyRa ;
   u8 preBtRetryIndex ;
   u8 curBtRetryIndex ;
   u8 bPreDacSwingOn ;
   u32 preDacSwingLvl ;
   u8 bCurDacSwingOn ;
   u32 curDacSwingLvl ;
   u8 bPreAdcBackOff ;
   u8 bCurAdcBackOff ;
   u8 bPreAgcTableEn ;
   u8 bCurAgcTableEn ;
   u32 preVal0x6c0 ;
   u32 curVal0x6c0 ;
   u32 preVal0x6c8 ;
   u32 curVal0x6c8 ;
   u8 preVal0x6cc ;
   u8 curVal0x6cc ;
   u8 bCurIgnoreWlanAct ;
   u8 bPreIgnoreWlanAct ;
   u8 prePsTdma ;
   u8 curPsTdma ;
   u8 psTdmaDuAdjType ;
   u8 bPrePsTdmaOn ;
   u8 bCurPsTdmaOn ;
   u8 preAlgorithm ;
   u8 curAlgorithm ;
   u8 bResetTdmaAdjust ;
   u8 btStatus ;
};
struct bt_coexist_8723a {
   u32 highPriorityTx ;
   u32 highPriorityRx ;
   u32 lowPriorityTx ;
   u32 lowPriorityRx ;
   u8 btRssi ;
   u8 TotalAntNum ;
   u8 bC2hBtInfoSupport ;
   u8 c2hBtInfo ;
   u8 c2hBtInfoOriginal ;
   u8 prec2hBtInfo ;
   u8 bC2hBtInquiryPage ;
   unsigned long btInqPageStartTime ;
   u8 c2hBtProfile ;
   u8 btRetryCnt ;
   u8 btInfoExt ;
   u8 bC2hBtInfoReqSent ;
   u8 bForceFwBtInfo ;
   u8 bForceA2dpSink ;
   struct btdm_8723a_2ant btdm2Ant ;
   struct btdm_8723a_1ant btdm1Ant ;
};
struct bt_coexist_str {
   u8 BluetoothCoexist ;
   u8 BT_Ant_Num ;
   u8 BT_CoexistType ;
   u8 BT_Ant_isolation ;
   u8 bt_radiosharedtype ;
   u32 Ratio_Tx ;
   u32 Ratio_PRI ;
   u8 bInitlized ;
   u32 BtRfRegOrigin1E ;
   u32 BtRfRegOrigin1F ;
   u8 bBTBusyTraffic ;
   u8 bBTTrafficModeSet ;
   u8 bBTNonTrafficModeSet ;
   struct bt_traffic_statistics BT21TrafficStatistics ;
   u64 CurrentState ;
   u64 PreviousState ;
   u8 preRssiState ;
   u8 preRssiState1 ;
   u8 preRssiStateBeacon ;
   u8 bFWCoexistAllOff ;
   u8 bSWCoexistAllOff ;
   u8 bHWCoexistAllOff ;
   u8 bBalanceOn ;
   u8 bSingleAntOn ;
   u8 bInterruptOn ;
   u8 bMultiNAVOn ;
   u8 PreWLANActH ;
   u8 PreWLANActL ;
   u8 WLANActH ;
   u8 WLANActL ;
   u8 A2DPState ;
   u8 AntennaState ;
   u32 lastBtEdca ;
   u16 last_aggr_num ;
   u8 bEDCAInitialized ;
   u8 exec_cnt ;
   u8 b8723aAgcTableOn ;
   u8 b92DAgcTableOn ;
   struct bt_coexist_8723a halCoex8723 ;
   u8 btActiveZeroCnt ;
   u8 bCurBtDisabled ;
   u8 bPreBtDisabled ;
   u8 bNeedToRoamForBtDisableEnable ;
   u8 fw3aVal[5U] ;
};
struct dm_priv {
   u8 DM_Type ;
   u8 DMFlag ;
   u8 InitDMFlag ;
   u32 InitODMFlag ;
   int UndecoratedSmoothedPWDB ;
   int UndecoratedSmoothedCCK ;
   int EntryMinUndecoratedSmoothedPWDB ;
   int EntryMaxUndecoratedSmoothedPWDB ;
   int MinUndecoratedPWDBForDM ;
   int LastMinUndecoratedPWDBForDM ;
   s32 UndecoratedSmoothedBeacon ;
   s32 BT_EntryMinUndecoratedSmoothedPWDB ;
   s32 BT_EntryMaxUndecoratedSmoothedPWDB ;
   u8 DynamicTxHighPowerLvl ;
   u8 bTXPowerTracking ;
   u8 TXPowercount ;
   u8 bTXPowerTrackingInit ;
   u8 TxPowerTrackControl ;
   u8 TM_Trigger ;
   u8 ThermalMeter[2U] ;
   u8 ThermalValue ;
   u8 ThermalValue_LCK ;
   u8 ThermalValue_IQK ;
   u8 ThermalValue_DPK ;
   u8 bRfPiEnable ;
   u32 APKoutput[2U][2U] ;
   u8 bAPKdone ;
   u8 bAPKThermalMeterIgnore ;
   u8 bDPdone ;
   u8 bDPPathAOK ;
   u8 bDPPathBOK ;
   u32 RegC04 ;
   u32 Reg874 ;
   u32 RegC08 ;
   u32 RegB68 ;
   u32 RegB6C ;
   u32 Reg870 ;
   u32 Reg860 ;
   u32 Reg864 ;
   u32 ADDA_backup[16U] ;
   u32 IQK_MAC_backup[4U] ;
   u32 IQK_BB_backup_recover[9U] ;
   u32 IQK_BB_backup[9U] ;
   u8 PowerIndex_backup[6U] ;
   u8 bCCKinCH14 ;
   u8 CCK_index ;
   u8 OFDM_index[2U] ;
   u8 bDoneTxpower ;
   u8 CCK_index_HP ;
   u8 OFDM_index_HP[2U] ;
   u8 ThermalValue_HP[8U] ;
   u8 ThermalValue_HP_index ;
   s32 RegE94 ;
   s32 RegE9C ;
   s32 RegEB4 ;
   s32 RegEBC ;
   u32 TXPowerTrackingCallbackCnt ;
   u32 prv_traffic_idx ;
   s32 OFDM_Pkt_Cnt ;
   u8 RSSI_Select ;
   u8 INIDATA_RATE[32U] ;
};
enum RT_MULTI_FUNC {
    RT_MULTI_FUNC_NONE = 0,
    RT_MULTI_FUNC_WIFI = 1,
    RT_MULTI_FUNC_BT = 2,
    RT_MULTI_FUNC_GPS = 4
} ;
enum RT_POLARITY_CTL {
    RT_POLARITY_LOW_ACT = 0,
    RT_POLARITY_HIGH_ACT = 1
} ;
enum RT_REGULATOR_MODE {
    RT_SWITCHING_REGULATOR = 0,
    RT_LDO_REGULATOR = 1
} ;
struct hal_data_8723a {
   struct hal_version VersionID ;
   enum rt_customer_id CustomerID ;
   u16 FirmwareVersion ;
   u16 FirmwareVersionRev ;
   u16 FirmwareSubVersion ;
   u16 FirmwareSignature ;
   u32 ReceiveConfig ;
   enum WIRELESS_MODE CurrentWirelessMode ;
   enum ht_channel_width CurrentChannelBW ;
   u8 CurrentChannel ;
   u8 nCur40MhzPrimeSC ;
   u16 BasicRateSet ;
   u8 rf_chip ;
   u8 rf_type ;
   u8 NumTotalRFPath ;
   u8 BoardType ;
   u8 CrystalCap ;
   u8 EEPROMVersion ;
   u16 EEPROMVID ;
   u16 EEPROMPID ;
   u16 EEPROMSVID ;
   u16 EEPROMSDID ;
   u8 EEPROMCustomerID ;
   u8 EEPROMSubCustomerID ;
   u8 EEPROMRegulatory ;
   u8 EEPROMThermalMeter ;
   u8 EEPROMBluetoothCoexist ;
   u8 EEPROMBluetoothType ;
   u8 EEPROMBluetoothAntNum ;
   u8 EEPROMBluetoothAntIsolation ;
   u8 EEPROMBluetoothRadioShared ;
   u8 bTXPowerDataReadFromEEPORM ;
   u8 bAPKThermalMeterIgnore ;
   u8 bIQKInitialized ;
   u8 bAntennaDetected ;
   u8 TxPwrLevelCck[2U][14U] ;
   u8 TxPwrLevelHT40_1S[2U][14U] ;
   u8 TxPwrLevelHT40_2S[2U][14U] ;
   u8 TxPwrHt20Diff[2U][14U] ;
   u8 TxPwrLegacyHtDiff[2U][14U] ;
   u8 PwrGroupHT20[2U][14U] ;
   u8 PwrGroupHT40[2U][14U] ;
   u8 LegacyHTTxPowerDiff ;
   u8 framesync ;
   u32 framesyncC34 ;
   u8 framesyncMonitor ;
   u8 DefaultInitialGain[4U] ;
   u8 pwrGroupCnt ;
   u32 MCSTxPowerLevelOriginalOffset[7U][16U] ;
   u32 CCKTxPowerLevelOriginalOffset ;
   u32 AntennaTxPath ;
   u32 AntennaRxPath ;
   u8 ExternalPA ;
   u8 bLedOpenDrain ;
   u8 b1x1RecvCombine ;
   u32 AcParam_BE ;
   u8 CurrentCckTxPwrIdx ;
   u8 CurrentOfdm24GTxPwrIdx ;
   struct bb_reg_define PHYRegDef[4U] ;
   bool bRFPathRxEnable[4U] ;
   u32 RfRegChnlVal[2U] ;
   u8 bCckHighPower ;
   bool bRDGEnable ;
   u8 LastHMEBoxNum ;
   u8 fw_ractrl ;
   u8 RegTxPause ;
   u32 RegBcnCtrlVal ;
   u8 RegFwHwTxQCtrl ;
   u8 RegReg542 ;
   struct dm_priv dmpriv ;
   struct dm_odm_t odmpriv ;
   struct sreset_priv srestpriv ;
   u8 bBTMode ;
   struct bt_30info BtInfo ;
   struct bt_coexist_str bt_coexist ;
   u8 bDumpRxPkt ;
   u8 FwRsvdPageStartOffset ;
   u8 pwrdown ;
   u32 interfaceIndex ;
   u8 OutEpQueueSel ;
   u8 OutEpNumber ;
   bool UsbRxHighSpeedMode ;
   bool SlimComboDbg ;
   u8 EepromOrEfuse ;
   u16 EfuseUsedBytes ;
   u16 BTEfuseUsedBytes ;
   u32 SysIntrStatus ;
   u32 SysIntrMask ;
   enum RT_MULTI_FUNC MultiFunc ;
   enum RT_POLARITY_CTL PolarityCtl ;
   enum RT_REGULATOR_MODE RegulatorMode ;
   bool bMACFuncEnable ;
   u32 IntArray[2U] ;
   u32 IntrMask[2U] ;
};
enum hrtimer_restart;
typedef __u16 __sum16;
enum hrtimer_restart;
struct iphdr {
   unsigned char ihl : 4 ;
   unsigned char version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
struct ieee80211_snap_hdr {
   u8 dsap ;
   u8 ssap ;
   u8 ctrl ;
   u8 oui[3U] ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct wlan_pwr_cfg {
   u16 offset ;
   u8 cut_msk ;
   unsigned char fab_msk : 4 ;
   unsigned char interface_msk : 4 ;
   unsigned char base : 4 ;
   unsigned char cmd : 4 ;
   u8 msk ;
   u8 value ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum RF_RADIO_PATH {
    RF_PATH_A = 0,
    RF_PATH_B = 1,
    RF_PATH_MAX = 2
} ;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct odm_packet_info {
   u8 Rate ;
   u8 StationID ;
   bool bPacketMatchBSSID ;
   bool bPacketToSelf ;
   bool bPacketBeacon ;
};
enum odm_bb_config_type {
    CONFIG_BB_PHY_REG = 0,
    CONFIG_BB_AGC_TAB = 1,
    CONFIG_BB_AGC_TAB_2G = 2,
    CONFIG_BB_AGC_TAB_5G = 3,
    CONFIG_BB_PHY_REG_PG = 4
} ;
struct phy_rx_agc_info {
   unsigned char gain : 7 ;
   unsigned char trsw : 1 ;
};
struct phy_status_rpt {
   struct phy_rx_agc_info path_agc[2U] ;
   u8 ch_corr[2U] ;
   u8 cck_sig_qual_ofdm_pwdb_all ;
   u8 cck_agc_rpt_ofdm_cfosho_a ;
   u8 cck_rpt_b_ofdm_cfosho_b ;
   u8 rsvd_1 ;
   u8 noise_power_db_msb ;
   u8 path_cfotail[2U] ;
   u8 pcts_mask[2U] ;
   s8 stream_rxevm[2U] ;
   u8 path_rxsnr[2U] ;
   u8 noise_power_db_lsb ;
   u8 rsvd_2[3U] ;
   u8 stream_csi[2U] ;
   u8 stream_target_csi[2U] ;
   s8 sig_evm ;
   u8 rsvd_3 ;
   unsigned char antsel_rx_keep_2 : 1 ;
   unsigned char sgi_en : 1 ;
   unsigned char rxsc : 2 ;
   unsigned char idle_long : 1 ;
   unsigned char r_ant_train_en : 1 ;
   unsigned char ant_sel_b : 1 ;
   unsigned char ant_sel : 1 ;
};
enum hrtimer_restart;
enum odm_cmninfo {
    ODM_CMNINFO_PLATFORM = 0,
    ODM_CMNINFO_ABILITY = 1,
    ODM_CMNINFO_INTERFACE = 2,
    ODM_CMNINFO_MP_TEST_CHIP = 3,
    ODM_CMNINFO_IC_TYPE = 4,
    ODM_CMNINFO_CUT_VER = 5,
    ODM_CMNINFO_FAB_VER = 6,
    ODM_CMNINFO_RF_TYPE = 7,
    ODM_CMNINFO_BOARD_TYPE = 8,
    ODM_CMNINFO_EXT_LNA = 9,
    ODM_CMNINFO_EXT_PA = 10,
    ODM_CMNINFO_EXT_TRSW = 11,
    ODM_CMNINFO_PATCH_ID = 12,
    ODM_CMNINFO_BINHCT_TEST = 13,
    ODM_CMNINFO_BWIFI_TEST = 14,
    ODM_CMNINFO_SMART_CONCURRENT = 15,
    ODM_CMNINFO_MAC_PHY_MODE = 16,
    ODM_CMNINFO_TX_UNI = 17,
    ODM_CMNINFO_RX_UNI = 18,
    ODM_CMNINFO_WM_MODE = 19,
    ODM_CMNINFO_BAND = 20,
    ODM_CMNINFO_SEC_CHNL_OFFSET = 21,
    ODM_CMNINFO_SEC_MODE = 22,
    ODM_CMNINFO_BW = 23,
    ODM_CMNINFO_CHNL = 24,
    ODM_CMNINFO_DMSP_GET_VALUE = 25,
    ODM_CMNINFO_BUDDY_ADAPTOR = 26,
    ODM_CMNINFO_DMSP_IS_MASTER = 27,
    ODM_CMNINFO_SCAN = 28,
    ODM_CMNINFO_POWER_SAVING = 29,
    ODM_CMNINFO_ONE_PATH_CCA = 30,
    ODM_CMNINFO_DRV_STOP = 31,
    ODM_CMNINFO_PNP_IN = 32,
    ODM_CMNINFO_INIT_ON = 33,
    ODM_CMNINFO_ANT_TEST = 34,
    ODM_CMNINFO_NET_CLOSED = 35,
    ODM_CMNINFO_MP_MODE = 36,
    ODM_CMNINFO_WIFI_DIRECT = 37,
    ODM_CMNINFO_WIFI_DISPLAY = 38,
    ODM_CMNINFO_LINK = 39,
    ODM_CMNINFO_RSSI_MIN = 40,
    ODM_CMNINFO_DBG_COMP = 41,
    ODM_CMNINFO_DBG_LEVEL = 42,
    ODM_CMNINFO_RA_THRESHOLD_HIGH = 43,
    ODM_CMNINFO_RA_THRESHOLD_LOW = 44,
    ODM_CMNINFO_RF_ANTENNA_TYPE = 45,
    ODM_CMNINFO_BT_DISABLED = 46,
    ODM_CMNINFO_BT_OPERATION = 47,
    ODM_CMNINFO_BT_DIG = 48,
    ODM_CMNINFO_BT_BUSY = 49,
    ODM_CMNINFO_BT_DISABLE_EDCA = 50,
    ODM_CMNINFO_STA_STATUS = 51,
    ODM_CMNINFO_PHY_STATUS = 52,
    ODM_CMNINFO_MAC_STATUS = 53,
    ODM_CMNINFO_MAX = 54
} ;
enum hrtimer_restart;
struct setpwrmode_parm {
   u8 Mode ;
   u8 SmartPS ;
   u8 AwakeInterval ;
   u8 bAllQueueUAPSD ;
   u8 BcnAntMode ;
};
struct joinbssrpt_parm {
   u8 OpMode ;
};
struct rsvdpage_loc {
   u8 LocProbeRsp ;
   u8 LocPsPoll ;
   u8 LocNullData ;
   u8 LocQosNull ;
   u8 LocBTQosNull ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct firmware {
   size_t size ;
   u8 const *data ;
   struct page **pages ;
   void *priv ;
};
struct tx_desc {
   __le32 txdw0 ;
   __le32 txdw1 ;
   __le32 txdw2 ;
   __le32 txdw3 ;
   __le32 txdw4 ;
   __le32 txdw5 ;
   __le32 txdw6 ;
   __le32 txdw7 ;
};
struct txpowerinfo {
   u8 CCKIndex[2U][12U] ;
   u8 HT40_1SIndex[2U][12U] ;
   u8 HT40_2SIndexDiff[2U][12U] ;
   u8 HT20IndexDiff[2U][12U] ;
   u8 OFDMIndexDiff[2U][12U] ;
   u8 HT40MaxOffset[2U][12U] ;
   u8 HT20MaxOffset[2U][12U] ;
   u8 TSSI_A[3U] ;
   u8 TSSI_B[3U] ;
   u8 TSSI_A_5G[3U] ;
   u8 TSSI_B_5G[3U] ;
};
struct txdesc_8723a {
   unsigned short pktlen ;
   unsigned char offset ;
   unsigned char bmc : 1 ;
   unsigned char htc : 1 ;
   unsigned char ls : 1 ;
   unsigned char fs : 1 ;
   unsigned char linip : 1 ;
   unsigned char noacm : 1 ;
   unsigned char gf : 1 ;
   unsigned char own : 1 ;
   unsigned char macid : 5 ;
   unsigned char agg_en : 1 ;
   unsigned char bk : 1 ;
   unsigned char rd_en : 1 ;
   unsigned char qsel : 5 ;
   unsigned char rd_nav_ext : 1 ;
   unsigned char lsig_txop_en : 1 ;
   unsigned char pifs : 1 ;
   unsigned char rate_id : 4 ;
   unsigned char navusehdr : 1 ;
   unsigned char en_desc_id : 1 ;
   unsigned char sectype : 2 ;
   unsigned char rsvd0424 : 2 ;
   unsigned char pkt_offset : 5 ;
   unsigned char rsvd0431 : 1 ;
   unsigned char rts_rc : 6 ;
   unsigned char data_rc : 6 ;
   unsigned char rsvd0812 : 2 ;
   unsigned char bar_rty_th : 2 ;
   unsigned char rsvd0816 : 1 ;
   unsigned char morefrag : 1 ;
   unsigned char raw : 1 ;
   unsigned char ccx : 1 ;
   unsigned char ampdu_density : 3 ;
   unsigned char bt_null : 1 ;
   unsigned char ant_sel_a : 1 ;
   unsigned char ant_sel_b : 1 ;
   unsigned char tx_ant_cck : 2 ;
   unsigned char tx_antl : 2 ;
   unsigned char tx_ant_ht : 2 ;
   unsigned char nextheadpage ;
   unsigned char tailpage ;
   unsigned short seq : 12 ;
   unsigned char cpu_handle : 1 ;
   unsigned char tag1 : 1 ;
   unsigned char trigger_int : 1 ;
   unsigned char hwseq_en : 1 ;
   unsigned char rtsrate : 5 ;
   unsigned char ap_dcfe : 1 ;
   unsigned char hwseq_sel : 2 ;
   unsigned char userate : 1 ;
   unsigned char disrtsfb : 1 ;
   unsigned char disdatafb : 1 ;
   unsigned char cts2self : 1 ;
   unsigned char rtsen : 1 ;
   unsigned char hw_rts_en : 1 ;
   unsigned char port_id : 1 ;
   unsigned char rsvd1615 : 3 ;
   unsigned char wait_dcts : 1 ;
   unsigned char cts2ap_en : 1 ;
   unsigned char data_sc : 2 ;
   unsigned char data_stbc : 2 ;
   unsigned char data_short : 1 ;
   unsigned char data_bw : 1 ;
   unsigned char rts_short : 1 ;
   unsigned char rts_bw : 1 ;
   unsigned char rts_sc : 2 ;
   unsigned char vcs_stbc : 2 ;
   unsigned char datarate : 6 ;
   unsigned char sgi : 1 ;
   unsigned char try_rate : 1 ;
   unsigned char data_ratefb_lmt : 5 ;
   unsigned char rts_ratefb_lmt : 4 ;
   unsigned char rty_lmt_en : 1 ;
   unsigned char data_rt_lmt : 6 ;
   unsigned char usb_txagg_num ;
   unsigned char txagg_a : 5 ;
   unsigned char txagg_b : 5 ;
   unsigned char use_max_len : 1 ;
   unsigned char max_agg_num : 5 ;
   unsigned char mcsg1_max_len : 4 ;
   unsigned char mcsg2_max_len : 4 ;
   unsigned char mcsg3_max_len : 4 ;
   unsigned char mcs7_sgi_max_len : 4 ;
   unsigned short checksum ;
   unsigned char mcsg4_max_len : 4 ;
   unsigned char mcsg5_max_len : 4 ;
   unsigned char mcsg6_max_len : 4 ;
   unsigned char mcs15_sgi_max_len : 4 ;
};
struct rt_8723a_firmware_hdr {
   u16 Signature ;
   u8 Category ;
   u8 Function ;
   u16 Version ;
   u8 Subversion ;
   u16 Rsvd1 ;
   u8 Month ;
   u8 Date ;
   u8 Hour ;
   u8 Minute ;
   u16 RamCodeSize ;
   u16 Rsvd2 ;
   u32 SvnIdx ;
   u32 Rsvd3 ;
   u32 Rsvd4 ;
   u32 Rsvd5 ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct txrpt_ccx_8723a {
   unsigned char tag1 : 1 ;
   unsigned char rsvd : 4 ;
   unsigned char int_bt : 1 ;
   unsigned char int_tri : 1 ;
   unsigned char int_ccx : 1 ;
   unsigned char mac_id : 5 ;
   unsigned char pkt_drop : 1 ;
   unsigned char pkt_ok : 1 ;
   unsigned char bmc : 1 ;
   unsigned char retry_cnt : 6 ;
   unsigned char lifetime_over : 1 ;
   unsigned char retry_over : 1 ;
   u8 ccx_qtime0 ;
   u8 ccx_qtime1 ;
   u8 final_data_rate ;
   unsigned char sw1 : 4 ;
   unsigned char qsel : 4 ;
   u8 sw0 ;
};
enum hrtimer_restart;
enum hrtimer_restart;
struct recv_stat {
   __le32 rxdw0 ;
   __le32 rxdw1 ;
   __le32 rxdw2 ;
   __le32 rxdw3 ;
   __le32 rxdw4 ;
   __le32 rxdw5 ;
};
struct phy_stat {
   unsigned int phydw0 ;
   unsigned int phydw1 ;
   unsigned int phydw2 ;
   unsigned int phydw3 ;
   unsigned int phydw4 ;
   unsigned int phydw5 ;
   unsigned int phydw6 ;
   unsigned int phydw7 ;
};
struct rxreport_8723a {
   unsigned short pktlen : 14 ;
   unsigned char crc32 : 1 ;
   unsigned char icverr : 1 ;
   unsigned char drvinfosize : 4 ;
   unsigned char security : 3 ;
   unsigned char qos : 1 ;
   unsigned char shift : 2 ;
   unsigned char physt : 1 ;
   unsigned char swdec : 1 ;
   unsigned char ls : 1 ;
   unsigned char fs : 1 ;
   unsigned char eor : 1 ;
   unsigned char own : 1 ;
   unsigned char macid : 5 ;
   unsigned char tid : 4 ;
   unsigned char hwrsvd : 4 ;
   unsigned char amsdu : 1 ;
   unsigned char paggr : 1 ;
   unsigned char faggr : 1 ;
   unsigned char a1fit : 4 ;
   unsigned char a2fit : 4 ;
   unsigned char pam : 1 ;
   unsigned char pwr : 1 ;
   unsigned char md : 1 ;
   unsigned char mf : 1 ;
   unsigned char type : 2 ;
   unsigned char mc : 1 ;
   unsigned char bc : 1 ;
   unsigned short seq : 12 ;
   unsigned char frag : 4 ;
   unsigned short nextpktlen : 14 ;
   unsigned char nextind : 1 ;
   unsigned char rsvd0831 : 1 ;
   unsigned char rxmcs : 6 ;
   unsigned char rxht : 1 ;
   unsigned char gf : 1 ;
   unsigned char splcp : 1 ;
   unsigned char bw : 1 ;
   unsigned char htc : 1 ;
   unsigned char eosp : 1 ;
   unsigned char bssidfit : 2 ;
   unsigned short rsvd1214 ;
   unsigned char unicastwake : 1 ;
   unsigned char magicwake : 1 ;
   unsigned char pattern0match : 1 ;
   unsigned char pattern1match : 1 ;
   unsigned char pattern2match : 1 ;
   unsigned char pattern3match : 1 ;
   unsigned char pattern4match : 1 ;
   unsigned char pattern5match : 1 ;
   unsigned char pattern6match : 1 ;
   unsigned char pattern7match : 1 ;
   unsigned char pattern8match : 1 ;
   unsigned char pattern9match : 1 ;
   unsigned char patternamatch : 1 ;
   unsigned char patternbmatch : 1 ;
   unsigned char patterncmatch : 1 ;
   unsigned int rsvd1613 : 19 ;
   u32 tsfl ;
   unsigned short bassn : 12 ;
   unsigned char bavld : 1 ;
   unsigned int rsvd2413 : 19 ;
};
struct recv_stat_cpu {
   u32 rxdw0 ;
   u32 rxdw1 ;
   u32 rxdw2 ;
   u32 rxdw3 ;
   u32 rxdw4 ;
   u32 rxdw5 ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct reportpwrstate_parm {
   unsigned char mode ;
   unsigned char state ;
   unsigned short rsvd ;
};
enum hrtimer_restart;
struct station_parameters;
struct station_info;
struct vif_params;
struct cfg80211_pmksa;
struct ieee80211_radiotap_header {
   u8 it_version ;
   u8 it_pad ;
   __le16 it_len ;
   __le32 it_present ;
};
struct nl80211_sta_flag_update {
   __u32 mask ;
   __u32 set ;
};
enum nl80211_mesh_power_mode {
    NL80211_MESH_POWER_UNKNOWN = 0,
    NL80211_MESH_POWER_ACTIVE = 1,
    NL80211_MESH_POWER_LIGHT_SLEEP = 2,
    NL80211_MESH_POWER_DEEP_SLEEP = 3,
    __NL80211_MESH_POWER_AFTER_LAST = 4,
    NL80211_MESH_POWER_MAX = 3
} ;
enum nl80211_ac {
    NL80211_AC_VO = 0,
    NL80211_AC_VI = 1,
    NL80211_AC_BE = 2,
    NL80211_AC_BK = 3,
    NL80211_NUM_ACS = 4
} ;
enum nl80211_txrate_gi {
    NL80211_TXRATE_DEFAULT_GI = 0,
    NL80211_TXRATE_FORCE_SGI = 1,
    NL80211_TXRATE_FORCE_LGI = 2
} ;
enum nl80211_tx_power_setting {
    NL80211_TX_POWER_AUTOMATIC = 0,
    NL80211_TX_POWER_LIMITED = 1,
    NL80211_TX_POWER_FIXED = 2
} ;
enum nl80211_coalesce_condition {
    NL80211_COALESCE_CONDITION_MATCH = 0,
    NL80211_COALESCE_CONDITION_NO_MATCH = 1
} ;
enum nl80211_hidden_ssid {
    NL80211_HIDDEN_SSID_NOT_IN_USE = 0,
    NL80211_HIDDEN_SSID_ZERO_LEN = 1,
    NL80211_HIDDEN_SSID_ZERO_CONTENTS = 2
} ;
enum nl80211_tdls_operation {
    NL80211_TDLS_DISCOVERY_REQ = 0,
    NL80211_TDLS_SETUP = 1,
    NL80211_TDLS_TEARDOWN = 2,
    NL80211_TDLS_ENABLE_LINK = 3,
    NL80211_TDLS_DISABLE_LINK = 4
} ;
enum nl80211_acl_policy {
    NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED = 0,
    NL80211_ACL_POLICY_DENY_UNLESS_LISTED = 1
} ;
enum nl80211_crit_proto_id {
    NL80211_CRIT_PROTO_UNSPEC = 0,
    NL80211_CRIT_PROTO_DHCP = 1,
    NL80211_CRIT_PROTO_EAPOL = 2,
    NL80211_CRIT_PROTO_APIPA = 3,
    NUM_NL80211_CRIT_PROTO = 4
} ;
struct vif_params {
   int use_4addr ;
   u8 macaddr[6U] ;
};
struct key_params {
   u8 const *key ;
   u8 const *seq ;
   int key_len ;
   int seq_len ;
   u32 cipher ;
};
struct survey_info {
   struct ieee80211_channel *channel ;
   u64 channel_time ;
   u64 channel_time_busy ;
   u64 channel_time_ext_busy ;
   u64 channel_time_rx ;
   u64 channel_time_tx ;
   u32 filled ;
   s8 noise ;
};
struct cfg80211_beacon_data {
   u8 const *head ;
   u8 const *tail ;
   u8 const *beacon_ies ;
   u8 const *proberesp_ies ;
   u8 const *assocresp_ies ;
   u8 const *probe_resp ;
   size_t head_len ;
   size_t tail_len ;
   size_t beacon_ies_len ;
   size_t proberesp_ies_len ;
   size_t assocresp_ies_len ;
   size_t probe_resp_len ;
};
struct cfg80211_acl_data {
   enum nl80211_acl_policy acl_policy ;
   int n_acl_entries ;
   struct mac_address mac_addrs[] ;
};
struct cfg80211_ap_settings {
   struct cfg80211_chan_def chandef ;
   struct cfg80211_beacon_data beacon ;
   int beacon_interval ;
   int dtim_period ;
   u8 const *ssid ;
   size_t ssid_len ;
   enum nl80211_hidden_ssid hidden_ssid ;
   struct cfg80211_crypto_settings crypto ;
   bool privacy ;
   enum nl80211_auth_type auth_type ;
   int inactivity_timeout ;
   u8 p2p_ctwindow ;
   bool p2p_opp_ps ;
   struct cfg80211_acl_data const *acl ;
};
struct cfg80211_csa_settings {
   struct cfg80211_chan_def chandef ;
   struct cfg80211_beacon_data beacon_csa ;
   u16 const *counter_offsets_beacon ;
   u16 const *counter_offsets_presp ;
   unsigned int n_counter_offsets_beacon ;
   unsigned int n_counter_offsets_presp ;
   struct cfg80211_beacon_data beacon_after ;
   bool radar_required ;
   bool block_tx ;
   u8 count ;
};
struct station_parameters {
   u8 const *supported_rates ;
   struct net_device *vlan ;
   u32 sta_flags_mask ;
   u32 sta_flags_set ;
   u32 sta_modify_mask ;
   int listen_interval ;
   u16 aid ;
   u8 supported_rates_len ;
   u8 plink_action ;
   u8 plink_state ;
   struct ieee80211_ht_cap const *ht_capa ;
   struct ieee80211_vht_cap const *vht_capa ;
   u8 uapsd_queues ;
   u8 max_sp ;
   enum nl80211_mesh_power_mode local_pm ;
   u16 capability ;
   u8 const *ext_capab ;
   u8 ext_capab_len ;
   u8 const *supported_channels ;
   u8 supported_channels_len ;
   u8 const *supported_oper_classes ;
   u8 supported_oper_classes_len ;
   u8 opmode_notif ;
   bool opmode_notif_used ;
};
struct rate_info {
   u8 flags ;
   u8 mcs ;
   u16 legacy ;
   u8 nss ;
};
struct sta_bss_parameters {
   u8 flags ;
   u8 dtim_period ;
   u16 beacon_interval ;
};
struct station_info {
   u32 filled ;
   u32 connected_time ;
   u32 inactive_time ;
   u64 rx_bytes ;
   u64 tx_bytes ;
   u16 llid ;
   u16 plid ;
   u8 plink_state ;
   s8 signal ;
   s8 signal_avg ;
   u8 chains ;
   s8 chain_signal[4U] ;
   s8 chain_signal_avg[4U] ;
   struct rate_info txrate ;
   struct rate_info rxrate ;
   u32 rx_packets ;
   u32 tx_packets ;
   u32 tx_retries ;
   u32 tx_failed ;
   u32 rx_dropped_misc ;
   struct sta_bss_parameters bss_param ;
   struct nl80211_sta_flag_update sta_flags ;
   int generation ;
   u8 const *assoc_req_ies ;
   size_t assoc_req_ies_len ;
   u32 beacon_loss_count ;
   s64 t_offset ;
   enum nl80211_mesh_power_mode local_pm ;
   enum nl80211_mesh_power_mode peer_pm ;
   enum nl80211_mesh_power_mode nonpeer_pm ;
   u32 expected_throughput ;
};
struct mpath_info {
   u32 filled ;
   u32 frame_qlen ;
   u32 sn ;
   u32 metric ;
   u32 exptime ;
   u32 discovery_timeout ;
   u8 discovery_retries ;
   u8 flags ;
   int generation ;
};
struct bss_parameters {
   int use_cts_prot ;
   int use_short_preamble ;
   int use_short_slot_time ;
   u8 const *basic_rates ;
   u8 basic_rates_len ;
   int ap_isolate ;
   int ht_opmode ;
   s8 p2p_ctwindow ;
   s8 p2p_opp_ps ;
};
struct mesh_config {
   u16 dot11MeshRetryTimeout ;
   u16 dot11MeshConfirmTimeout ;
   u16 dot11MeshHoldingTimeout ;
   u16 dot11MeshMaxPeerLinks ;
   u8 dot11MeshMaxRetries ;
   u8 dot11MeshTTL ;
   u8 element_ttl ;
   bool auto_open_plinks ;
   u32 dot11MeshNbrOffsetMaxNeighbor ;
   u8 dot11MeshHWMPmaxPREQretries ;
   u32 path_refresh_time ;
   u16 min_discovery_timeout ;
   u32 dot11MeshHWMPactivePathTimeout ;
   u16 dot11MeshHWMPpreqMinInterval ;
   u16 dot11MeshHWMPperrMinInterval ;
   u16 dot11MeshHWMPnetDiameterTraversalTime ;
   u8 dot11MeshHWMPRootMode ;
   u16 dot11MeshHWMPRannInterval ;
   bool dot11MeshGateAnnouncementProtocol ;
   bool dot11MeshForwarding ;
   s32 rssi_threshold ;
   u16 ht_opmode ;
   u32 dot11MeshHWMPactivePathToRootTimeout ;
   u16 dot11MeshHWMProotInterval ;
   u16 dot11MeshHWMPconfirmationInterval ;
   enum nl80211_mesh_power_mode power_mode ;
   u16 dot11MeshAwakeWindowDuration ;
   u32 plink_timeout ;
};
struct mesh_setup {
   struct cfg80211_chan_def chandef ;
   u8 const *mesh_id ;
   u8 mesh_id_len ;
   u8 sync_method ;
   u8 path_sel_proto ;
   u8 path_metric ;
   u8 auth_id ;
   u8 const *ie ;
   u8 ie_len ;
   bool is_authenticated ;
   bool is_secure ;
   bool user_mpm ;
   u8 dtim_period ;
   u16 beacon_interval ;
   int mcast_rate[3U] ;
   u32 basic_rates ;
};
struct ieee80211_txq_params {
   enum nl80211_ac ac ;
   u16 txop ;
   u16 cwmin ;
   u16 cwmax ;
   u8 aifs ;
};
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct ieee80211_channel *channels[0U] ;
};
struct cfg80211_bss_ies {
   u64 tsf ;
   struct callback_head callback_head ;
   int len ;
   u8 data[] ;
};
struct cfg80211_bss {
   struct ieee80211_channel *channel ;
   enum nl80211_bss_scan_width scan_width ;
   struct cfg80211_bss_ies const *ies ;
   struct cfg80211_bss_ies const *beacon_ies ;
   struct cfg80211_bss_ies const *proberesp_ies ;
   struct cfg80211_bss *hidden_beacon_bss ;
   s32 signal ;
   u16 beacon_interval ;
   u16 capability ;
   u8 bssid[6U] ;
   u8 priv[0U] ;
};
struct cfg80211_auth_request {
   struct cfg80211_bss *bss ;
   u8 const *ie ;
   size_t ie_len ;
   enum nl80211_auth_type auth_type ;
   u8 const *key ;
   u8 key_len ;
   u8 key_idx ;
   u8 const *sae_data ;
   size_t sae_data_len ;
};
struct cfg80211_assoc_request {
   struct cfg80211_bss *bss ;
   u8 const *ie ;
   u8 const *prev_bssid ;
   size_t ie_len ;
   struct cfg80211_crypto_settings crypto ;
   bool use_mfp ;
   u32 flags ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
struct cfg80211_deauth_request {
   u8 const *bssid ;
   u8 const *ie ;
   size_t ie_len ;
   u16 reason_code ;
   bool local_state_change ;
};
struct cfg80211_disassoc_request {
   struct cfg80211_bss *bss ;
   u8 const *ie ;
   size_t ie_len ;
   u16 reason_code ;
   bool local_state_change ;
};
struct __anonstruct_control_289 {
   u32 legacy ;
   u8 ht_mcs[10U] ;
   u16 vht_mcs[8U] ;
   enum nl80211_txrate_gi gi ;
};
struct cfg80211_bitrate_mask {
   struct __anonstruct_control_289 control[3U] ;
};
struct cfg80211_pmksa {
   u8 const *bssid ;
   u8 const *pmkid ;
};
struct cfg80211_coalesce_rules {
   int delay ;
   enum nl80211_coalesce_condition condition ;
   struct cfg80211_pkt_pattern *patterns ;
   int n_patterns ;
};
struct cfg80211_coalesce {
   struct cfg80211_coalesce_rules *rules ;
   int n_rules ;
};
struct cfg80211_gtk_rekey_data {
   u8 kek[16U] ;
   u8 kck[16U] ;
   u8 replay_ctr[8U] ;
};
struct cfg80211_update_ft_ies_params {
   u16 md ;
   u8 const *ie ;
   size_t ie_len ;
};
struct cfg80211_mgmt_tx_params {
   struct ieee80211_channel *chan ;
   bool offchan ;
   unsigned int wait ;
   u8 const *buf ;
   size_t len ;
   bool no_cck ;
   bool dont_wait_for_ack ;
   int n_csa_offsets ;
   u16 const *csa_offsets ;
};
struct cfg80211_dscp_exception {
   u8 dscp ;
   u8 up ;
};
struct cfg80211_dscp_range {
   u8 low ;
   u8 high ;
};
struct cfg80211_qos_map {
   u8 num_des ;
   struct cfg80211_dscp_exception dscp_exception[21U] ;
   struct cfg80211_dscp_range up[8U] ;
};
struct cfg80211_ops {
   int (*suspend)(struct wiphy * , struct cfg80211_wowlan * ) ;
   int (*resume)(struct wiphy * ) ;
   void (*set_wakeup)(struct wiphy * , bool ) ;
   struct wireless_dev *(*add_virtual_intf)(struct wiphy * , char const * , enum nl80211_iftype ,
                                            u32 * , struct vif_params * ) ;
   int (*del_virtual_intf)(struct wiphy * , struct wireless_dev * ) ;
   int (*change_virtual_intf)(struct wiphy * , struct net_device * , enum nl80211_iftype ,
                              u32 * , struct vif_params * ) ;
   int (*add_key)(struct wiphy * , struct net_device * , u8 , bool , u8 const * ,
                  struct key_params * ) ;
   int (*get_key)(struct wiphy * , struct net_device * , u8 , bool , u8 const * ,
                  void * , void (*)(void * , struct key_params * ) ) ;
   int (*del_key)(struct wiphy * , struct net_device * , u8 , bool , u8 const * ) ;
   int (*set_default_key)(struct wiphy * , struct net_device * , u8 , bool , bool ) ;
   int (*set_default_mgmt_key)(struct wiphy * , struct net_device * , u8 ) ;
   int (*start_ap)(struct wiphy * , struct net_device * , struct cfg80211_ap_settings * ) ;
   int (*change_beacon)(struct wiphy * , struct net_device * , struct cfg80211_beacon_data * ) ;
   int (*stop_ap)(struct wiphy * , struct net_device * ) ;
   int (*add_station)(struct wiphy * , struct net_device * , u8 const * , struct station_parameters * ) ;
   int (*del_station)(struct wiphy * , struct net_device * , u8 const * ) ;
   int (*change_station)(struct wiphy * , struct net_device * , u8 const * , struct station_parameters * ) ;
   int (*get_station)(struct wiphy * , struct net_device * , u8 const * , struct station_info * ) ;
   int (*dump_station)(struct wiphy * , struct net_device * , int , u8 * , struct station_info * ) ;
   int (*add_mpath)(struct wiphy * , struct net_device * , u8 const * , u8 const * ) ;
   int (*del_mpath)(struct wiphy * , struct net_device * , u8 const * ) ;
   int (*change_mpath)(struct wiphy * , struct net_device * , u8 const * , u8 const * ) ;
   int (*get_mpath)(struct wiphy * , struct net_device * , u8 * , u8 * , struct mpath_info * ) ;
   int (*dump_mpath)(struct wiphy * , struct net_device * , int , u8 * , u8 * , struct mpath_info * ) ;
   int (*get_mesh_config)(struct wiphy * , struct net_device * , struct mesh_config * ) ;
   int (*update_mesh_config)(struct wiphy * , struct net_device * , u32 , struct mesh_config const * ) ;
   int (*join_mesh)(struct wiphy * , struct net_device * , struct mesh_config const * ,
                    struct mesh_setup const * ) ;
   int (*leave_mesh)(struct wiphy * , struct net_device * ) ;
   int (*change_bss)(struct wiphy * , struct net_device * , struct bss_parameters * ) ;
   int (*set_txq_params)(struct wiphy * , struct net_device * , struct ieee80211_txq_params * ) ;
   int (*libertas_set_mesh_channel)(struct wiphy * , struct net_device * , struct ieee80211_channel * ) ;
   int (*set_monitor_channel)(struct wiphy * , struct cfg80211_chan_def * ) ;
   int (*scan)(struct wiphy * , struct cfg80211_scan_request * ) ;
   int (*auth)(struct wiphy * , struct net_device * , struct cfg80211_auth_request * ) ;
   int (*assoc)(struct wiphy * , struct net_device * , struct cfg80211_assoc_request * ) ;
   int (*deauth)(struct wiphy * , struct net_device * , struct cfg80211_deauth_request * ) ;
   int (*disassoc)(struct wiphy * , struct net_device * , struct cfg80211_disassoc_request * ) ;
   int (*connect)(struct wiphy * , struct net_device * , struct cfg80211_connect_params * ) ;
   int (*disconnect)(struct wiphy * , struct net_device * , u16 ) ;
   int (*join_ibss)(struct wiphy * , struct net_device * , struct cfg80211_ibss_params * ) ;
   int (*leave_ibss)(struct wiphy * , struct net_device * ) ;
   int (*set_mcast_rate)(struct wiphy * , struct net_device * , int * ) ;
   int (*set_wiphy_params)(struct wiphy * , u32 ) ;
   int (*set_tx_power)(struct wiphy * , struct wireless_dev * , enum nl80211_tx_power_setting ,
                       int ) ;
   int (*get_tx_power)(struct wiphy * , struct wireless_dev * , int * ) ;
   int (*set_wds_peer)(struct wiphy * , struct net_device * , u8 const * ) ;
   void (*rfkill_poll)(struct wiphy * ) ;
   int (*testmode_cmd)(struct wiphy * , struct wireless_dev * , void * , int ) ;
   int (*testmode_dump)(struct wiphy * , struct sk_buff * , struct netlink_callback * ,
                        void * , int ) ;
   int (*set_bitrate_mask)(struct wiphy * , struct net_device * , u8 const * , struct cfg80211_bitrate_mask const * ) ;
   int (*dump_survey)(struct wiphy * , struct net_device * , int , struct survey_info * ) ;
   int (*set_pmksa)(struct wiphy * , struct net_device * , struct cfg80211_pmksa * ) ;
   int (*del_pmksa)(struct wiphy * , struct net_device * , struct cfg80211_pmksa * ) ;
   int (*flush_pmksa)(struct wiphy * , struct net_device * ) ;
   int (*remain_on_channel)(struct wiphy * , struct wireless_dev * , struct ieee80211_channel * ,
                            unsigned int , u64 * ) ;
   int (*cancel_remain_on_channel)(struct wiphy * , struct wireless_dev * , u64 ) ;
   int (*mgmt_tx)(struct wiphy * , struct wireless_dev * , struct cfg80211_mgmt_tx_params * ,
                  u64 * ) ;
   int (*mgmt_tx_cancel_wait)(struct wiphy * , struct wireless_dev * , u64 ) ;
   int (*set_power_mgmt)(struct wiphy * , struct net_device * , bool , int ) ;
   int (*set_cqm_rssi_config)(struct wiphy * , struct net_device * , s32 , u32 ) ;
   int (*set_cqm_txe_config)(struct wiphy * , struct net_device * , u32 , u32 ,
                             u32 ) ;
   void (*mgmt_frame_register)(struct wiphy * , struct wireless_dev * , u16 , bool ) ;
   int (*set_antenna)(struct wiphy * , u32 , u32 ) ;
   int (*get_antenna)(struct wiphy * , u32 * , u32 * ) ;
   int (*set_ringparam)(struct wiphy * , u32 , u32 ) ;
   void (*get_ringparam)(struct wiphy * , u32 * , u32 * , u32 * , u32 * ) ;
   int (*sched_scan_start)(struct wiphy * , struct net_device * , struct cfg80211_sched_scan_request * ) ;
   int (*sched_scan_stop)(struct wiphy * , struct net_device * ) ;
   int (*set_rekey_data)(struct wiphy * , struct net_device * , struct cfg80211_gtk_rekey_data * ) ;
   int (*tdls_mgmt)(struct wiphy * , struct net_device * , u8 const * , u8 , u8 ,
                    u16 , u32 , u8 const * , size_t ) ;
   int (*tdls_oper)(struct wiphy * , struct net_device * , u8 const * , enum nl80211_tdls_operation ) ;
   int (*probe_client)(struct wiphy * , struct net_device * , u8 const * , u64 * ) ;
   int (*set_noack_map)(struct wiphy * , struct net_device * , u16 ) ;
   int (*get_et_sset_count)(struct wiphy * , struct net_device * , int ) ;
   void (*get_et_stats)(struct wiphy * , struct net_device * , struct ethtool_stats * ,
                        u64 * ) ;
   void (*get_et_strings)(struct wiphy * , struct net_device * , u32 , u8 * ) ;
   int (*get_channel)(struct wiphy * , struct wireless_dev * , struct cfg80211_chan_def * ) ;
   int (*start_p2p_device)(struct wiphy * , struct wireless_dev * ) ;
   void (*stop_p2p_device)(struct wiphy * , struct wireless_dev * ) ;
   int (*set_mac_acl)(struct wiphy * , struct net_device * , struct cfg80211_acl_data const * ) ;
   int (*start_radar_detection)(struct wiphy * , struct net_device * , struct cfg80211_chan_def * ,
                                u32 ) ;
   int (*update_ft_ies)(struct wiphy * , struct net_device * , struct cfg80211_update_ft_ies_params * ) ;
   int (*crit_proto_start)(struct wiphy * , struct wireless_dev * , enum nl80211_crit_proto_id ,
                           u16 ) ;
   void (*crit_proto_stop)(struct wiphy * , struct wireless_dev * ) ;
   int (*set_coalesce)(struct wiphy * , struct cfg80211_coalesce * ) ;
   int (*channel_switch)(struct wiphy * , struct net_device * , struct cfg80211_csa_settings * ) ;
   int (*set_qos_map)(struct wiphy * , struct net_device * , struct cfg80211_qos_map * ) ;
   int (*set_ap_chanwidth)(struct wiphy * , struct net_device * , struct cfg80211_chan_def * ) ;
};
struct __anonstruct_wpa_param_294 {
   u8 name ;
   u32 value ;
};
struct __anonstruct_wpa_ie_295 {
   u32 len ;
   u8 reserved[32U] ;
   u8 data[0U] ;
};
struct __anonstruct_mlme_296 {
   int command ;
   int reason_code ;
};
struct __anonstruct_crypt_297 {
   u8 alg[16U] ;
   u8 set_tx ;
   u32 err ;
   u8 idx ;
   u8 seq[8U] ;
   u16 key_len ;
   u8 key[0U] ;
};
struct __anonstruct_add_sta_298 {
   u16 aid ;
   u16 capability ;
   int flags ;
   u8 tx_supp_rates[16U] ;
   struct ieee80211_ht_cap ht_cap ;
};
struct __anonstruct_bcn_ie_299 {
   u8 reserved[2U] ;
   u8 buf[0U] ;
};
union __anonunion_u_293 {
   struct __anonstruct_wpa_param_294 wpa_param ;
   struct __anonstruct_wpa_ie_295 wpa_ie ;
   struct __anonstruct_mlme_296 mlme ;
   struct __anonstruct_crypt_297 crypt ;
   struct __anonstruct_add_sta_298 add_sta ;
   struct __anonstruct_bcn_ie_299 bcn_ie ;
};
struct ieee_param {
   u32 cmd ;
   u8 sta_addr[6U] ;
   union __anonunion_u_293 u ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
struct iw_michaelmicfailure {
   __u32 flags ;
   struct sockaddr src_addr ;
   __u8 tsc[8U] ;
};
union iwreq_data {
   char name[16U] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
enum nl80211_key_type {
    NL80211_KEYTYPE_GROUP = 0,
    NL80211_KEYTYPE_PAIRWISE = 1,
    NL80211_KEYTYPE_PEERKEY = 2,
    NUM_NL80211_KEYTYPES = 3
} ;
enum hrtimer_restart;
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info ;
};
struct usb_driver;
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
struct usb_driver {
   char const *name ;
   int (*probe)(struct usb_interface * , struct usb_device_id const * ) ;
   void (*disconnect)(struct usb_interface * ) ;
   int (*unlocked_ioctl)(struct usb_interface * , unsigned int , void * ) ;
   int (*suspend)(struct usb_interface * , pm_message_t ) ;
   int (*resume)(struct usb_interface * ) ;
   int (*reset_resume)(struct usb_interface * ) ;
   int (*pre_reset)(struct usb_interface * ) ;
   int (*post_reset)(struct usb_interface * ) ;
   struct usb_device_id const *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned char no_dynamic_id : 1 ;
   unsigned char supports_autosuspend : 1 ;
   unsigned char disable_hub_initiated_lpm : 1 ;
   unsigned char soft_unbind : 1 ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum rt_media_status;
enum rt_media_status;
enum rt_status {
    RT_STATUS_SUCCESS = 0,
    RT_STATUS_FAILURE = 1,
    RT_STATUS_PENDING = 2,
    RT_STATUS_RESOURCE = 3,
    RT_STATUS_INVALID_CONTEXT = 4,
    RT_STATUS_INVALID_PARAMETER = 5,
    RT_STATUS_NOT_SUPPORT = 6,
    RT_STATUS_OS_API_FAILED = 7
} ;
struct chnl_txpower_triple {
   u8 FirstChnl ;
   u8 NumChnls ;
   s8 MaxTxPowerInDbm ;
};
enum hci_state_with_cmd {
    STATE_CMD_CREATE_PHY_LINK = 0,
    STATE_CMD_ACCEPT_PHY_LINK = 1,
    STATE_CMD_DISCONNECT_PHY_LINK = 2,
    STATE_CMD_CONNECT_ACCEPT_TIMEOUT = 3,
    STATE_CMD_MAC_START_COMPLETE = 4,
    STATE_CMD_MAC_START_FAILED = 5,
    STATE_CMD_MAC_CONNECT_COMPLETE = 6,
    STATE_CMD_MAC_CONNECT_FAILED = 7,
    STATE_CMD_MAC_DISCONNECT_INDICATE = 8,
    STATE_CMD_MAC_CONNECT_CANCEL_INDICATE = 9,
    STATE_CMD_4WAY_FAILED = 10,
    STATE_CMD_4WAY_SUCCESSED = 11,
    STATE_CMD_ENTER_STATE = 12,
    STATE_CMD_NO_SUCH_CMD = 13
} ;
enum bt_traffic_mode_profile {
    BT_PROFILE_NONE = 0,
    BT_PROFILE_A2DP = 1,
    BT_PROFILE_PAN = 2,
    BT_PROFILE_HID = 3,
    BT_PROFILE_SCO = 4
} ;
struct amp_assoc_structure {
   u8 TypeID ;
   u16 Length ;
   u8 Data[1U] ;
};
struct amp_pref_chnl_regulatory {
   u8 reXId ;
   u8 regulatoryClass ;
   u8 coverageClass ;
};
struct packet_irp_hcicmd_data {
   unsigned short OCF : 10 ;
   unsigned char OGF : 6 ;
   u8 Length ;
   u8 Data[20U] ;
};
struct packet_irp_hcievent_data {
   u8 EventCode ;
   u8 Length ;
   u8 Data[20U] ;
};
struct common_triple {
   u8 byte_1st ;
   u8 byte_2nd ;
   u8 byte_3rd ;
};
enum bt_state_1ant {
    BT_INFO_STATE_DISABLED = 0,
    BT_INFO_STATE_NO_CONNECTION = 1,
    BT_INFO_STATE_CONNECT_IDLE = 2,
    BT_INFO_STATE_INQ_OR_PAG = 3,
    BT_INFO_STATE_ACL_ONLY_BUSY = 4,
    BT_INFO_STATE_SCO_ONLY_BUSY = 5,
    BT_INFO_STATE_ACL_SCO_BUSY = 6,
    BT_INFO_STATE_ACL_INQ_OR_PAG = 7,
    BT_INFO_STATE_MAX = 8
} ;
enum hrtimer_restart;
typedef struct page___0 *pgtable_t___0;
struct __anonstruct____missing_field_name_211 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
union __anonunion____missing_field_name_210 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_211 __annonCompField39 ;
   int units ;
};
struct __anonstruct____missing_field_name_209 {
   union __anonunion____missing_field_name_210 __annonCompField40 ;
   atomic_t _count ;
};
union __anonunion____missing_field_name_208 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_209 __annonCompField41 ;
   unsigned int active ;
};
struct __anonstruct____missing_field_name_206 {
   union __anonunion_ldv_14166_140 __annonCompField38 ;
   union __anonunion____missing_field_name_208 __annonCompField42 ;
};
struct __anonstruct____missing_field_name_213 {
   struct page___0 *next ;
   int pages ;
   int pobjects ;
};
union __anonunion____missing_field_name_212 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_213 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t___0 pmd_huge_pte ;
};
union __anonunion____missing_field_name_214 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache___0 *slab_cache ;
   struct page___0 *first_page ;
};
struct page___0 {
   unsigned long flags ;
   union __anonunion_ldv_14160_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_206 __annonCompField43 ;
   union __anonunion____missing_field_name_212 __annonCompField45 ;
   union __anonunion____missing_field_name_214 __annonCompField46 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) * (sizeof(unsigned long )) ))) ;
enum kobj_ns_type;
struct attribute___0 {
   char const *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct sysfs_ops___0 {
   ssize_t (*show)(struct kobject___0 * , struct attribute___0 * , char * ) ;
   ssize_t (*store)(struct kobject___0 * , struct attribute___0 * , char const * ,
                    size_t ) ;
};
struct kobject___0 {
   char const *name ;
   struct list_head entry ;
   struct kobject___0 *parent ;
   struct kset *kset ;
   struct kobj_type___0 *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
struct kobj_type___0 {
   void (*release)(struct kobject___0 *kobj ) ;
   struct sysfs_ops___0 const *sysfs_ops ;
   struct attribute___0 **default_attrs ;
   struct kobj_ns_type_operations const *(*child_ns_type)(struct kobject___0 *kobj ) ;
   void const *(*namespace)(struct kobject___0 *kobj ) ;
};
struct kmem_cache_cpu___0 {
   void **freelist ;
   unsigned long tid ;
   struct page___0 *page ;
   struct page___0 *partial ;
   unsigned int stat[26] ;
};
struct kmem_cache___0 {
   struct kmem_cache_cpu___0 *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const *name ;
   struct list_head list ;
   struct kobject___0 kobj ;
   struct memcg_cache_params___0 *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
struct __anonstruct____missing_field_name_227 {
   struct callback_head callback_head ;
   struct kmem_cache___0 *memcg_caches[0] ;
};
struct __anonstruct____missing_field_name_228 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache___0 *root_cache ;
   atomic_t nr_pages ;
};
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField50 ;
   struct __anonstruct____missing_field_name_228 __annonCompField51 ;
};
struct memcg_cache_params___0 {
   bool is_root_cache ;
   union __anonunion____missing_field_name_226 __annonCompField52 ;
};
long ldv__builtin_expect(long exp , long c ) ;
void ldv_spin_lock(void) ;
void ldv_spin_unlock(void) ;
extern int printk(char const * , ...) ;
__inline static void INIT_LIST_HEAD(struct list_head *list )
{
  {
  list->next = list;
  list->prev = list;
  return;
}
}
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
__inline static void list_add_tail(struct list_head *new , struct list_head *head )
{
  {
  __list_add(new, head->prev, head);
  return;
}
}
extern void *memcpy(void * , void const * , size_t ) ;
extern void *memset(void * , int , size_t ) ;
extern void lockdep_init_map(struct lockdep_map * , char const * , struct lock_class_key * ,
                             int ) ;
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
__inline static void ldv_spin_lock_bh_2(spinlock_t *lock )
{
  {
  _raw_spin_lock_bh(& lock->ldv_6347.rlock);
  return;
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void ldv_spin_unlock_bh_6(spinlock_t *lock )
{
  {
  _raw_spin_unlock_bh(& lock->ldv_6347.rlock);
  return;
}
}
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
extern unsigned long volatile jiffies ;
extern unsigned long msecs_to_jiffies(unsigned int const ) ;
extern int mod_timer(struct timer_list * , unsigned long ) ;
int ldv_mod_timer_33(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_34(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_35(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_36(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_37(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_38(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
extern int del_timer_sync(struct timer_list * ) ;
int ldv_del_timer_sync_39(struct timer_list *ldv_func_arg1 ) ;
extern void __init_work(struct work_struct * , int ) ;
extern struct workqueue_struct *__alloc_workqueue_key(char const * , unsigned int ,
                                                      int , struct lock_class_key * ,
                                                      char const * , ...) ;
extern bool queue_work_on(int , struct workqueue_struct * , struct work_struct * ) ;
extern bool cancel_work_sync(struct work_struct * ) ;
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work )
{
  bool tmp ;
  {
  tmp = queue_work_on(8192, wq, work);
  return (tmp);
}
}
extern void kfree(void const * ) ;
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t ) ;
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
void ldv_check_alloc_flags(gfp_t flags ) ;
extern void *malloc(size_t size ) ;
extern void *calloc(size_t nmemb , size_t size ) ;
extern int __VERIFIER_nondet_int(void) ;
extern unsigned long __VERIFIER_nondet_ulong(void) ;
extern void *__VERIFIER_nondet_pointer(void) ;
extern void __VERIFIER_assume(int expression ) ;
void *ldv_malloc(size_t size )
{
  void *p ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = malloc(size);
    p = tmp;
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
    return (p);
  }
}
}
void *ldv_zalloc(size_t size )
{
  void *p ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = calloc(1UL, size);
    p = tmp;
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
    return (p);
  }
}
}
int ldv_undef_int(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  return (tmp);
}
}
void *ldv_undef_ptr(void)
{
  void *tmp ;
  {
  tmp = __VERIFIER_nondet_pointer();
  return (tmp);
}
}
unsigned long ldv_undef_ulong(void)
{
  unsigned long tmp ;
  {
  tmp = __VERIFIER_nondet_ulong();
  return (tmp);
}
}
__inline static void ldv_error(void)
{
  {
  ERROR: ;
  __VERIFIER_error();
}
}
long ldv__builtin_expect(long exp , long c )
{
  {
  return (exp);
}
}
void ldv__builtin_trap(void)
{
  {
  ldv_error();
  return;
}
}
int LDV_IN_INTERRUPT = 1;
void disable_suitable_timer_6(struct timer_list *timer ) ;
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) ;
extern void msleep(unsigned int ) ;
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t ) ;
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
extern struct sk_buff *skb_copy(struct sk_buff const * , gfp_t ) ;
struct sk_buff *ldv_skb_copy_26(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
extern int pskb_expand_head(struct sk_buff * , int , int , gfp_t ) ;
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int , gfp_t ) ;
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
__inline static void ether_addr_copy(u8 *dst , u8 const *src )
{
  {
  *((u32 *)dst) = *((u32 const *)src);
  *((u16 *)dst + 4U) = *((u16 const *)src + 4U);
  return;
}
}
__inline static uint get_wlan_bssid_ex_sz(struct wlan_bssid_ex *bss )
{
  {
  return (bss->IELength + 95U);
}
}
void rtw_evt_work(struct work_struct *work ) ;
int rtw_enqueue_cmd23a(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) ;
void rtw_free_cmd_obj23a(struct cmd_obj *pcmd ) ;
int rtw_init_cmd_priv23a(struct cmd_priv *pcmdpriv ) ;
u32 rtw_init_evt_priv23a(struct evt_priv *pevtpriv ) ;
void rtw_free_evt_priv23a(struct evt_priv *pevtpriv ) ;
void rtw_cmd_clr_isr23a(struct cmd_priv *pcmdpriv ) ;
int rtw_sitesurvey_cmd23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ,
                          int ssid_num , struct rtw_ieee80211_channel *ch , int ch_num ) ;
int rtw_createbss_cmd23a(struct rtw_adapter *padapter ) ;
int rtw_setstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 unicast_key ) ;
int rtw_clearstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 entry , u8 enqueue ) ;
int rtw_joinbss_cmd23a(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) ;
int rtw_disassoc_cmd23a(struct rtw_adapter *padapter , u32 deauth_timeout_ms , bool enqueue ) ;
int rtw_setopmode_cmd23a(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) ;
int rtw_addbareq_cmd23a(struct rtw_adapter *padapter , u8 tid , u8 *addr ) ;
int rtw_dynamic_chk_wk_cmd23a(struct rtw_adapter *padapter ) ;
int rtw_lps_ctrl_wk_cmd23a(struct rtw_adapter *padapter , u8 lps_ctrl_type , u8 enqueue ) ;
int rtw_ps_cmd23a(struct rtw_adapter *padapter ) ;
int rtw_chk_hi_queue_cmd23a(struct rtw_adapter *padapter ) ;
int rtw_set_ch_cmd23a(struct rtw_adapter *padapter , u8 ch , u8 bw , u8 ch_offset ,
                      u8 enqueue ) ;
int rtw_c2h_wk_cmd23a(struct rtw_adapter *padapter , u8 *c2h_evt ) ;
int rtw_drvextra_cmd_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
void rtw_survey_cmd_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_disassoc_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_joinbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_createbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_getbbrfreg_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_setstaKey_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
void rtw_setassocsta_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
struct _cmd_callback rtw_cmd_callback[63U] ;
void c2h_evt_clear23a(struct rtw_adapter *adapter ) ;
s32 c2h_evt_read23a(struct rtw_adapter *adapter , u8 *buf ) ;
bool rtl8723a_chk_hi_queue_empty(struct rtw_adapter *padapter ) ;
void rtw_ps_processor23a(struct rtw_adapter *padapter ) ;
void LPS_Enter23a(struct rtw_adapter *padapter ) ;
void LPS_Leave23a(struct rtw_adapter *padapter ) ;
struct sta_info *rtw_alloc_stainfo23a(struct sta_priv *pstapriv , u8 *hwaddr , gfp_t gfp ) ;
struct sta_info *rtw_get_stainfo23a(struct sta_priv *pstapriv , u8 const *hwaddr ) ;
struct sta_info *rtw_get_bcmc_stainfo23a(struct rtw_adapter *padapter ) ;
void rtw_free_network_queue23a(struct rtw_adapter *padapter ) ;
__inline static bool check_fwstate(struct mlme_priv *pmlmepriv , int state )
{
  {
  if ((pmlmepriv->fw_state & state) != 0) {
    return (1);
  } else {
  }
  return (0);
}
}
__inline static void set_fwstate(struct mlme_priv *pmlmepriv , int state )
{
  {
  pmlmepriv->fw_state = pmlmepriv->fw_state | state;
  if (state == 2048) {
    pmlmepriv->bScanInProcess = 1U;
  } else {
  }
  return;
}
}
__inline static void _clr_fwstate_(struct mlme_priv *pmlmepriv , int state )
{
  {
  pmlmepriv->fw_state = pmlmepriv->fw_state & ~ state;
  if (state == 2048) {
    pmlmepriv->bScanInProcess = 0U;
  } else {
  }
  return;
}
}
__inline static void clr_fwstate(struct mlme_priv *pmlmepriv , int state )
{
  bool tmp ;
  {
  spin_lock_bh(& pmlmepriv->lock);
  tmp = check_fwstate(pmlmepriv, state);
  if ((int )tmp) {
    pmlmepriv->fw_state = pmlmepriv->fw_state ^ state;
  } else {
  }
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
struct wlan_network *rtw_get_oldest_wlan_network23a(struct rtw_queue *scanned_queue ) ;
void rtw_indicate_connect23a(struct rtw_adapter *padapter ) ;
int rtw_restruct_sec_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len ) ;
int rtw_restruct_wmm_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len , uint initial_out_len ) ;
struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv , int gfp ) ;
unsigned int rtw_restructure_ht_ie23a(struct rtw_adapter *padapter , u8 *in_ie , u8 *out_ie ,
                                      uint in_len , uint *pout_len ) ;
u32 GlobalDebugLevel23A ;
void clear_cam_entry23a(struct rtw_adapter *padapter , u8 entry ) ;
unsigned char check_assoc_AP23a(u8 *pframe , uint len ) ;
void linked_status_chk23a(struct rtw_adapter *padapter ) ;
int NULL_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int join_cmd_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int disconnect_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int createbss_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int setopmode_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int sitesurvey_cmd_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int setauth_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int setkey_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int set_stakey_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int add_ba_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int mlme_evt_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int h2c_msg_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int tx_beacon_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int set_ch_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int set_chplan_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int led_blink_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int set_csa_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
int tdls_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf ) ;
void update_beacon23a(struct rtw_adapter *padapter , u8 ie_id , u8 *oui , u8 tx ) ;
void expire_timeout_chk23a(struct rtw_adapter *padapter ) ;
void rtl8723a_set_FwJoinBssReport_cmd(struct rtw_adapter *padapter , u8 mstatus ) ;
bool rtl8723a_BT_using_antenna_1(struct rtw_adapter *padapter ) ;
bool rtl8723a_BT_coexist(struct rtw_adapter *padapter ) ;
void rtl8723a_BT_do_coexist(struct rtw_adapter *padapter ) ;
void rtl8723a_BT_wifiscan_notify(struct rtw_adapter *padapter , u8 scanType ) ;
void rtl8723a_BT_mediastatus_notify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) ;
void rtl8723a_BT_specialpacket_notify(struct rtw_adapter *padapter ) ;
void rtl8723a_BT_lps_leave(struct rtw_adapter *padapter ) ;
void rtl8723a_HalDmWatchDog(struct rtw_adapter *Adapter ) ;
void rtl8723a_sreset_xmit_status_check(struct rtw_adapter *padapter ) ;
bool c2h_id_filter_ccx_8723a(u8 id ) ;
int c2h_handler_8723a(struct rtw_adapter *padapter , struct c2h_evt_hdr *c2h_evt ) ;
static struct cmd_hdl wlancmds[63U] =
  { {0U, & NULL_hdl23a},
        {0U, & NULL_hdl23a},
        {0U, & NULL_hdl23a},
        {0U, & NULL_hdl23a},
        {0U, & NULL_hdl23a},
        {0U, & NULL_hdl23a},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {863U, & join_cmd_hdl23a},
        {4U, & disconnect_hdl23a},
        {863U, & createbss_hdl23a},
        {4U, & setopmode_hdl23a},
        {712U, & sitesurvey_cmd_hdl23a},
        {4U, & setauth_hdl23a},
        {24U, & setkey_hdl23a},
        {28U, & set_stakey_hdl23a},
        {6U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {6U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {8U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {13U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {4U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {14U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {4U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {128U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {4U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {2U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {4U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {12U, & add_ba_hdl23a},
        {3U, & set_ch_hdl23a},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (int (*)(struct rtw_adapter * , u8 const * ))0},
        {863U, & tx_beacon_hdl23a},
        {0U, & mlme_evt_hdl23a},
        {0U, & rtw_drvextra_cmd_hdl23a},
        {0U, & h2c_msg_hdl23a},
        {1U, & set_chplan_hdl23a},
        {8U, & led_blink_hdl23a},
        {1U, & set_csa_hdl23a},
        {7U, & tdls_hdl23a}};
struct _cmd_callback rtw_cmd_callback[63U] =
  { {0U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {1U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {2U, & rtw_getbbrfreg_cmdrsp_callback23a},
        {3U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {4U, & rtw_getbbrfreg_cmdrsp_callback23a},
        {5U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {6U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {7U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {8U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {9U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {10U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {11U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {12U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {13U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {14U, & rtw_joinbss_cmd23a_callback},
        {15U, & rtw_disassoc_cmd23a_callback},
        {16U, & rtw_createbss_cmd23a_callback},
        {17U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {18U, & rtw_survey_cmd_callback23a},
        {19U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {20U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {21U, & rtw_setstaKey_cmdrsp_callback23a},
        {22U, & rtw_setassocsta_cmdrsp_callback23a},
        {23U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {24U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {25U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {26U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {27U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {28U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {29U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {30U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {31U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {32U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {33U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {34U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {35U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {36U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {37U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {38U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {39U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {40U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {41U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {42U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {43U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {44U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {45U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {46U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {47U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {48U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {49U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {50U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {51U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {52U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {53U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {54U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {55U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {56U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {57U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {58U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {59U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {60U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {61U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0},
        {62U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}};
int rtw_init_cmd_priv23a(struct cmd_priv *pcmdpriv )
{
  int res ;
  struct lock_class_key __key ;
  char const *__lock_name ;
  struct workqueue_struct *tmp ;
  {
  res = 1;
  pcmdpriv->cmd_issued_cnt = 0U;
  pcmdpriv->cmd_done_cnt = 0U;
  pcmdpriv->rsp_cnt = 0U;
  __lock_name = "\"rtl8723au_cmd\"";
  tmp = __alloc_workqueue_key("rtl8723au_cmd", 0U, 1, & __key, __lock_name);
  pcmdpriv->wq = tmp;
  if ((unsigned long )pcmdpriv->wq == (unsigned long )((struct workqueue_struct *)0)) {
    res = 0;
  } else {
  }
  return (res);
}
}
static void rtw_irq_work(struct work_struct *work ) ;
u32 rtw_init_evt_priv23a(struct evt_priv *pevtpriv )
{
  struct lock_class_key __key ;
  char const *__lock_name ;
  struct workqueue_struct *tmp ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  {
  __lock_name = "\"rtl8723au_evt\"";
  tmp = __alloc_workqueue_key("rtl8723au_evt", 0U, 1, & __key, __lock_name);
  pevtpriv->wq = tmp;
  __init_work(& pevtpriv->irq_wk, 0);
  __constr_expr_0.counter = 137438953408L;
  pevtpriv->irq_wk.data = __constr_expr_0;
  lockdep_init_map(& pevtpriv->irq_wk.lockdep_map, "(&pevtpriv->irq_wk)", & __key___0,
                   0);
  INIT_LIST_HEAD(& pevtpriv->irq_wk.entry);
  pevtpriv->irq_wk.func = & rtw_irq_work;
  return (1U);
}
}
void rtw_free_evt_priv23a(struct evt_priv *pevtpriv )
{
  {
  cancel_work_sync(& pevtpriv->irq_wk);
  return;
}
}
static int rtw_cmd_filter(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj )
{
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  u8 bAllow ;
  {
  bAllow = 0U;
  if ((unsigned int )(pcmdpriv->padapter)->pwrctrlpriv.bHWPwrPindetect != 0U && (unsigned int )(pcmdpriv->padapter)->registrypriv.usbss_enable == 0U) {
    if ((unsigned int )cmd_obj->cmdcode == 57U) {
      pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)cmd_obj->parmbuf;
      if (pdrvextra_cmd_parm->ec_id == 4) {
        bAllow = 1U;
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )cmd_obj->cmdcode == 59U) {
    bAllow = 1U;
  } else {
  }
  if ((unsigned int )(pcmdpriv->padapter)->hw_init_completed == 0U && (unsigned int )bAllow == 0U) {
    return (0);
  } else {
  }
  return (1);
}
}
static void rtw_cmd_work(struct work_struct *work ) ;
int rtw_enqueue_cmd23a(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj )
{
  int res ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  bool tmp ;
  {
  res = 0;
  if ((unsigned long )cmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    goto exit;
  } else {
  }
  cmd_obj->padapter = pcmdpriv->padapter;
  res = rtw_cmd_filter(pcmdpriv, cmd_obj);
  if (res == 0) {
    rtw_free_cmd_obj23a(cmd_obj);
    goto exit;
  } else {
  }
  __init_work(& cmd_obj->work, 0);
  __constr_expr_0.counter = 137438953408L;
  cmd_obj->work.data = __constr_expr_0;
  lockdep_init_map(& cmd_obj->work.lockdep_map, "(&cmd_obj->work)", & __key, 0);
  INIT_LIST_HEAD(& cmd_obj->work.entry);
  cmd_obj->work.func = & rtw_cmd_work;
  tmp = queue_work(pcmdpriv->wq, & cmd_obj->work);
  res = (int )tmp;
  if (res == 0) {
    printk("\v%s: Call to queue_work() failed\n", "rtw_enqueue_cmd23a");
    res = 0;
  } else {
    res = 1;
  }
  exit: ;
  return (res);
}
}
void rtw_cmd_clr_isr23a(struct cmd_priv *pcmdpriv )
{
  {
  pcmdpriv->cmd_done_cnt = pcmdpriv->cmd_done_cnt + 1U;
  return;
}
}
void rtw_free_cmd_obj23a(struct cmd_obj *pcmd )
{
  {
  if ((unsigned int )pcmd->cmdcode != 14U && (unsigned int )pcmd->cmdcode != 16U) {
    kfree((void const *)pcmd->parmbuf);
  } else {
  }
  if ((unsigned long )pcmd->rsp != (unsigned long )((u8 *)0U)) {
    if (pcmd->rspsz != 0U) {
      kfree((void const *)pcmd->rsp);
    } else {
    }
  } else {
  }
  kfree((void const *)pcmd);
  return;
}
}
static void rtw_cmd_work(struct work_struct *work )
{
  int (*cmd_hdl)(struct rtw_adapter * , u8 const * ) ;
  void (*pcmd_callback)(struct rtw_adapter * , struct cmd_obj * ) ;
  struct cmd_priv *pcmdpriv ;
  struct cmd_obj *pcmd ;
  struct work_struct const *__mptr ;
  int tmp ;
  {
  __mptr = (struct work_struct const *)work;
  pcmd = (struct cmd_obj *)__mptr;
  pcmdpriv = & (pcmd->padapter)->cmdpriv;
  tmp = rtw_cmd_filter(pcmdpriv, pcmd);
  if (tmp == 0) {
    pcmd->res = 3;
    goto post_process;
  } else {
  }
  pcmdpriv->cmd_issued_cnt = pcmdpriv->cmd_issued_cnt + 1U;
  pcmd->cmdsz = (pcmd->cmdsz + 3U) & 4294967292U;
  if ((unsigned int )pcmd->cmdcode <= 62U) {
    cmd_hdl = wlancmds[(int )pcmd->cmdcode].h2cfuns;
    if ((unsigned long )cmd_hdl != (unsigned long )((int (*)(struct rtw_adapter * ,
                                                             u8 const * ))0)) {
      pcmd->res = (*cmd_hdl)(pcmd->padapter, (u8 const *)pcmd->parmbuf);
    } else {
      pcmd->res = 3;
    }
  } else {
    pcmd->res = 4;
  }
  post_process: ;
  if ((unsigned int )pcmd->cmdcode <= 62U) {
    pcmd_callback = rtw_cmd_callback[(int )pcmd->cmdcode].callback;
    if ((unsigned long )pcmd_callback == (unsigned long )((void (*)(struct rtw_adapter * ,
                                                                    struct cmd_obj * ))0)) {
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
        printk("\016mlme_cmd_hdl(): pcmd_callback = 0x%p, cmdcode = 0x%x\n", pcmd_callback,
               (int )pcmd->cmdcode);
      } else {
      }
      rtw_free_cmd_obj23a(pcmd);
    } else {
      (*pcmd_callback)(pcmd->padapter, pcmd);
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016%s: cmdcode = 0x%x callback not defined!\n", "rtw_cmd_work", (int )pcmd->cmdcode);
    } else {
    }
    rtw_free_cmd_obj23a(pcmd);
  }
  return;
}
}
int rtw_sitesurvey_cmd23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ,
                          int ssid_num , struct rtw_ieee80211_channel *ch , int ch_num )
{
  int res ;
  struct cmd_obj *ph2c ;
  struct sitesurvey_parm *psurveyPara ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int i ;
  size_t __len ;
  void *__ret ;
  int i___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned long tmp___2 ;
  {
  res = 0;
  pcmdpriv = & padapter->cmdpriv;
  pmlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    rtw_lps_ctrl_wk_cmd23a(padapter, 0, 1);
  } else {
  }
  tmp___0 = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp___0;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    return (0);
  } else {
  }
  tmp___1 = kzalloc(712UL, 32U);
  psurveyPara = (struct sitesurvey_parm *)tmp___1;
  if ((unsigned long )psurveyPara == (unsigned long )((struct sitesurvey_parm *)0)) {
    kfree((void const *)ph2c);
    return (0);
  } else {
  }
  rtw_free_network_queue23a(padapter);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
    printk("\016%s: flush network queue\n", "rtw_sitesurvey_cmd23a");
  } else {
  }
  ph2c->cmdcode = 18U;
  ph2c->parmbuf = (u8 *)psurveyPara;
  ph2c->cmdsz = 712U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  psurveyPara->scan_mode = (int )pmlmepriv->scan_mode;
  if ((unsigned long )ssid != (unsigned long )((struct cfg80211_ssid *)0)) {
    i = 0;
    goto ldv_54341;
    ldv_54340: ;
    if ((unsigned int )(ssid + (unsigned long )i)->ssid_len != 0U) {
      __len = 33UL;
      if (__len > 63UL) {
        __ret = memcpy((void *)(& psurveyPara->ssid) + (unsigned long )i, (void const *)ssid + (unsigned long )i,
                         __len);
      } else {
        __ret = memcpy((void *)(& psurveyPara->ssid) + (unsigned long )i,
                                 (void const *)ssid + (unsigned long )i, __len);
      }
      psurveyPara->ssid_num = (u8 )((int )psurveyPara->ssid_num + 1);
    } else {
    }
    i = i + 1;
    ldv_54341: ;
    if (i < ssid_num && i <= 8) {
      goto ldv_54340;
    } else {
    }
  } else {
  }
  if ((unsigned long )ch != (unsigned long )((struct rtw_ieee80211_channel *)0)) {
    i___0 = 0;
    goto ldv_54348;
    ldv_54347: ;
    if ((unsigned int )(ch + (unsigned long )i___0)->hw_value != 0U && ((ch + (unsigned long )i___0)->flags & 1U) == 0U) {
      __len___0 = 8UL;
      if (__len___0 > 63UL) {
        __ret___0 = memcpy((void *)(& psurveyPara->ch) + (unsigned long )i___0,
                             (void const *)ch + (unsigned long )i___0, __len___0);
      } else {
        __ret___0 = memcpy((void *)(& psurveyPara->ch) + (unsigned long )i___0,
                                     (void const *)ch + (unsigned long )i___0, __len___0);
      }
      psurveyPara->ch_num = (u8 )((int )psurveyPara->ch_num + 1);
    } else {
    }
    i___0 = i___0 + 1;
    ldv_54348: ;
    if (i___0 < ch_num && i___0 <= 50) {
      goto ldv_54347;
    } else {
    }
  } else {
  }
  set_fwstate(pmlmepriv, 2048);
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  if (res == 1) {
    tmp___2 = msecs_to_jiffies(8000U);
    ldv_mod_timer_33(& pmlmepriv->scan_to_timer, tmp___2 + (unsigned long )jiffies);
    pmlmepriv->scan_interval = 30U;
  } else {
    _clr_fwstate_(pmlmepriv, 2048);
  }
  return (res);
}
}
void rtw_getbbrfreg_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd )
{
  {
  kfree((void const *)pcmd->parmbuf);
  kfree((void const *)pcmd);
  return;
}
}
int rtw_createbss_cmd23a(struct rtw_adapter *padapter )
{
  struct cmd_obj *pcmd ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 res ;
  void *tmp ;
  int tmp___0 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  pmlmepriv = & padapter->mlmepriv;
  res = 1U;
  pdev_network = & padapter->registrypriv.dev_network;
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
      printk("\016 createbss for Any SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
    } else {
    }
  } else
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
    printk("\016 createbss for SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {
  }
  tmp = kzalloc(128UL, 32U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0U;
    goto exit;
  } else {
  }
  pcmd->cmdcode = 16U;
  pcmd->parmbuf = (u8 *)pdev_network;
  pcmd->cmdsz = get_wlan_bssid_ex_sz(pdev_network);
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  pdev_network->Length = pcmd->cmdsz;
  tmp___0 = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  res = (u8 )tmp___0;
  exit: ;
  return ((int )res);
}
}
int rtw_joinbss_cmd23a(struct rtw_adapter *padapter , struct wlan_network *pnetwork )
{
  u8 *auth ;
  int res ;
  struct wlan_bssid_ex *psecnetwork ;
  struct cmd_obj *pcmd ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct registry_priv *pregistrypriv ;
  struct ht_priv *phtpriv ;
  enum nl80211_iftype ifmode ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  uint tmp___2 ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___3 ;
  u32 tmp_len ;
  int tmp___4 ;
  u32 algo ;
  {
  res = 1;
  pcmdpriv = & padapter->cmdpriv;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pregistrypriv = & padapter->registrypriv;
  phtpriv = & pmlmepriv->htpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ifmode = pnetwork->network.ifmode;
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
      printk("\016+Join cmd: Any SSid\n");
    } else {
    }
  } else
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 6);
    printk("\016+Join cmd: SSid =[%s]\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {
  }
  tmp = kzalloc(128UL, 32U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016rtw_joinbss_cmd23a: memory allocate for cmd_obj fail!!!\n");
    } else {
    }
    goto exit;
  } else {
  }
  tmp___0 = check_fwstate(pmlmepriv, 40);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    switch ((unsigned int )ifmode) {
    case 1U:
    set_fwstate(pmlmepriv, 32);
    goto ldv_54381;
    case 8U: ;
    case 2U:
    set_fwstate(pmlmepriv, 8);
    goto ldv_54381;
    default: ;
    goto ldv_54381;
    }
    ldv_54381: ;
  } else {
  }
  psecnetwork = & psecuritypriv->sec_bss;
  if ((unsigned long )psecnetwork == (unsigned long )((struct wlan_bssid_ex *)0)) {
    if ((unsigned long )pcmd != (unsigned long )((struct cmd_obj *)0)) {
      kfree((void const *)pcmd);
    } else {
    }
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016rtw_joinbss_cmd23a :psecnetwork == NULL!!!\n");
    } else {
    }
    goto exit;
  } else {
  }
  memset((void *)psecnetwork, 0, 863UL);
  tmp___2 = get_wlan_bssid_ex_sz(& pnetwork->network);
  __len = (size_t )tmp___2;
  __ret = memcpy((void *)psecnetwork, (void const *)(& pnetwork->network),
                           __len);
  auth = (u8 *)(& psecuritypriv->authenticator_ie);
  psecuritypriv->authenticator_ie[0] = (unsigned char )psecnetwork->IELength;
  if (psecnetwork->IELength - 12U <= 254U) {
    __len___0 = (size_t )(psecnetwork->IELength - 12U);
    __ret___0 = memcpy((void *)(& psecuritypriv->authenticator_ie) + 1U,
                                 (void const *)(& psecnetwork->IEs) + 12U, __len___0);
  } else {
    __len___1 = 255UL;
    if (__len___1 > 63UL) {
      __ret___1 = memcpy((void *)(& psecuritypriv->authenticator_ie) + 1U, (void const *)(& psecnetwork->IEs) + 12U,
                           __len___1);
    } else {
      __ret___1 = memcpy((void *)(& psecuritypriv->authenticator_ie) + 1U,
                                   (void const *)(& psecnetwork->IEs) + 12U, __len___1);
    }
  }
  psecnetwork->IELength = 0U;
  if (pmlmepriv->assoc_by_bssid == 0U) {
    ether_addr_copy((u8 *)(& pmlmepriv->assoc_bssid), (u8 const *)(& pnetwork->network.MacAddress));
  } else {
  }
  tmp___3 = rtw_restruct_sec_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                                   pnetwork->network.IELength);
  psecnetwork->IELength = (u32 )tmp___3;
  pmlmepriv->qos_option = 0U;
  if ((unsigned int )pregistrypriv->wmm_enable != 0U) {
    tmp___4 = rtw_restruct_wmm_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                                     pnetwork->network.IELength, psecnetwork->IELength);
    tmp_len = (u32 )tmp___4;
    if (psecnetwork->IELength != tmp_len) {
      psecnetwork->IELength = tmp_len;
      pmlmepriv->qos_option = 1U;
    } else {
      pmlmepriv->qos_option = 0U;
    }
  } else {
  }
  phtpriv->ht_option = 0U;
  if ((unsigned int )pregistrypriv->ht_enable != 0U) {
    algo = padapter->securitypriv.dot11PrivacyAlgrthm;
    if ((algo != 1027073U && algo != 1027077U) && algo != 1027074U) {
      rtw_restructure_ht_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                               pnetwork->network.IELength, & psecnetwork->IELength);
    } else {
    }
  } else {
  }
  pmlmeinfo->assoc_AP_vendor = check_assoc_AP23a((u8 *)(& pnetwork->network.IEs),
                                                 pnetwork->network.IELength);
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 16U) {
    padapter->pwrctrlpriv.smart_ps = 0U;
  } else {
    padapter->pwrctrlpriv.smart_ps = padapter->registrypriv.smart_ps;
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: smart_ps =%d\n", "rtw_joinbss_cmd23a", (int )padapter->pwrctrlpriv.smart_ps);
  } else {
  }
  pcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);
  pcmd->cmdcode = 14U;
  pcmd->parmbuf = (u8 *)psecnetwork;
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
  return (res);
}
}
int rtw_disassoc_cmd23a(struct rtw_adapter *padapter , u32 deauth_timeout_ms , bool enqueue )
{
  struct cmd_obj *cmdobj ;
  struct disconnect_parm *param ;
  struct cmd_priv *cmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  cmdobj = (struct cmd_obj *)0;
  param = (struct disconnect_parm *)0;
  cmdpriv = & padapter->cmdpriv;
  res = 1;
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 6);
    printk("\016+rtw_disassoc_cmd23a\n");
  } else {
  }
  tmp = kzalloc(4UL, 32U);
  param = (struct disconnect_parm *)tmp;
  if ((unsigned long )param == (unsigned long )((struct disconnect_parm *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  param->deauth_timeout_ms = deauth_timeout_ms;
  if ((int )enqueue) {
    tmp___0 = kzalloc(128UL, 32U);
    cmdobj = (struct cmd_obj *)tmp___0;
    if ((unsigned long )cmdobj == (unsigned long )((struct cmd_obj *)0)) {
      res = 0;
      kfree((void const *)param);
      goto exit;
    } else {
    }
    cmdobj->cmdcode = 15U;
    cmdobj->parmbuf = (u8 *)param;
    cmdobj->cmdsz = 4U;
    cmdobj->rsp = (u8 *)0U;
    cmdobj->rspsz = 0U;
    res = rtw_enqueue_cmd23a(cmdpriv, cmdobj);
  } else {
    tmp___1 = disconnect_hdl23a(padapter, (u8 const *)param);
    if (tmp___1 != 0) {
      res = 0;
    } else {
    }
    kfree((void const *)param);
  }
  exit: ;
  return (res);
}
}
int rtw_setopmode_cmd23a(struct rtw_adapter *padapter , enum nl80211_iftype ifmode )
{
  struct cmd_obj *ph2c ;
  struct setopmode_parm *psetop ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 208U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(4UL, 208U);
  psetop = (struct setopmode_parm *)tmp___0;
  if ((unsigned long )psetop == (unsigned long )((struct setopmode_parm *)0)) {
    kfree((void const *)ph2c);
    res = 0;
    goto exit;
  } else {
  }
  ph2c->cmdcode = 17U;
  ph2c->parmbuf = (u8 *)psetop;
  ph2c->cmdsz = 4U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  psetop->mode = ifmode;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
int rtw_setstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 unicast_key )
{
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct sta_info *sta ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  size_t __len ;
  void *__ret ;
  int idx ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  psetstakey_rsp = (struct set_stakey_rsp *)0;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  sta = (struct sta_info *)psta;
  res = 1;
  tmp = kzalloc(128UL, 208U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(28UL, 208U);
  psetstakey_para = (struct set_stakey_parm *)tmp___0;
  if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
    kfree((void const *)ph2c);
    res = 0;
    goto exit;
  } else {
  }
  tmp___1 = kzalloc(8UL, 208U);
  psetstakey_rsp = (struct set_stakey_rsp *)tmp___1;
  if ((unsigned long )psetstakey_rsp == (unsigned long )((struct set_stakey_rsp *)0)) {
    kfree((void const *)ph2c);
    kfree((void const *)psetstakey_para);
    res = 0;
    goto exit;
  } else {
  }
  ph2c->cmdcode = 21U;
  ph2c->parmbuf = (u8 *)psetstakey_para;
  ph2c->cmdsz = 28U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  ph2c->rsp = (u8 *)psetstakey_rsp;
  ph2c->rspsz = 8U;
  ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const *)(& sta->hwaddr));
  tmp___2 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___2) {
    psetstakey_para->algorithm = (u32 )((unsigned char )psecuritypriv->dot11PrivacyAlgrthm);
  } else {
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U:
    psetstakey_para->algorithm = psecuritypriv->dot11PrivacyAlgrthm;
    goto ldv_54433;
    case 2U:
    psetstakey_para->algorithm = sta->dot118021XPrivacy;
    goto ldv_54433;
    }
    ldv_54433: ;
  }
  if ((unsigned int )unicast_key == 1U) {
    __len = 16UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& psetstakey_para->key), (void const *)(& sta->dot118021x_UncstKey),
                       __len);
    } else {
      __ret = memcpy((void *)(& psetstakey_para->key), (void const *)(& sta->dot118021x_UncstKey),
                               __len);
    }
  } else {
    idx = (int )psecuritypriv->dot118021XGrpKeyid;
    __len___0 = 16UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& psetstakey_para->key), (void const *)(& psecuritypriv->dot118021XGrpKey[idx].skey),
                           __len___0);
    } else {
      __ret___0 = memcpy((void *)(& psetstakey_para->key), (void const *)(& psecuritypriv->dot118021XGrpKey[idx].skey),
                                   __len___0);
    }
  }
  padapter->securitypriv.busetkipkey = 1U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
int rtw_clearstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 entry , u8 enqueue )
{
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct sta_info *sta ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  psetstakey_rsp = (struct set_stakey_rsp *)0;
  sta = (struct sta_info *)psta;
  res = 1;
  if ((unsigned int )enqueue == 0U) {
    clear_cam_entry23a(padapter, (int )entry);
  } else {
    tmp = kzalloc(128UL, 208U);
    ph2c = (struct cmd_obj *)tmp;
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
      res = 0;
      goto exit;
    } else {
    }
    tmp___0 = kzalloc(28UL, 208U);
    psetstakey_para = (struct set_stakey_parm *)tmp___0;
    if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
      kfree((void const *)ph2c);
      res = 0;
      goto exit;
    } else {
    }
    tmp___1 = kzalloc(8UL, 208U);
    psetstakey_rsp = (struct set_stakey_rsp *)tmp___1;
    if ((unsigned long )psetstakey_rsp == (unsigned long )((struct set_stakey_rsp *)0)) {
      kfree((void const *)ph2c);
      kfree((void const *)psetstakey_para);
      res = 0;
      goto exit;
    } else {
    }
    ph2c->cmdcode = 21U;
    ph2c->parmbuf = (u8 *)psetstakey_para;
    ph2c->cmdsz = 28U;
    ph2c->rsp = (u8 *)0U;
    ph2c->rspsz = 0U;
    ph2c->rsp = (u8 *)psetstakey_rsp;
    ph2c->rspsz = 8U;
    ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const *)(& sta->hwaddr));
    psetstakey_para->algorithm = 0U;
    psetstakey_para->id = entry;
    res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  }
  exit: ;
  return (res);
}
}
int rtw_addbareq_cmd23a(struct rtw_adapter *padapter , u8 tid , u8 *addr )
{
  struct cmd_priv *pcmdpriv ;
  struct cmd_obj *ph2c ;
  struct addBaReq_parm *paddbareq_parm ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  if ((unsigned int )tid > 15U) {
    res = 0;
    goto exit;
  } else {
  }
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(12UL, 32U);
  paddbareq_parm = (struct addBaReq_parm *)tmp___0;
  if ((unsigned long )paddbareq_parm == (unsigned long )((struct addBaReq_parm *)0)) {
    kfree((void const *)ph2c);
    res = 0;
    goto exit;
  } else {
  }
  paddbareq_parm->tid = (unsigned int )tid;
  ether_addr_copy((u8 *)(& paddbareq_parm->addr), (u8 const *)addr);
  ph2c->cmdcode = 45U;
  ph2c->parmbuf = (u8 *)paddbareq_parm;
  ph2c->cmdsz = 12U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
int rtw_dynamic_chk_wk_cmd23a(struct rtw_adapter *padapter )
{
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(16UL, 32U);
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
    kfree((void const *)ph2c);
    res = 0;
    goto exit;
  } else {
  }
  pdrvextra_cmd_parm->ec_id = 1;
  pdrvextra_cmd_parm->type_size = 0;
  pdrvextra_cmd_parm->pbuf = (unsigned char *)padapter;
  ph2c->cmdcode = 57U;
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
  ph2c->cmdsz = 16U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
int rtw_set_ch_cmd23a(struct rtw_adapter *padapter , u8 ch , u8 bw , u8 ch_offset ,
                      u8 enqueue )
{
  struct cmd_obj *pcmdobj ;
  struct set_ch_parm *set_ch_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): ch:%u, bw:%u, ch_offset:%u\n", "rtw_set_ch_cmd23a",
           (char *)(& (padapter->pnetdev)->name), (int )ch, (int )bw, (int )ch_offset);
  } else {
  }
  tmp = kzalloc(3UL, 208U);
  set_ch_parm = (struct set_ch_parm *)tmp;
  if ((unsigned long )set_ch_parm == (unsigned long )((struct set_ch_parm *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  set_ch_parm->ch = ch;
  set_ch_parm->bw = bw;
  set_ch_parm->ch_offset = ch_offset;
  if ((unsigned int )enqueue != 0U) {
    tmp___0 = kzalloc(128UL, 208U);
    pcmdobj = (struct cmd_obj *)tmp___0;
    if ((unsigned long )pcmdobj == (unsigned long )((struct cmd_obj *)0)) {
      kfree((void const *)set_ch_parm);
      res = 0;
      goto exit;
    } else {
    }
    pcmdobj->cmdcode = 46U;
    pcmdobj->parmbuf = (u8 *)set_ch_parm;
    pcmdobj->cmdsz = 3U;
    pcmdobj->rsp = (u8 *)0U;
    pcmdobj->rspsz = 0U;
    res = rtw_enqueue_cmd23a(pcmdpriv, pcmdobj);
  } else {
    tmp___1 = set_ch_hdl23a(padapter, (u8 const *)set_ch_parm);
    if (tmp___1 != 0) {
      res = 0;
    } else {
    }
    kfree((void const *)set_ch_parm);
  }
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): res:%u\n", "rtw_set_ch_cmd23a", (char *)(& (padapter->pnetdev)->name),
           res);
  } else {
  }
  return (res);
}
}
static void traffic_status_watchdog(struct rtw_adapter *padapter )
{
  u8 bEnterPS ;
  u8 bBusyTraffic ;
  u8 bTxBusyTraffic ;
  u8 bRxBusyTraffic ;
  u8 bHigherBusyTraffic ;
  u8 bHigherBusyRxTraffic ;
  u8 bHigherBusyTxTraffic ;
  struct mlme_priv *pmlmepriv ;
  int BusyThreshold ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  {
  bBusyTraffic = 0U;
  bTxBusyTraffic = 0U;
  bRxBusyTraffic = 0U;
  bHigherBusyTraffic = 0U;
  bHigherBusyRxTraffic = 0U;
  bHigherBusyTxTraffic = 0U;
  pmlmepriv = & padapter->mlmepriv;
  BusyThreshold = 100;
  tmp___4 = check_fwstate(pmlmepriv, 1);
  if ((int )tmp___4) {
    tmp = rtl8723a_BT_coexist(padapter);
    if ((int )tmp) {
      BusyThreshold = 50;
    } else
    if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
      BusyThreshold = 75;
    } else {
    }
    if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > (u32 )BusyThreshold || pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > (u32 )BusyThreshold) {
      bBusyTraffic = 1U;
      if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) {
        bRxBusyTraffic = 1U;
      } else {
        bTxBusyTraffic = 1U;
      }
    } else {
    }
    if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 4000U || pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 4000U) {
      bHigherBusyTraffic = 1U;
      if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) {
        bHigherBusyRxTraffic = 1U;
      } else {
        bHigherBusyTxTraffic = 1U;
      }
    } else {
    }
    tmp___0 = rtl8723a_BT_coexist(padapter);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      goto _L;
    } else {
      tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
      if (tmp___2) {
        tmp___3 = 0;
      } else {
        tmp___3 = 1;
      }
      if (tmp___3) {
        _L:
        if (pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 8U || pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2U) {
          bEnterPS = 0U;
        } else {
          bEnterPS = 1U;
        }
        if ((unsigned int )bEnterPS != 0U) {
          LPS_Enter23a(padapter);
        } else {
          LPS_Leave23a(padapter);
        }
      } else {
      }
    }
  } else {
    LPS_Leave23a(padapter);
  }
  pmlmepriv->LinkDetectInfo.NumRxOkInPeriod = 0U;
  pmlmepriv->LinkDetectInfo.NumTxOkInPeriod = 0U;
  pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod = 0U;
  pmlmepriv->LinkDetectInfo.bBusyTraffic = (unsigned int )bBusyTraffic != 0U;
  pmlmepriv->LinkDetectInfo.bTxBusyTraffic = (unsigned int )bTxBusyTraffic != 0U;
  pmlmepriv->LinkDetectInfo.bRxBusyTraffic = (unsigned int )bRxBusyTraffic != 0U;
  pmlmepriv->LinkDetectInfo.bHigherBusyTraffic = (unsigned int )bHigherBusyTraffic != 0U;
  pmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic = (unsigned int )bHigherBusyRxTraffic != 0U;
  pmlmepriv->LinkDetectInfo.bHigherBusyTxTraffic = (unsigned int )bHigherBusyTxTraffic != 0U;
  return;
}
}
static void dynamic_chk_wk_hdl(struct rtw_adapter *padapter , u8 *pbuf , int sz )
{
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  {
  padapter = (struct rtw_adapter *)pbuf;
  pmlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    expire_timeout_chk23a(padapter);
  } else {
  }
  rtl8723a_sreset_xmit_status_check(padapter);
  linked_status_chk23a(padapter);
  traffic_status_watchdog(padapter);
  rtl8723a_HalDmWatchDog(padapter);
  rtl8723a_BT_do_coexist(padapter);
  return;
}
}
static void lps_ctrl_wk_hdl(struct rtw_adapter *padapter , u8 lps_ctrl_type )
{
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  u8 mstatus ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  pmlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 64);
  if ((int )tmp) {
    return;
  } else {
    tmp___0 = check_fwstate(pmlmepriv, 32);
    if ((int )tmp___0) {
      return;
    } else {
    }
  }
  switch ((int )lps_ctrl_type) {
  case 0:
  rtl8723a_BT_wifiscan_notify(padapter, 1);
  tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    tmp___1 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___1) {
      LPS_Leave23a(padapter);
    } else {
    }
  } else {
  }
  goto ldv_54512;
  case 1:
  LPS_Leave23a(padapter);
  goto ldv_54512;
  case 2:
  mstatus = 1U;
  padapter->pwrctrlpriv.LpsIdleCount = 0U;
  rtl8723a_set_FwJoinBssReport_cmd(padapter, 1);
  rtl8723a_BT_mediastatus_notify(padapter, (enum rt_media_status )mstatus);
  goto ldv_54512;
  case 3:
  mstatus = 0U;
  rtl8723a_BT_mediastatus_notify(padapter, (enum rt_media_status )mstatus);
  tmp___4 = rtl8723a_BT_using_antenna_1(padapter);
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    LPS_Leave23a(padapter);
  } else {
  }
  rtl8723a_set_FwJoinBssReport_cmd(padapter, 0);
  goto ldv_54512;
  case 4:
  pwrpriv->DelayLPSLastTimeStamp = jiffies;
  rtl8723a_BT_specialpacket_notify(padapter);
  tmp___6 = rtl8723a_BT_using_antenna_1(padapter);
  if (tmp___6) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  if (tmp___7) {
    LPS_Leave23a(padapter);
  } else {
  }
  goto ldv_54512;
  case 5:
  rtl8723a_BT_lps_leave(padapter);
  tmp___8 = rtl8723a_BT_using_antenna_1(padapter);
  if (tmp___8) {
    tmp___9 = 0;
  } else {
    tmp___9 = 1;
  }
  if (tmp___9) {
    LPS_Leave23a(padapter);
  } else {
  }
  goto ldv_54512;
  default: ;
  goto ldv_54512;
  }
  ldv_54512: ;
  return;
}
}
int rtw_lps_ctrl_wk_cmd23a(struct rtw_adapter *padapter , u8 lps_ctrl_type , u8 enqueue )
{
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  if ((unsigned int )enqueue != 0U) {
    tmp = kzalloc(128UL, 32U);
    ph2c = (struct cmd_obj *)tmp;
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
      res = 0;
      goto exit;
    } else {
    }
    tmp___0 = kzalloc(16UL, 32U);
    pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
    if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
      kfree((void const *)ph2c);
      res = 0;
      goto exit;
    } else {
    }
    pdrvextra_cmd_parm->ec_id = 5;
    pdrvextra_cmd_parm->type_size = (int )lps_ctrl_type;
    pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
    ph2c->cmdcode = 57U;
    ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
    ph2c->cmdsz = 16U;
    ph2c->rsp = (u8 *)0U;
    ph2c->rspsz = 0U;
    res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  } else {
    lps_ctrl_wk_hdl(padapter, (int )lps_ctrl_type);
  }
  exit: ;
  return (res);
}
}
static void power_saving_wk_hdl(struct rtw_adapter *padapter , u8 *pbuf , int sz )
{
  {
  rtw_ps_processor23a(padapter);
  return;
}
}
int rtw_ps_cmd23a(struct rtw_adapter *padapter )
{
  struct cmd_obj *ppscmd ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 32U);
  ppscmd = (struct cmd_obj *)tmp;
  if ((unsigned long )ppscmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(16UL, 32U);
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
    kfree((void const *)ppscmd);
    res = 0;
    goto exit;
  } else {
  }
  pdrvextra_cmd_parm->ec_id = 4;
  pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
  ppscmd->cmdcode = 57U;
  ppscmd->parmbuf = (u8 *)pdrvextra_cmd_parm;
  ppscmd->cmdsz = 16U;
  ppscmd->rsp = (u8 *)0U;
  ppscmd->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ppscmd);
  exit: ;
  return (res);
}
}
static void rtw_chk_hi_queue_hdl(struct rtw_adapter *padapter )
{
  int cnt ;
  struct sta_info *psta_bmc ;
  struct sta_priv *pstapriv ;
  bool val ;
  {
  cnt = 0;
  pstapriv = & padapter->stapriv;
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
  if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {
  }
  if (psta_bmc->sleepq_len == 0U) {
    val = rtl8723a_chk_hi_queue_empty(padapter);
    goto ldv_54551;
    ldv_54550:
    msleep(100U);
    cnt = cnt + 1;
    if (cnt > 10) {
      goto ldv_54549;
    } else {
    }
    val = rtl8723a_chk_hi_queue_empty(padapter);
    ldv_54551: ;
    if (! val) {
      goto ldv_54550;
    } else {
    }
    ldv_54549: ;
    if (cnt <= 10) {
      pstapriv->tim_bitmap = (unsigned int )pstapriv->tim_bitmap & 65534U;
      pstapriv->sta_dz_bitmap = (unsigned int )pstapriv->sta_dz_bitmap & 65534U;
      update_beacon23a(padapter, 5, (u8 *)0U, 0);
    } else {
      rtw_chk_hi_queue_cmd23a(padapter);
    }
  } else {
  }
  return;
}
}
int rtw_chk_hi_queue_cmd23a(struct rtw_adapter *padapter )
{
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(16UL, 32U);
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
    kfree((void const *)ph2c);
    res = 0;
    goto exit;
  } else {
  }
  pdrvextra_cmd_parm->ec_id = 9;
  pdrvextra_cmd_parm->type_size = 0;
  pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
  ph2c->cmdcode = 57U;
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
  ph2c->cmdsz = 16U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
int rtw_c2h_wk_cmd23a(struct rtw_adapter *padapter , u8 *c2h_evt )
{
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(16UL, 32U);
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
    kfree((void const *)ph2c);
    res = 0;
    goto exit;
  } else {
  }
  pdrvextra_cmd_parm->ec_id = 10;
  pdrvextra_cmd_parm->type_size = (unsigned long )c2h_evt != (unsigned long )((u8 *)0U) ? 16 : 0;
  pdrvextra_cmd_parm->pbuf = c2h_evt;
  ph2c->cmdcode = 57U;
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
  ph2c->cmdsz = 16U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
static int c2h_evt_hdl(struct rtw_adapter *adapter , struct c2h_evt_hdr *c2h_evt )
{
  int ret ;
  u8 buf[16U] ;
  s32 tmp ;
  {
  ret = 0;
  if ((unsigned long )c2h_evt == (unsigned long )((struct c2h_evt_hdr *)0)) {
    tmp = c2h_evt_read23a(adapter, (u8 *)(& buf));
    if (tmp == 1) {
      c2h_evt = (struct c2h_evt_hdr *)(& buf);
      ret = c2h_handler_8723a(adapter, c2h_evt);
    } else {
    }
  } else {
    ret = c2h_handler_8723a(adapter, c2h_evt);
  }
  return (ret);
}
}
static void rtw_irq_work(struct work_struct *work )
{
  struct evt_priv *evtpriv ;
  struct rtw_adapter *adapter ;
  struct work_struct const *__mptr ;
  struct evt_priv const *__mptr___0 ;
  {
  __mptr = (struct work_struct const *)work;
  evtpriv = (struct evt_priv *)__mptr + 0xfffffffffffffff8UL;
  __mptr___0 = (struct evt_priv const *)evtpriv;
  adapter = (struct rtw_adapter *)__mptr___0 + 0xffffffffffffe778UL;
  c2h_evt_clear23a(adapter);
  return;
}
}
void rtw_evt_work(struct work_struct *work )
{
  struct evt_work *ework ;
  struct rtw_adapter *adapter ;
  struct work_struct const *__mptr ;
  bool tmp ;
  {
  __mptr = (struct work_struct const *)work;
  ework = (struct evt_work *)__mptr + 0xfffffffffffffff0UL;
  adapter = ework->adapter;
  c2h_evt_clear23a(adapter);
  if ((unsigned int )*((unsigned char *)ework + 0UL) == 0U && (unsigned int )*((unsigned char *)ework + 0UL) == 0U) {
    kfree((void const *)ework);
    return;
  } else {
  }
  tmp = c2h_id_filter_ccx_8723a((int )ework->u.c2h_evt.id);
  if ((int )tmp) {
    c2h_handler_8723a(adapter, & ework->u.c2h_evt);
    kfree((void const *)ework);
  } else {
    rtw_c2h_wk_cmd23a(adapter, (u8 *)(& ework->u.c2h_evt));
  }
  return;
}
}
int rtw_drvextra_cmd_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct drvextra_cmd_parm const *pdrvextra_cmd ;
  {
  if ((unsigned long )pbuf == (unsigned long )((u8 const *)0U)) {
    return (4);
  } else {
  }
  pdrvextra_cmd = (struct drvextra_cmd_parm const *)pbuf;
  switch (pdrvextra_cmd->ec_id) {
  case 1:
  dynamic_chk_wk_hdl(padapter, (u8 *)pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
  goto ldv_54597;
  case 4:
  power_saving_wk_hdl(padapter, (u8 *)pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
  goto ldv_54597;
  case 5:
  lps_ctrl_wk_hdl(padapter, (int )((unsigned char )pdrvextra_cmd->type_size));
  goto ldv_54597;
  case 9:
  rtw_chk_hi_queue_hdl(padapter);
  goto ldv_54597;
  case 10:
  c2h_evt_hdl(padapter, (struct c2h_evt_hdr *)pdrvextra_cmd->pbuf);
  goto ldv_54597;
  default: ;
  goto ldv_54597;
  }
  ldv_54597: ;
  if ((unsigned long )pdrvextra_cmd->pbuf != (unsigned long )((unsigned char * )0U) && (int )pdrvextra_cmd->type_size > 0) {
    kfree((void const *)pdrvextra_cmd->pbuf);
  } else {
  }
  return (0);
}
}
void rtw_survey_cmd_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd )
{
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  if (pcmd->res == 3) {
    tmp = msecs_to_jiffies(1U);
    ldv_mod_timer_34(& pmlmepriv->scan_to_timer, tmp + (unsigned long )jiffies);
  } else
  if (pcmd->res != 0) {
    tmp___0 = msecs_to_jiffies(1U);
    ldv_mod_timer_35(& pmlmepriv->scan_to_timer, tmp___0 + (unsigned long )jiffies);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016\n ********Error: MgntActrtw_set_802_11_bssid23a_LIST_SCAN Fail ************\n\n.");
    } else {
    }
  } else {
  }
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_disassoc_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd )
{
  struct mlme_priv *pmlmepriv ;
  {
  pmlmepriv = & padapter->mlmepriv;
  if (pcmd->res != 0) {
    spin_lock_bh(& pmlmepriv->lock);
    set_fwstate(pmlmepriv, 1);
    spin_unlock_bh(& pmlmepriv->lock);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016\n ***Error: disconnect_cmd_callback Fail ***\n.");
    } else {
    }
    return;
  } else {
  }
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_joinbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd )
{
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  if (pcmd->res == 3) {
    tmp = msecs_to_jiffies(1U);
    ldv_mod_timer_36(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
  } else
  if (pcmd->res != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n");
    } else {
    }
    tmp___0 = msecs_to_jiffies(1U);
    ldv_mod_timer_37(& pmlmepriv->assoc_timer, tmp___0 + (unsigned long )jiffies);
  } else {
  }
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_createbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd )
{
  struct sta_info *psta ;
  struct wlan_network *pwlan ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_network *tgt_network ;
  unsigned long tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  uint tmp___0 ;
  void *__ret___0 ;
  bool tmp___1 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;
  tgt_network = & pmlmepriv->cur_network;
  if (pcmd->res != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016\n ********Error: rtw_createbss_cmd23a_callback  Fail ************\n\n.");
    } else {
    }
    tmp = msecs_to_jiffies(1U);
    ldv_mod_timer_38(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
  } else {
  }
  ldv_del_timer_sync_39(& pmlmepriv->assoc_timer);
  tmp___1 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___1) {
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pnetwork->MacAddress));
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
      psta = rtw_alloc_stainfo23a(& padapter->stapriv, (u8 *)(& pnetwork->MacAddress),
                                  208U);
      if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
          printk("\016\nCan\'t alloc sta_info when createbss_cmd_callback\n");
        } else {
        }
        goto createbss_cmd_fail;
      } else {
      }
    } else {
    }
    spin_lock_bh(& pmlmepriv->lock);
    rtw_indicate_connect23a(padapter);
    spin_unlock_bh(& pmlmepriv->lock);
  } else {
    pwlan = rtw_alloc_network(pmlmepriv, 208);
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
    if ((unsigned long )pwlan == (unsigned long )((struct wlan_network *)0)) {
      pwlan = rtw_get_oldest_wlan_network23a(& pmlmepriv->scanned_queue);
      if ((unsigned long )pwlan == (unsigned long )((struct wlan_network *)0)) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
          printk("\016\n Error:  can\'t get pwlan in rtw23a_joinbss_event_cb\n");
        } else {
        }
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        goto createbss_cmd_fail;
      } else {
      }
      pwlan->last_scanned = jiffies;
    } else {
      list_add_tail(& pwlan->list, & pmlmepriv->scanned_queue.queue);
    }
    pnetwork->Length = get_wlan_bssid_ex_sz(pnetwork);
    __len = (size_t )pnetwork->Length;
    __ret = memcpy((void *)(& pwlan->network), (void const *)pnetwork,
                             __len);
    tmp___0 = get_wlan_bssid_ex_sz(pnetwork);
    __len___0 = (size_t )tmp___0;
    __ret___0 = memcpy((void *)(& tgt_network->network), (void const *)pnetwork,
                                 __len___0);
    clr_fwstate(pmlmepriv, 128);
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  }
  createbss_cmd_fail:
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_setstaKey_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd )
{
  struct sta_priv *pstapriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct sta_info *psta ;
  {
  pstapriv = & padapter->stapriv;
  psetstakey_rsp = (struct set_stakey_rsp *)pcmd->rsp;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& psetstakey_rsp->addr));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016\nERROR: rtw_setstaKey_cmdrsp_callback23a => can\'t get sta_info\n\n");
    } else {
    }
    goto exit;
  } else {
  }
  exit:
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
void rtw_setassocsta_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd )
{
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct set_assocsta_parm *passocsta_parm ;
  struct set_assocsta_rsp *passocsta_rsp ;
  struct sta_info *psta ;
  uint tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  pstapriv = & padapter->stapriv;
  pmlmepriv = & padapter->mlmepriv;
  passocsta_parm = (struct set_assocsta_parm *)pcmd->parmbuf;
  passocsta_rsp = (struct set_assocsta_rsp *)pcmd->rsp;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& passocsta_parm->addr));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016\nERROR: setassocsta_cmdrsp_callbac => can\'t get sta_info\n\n");
    } else {
    }
    goto exit;
  } else {
  }
  tmp = (uint )passocsta_rsp->cam_id;
  psta->mac_id = tmp;
  psta->aid = tmp;
  spin_lock_bh(& pmlmepriv->lock);
  tmp___0 = check_fwstate(pmlmepriv, 65536);
  if ((int )tmp___0) {
    tmp___1 = check_fwstate(pmlmepriv, 128);
    if ((int )tmp___1) {
      _clr_fwstate_(pmlmepriv, 128);
    } else {
    }
  } else {
  }
  set_fwstate(pmlmepriv, 1);
  spin_unlock_bh(& pmlmepriv->lock);
  exit:
  rtw_free_cmd_obj23a(pcmd);
  return;
}
}
__inline static void spin_lock_bh(spinlock_t *lock )
{
  {
  ldv_spin_lock();
  ldv_spin_lock_bh_2(lock);
  return;
}
}
__inline static void spin_unlock_bh(spinlock_t *lock )
{
  {
  ldv_spin_unlock();
  ldv_spin_unlock_bh_6(lock);
  return;
}
}
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_26(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_mod_timer_33(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_34(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_35(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_36(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_37(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_38(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_39(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
void *ldv_kmem_cache_alloc_72(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
extern void __const_udelay(unsigned long ) ;
struct sk_buff *ldv_skb_clone_80(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_88(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_82(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_78(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
int ldv_pskb_expand_head_87(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_83(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_84(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_85(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
u16 efuse_GetMaxSize23a(struct rtw_adapter *padapter ) ;
int rtw_efuse_access23a(struct rtw_adapter *padapter , u8 bWrite , u16 start_addr ,
                        u16 cnts , u8 *data ) ;
int rtw_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts , u8 *data ) ;
int rtw_BT_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts ,
                             u8 *data ) ;
u16 Efuse_GetCurrentSize23a(struct rtw_adapter *pAdapter , u8 efuseType ) ;
u8 Efuse_CalculateWordCnts23a(u8 word_en ) ;
void ReadEFuseByte23a(struct rtw_adapter *Adapter , u16 _offset , u8 *pbuf ) ;
void EFUSE_GetEfuseDefinition23a(struct rtw_adapter *pAdapter , u8 efuseType , u8 type ,
                                 void *pOut ) ;
int efuse_OneByteRead23a(struct rtw_adapter *pAdapter , u16 addr , u8 *data ) ;
int efuse_OneByteWrite23a(struct rtw_adapter *pAdapter , u16 addr , u8 data ) ;
void efuse_WordEnableDataRead23a(u8 word_en , u8 *sourdata , u8 *targetdata ) ;
u8 EFUSE_Read1Byte23a(struct rtw_adapter *Adapter , u16 Address ) ;
void EFUSE_ShadowMapUpdate23a(struct rtw_adapter *pAdapter , u8 efuseType ) ;
void EFUSE_ShadowRead23a(struct rtw_adapter *pAdapter , u8 Type , u16 Offset , u32 *Value ) ;
void rtl8723a_readefuse(struct rtw_adapter *padapter , u8 efuseType , u16 _offset ,
                        u16 _size_byte , u8 *pbuf ) ;
u16 rtl8723a_EfuseGetCurrentSize_WiFi(struct rtw_adapter *padapter ) ;
u16 rtl8723a_EfuseGetCurrentSize_BT(struct rtw_adapter *padapter ) ;
u8 rtl8723au_read8(struct rtw_adapter *padapter , u32 addr ) ;
u16 rtl8723au_read16(struct rtw_adapter *padapter , u32 addr ) ;
u32 rtl8723au_read32(struct rtw_adapter *padapter , u32 addr ) ;
int rtl8723au_write8(struct rtw_adapter *padapter , u32 addr , u8 val ) ;
int rtl8723au_write16(struct rtw_adapter *padapter , u32 addr , u16 val ) ;
static void Efuse_PowerSwitch(struct rtw_adapter *padapter , u8 bWrite , u8 PwrState )
{
  u8 tempval ;
  u16 tmpV16 ;
  {
  if ((unsigned int )PwrState == 1U) {
    rtl8723au_write8(padapter, 207U, 105);
    tmpV16 = rtl8723au_read16(padapter, 0U);
    if ((int )((short )tmpV16) >= 0) {
      tmpV16 = (u16 )((unsigned int )tmpV16 | 32768U);
      rtl8723au_write16(padapter, 0U, (int )tmpV16);
    } else {
    }
    tmpV16 = rtl8723au_read16(padapter, 2U);
    if (((unsigned long )tmpV16 & 4096UL) == 0UL) {
      tmpV16 = (u16 )((unsigned int )tmpV16 | 4096U);
      rtl8723au_write16(padapter, 2U, (int )tmpV16);
    } else {
    }
    tmpV16 = rtl8723au_read16(padapter, 8U);
    if (((unsigned long )tmpV16 & 32UL) == 0UL || ((unsigned long )tmpV16 & 2UL) == 0UL) {
      tmpV16 = (u16 )((unsigned int )tmpV16 | 34U);
      rtl8723au_write16(padapter, 8U, (int )tmpV16);
    } else {
    }
    if ((unsigned int )bWrite == 1U) {
      tempval = rtl8723au_read8(padapter, 55U);
      tempval = (unsigned int )tempval & 15U;
      tempval = (u8 )((unsigned int )tempval | 48U);
      rtl8723au_write8(padapter, 55U, (int )((unsigned int )tempval | 128U));
    } else {
    }
  } else {
    rtl8723au_write8(padapter, 207U, 0);
    if ((unsigned int )bWrite == 1U) {
      tempval = rtl8723au_read8(padapter, 55U);
      rtl8723au_write8(padapter, 55U, (int )tempval & 127);
    } else {
    }
  }
  return;
}
}
u16 Efuse_GetCurrentSize23a(struct rtw_adapter *pAdapter , u8 efuseType )
{
  u16 ret ;
  {
  ret = 0U;
  if ((unsigned int )efuseType == 0U) {
    ret = rtl8723a_EfuseGetCurrentSize_WiFi(pAdapter);
  } else {
    ret = rtl8723a_EfuseGetCurrentSize_BT(pAdapter);
  }
  return (ret);
}
}
u8 Efuse_CalculateWordCnts23a(u8 word_en )
{
  u8 word_cnts ;
  {
  word_cnts = 0U;
  if (((unsigned long )word_en & 1UL) == 0UL) {
    word_cnts = (u8 )((int )word_cnts + 1);
  } else {
  }
  if (((unsigned long )word_en & 2UL) == 0UL) {
    word_cnts = (u8 )((int )word_cnts + 1);
  } else {
  }
  if (((unsigned long )word_en & 4UL) == 0UL) {
    word_cnts = (u8 )((int )word_cnts + 1);
  } else {
  }
  if (((unsigned long )word_en & 8UL) == 0UL) {
    word_cnts = (u8 )((int )word_cnts + 1);
  } else {
  }
  return (word_cnts);
}
}
void ReadEFuseByte23a(struct rtw_adapter *Adapter , u16 _offset , u8 *pbuf )
{
  u32 value32 ;
  u8 readbyte ;
  u16 retry ;
  {
  rtl8723au_write8(Adapter, 49U, (int )((u8 )_offset));
  readbyte = rtl8723au_read8(Adapter, 50U);
  rtl8723au_write8(Adapter, 50U, (int )((u8 )(((int )((signed char )((int )_offset >> 8)) & 3) | ((int )((signed char )readbyte) & -4))));
  readbyte = rtl8723au_read8(Adapter, 51U);
  rtl8723au_write8(Adapter, 51U, (int )readbyte & 127);
  retry = 0U;
  value32 = rtl8723au_read32(Adapter, 48U);
  goto ldv_54268;
  ldv_54267:
  value32 = rtl8723au_read32(Adapter, 48U);
  retry = (u16 )((int )retry + 1);
  ldv_54268: ;
  if ((int )value32 >= 0 && (unsigned int )retry <= 9999U) {
    goto ldv_54267;
  } else {
  }
  __const_udelay(214750UL);
  value32 = rtl8723au_read32(Adapter, 48U);
  *pbuf = (unsigned char )value32;
  return;
}
}
void EFUSE_GetEfuseDefinition23a(struct rtw_adapter *pAdapter , u8 efuseType , u8 type ,
                                 void *pOut )
{
  u8 *pu1Tmp ;
  u16 *pu2Tmp ;
  u8 *pMax_section ;
  {
  switch ((int )type) {
  case 0:
  pMax_section = (u8 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pMax_section = 32U;
  } else {
    *pMax_section = 128U;
  }
  goto ldv_54280;
  case 1:
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 512U;
  } else {
    *pu2Tmp = 1536U;
  }
  goto ldv_54280;
  case 2:
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 497U;
  } else {
    *pu2Tmp = 496U;
  }
  goto ldv_54280;
  case 3:
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 497U;
  } else {
    *pu2Tmp = 1488U;
  }
  goto ldv_54280;
  case 4:
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 256U;
  } else {
    *pu2Tmp = 1024U;
  }
  goto ldv_54280;
  case 5:
  pu1Tmp = (u8 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu1Tmp = 15U;
  } else {
    *pu1Tmp = 16U;
  }
  goto ldv_54280;
  case 6:
  pu2Tmp = (u16 *)pOut;
  if ((unsigned int )efuseType == 0U) {
    *pu2Tmp = 512U;
  } else {
    *pu2Tmp = 512U;
  }
  goto ldv_54280;
  default:
  pu1Tmp = (u8 *)pOut;
  *pu1Tmp = 0U;
  goto ldv_54280;
  }
  ldv_54280: ;
  return;
}
}
u8 EFUSE_Read1Byte23a(struct rtw_adapter *Adapter , u16 Address )
{
  u8 data ;
  u8 Bytetemp ;
  u8 temp ;
  u32 k ;
  u16 contentLen ;
  {
  Bytetemp = 0U;
  temp = 0U;
  k = 0U;
  contentLen = 0U;
  EFUSE_GetEfuseDefinition23a(Adapter, 0, 1, (void *)(& contentLen));
  if ((int )Address < (int )contentLen) {
    temp = (u8 )Address;
    rtl8723au_write8(Adapter, 49U, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 50U);
    temp = (u8 )(((int )((signed char )((int )Address >> 8)) & 3) | ((int )((signed char )Bytetemp) & -4));
    rtl8723au_write8(Adapter, 50U, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 51U);
    temp = (unsigned int )Bytetemp & 127U;
    rtl8723au_write8(Adapter, 51U, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 51U);
    goto ldv_54299;
    ldv_54298:
    Bytetemp = rtl8723au_read8(Adapter, 51U);
    k = k + 1U;
    if (k == 1000U) {
      k = 0U;
      goto ldv_54297;
    } else {
    }
    ldv_54299: ;
    if ((int )((signed char )Bytetemp) >= 0) {
      goto ldv_54298;
    } else {
    }
    ldv_54297:
    data = rtl8723au_read8(Adapter, 48U);
    return (data);
  } else {
    return (255U);
  }
}
}
void EFUSE_Write1Byte(struct rtw_adapter *Adapter , u16 Address , u8 Value ) ;
void EFUSE_Write1Byte(struct rtw_adapter *Adapter , u16 Address , u8 Value )
{
  u8 Bytetemp ;
  u8 temp ;
  u32 k ;
  u16 contentLen ;
  {
  Bytetemp = 0U;
  temp = 0U;
  k = 0U;
  contentLen = 0U;
  EFUSE_GetEfuseDefinition23a(Adapter, 0, 1, (void *)(& contentLen));
  if ((int )Address < (int )contentLen) {
    rtl8723au_write8(Adapter, 48U, (int )Value);
    temp = (u8 )Address;
    rtl8723au_write8(Adapter, 49U, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 50U);
    temp = (u8 )(((int )((signed char )((int )Address >> 8)) & 3) | ((int )((signed char )Bytetemp) & -4));
    rtl8723au_write8(Adapter, 50U, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 51U);
    temp = (u8 )((unsigned int )Bytetemp | 128U);
    rtl8723au_write8(Adapter, 51U, (int )temp);
    Bytetemp = rtl8723au_read8(Adapter, 51U);
    goto ldv_54315;
    ldv_54314:
    Bytetemp = rtl8723au_read8(Adapter, 51U);
    k = k + 1U;
    if (k == 100U) {
      k = 0U;
      goto ldv_54313;
    } else {
    }
    ldv_54315: ;
    if ((int )((signed char )Bytetemp) < 0) {
      goto ldv_54314;
    } else {
    }
    ldv_54313: ;
  } else {
  }
  return;
}
}
int efuse_OneByteRead23a(struct rtw_adapter *pAdapter , u16 addr , u8 *data )
{
  u8 tmpidx ;
  int bResult ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  tmpidx = 0U;
  rtl8723au_write8(pAdapter, 49U, (int )((unsigned char )addr));
  tmp = rtl8723au_read8(pAdapter, 50U);
  rtl8723au_write8(pAdapter, 50U, (int )((u8 )(((int )((signed char )((int )addr >> 8)) & 3) | ((int )((signed char )tmp) & -4))));
  rtl8723au_write8(pAdapter, 51U, 114);
  goto ldv_54324;
  ldv_54323:
  tmpidx = (u8 )((int )tmpidx + 1);
  ldv_54324:
  tmp___0 = rtl8723au_read8(pAdapter, 51U);
  if ((int )((signed char )tmp___0) >= 0 && (unsigned int )tmpidx <= 99U) {
    goto ldv_54323;
  } else {
  }
  if ((unsigned int )tmpidx <= 99U) {
    *data = rtl8723au_read8(pAdapter, 48U);
    bResult = 1;
  } else {
    *data = 255U;
    bResult = 0;
  }
  return (bResult);
}
}
int efuse_OneByteWrite23a(struct rtw_adapter *pAdapter , u16 addr , u8 data )
{
  u8 tmpidx ;
  int bResult ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  tmpidx = 0U;
  rtl8723au_write8(pAdapter, 49U, (int )((unsigned char )addr));
  tmp = rtl8723au_read8(pAdapter, 50U);
  rtl8723au_write8(pAdapter, 50U, (int )((u8 )(((int )((signed char )tmp) & -4) | ((int )((signed char )((int )addr >> 8)) & 3))));
  rtl8723au_write8(pAdapter, 48U, (int )data);
  rtl8723au_write8(pAdapter, 51U, 242);
  goto ldv_54334;
  ldv_54333:
  tmpidx = (u8 )((int )tmpidx + 1);
  ldv_54334:
  tmp___0 = rtl8723au_read8(pAdapter, 51U);
  if ((int )((signed char )tmp___0) < 0 && (unsigned int )tmpidx <= 99U) {
    goto ldv_54333;
  } else {
  }
  if ((unsigned int )tmpidx <= 99U) {
    bResult = 1;
  } else {
    bResult = 0;
  }
  return (bResult);
}
}
void efuse_WordEnableDataRead23a(u8 word_en , u8 *sourdata , u8 *targetdata )
{
  {
  if (((unsigned long )word_en & 1UL) == 0UL) {
    *targetdata = *sourdata;
    *(targetdata + 1UL) = *(sourdata + 1UL);
  } else {
  }
  if (((unsigned long )word_en & 2UL) == 0UL) {
    *(targetdata + 2UL) = *(sourdata + 2UL);
    *(targetdata + 3UL) = *(sourdata + 3UL);
  } else {
  }
  if (((unsigned long )word_en & 4UL) == 0UL) {
    *(targetdata + 4UL) = *(sourdata + 4UL);
    *(targetdata + 5UL) = *(sourdata + 5UL);
  } else {
  }
  if (((unsigned long )word_en & 8UL) == 0UL) {
    *(targetdata + 6UL) = *(sourdata + 6UL);
    *(targetdata + 7UL) = *(sourdata + 7UL);
  } else {
  }
  return;
}
}
static int efuse_read8(struct rtw_adapter *padapter , u16 address , u8 *value )
{
  int tmp ;
  {
  tmp = efuse_OneByteRead23a(padapter, (int )address, value);
  return (tmp);
}
}
static int efuse_write8(struct rtw_adapter *padapter , u16 address , u8 *value )
{
  int tmp ;
  {
  tmp = efuse_OneByteWrite23a(padapter, (int )address, (int )*value);
  return (tmp);
}
}
int rtw_efuse_access23a(struct rtw_adapter *padapter , u8 bWrite , u16 start_addr ,
                        u16 cnts , u8 *data )
{
  int i ;
  u16 real_content_len ;
  u16 max_available_size ;
  int res ;
  int (*rw8)(struct rtw_adapter * , u16 , u8 * ) ;
  u8 *tmp ;
  u16 tmp___0 ;
  {
  i = 0;
  real_content_len = 0U;
  max_available_size = 0U;
  res = 0;
  EFUSE_GetEfuseDefinition23a(padapter, 0, 1, (void *)(& real_content_len));
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& max_available_size));
  if ((int )start_addr > (int )real_content_len) {
    return (0);
  } else {
  }
  if ((unsigned int )bWrite == 1U) {
    if ((int )start_addr + (int )cnts > (int )max_available_size) {
      return (0);
    } else {
    }
    rw8 = & efuse_write8;
  } else {
    rw8 = & efuse_read8;
  }
  Efuse_PowerSwitch(padapter, (int )bWrite, 1);
  i = 0;
  goto ldv_54368;
  ldv_54367: ;
  if ((int )start_addr >= (int )real_content_len) {
    res = 0;
    goto ldv_54366;
  } else {
  }
  tmp = data;
  data = data + 1;
  tmp___0 = start_addr;
  start_addr = (u16 )((int )start_addr + 1);
  res = (*rw8)(padapter, (int )tmp___0, tmp);
  if (res == 0) {
    goto ldv_54366;
  } else {
  }
  i = i + 1;
  ldv_54368: ;
  if ((int )cnts > i) {
    goto ldv_54367;
  } else {
  }
  ldv_54366:
  Efuse_PowerSwitch(padapter, (int )bWrite, 0);
  return (res);
}
}
u16 efuse_GetMaxSize23a(struct rtw_adapter *padapter )
{
  u16 max_size ;
  {
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& max_size));
  return (max_size);
}
}
int efuse_GetCurrentSize23a(struct rtw_adapter *padapter , u16 *size )
{
  {
  Efuse_PowerSwitch(padapter, 0, 1);
  *size = Efuse_GetCurrentSize23a(padapter, 0);
  Efuse_PowerSwitch(padapter, 0, 0);
  return (1);
}
}
int rtw_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts , u8 *data )
{
  u16 mapLen ;
  {
  mapLen = 0U;
  EFUSE_GetEfuseDefinition23a(padapter, 0, 4, (void *)(& mapLen));
  if ((int )addr + (int )cnts > (int )mapLen) {
    return (0);
  } else {
  }
  Efuse_PowerSwitch(padapter, 0, 1);
  rtl8723a_readefuse(padapter, 0, (int )addr, (int )cnts, data);
  Efuse_PowerSwitch(padapter, 0, 0);
  return (1);
}
}
int rtw_BT_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts ,
                             u8 *data )
{
  u16 mapLen ;
  {
  mapLen = 0U;
  EFUSE_GetEfuseDefinition23a(padapter, 1, 4, (void *)(& mapLen));
  if ((int )addr + (int )cnts > (int )mapLen) {
    return (0);
  } else {
  }
  Efuse_PowerSwitch(padapter, 0, 1);
  rtl8723a_readefuse(padapter, 1, (int )addr, (int )cnts, data);
  Efuse_PowerSwitch(padapter, 0, 0);
  return (1);
}
}
void Efuse_ReadAllMap(struct rtw_adapter *pAdapter , u8 efuseType , u8 *Efuse ) ;
void Efuse_ReadAllMap(struct rtw_adapter *pAdapter , u8 efuseType , u8 *Efuse )
{
  u16 mapLen ;
  {
  mapLen = 0U;
  Efuse_PowerSwitch(pAdapter, 0, 1);
  EFUSE_GetEfuseDefinition23a(pAdapter, (int )efuseType, 4, (void *)(& mapLen));
  rtl8723a_readefuse(pAdapter, (int )efuseType, 0, (int )mapLen, Efuse);
  Efuse_PowerSwitch(pAdapter, 0, 0);
  return;
}
}
static void efuse_ShadowRead1Byte(struct rtw_adapter *pAdapter , u16 Offset , u8 *Value )
{
  struct eeprom_priv *pEEPROM ;
  {
  pEEPROM = & pAdapter->eeprompriv;
  *Value = pEEPROM->efuse_eeprom_data[(int )Offset];
  return;
}
}
static void efuse_ShadowRead2Byte(struct rtw_adapter *pAdapter , u16 Offset , u16 *Value )
{
  struct eeprom_priv *pEEPROM ;
  {
  pEEPROM = & pAdapter->eeprompriv;
  *Value = (u16 )pEEPROM->efuse_eeprom_data[(int )Offset];
  *Value = (u16 )((int )((short )*Value) | (int )((short )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 1] << 8)));
  return;
}
}
static void efuse_ShadowRead4Byte(struct rtw_adapter *pAdapter , u16 Offset , u32 *Value )
{
  struct eeprom_priv *pEEPROM ;
  {
  pEEPROM = & pAdapter->eeprompriv;
  *Value = (u32 )pEEPROM->efuse_eeprom_data[(int )Offset];
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 1] << 8);
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 2] << 16);
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 3] << 24);
  return;
}
}
void EFUSE_ShadowMapUpdate23a(struct rtw_adapter *pAdapter , u8 efuseType )
{
  struct eeprom_priv *pEEPROM ;
  u16 mapLen ;
  {
  pEEPROM = & pAdapter->eeprompriv;
  mapLen = 0U;
  EFUSE_GetEfuseDefinition23a(pAdapter, (int )efuseType, 4, (void *)(& mapLen));
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 1U) {
    memset((void *)(& pEEPROM->efuse_eeprom_data), 255, (size_t )mapLen);
  } else {
    Efuse_ReadAllMap(pAdapter, (int )efuseType, (u8 *)(& pEEPROM->efuse_eeprom_data));
  }
  return;
}
}
void EFUSE_ShadowRead23a(struct rtw_adapter *pAdapter , u8 Type , u16 Offset , u32 *Value )
{
  {
  if ((unsigned int )Type == 1U) {
    efuse_ShadowRead1Byte(pAdapter, (int )Offset, (u8 *)Value);
  } else
  if ((unsigned int )Type == 2U) {
    efuse_ShadowRead2Byte(pAdapter, (int )Offset, (u16 *)Value);
  } else
  if ((unsigned int )Type == 4U) {
    efuse_ShadowRead4Byte(pAdapter, (int )Offset, Value);
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_72(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_78(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_80(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_82(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_83(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_84(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_85(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_87(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_88(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
__inline static int list_empty(struct list_head const *head )
{
  {
  return ((unsigned long )((struct list_head const *)head->next) == (unsigned long )head);
}
}
extern int memcmp(void const * , void const * , size_t ) ;
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
int ldv_mod_timer_131(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
void *ldv_kmem_cache_alloc_114(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_122(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_130(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_124(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_120(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_128(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_129(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_125(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_126(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_127(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
extern u8 const *cfg80211_find_ie(u8 , u8 const * , int ) ;
__inline static struct list_head *get_list_head(struct rtw_queue *queue )
{
  {
  return (& queue->queue);
}
}
u16 rtw_mcs_rate23a(u8 rf_type , u8 bw_40MHz , u8 short_GI_20 , u8 short_GI_40 , unsigned char *MCS_rate ) ;
u8 rtl8723a_get_rf_type(struct rtw_adapter *padapter ) ;
int rtw_select_and_join_from_scanned_queue23a(struct mlme_priv *pmlmepriv ) ;
int rtw_set_auth23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ) ;
__inline static int get_fwstate(struct mlme_priv *pmlmepriv )
{
  {
  return (pmlmepriv->fw_state);
}
}
void rtw_generate_random_ibss23a(u8 *pibss ) ;
void rtw_free_assoc_resources23a(struct rtw_adapter *adapter , int lock_scanned_queue ) ;
void rtw_indicate_disconnect23a(struct rtw_adapter *padapter ) ;
void rtw_update_registrypriv_dev_network23a(struct rtw_adapter *adapter ) ;
extern bool rtw_is_scan_deny(struct rtw_adapter * ) ;
int rtw_is_same_ibss23a(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) ;
int rtw_set_802_11_authentication_mode23a(struct rtw_adapter *padapter , enum ndis_802_11_auth_mode authmode ) ;
int rtw_set_802_11_bssid23a_list_scan(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                      int ssid_max_num ) ;
int rtw_set_802_11_ssid23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ) ;
u16 rtw_get_cur_max_rate23a(struct rtw_adapter *adapter ) ;
int rtw_do_join23a(struct rtw_adapter *padapter ) ;
int rtw_do_join23a(struct rtw_adapter *padapter )
{
  struct list_head *plist ;
  struct list_head *phead ;
  u8 *pibss ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *queue ;
  int ret ;
  int select_ret ;
  unsigned long tmp ;
  struct wlan_bssid_ex *pdev_network ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  pibss = (u8 *)0U;
  pmlmepriv = & padapter->mlmepriv;
  queue = & pmlmepriv->scanned_queue;
  ret = 1;
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  phead = get_list_head(queue);
  plist = phead->next;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
    printk("\016\n rtw_do_join23a: phead = %p; plist = %p\n\n\n", phead, plist);
  } else {
  }
  pmlmepriv->cur_network.join_res = -2;
  set_fwstate(pmlmepriv, 128);
  pmlmepriv->to_join = 1U;
  tmp___2 = list_empty((struct list_head const *)(& queue->queue));
  if (tmp___2 != 0) {
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
    _clr_fwstate_(pmlmepriv, 128);
    if (! pmlmepriv->LinkDetectInfo.bBusyTraffic || (unsigned int )padapter->mlmepriv.to_roaming != 0U) {
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
        printk("\016rtw_do_join23a(): site survey if scanned_queue is empty\n.");
      } else {
      }
      ret = rtw_sitesurvey_cmd23a(padapter, & pmlmepriv->assoc_ssid, 1, (struct rtw_ieee80211_channel *)0,
                                  0);
      if (ret != 1) {
        pmlmepriv->to_join = 0U;
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
          printk("\016rtw_do_join23a(): site survey return error\n.");
        } else {
        }
      } else {
      }
    } else {
      pmlmepriv->to_join = 0U;
      ret = 0;
    }
    goto exit;
  } else {
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
    select_ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
    if (select_ret == 1) {
      pmlmepriv->to_join = 0U;
      tmp = msecs_to_jiffies(6500U);
      ldv_mod_timer_131(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
    } else {
      tmp___1 = check_fwstate(pmlmepriv, 32);
      if ((int )tmp___1) {
        pdev_network = & padapter->registrypriv.dev_network;
        pmlmepriv->fw_state = 64;
        pibss = (u8 *)(& padapter->registrypriv.dev_network.MacAddress);
        __len = 33UL;
        if (__len > 63UL) {
          __ret = memcpy((void *)(& pdev_network->Ssid), (void const *)(& pmlmepriv->assoc_ssid),
                           __len);
        } else {
          __ret = memcpy((void *)(& pdev_network->Ssid), (void const *)(& pmlmepriv->assoc_ssid),
                                   __len);
        }
        rtw_update_registrypriv_dev_network23a(padapter);
        rtw_generate_random_ibss23a(pibss);
        tmp___0 = rtw_createbss_cmd23a(padapter);
        if (tmp___0 != 1) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
            printk("\016***Error =>do_goin: rtw_createbss_cmd status FAIL***\n");
          } else {
          }
          ret = 0;
          goto exit;
        } else {
        }
        pmlmepriv->to_join = 0U;
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
          printk("\016***Error => rtw_select_and_join_from_scanned_queue FAIL under STA_Mode***\n ");
        } else {
        }
      } else {
        _clr_fwstate_(pmlmepriv, 128);
        if (! pmlmepriv->LinkDetectInfo.bBusyTraffic || (unsigned int )padapter->mlmepriv.to_roaming != 0U) {
          ret = rtw_sitesurvey_cmd23a(padapter, & pmlmepriv->assoc_ssid, 1, (struct rtw_ieee80211_channel *)0,
                                      0);
          if (ret != 1) {
            pmlmepriv->to_join = 0U;
            if (GlobalDebugLevel23A > 3U) {
              printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
              printk("\016do_join(): site survey return error\n.");
            } else {
            }
          } else {
          }
        } else {
          ret = 0;
          pmlmepriv->to_join = 0U;
        }
      }
    }
  }
  exit: ;
  return (ret);
}
}
int rtw_set_802_11_ssid23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid )
{
  int status ;
  u32 cur_time ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  bool tmp___12 ;
  size_t __len ;
  void *__ret ;
  bool tmp___13 ;
  {
  status = 1;
  cur_time = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pnetwork = & pmlmepriv->cur_network;
  if (GlobalDebugLevel23A != 0U) {
    tmp = get_fwstate(pmlmepriv);
    printk("\016RTL8723AU: OLD_ERROR set ssid [%s] fw_state = 0x%08x\n", (u8 *)(& ssid->ssid),
           tmp);
  } else {
  }
  if ((unsigned int )padapter->hw_init_completed == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
      printk("\016set_ssid: hw_init_completed == false =>exit!!!\n");
    } else {
    }
    status = 0;
    goto exit;
  } else {
  }
  spin_lock_bh(& pmlmepriv->lock);
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = get_fwstate(pmlmepriv);
    printk("\016RTL8723AU: Set SSID under fw_state = 0x%08x\n", tmp___0);
  } else {
  }
  tmp___2 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___2) {
    goto handle_tkip_countermeasure;
  } else {
    tmp___1 = check_fwstate(pmlmepriv, 128);
    if ((int )tmp___1) {
      goto release_mlme_lock;
    } else {
    }
  }
  tmp___12 = check_fwstate(pmlmepriv, 65);
  if ((int )tmp___12) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
      printk("\016set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n");
    } else {
    }
    if ((int )pmlmepriv->assoc_ssid.ssid_len == (int )ssid->ssid_len) {
      tmp___11 = memcmp((void const *)(& pmlmepriv->assoc_ssid.ssid), (void const *)(& ssid->ssid),
                        (size_t )ssid->ssid_len);
      if (tmp___11 == 0) {
        tmp___7 = check_fwstate(pmlmepriv, 8);
        if (tmp___7) {
          tmp___8 = 0;
        } else {
          tmp___8 = 1;
        }
        if (tmp___8) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
            tmp___3 = get_fwstate(pmlmepriv);
            printk("\016Set SSID is the same ssid, fw_state = 0x%08x\n", tmp___3);
          } else {
          }
          tmp___6 = rtw_is_same_ibss23a(padapter, pnetwork);
          if (tmp___6 == 0) {
            rtw_disassoc_cmd23a(padapter, 0U, 1);
            tmp___4 = check_fwstate(pmlmepriv, 1);
            if ((int )tmp___4) {
              rtw_indicate_disconnect23a(padapter);
            } else {
            }
            rtw_free_assoc_resources23a(padapter, 1);
            tmp___5 = check_fwstate(pmlmepriv, 64);
            if ((int )tmp___5) {
              _clr_fwstate_(pmlmepriv, 64);
              set_fwstate(pmlmepriv, 32);
            } else {
            }
          } else {
            goto release_mlme_lock;
          }
        } else {
          rtw_lps_ctrl_wk_cmd23a(padapter, 1, 1);
        }
      } else {
        goto _L;
      }
    } else {
      _L:
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
        printk("\016Set SSID not the same ssid\n");
      } else {
      }
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
        printk("\016set_ssid =[%s] len = 0x%x\n", (u8 *)(& ssid->ssid), (unsigned int )ssid->ssid_len);
      } else {
      }
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
        printk("\016assoc_ssid =[%s] len = 0x%x\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid),
               (unsigned int )pmlmepriv->assoc_ssid.ssid_len);
      } else {
      }
      rtw_disassoc_cmd23a(padapter, 0U, 1);
      tmp___9 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___9) {
        rtw_indicate_disconnect23a(padapter);
      } else {
      }
      rtw_free_assoc_resources23a(padapter, 1);
      tmp___10 = check_fwstate(pmlmepriv, 64);
      if ((int )tmp___10) {
        _clr_fwstate_(pmlmepriv, 64);
        set_fwstate(pmlmepriv, 32);
      } else {
      }
    }
  } else {
  }
  handle_tkip_countermeasure: ;
  if ((unsigned int )padapter->securitypriv.btkip_countermeasure == 1U) {
    cur_time = (u32 )jiffies;
    if ((unsigned long )cur_time - padapter->securitypriv.btkip_countermeasure_time > 15000UL) {
      padapter->securitypriv.btkip_countermeasure = 0U;
      padapter->securitypriv.btkip_countermeasure_time = 0UL;
    } else {
      status = 0;
      goto release_mlme_lock;
    }
  } else {
  }
  __len = 33UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pmlmepriv->assoc_ssid), (void const *)ssid, __len);
  } else {
    __ret = memcpy((void *)(& pmlmepriv->assoc_ssid), (void const *)ssid,
                             __len);
  }
  pmlmepriv->assoc_by_bssid = 0U;
  tmp___13 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___13) {
    pmlmepriv->to_join = 1U;
  } else {
    status = rtw_do_join23a(padapter);
  }
  release_mlme_lock:
  spin_unlock_bh(& pmlmepriv->lock);
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
    printk("\016-rtw_set_802_11_ssid23a: status =%d\n", status);
  } else {
  }
  return (status);
}
}
int rtw_set_802_11_bssid23a_list_scan(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                      int ssid_max_num )
{
  struct mlme_priv *pmlmepriv ;
  int res ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  res = 1;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
    tmp = get_fwstate(pmlmepriv);
    printk("\016+rtw_set_802_11_bssid23a_list_scan(), fw_state =%x\n", tmp);
  } else {
  }
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  if ((unsigned int )padapter->hw_init_completed == 0U) {
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
      printk("\016\n === rtw_set_802_11_bssid23a_list_scan:hw_init_completed == false ===\n");
    } else {
    }
    goto exit;
  } else {
  }
  tmp___3 = check_fwstate(pmlmepriv, 2176);
  if ((int )tmp___3 || (int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
      tmp___0 = get_fwstate(pmlmepriv);
      printk("\016rtw_set_802_11_bssid23a_list_scan fail since fw_state = %x\n", tmp___0);
    } else {
    }
    tmp___1 = check_fwstate(pmlmepriv, 2176);
    if ((int )tmp___1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
        printk("\016\n###_FW_UNDER_SURVEY|_FW_UNDER_LINKING\n");
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
      printk("\016\n###pmlmepriv->sitesurveyctrl.traffic_busy == true\n");
    } else {
    }
  } else {
    tmp___2 = rtw_is_scan_deny(padapter);
    if ((int )tmp___2) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(%s): scan deny\n", "rtw_set_802_11_bssid23a_list_scan",
               (char *)(& (padapter->pnetdev)->name));
      } else {
      }
      return (1);
    } else {
    }
    spin_lock_bh(& pmlmepriv->lock);
    res = rtw_sitesurvey_cmd23a(padapter, pssid, ssid_max_num, (struct rtw_ieee80211_channel *)0,
                                0);
    spin_unlock_bh(& pmlmepriv->lock);
  }
  exit: ;
  return (res);
}
}
int rtw_set_802_11_authentication_mode23a(struct rtw_adapter *padapter , enum ndis_802_11_auth_mode authmode )
{
  struct security_priv *psecuritypriv ;
  int res ;
  {
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
    printk("\016set_802_11_auth.mode(): mode =%x\n", (unsigned int )authmode);
  } else {
  }
  psecuritypriv->ndisauthtype = (u32 )authmode;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
    printk("\016rtw_set_802_11_authentication_mode23a:psecuritypriv->ndisauthtype =%d",
           psecuritypriv->ndisauthtype);
  } else {
  }
  if (psecuritypriv->ndisauthtype > 3U) {
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else {
  }
  res = rtw_set_auth23a(padapter, psecuritypriv);
  return (res);
}
}
u16 rtw_get_cur_max_rate23a(struct rtw_adapter *adapter )
{
  int i ;
  u8 const *p ;
  u16 rate ;
  u16 max_rate ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct registry_priv *pregistrypriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_bss ;
  struct ieee80211_ht_cap *pht_capie ;
  u8 rf_type ;
  u8 bw_40MHz ;
  u8 short_GI_20 ;
  u8 short_GI_40 ;
  u16 mcs_rate ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;
  {
  i = 0;
  rate = 0U;
  max_rate = 0U;
  pmlmeext = & adapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pregistrypriv = & adapter->registrypriv;
  pmlmepriv = & adapter->mlmepriv;
  pcur_bss = & pmlmepriv->cur_network.network;
  rf_type = 0U;
  bw_40MHz = 0U;
  short_GI_20 = 0U;
  short_GI_40 = 0U;
  mcs_rate = 0U;
  tmp = check_fwstate(pmlmepriv, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    tmp___1 = check_fwstate(pmlmepriv, 64);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      return (0U);
    } else {
    }
  } else {
  }
  if (((int )pmlmeext->cur_wireless_mode & 24) != 0) {
    p = cfg80211_find_ie(45, (u8 const *)(& pcur_bss->IEs) + 12U, (int )(pcur_bss->IELength - 12U));
    if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      pht_capie = (struct ieee80211_ht_cap *)p + 2U;
      __len = 2UL;
      if (__len > 63UL) {
        __ret = memcpy((void *)(& mcs_rate), (void const *)(& pht_capie->mcs),
                         __len);
      } else {
        __ret = memcpy((void *)(& mcs_rate), (void const *)(& pht_capie->mcs),
                                 __len);
      }
      bw_40MHz = (u8 )((unsigned int )pmlmeext->cur_bwmode != 0U && ((unsigned int )pmlmeinfo->HT_info.infos[0] & 4U) != 0U);
      short_GI_20 = ((int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 32) != 0;
      short_GI_40 = ((int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 64) != 0;
      rf_type = rtl8723a_get_rf_type(adapter);
      max_rate = rtw_mcs_rate23a((int )rf_type, (int )pregistrypriv->cbw40_enable & (int )bw_40MHz,
                                 (int )short_GI_20, (int )short_GI_40, (unsigned char *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate));
    } else {
    }
  } else {
    goto ldv_51560;
    ldv_51559:
    rate = (unsigned int )((u16 )pcur_bss->SupportedRates[i]) & 127U;
    if ((int )rate > (int )max_rate) {
      max_rate = rate;
    } else {
    }
    i = i + 1;
    ldv_51560: ;
    if ((unsigned int )pcur_bss->SupportedRates[i] != 0U && (unsigned int )pcur_bss->SupportedRates[i] != 255U) {
      goto ldv_51559;
    } else {
    }
    max_rate = (u16 )(((int )max_rate * 10) / 2);
  }
  return (max_rate);
}
}
void *ldv_kmem_cache_alloc_114(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_120(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_122(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_124(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_125(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_126(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_127(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_128(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_129(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_130(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_mod_timer_131(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static __u16 __fswab16(__u16 val )
{
  {
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
__inline static __u16 __swab16p(__u16 const *p )
{
  __u16 tmp ;
  {
  tmp = __fswab16((int )*p);
  return (tmp);
}
}
__inline static __u16 __le16_to_cpup(__le16 const *p )
{
  {
  return ((__u16 )*p);
}
}
__inline static __u16 __be16_to_cpup(__be16 const *p )
{
  __u16 tmp ;
  {
  tmp = __swab16p(p);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_158(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_166(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_174(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_168(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_164(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_173(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_169(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_170(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_171(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
__inline static u16 get_unaligned_le16(void const *p )
{
  __u16 tmp ;
  {
  tmp = __le16_to_cpup((__le16 const *)p);
  return (tmp);
}
}
__inline static u16 get_unaligned_be16(void const *p )
{
  __u16 tmp ;
  {
  tmp = __be16_to_cpup((__be16 const *)p);
  return (tmp);
}
}
extern u8 const *cfg80211_find_vendor_ie(unsigned int , u8 , u8 const * , int ) ;
u8 RTW_WPA_OUI23A_TYPE[4U] ;
u16 RTW_WPA_VERSION23A ;
u8 WPA_AUTH_KEY_MGMT_NONE23A[4U] ;
u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] ;
u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] ;
u8 WPA_CIPHER_SUITE_NONE23A[4U] ;
u8 WPA_CIPHER_SUITE_WEP4023A[4U] ;
u8 WPA_CIPHER_SUITE_TKIP23A[4U] ;
u8 WPA_CIPHER_SUITE_WRAP23A[4U] ;
u8 WPA_CIPHER_SUITE_CCMP23A[4U] ;
u8 WPA_CIPHER_SUITE_WEP10423A[4U] ;
u16 RSN_VERSION_BSD23A ;
u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] ;
u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] ;
u8 RSN_CIPHER_SUITE_NONE23A[4U] ;
u8 RSN_CIPHER_SUITE_WEP4023A[4U] ;
u8 RSN_CIPHER_SUITE_TKIP23A[4U] ;
u8 RSN_CIPHER_SUITE_WRAP23A[4U] ;
u8 RSN_CIPHER_SUITE_CCMP23A[4U] ;
u8 RSN_CIPHER_SUITE_WEP10423A[4U] ;
u8 *rtw_set_fixed_ie23a(unsigned char *pbuf , unsigned int len , unsigned char *source ,
                        unsigned int *frlen ) ;
u8 *rtw_set_ie23a(u8 *pbuf , int index , uint len , u8 const *source , uint *frlen ) ;
u8 *rtw_get_ie23a(u8 *pbuf , int index , int *len , int limit ) ;
u8 *rtw_get_ie23a_ex(u8 *in_ie , uint in_len , u8 eid , u8 *oui , u8 oui_len , u8 *ie ,
                     uint *ielen ) ;
int rtw_ies_remove_ie23a(u8 *ies , uint *ies_len , uint offset , u8 eid , u8 *oui ,
                         u8 oui_len ) ;
void rtw_set_supported_rate23a(u8 *SupportedRates , uint mode ) ;
int rtw_get_wpa_cipher_suite23a(u8 const *s ) ;
int rtw_get_wpa2_cipher_suite23a(u8 const *s ) ;
int rtw_parse_wpa_ie23a(u8 const *wpa_ie , int wpa_ie_len , int *group_cipher ,
                        int *pairwise_cipher , int *is_8021x ) ;
int rtw_parse_wpa2_ie23a(u8 const *rsn_ie , int rsn_ie_len , int *group_cipher ,
                         int *pairwise_cipher , int *is_8021x ) ;
int rtw_get_sec_ie23a(u8 *in_ie , uint in_len , u8 *rsn_ie , u16 *rsn_len , u8 *wpa_ie ,
                      u16 *wpa_len ) ;
u8 *rtw_get_wps_ie23a(u8 *in_ie , uint in_len , u8 *wps_ie , uint *wps_ielen ) ;
u8 *rtw_get_wps_attr23a(u8 *wps_ie , uint wps_ielen , u16 target_attr_id , u8 *buf_attr ,
                        u32 *len_attr ) ;
u8 *rtw_get_wps_attr_content23a(u8 *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                u8 *buf_content , uint *len_content ) ;
uint rtw_get_rateset_len23a(u8 *rateset ) ;
int rtw_generate_ie23a(struct registry_priv *pregistrypriv ) ;
int rtw_get_bit_value_from_ieee_value23a(u8 val ) ;
int rtw_check_network_type23a(unsigned char *rate , int ratelen , int channel ) ;
void rtw_get_bcn_info23a(struct wlan_network *pnetwork ) ;
char const *action_public_str23a(u8 action ) ;
__le16 *rtw_get_capability23a_from_ie(u8 *ie ) ;
u8 RTW_WPA_OUI23A_TYPE[4U] = { 0U, 80U, 242U, 1U};
u16 RTW_WPA_VERSION23A = 1U;
u8 WPA_AUTH_KEY_MGMT_NONE23A[4U] = { 0U, 80U, 242U, 0U};
u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] = { 0U, 80U, 242U, 1U};
u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] = { 0U, 80U, 242U, 2U};
u8 WPA_CIPHER_SUITE_NONE23A[4U] = { 0U, 80U, 242U, 0U};
u8 WPA_CIPHER_SUITE_WEP4023A[4U] = { 0U, 80U, 242U, 1U};
u8 WPA_CIPHER_SUITE_TKIP23A[4U] = { 0U, 80U, 242U, 2U};
u8 WPA_CIPHER_SUITE_WRAP23A[4U] = { 0U, 80U, 242U, 3U};
u8 WPA_CIPHER_SUITE_CCMP23A[4U] = { 0U, 80U, 242U, 4U};
u8 WPA_CIPHER_SUITE_WEP10423A[4U] = { 0U, 80U, 242U, 5U};
u16 RSN_VERSION_BSD23A = 1U;
u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] = { 0U, 15U, 172U, 1U};
u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] = { 0U, 15U, 172U, 2U};
u8 RSN_CIPHER_SUITE_NONE23A[4U] = { 0U, 15U, 172U, 0U};
u8 RSN_CIPHER_SUITE_WEP4023A[4U] = { 0U, 15U, 172U, 1U};
u8 RSN_CIPHER_SUITE_TKIP23A[4U] = { 0U, 15U, 172U, 2U};
u8 RSN_CIPHER_SUITE_WRAP23A[4U] = { 0U, 15U, 172U, 3U};
u8 RSN_CIPHER_SUITE_CCMP23A[4U] = { 0U, 15U, 172U, 4U};
u8 RSN_CIPHER_SUITE_WEP10423A[4U] = { 0U, 15U, 172U, 5U};
static u8 WIFI_CCKRATES[4U] = { 130U, 132U, 139U, 150U};
static u8 WIFI_OFDMRATES[8U] =
  { 12U, 18U, 24U, 36U,
        48U, 72U, 96U, 108U};
int rtw_get_bit_value_from_ieee_value23a(u8 val )
{
  unsigned char dot11_rate_table[13U] ;
  int i ;
  {
  dot11_rate_table[0] = 2U;
  dot11_rate_table[1] = 4U;
  dot11_rate_table[2] = 11U;
  dot11_rate_table[3] = 22U;
  dot11_rate_table[4] = 12U;
  dot11_rate_table[5] = 18U;
  dot11_rate_table[6] = 24U;
  dot11_rate_table[7] = 36U;
  dot11_rate_table[8] = 48U;
  dot11_rate_table[9] = 72U;
  dot11_rate_table[10] = 96U;
  dot11_rate_table[11] = 108U;
  dot11_rate_table[12] = 0U;
  i = 0;
  goto ldv_51435;
  ldv_51434: ;
  if ((int )dot11_rate_table[i] == (int )val) {
    return ((int )(1UL << i));
  } else {
  }
  i = i + 1;
  ldv_51435: ;
  if ((unsigned int )dot11_rate_table[i] != 0U) {
    goto ldv_51434;
  } else {
  }
  return (0);
}
}
static bool rtw_is_cckrates_included(u8 *rate )
{
  u32 i ;
  {
  i = 0U;
  goto ldv_51442;
  ldv_51441: ;
  if (((((int )*(rate + (unsigned long )i) & 127) == 2 || ((int )*(rate + (unsigned long )i) & 127) == 4) || ((int )*(rate + (unsigned long )i) & 127) == 11) || ((int )*(rate + (unsigned long )i) & 127) == 22) {
    return (1);
  } else {
  }
  i = i + 1U;
  ldv_51442: ;
  if ((unsigned int )*(rate + (unsigned long )i) != 0U) {
    goto ldv_51441;
  } else {
  }
  return (0);
}
}
static bool rtw_is_cckratesonly_included(u8 *rate )
{
  u32 i ;
  {
  i = 0U;
  goto ldv_51449;
  ldv_51448: ;
  if (((((int )*(rate + (unsigned long )i) & 127) != 2 && ((int )*(rate + (unsigned long )i) & 127) != 4) && ((int )*(rate + (unsigned long )i) & 127) != 11) && ((int )*(rate + (unsigned long )i) & 127) != 22) {
    return (0);
  } else {
  }
  i = i + 1U;
  ldv_51449: ;
  if ((unsigned int )*(rate + (unsigned long )i) != 0U) {
    goto ldv_51448;
  } else {
  }
  return (1);
}
}
int rtw_check_network_type23a(unsigned char *rate , int ratelen , int channel )
{
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  if (channel > 14) {
    tmp = rtw_is_cckrates_included(rate);
    if ((int )tmp) {
      return (0);
    } else {
      return (4);
    }
  } else {
    tmp___1 = rtw_is_cckratesonly_included(rate);
    if ((int )tmp___1) {
      return (1);
    } else {
      tmp___0 = rtw_is_cckrates_included(rate);
      if ((int )tmp___0) {
        return (3);
      } else {
        return (2);
      }
    }
  }
}
}
u8 *rtw_set_fixed_ie23a(unsigned char *pbuf , unsigned int len , unsigned char *source ,
                        unsigned int *frlen )
{
  size_t __len ;
  void *__ret ;
  {
  __len = (size_t )len;
  __ret = memcpy((void *)pbuf, (void const *)source, __len);
  *frlen = *frlen + len;
  return (pbuf + (unsigned long )len);
}
}
u8 *rtw_set_ie23a(u8 *pbuf , int index , uint len , u8 const *source , uint *frlen )
{
  size_t __len ;
  void *__ret ;
  {
  *pbuf = (unsigned char )index;
  *(pbuf + 1UL) = (unsigned char )len;
  if (len != 0U) {
    __len = (size_t )len;
    __ret = memcpy((void *)pbuf + 2U, (void const *)source, __len);
  } else {
  }
  *frlen = (*frlen + len) + 2U;
  return (pbuf + ((unsigned long )len + 2UL));
}
}
u8 *rtw_get_ie23a(u8 *pbuf , int index , int *len , int limit )
{
  int tmp ;
  int i ;
  u8 *p ;
  {
  if (limit <= 0) {
    return ((u8 *)0U);
  } else {
  }
  p = pbuf;
  i = 0;
  *len = 0;
  ldv_51501: ;
  if ((int )*p == index) {
    *len = (int )*(p + 1UL);
    return (p);
  } else {
    tmp = (int )*(p + 1UL);
    p = p + ((unsigned long )tmp + 2UL);
    i = (tmp + 2) + i;
  }
  if (i >= limit) {
    goto ldv_51500;
  } else {
  }
  goto ldv_51501;
  ldv_51500: ;
  return ((u8 *)0U);
}
}
u8 *rtw_get_ie23a_ex(u8 *in_ie , uint in_len , u8 eid , u8 *oui , u8 oui_len , u8 *ie ,
                     uint *ielen )
{
  uint cnt ;
  u8 *target_ie ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  {
  target_ie = (u8 *)0U;
  if ((unsigned long )ielen != (unsigned long )((uint *)0U)) {
    *ielen = 0U;
  } else {
  }
  if ((unsigned long )in_ie == (unsigned long )((u8 *)0U) || in_len == 0U) {
    return (target_ie);
  } else {
  }
  cnt = 0U;
  goto ldv_51518;
  ldv_51517: ;
  if ((int )*(in_ie + (unsigned long )cnt) == (int )eid) {
    if ((unsigned long )oui == (unsigned long )((u8 *)0U)) {
      goto _L;
    } else {
      tmp = memcmp((void const *)in_ie + (unsigned long )(cnt + 2U), (void const *)oui,
                   (size_t )oui_len);
      if (tmp == 0) {
        _L:
        target_ie = in_ie + (unsigned long )cnt;
        if ((unsigned long )ie != (unsigned long )((u8 *)0U)) {
          __len = (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
          __ret = memcpy((void *)ie, (void const *)in_ie + (unsigned long )cnt,
                                   __len);
        } else {
        }
        if ((unsigned long )ielen != (unsigned long )((uint *)0U)) {
          *ielen = (uint )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
        } else {
        }
        goto ldv_51516;
      } else {
        cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
      }
    }
  } else {
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  }
  ldv_51518: ;
  if (cnt < in_len) {
    goto ldv_51517;
  } else {
  }
  ldv_51516: ;
  return (target_ie);
}
}
int rtw_ies_remove_ie23a(u8 *ies , uint *ies_len , uint offset , u8 eid , u8 *oui ,
                         u8 oui_len )
{
  int ret ;
  u8 *target_ie ;
  u32 target_ielen ;
  u8 *start ;
  uint search_len ;
  u8 buf[768U] ;
  unsigned int tmp ;
  u8 *remain_ies ;
  uint remain_len ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  ret = 0;
  if (((unsigned long )ies == (unsigned long )((u8 *)0U) || (unsigned long )ies_len == (unsigned long )((uint *)0U)) || *ies_len <= offset) {
    goto exit;
  } else {
  }
  start = ies + (unsigned long )offset;
  search_len = *ies_len - offset;
  ldv_51543:
  target_ie = rtw_get_ie23a_ex(start, search_len, (int )eid, oui, (int )oui_len, (u8 *)0U,
                               & target_ielen);
  if ((unsigned long )target_ie != (unsigned long )((u8 *)0U) && target_ielen != 0U) {
    buf[0] = 0U;
    tmp = 1U;
    while (1) {
      if (tmp >= 768U) {
        break;
      } else {
      }
      buf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    remain_ies = target_ie + (unsigned long )target_ielen;
    remain_len = ((uint )((long )start) - (uint )((long )remain_ies)) + search_len;
    __len = (size_t )remain_len;
    __ret = memcpy((void *)(& buf), (void const *)remain_ies, __len);
    __len___0 = (size_t )remain_len;
    __ret___0 = memcpy((void *)target_ie, (void const *)(& buf), __len___0);
    *ies_len = *ies_len - target_ielen;
    ret = 1;
    start = target_ie;
    search_len = remain_len;
  } else {
    goto ldv_51542;
  }
  goto ldv_51543;
  ldv_51542: ;
  exit: ;
  return (ret);
}
}
void rtw_set_supported_rate23a(u8 *SupportedRates , uint mode )
{
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  {
  memset((void *)SupportedRates, 0, 16UL);
  switch (mode) {
  case 1U:
  __len = 4UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)SupportedRates, (void const *)(& WIFI_CCKRATES), __len);
  } else {
    __ret = memcpy((void *)SupportedRates, (void const *)(& WIFI_CCKRATES),
                             __len);
  }
  goto ldv_51552;
  case 2U: ;
  case 4U: ;
  case 16U: ;
  case 20U:
  __len___0 = 8UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)SupportedRates, (void const *)(& WIFI_OFDMRATES),
                         __len___0);
  } else {
    __ret___0 = memcpy((void *)SupportedRates, (void const *)(& WIFI_OFDMRATES),
                                 __len___0);
  }
  goto ldv_51552;
  case 3U: ;
  case 10U: ;
  case 8U: ;
  case 11U:
  __len___1 = 4UL;
  if (__len___1 > 63UL) {
    __ret___1 = memcpy((void *)SupportedRates, (void const *)(& WIFI_CCKRATES),
                         __len___1);
  } else {
    __ret___1 = memcpy((void *)SupportedRates, (void const *)(& WIFI_CCKRATES),
                                 __len___1);
  }
  __len___2 = 8UL;
  if (__len___2 > 63UL) {
    __ret___2 = memcpy((void *)SupportedRates + 4U, (void const *)(& WIFI_OFDMRATES),
                         __len___2);
  } else {
    __ret___2 = memcpy((void *)SupportedRates + 4U, (void const *)(& WIFI_OFDMRATES),
                                 __len___2);
  }
  goto ldv_51552;
  }
  ldv_51552: ;
  return;
}
}
uint rtw_get_rateset_len23a(u8 *rateset )
{
  uint i ;
  {
  i = 0U;
  ldv_51575: ;
  if ((unsigned int )*(rateset + (unsigned long )i) == 0U) {
    goto ldv_51574;
  } else {
  }
  if (i > 12U) {
    goto ldv_51574;
  } else {
  }
  i = i + 1U;
  goto ldv_51575;
  ldv_51574: ;
  return (i);
}
}
int rtw_generate_ie23a(struct registry_priv *pregistrypriv )
{
  u8 wireless_mode ;
  int sz ;
  int rateLen ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *ie ;
  uint tmp ;
  {
  sz = 0;
  pdev_network = & pregistrypriv->dev_network;
  ie = (u8 *)(& pdev_network->IEs);
  sz = sz + 8;
  ie = ie + (unsigned long )sz;
  *((u16 *)ie) = pdev_network->BeaconPeriod;
  sz = sz + 2;
  ie = ie + 2UL;
  *((u16 *)ie) = 0U;
  *((u16 *)ie) = (u16 )((unsigned int )*((u16 *)ie) | 2U);
  if ((unsigned int )pregistrypriv->preamble == 3U) {
    *((u16 *)ie) = (u16 )((unsigned int )*((u16 *)ie) | 32U);
  } else {
  }
  if (pdev_network->Privacy != 0U) {
    *((u16 *)ie) = (u16 )((unsigned int )*((u16 *)ie) | 16U);
  } else {
  }
  sz = sz + 2;
  ie = ie + 2UL;
  ie = rtw_set_ie23a(ie, 0, (uint )pdev_network->Ssid.ssid_len, (u8 const *)(& pdev_network->Ssid.ssid),
                     (uint *)(& sz));
  if ((unsigned int )pregistrypriv->wireless_mode == 31U) {
    if (pdev_network->DSConfig > 14U) {
      wireless_mode = 20U;
    } else {
      wireless_mode = 11U;
    }
  } else {
    wireless_mode = pregistrypriv->wireless_mode;
  }
  rtw_set_supported_rate23a((u8 *)(& pdev_network->SupportedRates), (uint )wireless_mode);
  tmp = rtw_get_rateset_len23a((u8 *)(& pdev_network->SupportedRates));
  rateLen = (int )tmp;
  if (rateLen > 8) {
    ie = rtw_set_ie23a(ie, 1, 8U, (u8 const *)(& pdev_network->SupportedRates),
                       (uint *)(& sz));
  } else {
    ie = rtw_set_ie23a(ie, 1, (uint )rateLen, (u8 const *)(& pdev_network->SupportedRates),
                       (uint *)(& sz));
  }
  ie = rtw_set_ie23a(ie, 3, 1U, (u8 const *)(& pdev_network->DSConfig), (uint *)(& sz));
  ie = rtw_set_ie23a(ie, 6, 2U, (u8 const *)(& pdev_network->ATIMWindow), (uint *)(& sz));
  if (rateLen > 8) {
    ie = rtw_set_ie23a(ie, 50, (uint )(rateLen + -8), (u8 const *)(& pdev_network->SupportedRates) + 8U,
                       (uint *)(& sz));
  } else {
  }
  return (sz);
}
}
int rtw_get_wpa_cipher_suite23a(u8 const *s )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  tmp = memcmp((void const *)s, (void const *)(& WPA_CIPHER_SUITE_NONE23A), 4UL);
  if (tmp == 0) {
    return (1);
  } else {
  }
  tmp___0 = memcmp((void const *)s, (void const *)(& WPA_CIPHER_SUITE_WEP4023A),
                   4UL);
  if (tmp___0 == 0) {
    return (2);
  } else {
  }
  tmp___1 = memcmp((void const *)s, (void const *)(& WPA_CIPHER_SUITE_TKIP23A),
                   4UL);
  if (tmp___1 == 0) {
    return (8);
  } else {
  }
  tmp___2 = memcmp((void const *)s, (void const *)(& WPA_CIPHER_SUITE_CCMP23A),
                   4UL);
  if (tmp___2 == 0) {
    return (16);
  } else {
  }
  tmp___3 = memcmp((void const *)s, (void const *)(& WPA_CIPHER_SUITE_WEP10423A),
                   4UL);
  if (tmp___3 == 0) {
    return (4);
  } else {
  }
  return (0);
}
}
int rtw_get_wpa2_cipher_suite23a(u8 const *s )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  tmp = memcmp((void const *)s, (void const *)(& RSN_CIPHER_SUITE_NONE23A), 4UL);
  if (tmp == 0) {
    return (1);
  } else {
  }
  tmp___0 = memcmp((void const *)s, (void const *)(& RSN_CIPHER_SUITE_WEP4023A),
                   4UL);
  if (tmp___0 == 0) {
    return (2);
  } else {
  }
  tmp___1 = memcmp((void const *)s, (void const *)(& RSN_CIPHER_SUITE_TKIP23A),
                   4UL);
  if (tmp___1 == 0) {
    return (8);
  } else {
  }
  tmp___2 = memcmp((void const *)s, (void const *)(& RSN_CIPHER_SUITE_CCMP23A),
                   4UL);
  if (tmp___2 == 0) {
    return (16);
  } else {
  }
  tmp___3 = memcmp((void const *)s, (void const *)(& RSN_CIPHER_SUITE_WEP10423A),
                   4UL);
  if (tmp___3 == 0) {
    return (4);
  } else {
  }
  return (0);
}
}
int rtw_parse_wpa_ie23a(u8 const *wpa_ie , int wpa_ie_len , int *group_cipher ,
                        int *pairwise_cipher , int *is_8021x )
{
  int i ;
  int ret ;
  int left ;
  int count ;
  u8 const *pos ;
  u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  ret = 1;
  if (wpa_ie_len <= 0) {
    return (0);
  } else {
  }
  if ((unsigned int )((unsigned char )*(wpa_ie + 1UL)) != (unsigned int )((unsigned char )wpa_ie_len) - 2U) {
    return (0);
  } else {
  }
  pos = wpa_ie;
  pos = pos + 8UL;
  left = wpa_ie_len + -8;
  if (left > 3) {
    *group_cipher = rtw_get_wpa_cipher_suite23a(pos);
    pos = pos + 4UL;
    left = left + -4;
  } else
  if (left > 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016%s: ie length mismatch, %u too much", "rtw_parse_wpa_ie23a", left);
    } else {
    }
    return (0);
  } else {
  }
  if (left > 1) {
    tmp = get_unaligned_le16((void const *)pos);
    count = (int )tmp;
    pos = pos + 2UL;
    left = left + -2;
    if (count == 0 || count * 4 > left) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
        printk("\016%s: ie count botch (pairwise), count %u left %u", "rtw_parse_wpa_ie23a",
               count, left);
      } else {
      }
      return (0);
    } else {
    }
    i = 0;
    goto ldv_51604;
    ldv_51603:
    tmp___0 = rtw_get_wpa_cipher_suite23a(pos);
    *pairwise_cipher = *pairwise_cipher | tmp___0;
    pos = pos + 4UL;
    left = left + -4;
    i = i + 1;
    ldv_51604: ;
    if (i < count) {
      goto ldv_51603;
    } else {
    }
  } else
  if (left == 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016%s: ie too short (for key mgmt)", "rtw_parse_wpa_ie23a");
    } else {
    }
    return (0);
  } else {
  }
  if ((unsigned long )is_8021x != (unsigned long )((int *)0)) {
    if (left > 5) {
      pos = pos + 2UL;
      tmp___1 = memcmp((void const *)pos, (void const *)(& RTW_WPA_OUI23A_TYPE),
                       4UL);
      if (tmp___1 == 0) {
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
          printk("\016%s : there has 802.1x auth\n", "rtw_parse_wpa_ie23a");
        } else {
        }
        *is_8021x = 1;
      } else {
      }
    } else {
    }
  } else {
  }
  return (ret);
}
}
int rtw_parse_wpa2_ie23a(u8 const *rsn_ie , int rsn_ie_len , int *group_cipher ,
                         int *pairwise_cipher , int *is_8021x )
{
  int i ;
  int ret ;
  int left ;
  int count ;
  u8 const *pos ;
  u8 SUITE_1X[4U] ;
  u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  ret = 1;
  SUITE_1X[0] = 0U;
  SUITE_1X[1] = 15U;
  SUITE_1X[2] = 172U;
  SUITE_1X[3] = 1U;
  if (rsn_ie_len <= 0) {
    return (0);
  } else {
  }
  if ((unsigned int )((unsigned char )*rsn_ie) != 48U || (unsigned int )((unsigned char )*(rsn_ie + 1UL)) != (unsigned int )((unsigned char )rsn_ie_len) - 2U) {
    return (0);
  } else {
  }
  pos = rsn_ie;
  pos = pos + 4UL;
  left = rsn_ie_len + -4;
  if (left > 3) {
    *group_cipher = rtw_get_wpa2_cipher_suite23a(pos);
    pos = pos + 4UL;
    left = left + -4;
  } else
  if (left > 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016%s: ie length mismatch, %u too much", "rtw_parse_wpa2_ie23a", left);
    } else {
    }
    return (0);
  } else {
  }
  if (left > 1) {
    tmp = get_unaligned_le16((void const *)pos);
    count = (int )tmp;
    pos = pos + 2UL;
    left = left + -2;
    if (count == 0 || count * 4 > left) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
        printk("\016%s: ie count botch (pairwise), count %u left %u", "rtw_parse_wpa2_ie23a",
               count, left);
      } else {
      }
      return (0);
    } else {
    }
    i = 0;
    goto ldv_51621;
    ldv_51620:
    tmp___0 = rtw_get_wpa2_cipher_suite23a(pos);
    *pairwise_cipher = *pairwise_cipher | tmp___0;
    pos = pos + 4UL;
    left = left + -4;
    i = i + 1;
    ldv_51621: ;
    if (i < count) {
      goto ldv_51620;
    } else {
    }
  } else
  if (left == 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016%s: ie too short (for key mgmt)", "rtw_parse_wpa2_ie23a");
    } else {
    }
    return (0);
  } else {
  }
  if ((unsigned long )is_8021x != (unsigned long )((int *)0)) {
    if (left > 5) {
      pos = pos + 2UL;
      tmp___1 = memcmp((void const *)pos, (void const *)(& SUITE_1X), 4UL);
      if (tmp___1 == 0) {
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
          printk("\016%s (): there has 802.1x auth\n", "rtw_parse_wpa2_ie23a");
        } else {
        }
        *is_8021x = 1;
      } else {
      }
    } else {
    }
  } else {
  }
  return (ret);
}
}
int rtw_get_sec_ie23a(u8 *in_ie , uint in_len , u8 *rsn_ie , u16 *rsn_len , u8 *wpa_ie ,
                      u16 *wpa_len )
{
  u8 authmode ;
  u8 sec_idx ;
  u8 i ;
  uint cnt ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp ;
  {
  cnt = 12U;
  sec_idx = 0U;
  goto ldv_51648;
  ldv_51647:
  authmode = *(in_ie + (unsigned long )cnt);
  if ((unsigned int )authmode == 221U) {
    tmp = memcmp((void const *)in_ie + (unsigned long )(cnt + 2U), (void const *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
    if (tmp == 0) {
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
        printk("\016\n rtw_get_wpa_ie23a: sec_idx =%d in_ie[cnt+1]+2 =%d\n", (int )sec_idx,
               (int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
      } else {
      }
      if ((unsigned long )wpa_ie != (unsigned long )((u8 *)0U)) {
        __len = (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
        __ret = memcpy((void *)wpa_ie, (void const *)in_ie + (unsigned long )cnt,
                                 __len);
        i = 0U;
        goto ldv_51639;
        ldv_51638: ;
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
          printk("\016\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n", (int )*(wpa_ie + (unsigned long )i),
                 (int )*(wpa_ie + ((unsigned long )i + 1UL)), (int )*(wpa_ie + ((unsigned long )i + 2UL)),
                 (int )*(wpa_ie + ((unsigned long )i + 3UL)), (int )*(wpa_ie + ((unsigned long )i + 4UL)),
                 (int )*(wpa_ie + ((unsigned long )i + 5UL)), (int )*(wpa_ie + ((unsigned long )i + 6UL)),
                 (int )*(wpa_ie + ((unsigned long )i + 7UL)));
        } else {
        }
        i = (unsigned int )i + 8U;
        ldv_51639: ;
        if ((int )i < (int )*(in_ie + (unsigned long )(cnt + 1U)) + 2) {
          goto ldv_51638;
        } else {
        }
      } else {
      }
      *wpa_len = (unsigned int )((u16 )*(in_ie + (unsigned long )(cnt + 1U))) + 2U;
      cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
    } else {
      goto _L;
    }
  } else
  _L:
  if ((unsigned int )authmode == 48U) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
      printk("\016\n get_rsn_ie: sec_idx =%d in_ie[cnt+1]+2 =%d\n", (int )sec_idx,
             (int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
    } else {
    }
    if ((unsigned long )rsn_ie != (unsigned long )((u8 *)0U)) {
      __len___0 = (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
      __ret___0 = memcpy((void *)rsn_ie, (void const *)in_ie + (unsigned long )cnt,
                                   __len___0);
      i = 0U;
      goto ldv_51645;
      ldv_51644: ;
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
        printk("\016\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n", (int )*(rsn_ie + (unsigned long )i),
               (int )*(rsn_ie + ((unsigned long )i + 1UL)), (int )*(rsn_ie + ((unsigned long )i + 2UL)),
               (int )*(rsn_ie + ((unsigned long )i + 3UL)), (int )*(rsn_ie + ((unsigned long )i + 4UL)),
               (int )*(rsn_ie + ((unsigned long )i + 5UL)), (int )*(rsn_ie + ((unsigned long )i + 6UL)),
               (int )*(rsn_ie + ((unsigned long )i + 7UL)));
      } else {
      }
      i = (unsigned int )i + 8U;
      ldv_51645: ;
      if ((int )i < (int )*(in_ie + (unsigned long )(cnt + 1U)) + 2) {
        goto ldv_51644;
      } else {
      }
    } else {
    }
    *rsn_len = (unsigned int )((u16 )*(in_ie + (unsigned long )(cnt + 1U))) + 2U;
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  } else {
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  }
  ldv_51648: ;
  if (cnt < in_len) {
    goto ldv_51647;
  } else {
  }
  return ((int )*rsn_len + (int )*wpa_len);
}
}
u8 *rtw_get_wps_ie23a(u8 *in_ie , uint in_len , u8 *wps_ie , uint *wps_ielen )
{
  uint cnt ;
  u8 *wpsie_ptr ;
  u8 eid ;
  u8 wps_oui[4U] ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  {
  wpsie_ptr = (u8 *)0U;
  wps_oui[0] = 0U;
  wps_oui[1] = 80U;
  wps_oui[2] = 242U;
  wps_oui[3] = 4U;
  if ((unsigned long )wps_ielen != (unsigned long )((uint *)0U)) {
    *wps_ielen = 0U;
  } else {
  }
  if ((unsigned long )in_ie == (unsigned long )((u8 *)0U) || in_len == 0U) {
    return (wpsie_ptr);
  } else {
  }
  cnt = 0U;
  goto ldv_51665;
  ldv_51664:
  eid = *(in_ie + (unsigned long )cnt);
  if ((unsigned int )eid == 221U) {
    tmp = memcmp((void const *)in_ie + (unsigned long )(cnt + 2U), (void const *)(& wps_oui),
                 4UL);
    if (tmp == 0) {
      wpsie_ptr = in_ie + (unsigned long )cnt;
      if ((unsigned long )wps_ie != (unsigned long )((u8 *)0U)) {
        __len = (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
        __ret = memcpy((void *)wps_ie, (void const *)in_ie + (unsigned long )cnt,
                                 __len);
      } else {
      }
      if ((unsigned long )wps_ielen != (unsigned long )((uint *)0U)) {
        *wps_ielen = (uint )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
      } else {
      }
      cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
      goto ldv_51663;
    } else {
      cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
    }
  } else {
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  }
  ldv_51665: ;
  if (cnt < in_len) {
    goto ldv_51664;
  } else {
  }
  ldv_51663: ;
  return (wpsie_ptr);
}
}
u8 *rtw_get_wps_attr23a(u8 *wps_ie , uint wps_ielen , u16 target_attr_id , u8 *buf_attr ,
                        u32 *len_attr )
{
  u8 *attr_ptr ;
  u8 *target_attr_ptr ;
  u8 wps_oui[4U] ;
  int tmp ;
  u16 attr_id ;
  u16 tmp___0 ;
  u16 attr_data_len ;
  u16 tmp___1 ;
  u16 attr_len ;
  size_t __len ;
  void *__ret ;
  {
  attr_ptr = (u8 *)0U;
  target_attr_ptr = (u8 *)0U;
  wps_oui[0] = 0U;
  wps_oui[1] = 80U;
  wps_oui[2] = 242U;
  wps_oui[3] = 4U;
  if ((unsigned long )len_attr != (unsigned long )((u32 *)0U)) {
    *len_attr = 0U;
  } else {
  }
  if ((unsigned int )*wps_ie != 221U) {
    return (attr_ptr);
  } else {
    tmp = memcmp((void const *)wps_ie + 2U, (void const *)(& wps_oui), 4UL);
    if (tmp != 0) {
      return (attr_ptr);
    } else {
    }
  }
  attr_ptr = wps_ie + 6UL;
  goto ldv_51684;
  ldv_51683:
  tmp___0 = get_unaligned_be16((void const *)attr_ptr);
  attr_id = tmp___0;
  tmp___1 = get_unaligned_be16((void const *)attr_ptr + 2U);
  attr_data_len = tmp___1;
  attr_len = (unsigned int )attr_data_len + 4U;
  if ((int )attr_id == (int )target_attr_id) {
    target_attr_ptr = attr_ptr;
    if ((unsigned long )buf_attr != (unsigned long )((u8 *)0U)) {
      __len = (size_t )attr_len;
      __ret = memcpy((void *)buf_attr, (void const *)attr_ptr, __len);
    } else {
    }
    if ((unsigned long )len_attr != (unsigned long )((u32 *)0U)) {
      *len_attr = (u32 )attr_len;
    } else {
    }
    goto ldv_51682;
  } else {
    attr_ptr = attr_ptr + (unsigned long )attr_len;
  }
  ldv_51684: ;
  if ((long )attr_ptr - (long )wps_ie < (long )wps_ielen) {
    goto ldv_51683;
  } else {
  }
  ldv_51682: ;
  return (target_attr_ptr);
}
}
u8 *rtw_get_wps_attr_content23a(u8 *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                u8 *buf_content , uint *len_content )
{
  u8 *attr_ptr ;
  u32 attr_len ;
  size_t __len ;
  void *__ret ;
  {
  if ((unsigned long )len_content != (unsigned long )((uint *)0U)) {
    *len_content = 0U;
  } else {
  }
  attr_ptr = rtw_get_wps_attr23a(wps_ie, wps_ielen, (int )target_attr_id, (u8 *)0U,
                                 & attr_len);
  if ((unsigned long )attr_ptr != (unsigned long )((u8 *)0U) && attr_len != 0U) {
    if ((unsigned long )buf_content != (unsigned long )((u8 *)0U)) {
      __len = (size_t )(attr_len - 4U);
      __ret = memcpy((void *)buf_content, (void const *)attr_ptr + 4U,
                               __len);
    } else {
    }
    if ((unsigned long )len_content != (unsigned long )((uint *)0U)) {
      *len_content = attr_len - 4U;
    } else {
    }
    return (attr_ptr + 4UL);
  } else {
  }
  return ((u8 *)0U);
}
}
static int rtw_get_cipher_info(struct wlan_network *pnetwork )
{
  u8 const *pbuf ;
  int group_cipher ;
  int pairwise_cipher ;
  int is8021x ;
  int ret ;
  int r ;
  int offset ;
  int plen ;
  char *pie ;
  {
  group_cipher = 0;
  pairwise_cipher = 0;
  is8021x = 0;
  ret = 0;
  offset = 12;
  pie = (char *)(& pnetwork->network.IEs) + (unsigned long )offset;
  plen = (int )(pnetwork->network.IELength - (u32 )offset);
  pbuf = cfg80211_find_vendor_ie(20722U, 1, (u8 const *)pie, plen);
  if ((unsigned long )pbuf != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(pbuf + 1UL)) != 0U) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
      printk("\016rtw_get_cipher_info: wpa_ielen: %d", (int )*(pbuf + 1UL));
    } else {
    }
    r = rtw_parse_wpa_ie23a(pbuf, (int )*(pbuf + 1UL) + 2, & group_cipher, & pairwise_cipher,
                            & is8021x);
    if (r == 1) {
      pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
      pnetwork->BcnInfo.group_cipher = group_cipher;
      pnetwork->BcnInfo.is_8021x = is8021x;
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
        printk("\016%s: pnetwork->pairwise_cipher: %d, is_8021x is %d", "rtw_get_cipher_info",
               pnetwork->BcnInfo.pairwise_cipher, pnetwork->BcnInfo.is_8021x);
      } else {
      }
      ret = 1;
    } else {
    }
  } else {
    pbuf = cfg80211_find_ie(48, (u8 const *)pie, plen);
    if ((unsigned long )pbuf != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(pbuf + 1UL)) != 0U) {
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
        printk("\016get RSN IE\n");
      } else {
      }
      r = rtw_parse_wpa2_ie23a(pbuf, (int )*(pbuf + 1UL) + 2, & group_cipher, & pairwise_cipher,
                               & is8021x);
      if (r == 1) {
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
          printk("\016get RSN IE  OK!!!\n");
        } else {
        }
        pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
        pnetwork->BcnInfo.group_cipher = group_cipher;
        pnetwork->BcnInfo.is_8021x = is8021x;
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
          printk("\016%s: pnetwork->pairwise_cipher: %d,pnetwork->group_cipher is %d, is_8021x is %d",
                 "rtw_get_cipher_info", pnetwork->BcnInfo.pairwise_cipher, pnetwork->BcnInfo.group_cipher,
                 pnetwork->BcnInfo.is_8021x);
        } else {
        }
        ret = 1;
      } else {
      }
    } else {
    }
  }
  return (ret);
}
}
void rtw_get_bcn_info23a(struct wlan_network *pnetwork )
{
  unsigned short cap ;
  u8 bencrypt ;
  u16 wpa_len ;
  u16 rsn_len ;
  struct HT_info_element *pht_info ;
  struct ieee80211_ht_cap *pht_cap ;
  u8 const *p ;
  __le16 *tmp ;
  {
  bencrypt = 0U;
  wpa_len = 0U;
  rsn_len = 0U;
  tmp = rtw_get_capability23a_from_ie((u8 *)(& pnetwork->network.IEs));
  cap = get_unaligned_le16((void const *)tmp);
  if (((int )cap & 16) != 0) {
    bencrypt = 1U;
    pnetwork->network.Privacy = 1U;
  } else {
    pnetwork->BcnInfo.encryp_protocol = 0U;
  }
  rtw_get_sec_ie23a((u8 *)(& pnetwork->network.IEs), pnetwork->network.IELength, (u8 *)0U,
                    & rsn_len, (u8 *)0U, & wpa_len);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016rtw_get_bcn_info23a: ssid =%s\n", (u8 *)(& pnetwork->network.Ssid.ssid));
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016rtw_get_bcn_info23a: wpa_len =%d rsn_len =%d\n", (int )wpa_len, (int )rsn_len);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016rtw_get_bcn_info23a: ssid =%s\n", (u8 *)(& pnetwork->network.Ssid.ssid));
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016rtw_get_bcn_info23a: wpa_len =%d rsn_len =%d\n", (int )wpa_len, (int )rsn_len);
  } else {
  }
  if ((unsigned int )rsn_len != 0U) {
    pnetwork->BcnInfo.encryp_protocol = 3U;
  } else
  if ((unsigned int )wpa_len != 0U) {
    pnetwork->BcnInfo.encryp_protocol = 2U;
  } else
  if ((unsigned int )bencrypt != 0U) {
    pnetwork->BcnInfo.encryp_protocol = 1U;
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016rtw_get_bcn_info23a: pnetwork->encryp_protocol is %x\n", (int )pnetwork->BcnInfo.encryp_protocol);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016rtw_get_bcn_info23a: pnetwork->encryp_protocol is %x\n", (int )pnetwork->BcnInfo.encryp_protocol);
  } else {
  }
  rtw_get_cipher_info(pnetwork);
  p = cfg80211_find_ie(45, (u8 const *)(& pnetwork->network.IEs) + 12U, (int )(pnetwork->network.IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_cap = (struct ieee80211_ht_cap *)p + 2U;
    pnetwork->BcnInfo.ht_cap_info = pht_cap->cap_info;
  } else {
    pnetwork->BcnInfo.ht_cap_info = 0U;
  }
  p = cfg80211_find_ie(61, (u8 const *)(& pnetwork->network.IEs) + 12U, (int )(pnetwork->network.IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_info = (struct HT_info_element *)p + 2U;
    pnetwork->BcnInfo.ht_info_infos_0 = pht_info->infos[0];
  } else {
    pnetwork->BcnInfo.ht_info_infos_0 = 0U;
  }
  return;
}
}
u16 rtw_mcs_rate23a(u8 rf_type , u8 bw_40MHz , u8 short_GI_20 , u8 short_GI_40 , unsigned char *MCS_rate )
{
  u16 max_rate ;
  {
  max_rate = 0U;
  if ((unsigned int )rf_type == 3U) {
    if ((int )((signed char )*MCS_rate) < 0) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1500U : 1350U) : ((unsigned int )short_GI_20 != 0U ? 722U : 650U);
    } else
    if (((unsigned long )*MCS_rate & 64UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1350U : 1215U) : ((unsigned int )short_GI_20 != 0U ? 650U : 585U);
    } else
    if (((unsigned long )*MCS_rate & 32UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
    } else
    if (((unsigned long )*MCS_rate & 16UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
    } else
    if (((unsigned long )*MCS_rate & 8UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
    } else
    if (((unsigned long )*MCS_rate & 4UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 450U : 405U) : ((unsigned int )short_GI_20 != 0U ? 217U : 195U);
    } else
    if (((unsigned long )*MCS_rate & 2UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
    } else
    if ((int )*MCS_rate & 1) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 150U : 135U) : ((unsigned int )short_GI_20 != 0U ? 72U : 65U);
    } else {
    }
  } else
  if ((unsigned int )*(MCS_rate + 1UL) != 0U) {
    if ((int )((signed char )*(MCS_rate + 1UL)) < 0) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 3000U : 2700U) : ((unsigned int )short_GI_20 != 0U ? 1444U : 1300U);
    } else
    if (((unsigned long )*(MCS_rate + 1UL) & 64UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 2700U : 2430U) : ((unsigned int )short_GI_20 != 0U ? 1300U : 1170U);
    } else
    if (((unsigned long )*(MCS_rate + 1UL) & 32UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 2400U : 2160U) : ((unsigned int )short_GI_20 != 0U ? 1156U : 1040U);
    } else
    if (((unsigned long )*(MCS_rate + 1UL) & 16UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1800U : 1620U) : ((unsigned int )short_GI_20 != 0U ? 867U : 780U);
    } else
    if (((unsigned long )*(MCS_rate + 1UL) & 8UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
    } else
    if (((unsigned long )*(MCS_rate + 1UL) & 4UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
    } else
    if (((unsigned long )*(MCS_rate + 1UL) & 2UL) != 0UL) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
    } else
    if ((int )*(MCS_rate + 1UL) & 1) {
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
    } else {
    }
  } else
  if ((int )((signed char )*MCS_rate) < 0) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1500U : 1350U) : ((unsigned int )short_GI_20 != 0U ? 722U : 650U);
  } else
  if (((unsigned long )*MCS_rate & 64UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1350U : 1215U) : ((unsigned int )short_GI_20 != 0U ? 650U : 585U);
  } else
  if (((unsigned long )*MCS_rate & 32UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
  } else
  if (((unsigned long )*MCS_rate & 16UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
  } else
  if (((unsigned long )*MCS_rate & 8UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
  } else
  if (((unsigned long )*MCS_rate & 4UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 450U : 405U) : ((unsigned int )short_GI_20 != 0U ? 217U : 195U);
  } else
  if (((unsigned long )*MCS_rate & 2UL) != 0UL) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
  } else
  if ((int )*MCS_rate & 1) {
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 150U : 135U) : ((unsigned int )short_GI_20 != 0U ? 72U : 65U);
  } else {
  }
  return (max_rate);
}
}
static char const *_action_public_str23a[17U] =
  { "ACT_PUB_BSSCOEXIST", "ACT_PUB_DSE_ENABLE", "ACT_PUB_DSE_DEENABLE", "ACT_PUB_DSE_REG_LOCATION",
        "ACT_PUB_EXT_CHL_SWITCH", "ACT_PUB_DSE_MSR_REQ", "ACT_PUB_DSE_MSR_RPRT", "ACT_PUB_MP",
        "ACT_PUB_DSE_PWR_CONSTRAINT", "ACT_PUB_VENDOR", "ACT_PUB_GAS_INITIAL_REQ", "ACT_PUB_GAS_INITIAL_RSP",
        "ACT_PUB_GAS_COMEBACK_REQ", "ACT_PUB_GAS_COMEBACK_RSP", "ACT_PUB_TDLS_DISCOVERY_RSP", "ACT_PUB_LOCATION_TRACK",
        "ACT_PUB_RSVD"};
char const *action_public_str23a(u8 action )
{
  {
  action = (u8 )(16U < (unsigned int )action ? 16U : action);
  return (_action_public_str23a[(int )action]);
}
}
void *ldv_kmem_cache_alloc_158(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_164(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_166(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_168(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_169(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_170(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_171(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_173(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_174(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_mod_timer_218(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_219(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_220(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_221(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_222(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_223(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_224(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_225(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_226(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_227(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_228(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_229(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_230(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_255(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_264(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_275(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_277(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_280(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_281(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_283(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_285(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_288(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_290(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_292(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_296(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_297(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_299(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_301(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_303(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_305(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_307(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_315(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_317(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_318(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_321(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_217(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_231(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_232(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_233(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_234(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_235(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_236(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_237(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_238(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_239(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_240(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_241(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_242(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_243(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_244(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_245(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_246(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_247(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_248(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_249(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_250(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_251(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_252(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_253(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_254(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_256(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_257(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_258(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_259(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_260(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_261(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_262(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_263(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_265(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_266(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_267(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_268(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_269(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_270(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_271(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_272(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_273(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_274(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_276(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_278(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_279(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_282(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_284(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_286(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_287(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_289(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_291(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_293(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_294(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_295(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_298(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_300(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_302(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_304(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_306(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_308(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_309(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_310(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_311(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_312(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_313(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_314(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_316(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_319(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_320(struct timer_list *ldv_func_arg1 ) ;
extern struct workqueue_struct *system_wq ;
__inline static bool schedule_work(struct work_struct *work )
{
  bool tmp ;
  {
  tmp = queue_work(system_wq, work);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_200(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void ldv_stop(void)
{
  {
  LDV_STOP: ;
  goto LDV_STOP;
}
}
int ldv_timer_1_3 ;
struct timer_list *ldv_timer_list_1_1 ;
int ldv_timer_1_1 ;
int ldv_timer_1_0 ;
struct timer_list *ldv_timer_list_1_3 ;
struct timer_list *ldv_timer_list_1_0 ;
int ldv_timer_1_2 ;
struct timer_list *ldv_timer_list_1_2 ;
void timer_init_1(void) ;
int reg_timer_1(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void activate_suitable_timer_1(struct timer_list *timer , unsigned long data ) ;
void choose_timer_1(void) ;
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void disable_suitable_timer_1(struct timer_list *timer ) ;
void ldv_timer_1(int state , struct timer_list *timer ) ;
struct sk_buff *ldv_skb_clone_208(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_216(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_210(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_206(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_214(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_215(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_211(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_212(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_213(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
void LedControl871x23a(struct rtw_adapter *padapter , enum led_ctl_mode LedAction ) ;
void BlinkWorkItemCallback23a(struct work_struct *work ) ;
void ResetLedStatus23a(struct led_8723a *pLed ) ;
void InitLed871x23a(struct rtw_adapter *padapter , struct led_8723a *pLed , enum led_pin_8723a LedPin ) ;
void DeInitLed871x23a(struct led_8723a *pLed ) ;
void BlinkHandler23a(struct led_8723a *pLed ) ;
void SwLedOn23a(struct rtw_adapter *padapter , struct led_8723a *pLed ) ;
void SwLedOff23a(struct rtw_adapter *padapter , struct led_8723a *pLed ) ;
static void BlinkTimerCallback(unsigned long data )
{
  struct led_8723a *pLed ;
  struct rtw_adapter *padapter ;
  {
  pLed = (struct led_8723a *)data;
  padapter = pLed->padapter;
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
    return;
  } else {
  }
  schedule_work(& pLed->BlinkWorkItem);
  return;
}
}
void BlinkWorkItemCallback23a(struct work_struct *work )
{
  struct led_8723a *pLed ;
  struct work_struct const *__mptr ;
  {
  __mptr = (struct work_struct const *)work;
  pLed = (struct led_8723a *)__mptr + 0xffffffffffffff58UL;
  BlinkHandler23a(pLed);
  return;
}
}
void ResetLedStatus23a(struct led_8723a *pLed )
{
  {
  pLed->CurrLedState = 2;
  pLed->bLedOn = 0U;
  pLed->bLedBlinkInProgress = 0U;
  pLed->bLedWPSBlinkInProgress = 0U;
  pLed->BlinkTimes = 0U;
  pLed->BlinkingLedState = 0;
  pLed->bLedNoLinkBlinkInProgress = 0U;
  pLed->bLedLinkBlinkInProgress = 0U;
  pLed->bLedStartToLinkBlinkInProgress = 0U;
  pLed->bLedScanBlinkInProgress = 0U;
  return;
}
}
void InitLed871x23a(struct rtw_adapter *padapter , struct led_8723a *pLed , enum led_pin_8723a LedPin )
{
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  {
  pLed->padapter = padapter;
  pLed->LedPin = LedPin;
  ResetLedStatus23a(pLed);
  reg_timer_6(& pLed->BlinkTimer, & BlinkTimerCallback, (unsigned long )pLed);
  __init_work(& pLed->BlinkWorkItem, 0);
  __constr_expr_0.counter = 137438953408L;
  pLed->BlinkWorkItem.data = __constr_expr_0;
  lockdep_init_map(& pLed->BlinkWorkItem.lockdep_map, "(&pLed->BlinkWorkItem)", & __key,
                   0);
  INIT_LIST_HEAD(& pLed->BlinkWorkItem.entry);
  pLed->BlinkWorkItem.func = & BlinkWorkItemCallback23a;
  return;
}
}
void DeInitLed871x23a(struct led_8723a *pLed )
{
  {
  cancel_work_sync(& pLed->BlinkWorkItem);
  ldv_del_timer_sync_217(& pLed->BlinkTimer);
  ResetLedStatus23a(pLed);
  return;
}
}
static void SwLedBlink(struct led_8723a *pLed )
{
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  u8 bStopBlinking ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  {
  padapter = pLed->padapter;
  pmlmepriv = & padapter->mlmepriv;
  bStopBlinking = 0U;
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
    SwLedOn23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {
    }
  } else {
    SwLedOff23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {
    }
  }
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  switch ((unsigned int )pLed->CurrLedState) {
  case 3U: ;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  goto ldv_51938;
  case 8U:
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    tmp___0 = check_fwstate(pmlmepriv, 8);
    if ((int )tmp___0) {
      bStopBlinking = 1U;
    } else {
    }
  } else {
  }
  tmp___1 = check_fwstate(pmlmepriv, 1);
  if ((int )tmp___1) {
    tmp___2 = check_fwstate(pmlmepriv, 32);
    if ((int )tmp___2) {
      bStopBlinking = 1U;
    } else {
      tmp___3 = check_fwstate(pmlmepriv, 64);
      if ((int )tmp___3) {
        bStopBlinking = 1U;
      } else {
        goto _L;
      }
    }
  } else
  _L:
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  goto ldv_51938;
  case 10U: ;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  goto ldv_51938;
  default:
  bStopBlinking = 1U;
  goto ldv_51938;
  }
  ldv_51938: ;
  if ((unsigned int )bStopBlinking != 0U) {
    tmp___5 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___5 && (unsigned int )pLed->bLedOn == 0U) {
      SwLedOn23a(padapter, pLed);
    } else {
      tmp___4 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___4 && (unsigned int )pLed->bLedOn != 0U) {
        SwLedOff23a(padapter, pLed);
      } else {
      }
    }
    pLed->BlinkTimes = 0U;
    pLed->bLedBlinkInProgress = 0U;
  } else {
    if ((unsigned int )pLed->BlinkingLedState == 1U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    switch ((unsigned int )pLed->CurrLedState) {
    case 3U:
    tmp___6 = msecs_to_jiffies(100U);
    ldv_mod_timer_218(& pLed->BlinkTimer, tmp___6 + (unsigned long )jiffies);
    goto ldv_51943;
    case 4U: ;
    case 8U:
    tmp___7 = msecs_to_jiffies(200U);
    ldv_mod_timer_219(& pLed->BlinkTimer, tmp___7 + (unsigned long )jiffies);
    goto ldv_51943;
    case 10U:
    tmp___8 = msecs_to_jiffies(400U);
    ldv_mod_timer_220(& pLed->BlinkTimer, tmp___8 + (unsigned long )jiffies);
    goto ldv_51943;
    default:
    tmp___9 = msecs_to_jiffies(200U);
    ldv_mod_timer_221(& pLed->BlinkTimer, tmp___9 + (unsigned long )jiffies);
    goto ldv_51943;
    }
    ldv_51943: ;
  }
  return;
}
}
static void SwLedBlink1(struct led_8723a *pLed )
{
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  unsigned long delay ;
  u8 bStopBlinking ;
  bool tmp ;
  bool tmp___0 ;
  unsigned long tmp___1 ;
  {
  padapter = pLed->padapter;
  pmlmepriv = & padapter->mlmepriv;
  delay = 0UL;
  bStopBlinking = 0U;
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
    SwLedOn23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {
    }
  } else {
    SwLedOff23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {
    }
  }
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
    SwLedOff23a(padapter, pLed);
    ResetLedStatus23a(pLed);
    return;
  } else {
  }
  switch ((unsigned int )pLed->CurrLedState) {
  case 4U: ;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  delay = 1000UL;
  goto ldv_51956;
  case 3U: ;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  delay = 500UL;
  goto ldv_51956;
  case 6U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    tmp = check_fwstate(pmlmepriv, 1);
    if ((int )tmp) {
      pLed->bLedLinkBlinkInProgress = 1U;
      pLed->CurrLedState = 3;
      if ((unsigned int )pLed->bLedOn != 0U) {
        pLed->BlinkingLedState = 2;
      } else {
        pLed->BlinkingLedState = 1;
      }
      delay = 500UL;
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {
      }
    } else {
      pLed->bLedNoLinkBlinkInProgress = 1U;
      pLed->CurrLedState = 4;
      if ((unsigned int )pLed->bLedOn != 0U) {
        pLed->BlinkingLedState = 2;
      } else {
        pLed->BlinkingLedState = 1;
      }
      delay = 1000UL;
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {
      }
    }
    pLed->bLedScanBlinkInProgress = 0U;
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 180UL;
  }
  goto ldv_51956;
  case 9U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    tmp___0 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___0) {
      pLed->bLedLinkBlinkInProgress = 1U;
      pLed->CurrLedState = 3;
      if ((unsigned int )pLed->bLedOn != 0U) {
        pLed->BlinkingLedState = 2;
      } else {
        pLed->BlinkingLedState = 1;
      }
      delay = 500UL;
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {
      }
    } else {
      pLed->bLedNoLinkBlinkInProgress = 1U;
      pLed->CurrLedState = 4;
      if ((unsigned int )pLed->bLedOn != 0U) {
        pLed->BlinkingLedState = 2;
      } else {
        pLed->BlinkingLedState = 1;
      }
      delay = 1000UL;
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {
      }
    }
    pLed->BlinkTimes = 0U;
    pLed->bLedBlinkInProgress = 0U;
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 50UL;
  }
  goto ldv_51956;
  case 10U: ;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  delay = 180UL;
  goto ldv_51956;
  case 11U: ;
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
    bStopBlinking = 0U;
  } else {
    bStopBlinking = 1U;
  }
  if ((unsigned int )bStopBlinking != 0U) {
    pLed->bLedLinkBlinkInProgress = 1U;
    pLed->CurrLedState = 3;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 500UL;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
    } else {
    }
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
    pLed->BlinkingLedState = 2;
    delay = 5000UL;
  }
  goto ldv_51956;
  default: ;
  goto ldv_51956;
  }
  ldv_51956: ;
  if (delay != 0UL) {
    tmp___1 = msecs_to_jiffies((unsigned int const )delay);
    ldv_mod_timer_222(& pLed->BlinkTimer, tmp___1 + (unsigned long )jiffies);
  } else {
  }
  return;
}
}
static void SwLedBlink2(struct led_8723a *pLed )
{
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  u8 bStopBlinking ;
  bool tmp ;
  unsigned long tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  {
  padapter = pLed->padapter;
  pmlmepriv = & padapter->mlmepriv;
  bStopBlinking = 0U;
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
    SwLedOn23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {
    }
  } else {
    SwLedOff23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {
    }
  }
  switch ((unsigned int )pLed->CurrLedState) {
  case 6U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
      SwLedOff23a(padapter, pLed);
    } else {
      tmp = check_fwstate(pmlmepriv, 1);
      if ((int )tmp) {
        pLed->CurrLedState = 1;
        pLed->BlinkingLedState = 1;
        SwLedOn23a(padapter, pLed);
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
          printk("\016stop scan blink CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {
        }
      } else {
        pLed->CurrLedState = 2;
        pLed->BlinkingLedState = 2;
        SwLedOff23a(padapter, pLed);
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
          printk("\016stop scan blink CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {
        }
      }
    }
    pLed->bLedScanBlinkInProgress = 0U;
  } else
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
    SwLedOff23a(padapter, pLed);
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    tmp___0 = msecs_to_jiffies(180U);
    ldv_mod_timer_223(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  }
  goto ldv_51970;
  case 9U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
      SwLedOff23a(padapter, pLed);
    } else {
      tmp___1 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___1) {
        pLed->CurrLedState = 1;
        pLed->BlinkingLedState = 1;
        SwLedOn23a(padapter, pLed);
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
          printk("\016stop CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {
        }
      } else {
        pLed->CurrLedState = 2;
        pLed->BlinkingLedState = 2;
        SwLedOff23a(padapter, pLed);
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
          printk("\016stop CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {
        }
      }
    }
    pLed->bLedBlinkInProgress = 0U;
  } else
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
    SwLedOff23a(padapter, pLed);
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    tmp___2 = msecs_to_jiffies(50U);
    ldv_mod_timer_224(& pLed->BlinkTimer, tmp___2 + (unsigned long )jiffies);
  }
  goto ldv_51970;
  default: ;
  goto ldv_51970;
  }
  ldv_51970: ;
  return;
}
}
static void SwLedBlink3(struct led_8723a *pLed )
{
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  u8 bStopBlinking ;
  bool tmp ;
  unsigned long tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  {
  padapter = pLed->padapter;
  pmlmepriv = & padapter->mlmepriv;
  bStopBlinking = 0U;
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
    SwLedOn23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {
    }
  } else {
    if ((unsigned int )pLed->CurrLedState != 11U) {
      SwLedOff23a(padapter, pLed);
    } else {
    }
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {
    }
  }
  switch ((unsigned int )pLed->CurrLedState) {
  case 6U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
      SwLedOff23a(padapter, pLed);
    } else {
      tmp = check_fwstate(pmlmepriv, 1);
      if ((int )tmp) {
        pLed->CurrLedState = 1;
        pLed->BlinkingLedState = 1;
        if ((unsigned int )pLed->bLedOn == 0U) {
          SwLedOn23a(padapter, pLed);
        } else {
        }
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
          printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {
        }
      } else {
        pLed->CurrLedState = 2;
        pLed->BlinkingLedState = 2;
        if ((unsigned int )pLed->bLedOn != 0U) {
          SwLedOff23a(padapter, pLed);
        } else {
        }
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
          printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {
        }
      }
    }
    pLed->bLedScanBlinkInProgress = 0U;
  } else
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
    SwLedOff23a(padapter, pLed);
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    tmp___0 = msecs_to_jiffies(180U);
    ldv_mod_timer_225(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  }
  goto ldv_51980;
  case 9U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
      SwLedOff23a(padapter, pLed);
    } else {
      tmp___1 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___1) {
        pLed->CurrLedState = 1;
        pLed->BlinkingLedState = 1;
        if ((unsigned int )pLed->bLedOn == 0U) {
          SwLedOn23a(padapter, pLed);
        } else {
        }
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
          printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {
        }
      } else {
        pLed->CurrLedState = 2;
        pLed->BlinkingLedState = 2;
        if ((unsigned int )pLed->bLedOn != 0U) {
          SwLedOff23a(padapter, pLed);
        } else {
        }
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
          printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {
        }
      }
    }
    pLed->bLedBlinkInProgress = 0U;
  } else
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
    SwLedOff23a(padapter, pLed);
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    tmp___2 = msecs_to_jiffies(50U);
    ldv_mod_timer_226(& pLed->BlinkTimer, tmp___2 + (unsigned long )jiffies);
  }
  goto ldv_51980;
  case 10U: ;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  tmp___3 = msecs_to_jiffies(180U);
  ldv_mod_timer_227(& pLed->BlinkTimer, tmp___3 + (unsigned long )jiffies);
  goto ldv_51980;
  case 11U: ;
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
    pLed->BlinkingLedState = 2;
    tmp___4 = msecs_to_jiffies(5000U);
    ldv_mod_timer_228(& pLed->BlinkTimer, tmp___4 + (unsigned long )jiffies);
    bStopBlinking = 0U;
  } else {
    bStopBlinking = 1U;
  }
  if ((unsigned int )bStopBlinking != 0U) {
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
      SwLedOff23a(padapter, pLed);
    } else {
      pLed->CurrLedState = 1;
      pLed->BlinkingLedState = 1;
      SwLedOn23a(padapter, pLed);
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {
      }
    }
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  goto ldv_51980;
  default: ;
  goto ldv_51980;
  }
  ldv_51980: ;
  return;
}
}
static void SwLedBlink4(struct led_8723a *pLed )
{
  struct rtw_adapter *padapter ;
  struct led_priv *ledpriv ;
  struct led_8723a *pLed1 ;
  u8 bStopBlinking ;
  unsigned long delay ;
  unsigned long tmp ;
  {
  padapter = pLed->padapter;
  ledpriv = & padapter->ledpriv;
  pLed1 = & ledpriv->SwLed1;
  bStopBlinking = 0U;
  delay = 0UL;
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
    SwLedOn23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {
    }
  } else {
    SwLedOff23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {
    }
  }
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress == 0U && (unsigned int )pLed1->BlinkingLedState == 0U) {
    pLed1->BlinkingLedState = 2;
    pLed1->CurrLedState = 2;
    SwLedOff23a(padapter, pLed1);
  } else {
  }
  switch ((unsigned int )pLed->CurrLedState) {
  case 4U: ;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  delay = 1000UL;
  goto ldv_51994;
  case 8U: ;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
    delay = 200UL;
  } else {
    pLed->BlinkingLedState = 1;
    delay = 100UL;
  }
  goto ldv_51994;
  case 6U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 0U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
      SwLedOff23a(padapter, pLed);
    } else {
      pLed->bLedNoLinkBlinkInProgress = 0U;
      pLed->CurrLedState = 4;
      if ((unsigned int )pLed->bLedOn != 0U) {
        pLed->BlinkingLedState = 2;
      } else {
        pLed->BlinkingLedState = 1;
      }
      delay = 1000UL;
    }
    pLed->bLedScanBlinkInProgress = 0U;
  } else
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
    SwLedOff23a(padapter, pLed);
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 180UL;
  }
  goto ldv_51994;
  case 9U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
      SwLedOff23a(padapter, pLed);
    } else {
      pLed->bLedNoLinkBlinkInProgress = 1U;
      pLed->CurrLedState = 4;
      if ((unsigned int )pLed->bLedOn != 0U) {
        pLed->BlinkingLedState = 2;
      } else {
        pLed->BlinkingLedState = 1;
      }
      delay = 1000UL;
    }
    pLed->bLedBlinkInProgress = 0U;
  } else
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
    SwLedOff23a(padapter, pLed);
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 50UL;
  }
  goto ldv_51994;
  case 10U: ;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
    delay = 200UL;
  } else {
    pLed->BlinkingLedState = 1;
    delay = 100UL;
  }
  goto ldv_51994;
  case 11U: ;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  delay = 100UL;
  goto ldv_51994;
  case 12U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkTimes = 1U;
    } else {
      bStopBlinking = 1U;
    }
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    pLed->BlinkTimes = 10U;
    pLed->BlinkingLedState = 1;
    delay = 500UL;
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 100UL;
  }
  goto ldv_51994;
  default: ;
  goto ldv_51994;
  }
  ldv_51994: ;
  if (delay != 0UL) {
    tmp = msecs_to_jiffies((unsigned int const )delay);
    ldv_mod_timer_229(& pLed->BlinkTimer, tmp + (unsigned long )jiffies);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016SwLedBlink4 CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
  } else {
  }
  return;
}
}
static void SwLedBlink5(struct led_8723a *pLed )
{
  struct rtw_adapter *padapter ;
  u8 bStopBlinking ;
  unsigned long delay ;
  unsigned long tmp ;
  {
  padapter = pLed->padapter;
  bStopBlinking = 0U;
  delay = 0UL;
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
    SwLedOn23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {
    }
  } else {
    SwLedOff23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {
    }
  }
  switch ((unsigned int )pLed->CurrLedState) {
  case 6U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
      pLed->CurrLedState = 2;
      pLed->BlinkingLedState = 2;
      if ((unsigned int )pLed->bLedOn != 0U) {
        SwLedOff23a(padapter, pLed);
      } else {
      }
    } else {
      pLed->CurrLedState = 1;
      pLed->BlinkingLedState = 1;
      if ((unsigned int )pLed->bLedOn == 0U) {
        delay = 50UL;
      } else {
      }
    }
    pLed->bLedScanBlinkInProgress = 0U;
  } else
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
    SwLedOff23a(padapter, pLed);
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 180UL;
  }
  goto ldv_52009;
  case 9U:
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
  if (pLed->BlinkTimes == 0U) {
    bStopBlinking = 1U;
  } else {
  }
  if ((unsigned int )bStopBlinking != 0U) {
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
      pLed->CurrLedState = 2;
      pLed->BlinkingLedState = 2;
      if ((unsigned int )pLed->bLedOn != 0U) {
        SwLedOff23a(padapter, pLed);
      } else {
      }
    } else {
      pLed->CurrLedState = 1;
      pLed->BlinkingLedState = 1;
      if ((unsigned int )pLed->bLedOn == 0U) {
        delay = 50UL;
      } else {
      }
    }
    pLed->bLedBlinkInProgress = 0U;
  } else
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
    SwLedOff23a(padapter, pLed);
  } else {
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 50UL;
  }
  goto ldv_52009;
  default: ;
  goto ldv_52009;
  }
  ldv_52009: ;
  if (delay != 0UL) {
    tmp = msecs_to_jiffies((unsigned int const )delay);
    ldv_mod_timer_230(& pLed->BlinkTimer, tmp + (unsigned long )jiffies);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016SwLedBlink5 CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
  } else {
  }
  return;
}
}
static void SwLedBlink6(struct led_8723a *pLed )
{
  struct rtw_adapter *padapter ;
  {
  padapter = pLed->padapter;
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
    SwLedOn23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {
    }
  } else {
    SwLedOff23a(padapter, pLed);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {
    }
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016<==== blink6\n");
  } else {
  }
  return;
}
}
static void SwLedControlMode1(struct rtw_adapter *padapter , enum led_ctl_mode LedAction )
{
  struct led_priv *ledpriv ;
  struct led_8723a *pLed ;
  struct mlme_priv *pmlmepriv ;
  long delay ;
  bool tmp ;
  unsigned long tmp___0 ;
  {
  ledpriv = & padapter->ledpriv;
  pLed = & ledpriv->SwLed0;
  pmlmepriv = & padapter->mlmepriv;
  delay = -1L;
  switch ((unsigned int )LedAction) {
  case 1U: ;
  case 8U: ;
  case 3U: ;
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 0U) {
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_231(& pLed->BlinkTimer);
      pLed->bLedLinkBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_232(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedNoLinkBlinkInProgress = 1U;
    pLed->CurrLedState = 4;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 1000L;
  } else {
  }
  goto ldv_52027;
  case 2U: ;
  if ((unsigned int )pLed->bLedLinkBlinkInProgress == 0U) {
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_233(& pLed->BlinkTimer);
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_234(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedLinkBlinkInProgress = 1U;
    pLed->CurrLedState = 3;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 500L;
  } else {
  }
  goto ldv_52027;
  case 6U: ;
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
    tmp = check_fwstate(pmlmepriv, 1);
    if ((int )tmp) {
    } else {
      goto _L;
    }
  } else
  _L:
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
    if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_235(& pLed->BlinkTimer);
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_236(& pLed->BlinkTimer);
      pLed->bLedLinkBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_237(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedScanBlinkInProgress = 1U;
    pLed->CurrLedState = 6;
    pLed->BlinkTimes = 24U;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 180L;
  } else {
  }
  goto ldv_52027;
  case 4U: ;
  case 5U: ;
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_238(& pLed->BlinkTimer);
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_239(& pLed->BlinkTimer);
      pLed->bLedLinkBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedBlinkInProgress = 1U;
    pLed->CurrLedState = 9;
    pLed->BlinkTimes = 2U;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 50L;
  } else {
  }
  goto ldv_52027;
  case 9U: ;
  case 11U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U) {
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_240(& pLed->BlinkTimer);
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_241(& pLed->BlinkTimer);
      pLed->bLedLinkBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_242(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
      ldv_del_timer_sync_243(& pLed->BlinkTimer);
      pLed->bLedScanBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedWPSBlinkInProgress = 1U;
    pLed->CurrLedState = 10;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 180L;
  } else {
  }
  goto ldv_52027;
  case 10U: ;
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
    ldv_del_timer_sync_244(& pLed->BlinkTimer);
    pLed->bLedNoLinkBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
    ldv_del_timer_sync_245(& pLed->BlinkTimer);
    pLed->bLedLinkBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
    ldv_del_timer_sync_246(& pLed->BlinkTimer);
    pLed->bLedBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
    ldv_del_timer_sync_247(& pLed->BlinkTimer);
    pLed->bLedScanBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_248(& pLed->BlinkTimer);
  } else {
    pLed->bLedWPSBlinkInProgress = 1U;
  }
  pLed->CurrLedState = 11;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
    delay = 5000L;
  } else {
    pLed->BlinkingLedState = 1;
    delay = 0L;
  }
  goto ldv_52027;
  case 12U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_249(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  pLed->bLedNoLinkBlinkInProgress = 1U;
  pLed->CurrLedState = 4;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  delay = 1000L;
  goto ldv_52027;
  case 7U:
  pLed->CurrLedState = 2;
  pLed->BlinkingLedState = 2;
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress != 0U) {
    ldv_del_timer_sync_250(& pLed->BlinkTimer);
    pLed->bLedNoLinkBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedLinkBlinkInProgress != 0U) {
    ldv_del_timer_sync_251(& pLed->BlinkTimer);
    pLed->bLedLinkBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
    ldv_del_timer_sync_252(& pLed->BlinkTimer);
    pLed->bLedBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_253(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
    ldv_del_timer_sync_254(& pLed->BlinkTimer);
    pLed->bLedScanBlinkInProgress = 0U;
  } else {
  }
  SwLedOff23a(padapter, pLed);
  goto ldv_52027;
  default: ;
  goto ldv_52027;
  }
  ldv_52027: ;
  if (delay != -1L) {
    tmp___0 = msecs_to_jiffies((unsigned int const )delay);
    ldv_mod_timer_255(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016Led %d\n", (unsigned int )pLed->CurrLedState);
  } else {
  }
  return;
}
}
static void SwLedControlMode2(struct rtw_adapter *padapter , enum led_ctl_mode LedAction )
{
  struct led_priv *ledpriv ;
  struct mlme_priv *pmlmepriv ;
  struct led_8723a *pLed ;
  long delay ;
  bool tmp ;
  unsigned long tmp___0 ;
  {
  ledpriv = & padapter->ledpriv;
  pmlmepriv = & padapter->mlmepriv;
  pLed = & ledpriv->SwLed0;
  delay = -1L;
  switch ((unsigned int )LedAction) {
  case 6U: ;
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
  } else
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
    if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_256(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedScanBlinkInProgress = 1U;
    pLed->CurrLedState = 6;
    pLed->BlinkTimes = 24U;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 180L;
  } else {
  }
  goto ldv_52047;
  case 4U: ;
  case 5U: ;
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
    tmp = check_fwstate(pmlmepriv, 1);
    if ((int )tmp) {
      if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
        return;
      } else {
      }
      pLed->bLedBlinkInProgress = 1U;
      pLed->CurrLedState = 9;
      pLed->BlinkTimes = 2U;
      if ((unsigned int )pLed->bLedOn != 0U) {
        pLed->BlinkingLedState = 2;
      } else {
        pLed->BlinkingLedState = 1;
      }
      delay = 50L;
    } else {
    }
  } else {
  }
  goto ldv_52047;
  case 2U:
  pLed->CurrLedState = 1;
  pLed->BlinkingLedState = 1;
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
    ldv_del_timer_sync_257(& pLed->BlinkTimer);
    pLed->bLedBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
    ldv_del_timer_sync_258(& pLed->BlinkTimer);
    pLed->bLedScanBlinkInProgress = 0U;
  } else {
  }
  delay = 0L;
  goto ldv_52047;
  case 9U: ;
  case 11U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U) {
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_259(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
      ldv_del_timer_sync_260(& pLed->BlinkTimer);
      pLed->bLedScanBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedWPSBlinkInProgress = 1U;
    pLed->CurrLedState = 1;
    pLed->BlinkingLedState = 1;
    delay = 0L;
  } else {
  }
  goto ldv_52047;
  case 10U:
  pLed->bLedWPSBlinkInProgress = 0U;
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
    SwLedOff23a(padapter, pLed);
  } else {
    pLed->CurrLedState = 1;
    pLed->BlinkingLedState = 1;
    delay = 0L;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
    } else {
    }
  }
  goto ldv_52047;
  case 12U:
  pLed->bLedWPSBlinkInProgress = 0U;
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
    SwLedOff23a(padapter, pLed);
  } else {
    pLed->CurrLedState = 2;
    pLed->BlinkingLedState = 2;
    delay = 0L;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
      printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
    } else {
    }
  }
  goto ldv_52047;
  case 8U: ;
  case 3U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U && (unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
    pLed->CurrLedState = 2;
    pLed->BlinkingLedState = 2;
    delay = 0L;
  } else {
  }
  goto ldv_52047;
  case 7U:
  pLed->CurrLedState = 2;
  pLed->BlinkingLedState = 2;
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
    ldv_del_timer_sync_261(& pLed->BlinkTimer);
    pLed->bLedBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
    ldv_del_timer_sync_262(& pLed->BlinkTimer);
    pLed->bLedScanBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_263(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  delay = 0L;
  goto ldv_52047;
  default: ;
  goto ldv_52047;
  }
  ldv_52047: ;
  if (delay != -1L) {
    tmp___0 = msecs_to_jiffies((unsigned int const )delay);
    ldv_mod_timer_264(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
  } else {
  }
  return;
}
}
static void SwLedControlMode3(struct rtw_adapter *padapter , enum led_ctl_mode LedAction )
{
  struct led_priv *ledpriv ;
  struct mlme_priv *pmlmepriv ;
  struct led_8723a *pLed ;
  long delay ;
  bool tmp ;
  unsigned long tmp___0 ;
  {
  ledpriv = & padapter->ledpriv;
  pmlmepriv = & padapter->mlmepriv;
  pLed = & ledpriv->SwLed0;
  delay = -1L;
  switch ((unsigned int )LedAction) {
  case 6U: ;
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
  } else
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
    if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_265(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedScanBlinkInProgress = 1U;
    pLed->CurrLedState = 6;
    pLed->BlinkTimes = 24U;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 180L;
  } else {
  }
  goto ldv_52068;
  case 4U: ;
  case 5U: ;
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
    tmp = check_fwstate(pmlmepriv, 1);
    if ((int )tmp) {
      if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
        return;
      } else {
      }
      pLed->bLedBlinkInProgress = 1U;
      pLed->CurrLedState = 9;
      pLed->BlinkTimes = 2U;
      if ((unsigned int )pLed->bLedOn != 0U) {
        pLed->BlinkingLedState = 2;
      } else {
        pLed->BlinkingLedState = 1;
      }
      delay = 50L;
    } else {
    }
  } else {
  }
  goto ldv_52068;
  case 2U: ;
  if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    return;
  } else {
  }
  pLed->CurrLedState = 1;
  pLed->BlinkingLedState = 1;
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
    ldv_del_timer_sync_266(& pLed->BlinkTimer);
    pLed->bLedBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
    ldv_del_timer_sync_267(& pLed->BlinkTimer);
    pLed->bLedScanBlinkInProgress = 0U;
  } else {
  }
  delay = 0L;
  goto ldv_52068;
  case 9U: ;
  case 11U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U) {
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_268(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
      ldv_del_timer_sync_269(& pLed->BlinkTimer);
      pLed->bLedScanBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedWPSBlinkInProgress = 1U;
    pLed->CurrLedState = 10;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    delay = 180L;
  } else {
  }
  goto ldv_52068;
  case 10U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_270(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
    pLed->bLedWPSBlinkInProgress = 1U;
  }
  pLed->CurrLedState = 11;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
    delay = 5000L;
  } else {
    pLed->BlinkingLedState = 1;
    delay = 0L;
  }
  goto ldv_52068;
  case 12U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_271(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  pLed->CurrLedState = 2;
  pLed->BlinkingLedState = 2;
  delay = 0L;
  goto ldv_52068;
  case 8U: ;
  case 3U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U && (unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
    pLed->CurrLedState = 2;
    pLed->BlinkingLedState = 2;
    delay = 0L;
  } else {
  }
  goto ldv_52068;
  case 7U:
  pLed->CurrLedState = 2;
  pLed->BlinkingLedState = 2;
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
    ldv_del_timer_sync_272(& pLed->BlinkTimer);
    pLed->bLedBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
    ldv_del_timer_sync_273(& pLed->BlinkTimer);
    pLed->bLedScanBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_274(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  delay = 0L;
  goto ldv_52068;
  default: ;
  goto ldv_52068;
  }
  ldv_52068: ;
  if (delay != -1L) {
    tmp___0 = msecs_to_jiffies((unsigned int const )delay);
    ldv_mod_timer_275(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
  } else {
  }
  return;
}
}
static void SwLedControlMode4(struct rtw_adapter *padapter , enum led_ctl_mode LedAction )
{
  struct led_priv *ledpriv ;
  struct mlme_priv *pmlmepriv ;
  struct led_8723a *pLed ;
  struct led_8723a *pLed1 ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  bool tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  {
  ledpriv = & padapter->ledpriv;
  pmlmepriv = & padapter->mlmepriv;
  pLed = & ledpriv->SwLed0;
  pLed1 = & ledpriv->SwLed1;
  switch ((unsigned int )LedAction) {
  case 8U: ;
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
    pLed1->bLedWPSBlinkInProgress = 0U;
    ldv_del_timer_sync_276(& pLed1->BlinkTimer);
    pLed1->BlinkingLedState = 2;
    pLed1->CurrLedState = 2;
    if ((unsigned int )pLed1->bLedOn != 0U) {
      ldv_mod_timer_277(& pLed->BlinkTimer, jiffies);
    } else {
    }
  } else {
  }
  if ((unsigned int )pLed->bLedStartToLinkBlinkInProgress == 0U) {
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_278(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_279(& pLed->BlinkTimer);
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedStartToLinkBlinkInProgress = 1U;
    pLed->CurrLedState = 8;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
      tmp = msecs_to_jiffies(200U);
      ldv_mod_timer_280(& pLed->BlinkTimer, tmp + (unsigned long )jiffies);
    } else {
      pLed->BlinkingLedState = 1;
      tmp___0 = msecs_to_jiffies(100U);
      ldv_mod_timer_281(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
    }
  } else {
  }
  goto ldv_52089;
  case 2U: ;
  case 3U: ;
  if ((unsigned int )LedAction == 2U) {
    if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
      pLed1->bLedWPSBlinkInProgress = 0U;
      ldv_del_timer_sync_282(& pLed1->BlinkTimer);
      pLed1->BlinkingLedState = 2;
      pLed1->CurrLedState = 2;
      if ((unsigned int )pLed1->bLedOn != 0U) {
        ldv_mod_timer_283(& pLed->BlinkTimer, jiffies);
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 0U) {
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_284(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedNoLinkBlinkInProgress = 1U;
    pLed->CurrLedState = 4;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    tmp___1 = msecs_to_jiffies(1000U);
    ldv_mod_timer_285(& pLed->BlinkTimer, tmp___1 + (unsigned long )jiffies);
  } else {
  }
  goto ldv_52089;
  case 6U: ;
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
    tmp___3 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___3) {
    } else {
      goto _L;
    }
  } else
  _L:
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
    if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_286(& pLed->BlinkTimer);
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_287(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedScanBlinkInProgress = 1U;
    pLed->CurrLedState = 6;
    pLed->BlinkTimes = 24U;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    tmp___2 = msecs_to_jiffies(180U);
    ldv_mod_timer_288(& pLed->BlinkTimer, tmp___2 + (unsigned long )jiffies);
  } else {
  }
  goto ldv_52089;
  case 4U: ;
  case 5U: ;
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
      return;
    } else {
    }
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_289(& pLed->BlinkTimer);
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedBlinkInProgress = 1U;
    pLed->CurrLedState = 9;
    pLed->BlinkTimes = 2U;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    tmp___4 = msecs_to_jiffies(50U);
    ldv_mod_timer_290(& pLed->BlinkTimer, tmp___4 + (unsigned long )jiffies);
  } else {
  }
  goto ldv_52089;
  case 9U: ;
  case 11U: ;
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
    pLed1->bLedWPSBlinkInProgress = 0U;
    ldv_del_timer_sync_291(& pLed1->BlinkTimer);
    pLed1->BlinkingLedState = 2;
    pLed1->CurrLedState = 2;
    if ((unsigned int )pLed1->bLedOn != 0U) {
      ldv_mod_timer_292(& pLed->BlinkTimer, jiffies);
    } else {
    }
  } else {
  }
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U) {
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
      ldv_del_timer_sync_293(& pLed->BlinkTimer);
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_294(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
      ldv_del_timer_sync_295(& pLed->BlinkTimer);
      pLed->bLedScanBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedWPSBlinkInProgress = 1U;
    pLed->CurrLedState = 10;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
      tmp___5 = msecs_to_jiffies(200U);
      ldv_mod_timer_296(& pLed->BlinkTimer, tmp___5 + (unsigned long )jiffies);
    } else {
      pLed->BlinkingLedState = 1;
      tmp___6 = msecs_to_jiffies(100U);
      ldv_mod_timer_297(& pLed->BlinkTimer, tmp___6 + (unsigned long )jiffies);
    }
  } else {
  }
  goto ldv_52089;
  case 10U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_298(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  pLed->bLedNoLinkBlinkInProgress = 1U;
  pLed->CurrLedState = 4;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  tmp___7 = msecs_to_jiffies(1000U);
  ldv_mod_timer_299(& pLed->BlinkTimer, tmp___7 + (unsigned long )jiffies);
  goto ldv_52089;
  case 12U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_300(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  pLed->bLedNoLinkBlinkInProgress = 1U;
  pLed->CurrLedState = 4;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  tmp___8 = msecs_to_jiffies(1000U);
  ldv_mod_timer_301(& pLed->BlinkTimer, tmp___8 + (unsigned long )jiffies);
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_302(& pLed1->BlinkTimer);
  } else {
    pLed1->bLedWPSBlinkInProgress = 1U;
  }
  pLed1->CurrLedState = 11;
  if ((unsigned int )pLed1->bLedOn != 0U) {
    pLed1->BlinkingLedState = 2;
  } else {
    pLed1->BlinkingLedState = 1;
  }
  tmp___9 = msecs_to_jiffies(100U);
  ldv_mod_timer_303(& pLed->BlinkTimer, tmp___9 + (unsigned long )jiffies);
  goto ldv_52089;
  case 13U: ;
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_304(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  pLed->bLedNoLinkBlinkInProgress = 1U;
  pLed->CurrLedState = 4;
  if ((unsigned int )pLed->bLedOn != 0U) {
    pLed->BlinkingLedState = 2;
  } else {
    pLed->BlinkingLedState = 1;
  }
  tmp___10 = msecs_to_jiffies(1000U);
  ldv_mod_timer_305(& pLed->BlinkTimer, tmp___10 + (unsigned long )jiffies);
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_306(& pLed1->BlinkTimer);
  } else {
    pLed1->bLedWPSBlinkInProgress = 1U;
  }
  pLed1->CurrLedState = 12;
  pLed1->BlinkTimes = 10U;
  if ((unsigned int )pLed1->bLedOn != 0U) {
    pLed1->BlinkingLedState = 2;
  } else {
    pLed1->BlinkingLedState = 1;
  }
  tmp___11 = msecs_to_jiffies(100U);
  ldv_mod_timer_307(& pLed->BlinkTimer, tmp___11 + (unsigned long )jiffies);
  goto ldv_52089;
  case 7U:
  pLed->CurrLedState = 2;
  pLed->BlinkingLedState = 2;
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress != 0U) {
    ldv_del_timer_sync_308(& pLed->BlinkTimer);
    pLed->bLedNoLinkBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedLinkBlinkInProgress != 0U) {
    ldv_del_timer_sync_309(& pLed->BlinkTimer);
    pLed->bLedLinkBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
    ldv_del_timer_sync_310(& pLed->BlinkTimer);
    pLed->bLedBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_311(& pLed->BlinkTimer);
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
    ldv_del_timer_sync_312(& pLed->BlinkTimer);
    pLed->bLedScanBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed->bLedStartToLinkBlinkInProgress != 0U) {
    ldv_del_timer_sync_313(& pLed->BlinkTimer);
    pLed->bLedStartToLinkBlinkInProgress = 0U;
  } else {
  }
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
    ldv_del_timer_sync_314(& pLed1->BlinkTimer);
    pLed1->bLedWPSBlinkInProgress = 0U;
  } else {
  }
  pLed1->BlinkingLedState = 0;
  SwLedOff23a(padapter, pLed);
  SwLedOff23a(padapter, pLed1);
  goto ldv_52089;
  default: ;
  goto ldv_52089;
  }
  ldv_52089: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016Led %d\n", (unsigned int )pLed->CurrLedState);
  } else {
  }
  return;
}
}
static void SwLedControlMode5(struct rtw_adapter *padapter , enum led_ctl_mode LedAction )
{
  struct led_priv *ledpriv ;
  struct mlme_priv *pmlmepriv ;
  struct led_8723a *pLed ;
  unsigned long tmp ;
  bool tmp___0 ;
  unsigned long tmp___1 ;
  {
  ledpriv = & padapter->ledpriv;
  pmlmepriv = & padapter->mlmepriv;
  pLed = & ledpriv->SwLed0;
  switch ((unsigned int )LedAction) {
  case 1U: ;
  case 3U: ;
  case 2U:
  pLed->CurrLedState = 1;
  pLed->BlinkingLedState = 1;
  ldv_mod_timer_315(& pLed->BlinkTimer, jiffies);
  goto ldv_52112;
  case 6U: ;
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
    tmp___0 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___0) {
    } else {
      goto _L;
    }
  } else
  _L:
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
      ldv_del_timer_sync_316(& pLed->BlinkTimer);
      pLed->bLedBlinkInProgress = 0U;
    } else {
    }
    pLed->bLedScanBlinkInProgress = 1U;
    pLed->CurrLedState = 6;
    pLed->BlinkTimes = 24U;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    tmp = msecs_to_jiffies(180U);
    ldv_mod_timer_317(& pLed->BlinkTimer, tmp + (unsigned long )jiffies);
  } else {
  }
  goto ldv_52112;
  case 4U: ;
  case 5U: ;
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
    if ((unsigned int )pLed->CurrLedState == 6U) {
      return;
    } else {
    }
    pLed->bLedBlinkInProgress = 1U;
    pLed->CurrLedState = 9;
    pLed->BlinkTimes = 2U;
    if ((unsigned int )pLed->bLedOn != 0U) {
      pLed->BlinkingLedState = 2;
    } else {
      pLed->BlinkingLedState = 1;
    }
    tmp___1 = msecs_to_jiffies(50U);
    ldv_mod_timer_318(& pLed->BlinkTimer, tmp___1 + (unsigned long )jiffies);
  } else {
  }
  goto ldv_52112;
  case 7U:
  pLed->CurrLedState = 2;
  pLed->BlinkingLedState = 2;
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
    ldv_del_timer_sync_319(& pLed->BlinkTimer);
    pLed->bLedBlinkInProgress = 0U;
  } else {
  }
  SwLedOff23a(padapter, pLed);
  goto ldv_52112;
  default: ;
  goto ldv_52112;
  }
  ldv_52112: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016Led %d\n", (unsigned int )pLed->CurrLedState);
  } else {
  }
  return;
}
}
static void SwLedControlMode6(struct rtw_adapter *padapter , enum led_ctl_mode LedAction )
{
  struct led_priv *ledpriv ;
  struct led_8723a *pLed0 ;
  {
  ledpriv = & padapter->ledpriv;
  pLed0 = & ledpriv->SwLed0;
  switch ((unsigned int )LedAction) {
  case 1U: ;
  case 2U: ;
  case 3U:
  ldv_del_timer_sync_320(& pLed0->BlinkTimer);
  pLed0->CurrLedState = 1;
  pLed0->BlinkingLedState = 1;
  ldv_mod_timer_321(& pLed0->BlinkTimer, jiffies);
  goto ldv_52127;
  case 7U:
  SwLedOff23a(padapter, pLed0);
  goto ldv_52127;
  default: ;
  goto ldv_52127;
  }
  ldv_52127: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016ledcontrol 6 Led %d\n", (unsigned int )pLed0->CurrLedState);
  } else {
  }
  return;
}
}
void BlinkHandler23a(struct led_8723a *pLed )
{
  struct rtw_adapter *padapter ;
  struct led_priv *ledpriv ;
  {
  padapter = pLed->padapter;
  ledpriv = & padapter->ledpriv;
  if (padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) {
    return;
  } else {
  }
  switch ((unsigned int )ledpriv->LedStrategy) {
  case 0U:
  SwLedBlink(pLed);
  goto ldv_52136;
  case 1U:
  SwLedBlink1(pLed);
  goto ldv_52136;
  case 2U:
  SwLedBlink2(pLed);
  goto ldv_52136;
  case 3U:
  SwLedBlink3(pLed);
  goto ldv_52136;
  case 4U:
  SwLedBlink4(pLed);
  goto ldv_52136;
  case 5U:
  SwLedBlink5(pLed);
  goto ldv_52136;
  case 6U:
  SwLedBlink6(pLed);
  goto ldv_52136;
  default: ;
  goto ldv_52136;
  }
  ldv_52136: ;
  return;
}
}
void LedControl871x23a(struct rtw_adapter *padapter , enum led_ctl_mode LedAction )
{
  struct led_priv *ledpriv ;
  {
  ledpriv = & padapter->ledpriv;
  if ((padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) || (unsigned int )padapter->hw_init_completed == 0U) {
    return;
  } else {
  }
  if ((unsigned int )ledpriv->bRegUseLed == 0U) {
    return;
  } else {
  }
  if (((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) && ((((((unsigned int )LedAction == 4U || (unsigned int )LedAction == 5U) || (unsigned int )LedAction == 6U) || (unsigned int )LedAction == 2U) || (unsigned int )LedAction == 3U) || (unsigned int )LedAction == 1U)) {
    return;
  } else {
  }
  switch ((unsigned int )ledpriv->LedStrategy) {
  case 0U: ;
  goto ldv_52150;
  case 1U:
  SwLedControlMode1(padapter, LedAction);
  goto ldv_52150;
  case 2U:
  SwLedControlMode2(padapter, LedAction);
  goto ldv_52150;
  case 3U:
  SwLedControlMode3(padapter, LedAction);
  goto ldv_52150;
  case 4U:
  SwLedControlMode4(padapter, LedAction);
  goto ldv_52150;
  case 5U:
  SwLedControlMode5(padapter, LedAction);
  goto ldv_52150;
  case 6U:
  SwLedControlMode6(padapter, LedAction);
  goto ldv_52150;
  default: ;
  goto ldv_52150;
  }
  ldv_52150: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
    printk("\016LedStrategy:%d, LedAction %d\n", (unsigned int )ledpriv->LedStrategy,
           (unsigned int )LedAction);
  } else {
  }
  return;
}
}
void timer_init_1(void)
{
  {
  ldv_timer_1_0 = 0;
  ldv_timer_1_1 = 0;
  ldv_timer_1_2 = 0;
  ldv_timer_1_3 = 0;
  return;
}
}
int reg_timer_1(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& BlinkTimerCallback)) {
    activate_suitable_timer_1(timer, data);
  } else {
  }
  return (0);
}
}
void activate_suitable_timer_1(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_1_0 == 0 || ldv_timer_1_0 == 2) {
    ldv_timer_list_1_0 = timer;
    ldv_timer_list_1_0->data = data;
    ldv_timer_1_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_1_1 == 0 || ldv_timer_1_1 == 2) {
    ldv_timer_list_1_1 = timer;
    ldv_timer_list_1_1->data = data;
    ldv_timer_1_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_1_2 == 0 || ldv_timer_1_2 == 2) {
    ldv_timer_list_1_2 = timer;
    ldv_timer_list_1_2->data = data;
    ldv_timer_1_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_1_3 == 0 || ldv_timer_1_3 == 2) {
    ldv_timer_list_1_3 = timer;
    ldv_timer_list_1_3->data = data;
    ldv_timer_1_3 = 1;
    return;
  } else {
  }
  return;
}
}
void choose_timer_1(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_1_0 == 1) {
    ldv_timer_1_0 = 2;
    ldv_timer_1(ldv_timer_1_0, ldv_timer_list_1_0);
  } else {
  }
  goto ldv_52175;
  case 1: ;
  if (ldv_timer_1_1 == 1) {
    ldv_timer_1_1 = 2;
    ldv_timer_1(ldv_timer_1_1, ldv_timer_list_1_1);
  } else {
  }
  goto ldv_52175;
  case 2: ;
  if (ldv_timer_1_2 == 1) {
    ldv_timer_1_2 = 2;
    ldv_timer_1(ldv_timer_1_2, ldv_timer_list_1_2);
  } else {
  }
  goto ldv_52175;
  case 3: ;
  if (ldv_timer_1_3 == 1) {
    ldv_timer_1_3 = 2;
    ldv_timer_1(ldv_timer_1_3, ldv_timer_list_1_3);
  } else {
  }
  goto ldv_52175;
  default:
  ldv_stop();
  }
  ldv_52175: ;
  return;
}
}
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_1_0 == (unsigned long )timer) {
    if (ldv_timer_1_0 == 2 || pending_flag != 0) {
      ldv_timer_list_1_0 = timer;
      ldv_timer_list_1_0->data = data;
      ldv_timer_1_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_1_1 == (unsigned long )timer) {
    if (ldv_timer_1_1 == 2 || pending_flag != 0) {
      ldv_timer_list_1_1 = timer;
      ldv_timer_list_1_1->data = data;
      ldv_timer_1_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_1_2 == (unsigned long )timer) {
    if (ldv_timer_1_2 == 2 || pending_flag != 0) {
      ldv_timer_list_1_2 = timer;
      ldv_timer_list_1_2->data = data;
      ldv_timer_1_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_1_3 == (unsigned long )timer) {
    if (ldv_timer_1_3 == 2 || pending_flag != 0) {
      ldv_timer_list_1_3 = timer;
      ldv_timer_list_1_3->data = data;
      ldv_timer_1_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_1(timer, data);
  return;
}
}
void disable_suitable_timer_1(struct timer_list *timer )
{
  {
  if (ldv_timer_1_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_1_0) {
    ldv_timer_1_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_1_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_1_1) {
    ldv_timer_1_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_1_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_1_2) {
    ldv_timer_1_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_1_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_1_3) {
    ldv_timer_1_3 = 0;
    return;
  } else {
  }
  return;
}
}
void ldv_timer_1(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  BlinkTimerCallback(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void *ldv_kmem_cache_alloc_200(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_206(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_208(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_210(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_211(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_212(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_213(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_214(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_215(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_216(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_del_timer_sync_217(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_218(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_219(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_220(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_221(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_222(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_223(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_224(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_225(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_226(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_227(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_228(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_229(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_230(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_231(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_232(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_233(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_234(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___19 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_235(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___20 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_236(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___21 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_237(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___22 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_238(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___23 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_239(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___24 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_240(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___25 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_241(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___26 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_242(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___27 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_243(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___28 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_244(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___29 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_245(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___30 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_246(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___31 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_247(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___32 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_248(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___33 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_249(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___34 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_250(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___35 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_251(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___36 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_252(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___37 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_253(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___38 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_254(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___39 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_255(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___40 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_256(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___41 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_257(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___42 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_258(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___43 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_259(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___44 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_260(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___45 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_261(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___46 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_262(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___47 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_263(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___48 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_264(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___49 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_265(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___50 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_266(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___51 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_267(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___52 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_268(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___53 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_269(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___54 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_270(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___55 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_271(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___56 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_272(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___57 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_273(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___58 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_274(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___59 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_275(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___60 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_276(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___61 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_277(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___62 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_278(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___63 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_279(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___64 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_280(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___65 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_281(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___66 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_282(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___67 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_283(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___68 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_284(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___69 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_285(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___70 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_286(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___71 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_287(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___72 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_288(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___73 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_289(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___74 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_290(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___75 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_291(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___76 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_292(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___77 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_293(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___78 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_294(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___79 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_295(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___80 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_296(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___81 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_297(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___82 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_298(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___83 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_299(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___84 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_300(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___85 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_301(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___86 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_302(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___87 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_303(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___88 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_304(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___89 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_305(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___90 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_306(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___91 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_307(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___92 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_308(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___93 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_309(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___94 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_310(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___95 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_311(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___96 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_312(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___97 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_313(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___98 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_314(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___99 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_315(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___100 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_316(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___101 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_317(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___102 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_318(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___103 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_319(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___104 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_320(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___105 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_321(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___106 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
extern void __list_del_entry(struct list_head * ) ;
__inline static void list_del_init(struct list_head *entry )
{
  {
  __list_del_entry(entry);
  INIT_LIST_HEAD(entry);
  return;
}
}
__inline static void atomic_set(atomic_t *v , int i )
{
  {
  v->counter = i;
  return;
}
}
extern void __raw_spin_lock_init(raw_spinlock_t * , char const * , struct lock_class_key * ) ;
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock )
{
  {
  return (& lock->ldv_6347.rlock);
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
extern unsigned int jiffies_to_msecs(unsigned long const ) ;
int ldv_mod_timer_470(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_471(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_472(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_473(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_474(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_476(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_477(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_478(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_479(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_469(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_475(struct timer_list *ldv_func_arg1 ) ;
void *ldv_kmem_cache_alloc_452(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct timer_list *ldv_timer_list_2_0 ;
int ldv_timer_5_2 ;
struct timer_list *ldv_timer_list_5_0 ;
struct timer_list *ldv_timer_list_3_2 ;
int ldv_timer_2_2 ;
int ldv_timer_3_3 ;
struct timer_list *ldv_timer_list_5_3 ;
int ldv_timer_4_3 ;
struct timer_list *ldv_timer_list_5_1 ;
struct timer_list *ldv_timer_list_4_0 ;
struct timer_list *ldv_timer_list_2_1 ;
int ldv_timer_2_0 ;
struct timer_list *ldv_timer_list_4_3 ;
int ldv_timer_5_3 ;
int ldv_timer_3_2 ;
int ldv_timer_3_0 ;
int ldv_timer_4_1 ;
struct timer_list *ldv_timer_list_4_1 ;
struct timer_list *ldv_timer_list_2_2 ;
int ldv_timer_4_0 ;
int ldv_timer_2_1 ;
struct timer_list *ldv_timer_list_5_2 ;
struct timer_list *ldv_timer_list_3_1 ;
int ldv_timer_5_1 ;
int ldv_timer_2_3 ;
struct timer_list *ldv_timer_list_3_3 ;
int ldv_timer_3_1 ;
int ldv_timer_4_2 ;
int ldv_timer_5_0 ;
struct timer_list *ldv_timer_list_4_2 ;
struct timer_list *ldv_timer_list_2_3 ;
struct timer_list *ldv_timer_list_3_0 ;
void ldv_timer_5(int state , struct timer_list *timer ) ;
void choose_timer_5(void) ;
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void timer_init_4(void) ;
void timer_init_2(void) ;
void disable_suitable_timer_3(struct timer_list *timer ) ;
void activate_suitable_timer_3(struct timer_list *timer , unsigned long data ) ;
void timer_init_5(void) ;
void disable_suitable_timer_2(struct timer_list *timer ) ;
int reg_timer_3(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void disable_suitable_timer_5(struct timer_list *timer ) ;
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) ;
void ldv_timer_2(int state , struct timer_list *timer ) ;
void choose_timer_2(void) ;
int reg_timer_2(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void choose_timer_3(void) ;
void timer_init_3(void) ;
void choose_timer_4(void) ;
void disable_suitable_timer_4(struct timer_list *timer ) ;
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) ;
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void ldv_timer_4(int state , struct timer_list *timer ) ;
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) ;
void activate_suitable_timer_2(struct timer_list *timer , unsigned long data ) ;
void ldv_timer_3(int state , struct timer_list *timer ) ;
extern struct pid *find_vpid(int ) ;
extern int kill_pid(struct pid * , int , int ) ;
struct sk_buff *ldv_skb_clone_460(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_468(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_462(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_458(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_466(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_467(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_463(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_464(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_465(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
extern void netif_carrier_on(struct net_device * ) ;
__inline static bool is_zero_ether_addr(u8 const *addr )
{
  {
  return (((unsigned int )*((u32 const *)addr) | (unsigned int )*((u16 const *)addr + 4U)) == 0U);
}
}
__inline static bool is_multicast_ether_addr(u8 const *addr )
{
  {
  return (((int )*addr & 1) != 0);
}
}
__inline static bool ether_addr_equal(u8 const *addr1 , u8 const *addr2 )
{
  u32 fold ;
  {
  fold = ((unsigned int )*((u32 const *)addr1) ^ (unsigned int )*((u32 const *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const *)addr2 + 4U)));
  return (fold == 0U);
}
}
__inline static void *wiphy_priv(struct wiphy *wiphy )
{
  long tmp ;
  {
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3111), "i" (12UL));
    ldv_45953: ;
    goto ldv_45953;
  } else {
  }
  return ((void *)(& wiphy->priv));
}
}
__inline static void *wdev_priv(struct wireless_dev *wdev )
{
  long tmp ;
  void *tmp___0 ;
  {
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3343), "i" (12UL));
    ldv_46033: ;
    goto ldv_46033;
  } else {
  }
  tmp___0 = wiphy_priv(wdev->wiphy);
  return (tmp___0);
}
}
unsigned char MCS_rate_2R23A[16U] ;
unsigned char MCS_rate_1R23A[16U] ;
void _rtw_init_queue23a(struct rtw_queue *pqueue ) ;
void rtw_update_protection23a(struct rtw_adapter *padapter , u8 *ie , uint ie_len ) ;
void rtw_os_xmit_schedule23a(struct rtw_adapter *padapter ) ;
u32 rtw_free_uc_swdec_pending_queue23a(struct rtw_adapter *adapter ) ;
__inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex )
{
  s32 SignalPower ;
  {
  SignalPower = (int )((SignalStrengthIndex + 1U) >> 1);
  SignalPower = SignalPower + -95;
  return (SignalPower);
}
}
int GetHalDefVar8192CUsb(struct rtw_adapter *Adapter , enum hal_def_variable eVariable ,
                         void *pValue ) ;
void rtl8723a_set_rxdma_agg_pg_th(struct rtw_adapter *padapter , u8 val ) ;
int rtw_free_stainfo23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void rtw_free_all_stainfo23a(struct rtw_adapter *padapter ) ;
int rtw_init_bcmc_stainfo23a(struct rtw_adapter *padapter ) ;
bool rtw_access_ctrl23a(struct rtw_adapter *padapter , u8 *mac_addr ) ;
void rtw_os_indicate_disconnect23a(struct rtw_adapter *adapter ) ;
void rtw_reset_securitypriv23a(struct rtw_adapter *adapter ) ;
void rtw_joinbss_event_prehandle23a(struct rtw_adapter *adapter , u8 *pbuf ) ;
void rtw_survey_event_cb23a(struct rtw_adapter *adapter , u8 const *pbuf ) ;
void rtw_surveydone_event_callback23a(struct rtw_adapter *adapter , u8 const *pbuf ) ;
void rtw23a_joinbss_event_cb(struct rtw_adapter *adapter , u8 const *pbuf ) ;
void rtw_stassoc_event_callback23a(struct rtw_adapter *adapter , u8 const *pbuf ) ;
void rtw_stadel_event_callback23a(struct rtw_adapter *adapter , u8 const *pbuf ) ;
void rtw23a_join_to_handler(unsigned long data ) ;
int rtw_init_mlme_priv23a(struct rtw_adapter *padapter ) ;
void rtw_free_mlme_priv23a(struct mlme_priv *pmlmepriv ) ;
int rtw_set_key23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ,
                   int keyid , u8 set_tx ) ;
u16 rtw_get_capability23a(struct wlan_bssid_ex *bss ) ;
void rtw_update_scanned_network23a(struct rtw_adapter *adapter , struct wlan_bssid_ex *target ) ;
struct wlan_network *rtw_find_network23a(struct rtw_queue *scanned_queue , u8 *addr ) ;
void rtw_scan_abort23a(struct rtw_adapter *adapter ) ;
void rtw_init_registrypriv_dev_network23a(struct rtw_adapter *adapter ) ;
void rtw_get_encrypt_decrypt_from_registrypriv23a(struct rtw_adapter *adapter ) ;
void rtw_scan_timeout_handler23a(unsigned long data ) ;
void rtw_dynamic_check_timer_handler(unsigned long data ) ;
void rtw_clear_scan_deny(struct rtw_adapter *adapter ) ;
void rtw_set_scan_deny_timer_hdl(unsigned long data ) ;
void rtw_set_scan_deny(struct rtw_adapter *adapter , u32 ms ) ;
void rtw23a_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv ) ;
int rtw_if_up23a(struct rtw_adapter *padapter ) ;
int rtw_linked_check(struct rtw_adapter *padapter ) ;
__le16 *rtw_get_beacon_interval23a_from_ie(u8 *ie ) ;
void rtw_joinbss_reset23a(struct rtw_adapter *padapter ) ;
void rtw_update_ht_cap23a(struct rtw_adapter *padapter , u8 *pie , uint ie_len ) ;
void rtw_issue_addbareq_cmd23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
int is_same_network23a(struct wlan_bssid_ex *src , struct wlan_bssid_ex *dst ) ;
void rtw23a_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) ;
void rtw_set_roaming(struct rtw_adapter *adapter , u8 to_roaming ) ;
void update_network23a(struct wlan_bssid_ex *dst , struct wlan_bssid_ex *src , struct rtw_adapter *padapter ,
                       bool update_ie ) ;
void update_sta_info23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void mlmeext_joinbss_event_callback23a(struct rtw_adapter *padapter , int join_res ) ;
void mlmeext_sta_del_event_callback23a(struct rtw_adapter *padapter ) ;
void mlmeext_sta_add_event_callback23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void ap_sta_info_defer_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter ) ;
void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter ) ;
void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter ) ;
void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv , bool aborted ) ;
__inline static u8 *myid(struct eeprom_priv *peepriv )
{
  {
  return ((u8 *)(& peepriv->mac_addr));
}
}
void rtl8723a_SetHalODMVar(struct rtw_adapter *Adapter , enum hal_odm_variable eVariable ,
                           void *pValue1 , bool bSet ) ;
void rtw_sreset_reset(struct rtw_adapter *active_adapter ) ;
static void rtw_init_mlme_timer(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  {
  pmlmepriv = & padapter->mlmepriv;
  reg_timer_6(& pmlmepriv->assoc_timer, & rtw23a_join_to_handler, (unsigned long )padapter);
  reg_timer_6(& pmlmepriv->scan_to_timer, & rtw_scan_timeout_handler23a, (unsigned long )padapter);
  reg_timer_6(& pmlmepriv->dynamic_chk_timer, & rtw_dynamic_check_timer_handler, (unsigned long )padapter);
  reg_timer_6(& pmlmepriv->set_scan_deny_timer, & rtw_set_scan_deny_timer_hdl, (unsigned long )padapter);
  return;
}
}
int rtw_init_mlme_priv23a(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  int res ;
  struct lock_class_key __key ;
  {
  pmlmepriv = & padapter->mlmepriv;
  res = 1;
  pmlmepriv->nic_hdl = padapter;
  pmlmepriv->fw_state = 0;
  pmlmepriv->cur_network.network.ifmode = 0;
  pmlmepriv->scan_mode = 1;
  spinlock_check(& pmlmepriv->lock);
  __raw_spin_lock_init(& pmlmepriv->lock.ldv_6347.rlock, "&(&pmlmepriv->lock)->rlock",
                       & __key);
  _rtw_init_queue23a(& pmlmepriv->scanned_queue);
  memset((void *)(& pmlmepriv->assoc_ssid), 0, 33UL);
  rtw_clear_scan_deny(padapter);
  rtw_init_mlme_timer(padapter);
  return (res);
}
}
static void rtw_free_mlme_ie_data(u8 **ppie , u32 *plen )
{
  {
  if ((unsigned long )*ppie != (unsigned long )((u8 *)0U)) {
    kfree((void const *)*ppie);
    *plen = 0U;
    *ppie = (u8 *)0U;
  } else {
  }
  return;
}
}
void rtw23a_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv )
{
  {
  kfree((void const *)pmlmepriv->assoc_req);
  kfree((void const *)pmlmepriv->assoc_rsp);
  rtw_free_mlme_ie_data(& pmlmepriv->wps_beacon_ie, & pmlmepriv->wps_beacon_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->wps_probe_req_ie, & pmlmepriv->wps_probe_req_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->wps_probe_resp_ie, & pmlmepriv->wps_probe_resp_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->wps_assoc_resp_ie, & pmlmepriv->wps_assoc_resp_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_beacon_ie, & pmlmepriv->p2p_beacon_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_probe_req_ie, & pmlmepriv->p2p_probe_req_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_probe_resp_ie, & pmlmepriv->p2p_probe_resp_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_go_probe_resp_ie, & pmlmepriv->p2p_go_probe_resp_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_assoc_req_ie, & pmlmepriv->p2p_assoc_req_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_beacon_ie, & pmlmepriv->wfd_beacon_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_probe_req_ie, & pmlmepriv->wfd_probe_req_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_probe_resp_ie, & pmlmepriv->wfd_probe_resp_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_go_probe_resp_ie, & pmlmepriv->wfd_go_probe_resp_ie_len);
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_assoc_req_ie, & pmlmepriv->wfd_assoc_req_ie_len);
  return;
}
}
void rtw_free_mlme_priv23a(struct mlme_priv *pmlmepriv )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016rtw_free_mlme_priv23a\n");
  } else {
  }
  rtw23a_free_mlme_priv_ie_data(pmlmepriv);
  return;
}
}
struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv , int gfp )
{
  struct wlan_network *pnetwork ;
  void *tmp ;
  {
  tmp = kzalloc(928UL, (gfp_t )gfp);
  pnetwork = (struct wlan_network *)tmp;
  if ((unsigned long )pnetwork != (unsigned long )((struct wlan_network *)0)) {
    INIT_LIST_HEAD(& pnetwork->list);
    pnetwork->network_type = 0;
    pnetwork->fixed = 0;
    pnetwork->last_scanned = jiffies;
    pnetwork->aid = 0;
    pnetwork->join_res = 0;
  } else {
  }
  return (pnetwork);
}
}
static void _rtw_free_network23a(struct mlme_priv *pmlmepriv , struct wlan_network *pnetwork )
{
  {
  if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
    return;
  } else {
  }
  if (pnetwork->fixed == 1) {
    return;
  } else {
  }
  list_del_init(& pnetwork->list);
  kfree((void const *)pnetwork);
  return;
}
}
struct wlan_network *rtw_find_network23a(struct rtw_queue *scanned_queue , u8 *addr )
{
  struct list_head *phead ;
  struct list_head *plist ;
  struct wlan_network *pnetwork ;
  bool tmp ;
  struct list_head const *__mptr ;
  bool tmp___0 ;
  {
  pnetwork = (struct wlan_network *)0;
  tmp = is_zero_ether_addr((u8 const *)addr);
  if ((int )tmp) {
    pnetwork = (struct wlan_network *)0;
    goto exit;
  } else {
  }
  phead = get_list_head(scanned_queue);
  plist = phead->next;
  goto ldv_54345;
  ldv_54344:
  __mptr = (struct list_head const *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  tmp___0 = ether_addr_equal((u8 const *)addr, (u8 const *)(& pnetwork->network.MacAddress));
  if ((int )tmp___0) {
    goto ldv_54343;
  } else {
  }
  plist = plist->next;
  ldv_54345: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54344;
  } else {
  }
  ldv_54343: ;
  if ((unsigned long )plist == (unsigned long )phead) {
    pnetwork = (struct wlan_network *)0;
  } else {
  }
  exit: ;
  return (pnetwork);
}
}
void rtw_free_network_queue23a(struct rtw_adapter *padapter )
{
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct wlan_network *pnetwork ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *scanned_queue ;
  struct list_head const *__mptr ;
  {
  pmlmepriv = & padapter->mlmepriv;
  scanned_queue = & pmlmepriv->scanned_queue;
  spin_lock_bh(& scanned_queue->lock);
  phead = get_list_head(scanned_queue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_54358;
  ldv_54357:
  __mptr = (struct list_head const *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  _rtw_free_network23a(pmlmepriv, pnetwork);
  plist = ptmp;
  ptmp = plist->next;
  ldv_54358: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54357;
  } else {
  }
  spin_unlock_bh(& scanned_queue->lock);
  return;
}
}
int rtw_if_up23a(struct rtw_adapter *padapter )
{
  int res ;
  bool tmp ;
  int tmp___0 ;
  {
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto _L;
  } else {
    tmp = check_fwstate(& padapter->mlmepriv, 1);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      _L:
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
        printk("\016rtw_if_up23a:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped,
               padapter->bSurpriseRemoved);
      } else {
      }
      res = 0;
    } else {
      res = 1;
    }
  }
  return (res);
}
}
void rtw_generate_random_ibss23a(u8 *pibss )
{
  unsigned long curtime ;
  {
  curtime = jiffies;
  *pibss = 2U;
  *(pibss + 1UL) = 17U;
  *(pibss + 2UL) = 135U;
  *(pibss + 3UL) = (u8 )curtime;
  *(pibss + 4UL) = (u8 )(curtime >> 8);
  *(pibss + 5UL) = (u8 )(curtime >> 16);
  return;
}
}
void rtw_set_roaming(struct rtw_adapter *adapter , u8 to_roaming )
{
  {
  if ((unsigned int )to_roaming == 0U) {
    adapter->mlmepriv.to_join = 0U;
  } else {
  }
  adapter->mlmepriv.to_roaming = to_roaming;
  return;
}
}
static void _rtw_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network )
{
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  int do_join_r ;
  size_t __len ;
  void *__ret ;
  {
  pmlmepriv = & padapter->mlmepriv;
  if ((unsigned long )tgt_network != (unsigned long )((struct wlan_network *)0)) {
    pnetwork = tgt_network;
  } else {
    pnetwork = & pmlmepriv->cur_network;
  }
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: roaming from %s(%02x:%02x:%02x:%02x:%02x:%02x), length:%d\n",
             (u8 *)(& pnetwork->network.Ssid.ssid), (int )*((u8 *)(& pnetwork->network.MacAddress)),
             (int )*((u8 *)(& pnetwork->network.MacAddress) + 1UL), (int )*((u8 *)(& pnetwork->network.MacAddress) + 2UL),
             (int )*((u8 *)(& pnetwork->network.MacAddress) + 3UL), (int )*((u8 *)(& pnetwork->network.MacAddress) + 4UL),
             (int )*((u8 *)(& pnetwork->network.MacAddress) + 5UL), (int )pnetwork->network.Ssid.ssid_len);
    } else {
    }
    __len = 33UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& pmlmepriv->assoc_ssid), (void const *)(& pnetwork->network.Ssid),
                       __len);
    } else {
      __ret = memcpy((void *)(& pmlmepriv->assoc_ssid), (void const *)(& pnetwork->network.Ssid),
                               __len);
    }
    pmlmepriv->assoc_by_bssid = 0U;
    ldv_54385:
    do_join_r = rtw_do_join23a(padapter);
    if (do_join_r == 1) {
      goto ldv_54382;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: roaming do_join return %d\n", do_join_r);
      } else {
      }
      pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
      if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
        goto ldv_54383;
      } else {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s(%d) -to roaming fail, indicate_disconnect\n",
                 "_rtw_roaming", 511);
        } else {
        }
        rtw_indicate_disconnect23a(padapter);
        goto ldv_54382;
      }
    }
    ldv_54383: ;
    goto ldv_54385;
    ldv_54382: ;
  } else {
  }
  return;
}
}
void rtw23a_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network )
{
  struct mlme_priv *pmlmepriv ;
  {
  pmlmepriv = & padapter->mlmepriv;
  spin_lock_bh(& pmlmepriv->lock);
  _rtw_roaming(padapter, tgt_network);
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
__le16 *rtw_get_capability23a_from_ie(u8 *ie )
{
  {
  return ((__le16 *)ie + 10U);
}
}
u16 rtw_get_capability23a(struct wlan_bssid_ex *bss )
{
  u16 val ;
  size_t __len ;
  void *__ret ;
  __le16 *tmp ;
  __le16 *tmp___0 ;
  {
  __len = 2UL;
  if (__len > 63UL) {
    tmp = rtw_get_capability23a_from_ie((u8 *)(& bss->IEs));
    __ret = memcpy((void *)(& val), (void const *)tmp, __len);
  } else {
    tmp___0 = rtw_get_capability23a_from_ie((u8 *)(& bss->IEs));
    __ret = memcpy((void *)(& val), (void const *)tmp___0, __len);
  }
  return (val);
}
}
__le16 *rtw_get_beacon_interval23a_from_ie(u8 *ie )
{
  {
  return ((__le16 *)ie + 8U);
}
}
static void rtw_free_network_nolock(struct mlme_priv *pmlmepriv , struct wlan_network *pnetwork )
{
  {
  _rtw_free_network23a(pmlmepriv, pnetwork);
  return;
}
}
int rtw_is_same_ibss23a(struct rtw_adapter *adapter , struct wlan_network *pnetwork )
{
  int ret ;
  struct security_priv *psecuritypriv ;
  {
  ret = 1;
  psecuritypriv = & adapter->securitypriv;
  if (psecuritypriv->dot11PrivacyAlgrthm != 0U && pnetwork->network.Privacy == 0U) {
    ret = 0;
  } else
  if (psecuritypriv->dot11PrivacyAlgrthm == 0U && pnetwork->network.Privacy == 1U) {
    ret = 0;
  } else {
    ret = 1;
  }
  return (ret);
}
}
__inline int is_same_ess(struct wlan_bssid_ex *a , struct wlan_bssid_ex *b ) ;
__inline int is_same_ess(struct wlan_bssid_ex *a , struct wlan_bssid_ex *b )
{
  int tmp ;
  int tmp___0 ;
  {
  if ((int )a->Ssid.ssid_len == (int )b->Ssid.ssid_len) {
    tmp = memcmp((void const *)(& a->Ssid.ssid), (void const *)(& b->Ssid.ssid),
                 (size_t )a->Ssid.ssid_len);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int is_same_network23a(struct wlan_bssid_ex *src , struct wlan_bssid_ex *dst )
{
  u16 s_cap ;
  u16 d_cap ;
  __le16 *tmp ;
  __le16 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  tmp = rtw_get_capability23a_from_ie((u8 *)(& src->IEs));
  s_cap = get_unaligned_le16((void const *)tmp);
  tmp___0 = rtw_get_capability23a_from_ie((u8 *)(& dst->IEs));
  d_cap = get_unaligned_le16((void const *)tmp___0);
  if ((int )src->Ssid.ssid_len == (int )dst->Ssid.ssid_len) {
    tmp___1 = ether_addr_equal((u8 const *)(& src->MacAddress), (u8 const *)(& dst->MacAddress));
    if ((int )tmp___1) {
      tmp___2 = memcmp((void const *)(& src->Ssid.ssid), (void const *)(& dst->Ssid.ssid),
                       (size_t )src->Ssid.ssid_len);
      if (tmp___2 == 0) {
        if ((((int )s_cap ^ (int )d_cap) & 2) == 0) {
          if ((((int )s_cap ^ (int )d_cap) & 1) == 0) {
            tmp___3 = 1;
          } else {
            tmp___3 = 0;
          }
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  return (tmp___3);
}
}
struct wlan_network *rtw_get_oldest_wlan_network23a(struct rtw_queue *scanned_queue )
{
  struct list_head *plist ;
  struct list_head *phead ;
  struct wlan_network *pwlan ;
  struct wlan_network *oldest ;
  struct list_head const *__mptr ;
  {
  oldest = (struct wlan_network *)0;
  phead = get_list_head(scanned_queue);
  plist = phead->next;
  goto ldv_54443;
  ldv_54442:
  __mptr = (struct list_head const *)plist;
  pwlan = (struct wlan_network *)__mptr;
  if (pwlan->fixed != 1) {
    if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0) || (long )(pwlan->last_scanned - oldest->last_scanned) < 0L) {
      oldest = pwlan;
    } else {
    }
  } else {
  }
  plist = plist->next;
  ldv_54443: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54442;
  } else {
  }
  return (oldest);
}
}
void update_network23a(struct wlan_bssid_ex *dst , struct wlan_bssid_ex *src , struct rtw_adapter *padapter ,
                       bool update_ie )
{
  u8 ss_ori ;
  u8 sq_ori ;
  long rssi_ori ;
  u8 ss_smp ;
  u8 sq_smp ;
  long rssi_smp ;
  u8 ss_final ;
  u8 sq_final ;
  long rssi_final ;
  bool tmp ;
  int tmp___0 ;
  size_t __len ;
  uint tmp___1 ;
  void *__ret ;
  {
  ss_ori = dst->PhyInfo.SignalStrength;
  sq_ori = dst->PhyInfo.SignalQuality;
  rssi_ori = dst->Rssi;
  ss_smp = src->PhyInfo.SignalStrength;
  sq_smp = src->PhyInfo.SignalQuality;
  rssi_smp = src->Rssi;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s %s(%pM, ch%u) ss_ori:%3u, sq_ori:%3u, rssi_ori:%3ld, ss_smp:%3u, sq_smp:%3u, rssi_smp:%3ld\n",
           "update_network23a", (u8 *)(& src->Ssid.ssid), (u8 *)(& src->MacAddress),
           src->DSConfig, (int )ss_ori, (int )sq_ori, rssi_ori, (int )ss_smp, (int )sq_smp,
           rssi_smp);
  } else {
  }
  tmp = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp) {
    tmp___0 = is_same_network23a(& padapter->mlmepriv.cur_network.network, src);
    if (tmp___0 != 0) {
      ss_final = padapter->recvpriv.signal_strength;
      sq_final = padapter->recvpriv.signal_qual;
      if ((unsigned int )sq_smp != 101U) {
        rssi_final = (src->Rssi + dst->Rssi * 4L) / 5L;
      } else {
        rssi_final = rssi_ori;
      }
    } else {
      goto _L;
    }
  } else
  _L:
  if ((unsigned int )sq_smp != 101U) {
    ss_final = (u8 )(((unsigned int )src->PhyInfo.SignalStrength + (unsigned int )dst->PhyInfo.SignalStrength * 4U) / 5U);
    sq_final = (u8 )(((unsigned int )src->PhyInfo.SignalQuality + (unsigned int )dst->PhyInfo.SignalQuality * 4U) / 5U);
    rssi_final = src->Rssi + (dst->Rssi * 4L) / 5L;
  } else {
    ss_final = dst->PhyInfo.SignalStrength;
    sq_final = dst->PhyInfo.SignalQuality;
    rssi_final = dst->Rssi;
  }
  if ((int )update_ie) {
    tmp___1 = get_wlan_bssid_ex_sz(src);
    __len = (size_t )tmp___1;
    __ret = memcpy((void *)dst, (void const *)src, __len);
  } else {
  }
  dst->PhyInfo.SignalStrength = ss_final;
  dst->PhyInfo.SignalQuality = sq_final;
  dst->Rssi = rssi_final;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s %s(%pM), SignalStrength:%u, SignalQuality:%u, RawRSSI:%ld\n",
           "update_network23a", (u8 *)(& dst->Ssid.ssid), (u8 *)(& dst->MacAddress),
           (int )dst->PhyInfo.SignalStrength, (int )dst->PhyInfo.SignalQuality, dst->Rssi);
  } else {
  }
  return;
}
}
static void update_current_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *pnetwork )
{
  struct mlme_priv *pmlmepriv ;
  int bcn_size ;
  bool tmp ;
  int tmp___0 ;
  {
  pmlmepriv = & adapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    tmp___0 = is_same_network23a(& pmlmepriv->cur_network.network, pnetwork);
    if (tmp___0 != 0) {
      update_network23a(& pmlmepriv->cur_network.network, pnetwork, adapter, 1);
      bcn_size = 12;
      rtw_update_protection23a(adapter, (u8 *)(& pmlmepriv->cur_network.network.IEs) + (unsigned long )bcn_size,
                               pmlmepriv->cur_network.network.IELength);
    } else {
    }
  } else {
  }
  return;
}
}
void rtw_update_scanned_network23a(struct rtw_adapter *adapter , struct wlan_bssid_ex *target )
{
  struct list_head *plist ;
  struct list_head *phead ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  struct wlan_network *oldest ;
  struct rtw_queue *queue ;
  u32 bssid_ex_sz ;
  int found ;
  struct list_head const *__mptr ;
  int tmp ;
  size_t __len ;
  void *__ret ;
  bool update_ie ;
  {
  pmlmepriv = & adapter->mlmepriv;
  pnetwork = (struct wlan_network *)0;
  oldest = (struct wlan_network *)0;
  queue = & pmlmepriv->scanned_queue;
  found = 0;
  spin_lock_bh(& queue->lock);
  phead = get_list_head(queue);
  plist = phead->next;
  goto ldv_54492;
  ldv_54491:
  __mptr = (struct list_head const *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  tmp = is_same_network23a(& pnetwork->network, target);
  if (tmp != 0) {
    found = 1;
    goto ldv_54484;
  } else {
  }
  if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0) || (long )(pnetwork->last_scanned - oldest->last_scanned) < 0L) {
    oldest = pnetwork;
  } else {
  }
  plist = plist->next;
  ldv_54492: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54491;
  } else {
  }
  ldv_54484: ;
  if (found == 0) {
    pnetwork = rtw_alloc_network(pmlmepriv, 32);
    if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
      if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0)) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
          printk("\016\n\n\nsomething wrong here\n\n\n");
        } else {
        }
        goto exit;
      } else {
      }
      pnetwork = oldest;
    } else {
      list_add_tail(& pnetwork->list, & queue->queue);
    }
    bssid_ex_sz = get_wlan_bssid_ex_sz(target);
    target->Length = bssid_ex_sz;
    __len = (size_t )bssid_ex_sz;
    __ret = memcpy((void *)(& pnetwork->network), (void const *)target,
                             __len);
    pnetwork->fixed = 0;
    pnetwork->last_scanned = jiffies;
    pnetwork->network_type = 0;
    pnetwork->aid = 0;
    pnetwork->join_res = 0;
    if ((unsigned int )pnetwork->network.PhyInfo.SignalQuality == 101U) {
      pnetwork->network.PhyInfo.SignalQuality = 0U;
    } else {
    }
  } else {
    update_ie = 1;
    pnetwork->last_scanned = jiffies;
    if (pnetwork->network.IELength > target->IELength && (unsigned int )target->reserved == 1U) {
      update_ie = 0;
    } else {
    }
    update_network23a(& pnetwork->network, target, adapter, (int )update_ie);
  }
  exit:
  spin_unlock_bh(& queue->lock);
  return;
}
}
static void rtw_add_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *pnetwork )
{
  {
  update_current_network(adapter, pnetwork);
  rtw_update_scanned_network23a(adapter, pnetwork);
  return;
}
}
static int rtw_is_desired_network(struct rtw_adapter *adapter , struct wlan_network *pnetwork )
{
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  u32 desired_encmode ;
  u32 privacy ;
  uint wps_ielen ;
  int bselected ;
  u8 *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  psecuritypriv = & adapter->securitypriv;
  pmlmepriv = & adapter->mlmepriv;
  bselected = 1;
  desired_encmode = psecuritypriv->ndisencryptstatus;
  privacy = pnetwork->network.Privacy;
  tmp___0 = check_fwstate(pmlmepriv, 256);
  if ((int )tmp___0) {
    tmp = rtw_get_wps_ie23a((u8 *)(& pnetwork->network.IEs) + 12UL, pnetwork->network.IELength - 12U,
                            (u8 *)0U, & wps_ielen);
    if ((unsigned long )tmp != (unsigned long )((u8 *)0U)) {
      return (1);
    } else {
      return (0);
    }
  } else {
  }
  if ((unsigned int )adapter->registrypriv.wifi_spec == 1U) {
    if (desired_encmode == 1U && privacy != 0U) {
      bselected = 0;
    } else {
    }
  } else {
  }
  if (desired_encmode != 1U && privacy == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: desired_encmode: %d, privacy: %d\n", desired_encmode,
             privacy);
    } else {
    }
    bselected = 0;
  } else {
  }
  tmp___1 = check_fwstate(pmlmepriv, 32);
  if ((int )tmp___1) {
    if ((unsigned int )pnetwork->network.ifmode != (unsigned int )pmlmepriv->cur_network.network.ifmode) {
      bselected = 0;
    } else {
    }
  } else {
  }
  return (bselected);
}
}
void rtw_atimdone_event_callback23a(struct rtw_adapter *adapter , u8 const *pbuf )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016receive atimdone_evet\n");
  } else {
  }
  return;
}
}
void rtw_survey_event_cb23a(struct rtw_adapter *adapter , u8 const *pbuf )
{
  u32 len ;
  struct wlan_bssid_ex *pnetwork ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *ibss_wlan ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  pmlmepriv = & adapter->mlmepriv;
  pnetwork = (struct wlan_bssid_ex *)pbuf;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016rtw_survey_event_cb23a, ssid=%s\n", (u8 *)(& pnetwork->Ssid.ssid));
  } else {
  }
  len = get_wlan_bssid_ex_sz(pnetwork);
  if (len > 863U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016\n ****rtw_survey_event_cb23a: return a wrong bss ***\n");
    } else {
    }
    return;
  } else {
  }
  spin_lock_bh(& pmlmepriv->lock);
  tmp___0 = check_fwstate(pmlmepriv, 64);
  if ((int )tmp___0) {
    tmp = ether_addr_equal((u8 const *)(& pmlmepriv->cur_network.network.MacAddress),
                           (u8 const *)(& pnetwork->MacAddress));
    if ((int )tmp) {
      __len = 8UL;
      if (__len > 63UL) {
        __ret = memcpy((void *)(& pmlmepriv->cur_network.network.IEs), (void const *)(& pnetwork->IEs),
                         __len);
      } else {
        __ret = memcpy((void *)(& pmlmepriv->cur_network.network.IEs), (void const *)(& pnetwork->IEs),
                                 __len);
      }
      spin_lock_bh(& pmlmepriv->scanned_queue.lock);
      ibss_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->MacAddress));
      if ((unsigned long )ibss_wlan != (unsigned long )((struct wlan_network *)0)) {
        __len___0 = 8UL;
        if (__len___0 > 63UL) {
          __ret___0 = memcpy((void *)(& ibss_wlan->network.IEs), (void const *)(& pnetwork->IEs),
                               __len___0);
        } else {
          __ret___0 = memcpy((void *)(& ibss_wlan->network.IEs), (void const *)(& pnetwork->IEs),
                                       __len___0);
        }
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        goto exit;
      } else {
      }
      spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
    } else {
    }
  } else {
  }
  tmp___1 = check_fwstate(pmlmepriv, 128);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    if ((unsigned int )pnetwork->Ssid.ssid[0] == 0U) {
      pnetwork->Ssid.ssid_len = 0U;
    } else {
    }
    rtw_add_network(adapter, pnetwork);
  } else {
  }
  exit:
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
void rtw_surveydone_event_callback23a(struct rtw_adapter *adapter , u8 const *pbuf )
{
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *pibss ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  size_t __len ;
  void *__ret ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int ret ;
  unsigned long e ;
  int tmp___8 ;
  bool tmp___9 ;
  {
  pmlmepriv = & adapter->mlmepriv;
  pmlmeext = & adapter->mlmeextpriv;
  spin_lock_bh(& pmlmepriv->lock);
  if ((unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
    pmlmepriv->wps_probe_req_ie_len = 0U;
    kfree((void const *)pmlmepriv->wps_probe_req_ie);
    pmlmepriv->wps_probe_req_ie = (u8 *)0U;
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    tmp = get_fwstate(pmlmepriv);
    printk("\016rtw_surveydone_event_callback23a: fw_state:%x\n\n", tmp);
  } else {
  }
  tmp___1 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___1) {
    ldv_del_timer_sync_469(& pmlmepriv->scan_to_timer);
    _clr_fwstate_(pmlmepriv, 2048);
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    tmp___0 = get_fwstate(pmlmepriv);
    printk("\016nic status =%x, survey done event comes too late!\n", tmp___0);
  } else {
  }
  tmp___2 = msecs_to_jiffies(adapter->recvpriv.signal_stat_sampling_interval);
  ldv_mod_timer_470(& adapter->recvpriv.signal_stat_timer, tmp___2 + (unsigned long )jiffies);
  if ((unsigned int )pmlmepriv->to_join == 1U) {
    tmp___9 = check_fwstate(pmlmepriv, 32);
    if ((int )tmp___9) {
      tmp___6 = check_fwstate(pmlmepriv, 1);
      if (tmp___6) {
        tmp___7 = 0;
      } else {
        tmp___7 = 1;
      }
      if (tmp___7) {
        set_fwstate(pmlmepriv, 128);
        tmp___5 = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
        if (tmp___5 == 1) {
          tmp___3 = msecs_to_jiffies(6500U);
          ldv_mod_timer_471(& pmlmepriv->assoc_timer, tmp___3 + (unsigned long )jiffies);
        } else {
          pdev_network = & adapter->registrypriv.dev_network;
          pibss = (u8 *)(& adapter->registrypriv.dev_network.MacAddress);
          _clr_fwstate_(pmlmepriv, 2048);
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
            printk("\016switching to adhoc master\n");
          } else {
          }
          memset((void *)(& pdev_network->Ssid), 0, 33UL);
          __len = 33UL;
          if (__len > 63UL) {
            __ret = memcpy((void *)(& pdev_network->Ssid), (void const *)(& pmlmepriv->assoc_ssid),
                             __len);
          } else {
            __ret = memcpy((void *)(& pdev_network->Ssid), (void const *)(& pmlmepriv->assoc_ssid),
                                     __len);
          }
          rtw_update_registrypriv_dev_network23a(adapter);
          rtw_generate_random_ibss23a(pibss);
          pmlmepriv->fw_state = 64;
          tmp___4 = rtw_createbss_cmd23a(adapter);
          if (tmp___4 != 1) {
            if (GlobalDebugLevel23A > 3U) {
              printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
              printk("\016Error =>rtw_createbss_cmd23a status FAIL\n");
            } else {
            }
          } else {
          }
          pmlmepriv->to_join = 0U;
        }
      } else {
      }
    } else {
      set_fwstate(pmlmepriv, 128);
      pmlmepriv->to_join = 0U;
      ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
      if (ret == 1) {
        e = msecs_to_jiffies(6500U);
        ldv_mod_timer_472(& pmlmepriv->assoc_timer, (unsigned long )jiffies + e);
      } else
      if (ret == 2) {
        _clr_fwstate_(pmlmepriv, 128);
        rtw_indicate_connect23a(adapter);
      } else {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: try_to_join, but select scanning queue fail, to_roaming:%d\n",
                 (int )adapter->mlmepriv.to_roaming);
        } else {
        }
        if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
          pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
          if ((unsigned int )pmlmepriv->to_roaming == 0U) {
            rtw_set_roaming(adapter, 0);
            rtw_free_assoc_resources23a(adapter, 1);
            rtw_indicate_disconnect23a(adapter);
          } else {
            tmp___8 = rtw_sitesurvey_cmd23a(adapter, & pmlmepriv->assoc_ssid, 1, (struct rtw_ieee80211_channel *)0,
                                            0);
            if (tmp___8 != 1) {
              rtw_set_roaming(adapter, 0);
              rtw_free_assoc_resources23a(adapter, 1);
              rtw_indicate_disconnect23a(adapter);
            } else {
              pmlmepriv->to_join = 1U;
            }
          }
        } else {
        }
        _clr_fwstate_(pmlmepriv, 128);
      }
    }
  } else {
  }
  spin_unlock_bh(& pmlmepriv->lock);
  rtw_os_xmit_schedule23a(adapter);
  if (pmlmeext->sitesurvey_res.bss_cnt == 0) {
    rtw_sreset_reset(adapter);
  } else {
  }
  rtw_cfg80211_surveydone_event_callback(adapter);
  return;
}
}
static void free_scanqueue(struct mlme_priv *pmlmepriv )
{
  struct wlan_network *pnetwork ;
  struct rtw_queue *scan_queue ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptemp ;
  struct list_head const *__mptr ;
  {
  scan_queue = & pmlmepriv->scanned_queue;
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
    printk("\016+free_scanqueue\n");
  } else {
  }
  spin_lock_bh(& scan_queue->lock);
  phead = get_list_head(scan_queue);
  plist = phead->next;
  ptemp = plist->next;
  goto ldv_54555;
  ldv_54554:
  list_del_init(plist);
  __mptr = (struct list_head const *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  kfree((void const *)pnetwork);
  plist = ptemp;
  ptemp = plist->next;
  ldv_54555: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54554;
  } else {
  }
  spin_unlock_bh(& scan_queue->lock);
  return;
}
}
void rtw_free_assoc_resources23a(struct rtw_adapter *adapter , int lock_scanned_queue )
{
  struct wlan_network *pwlan ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct wlan_network *tgt_network ;
  struct sta_info *psta ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  pmlmepriv = & adapter->mlmepriv;
  pstapriv = & adapter->stapriv;
  tgt_network = & pmlmepriv->cur_network;
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
    printk("\016+rtw_free_assoc_resources23a\n");
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016tgt_network->network.MacAddress=%02x:%02x:%02x:%02x:%02x:%02x ssid=%s\n",
           (int )*((u8 *)(& tgt_network->network.MacAddress)), (int )*((u8 *)(& tgt_network->network.MacAddress) + 1UL),
           (int )*((u8 *)(& tgt_network->network.MacAddress) + 2UL), (int )*((u8 *)(& tgt_network->network.MacAddress) + 3UL),
           (int )*((u8 *)(& tgt_network->network.MacAddress) + 4UL), (int )*((u8 *)(& tgt_network->network.MacAddress) + 5UL),
           (u8 *)(& tgt_network->network.Ssid.ssid));
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 24);
  if ((int )tmp) {
    psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const *)(& tgt_network->network.MacAddress));
    spin_lock_bh(& pstapriv->sta_hash_lock);
    rtw_free_stainfo23a(adapter, psta);
    spin_unlock_bh(& pstapriv->sta_hash_lock);
  } else {
  }
  tmp___0 = check_fwstate(pmlmepriv, 112);
  if ((int )tmp___0) {
    rtw_free_all_stainfo23a(adapter);
    psta = rtw_get_bcmc_stainfo23a(adapter);
    spin_lock_bh(& pstapriv->sta_hash_lock);
    rtw_free_stainfo23a(adapter, psta);
    spin_unlock_bh(& pstapriv->sta_hash_lock);
    rtw_init_bcmc_stainfo23a(adapter);
  } else {
  }
  if (lock_scanned_queue != 0) {
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  } else {
  }
  pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
  if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
    pwlan->fixed = 0;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016rtw_free_assoc_resources23a : pwlan== NULL\n");
  } else {
  }
  tmp___1 = check_fwstate(pmlmepriv, 64);
  if ((int )tmp___1 && adapter->stapriv.asoc_sta_count == 1) {
    rtw_free_network_nolock(pmlmepriv, pwlan);
  } else {
  }
  if (lock_scanned_queue != 0) {
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  } else {
  }
  pmlmepriv->key_mask = 0U;
  return;
}
}
void rtw_indicate_connect23a(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct pid *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016+rtw_indicate_connect23a\n");
  } else {
  }
  pmlmepriv->to_join = 0U;
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    set_fwstate(pmlmepriv, 1);
    rtw_cfg80211_indicate_connect(padapter);
    netif_carrier_on(padapter->pnetdev);
    if (padapter->pid[2] != 0) {
      tmp = find_vpid(padapter->pid[2]);
      kill_pid(tmp, 14, 1);
    } else {
    }
  } else {
  }
  rtw_set_roaming(padapter, 0);
  rtw_set_scan_deny(padapter, 3000U);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    tmp___2 = get_fwstate(pmlmepriv);
    printk("\016-rtw_indicate_connect23a: fw_state=0x%08x\n", tmp___2);
  } else {
  }
  return;
}
}
void rtw_indicate_disconnect23a(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  bool tmp___0 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016+rtw_indicate_disconnect23a\n");
  } else {
  }
  _clr_fwstate_(pmlmepriv, 384);
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
    _clr_fwstate_(pmlmepriv, 1);
  } else {
  }
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp___0 || (unsigned int )padapter->mlmepriv.to_roaming == 0U) {
    rtw_os_indicate_disconnect23a(padapter);
    tmp = msecs_to_jiffies(3000U);
    padapter->pwrctrlpriv.ips_deny_time = tmp + (unsigned long )jiffies;
    _clr_fwstate_(pmlmepriv, 1);
    rtw_clear_scan_deny(padapter);
  } else {
  }
  rtw_lps_ctrl_wk_cmd23a(padapter, 3, 1);
  return;
}
}
void rtw_scan_abort23a(struct rtw_adapter *adapter )
{
  unsigned long start ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  bool tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  {
  pmlmepriv = & adapter->mlmepriv;
  pmlmeext = & adapter->mlmeextpriv;
  start = jiffies;
  pmlmeext->scan_abort = 1U;
  goto ldv_54583;
  ldv_54582: ;
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
    goto ldv_54580;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): fw_state = _FW_UNDER_SURVEY!\n", "rtw_scan_abort23a",
           (char *)(& (adapter->pnetdev)->name));
  } else {
  }
  msleep(20U);
  ldv_54583:
  tmp = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp) {
    tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
    if (tmp___0 <= 200U) {
      goto ldv_54582;
    } else {
      goto ldv_54580;
    }
  } else {
  }
  ldv_54580:
  tmp___2 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___2) {
    if (adapter->bDriverStopped == 0 && adapter->bSurpriseRemoved == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(%s): waiting for scan_abort time out!\n", "rtw_scan_abort23a",
               (char *)(& (adapter->pnetdev)->name));
      } else {
      }
    } else {
    }
    tmp___1 = wdev_priv(adapter->rtw_wdev);
    rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___1, 1);
  } else {
  }
  pmlmeext->scan_abort = 0U;
  return;
}
}
static struct sta_info *rtw_joinbss_update_stainfo(struct rtw_adapter *padapter ,
                                                   struct wlan_network *pnetwork )
{
  int i ;
  struct sta_info *bmc_sta ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_priv *pstapriv ;
  {
  pstapriv = & padapter->stapriv;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pnetwork->network.MacAddress));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    psta = rtw_alloc_stainfo23a(pstapriv, (u8 *)(& pnetwork->network.MacAddress),
                                32U);
  } else {
  }
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s\n", "rtw_joinbss_update_stainfo");
    } else {
    }
    psta->aid = (uint )pnetwork->join_res;
    psta->mac_id = 0U;
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
    if (padapter->securitypriv.dot11AuthAlgrthm == 2U) {
      padapter->securitypriv.binstallGrpkey = 0U;
      padapter->securitypriv.busetkipkey = 0U;
      psta->ieee8021x_blocked = 1U;
      psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
      memset((void *)(& psta->dot118021x_UncstKey), 0, 16UL);
      memset((void *)(& psta->dot11tkiprxmickey), 0, 16UL);
      memset((void *)(& psta->dot11tkiptxmickey), 0, 16UL);
      memset((void *)(& psta->dot11txpn), 0, 8UL);
      memset((void *)(& psta->dot11rxpn), 0, 8UL);
    } else {
    }
    if (padapter->securitypriv.wps_ie_len != 0) {
      psta->ieee8021x_blocked = 1U;
      padapter->securitypriv.wps_ie_len = 0;
    } else {
    }
    i = 0;
    goto ldv_54595;
    ldv_54594:
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
    preorder_ctrl->enable = 0U;
    preorder_ctrl->indicate_seq = 65535U;
    preorder_ctrl->wend_b = 65535U;
    preorder_ctrl->wsize_b = 64U;
    i = i + 1;
    ldv_54595: ;
    if (i <= 15) {
      goto ldv_54594;
    } else {
    }
    bmc_sta = rtw_get_bcmc_stainfo23a(padapter);
    if ((unsigned long )bmc_sta != (unsigned long )((struct sta_info *)0)) {
      i = 0;
      goto ldv_54598;
      ldv_54597:
      preorder_ctrl = (struct recv_reorder_ctrl *)(& bmc_sta->recvreorder_ctrl) + (unsigned long )i;
      preorder_ctrl->enable = 0U;
      preorder_ctrl->indicate_seq = 65535U;
      preorder_ctrl->wend_b = 65535U;
      preorder_ctrl->wsize_b = 64U;
      i = i + 1;
      ldv_54598: ;
      if (i <= 15) {
        goto ldv_54597;
      } else {
      }
    } else {
    }
    update_sta_info23a(padapter, psta);
  } else {
  }
  return (psta);
}
}
static void rtw_joinbss_update_network23a(struct rtw_adapter *padapter , struct wlan_network *ptarget_wlan ,
                                          struct wlan_network *pnetwork )
{
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  int bcn_size ;
  int tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned long tmp___0 ;
  s32 tmp___1 ;
  unsigned long tmp___2 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_joinbss_update_network23a");
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    tmp = get_fwstate(pmlmepriv);
    printk("\016\nfw_state:%x, BSSID:%02x:%02x:%02x:%02x:%02x:%02x\n", tmp, (int )*((u8 *)(& pnetwork->network.MacAddress)),
           (int )*((u8 *)(& pnetwork->network.MacAddress) + 1UL), (int )*((u8 *)(& pnetwork->network.MacAddress) + 2UL),
           (int )*((u8 *)(& pnetwork->network.MacAddress) + 3UL), (int )*((u8 *)(& pnetwork->network.MacAddress) + 4UL),
           (int )*((u8 *)(& pnetwork->network.MacAddress) + 5UL));
  } else {
  }
  __len = (size_t )pnetwork->network.Length;
  __ret = memcpy((void *)(& cur_network->network), (void const *)(& pnetwork->network),
                           __len);
  cur_network->network.IELength = ptarget_wlan->network.IELength;
  __len___0 = 768UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& cur_network->network.IEs), (void const *)(& ptarget_wlan->network.IEs),
                         __len___0);
  } else {
    __ret___0 = memcpy((void *)(& cur_network->network.IEs), (void const *)(& ptarget_wlan->network.IEs),
                                 __len___0);
  }
  cur_network->aid = pnetwork->join_res;
  tmp___0 = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
  ldv_mod_timer_473(& padapter->recvpriv.signal_stat_timer, tmp___0 + (unsigned long )jiffies);
  padapter->recvpriv.signal_strength = ptarget_wlan->network.PhyInfo.SignalStrength;
  padapter->recvpriv.signal_qual = ptarget_wlan->network.PhyInfo.SignalQuality;
  tmp___1 = translate_percentage_to_dbm((u32 )ptarget_wlan->network.PhyInfo.SignalStrength);
  padapter->recvpriv.rssi = (s8 )tmp___1;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s signal_strength:%3u, rssi:%3d, signal_qual:%3u\n", "rtw_joinbss_update_network23a",
           (int )padapter->recvpriv.signal_strength, (int )padapter->recvpriv.rssi,
           (int )padapter->recvpriv.signal_qual);
  } else {
  }
  tmp___2 = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
  ldv_mod_timer_474(& padapter->recvpriv.signal_stat_timer, tmp___2 + (unsigned long )jiffies);
  switch ((unsigned int )pnetwork->network.ifmode) {
  case 8U: ;
  case 2U: ;
  if ((pmlmepriv->fw_state & 256) != 0) {
    pmlmepriv->fw_state = 264;
  } else {
    pmlmepriv->fw_state = 8;
  }
  goto ldv_54617;
  case 1U:
  pmlmepriv->fw_state = 32;
  goto ldv_54617;
  default:
  pmlmepriv->fw_state = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016Invalid network_mode\n");
  } else {
  }
  goto ldv_54617;
  }
  ldv_54617:
  bcn_size = 12;
  rtw_update_protection23a(padapter, (u8 *)(& cur_network->network.IEs) + (unsigned long )bcn_size,
                           cur_network->network.IELength);
  rtw_update_ht_cap23a(padapter, (u8 *)(& cur_network->network.IEs), cur_network->network.IELength);
  return;
}
}
void rtw_joinbss_event_prehandle23a(struct rtw_adapter *adapter , u8 *pbuf )
{
  struct sta_info *ptarget_sta ;
  struct sta_info *pcur_sta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  struct wlan_network *cur_network ;
  struct wlan_network *pcur_wlan ;
  struct wlan_network *ptarget_wlan ;
  bool the_same_macaddr ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  unsigned long tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  unsigned long tmp___11 ;
  {
  pstapriv = & adapter->stapriv;
  pmlmepriv = & adapter->mlmepriv;
  pnetwork = (struct wlan_network *)pbuf;
  cur_network = & pmlmepriv->cur_network;
  ptarget_wlan = (struct wlan_network *)0;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016joinbss event call back received with res=%d\n", pnetwork->join_res);
  } else {
  }
  rtw_get_encrypt_decrypt_from_registrypriv23a(adapter);
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016@@@@@   joinbss event call back  for Any SSid\n");
    } else {
    }
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016@@@@@   rtw23a_joinbss_event_cb for SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {
  }
  tmp = ether_addr_equal((u8 const *)(& pnetwork->network.MacAddress), (u8 const *)(& cur_network->network.MacAddress));
  if ((int )tmp) {
    the_same_macaddr = 1;
  } else {
    the_same_macaddr = 0;
  }
  pnetwork->network.Length = get_wlan_bssid_ex_sz(& pnetwork->network);
  if (pnetwork->network.Length > 863U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016\n\n ***joinbss_evt_callback return a wrong bss ***\n\n");
    } else {
    }
    return;
  } else {
  }
  spin_lock_bh(& pmlmepriv->lock);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016\n rtw23a_joinbss_event_cb !! _enter_critical\n");
  } else {
  }
  if (pnetwork->join_res > 0) {
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
    tmp___7 = check_fwstate(pmlmepriv, 128);
    if ((int )tmp___7) {
      tmp___2 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___2) {
        if ((int )the_same_macaddr) {
          ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
        } else {
          pcur_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
          if ((unsigned long )pcur_wlan != (unsigned long )((struct wlan_network *)0)) {
            pcur_wlan->fixed = 0;
          } else {
          }
          pcur_sta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& cur_network->network.MacAddress));
          if ((unsigned long )pcur_sta != (unsigned long )((struct sta_info *)0)) {
            spin_lock_bh(& pstapriv->sta_hash_lock);
            rtw_free_stainfo23a(adapter, pcur_sta);
            spin_unlock_bh(& pstapriv->sta_hash_lock);
          } else {
          }
          ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->network.MacAddress));
          tmp___0 = check_fwstate(pmlmepriv, 8);
          if ((int )tmp___0) {
            if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
              ptarget_wlan->fixed = 1;
            } else {
            }
          } else {
          }
        }
      } else {
        ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->network.MacAddress));
        tmp___1 = check_fwstate(pmlmepriv, 8);
        if ((int )tmp___1) {
          if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
            ptarget_wlan->fixed = 1;
          } else {
          }
        } else {
        }
      }
      if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
        rtw_joinbss_update_network23a(adapter, ptarget_wlan, pnetwork);
      } else {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
          printk("\016Can\'t find ptarget_wlan when joinbss_event callback\n");
        } else {
        }
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        goto ignore_joinbss_callback;
      }
      tmp___3 = check_fwstate(pmlmepriv, 8);
      if ((int )tmp___3) {
        ptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);
        if ((unsigned long )ptarget_sta == (unsigned long )((struct sta_info *)0)) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
            printk("\016Can\'t update stainfo when joinbss_event callback\n");
          } else {
          }
          spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
          goto ignore_joinbss_callback;
        } else {
        }
      } else {
      }
      tmp___5 = check_fwstate(pmlmepriv, 8);
      if ((int )tmp___5) {
        rtw_indicate_connect23a(adapter);
      } else
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
        tmp___4 = get_fwstate(pmlmepriv);
        printk("\016adhoc mode, fw_state:%x", tmp___4);
      } else {
      }
      ldv_del_timer_sync_475(& pmlmepriv->assoc_timer);
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
        printk("\016Cancle assoc_timer\n");
      } else {
      }
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
        tmp___6 = get_fwstate(pmlmepriv);
        printk("\016rtw23a_joinbss_event_cb err: fw_state:%x", tmp___6);
      } else {
      }
      spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
      goto ignore_joinbss_callback;
    }
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  } else
  if (pnetwork->join_res == -4) {
    rtw_reset_securitypriv23a(adapter);
    tmp___8 = msecs_to_jiffies(1U);
    ldv_mod_timer_476(& pmlmepriv->assoc_timer, tmp___8 + (unsigned long )jiffies);
    tmp___10 = check_fwstate(pmlmepriv, 128);
    if ((int )tmp___10) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
        tmp___9 = get_fwstate(pmlmepriv);
        printk("\016fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", tmp___9);
      } else {
      }
      _clr_fwstate_(pmlmepriv, 128);
    } else {
    }
  } else {
    tmp___11 = msecs_to_jiffies(1U);
    ldv_mod_timer_477(& pmlmepriv->assoc_timer, tmp___11 + (unsigned long )jiffies);
    _clr_fwstate_(pmlmepriv, 128);
  }
  ignore_joinbss_callback:
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
void rtw23a_joinbss_event_cb(struct rtw_adapter *adapter , u8 const *pbuf )
{
  struct wlan_network *pnetwork ;
  {
  pnetwork = (struct wlan_network *)pbuf;
  mlmeext_joinbss_event_callback23a(adapter, pnetwork->join_res);
  rtw_os_xmit_schedule23a(adapter);
  return;
}
}
void rtw_stassoc_event_callback23a(struct rtw_adapter *adapter , u8 const *pbuf )
{
  struct sta_info *psta ;
  struct mlme_priv *pmlmepriv ;
  struct stassoc_event *pstassoc ;
  struct wlan_network *cur_network ;
  struct wlan_network *ptarget_wlan ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  pmlmepriv = & adapter->mlmepriv;
  pstassoc = (struct stassoc_event *)pbuf;
  cur_network = & pmlmepriv->cur_network;
  tmp = rtw_access_ctrl23a(adapter, (u8 *)(& pstassoc->macaddr));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  tmp___1 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___1) {
    psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const *)(& pstassoc->macaddr));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      ap_sta_info_defer_update23a(adapter, psta);
    } else {
    }
    return;
  } else {
  }
  psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const *)(& pstassoc->macaddr));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016Error: rtw_stassoc_event_callback23a: sta has been in sta_hash_queue\n");
    } else {
    }
    return;
  } else {
  }
  psta = rtw_alloc_stainfo23a(& adapter->stapriv, (u8 *)(& pstassoc->macaddr), 208U);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016Can\'t alloc sta_info when rtw_stassoc_event_callback23a\n");
    } else {
    }
    return;
  } else {
  }
  psta->qos_option = 0U;
  psta->mac_id = (unsigned int )pstassoc->cam_id;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_stassoc_event_callback23a");
  } else {
  }
  rtl8723a_SetHalODMVar(adapter, 0, (void *)psta, 1);
  if (adapter->securitypriv.dot11AuthAlgrthm == 2U) {
    psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
  } else {
  }
  psta->ieee8021x_blocked = 0U;
  spin_lock_bh(& pmlmepriv->lock);
  tmp___2 = check_fwstate(pmlmepriv, 64);
  if ((int )tmp___2) {
    goto _L;
  } else {
    tmp___3 = check_fwstate(pmlmepriv, 32);
    if ((int )tmp___3) {
      _L:
      if (adapter->stapriv.asoc_sta_count == 2) {
        spin_lock_bh(& pmlmepriv->scanned_queue.lock);
        ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
        if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
          ptarget_wlan->fixed = 1;
        } else {
        }
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        rtw_indicate_connect23a(adapter);
      } else {
      }
    } else {
    }
  }
  spin_unlock_bh(& pmlmepriv->lock);
  mlmeext_sta_add_event_callback23a(adapter, psta);
  return;
}
}
void rtw_stadel_event_callback23a(struct rtw_adapter *adapter , u8 const *pbuf )
{
  int mac_id ;
  struct sta_info *psta ;
  struct wlan_network *pwlan ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *pibss ;
  struct mlme_priv *pmlmepriv ;
  struct stadel_event *pstadel ;
  struct sta_priv *pstapriv ;
  struct wlan_network *tgt_network ;
  bool tmp ;
  bool tmp___0 ;
  size_t __len ;
  uint tmp___1 ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  {
  pmlmepriv = & adapter->mlmepriv;
  pstadel = (struct stadel_event *)pbuf;
  pstapriv = & adapter->stapriv;
  tgt_network = & pmlmepriv->cur_network;
  psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const *)(& pstadel->macaddr));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    mac_id = (int )psta->mac_id;
  } else {
    mac_id = pstadel->mac_id;
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(mac_id=%d)=%02x:%02x:%02x:%02x:%02x:%02x\n", "rtw_stadel_event_callback23a",
           mac_id, (int )*((u8 *)(& pstadel->macaddr)), (int )*((u8 *)(& pstadel->macaddr) + 1UL),
           (int )*((u8 *)(& pstadel->macaddr) + 2UL), (int )*((u8 *)(& pstadel->macaddr) + 3UL),
           (int )*((u8 *)(& pstadel->macaddr) + 4UL), (int )*((u8 *)(& pstadel->macaddr) + 5UL));
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    return;
  } else {
  }
  mlmeext_sta_del_event_callback23a(adapter);
  spin_lock_bh(& pmlmepriv->lock);
  tmp___0 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___0) {
    if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
      pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
    } else
    if ((unsigned int )adapter->mlmepriv.to_roaming == 0U) {
      rtw_set_roaming(adapter, (int )adapter->registrypriv.max_roaming_times);
    } else {
    }
    if ((unsigned int )*((u16 *)(& pstadel->rsvd)) != 65535U) {
      rtw_set_roaming(adapter, 0);
    } else {
    }
    rtw_free_uc_swdec_pending_queue23a(adapter);
    rtw_free_assoc_resources23a(adapter, 1);
    rtw_indicate_disconnect23a(adapter);
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
    pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
    if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
      pwlan->fixed = 0;
      rtw_free_network_nolock(pmlmepriv, pwlan);
    } else {
    }
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
    _rtw_roaming(adapter, tgt_network);
  } else {
  }
  tmp___4 = check_fwstate(pmlmepriv, 64);
  if ((int )tmp___4) {
    goto _L;
  } else {
    tmp___5 = check_fwstate(pmlmepriv, 32);
    if ((int )tmp___5) {
      _L:
      spin_lock_bh(& pstapriv->sta_hash_lock);
      rtw_free_stainfo23a(adapter, psta);
      spin_unlock_bh(& pstapriv->sta_hash_lock);
      if (adapter->stapriv.asoc_sta_count == 1) {
        spin_lock_bh(& pmlmepriv->scanned_queue.lock);
        pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
        if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
          pwlan->fixed = 0;
          rtw_free_network_nolock(pmlmepriv, pwlan);
        } else {
        }
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
        pdev_network = & adapter->registrypriv.dev_network;
        pibss = (u8 *)(& adapter->registrypriv.dev_network.MacAddress);
        tmp___1 = get_wlan_bssid_ex_sz(& tgt_network->network);
        __len = (size_t )tmp___1;
        __ret = memcpy((void *)pdev_network, (void const *)(& tgt_network->network),
                                 __len);
        memset((void *)(& pdev_network->Ssid), 0, 33UL);
        __len___0 = 33UL;
        if (__len___0 > 63UL) {
          __ret___0 = memcpy((void *)(& pdev_network->Ssid), (void const *)(& pmlmepriv->assoc_ssid),
                               __len___0);
        } else {
          __ret___0 = memcpy((void *)(& pdev_network->Ssid), (void const *)(& pmlmepriv->assoc_ssid),
                                       __len___0);
        }
        rtw_update_registrypriv_dev_network23a(adapter);
        rtw_generate_random_ibss23a(pibss);
        tmp___2 = check_fwstate(pmlmepriv, 32);
        if ((int )tmp___2) {
          set_fwstate(pmlmepriv, 64);
          _clr_fwstate_(pmlmepriv, 32);
        } else {
        }
        tmp___3 = rtw_createbss_cmd23a(adapter);
        if (tmp___3 != 1) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
            printk("\016***Error =>stadel_event_callback: rtw_createbss_cmd23a status FAIL***\n");
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
  }
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
void rtw23a_join_to_handler(unsigned long data )
{
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  int do_join_r ;
  int tmp ;
  {
  adapter = (struct rtw_adapter *)data;
  pmlmepriv = & adapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    tmp = get_fwstate(pmlmepriv);
    printk("\016RTL8723AU: %s, fw_state=%x\n", "rtw23a_join_to_handler", tmp);
  } else {
  }
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
    return;
  } else {
  }
  spin_lock_bh(& pmlmepriv->lock);
  if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
    ldv_54678:
    pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
    if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s try another roaming\n", "rtw23a_join_to_handler");
      } else {
      }
      do_join_r = rtw_do_join23a(adapter);
      if (do_join_r != 1) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s roaming do_join return %d\n", "rtw23a_join_to_handler",
                 do_join_r);
        } else {
        }
        goto ldv_54676;
      } else {
      }
      goto ldv_54677;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s We\'ve try roaming but fail\n", "rtw23a_join_to_handler");
      } else {
      }
      rtw_indicate_disconnect23a(adapter);
      goto ldv_54677;
    }
    ldv_54676: ;
    goto ldv_54678;
    ldv_54677: ;
  } else {
    rtw_indicate_disconnect23a(adapter);
    free_scanqueue(pmlmepriv);
    rtw_cfg80211_indicate_disconnect(adapter);
  }
  spin_unlock_bh(& pmlmepriv->lock);
  return;
}
}
void rtw_scan_timeout_handler23a(unsigned long data )
{
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  int tmp ;
  void *tmp___0 ;
  {
  adapter = (struct rtw_adapter *)data;
  pmlmepriv = & adapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    tmp = get_fwstate(pmlmepriv);
    printk("\016RTL8723AU: %s(%s): fw_state =%x\n", "rtw_scan_timeout_handler23a",
           (char *)(& (adapter->pnetdev)->name), tmp);
  } else {
  }
  spin_lock_bh(& pmlmepriv->lock);
  _clr_fwstate_(pmlmepriv, 2048);
  spin_unlock_bh(& pmlmepriv->lock);
  tmp___0 = wdev_priv(adapter->rtw_wdev);
  rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___0, 1);
  return;
}
}
static void rtw_auto_scan_handler(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  {
  pmlmepriv = & padapter->mlmepriv;
  if (pmlmepriv->scan_interval != 0U) {
    pmlmepriv->scan_interval = pmlmepriv->scan_interval - 1U;
    if (pmlmepriv->scan_interval == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s\n", "rtw_auto_scan_handler");
      } else {
      }
      rtw_set_802_11_bssid23a_list_scan(padapter, (struct cfg80211_ssid *)0, 0);
      pmlmepriv->scan_interval = 30U;
    } else {
    }
  } else {
  }
  return;
}
}
void rtw_dynamic_check_timer_handler(unsigned long data )
{
  struct rtw_adapter *adapter ;
  struct registry_priv *pregistrypriv ;
  unsigned long tmp ;
  {
  adapter = (struct rtw_adapter *)data;
  pregistrypriv = & adapter->registrypriv;
  if ((unsigned int )adapter->hw_init_completed == 0U) {
    goto out;
  } else {
  }
  if (adapter->bDriverStopped == 1 || adapter->bSurpriseRemoved == 1) {
    goto out;
  } else {
  }
  if (adapter->net_closed == 1) {
    goto out;
  } else {
  }
  rtw_dynamic_chk_wk_cmd23a(adapter);
  if ((unsigned int )pregistrypriv->wifi_spec == 1U) {
    rtw_auto_scan_handler(adapter);
  } else {
  }
  out:
  tmp = msecs_to_jiffies(2000U);
  ldv_mod_timer_478(& adapter->mlmepriv.dynamic_chk_timer, tmp + (unsigned long )jiffies);
  return;
}
}
void rtw_clear_scan_deny(struct rtw_adapter *adapter )
{
  struct mlme_priv *mlmepriv ;
  {
  mlmepriv = & adapter->mlmepriv;
  atomic_set(& mlmepriv->set_scan_deny, 0);
  return;
}
}
void rtw_set_scan_deny_timer_hdl(unsigned long data )
{
  struct rtw_adapter *adapter ;
  {
  adapter = (struct rtw_adapter *)data;
  rtw_clear_scan_deny(adapter);
  return;
}
}
void rtw_set_scan_deny(struct rtw_adapter *adapter , u32 ms )
{
  struct mlme_priv *mlmepriv ;
  unsigned long tmp ;
  {
  mlmepriv = & adapter->mlmepriv;
  atomic_set(& mlmepriv->set_scan_deny, 1);
  tmp = msecs_to_jiffies(ms);
  ldv_mod_timer_479(& mlmepriv->set_scan_deny_timer, tmp + (unsigned long )jiffies);
  return;
}
}
static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv , struct wlan_network **candidate ,
                                    struct wlan_network *competitor )
{
  int updated ;
  struct rtw_adapter *adapter ;
  struct mlme_priv const *__mptr ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int passed ;
  int tmp___3 ;
  {
  updated = 0;
  __mptr = (struct mlme_priv const *)pmlmepriv;
  adapter = (struct rtw_adapter *)__mptr + 0xffffffffffffffe0UL;
  if (pmlmepriv->assoc_by_bssid == 1U) {
    tmp = ether_addr_equal((u8 const *)(& competitor->network.MacAddress), (u8 const *)(& pmlmepriv->assoc_bssid));
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      goto exit;
    } else {
    }
  } else {
  }
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len != 0U) {
    if ((int )competitor->network.Ssid.ssid_len != (int )pmlmepriv->assoc_ssid.ssid_len) {
      goto exit;
    } else {
      tmp___1 = memcmp((void const *)(& competitor->network.Ssid.ssid), (void const *)(& pmlmepriv->assoc_ssid.ssid),
                       (size_t )pmlmepriv->assoc_ssid.ssid_len);
      if (tmp___1 != 0) {
        goto exit;
      } else {
      }
    }
  } else {
  }
  tmp___2 = rtw_is_desired_network(adapter, competitor);
  if (tmp___2 == 0) {
    goto exit;
  } else {
  }
  if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
    passed = jiffies_to_msecs((unsigned long )jiffies - competitor->last_scanned);
    if (passed > 1999U) {
      goto exit;
    } else {
      tmp___3 = is_same_ess(& competitor->network, & pmlmepriv->cur_network.network);
      if (tmp___3 == 0) {
        goto exit;
      } else {
      }
    }
  } else {
  }
  if ((unsigned long )*candidate == (unsigned long )((struct wlan_network *)0) || (*candidate)->network.Rssi < competitor->network.Rssi) {
    *candidate = competitor;
    updated = 1;
  } else {
  }
  if (updated != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: [by_bssid:%u][assoc_ssid:%s][to_roaming:%u] new candidate: %s(%02x:%02x:%02x:%02x:%02x:%02x) rssi:%d\n",
             pmlmepriv->assoc_by_bssid, (u8 *)(& pmlmepriv->assoc_ssid.ssid), (int )adapter->mlmepriv.to_roaming,
             (u8 *)(& (*candidate)->network.Ssid.ssid), (int )*((u8 *)(& (*candidate)->network.MacAddress)),
             (int )*((u8 *)(& (*candidate)->network.MacAddress) + 1UL), (int )*((u8 *)(& (*candidate)->network.MacAddress) + 2UL),
             (int )*((u8 *)(& (*candidate)->network.MacAddress) + 3UL), (int )*((u8 *)(& (*candidate)->network.MacAddress) + 4UL),
             (int )*((u8 *)(& (*candidate)->network.MacAddress) + 5UL), (int )(*candidate)->network.Rssi);
    } else {
    }
  } else {
  }
  exit: ;
  return (updated);
}
}
int rtw_select_and_join_from_scanned_queue23a(struct mlme_priv *pmlmepriv )
{
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct rtw_adapter *adapter ;
  struct rtw_queue *queue ;
  struct wlan_network *pnetwork ;
  struct wlan_network *candidate ;
  struct list_head const *__mptr ;
  bool tmp ;
  {
  queue = & pmlmepriv->scanned_queue;
  candidate = (struct wlan_network *)0;
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  phead = get_list_head(queue);
  adapter = pmlmepriv->nic_hdl;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_54740;
  ldv_54739:
  __mptr = (struct list_head const *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016%s return _FAIL:(pnetwork == NULL)\n", "rtw_select_and_join_from_scanned_queue23a");
    } else {
    }
    ret = 0;
    goto exit;
  } else {
  }
  rtw_check_join_candidate(pmlmepriv, & candidate, pnetwork);
  plist = ptmp;
  ptmp = plist->next;
  ldv_54740: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54739;
  } else {
  }
  if ((unsigned long )candidate == (unsigned long )((struct wlan_network *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: return _FAIL(candidate == NULL)\n", "rtw_select_and_join_from_scanned_queue23a");
    } else {
    }
    ret = 0;
    goto exit;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: candidate: %s(%02x:%02x:%02x:%02x:%02x:%02x, ch:%u)\n",
           "rtw_select_and_join_from_scanned_queue23a", (u8 *)(& candidate->network.Ssid.ssid),
           (int )*((u8 *)(& candidate->network.MacAddress)), (int )*((u8 *)(& candidate->network.MacAddress) + 1UL),
           (int )*((u8 *)(& candidate->network.MacAddress) + 2UL), (int )*((u8 *)(& candidate->network.MacAddress) + 3UL),
           (int )*((u8 *)(& candidate->network.MacAddress) + 4UL), (int )*((u8 *)(& candidate->network.MacAddress) + 5UL),
           candidate->network.DSConfig);
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: _FW_LINKED while ask_for_joinbss!!!\n", "rtw_select_and_join_from_scanned_queue23a");
    } else {
    }
    rtw_disassoc_cmd23a(adapter, 0U, 1);
    rtw_indicate_disconnect23a(adapter);
    rtw_free_assoc_resources23a(adapter, 0);
  } else {
  }
  set_fwstate(pmlmepriv, 128);
  ret = rtw_joinbss_cmd23a(adapter, candidate);
  exit:
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  return (ret);
}
}
int rtw_set_auth23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv )
{
  struct cmd_obj *pcmd ;
  struct setauth_parm *psetauthparm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  {
  pcmdpriv = & adapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 208U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(4UL, 208U);
  psetauthparm = (struct setauth_parm *)tmp___0;
  if ((unsigned long )psetauthparm == (unsigned long )((struct setauth_parm *)0)) {
    kfree((void const *)pcmd);
    res = 0;
    goto exit;
  } else {
  }
  psetauthparm->mode = (unsigned char )psecuritypriv->dot11AuthAlgrthm;
  pcmd->cmdcode = 19U;
  pcmd->parmbuf = (u8 *)psetauthparm;
  pcmd->cmdsz = 4U;
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016after enqueue set_auth_cmd, auth_mode=%x\n", psecuritypriv->dot11AuthAlgrthm);
  } else {
  }
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
  return (res);
}
}
int rtw_set_key23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ,
                   int keyid , u8 set_tx )
{
  u8 keylen ;
  struct cmd_obj *pcmd ;
  struct setkey_parm *psetkeyparm ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  {
  pcmdpriv = & adapter->cmdpriv;
  pmlmepriv = & adapter->mlmepriv;
  res = 1;
  if (keyid > 3) {
    res = 0;
    goto exit;
  } else {
  }
  tmp = kzalloc(128UL, 208U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(24UL, 208U);
  psetkeyparm = (struct setkey_parm *)tmp___0;
  if ((unsigned long )psetkeyparm == (unsigned long )((struct setkey_parm *)0)) {
    kfree((void const *)pcmd);
    res = 0;
    goto exit;
  } else {
  }
  if (psecuritypriv->dot11AuthAlgrthm == 2U) {
    psetkeyparm->algorithm = (u32 )((unsigned char )psecuritypriv->dot118021XGrpPrivacy);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016\n rtw_set_key23a: psetkeyparm->algorithm = (unsigned char)psecuritypriv->dot118021XGrpPrivacy =%d\n",
             psetkeyparm->algorithm);
    } else {
    }
  } else {
    psetkeyparm->algorithm = (u32 )((unsigned char )psecuritypriv->dot11PrivacyAlgrthm);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016\n rtw_set_key23a: psetkeyparm->algorithm = (u8)psecuritypriv->dot11PrivacyAlgrthm =%d\n",
             psetkeyparm->algorithm);
    } else {
    }
  }
  psetkeyparm->keyid = (u8 )keyid;
  psetkeyparm->set_tx = set_tx;
  if (psetkeyparm->algorithm == 1027073U || psetkeyparm->algorithm == 1027077U) {
    pmlmepriv->key_mask = (int )pmlmepriv->key_mask | (int )((u8 )(1UL << (int )psetkeyparm->keyid));
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ==> rtw_set_key23a algorithm(%x), keyid(%x), key_mask(%x)\n",
           psetkeyparm->algorithm, (int )psetkeyparm->keyid, (int )pmlmepriv->key_mask);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016\n rtw_set_key23a: psetkeyparm->algorithm =%d psetkeyparm->keyid = (u8)keyid =%d\n",
           psetkeyparm->algorithm, keyid);
  } else {
  }
  switch (psetkeyparm->algorithm) {
  case 1027073U:
  keylen = 5U;
  __len = (size_t )keylen;
  __ret = memcpy((void *)(& psetkeyparm->key), (void const *)(& psecuritypriv->wep_key[keyid].key),
                           __len);
  goto ldv_54768;
  case 1027077U:
  keylen = 13U;
  __len___0 = (size_t )keylen;
  __ret___0 = memcpy((void *)(& psetkeyparm->key), (void const *)(& psecuritypriv->wep_key[keyid].key),
                               __len___0);
  goto ldv_54768;
  case 1027074U:
  keylen = 16U;
  __len___1 = (size_t )keylen;
  __ret___1 = memcpy((void *)(& psetkeyparm->key), (void const *)(& psecuritypriv->dot118021XGrpKey) + (unsigned long )keyid,
                               __len___1);
  psetkeyparm->grpkey = 1U;
  goto ldv_54768;
  case 1027076U:
  keylen = 16U;
  __len___2 = (size_t )keylen;
  __ret___2 = memcpy((void *)(& psetkeyparm->key), (void const *)(& psecuritypriv->dot118021XGrpKey) + (unsigned long )keyid,
                               __len___2);
  psetkeyparm->grpkey = 1U;
  goto ldv_54768;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
    printk("\016\n rtw_set_key23a:psecuritypriv->dot11PrivacyAlgrthm = %x (must be 1 or 2 or 4 or 5)\n",
           psecuritypriv->dot11PrivacyAlgrthm);
  } else {
  }
  res = 0;
  kfree((void const *)pcmd);
  kfree((void const *)psetkeyparm);
  goto exit;
  }
  ldv_54768:
  pcmd->cmdcode = 20U;
  pcmd->parmbuf = (u8 *)psetkeyparm;
  pcmd->cmdsz = 24U;
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
  return (res);
}
}
int rtw_restruct_wmm_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len , uint initial_out_len )
{
  unsigned int ielength ;
  unsigned int i ;
  unsigned int j ;
  {
  ielength = 0U;
  i = 12U;
  goto ldv_54797;
  ldv_54796:
  ielength = initial_out_len;
  if ((((((unsigned int )*(in_ie + (unsigned long )i) == 221U && (unsigned int )*(in_ie + (unsigned long )(i + 2U)) == 0U) && (unsigned int )*(in_ie + (unsigned long )(i + 3U)) == 80U) && (unsigned int )*(in_ie + (unsigned long )(i + 4U)) == 242U) && (unsigned int )*(in_ie + (unsigned long )(i + 5U)) == 2U) && i + 5U < in_len) {
    j = i;
    goto ldv_54793;
    ldv_54792:
    *(out_ie + (unsigned long )ielength) = *(in_ie + (unsigned long )j);
    ielength = ielength + 1U;
    j = j + 1U;
    ldv_54793: ;
    if (i + 9U > j) {
      goto ldv_54792;
    } else {
    }
    *(out_ie + (unsigned long )(initial_out_len + 1U)) = 7U;
    *(out_ie + (unsigned long )(initial_out_len + 6U)) = 0U;
    *(out_ie + (unsigned long )(initial_out_len + 8U)) = 0U;
    goto ldv_54795;
  } else {
  }
  i = ((unsigned int )*(in_ie + (unsigned long )(i + 1U)) + i) + 2U;
  ldv_54797: ;
  if (i < in_len) {
    goto ldv_54796;
  } else {
  }
  ldv_54795: ;
  return ((int )ielength);
}
}
static int SecIsInPMKIDList(struct rtw_adapter *Adapter , u8 *bssid )
{
  struct security_priv *psecuritypriv ;
  int i ;
  bool tmp ;
  {
  psecuritypriv = & Adapter->securitypriv;
  i = 0;
  ldv_54805: ;
  if ((unsigned int )psecuritypriv->PMKIDList[i].bUsed != 0U) {
    tmp = ether_addr_equal((u8 const *)(& psecuritypriv->PMKIDList[i].Bssid), (u8 const *)bssid);
    if ((int )tmp) {
      goto ldv_54804;
    } else {
      i = i + 1;
    }
  } else {
    i = i + 1;
  }
  if (i <= 15) {
    goto ldv_54805;
  } else {
  }
  ldv_54804: ;
  if (i == 16) {
    i = -1;
  } else {
  }
  return (i);
}
}
static int rtw_append_pmkid(struct rtw_adapter *Adapter , int iEntry , u8 *ie , uint ie_len )
{
  struct security_priv *psecuritypriv ;
  size_t __len ;
  void *__ret ;
  {
  psecuritypriv = & Adapter->securitypriv;
  if ((unsigned int )*(ie + 13UL) <= 20U) {
    *(ie + (unsigned long )ie_len) = 1U;
    ie_len = ie_len + 1U;
    *(ie + (unsigned long )ie_len) = 0U;
    ie_len = ie_len + 1U;
    __len = 16UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)ie + (unsigned long )ie_len, (void const *)(& psecuritypriv->PMKIDList[iEntry].PMKID),
                       __len);
    } else {
      __ret = memcpy((void *)ie + (unsigned long )ie_len, (void const *)(& psecuritypriv->PMKIDList[iEntry].PMKID),
                               __len);
    }
    ie_len = ie_len + 16U;
    *(ie + 13UL) = (unsigned int )*(ie + 13UL) + 18U;
  } else {
  }
  return ((int )ie_len);
}
}
int rtw_restruct_sec_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len )
{
  u8 authmode ;
  uint ielength ;
  int iEntry ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  uint ndisauthmode ;
  uint ndissecuritytype ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  bool tmp ;
  int tmp___0 ;
  {
  pmlmepriv = & adapter->mlmepriv;
  psecuritypriv = & adapter->securitypriv;
  ndisauthmode = psecuritypriv->ndisauthtype;
  ndissecuritytype = psecuritypriv->ndisencryptstatus;
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
    printk("\016+rtw_restruct_sec_ie23a: ndisauthmode=%d ndissecuritytype=%d\n", ndisauthmode,
           ndissecuritytype);
  } else {
  }
  __len = 12UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)out_ie, (void const *)in_ie, __len);
  } else {
    __ret = memcpy((void *)out_ie, (void const *)in_ie, __len);
  }
  ielength = 12U;
  if (ndisauthmode == 3U || ndisauthmode == 4U) {
    authmode = 221U;
  } else {
  }
  if (ndisauthmode == 6U || ndisauthmode == 7U) {
    authmode = 48U;
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 256);
  if ((int )tmp) {
    __len___0 = (size_t )psecuritypriv->wps_ie_len;
    __ret___0 = memcpy((void *)out_ie + (unsigned long )ielength, (void const *)(& psecuritypriv->wps_ie),
                                 __len___0);
    ielength = (uint )psecuritypriv->wps_ie_len + ielength;
  } else
  if ((unsigned int )authmode == 221U || (unsigned int )authmode == 48U) {
    __len___1 = (size_t )((int )psecuritypriv->supplicant_ie[1] + 2);
    __ret___1 = memcpy((void *)out_ie + (unsigned long )ielength, (void const *)(& psecuritypriv->supplicant_ie),
                                 __len___1);
    ielength = ((uint )psecuritypriv->supplicant_ie[1] + ielength) + 2U;
  } else {
  }
  iEntry = SecIsInPMKIDList(adapter, (u8 *)(& pmlmepriv->assoc_bssid));
  if (iEntry < 0) {
    return ((int )ielength);
  } else
  if ((unsigned int )authmode == 48U) {
    tmp___0 = rtw_append_pmkid(adapter, iEntry, out_ie, ielength);
    ielength = (uint )tmp___0;
  } else {
  }
  return ((int )ielength);
}
}
void rtw_init_registrypriv_dev_network23a(struct rtw_adapter *adapter )
{
  struct registry_priv *pregistrypriv ;
  struct eeprom_priv *peepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *myhwaddr ;
  u8 *tmp ;
  size_t __len ;
  void *__ret ;
  {
  pregistrypriv = & adapter->registrypriv;
  peepriv = & adapter->eeprompriv;
  pdev_network = & pregistrypriv->dev_network;
  tmp = myid(peepriv);
  myhwaddr = tmp;
  ether_addr_copy((u8 *)(& pdev_network->MacAddress), (u8 const *)myhwaddr);
  __len = 33UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pdev_network->Ssid), (void const *)(& pregistrypriv->ssid),
                     __len);
  } else {
    __ret = memcpy((void *)(& pdev_network->Ssid), (void const *)(& pregistrypriv->ssid),
                             __len);
  }
  pdev_network->BeaconPeriod = 100U;
  return;
}
}
void rtw_update_registrypriv_dev_network23a(struct rtw_adapter *adapter )
{
  int sz ;
  struct registry_priv *pregistrypriv ;
  struct wlan_bssid_ex *pdev_network ;
  struct security_priv *psecuritypriv ;
  struct wlan_network *cur_network ;
  {
  sz = 0;
  pregistrypriv = & adapter->registrypriv;
  pdev_network = & pregistrypriv->dev_network;
  psecuritypriv = & adapter->securitypriv;
  cur_network = & adapter->mlmepriv.cur_network;
  pdev_network->Privacy = psecuritypriv->dot11PrivacyAlgrthm != 0U;
  pdev_network->Rssi = 0L;
  pdev_network->DSConfig = (u32 )pregistrypriv->channel;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016pregistrypriv->channel =%d, pdev_network->DSConfig = 0x%x\n", (int )pregistrypriv->channel,
           pdev_network->DSConfig);
  } else {
  }
  if ((unsigned int )cur_network->network.ifmode == 1U) {
    pdev_network->ATIMWindow = 0U;
  } else {
  }
  pdev_network->ifmode = cur_network->network.ifmode;
  sz = rtw_generate_ie23a(pregistrypriv);
  pdev_network->IELength = (u32 )sz;
  pdev_network->Length = get_wlan_bssid_ex_sz(pdev_network);
  return;
}
}
void rtw_get_encrypt_decrypt_from_registrypriv23a(struct rtw_adapter *adapter )
{
  {
  return;
}
}
void rtw_joinbss_reset23a(struct rtw_adapter *padapter )
{
  u8 threshold ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  {
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  pmlmepriv->num_FortyMHzIntolerant = 0;
  pmlmepriv->num_sta_no_ht = 0;
  phtpriv->ampdu_enable = 0U;
  if (phtpriv->ht_option != 0U) {
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
      threshold = 1U;
    } else {
      threshold = 0U;
    }
  } else {
    threshold = 1U;
  }
  rtl8723a_set_rxdma_agg_pg_th(padapter, (int )threshold);
  return;
}
}
unsigned int rtw_restructure_ht_ie23a(struct rtw_adapter *padapter , u8 *in_ie , u8 *out_ie ,
                                      uint in_len , uint *pout_len )
{
  u32 out_len ;
  int max_rx_ampdu_factor ;
  unsigned char *pframe ;
  u8 const *p ;
  struct ieee80211_ht_cap ht_capie ;
  unsigned char WMM_IE[7U] ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  u32 rx_packet_offset ;
  u32 max_recvbuf_sz ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  {
  WMM_IE[0] = 0U;
  WMM_IE[1] = 80U;
  WMM_IE[2] = 242U;
  WMM_IE[3] = 2U;
  WMM_IE[4] = 0U;
  WMM_IE[5] = 1U;
  WMM_IE[6] = 0U;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  phtpriv->ht_option = 0U;
  p = cfg80211_find_ie(45, (u8 const *)in_ie + 12U, (int )(in_len - 12U));
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    if (pmlmepriv->qos_option == 0U) {
      out_len = *pout_len;
      tmp = rtw_set_ie23a(out_ie + (unsigned long )out_len, 221, 7U, (u8 const *)(& WMM_IE),
                          pout_len);
      pframe = tmp;
      pmlmepriv->qos_option = 1U;
    } else {
    }
    out_len = *pout_len;
    memset((void *)(& ht_capie), 0, 26UL);
    ht_capie.cap_info = 4322U;
    GetHalDefVar8192CUsb(padapter, 5, (void *)(& rx_packet_offset));
    GetHalDefVar8192CUsb(padapter, 4, (void *)(& max_recvbuf_sz));
    GetHalDefVar8192CUsb(padapter, 11, (void *)(& max_rx_ampdu_factor));
    ht_capie.ampdu_params_info = (unsigned int )((u8 )max_rx_ampdu_factor) & 3U;
    if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
      ht_capie.ampdu_params_info = (u8 )((unsigned int )ht_capie.ampdu_params_info | 28U);
    } else {
      ht_capie.ampdu_params_info = ht_capie.ampdu_params_info;
    }
    tmp___0 = rtw_set_ie23a(out_ie + (unsigned long )out_len, 45, 26U, (u8 const *)(& ht_capie),
                            pout_len);
    pframe = tmp___0;
    phtpriv->ht_option = 1U;
    p = cfg80211_find_ie(61, (u8 const *)in_ie + 12U, (int )(in_len - 12U));
    if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) == 22U) {
      out_len = *pout_len;
      tmp___1 = rtw_set_ie23a(out_ie + (unsigned long )out_len, 61, (uint )*(p + 1UL),
                              p + 2UL, pout_len);
      pframe = tmp___1;
    } else {
    }
  } else {
  }
  return (phtpriv->ht_option);
}
}
void rtw_update_ht_cap23a(struct rtw_adapter *padapter , u8 *pie , uint ie_len )
{
  u8 max_ampdu_sz ;
  u8 const *p ;
  struct ieee80211_ht_cap *pht_capie ;
  struct ieee80211_ht_addt_info *pht_addtinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bcn_fixed_size ;
  int i ;
  u8 rf_type ;
  {
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  pregistrypriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (phtpriv->ht_option == 0U) {
    return;
  } else {
  }
  if ((unsigned int )pmlmeinfo->HT_info_enable == 0U || (unsigned int )pmlmeinfo->HT_caps_enable == 0U) {
    return;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +rtw_update_ht_cap23a()\n");
  } else {
  }
  bcn_fixed_size = 12;
  pie = pie + (unsigned long )bcn_fixed_size;
  ie_len = ie_len - (uint )bcn_fixed_size;
  if (phtpriv->ampdu_enable == 0U && (unsigned int )pregistrypriv->ampdu_enable == 1U) {
    if ((unsigned int )pregistrypriv->wifi_spec == 1U) {
      phtpriv->ampdu_enable = 0U;
    } else {
      phtpriv->ampdu_enable = 1U;
    }
  } else
  if ((unsigned int )pregistrypriv->ampdu_enable == 2U) {
    phtpriv->ampdu_enable = 1U;
  } else {
  }
  p = cfg80211_find_ie(45, (u8 const *)pie, (int )ie_len);
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_capie = (struct ieee80211_ht_cap *)p + 2U;
    max_ampdu_sz = (unsigned int )pht_capie->ampdu_params_info & 3U;
    max_ampdu_sz = (u8 )(1 << ((int )max_ampdu_sz + 3));
    phtpriv->rx_ampdu_maxlen = (u32 )max_ampdu_sz;
  } else {
  }
  p = cfg80211_find_ie(61, (u8 const *)pie, (int )ie_len);
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_addtinfo = (struct ieee80211_ht_addt_info *)p + 2U;
  } else {
  }
  if (((unsigned int )pregistrypriv->cbw40_enable != 0U && ((unsigned long )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 2UL) != 0UL) && ((unsigned long )pmlmeinfo->HT_info.infos[0] & 4UL) != 0UL) {
    rf_type = rtl8723a_get_rf_type(padapter);
    i = 0;
    goto ldv_54900;
    ldv_54899: ;
    if ((unsigned int )rf_type == 3U || (unsigned int )rf_type == 0U) {
      pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] = (int )pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] & (int )MCS_rate_1R23A[i];
    } else {
      pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] = (int )pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] & (int )MCS_rate_2R23A[i];
    }
    i = i + 1;
    ldv_54900: ;
    if (i <= 15) {
      goto ldv_54899;
    } else {
    }
    pmlmeext->cur_bwmode = 1U;
    switch ((int )pmlmeinfo->HT_info.infos[0] & 3) {
    case 1:
    pmlmeext->cur_ch_offset = 1U;
    goto ldv_54903;
    case 3:
    pmlmeext->cur_ch_offset = 2U;
    goto ldv_54903;
    default:
    pmlmeext->cur_ch_offset = 0U;
    goto ldv_54903;
    }
    ldv_54903: ;
  } else {
  }
  pmlmeinfo->SM_PS = (u8 )(((int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 12) >> 2);
  if ((unsigned int )pmlmeinfo->SM_PS == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): WLAN_HT_CAP_SM_PS_STATIC\n", "rtw_update_ht_cap23a");
    } else {
    }
  } else {
  }
  pmlmeinfo->HT_protection = (unsigned int )pmlmeinfo->HT_info.infos[1] & 3U;
  return;
}
}
void rtw_issue_addbareq_cmd23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  u8 issued ;
  int priority ;
  struct sta_info *psta ;
  struct ht_priv *phtpriv ;
  struct pkt_attrib *pattrib ;
  s32 bmcst ;
  bool tmp ;
  {
  pattrib = & pxmitframe->attrib;
  tmp = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
  bmcst = (s32 )tmp;
  if (bmcst != 0 || padapter->mlmepriv.LinkDetectInfo.NumTxOkInPeriod <= 99U) {
    return;
  } else {
  }
  priority = (int )pattrib->priority;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_issue_addbareq_cmd23a");
    } else {
    }
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_issue_addbareq_cmd23a");
    } else {
    }
    return;
  } else {
  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_issue_addbareq_cmd23a",
             psta->state);
    } else {
    }
    return;
  } else {
  }
  phtpriv = & psta->htpriv;
  if (phtpriv->ht_option == 1U && phtpriv->ampdu_enable == 1U) {
    issued = (unsigned int )((u8 )((int )phtpriv->agg_enable_bitmap >> priority)) & 1U;
    issued = (u8 )(((int )((signed char )((int )phtpriv->candidate_tid_bitmap >> priority)) & 1) | (int )((signed char )issued));
    if ((unsigned int )issued == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: rtw_issue_addbareq_cmd23a, p =%d\n", priority);
      } else {
      }
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap | (int )((u16 )(1UL << priority));
      rtw_addbareq_cmd23a(padapter, (int )((unsigned char )priority), (u8 *)(& pattrib->ra));
    } else {
    }
  } else {
  }
  return;
}
}
int rtw_linked_check(struct rtw_adapter *padapter )
{
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  tmp___0 = check_fwstate(& padapter->mlmepriv, 16);
  if ((int )tmp___0) {
    goto _L;
  } else {
    tmp___1 = check_fwstate(& padapter->mlmepriv, 96);
    if ((int )tmp___1) {
      _L:
      if (padapter->stapriv.asoc_sta_count > 2) {
        return (1);
      } else {
      }
    } else {
      tmp = check_fwstate(& padapter->mlmepriv, 1);
      if ((int )tmp) {
        return (1);
      } else {
      }
    }
  }
  return (0);
}
}
void ldv_timer_5(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  rtw_set_scan_deny_timer_hdl(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void choose_timer_5(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_5_0 == 1) {
    ldv_timer_5_0 = 2;
    ldv_timer_5(ldv_timer_5_0, ldv_timer_list_5_0);
  } else {
  }
  goto ldv_54929;
  case 1: ;
  if (ldv_timer_5_1 == 1) {
    ldv_timer_5_1 = 2;
    ldv_timer_5(ldv_timer_5_1, ldv_timer_list_5_1);
  } else {
  }
  goto ldv_54929;
  case 2: ;
  if (ldv_timer_5_2 == 1) {
    ldv_timer_5_2 = 2;
    ldv_timer_5(ldv_timer_5_2, ldv_timer_list_5_2);
  } else {
  }
  goto ldv_54929;
  case 3: ;
  if (ldv_timer_5_3 == 1) {
    ldv_timer_5_3 = 2;
    ldv_timer_5(ldv_timer_5_3, ldv_timer_list_5_3);
  } else {
  }
  goto ldv_54929;
  default:
  ldv_stop();
  }
  ldv_54929: ;
  return;
}
}
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_2_0 == (unsigned long )timer) {
    if (ldv_timer_2_0 == 2 || pending_flag != 0) {
      ldv_timer_list_2_0 = timer;
      ldv_timer_list_2_0->data = data;
      ldv_timer_2_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_2_1 == (unsigned long )timer) {
    if (ldv_timer_2_1 == 2 || pending_flag != 0) {
      ldv_timer_list_2_1 = timer;
      ldv_timer_list_2_1->data = data;
      ldv_timer_2_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_2_2 == (unsigned long )timer) {
    if (ldv_timer_2_2 == 2 || pending_flag != 0) {
      ldv_timer_list_2_2 = timer;
      ldv_timer_list_2_2->data = data;
      ldv_timer_2_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_2_3 == (unsigned long )timer) {
    if (ldv_timer_2_3 == 2 || pending_flag != 0) {
      ldv_timer_list_2_3 = timer;
      ldv_timer_list_2_3->data = data;
      ldv_timer_2_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_2(timer, data);
  return;
}
}
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_4_0 == (unsigned long )timer) {
    if (ldv_timer_4_0 == 2 || pending_flag != 0) {
      ldv_timer_list_4_0 = timer;
      ldv_timer_list_4_0->data = data;
      ldv_timer_4_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_4_1 == (unsigned long )timer) {
    if (ldv_timer_4_1 == 2 || pending_flag != 0) {
      ldv_timer_list_4_1 = timer;
      ldv_timer_list_4_1->data = data;
      ldv_timer_4_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_4_2 == (unsigned long )timer) {
    if (ldv_timer_4_2 == 2 || pending_flag != 0) {
      ldv_timer_list_4_2 = timer;
      ldv_timer_list_4_2->data = data;
      ldv_timer_4_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_4_3 == (unsigned long )timer) {
    if (ldv_timer_4_3 == 2 || pending_flag != 0) {
      ldv_timer_list_4_3 = timer;
      ldv_timer_list_4_3->data = data;
      ldv_timer_4_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_4(timer, data);
  return;
}
}
void timer_init_4(void)
{
  {
  ldv_timer_4_0 = 0;
  ldv_timer_4_1 = 0;
  ldv_timer_4_2 = 0;
  ldv_timer_4_3 = 0;
  return;
}
}
void timer_init_2(void)
{
  {
  ldv_timer_2_0 = 0;
  ldv_timer_2_1 = 0;
  ldv_timer_2_2 = 0;
  ldv_timer_2_3 = 0;
  return;
}
}
void disable_suitable_timer_3(struct timer_list *timer )
{
  {
  if (ldv_timer_3_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_0) {
    ldv_timer_3_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_3_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_1) {
    ldv_timer_3_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_3_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_2) {
    ldv_timer_3_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_3_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_3) {
    ldv_timer_3_3 = 0;
    return;
  } else {
  }
  return;
}
}
void activate_suitable_timer_3(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_3_0 == 0 || ldv_timer_3_0 == 2) {
    ldv_timer_list_3_0 = timer;
    ldv_timer_list_3_0->data = data;
    ldv_timer_3_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_3_1 == 0 || ldv_timer_3_1 == 2) {
    ldv_timer_list_3_1 = timer;
    ldv_timer_list_3_1->data = data;
    ldv_timer_3_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_3_2 == 0 || ldv_timer_3_2 == 2) {
    ldv_timer_list_3_2 = timer;
    ldv_timer_list_3_2->data = data;
    ldv_timer_3_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_3_3 == 0 || ldv_timer_3_3 == 2) {
    ldv_timer_list_3_3 = timer;
    ldv_timer_list_3_3->data = data;
    ldv_timer_3_3 = 1;
    return;
  } else {
  }
  return;
}
}
void timer_init_5(void)
{
  {
  ldv_timer_5_0 = 0;
  ldv_timer_5_1 = 0;
  ldv_timer_5_2 = 0;
  ldv_timer_5_3 = 0;
  return;
}
}
void disable_suitable_timer_2(struct timer_list *timer )
{
  {
  if (ldv_timer_2_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_0) {
    ldv_timer_2_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_2_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_1) {
    ldv_timer_2_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_2_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_2) {
    ldv_timer_2_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_2_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_3) {
    ldv_timer_2_3 = 0;
    return;
  } else {
  }
  return;
}
}
int reg_timer_3(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& rtw_scan_timeout_handler23a)) {
    activate_suitable_timer_3(timer, data);
  } else {
  }
  return (0);
}
}
void disable_suitable_timer_5(struct timer_list *timer )
{
  {
  if (ldv_timer_5_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_0) {
    ldv_timer_5_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_5_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_1) {
    ldv_timer_5_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_5_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_2) {
    ldv_timer_5_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_5_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_3) {
    ldv_timer_5_3 = 0;
    return;
  } else {
  }
  return;
}
}
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_4_0 == 0 || ldv_timer_4_0 == 2) {
    ldv_timer_list_4_0 = timer;
    ldv_timer_list_4_0->data = data;
    ldv_timer_4_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_4_1 == 0 || ldv_timer_4_1 == 2) {
    ldv_timer_list_4_1 = timer;
    ldv_timer_list_4_1->data = data;
    ldv_timer_4_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_4_2 == 0 || ldv_timer_4_2 == 2) {
    ldv_timer_list_4_2 = timer;
    ldv_timer_list_4_2->data = data;
    ldv_timer_4_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_4_3 == 0 || ldv_timer_4_3 == 2) {
    ldv_timer_list_4_3 = timer;
    ldv_timer_list_4_3->data = data;
    ldv_timer_4_3 = 1;
    return;
  } else {
  }
  return;
}
}
void ldv_timer_2(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  rtw23a_join_to_handler(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void choose_timer_2(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_2_0 == 1) {
    ldv_timer_2_0 = 2;
    ldv_timer_2(ldv_timer_2_0, ldv_timer_list_2_0);
  } else {
  }
  goto ldv_54984;
  case 1: ;
  if (ldv_timer_2_1 == 1) {
    ldv_timer_2_1 = 2;
    ldv_timer_2(ldv_timer_2_1, ldv_timer_list_2_1);
  } else {
  }
  goto ldv_54984;
  case 2: ;
  if (ldv_timer_2_2 == 1) {
    ldv_timer_2_2 = 2;
    ldv_timer_2(ldv_timer_2_2, ldv_timer_list_2_2);
  } else {
  }
  goto ldv_54984;
  case 3: ;
  if (ldv_timer_2_3 == 1) {
    ldv_timer_2_3 = 2;
    ldv_timer_2(ldv_timer_2_3, ldv_timer_list_2_3);
  } else {
  }
  goto ldv_54984;
  default:
  ldv_stop();
  }
  ldv_54984: ;
  return;
}
}
int reg_timer_2(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& rtw23a_join_to_handler)) {
    activate_suitable_timer_2(timer, data);
  } else {
  }
  return (0);
}
}
void choose_timer_3(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_3_0 == 1) {
    ldv_timer_3_0 = 2;
    ldv_timer_3(ldv_timer_3_0, ldv_timer_list_3_0);
  } else {
  }
  goto ldv_54999;
  case 1: ;
  if (ldv_timer_3_1 == 1) {
    ldv_timer_3_1 = 2;
    ldv_timer_3(ldv_timer_3_1, ldv_timer_list_3_1);
  } else {
  }
  goto ldv_54999;
  case 2: ;
  if (ldv_timer_3_2 == 1) {
    ldv_timer_3_2 = 2;
    ldv_timer_3(ldv_timer_3_2, ldv_timer_list_3_2);
  } else {
  }
  goto ldv_54999;
  case 3: ;
  if (ldv_timer_3_3 == 1) {
    ldv_timer_3_3 = 2;
    ldv_timer_3(ldv_timer_3_3, ldv_timer_list_3_3);
  } else {
  }
  goto ldv_54999;
  default:
  ldv_stop();
  }
  ldv_54999: ;
  return;
}
}
void timer_init_3(void)
{
  {
  ldv_timer_3_0 = 0;
  ldv_timer_3_1 = 0;
  ldv_timer_3_2 = 0;
  ldv_timer_3_3 = 0;
  return;
}
}
void choose_timer_4(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_4_0 == 1) {
    ldv_timer_4_0 = 2;
    ldv_timer_4(ldv_timer_4_0, ldv_timer_list_4_0);
  } else {
  }
  goto ldv_55011;
  case 1: ;
  if (ldv_timer_4_1 == 1) {
    ldv_timer_4_1 = 2;
    ldv_timer_4(ldv_timer_4_1, ldv_timer_list_4_1);
  } else {
  }
  goto ldv_55011;
  case 2: ;
  if (ldv_timer_4_2 == 1) {
    ldv_timer_4_2 = 2;
    ldv_timer_4(ldv_timer_4_2, ldv_timer_list_4_2);
  } else {
  }
  goto ldv_55011;
  case 3: ;
  if (ldv_timer_4_3 == 1) {
    ldv_timer_4_3 = 2;
    ldv_timer_4(ldv_timer_4_3, ldv_timer_list_4_3);
  } else {
  }
  goto ldv_55011;
  default:
  ldv_stop();
  }
  ldv_55011: ;
  return;
}
}
void disable_suitable_timer_4(struct timer_list *timer )
{
  {
  if (ldv_timer_4_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_0) {
    ldv_timer_4_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_4_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_1) {
    ldv_timer_4_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_4_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_2) {
    ldv_timer_4_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_4_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_3) {
    ldv_timer_4_3 = 0;
    return;
  } else {
  }
  return;
}
}
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& rtw_dynamic_check_timer_handler)) {
    activate_suitable_timer_4(timer, data);
  } else {
  }
  return (0);
}
}
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_3_0 == (unsigned long )timer) {
    if (ldv_timer_3_0 == 2 || pending_flag != 0) {
      ldv_timer_list_3_0 = timer;
      ldv_timer_list_3_0->data = data;
      ldv_timer_3_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_3_1 == (unsigned long )timer) {
    if (ldv_timer_3_1 == 2 || pending_flag != 0) {
      ldv_timer_list_3_1 = timer;
      ldv_timer_list_3_1->data = data;
      ldv_timer_3_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_3_2 == (unsigned long )timer) {
    if (ldv_timer_3_2 == 2 || pending_flag != 0) {
      ldv_timer_list_3_2 = timer;
      ldv_timer_list_3_2->data = data;
      ldv_timer_3_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_3_3 == (unsigned long )timer) {
    if (ldv_timer_3_3 == 2 || pending_flag != 0) {
      ldv_timer_list_3_3 = timer;
      ldv_timer_list_3_3->data = data;
      ldv_timer_3_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_3(timer, data);
  return;
}
}
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_5_0 == (unsigned long )timer) {
    if (ldv_timer_5_0 == 2 || pending_flag != 0) {
      ldv_timer_list_5_0 = timer;
      ldv_timer_list_5_0->data = data;
      ldv_timer_5_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_5_1 == (unsigned long )timer) {
    if (ldv_timer_5_1 == 2 || pending_flag != 0) {
      ldv_timer_list_5_1 = timer;
      ldv_timer_list_5_1->data = data;
      ldv_timer_5_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_5_2 == (unsigned long )timer) {
    if (ldv_timer_5_2 == 2 || pending_flag != 0) {
      ldv_timer_list_5_2 = timer;
      ldv_timer_list_5_2->data = data;
      ldv_timer_5_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_5_3 == (unsigned long )timer) {
    if (ldv_timer_5_3 == 2 || pending_flag != 0) {
      ldv_timer_list_5_3 = timer;
      ldv_timer_list_5_3->data = data;
      ldv_timer_5_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_5(timer, data);
  return;
}
}
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& rtw_set_scan_deny_timer_hdl)) {
    activate_suitable_timer_5(timer, data);
  } else {
  }
  return (0);
}
}
void ldv_timer_4(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  rtw_dynamic_check_timer_handler(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_5_0 == 0 || ldv_timer_5_0 == 2) {
    ldv_timer_list_5_0 = timer;
    ldv_timer_list_5_0->data = data;
    ldv_timer_5_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_5_1 == 0 || ldv_timer_5_1 == 2) {
    ldv_timer_list_5_1 = timer;
    ldv_timer_list_5_1->data = data;
    ldv_timer_5_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_5_2 == 0 || ldv_timer_5_2 == 2) {
    ldv_timer_list_5_2 = timer;
    ldv_timer_list_5_2->data = data;
    ldv_timer_5_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_5_3 == 0 || ldv_timer_5_3 == 2) {
    ldv_timer_list_5_3 = timer;
    ldv_timer_list_5_3->data = data;
    ldv_timer_5_3 = 1;
    return;
  } else {
  }
  return;
}
}
void activate_suitable_timer_2(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_2_0 == 0 || ldv_timer_2_0 == 2) {
    ldv_timer_list_2_0 = timer;
    ldv_timer_list_2_0->data = data;
    ldv_timer_2_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_2_1 == 0 || ldv_timer_2_1 == 2) {
    ldv_timer_list_2_1 = timer;
    ldv_timer_list_2_1->data = data;
    ldv_timer_2_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_2_2 == 0 || ldv_timer_2_2 == 2) {
    ldv_timer_list_2_2 = timer;
    ldv_timer_list_2_2->data = data;
    ldv_timer_2_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_2_3 == 0 || ldv_timer_2_3 == 2) {
    ldv_timer_list_2_3 = timer;
    ldv_timer_list_2_3->data = data;
    ldv_timer_2_3 = 1;
    return;
  } else {
  }
  return;
}
}
void ldv_timer_3(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  rtw_scan_timeout_handler23a(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void *ldv_kmem_cache_alloc_452(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_458(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_460(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_462(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_463(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_464(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_465(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_466(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_467(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_468(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_del_timer_sync_469(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_470(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_471(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_472(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_473(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_474(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_475(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_476(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_477(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_478(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_479(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static __u64 __le64_to_cpup(__le64 const *p )
{
  {
  return ((__u64 )*p);
}
}
extern int sprintf(char * , char const * , ...) ;
extern void __xadd_wrong_size(void) ;
__inline static int atomic_add_return(int i , atomic_t *v )
{
  int __ret ;
  {
  __ret = i;
  switch (4UL) {
  case 1UL:
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5626;
  case 2UL:
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5626;
  case 4UL:
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5626;
  case 8UL:
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5626;
  default:
  __xadd_wrong_size();
  }
  ldv_5626: ;
  return (__ret + i);
}
}
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long ) ;
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
__inline static void ldv_spin_unlock_irqrestore_508(spinlock_t *lock , unsigned long flags )
{
  {
  _raw_spin_unlock_irqrestore(& lock->ldv_6347.rlock, flags);
  return;
}
}
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
extern void mutex_lock_nested(struct mutex * , unsigned int ) ;
extern void mutex_unlock(struct mutex * ) ;
int ldv_mod_timer_535(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_536(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_538(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_539(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_540(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_542(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_544(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_546(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_547(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_552(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_553(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_533(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_534(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_537(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_541(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_543(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_545(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_548(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_549(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_550(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_551(struct timer_list *ldv_func_arg1 ) ;
extern void *ldv_malloc(size_t);
void *__kmalloc(size_t size, gfp_t t)
{
 return ldv_malloc(size);
}
void *ldv_kmem_cache_alloc_516(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *ldv_kmalloc_512(size_t size , gfp_t flags )
{
  void *tmp___2 ;
  {
  tmp___2 = __kmalloc(size, flags);
  return (tmp___2);
}
}
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct timer_list *ldv_timer_list_7_1 ;
struct timer_list *ldv_timer_list_8_1 ;
int ldv_timer_6_2 ;
int ldv_timer_6_0 ;
struct timer_list *ldv_timer_list_6_3 ;
int ldv_timer_8_2 ;
struct timer_list *ldv_timer_list_6_2 ;
struct timer_list *ldv_timer_list_7_3 ;
struct timer_list *ldv_timer_list_6_0 ;
struct timer_list *ldv_timer_list_8_3 ;
int ldv_timer_7_1 ;
struct timer_list *ldv_timer_list_7_0 ;
int ldv_timer_8_3 ;
int ldv_timer_7_3 ;
struct timer_list *ldv_timer_list_7_2 ;
struct timer_list *ldv_timer_list_6_1 ;
int ldv_timer_7_0 ;
int ldv_timer_6_3 ;
int ldv_timer_8_0 ;
int ldv_timer_8_1 ;
int ldv_timer_7_2 ;
struct timer_list *ldv_timer_list_8_0 ;
int ldv_timer_6_1 ;
struct timer_list *ldv_timer_list_8_2 ;
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) ;
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void disable_suitable_timer_8(struct timer_list *timer ) ;
void timer_init_6(void) ;
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void ldv_timer_7(int state , struct timer_list *timer ) ;
void choose_timer_8(void) ;
void disable_suitable_timer_7(struct timer_list *timer ) ;
int reg_timer_8(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void choose_timer_6(void) ;
void ldv_timer_6(int state , struct timer_list *timer ) ;
void timer_init_7(void) ;
void ldv_timer_8(int state , struct timer_list *timer ) ;
void choose_timer_7(void) ;
void timer_init_8(void) ;
void activate_suitable_timer_8(struct timer_list *timer , unsigned long data ) ;
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data ) ;
extern void yield(void) ;
struct sk_buff *ldv_skb_clone_524(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_532(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_526(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_522(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_530(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_531(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_527(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_528(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_529(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
__inline static u64 get_unaligned_le64(void const *p )
{
  __u64 tmp ;
  {
  tmp = __le64_to_cpup((__le64 const *)p);
  return (tmp);
}
}
__inline static void put_unaligned_le16(u16 val , void *p )
{
  {
  *((__le16 *)p) = val;
  return;
}
}
__inline static bool is_broadcast_ether_addr(u8 const *addr )
{
  {
  return ((unsigned int )(((int )((unsigned short )*((u16 const *)addr)) & (int )((unsigned short )*((u16 const *)addr + 2U))) & (int )((unsigned short )*((u16 const *)addr + 4U))) == 65535U);
}
}
__inline static int ieee80211_has_retry(__le16 fc )
{
  {
  return (((int )fc & 2048) != 0);
}
}
__inline static int ieee80211_is_mgmt(__le16 fc )
{
  {
  return (((int )fc & 12) == 0);
}
}
__inline static int ieee80211_is_assoc_req(__le16 fc )
{
  {
  return (((int )fc & 252) == 0);
}
}
__inline static int ieee80211_is_probe_req(__le16 fc )
{
  {
  return (((int )fc & 252) == 64);
}
}
__inline static int ieee80211_is_probe_resp(__le16 fc )
{
  {
  return (((int )fc & 252) == 80);
}
}
__inline static int ieee80211_is_beacon(__le16 fc )
{
  {
  return (((int )fc & 252) == 128);
}
}
__inline static void *wiphy_priv___0(struct wiphy *wiphy )
{
  long tmp ;
  {
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3111), "i" (12UL));
    ldv_45997: ;
    goto ldv_45997;
  } else {
  }
  return ((void *)(& wiphy->priv));
}
}
__inline static void *wdev_priv___0(struct wireless_dev *wdev )
{
  long tmp ;
  void *tmp___0 ;
  {
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3343), "i" (12UL));
    ldv_46077: ;
    goto ldv_46077;
  } else {
  }
  tmp___0 = wiphy_priv___0(wdev->wiphy);
  return (tmp___0);
}
}
extern u8 hal_ch_offset_to_secondary_ch_offset23a(u8 ) ;
extern u8 *rtw_set_ie23a_ch_switch(u8 * , u32 * , u8 , u8 , u8 ) ;
extern u8 *rtw_set_ie23a_secondary_ch_offset(u8 * , u32 * , u8 ) ;
void rtw_sctx_init23a(struct submit_ctx *sctx , int timeout_ms ) ;
int rtw_sctx_wait23a(struct submit_ctx *sctx ) ;
struct xmit_buf *rtw_alloc_xmitbuf23a_ext(struct xmit_priv *pxmitpriv ) ;
s32 rtw_free_xmitbuf23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) ;
struct xmit_frame *rtw_alloc_xmitframe23a_ext(struct xmit_priv *pxmitpriv ) ;
s32 rtw_free_xmitframe23a(struct xmit_priv *pxmitpriv , struct xmit_frame *pxmitframe ) ;
int rtw_ack_tx_wait23a(struct xmit_priv *pxmitpriv , u32 timeout_ms ) ;
void mgt_dispatcher23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void hw_var_set_correct_tsf(struct rtw_adapter *padapter ) ;
void hw_var_set_mlme_disconnect(struct rtw_adapter *padapter ) ;
void hw_var_set_opmode(struct rtw_adapter *padapter , u8 mode ) ;
void hw_var_set_bssid(struct rtw_adapter *padapter , u8 *val ) ;
void hw_var_set_mlme_join(struct rtw_adapter *padapter , u8 type ) ;
void HalSetBrateCfg23a(struct rtw_adapter *padapter , u8 *mBratesOS ) ;
void rtl8723a_set_bcn_func(struct rtw_adapter *padapter , u8 val ) ;
void rtl8723a_mlme_sitesurvey(struct rtw_adapter *padapter , u8 flag ) ;
void rtl8723a_on_rcr_am(struct rtw_adapter *padapter ) ;
void rtl8723a_set_sec_cfg(struct rtw_adapter *padapter , u8 sec ) ;
void rtl8723a_cam_write(struct rtw_adapter *padapter , u8 entry , u16 ctrl , u8 const *mac ,
                        u8 const *key ) ;
void rtl8723a_bcn_valid(struct rtw_adapter *padapter ) ;
bool rtl8723a_get_bcn_valid(struct rtw_adapter *padapter ) ;
void rtl8723a_set_beacon_interval(struct rtw_adapter *padapter , u16 interval ) ;
void rtl8723a_set_initial_gain(struct rtw_adapter *padapter , u32 rx_gain ) ;
void rtl8723a_odm_support_ability_backup(struct rtw_adapter *padapter ) ;
void rtl8723a_odm_support_ability_restore(struct rtw_adapter *padapter ) ;
void rtl8723a_odm_support_ability_set(struct rtw_adapter *padapter , u32 val ) ;
void rtl8723a_odm_support_ability_clr(struct rtw_adapter *padapter , u32 val ) ;
void rtw_wep_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
unsigned char WMM_OUI23A[4U] ;
unsigned char WPS_OUI23A[4U] ;
unsigned char WFD_OUI23A[4U] ;
unsigned char P2P_OUI23A[4U] ;
unsigned char WMM_INFO_OUI23A[6U] ;
unsigned char WMM_PARA_OUI23A[6U] ;
int rtw_ch_set_search_ch23a(struct rt_channel_info *ch_set , u32 const ch ) ;
int init_mlme_ext_priv23a(struct rtw_adapter *padapter ) ;
int init_hw_mlme_ext23a(struct rtw_adapter *padapter ) ;
void free_mlme_ext_priv23a(struct mlme_ext_priv *pmlmeext ) ;
void init_mlme_ext_timer23a(struct rtw_adapter *padapter ) ;
void init_addba_retry_timer23a(struct sta_info *psta ) ;
struct xmit_frame *alloc_mgtxmitframe23a(struct xmit_priv *pxmitpriv ) ;
void get_rate_set23a(struct rtw_adapter *padapter , unsigned char *pbssrate , int *bssrate_len ) ;
void UpdateBrateTbl23a(struct rtw_adapter *Adapter , u8 *mBratesOS ) ;
void Update23aTblForSoftAP(u8 *bssrateset , u32 bssratelen ) ;
void Set_MSR23a(struct rtw_adapter *padapter , u8 type ) ;
extern u8 rtw_get_oper_ch23a(struct rtw_adapter * ) ;
void set_channel_bwmode23a(struct rtw_adapter *padapter , unsigned char channel ,
                           unsigned char channel_offset , unsigned short bwmode ) ;
void SelectChannel23a(struct rtw_adapter *padapter , unsigned char channel ) ;
unsigned int decide_wait_for_beacon_timeout23a(unsigned int bcn_interval ) ;
int allocate_fw_sta_entry23a(struct rtw_adapter *padapter ) ;
void flush_all_cam_entry23a(struct rtw_adapter *padapter ) ;
bool IsLegal5GChannel(struct rtw_adapter *Adapter , u8 channel ) ;
int collect_bss_info23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ,
                        struct wlan_bssid_ex *bssid ) ;
extern u8 *get_my_bssid23a(struct wlan_bssid_ex * ) ;
u16 get_beacon_interval23a(struct wlan_bssid_ex *bss ) ;
bool is_client_associated_to_ap23a(struct rtw_adapter *padapter ) ;
bool is_client_associated_to_ibss23a(struct rtw_adapter *padapter ) ;
bool is_IBSS_empty23a(struct rtw_adapter *padapter ) ;
int WMM_param_handler23a(struct rtw_adapter *padapter , u8 *p ) ;
void WMMOnAssocRsp23a(struct rtw_adapter *padapter ) ;
void HT_caps_handler23a(struct rtw_adapter *padapter , u8 *p ) ;
void HT_info_handler23a(struct rtw_adapter *padapter , u8 *p ) ;
void HTOnAssocRsp23a(struct rtw_adapter *padapter ) ;
void ERP_IE_handler23a(struct rtw_adapter *padapter , u8 *p ) ;
void VCS_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void update_beacon23a_info(struct rtw_adapter *padapter , u8 *pframe , uint pkt_len ,
                           struct sta_info *psta ) ;
int rtw_check_bcn_info23a(struct rtw_adapter *Adapter , struct ieee80211_mgmt *mgmt ,
                          u32 pkt_len ) ;
void update_IOT_info23a(struct rtw_adapter *padapter ) ;
void update_capinfo23a(struct rtw_adapter *Adapter , u16 updateCap ) ;
void update_wireless_mode23a(struct rtw_adapter *padapter ) ;
void update_tx_basic_rate23a(struct rtw_adapter *padapter , u8 wirelessmode ) ;
void update_bmc_sta_support_rate23a(struct rtw_adapter *padapter , u32 mac_id ) ;
int update_sta_support_rate23a(struct rtw_adapter *padapter , u8 *pvar_ie , uint var_ie_len ,
                               int cam_idx ) ;
void Update_RA_Entry23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void set_sta_rate23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
int receive_disconnect23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                          unsigned short reason ) ;
int support_short_GI23a(struct rtw_adapter *padapter , struct HT_caps_element *pHT_caps ) ;
bool is_ap_in_tkip23a(struct rtw_adapter *padapter ) ;
void report_join_res23a(struct rtw_adapter *padapter , int res ) ;
void report_survey_event23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void report_surveydone_event23a(struct rtw_adapter *padapter ) ;
void report_del_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             unsigned short reason ) ;
void report_add_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             int cam_idx ) ;
int set_tx_beacon_cmd23a(struct rtw_adapter *padapter ) ;
void update_mgnt_tx_rate23a(struct rtw_adapter *padapter , u8 rate ) ;
void update_mgntframe_attrib23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) ;
void dump_mgntframe23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
s32 dump_mgntframe23a_and_wait(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ,
                               int timeout_ms ) ;
s32 dump_mgntframe23a_and_wait_ack23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
void issue_beacon23a(struct rtw_adapter *padapter , int timeout_ms ) ;
int issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                      int try_cnt , int wait_ms ) ;
int issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , u16 tid ,
                          int try_cnt , int wait_ms ) ;
int issue_deauth23a(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ) ;
void issue_action_spct_ch_switch23a(struct rtw_adapter *padapter , u8 *ra , u8 new_ch ,
                                    u8 ch_offset ) ;
void issue_action_BA23a(struct rtw_adapter *padapter , unsigned char const *raddr ,
                        unsigned char action , unsigned short status ) ;
int send_delba23a(struct rtw_adapter *padapter , u8 initiator , u8 *addr ) ;
int send_beacon23a(struct rtw_adapter *padapter ) ;
void process_addba_req23a(struct rtw_adapter *padapter , u8 *paddba_req , u8 *addr ) ;
void init_mlme_ap_info23a(struct rtw_adapter *padapter ) ;
void associated_clients_update23a(struct rtw_adapter *padapter , u8 updated ) ;
void bss_cap_update_on_sta_join23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void sta_info_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
u8 ap_free_sta23a(struct rtw_adapter *padapter , struct sta_info *psta , bool active ,
                  u16 reason ) ;
void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter , u8 *pmgmt_frame ,
                                     uint frame_len ) ;
void rtw_cfg80211_rx_action(struct rtw_adapter *adapter , u8 *frame , uint frame_len ,
                            char const *msg ) ;
int rtl8723au_hal_xmitframe_enqueue(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
int rtl8723au_mgnt_xmit(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
void rtl8723a_sreset_linked_status_check(struct rtw_adapter *padapter ) ;
void rtl8723a_SetBeaconRelatedRegisters(struct rtw_adapter *padapter ) ;
static int OnAssocReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAssocRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnProbeReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnProbeRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int DoReserved23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnBeacon23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAtim23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnDisassoc23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAuth23aClient23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnDeAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int on_action_spct23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_qos(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_dls(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_back23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int on_action_public23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_ht(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_wmm(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int OnAction23a_p2p(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static void issue_assocreq(struct rtw_adapter *padapter ) ;
__inline static void issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                    u8 *da ) ;
static int issue_probereq_ex(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                             u8 *da , int try_cnt , int wait_ms ) ;
static void issue_probersp(struct rtw_adapter *padapter , unsigned char *da , u8 is_valid_p2p_probereq ) ;
static void issue_auth(struct rtw_adapter *padapter , struct sta_info *psta , unsigned short status ) ;
static int issue_deauth_ex(struct rtw_adapter *padapter , u8 *da , unsigned short reason ,
                           int try_cnt , int wait_ms ) ;
static void start_clnt_assoc(struct rtw_adapter *padapter ) ;
static void start_clnt_auth(struct rtw_adapter *padapter ) ;
static void start_clnt_join(struct rtw_adapter *padapter ) ;
static void start_create_ibss(struct rtw_adapter *padapter ) ;
static int OnAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static void issue_assocrsp(struct rtw_adapter *padapter , unsigned short status ,
                           struct sta_info *pstat , u16 pkt_type ) ;
static struct mlme_handler mlme_sta_tbl[14U] =
  { {(char *)"OnAssocReq23a", & OnAssocReq23a},
        {(char *)"OnAssocRsp23a", & OnAssocRsp23a},
        {(char *)"OnReAssocReq", & OnAssocReq23a},
        {(char *)"OnReAssocRsp", & OnAssocRsp23a},
        {(char *)"OnProbeReq23a", & OnProbeReq23a},
        {(char *)"OnProbeRsp23a", & OnProbeRsp23a},
        {(char *)"DoReserved23a", & DoReserved23a},
        {(char *)"DoReserved23a", & DoReserved23a},
        {(char *)"OnBeacon23a", & OnBeacon23a},
        {(char *)"OnATIM", & OnAtim23a},
        {(char *)"OnDisassoc23a", & OnDisassoc23a},
        {(char *)"OnAuth23a", & OnAuth23aClient23a},
        {(char *)"OnDeAuth23a", & OnDeAuth23a},
        {(char *)"OnAction23a", & OnAction23a}};
static struct action_handler OnAction23a_tbl[9U] =
  { {0U, (char *)"ACTION_SPECTRUM_MGMT", & on_action_spct23a},
        {1U, (char *)"ACTION_QOS", & OnAction23a_qos},
        {2U, (char *)"ACTION_DLS", & OnAction23a_dls},
        {3U, (char *)"ACTION_BACK", & OnAction23a_back23a},
        {4U, (char *)"ACTION_PUBLIC", & on_action_public23a},
        {7U, (char *)"ACTION_HT", & OnAction23a_ht},
        {8U, (char *)"ACTION_SA_QUERY", & DoReserved23a},
        {17U, (char *)"ACTION_WMM", & OnAction23a_wmm},
        {127U, (char *)"ACTION_P2P", & OnAction23a_p2p}};
static u8 null_addr[6U] = { 0U, 0U, 0U, 0U,
        0U, 0U};
unsigned char WMM_OUI23A[4U] = { 0U, 80U, 242U, 2U};
unsigned char WPS_OUI23A[4U] = { 0U, 80U, 242U, 4U};
unsigned char P2P_OUI23A[4U] = { 80U, 111U, 154U, 9U};
unsigned char WFD_OUI23A[4U] = { 80U, 111U, 154U, 10U};
unsigned char WMM_INFO_OUI23A[6U] = { 0U, 80U, 242U, 2U,
        0U, 1U};
unsigned char WMM_PARA_OUI23A[6U] = { 0U, 80U, 242U, 2U,
        1U, 1U};
static unsigned char REALTEK_96B_IE[6U] = { 0U, 224U, 76U, 2U,
        1U, 32U};
unsigned char MCS_rate_2R23A[16U] =
  { 255U, 255U, 0U, 0U,
        1U, 0U, 0U, 0U,
        0U, 0U, 0U, 0U,
        0U, 0U, 0U, 0U};
unsigned char MCS_rate_1R23A[16U] =
  { 255U, 0U, 0U, 0U,
        1U, 0U, 0U, 0U,
        0U, 0U, 0U, 0U,
        0U, 0U, 0U, 0U};
static struct rt_channel_plan_2g RTW_ChannelPlan2G[6U] = { {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U}, 13U},
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U}, 13U},
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U}, 11U},
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U, 14U}, 14U},
        {{10U, 11U, 12U, 13U}, 4U},
        {{(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, 0U}};
static struct rt_channel_plan_5g RTW_ChannelPlan5G[20U] =
  { {{(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, 0U},
        {{36U,
       40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U, 124U,
       128U, 132U, 136U, 140U}, 19U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U, 149U, 153U, 157U, 161U, 165U}, 24U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 149U, 153U, 157U, 161U, 165U}, 22U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U, 149U, 153U, 157U, 161U, 165U}, 24U},
        {{36U, 40U, 44U, 48U, 149U, 153U, 157U, 161U, 165U}, 9U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 149U, 153U, 157U, 161U, 165U}, 13U},
        {{36U,
       40U, 44U, 48U, 52U, 56U, 60U, 64U, 149U, 153U, 157U, 161U}, 12U},
        {{149U, 153U, 157U, 161U, 165U}, 5U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U}, 8U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 136U,
       140U, 149U, 153U, 157U, 161U, 165U}, 20U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 149U, 153U, 157U, 161U, 165U}, 20U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U}, 19U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U}, 8U},
        {{100U, 104U, 108U, 112U, 116U, 120U, 124U, 128U, 132U, 136U, 140U}, 11U},
        {{56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 136U, 140U, 149U, 153U, 157U,
       161U, 165U}, 15U},
        {{56U, 60U, 64U, 149U, 153U, 157U, 161U, 165U}, 8U},
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 132U,
       136U, 140U, 149U, 153U, 157U, 161U, 165U}, 21U},
        {{36U, 40U, 44U, 48U}, 4U},
        {{36U, 40U, 44U, 48U, 149U, 153U, 157U, 161U}, 8U}};
static struct rt_channel_plan_map RTW_ChannelPlanMap[66U] =
  { {2U, 17U},
        {2U, 10U},
        {1U, 1U},
        {1U, 0U},
        {1U, 0U},
        {3U, 0U},
        {3U, 0U},
        {1U, 9U},
        {3U, 9U},
        {3U, 0U},
        {0U, 0U},
        {2U, 15U},
        {1U, 8U},
        {2U, 6U},
        {2U, 11U},
        {2U, 9U},
        {1U, 1U},
        {2U, 5U},
        {1U, 18U},
        {0U, 4U},
        {2U, 16U},
        {0U, 18U},
        {0U, 19U},
        {3U, 18U},
        {5U, 8U},
        {2U, 8U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {5U, 4U},
        {0U, 0U},
        {1U, 0U},
        {2U, 0U},
        {3U, 0U},
        {4U, 0U},
        {2U, 4U},
        {0U, 1U},
        {3U, 12U},
        {0U, 11U},
        {0U, 5U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {0U, 6U},
        {0U, 7U},
        {0U, 8U},
        {0U, 9U},
        {2U, 10U},
        {0U, 2U},
        {0U, 3U},
        {3U, 13U},
        {3U, 14U},
        {2U, 15U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {0U, 0U},
        {2U, 16U},
        {3U, 0U}};
static struct rt_channel_plan_map RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE = {3U, 2U};
static void dummy_event_callback(struct rtw_adapter *adapter , u8 const *pbuf )
{
  {
  return;
}
}
static struct fwevent wlanevents[25U] =
  { {0U, & dummy_event_callback},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, & rtw_survey_event_cb23a},
        {4U, & rtw_surveydone_event_callback23a},
        {0U, & rtw23a_joinbss_event_cb},
        {12U, & rtw_stassoc_event_callback23a},
        {12U, & rtw_stadel_event_callback23a},
        {0U, & dummy_event_callback},
        {0U, & dummy_event_callback},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, & dummy_event_callback},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0},
        {0U, & dummy_event_callback},
        {0U, (void (*)(struct rtw_adapter * , u8 const * ))0}};
static void rtw_correct_TSF(struct rtw_adapter *padapter )
{
  {
  hw_var_set_correct_tsf(padapter);
  return;
}
}
static void rtw_update_TSF(struct mlme_ext_priv *pmlmeext , struct ieee80211_mgmt *mgmt )
{
  {
  pmlmeext->TSFValue = get_unaligned_le64((void const *)(& mgmt->u.beacon.timestamp));
  return;
}
}
int rtw_ch_set_search_ch23a(struct rt_channel_info *ch_set , u32 const ch )
{
  int i ;
  {
  i = 0;
  goto ldv_54463;
  ldv_54462: ;
  if ((unsigned int )(ch_set + (unsigned long )i)->ChannelNum == (unsigned int )ch) {
    goto ldv_54461;
  } else {
  }
  i = i + 1;
  ldv_54463: ;
  if ((unsigned int )(ch_set + (unsigned long )i)->ChannelNum != 0U) {
    goto ldv_54462;
  } else {
  }
  ldv_54461: ;
  if ((int )(ch_set + (unsigned long )i)->ChannelNum <= i) {
    return (-1);
  } else {
  }
  return (i);
}
}
int init_hw_mlme_ext23a(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  return (1);
}
}
static void init_mlme_ext_priv23a_value(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char mixed_datarate[13U] ;
  unsigned char mixed_basicrate[13U] ;
  unsigned int tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  mixed_datarate[0] = 0U;
  mixed_datarate[1] = 1U;
  mixed_datarate[2] = 2U;
  mixed_datarate[3] = 3U;
  mixed_datarate[4] = 4U;
  mixed_datarate[5] = 5U;
  mixed_datarate[6] = 6U;
  mixed_datarate[7] = 7U;
  mixed_datarate[8] = 8U;
  mixed_datarate[9] = 9U;
  mixed_datarate[10] = 10U;
  mixed_datarate[11] = 11U;
  mixed_datarate[12] = 255U;
  mixed_basicrate[0] = 0U;
  mixed_basicrate[1] = 1U;
  mixed_basicrate[2] = 2U;
  mixed_basicrate[3] = 3U;
  mixed_basicrate[4] = 4U;
  mixed_basicrate[5] = 6U;
  mixed_basicrate[6] = 8U;
  mixed_basicrate[7] = 255U;
  tmp = 8U;
  while (1) {
    if (tmp >= 13U) {
      break;
    } else {
    }
    mixed_basicrate[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  atomic_set(& pmlmeext->event_seq, 0);
  pmlmeext->mgnt_seq = 0U;
  pmlmeext->cur_channel = padapter->registrypriv.channel;
  pmlmeext->cur_bwmode = 0U;
  pmlmeext->cur_ch_offset = 0U;
  pmlmeext->retry = 0U;
  pmlmeext->cur_wireless_mode = padapter->registrypriv.wireless_mode;
  __len = 13UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pmlmeext->datarate), (void const *)(& mixed_datarate),
                     __len);
  } else {
    __ret = memcpy((void *)(& pmlmeext->datarate), (void const *)(& mixed_datarate),
                             __len);
  }
  __len___0 = 13UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& pmlmeext->basicrate), (void const *)(& mixed_basicrate),
                         __len___0);
  } else {
    __ret___0 = memcpy((void *)(& pmlmeext->basicrate), (void const *)(& mixed_basicrate),
                                 __len___0);
  }
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
    pmlmeext->tx_rate = 12U;
  } else {
    pmlmeext->tx_rate = 2U;
  }
  pmlmeext->sitesurvey_res.state = 0;
  pmlmeext->sitesurvey_res.channel_idx = 0;
  pmlmeext->sitesurvey_res.bss_cnt = 0;
  pmlmeext->scan_abort = 0U;
  pmlmeinfo->state = 0U;
  pmlmeinfo->reauth_count = 0U;
  pmlmeinfo->reassoc_count = 0U;
  pmlmeinfo->link_count = 0U;
  pmlmeinfo->auth_seq = 0U;
  pmlmeinfo->auth_algo = 0U;
  pmlmeinfo->key_index = 0U;
  pmlmeinfo->iv = 0U;
  pmlmeinfo->enc_algo = 0U;
  pmlmeinfo->authModeToggle = 0U;
  memset((void *)(& pmlmeinfo->chg_txt), 0, 128UL);
  pmlmeinfo->slotTime = 9U;
  pmlmeinfo->preamble_mode = 2U;
  pmlmeinfo->dialogToken = 0U;
  pmlmeext->action_public_rxseq = 65535U;
  pmlmeext->action_public_dialog_token = 255U;
  return;
}
}
static int has_channel(struct rt_channel_info *channel_set , u8 chanset_size , u8 chan )
{
  int i ;
  {
  i = 0;
  goto ldv_54488;
  ldv_54487: ;
  if ((int )(channel_set + (unsigned long )i)->ChannelNum == (int )chan) {
    return (1);
  } else {
  }
  i = i + 1;
  ldv_54488: ;
  if ((int )chanset_size > i) {
    goto ldv_54487;
  } else {
  }
  return (0);
}
}
static void init_channel_list(struct rtw_adapter *padapter , struct rt_channel_info *channel_set ,
                              u8 chanset_size , struct p2p_channels *channel_list )
{
  struct p2p_oper_class_map op_class[10U] ;
  int cla ;
  int op ;
  u8 ch ;
  struct p2p_oper_class_map *o ;
  struct p2p_reg_class *reg ;
  int tmp ;
  {
  op_class[0].mode = 0;
  op_class[0].op_class = 81U;
  op_class[0].min_chan = 1U;
  op_class[0].max_chan = 13U;
  op_class[0].inc = 1U;
  op_class[0].bw = 0;
  op_class[1].mode = 0;
  op_class[1].op_class = 82U;
  op_class[1].min_chan = 14U;
  op_class[1].max_chan = 14U;
  op_class[1].inc = 1U;
  op_class[1].bw = 0;
  op_class[2].mode = 1;
  op_class[2].op_class = 115U;
  op_class[2].min_chan = 36U;
  op_class[2].max_chan = 48U;
  op_class[2].inc = 4U;
  op_class[2].bw = 0;
  op_class[3].mode = 1;
  op_class[3].op_class = 116U;
  op_class[3].min_chan = 36U;
  op_class[3].max_chan = 44U;
  op_class[3].inc = 8U;
  op_class[3].bw = 1;
  op_class[4].mode = 1;
  op_class[4].op_class = 117U;
  op_class[4].min_chan = 40U;
  op_class[4].max_chan = 48U;
  op_class[4].inc = 8U;
  op_class[4].bw = 2;
  op_class[5].mode = 1;
  op_class[5].op_class = 124U;
  op_class[5].min_chan = 149U;
  op_class[5].max_chan = 161U;
  op_class[5].inc = 4U;
  op_class[5].bw = 0;
  op_class[6].mode = 1;
  op_class[6].op_class = 125U;
  op_class[6].min_chan = 149U;
  op_class[6].max_chan = 169U;
  op_class[6].inc = 4U;
  op_class[6].bw = 0;
  op_class[7].mode = 1;
  op_class[7].op_class = 126U;
  op_class[7].min_chan = 149U;
  op_class[7].max_chan = 157U;
  op_class[7].inc = 8U;
  op_class[7].bw = 1;
  op_class[8].mode = 1;
  op_class[8].op_class = 127U;
  op_class[8].min_chan = 153U;
  op_class[8].max_chan = 161U;
  op_class[8].inc = 8U;
  op_class[8].bw = 2;
  op_class[9].mode = 4294967295L;
  op_class[9].op_class = 0U;
  op_class[9].min_chan = 0U;
  op_class[9].max_chan = 0U;
  op_class[9].inc = 0U;
  op_class[9].bw = 0;
  cla = 0;
  op = 0;
  goto ldv_54507;
  ldv_54506:
  o = (struct p2p_oper_class_map *)(& op_class) + (unsigned long )op;
  reg = (struct p2p_reg_class *)0;
  ch = o->min_chan;
  goto ldv_54504;
  ldv_54503:
  tmp = has_channel(channel_set, (int )chanset_size, (int )ch);
  if (tmp == 0) {
    goto ldv_54502;
  } else {
  }
  if ((unsigned int )padapter->registrypriv.ht_enable == 0U && (unsigned int )o->inc == 8U) {
    goto ldv_54502;
  } else {
  }
  if (((unsigned long )padapter->registrypriv.cbw40_enable & 2UL) == 0UL && ((unsigned int )o->bw == 2U || (unsigned int )o->bw == 1U)) {
    goto ldv_54502;
  } else {
  }
  if ((unsigned long )reg == (unsigned long )((struct p2p_reg_class *)0)) {
    reg = (struct p2p_reg_class *)(& channel_list->reg_class) + (unsigned long )cla;
    cla = cla + 1;
    reg->reg_class = o->op_class;
    reg->channels = 0UL;
  } else {
  }
  reg->channel[reg->channels] = ch;
  reg->channels = reg->channels + 1UL;
  ldv_54502:
  ch = (int )o->inc + (int )ch;
  ldv_54504: ;
  if ((int )o->max_chan >= (int )ch) {
    goto ldv_54503;
  } else {
  }
  op = op + 1;
  ldv_54507: ;
  if ((unsigned int )op_class[op].op_class != 0U) {
    goto ldv_54506;
  } else {
  }
  channel_list->reg_classes = (size_t )cla;
  return;
}
}
static u8 init_channel_set(struct rtw_adapter *padapter , u8 cplan , struct rt_channel_info *c_set )
{
  u8 i ;
  u8 ch_size ;
  u8 b5GBand ;
  u8 b2_4GBand ;
  u8 Index2G ;
  u8 Index5G ;
  {
  ch_size = 0U;
  b5GBand = 0U;
  b2_4GBand = 0U;
  Index2G = 0U;
  Index5G = 0U;
  memset((void *)c_set, 0, 304UL);
  if ((unsigned int )cplan > 65U && (unsigned int )cplan != 127U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ChannelPlan ID %x error !!!!!\n", (int )cplan);
    } else {
    }
    return (ch_size);
  } else {
  }
  if (((int )padapter->registrypriv.wireless_mode & 2) != 0) {
    b2_4GBand = 1U;
    if ((unsigned int )cplan == 127U) {
      Index2G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index2G;
    } else {
      Index2G = RTW_ChannelPlanMap[(int )cplan].Index2G;
    }
  } else {
  }
  if (((int )padapter->registrypriv.wireless_mode & 4) != 0) {
    b5GBand = 1U;
    if ((unsigned int )cplan == 127U) {
      Index5G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index5G;
    } else {
      Index5G = RTW_ChannelPlanMap[(int )cplan].Index5G;
    }
  } else {
  }
  if ((unsigned int )b2_4GBand != 0U) {
    i = 0U;
    goto ldv_54521;
    ldv_54520:
    (c_set + (unsigned long )ch_size)->ChannelNum = RTW_ChannelPlan2G[(int )Index2G].Channel[(int )i];
    if ((unsigned int )cplan == 9U || (unsigned int )cplan == 65U) {
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum != 0U && (unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 11U) {
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      } else
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum > 11U && (unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 14U) {
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      } else {
      }
    } else
    if (((unsigned int )cplan == 10U || (unsigned int )cplan == 19U) || (unsigned int )Index2G == 0U) {
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 11U) {
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      } else {
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      }
    } else {
      (c_set + (unsigned long )ch_size)->ScanType = 1;
    }
    ch_size = (u8 )((int )ch_size + 1);
    i = (u8 )((int )i + 1);
    ldv_54521: ;
    if ((int )RTW_ChannelPlan2G[(int )Index2G].Len > (int )i) {
      goto ldv_54520;
    } else {
    }
  } else {
  }
  if ((unsigned int )b5GBand != 0U) {
    i = 0U;
    goto ldv_54525;
    ldv_54524: ;
    if ((unsigned int )RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i] <= 48U || (unsigned int )RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i] > 148U) {
      (c_set + (unsigned long )ch_size)->ChannelNum = RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i];
      if ((unsigned int )cplan == 19U) {
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      } else {
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(): channel_set[%d].ChannelNum = %d\n", "init_channel_set",
               (int )ch_size, (int )(c_set + (unsigned long )ch_size)->ChannelNum);
      } else {
      }
      ch_size = (u8 )((int )ch_size + 1);
    } else {
    }
    i = (u8 )((int )i + 1);
    ldv_54525: ;
    if ((int )RTW_ChannelPlan5G[(int )Index5G].Len > (int )i) {
      goto ldv_54524;
    } else {
    }
  } else {
  }
  return (ch_size);
}
}
int init_mlme_ext_priv23a(struct rtw_adapter *padapter )
{
  int res ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  res = 1;
  pregistrypriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmeext->padapter = padapter;
  init_mlme_ext_priv23a_value(padapter);
  pmlmeinfo->bAcceptAddbaReq = pregistrypriv->bAcceptAddbaReq;
  init_mlme_ext_timer23a(padapter);
  init_mlme_ap_info23a(padapter);
  pmlmeext->max_chan_nums = init_channel_set(padapter, (int )pmlmepriv->ChannelPlan,
                                             (struct rt_channel_info *)(& pmlmeext->channel_set));
  init_channel_list(padapter, (struct rt_channel_info *)(& pmlmeext->channel_set),
                    (int )pmlmeext->max_chan_nums, & pmlmeext->channel_list);
  pmlmeext->chan_scan_time = 100U;
  pmlmeext->mlmeext_init = 1U;
  pmlmeext->active_keep_alive_check = 1U;
  return (res);
}
}
void free_mlme_ext_priv23a(struct mlme_ext_priv *pmlmeext )
{
  struct rtw_adapter *padapter ;
  {
  padapter = pmlmeext->padapter;
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {
  }
  if (padapter->bDriverStopped == 1) {
    ldv_del_timer_sync_533(& pmlmeext->survey_timer);
    ldv_del_timer_sync_534(& pmlmeext->link_timer);
  } else {
  }
  return;
}
}
static void _mgt_dispatcher23a(struct rtw_adapter *padapter , struct mlme_handler *ptable ,
                               struct recv_frame *precv_frame )
{
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  if ((unsigned long )ptable->func != (unsigned long )((int (*)(struct rtw_adapter * ,
                                                                struct recv_frame * ))0)) {
    tmp = myid(& padapter->eeprompriv);
    tmp___0 = ether_addr_equal((u8 const *)(& hdr->addr1), (u8 const *)tmp);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      tmp___2 = is_broadcast_ether_addr((u8 const *)(& hdr->addr1));
      if (tmp___2) {
        tmp___3 = 0;
      } else {
        tmp___3 = 1;
      }
      if (tmp___3) {
        return;
      } else {
      }
    } else {
    }
    (*(ptable->func))(padapter, precv_frame);
  } else {
  }
  return;
}
}
void mgt_dispatcher23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct mlme_handler *ptable ;
  struct mlme_priv *pmlmepriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct sta_info *psta ;
  u16 stype ;
  int index ;
  int tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  tmp = ieee80211_is_mgmt((int )mgmt->frame_control);
  if (tmp == 0) {
    return;
  } else {
  }
  tmp___0 = myid(& padapter->eeprompriv);
  tmp___1 = ether_addr_equal((u8 const *)(& mgmt->da), (u8 const *)tmp___0);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    tmp___3 = is_broadcast_ether_addr((u8 const *)(& mgmt->da));
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      return;
    } else {
    }
  } else {
  }
  ptable = (struct mlme_handler *)(& mlme_sta_tbl);
  stype = (unsigned int )mgmt->frame_control & 240U;
  index = (int )stype >> 4;
  if (index > 13) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016Currently we do not support reserved sub-fr-type =%d\n", index);
    } else {
    }
    return;
  } else {
  }
  ptable = ptable + (unsigned long )index;
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& mgmt->sa));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    tmp___5 = ieee80211_has_retry((int )mgmt->frame_control);
    if (tmp___5 != 0) {
      if ((int )precv_frame->attrib.seq_num == (int )psta->RxMgmtFrameSeqNum) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: Drop duplicate management frame with seq_num = %d.\n",
                 (int )precv_frame->attrib.seq_num);
        } else {
        }
        return;
      } else {
      }
    } else {
    }
    psta->RxMgmtFrameSeqNum = precv_frame->attrib.seq_num;
  } else {
  }
  switch ((int )stype) {
  case 176:
  tmp___6 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___6) {
    ptable->func = & OnAuth23a;
  } else {
    ptable->func = & OnAuth23aClient23a;
  }
  case 0: ;
  case 32:
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
  goto ldv_54560;
  case 64:
  tmp___7 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___7) {
    _mgt_dispatcher23a(padapter, ptable, precv_frame);
  } else {
    _mgt_dispatcher23a(padapter, ptable, precv_frame);
  }
  goto ldv_54560;
  case 128:
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
  goto ldv_54560;
  case 208:
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
  goto ldv_54560;
  default:
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
  goto ldv_54560;
  }
  ldv_54560: ;
  return;
}
}
static int OnProbeReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  u8 const *ie ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  int len ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur = & pmlmeinfo->network;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  len = (int )skb->len;
  tmp = check_fwstate(pmlmepriv, 8);
  if ((int )tmp) {
    return (1);
  } else {
  }
  tmp___0 = check_fwstate(pmlmepriv, 1);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    tmp___2 = check_fwstate(pmlmepriv, 80);
    if (tmp___2) {
      tmp___3 = 0;
    } else {
      tmp___3 = 1;
    }
    if (tmp___3) {
      return (1);
    } else {
    }
  } else {
  }
  tmp___4 = ieee80211_is_probe_req((int )mgmt->frame_control);
  tmp___5 = ldv__builtin_expect(tmp___4 == 0, 0L);
  if (tmp___5 != 0L) {
    printk("\f%s: Received non probe request frame\n", "OnProbeReq23a");
    return (0);
  } else {
  }
  len = (int )((unsigned int )len - 24U);
  ie = cfg80211_find_ie(0, (u8 const *)(& mgmt->u.probe_req.variable), len);
  if ((unsigned long )ie == (unsigned long )((u8 const *)0U)) {
    goto out;
  } else {
  }
  if ((unsigned int )((unsigned char )*(ie + 1UL)) != 0U) {
    tmp___6 = memcmp((void const *)ie + 2U, (void const *)(& cur->Ssid.ssid),
                     (size_t )cur->Ssid.ssid_len);
    if (tmp___6 != 0) {
      return (1);
    } else {
      goto _L;
    }
  } else
  _L:
  if ((unsigned int )((unsigned char )*(ie + 1UL)) == 0U && (unsigned int )pmlmeinfo->hidden_ssid_mode != 0U) {
    return (1);
  } else {
  }
  tmp___7 = check_fwstate(pmlmepriv, 1);
  if ((int )tmp___7 && pmlmepriv->cur_network.join_res != 0) {
    issue_probersp(padapter, (unsigned char *)(& mgmt->sa), 0);
  } else {
  }
  out: ;
  return (1);
}
}
static int OnProbeRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct mlme_ext_priv *pmlmeext ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  if (pmlmeext->sitesurvey_res.state == 3) {
    report_survey_event23a(padapter, precv_frame);
    return (1);
  } else {
  }
  return (1);
}
}
static int OnBeacon23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  int cam_idx ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *pframe ;
  int pkt_len ;
  struct wlan_bssid_ex *pbss ;
  int ret ;
  u8 *p ;
  u8 *pie ;
  int pie_len ;
  u32 ielen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  pframe = skb->data;
  pkt_len = (int )skb->len;
  ret = 1;
  ielen = 0U;
  pie = (u8 *)(& mgmt->u.beacon.variable);
  pie_len = (int )((unsigned int )pkt_len - 36U);
  p = rtw_get_ie23a(pie, 50, (int *)(& ielen), pie_len);
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ielen != 0U) {
    if ((unsigned int )*(p + (unsigned long )(ielen + 1U)) == 45U && (unsigned int )*(p + (unsigned long )(ielen + 2U)) != 45U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: [WIFIDBG] Error in ESR IE is detected in Beacon of BSSID: %pM. Fix the length of ESR IE to avoid failed Beacon parsing.\n",
               (u8 *)(& mgmt->bssid));
      } else {
      }
      *(p + 1UL) = (unsigned int )((u8 )ielen) - 1U;
    } else {
    }
  } else {
  }
  if (pmlmeext->sitesurvey_res.state == 3) {
    report_survey_event23a(padapter, precv_frame);
    return (1);
  } else {
  }
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  tmp___0 = ether_addr_equal((u8 const *)(& mgmt->bssid), (u8 const *)tmp);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto out;
  } else {
  }
  if ((pmlmeinfo->state & 256U) != 0U) {
    tmp___2 = kmalloc(863UL, 32U);
    pbss = (struct wlan_bssid_ex *)tmp___2;
    if ((unsigned long )pbss != (unsigned long )((struct wlan_bssid_ex *)0)) {
      tmp___3 = collect_bss_info23a(padapter, precv_frame, pbss);
      if (tmp___3 == 1) {
        update_network23a(& pmlmepriv->cur_network.network, pbss, padapter, 1);
        rtw_get_bcn_info23a(& pmlmepriv->cur_network);
      } else {
      }
      kfree((void const *)pbss);
    } else {
    }
    pmlmeinfo->assoc_AP_vendor = check_assoc_AP23a((u8 *)(& mgmt->u.beacon), (uint )pkt_len - 24U);
    rtw_update_TSF(pmlmeext, mgmt);
    start_clnt_auth(padapter);
    return (1);
  } else {
  }
  if ((pmlmeinfo->state & 3U) == 2U && (pmlmeinfo->state & 16384U) != 0U) {
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& mgmt->sa));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      ret = rtw_check_bcn_info23a(padapter, mgmt, (u32 )pkt_len);
      if (ret == 0) {
        if (GlobalDebugLevel23A != 0U) {
          printk("\016RTL8723AU: OLD_ERROR ap has changed, disconnect now\n");
        } else {
        }
        receive_disconnect23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress),
                              65535);
        return (1);
      } else {
      }
      if ((((psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) & 15ULL) == 0ULL) {
        update_beacon23a_info(padapter, pframe, (uint )pkt_len, psta);
      } else {
      }
    } else {
    }
  } else
  if ((pmlmeinfo->state & 3U) == 1U) {
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& mgmt->sa));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      if ((((psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) & 15ULL) == 0ULL) {
        update_beacon23a_info(padapter, pframe, (uint )pkt_len, psta);
      } else {
      }
    } else {
      cam_idx = allocate_fw_sta_entry23a(padapter);
      if (cam_idx == 32) {
        goto out;
      } else {
      }
      tmp___4 = update_sta_support_rate23a(padapter, pie, (uint )pie_len, cam_idx);
      if (tmp___4 == 0) {
        pmlmeinfo->FW_sta_info[cam_idx].status = 0U;
        goto out;
      } else {
      }
      rtw_update_TSF(pmlmeext, mgmt);
      report_add_sta_event23a(padapter, (unsigned char *)(& mgmt->sa), cam_idx);
    }
  } else {
  }
  out: ;
  return (1);
}
}
static int OnAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct sta_info stat ;
  struct sta_info *pstat ;
  struct sta_priv *pstapriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *pframe ;
  u8 const *p ;
  unsigned char *sa ;
  u16 auth_mode ;
  u16 seq ;
  u16 algorithm ;
  int status ;
  int len ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __len ;
  void *__ret ;
  {
  pstat = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  len = (int )skb->len;
  if ((pmlmeinfo->state & 3U) != 3U) {
    return (0);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +OnAuth23a\n");
  } else {
  }
  sa = (unsigned char *)(& mgmt->sa);
  auth_mode = (u16 )psecuritypriv->dot11AuthAlgrthm;
  pframe = (u8 *)(& mgmt->u.auth.variable);
  len = (int )(skb->len - 30U);
  seq = mgmt->u.auth.auth_transaction;
  algorithm = mgmt->u.auth.auth_alg;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: auth alg =%x, seq =%X\n", (int )algorithm, (int )seq);
  } else {
  }
  if (((unsigned int )auth_mode == 2U && psecuritypriv->dot11PrivacyAlgrthm != 1027073U) && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
    auth_mode = 0U;
  } else {
  }
  if (((unsigned int )algorithm != 0U && (unsigned int )auth_mode == 0U) || ((unsigned int )algorithm == 0U && (unsigned int )auth_mode == 1U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: auth rejected due to bad alg [alg =%d, auth_mib =%d] %02X%02X%02X%02X%02X%02X\n",
             (int )algorithm, (int )auth_mode, (int )*sa, (int )*(sa + 1UL), (int )*(sa + 2UL),
             (int )*(sa + 3UL), (int )*(sa + 4UL), (int )*(sa + 5UL));
    } else {
    }
    status = 13;
    goto auth_fail;
  } else {
  }
  tmp = rtw_access_ctrl23a(padapter, sa);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    status = 17;
    goto auth_fail;
  } else {
  }
  pstat = rtw_get_stainfo23a(pstapriv, (u8 const *)sa);
  if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: going to alloc stainfo for sa =%02x:%02x:%02x:%02x:%02x:%02x\n",
             (int )*sa, (int )*(sa + 1UL), (int )*(sa + 2UL), (int )*(sa + 3UL), (int )*(sa + 4UL),
             (int )*(sa + 5UL));
    } else {
    }
    pstat = rtw_alloc_stainfo23a(pstapriv, sa, 32U);
    if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU:  Exceed the upper limit of supported clients...\n");
      } else {
      }
      status = 17;
      goto auth_fail;
    } else {
    }
    pstat->state = 256U;
    pstat->auth_seq = 0U;
  } else {
    spin_lock_bh(& pstapriv->asoc_list_lock);
    tmp___1 = list_empty((struct list_head const *)(& pstat->asoc_list));
    if (tmp___1 == 0) {
      list_del_init(& pstat->asoc_list);
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
    } else {
    }
    spin_unlock_bh(& pstapriv->asoc_list_lock);
  }
  spin_lock_bh(& pstapriv->auth_list_lock);
  tmp___2 = list_empty((struct list_head const *)(& pstat->auth_list));
  if (tmp___2 != 0) {
    list_add_tail(& pstat->auth_list, & pstapriv->auth_list);
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt + 1);
  } else {
  }
  spin_unlock_bh(& pstapriv->auth_list_lock);
  if (pstat->auth_seq == 0U) {
    pstat->expire_to = pstapriv->auth_to;
  } else {
  }
  if (pstat->auth_seq + 1U != (unsigned int )seq) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: (1)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
             (int )seq, pstat->auth_seq + 1U);
    } else {
    }
    status = 14;
    goto auth_fail;
  } else {
  }
  if ((unsigned int )algorithm == 0U && ((unsigned int )auth_mode == 0U || (unsigned int )auth_mode == 2U)) {
    if ((unsigned int )seq == 1U) {
      pstat->state = pstat->state & 4294967039U;
      pstat->state = pstat->state | 1024U;
      pstat->expire_to = pstapriv->assoc_to;
      pstat->authalg = (unsigned int )algorithm;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: (2)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
               (int )seq, pstat->auth_seq + 1U);
      } else {
      }
      status = 14;
      goto auth_fail;
    }
  } else
  if ((unsigned int )seq == 1U) {
    pstat->state = pstat->state & 4294967039U;
    pstat->state = pstat->state | 512U;
    pstat->authalg = (unsigned int )algorithm;
    pstat->auth_seq = 2U;
  } else
  if ((unsigned int )seq == 3U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: checking for challenging txt...\n");
    } else {
    }
    p = cfg80211_find_ie(16, (u8 const *)pframe, len);
    if ((unsigned long )p == (unsigned long )((u8 const *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: auth rejected because challenge failure!(1)\n");
      } else {
      }
      status = 15;
      goto auth_fail;
    } else {
    }
    tmp___3 = memcmp((void const *)p + 2U, (void const *)(& pstat->chg_txt), 128UL);
    if (tmp___3 == 0) {
      pstat->state = pstat->state & 4294966783U;
      pstat->state = pstat->state | 1024U;
      pstat->expire_to = pstapriv->assoc_to;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: auth rejected because challenge failure!\n");
      } else {
      }
      status = 15;
      goto auth_fail;
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: (3)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
             (int )seq, pstat->auth_seq + 1U);
    } else {
    }
    status = 14;
    goto auth_fail;
  }
  pstat->auth_seq = (unsigned int )((int )seq + 1);
  issue_auth(padapter, pstat, 0);
  if ((pstat->state & 1024U) != 0U) {
    pstat->auth_seq = 0U;
  } else {
  }
  return (1);
  auth_fail: ;
  if ((unsigned long )pstat != (unsigned long )((struct sta_info *)0)) {
    rtw_free_stainfo23a(padapter, pstat);
  } else {
  }
  pstat = & stat;
  memset((void *)pstat, 0, 5656UL);
  pstat->auth_seq = 2U;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pstat->hwaddr), (void const *)sa, __len);
  } else {
    __ret = memcpy((void *)(& pstat->hwaddr), (void const *)sa, __len);
  }
  issue_auth(padapter, pstat, (int )((unsigned short )status));
  return (0);
}
}
static int OnAuth23aClient23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  unsigned int seq ;
  unsigned int status ;
  unsigned int algthm ;
  unsigned int go2asoc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 const *p ;
  u8 *pie ;
  int plen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  size_t __len ;
  void *__ret ;
  unsigned long tmp___3 ;
  {
  go2asoc = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  plen = (int )skb->len;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAuth23aClient23a");
  } else {
  }
  tmp = myid(& padapter->eeprompriv);
  tmp___0 = ether_addr_equal((u8 const *)tmp, (u8 const *)(& mgmt->da));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {
  }
  if ((pmlmeinfo->state & 512U) == 0U) {
    return (1);
  } else {
  }
  pie = (u8 *)(& mgmt->u.auth.variable);
  plen = (int )((unsigned int )plen - 30U);
  algthm = (unsigned int )mgmt->u.auth.auth_alg;
  seq = (unsigned int )mgmt->u.auth.auth_transaction;
  status = (unsigned int )mgmt->u.auth.status_code;
  if (status != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: clnt auth fail, status: %d\n", status);
    } else {
    }
    if (status == 13U) {
      if (pmlmeinfo->auth_algo == 1U) {
        pmlmeinfo->auth_algo = 0U;
      } else {
        pmlmeinfo->auth_algo = 1U;
      }
    } else {
    }
    tmp___2 = msecs_to_jiffies(1U);
    ldv_mod_timer_535(& pmlmeext->link_timer, tmp___2 + (unsigned long )jiffies);
    goto authclnt_fail;
  } else {
  }
  if (seq == 2U) {
    if (pmlmeinfo->auth_algo == 1U) {
      p = cfg80211_find_ie(16, (u8 const *)pie, plen);
      if ((unsigned long )p == (unsigned long )((u8 const *)0U)) {
        goto authclnt_fail;
      } else {
      }
      __len = (size_t )*(p + 1UL);
      __ret = memcpy((void *)(& pmlmeinfo->chg_txt), (void const *)p + 2U,
                               __len);
      pmlmeinfo->auth_seq = 3U;
      issue_auth(padapter, (struct sta_info *)0, 0);
      tmp___3 = msecs_to_jiffies(300U);
      ldv_mod_timer_536(& pmlmeext->link_timer, tmp___3 + (unsigned long )jiffies);
      return (1);
    } else {
      go2asoc = 1U;
    }
  } else
  if (seq == 4U) {
    if (pmlmeinfo->auth_algo == 1U) {
      go2asoc = 1U;
    } else {
      goto authclnt_fail;
    }
  } else {
    goto authclnt_fail;
  }
  if (go2asoc != 0U) {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: OLD_ERROR auth success, start assoc\n");
    } else {
    }
    start_clnt_assoc(padapter);
    return (1);
  } else {
  }
  authclnt_fail: ;
  return (0);
}
}
static int rtw_validate_vendor_specific_ies(u8 const *pos , int elen )
{
  unsigned int oui ;
  {
  if (elen <= 3) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: short vendor specific information element ignored (len =%i)\n",
             elen);
    } else {
    }
    return (-22);
  } else {
  }
  oui = (((unsigned int )*pos << 16) | ((unsigned int )*(pos + 1UL) << 8)) | (unsigned int )*(pos + 2UL);
  switch (oui) {
  case 20722U: ;
  switch ((int )*(pos + 3UL)) {
  case 1: ;
  goto ldv_54656;
  case 2: ;
  if (elen <= 4) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: short WME information element ignored (len =%i)\n", elen);
    } else {
    }
    return (-22);
  } else {
  }
  switch ((int )*(pos + 4UL)) {
  case 0: ;
  case 1: ;
  goto ldv_54660;
  case 2: ;
  goto ldv_54660;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: unknown WME information element ignored (subtype =%d len =%i)\n",
           (int )*(pos + 4UL), elen);
  } else {
  }
  return (-22);
  }
  ldv_54660: ;
  goto ldv_54656;
  case 4: ;
  goto ldv_54656;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Unknown Microsoft information element ignored (type =%d len =%i)\n",
           (int )*(pos + 3UL), elen);
  } else {
  }
  return (-22);
  }
  ldv_54656: ;
  goto ldv_54665;
  case 36940U: ;
  switch ((int )*(pos + 3UL)) {
  case 51: ;
  goto ldv_54668;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Unknown Broadcom information element ignored (type =%d len =%i)\n",
           (int )*(pos + 3UL), elen);
  } else {
  }
  return (-22);
  }
  ldv_54668: ;
  goto ldv_54665;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: unknown vendor specific information element ignored (vendor OUI %02x:%02x:%02x len =%i)\n",
           (int )*pos, (int )*(pos + 1UL), (int )*(pos + 2UL), elen);
  } else {
  }
  return (-22);
  }
  ldv_54665: ;
  return (0);
}
}
static int rtw_validate_frame_ies(u8 const *start , uint len )
{
  u8 const *pos ;
  int left ;
  int unknown ;
  u8 id ;
  u8 elen ;
  u8 const *tmp ;
  u8 const *tmp___0 ;
  int tmp___1 ;
  {
  pos = start;
  left = (int )len;
  unknown = 0;
  goto ldv_54703;
  ldv_54702:
  tmp = pos;
  pos = pos + 1;
  id = *tmp;
  tmp___0 = pos;
  pos = pos + 1;
  elen = *tmp___0;
  left = left + -2;
  if ((int )elen > left) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: IEEE 802.11 failed (id =%d elen =%d left =%i)\n",
             "rtw_validate_frame_ies", (int )id, (int )elen, left);
    } else {
    }
    return (-22);
  } else {
  }
  switch ((int )id) {
  case 0: ;
  case 1: ;
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 16: ;
  case 42: ;
  case 50: ;
  case 221:
  tmp___1 = rtw_validate_vendor_specific_ies(pos, (int )elen);
  if (tmp___1 != 0) {
    unknown = unknown + 1;
  } else {
  }
  goto ldv_54692;
  case 48: ;
  case 33: ;
  case 36: ;
  case 54: ;
  case 55: ;
  case 56: ;
  case 45: ;
  case 61: ;
  default:
  unknown = unknown + 1;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s IEEE 802.11 ignored unknown element (id =%d elen =%d)\n",
           "rtw_validate_frame_ies", (int )id, (int )elen);
  } else {
  }
  goto ldv_54692;
  }
  ldv_54692:
  left = left - (int )elen;
  pos = pos + (unsigned long )elen;
  ldv_54703: ;
  if (left > 1) {
    goto ldv_54702;
  } else {
  }
  if (left != 0) {
    return (-22);
  } else {
  }
  return (0);
}
}
static int OnAssocReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  u16 capab_info ;
  u16 listen_interval ;
  struct sta_info *pstat ;
  unsigned char reassoc ;
  unsigned char WMM_IE[6U] ;
  int i ;
  int wpa_ie_len ;
  int left ;
  unsigned char supportRate[16U] ;
  int supportRateNum ;
  unsigned short status ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 const *pos ;
  u8 const *p ;
  u8 const *wpa_ie ;
  u8 const *wps_ie ;
  u8 *pframe ;
  uint pkt_len ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  int group_cipher ;
  int pairwise_cipher ;
  u8 selected_registrar ;
  int copy_len ;
  size_t __len___2 ;
  void *__ret___2 ;
  u8 const *end ;
  int tmp___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  {
  WMM_IE[0] = 0U;
  WMM_IE[1] = 80U;
  WMM_IE[2] = 242U;
  WMM_IE[3] = 2U;
  WMM_IE[4] = 0U;
  WMM_IE[5] = 1U;
  status = 0U;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur = & pmlmeinfo->network;
  pstapriv = & padapter->stapriv;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  pframe = skb->data;
  pkt_len = skb->len;
  if ((pmlmeinfo->state & 3U) != 3U) {
    return (0);
  } else {
  }
  left = (int )(pkt_len - 24U);
  tmp = ieee80211_is_assoc_req((int )mgmt->frame_control);
  if (tmp != 0) {
    reassoc = 0U;
    pos = (u8 const *)(& mgmt->u.assoc_req.variable);
    left = (int )((unsigned int )left - 28U);
  } else {
    reassoc = 1U;
    pos = (u8 const *)(& mgmt->u.reassoc_req.variable);
    left = (int )((unsigned int )left - 34U);
  }
  if (left < 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: handle_assoc(reassoc =%d) - too short payload (len =%lu)\n",
             (int )reassoc, (unsigned long )pkt_len);
    } else {
    }
    return (0);
  } else {
  }
  pstat = rtw_get_stainfo23a(pstapriv, (u8 const *)(& mgmt->sa));
  if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
    status = 6U;
    goto asoc_class2_error;
  } else {
  }
  capab_info = get_unaligned_le16((void const *)(& mgmt->u.assoc_req.capab_info));
  listen_interval = get_unaligned_le16((void const *)(& mgmt->u.assoc_req.listen_interval));
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAssocReq23a");
  } else {
  }
  if ((pstat->state & 1024U) == 0U) {
    if ((pstat->state & 16384U) == 0U) {
      status = 6U;
      goto asoc_class2_error;
    } else {
      pstat->state = pstat->state & 4294950911U;
      pstat->state = pstat->state | 8192U;
    }
  } else {
    pstat->state = pstat->state & 4294966271U;
    pstat->state = pstat->state | 8192U;
  }
  pstat->capability = capab_info;
  tmp___0 = rtw_validate_frame_ies(pos, (uint )left);
  if (tmp___0 != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: STA %02x:%02x:%02x:%02x:%02x:%02x sent invalid association request\n",
             (int )*((u8 *)(& pstat->hwaddr)), (int )*((u8 *)(& pstat->hwaddr) + 1UL),
             (int )*((u8 *)(& pstat->hwaddr) + 2UL), (int )*((u8 *)(& pstat->hwaddr) + 3UL),
             (int )*((u8 *)(& pstat->hwaddr) + 4UL), (int )*((u8 *)(& pstat->hwaddr) + 5UL));
    } else {
    }
    status = 1U;
    goto OnAssocReq23aFail;
  } else {
  }
  p = cfg80211_find_ie(0, pos, left);
  if ((unsigned long )p == (unsigned long )((u8 const *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: STA %02x:%02x:%02x:%02x:%02x:%02x sent invalid association request lacking an SSID\n",
             (int )*((u8 *)(& pstat->hwaddr)), (int )*((u8 *)(& pstat->hwaddr) + 1UL),
             (int )*((u8 *)(& pstat->hwaddr) + 2UL), (int )*((u8 *)(& pstat->hwaddr) + 3UL),
             (int )*((u8 *)(& pstat->hwaddr) + 4UL), (int )*((u8 *)(& pstat->hwaddr) + 5UL));
    } else {
    }
    status = 1U;
    goto OnAssocReq23aFail;
  } else {
    tmp___1 = memcmp((void const *)p + 2U, (void const *)(& cur->Ssid.ssid), (size_t )cur->Ssid.ssid_len);
    if (tmp___1 != 0) {
      status = 1U;
    } else {
    }
    if ((int )((unsigned char )*(p + 1UL)) != (int )cur->Ssid.ssid_len) {
      status = 1U;
    } else {
    }
  }
  if ((unsigned int )status != 0U) {
    goto OnAssocReq23aFail;
  } else {
  }
  p = cfg80211_find_ie(1, pos, left);
  if ((unsigned long )p == (unsigned long )((u8 const *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Rx a sta assoc-req which supported rate is empty!\n");
    } else {
    }
    status = 1U;
    goto OnAssocReq23aFail;
  } else {
    __len = (size_t )*(p + 1UL);
    __ret = memcpy((void *)(& supportRate), (void const *)p + 2U, __len);
    supportRateNum = (int )*(p + 1UL);
    p = cfg80211_find_ie(50, pos, left);
    if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
      if ((unsigned int )supportRateNum <= 16U) {
        __len___0 = (size_t )*(p + 1UL);
        __ret___0 = memcpy((void *)(& supportRate) + (unsigned long )supportRateNum,
                                     (void const *)p + 2U, __len___0);
        supportRateNum = (int )*(p + 1UL) + supportRateNum;
      } else {
      }
    } else {
    }
  }
  pstat->bssratelen = (u32 )supportRateNum;
  __len___1 = (size_t )supportRateNum;
  __ret___1 = memcpy((void *)(& pstat->bssrateset), (void const *)(& supportRate),
                               __len___1);
  Update23aTblForSoftAP((u8 *)(& pstat->bssrateset), pstat->bssratelen);
  pstat->dot8021xalg = 0;
  pstat->wpa_psk = 0;
  pstat->wpa_group_cipher = 0;
  pstat->wpa2_group_cipher = 0;
  pstat->wpa_pairwise_cipher = 0;
  pstat->wpa2_pairwise_cipher = 0;
  memset((void *)(& pstat->wpa_ie), 0, 32UL);
  wpa_ie = cfg80211_find_ie(48, pos, left);
  if ((unsigned long )wpa_ie == (unsigned long )((u8 const *)0U)) {
    wpa_ie = cfg80211_find_vendor_ie(20722U, 1, pos, left);
  } else {
  }
  if ((unsigned long )wpa_ie != (unsigned long )((u8 const *)0U)) {
    group_cipher = 0;
    pairwise_cipher = 0;
    wpa_ie_len = (int )*(wpa_ie + 1UL);
    if (((unsigned long )psecuritypriv->wpa_psk & 2UL) != 0UL) {
      r = rtw_parse_wpa2_ie23a(wpa_ie, wpa_ie_len + 2, & group_cipher, & pairwise_cipher,
                               (int *)0);
      if (r == 1) {
        pstat->dot8021xalg = 1;
        pstat->wpa_psk = pstat->wpa_psk | 2;
        pstat->wpa2_group_cipher = (int )(psecuritypriv->wpa2_group_cipher & (unsigned int )group_cipher);
        pstat->wpa2_pairwise_cipher = (int )(psecuritypriv->wpa2_pairwise_cipher & (unsigned int )pairwise_cipher);
      } else {
        status = 40U;
      }
    } else
    if ((int )psecuritypriv->wpa_psk & 1) {
      r = rtw_parse_wpa_ie23a(wpa_ie, wpa_ie_len + 2, & group_cipher, & pairwise_cipher,
                              (int *)0);
      if (r == 1) {
        pstat->dot8021xalg = 1;
        pstat->wpa_psk = pstat->wpa_psk | 1;
        pstat->wpa_group_cipher = (int )(psecuritypriv->wpa_group_cipher & (unsigned int )group_cipher);
        pstat->wpa_pairwise_cipher = (int )(psecuritypriv->wpa_pairwise_cipher & (unsigned int )pairwise_cipher);
      } else {
        status = 40U;
      }
    } else {
      wpa_ie = (u8 const *)0U;
      wpa_ie_len = 0;
    }
    if ((unsigned long )wpa_ie != (unsigned long )((u8 const *)0U) && (unsigned int )status == 0U) {
      if (pstat->wpa_group_cipher == 0) {
        status = 41U;
      } else {
      }
      if (pstat->wpa_pairwise_cipher == 0) {
        status = 42U;
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )status != 0U) {
    goto OnAssocReq23aFail;
  } else {
  }
  pstat->flags = pstat->flags & -12289;
  wps_ie = cfg80211_find_vendor_ie(20722U, 4, pos, left);
  if ((unsigned long )wpa_ie == (unsigned long )((u8 const *)0U)) {
    if ((unsigned long )wps_ie != (unsigned long )((u8 const *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: STA included WPS IE in (Re)Association Request - assume WPS is used\n");
      } else {
      }
      pstat->flags = pstat->flags | 4096;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: STA did not include WPA/RSN IE in (Re)Association Request - possible WPS use\n");
      } else {
      }
      pstat->flags = pstat->flags | 8192;
    }
    if (psecuritypriv->wpa_psk != 0U && ((unsigned long )pstat->flags & 12288UL) != 0UL) {
      if ((unsigned long )pmlmepriv->wps_beacon_ie != (unsigned long )((u8 *)0U)) {
        selected_registrar = 0U;
        rtw_get_wps_attr_content23a(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len,
                                    4161, & selected_registrar, (uint *)0U);
        if ((unsigned int )selected_registrar == 0U) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: selected_registrar is false,or AP is not ready to do WPS\n");
          } else {
          }
          status = 17U;
          goto OnAssocReq23aFail;
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
    if (psecuritypriv->wpa_psk == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: STA %02x:%02x:%02x:%02x:%02x:%02x: WPA/RSN IE in association request, but AP don\'t support WPA/RSN\n",
               (int )*((u8 *)(& pstat->hwaddr)), (int )*((u8 *)(& pstat->hwaddr) + 1UL),
               (int )*((u8 *)(& pstat->hwaddr) + 2UL), (int )*((u8 *)(& pstat->hwaddr) + 3UL),
               (int )*((u8 *)(& pstat->hwaddr) + 4UL), (int )*((u8 *)(& pstat->hwaddr) + 5UL));
      } else {
      }
      status = 40U;
      goto OnAssocReq23aFail;
    } else {
    }
    if ((unsigned long )wps_ie != (unsigned long )((u8 const *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: STA included WPS IE in (Re)Association Request - WPS is used\n");
      } else {
      }
      pstat->flags = pstat->flags | 4096;
      copy_len = 0;
    } else {
      copy_len = (int )(32U < (unsigned int )(wpa_ie_len + 2) ? 32U : (unsigned int )(wpa_ie_len + 2));
    }
    if (copy_len > 0) {
      __len___2 = (size_t )copy_len;
      __ret___2 = memcpy((void *)(& pstat->wpa_ie), (void const *)wpa_ie + 0xfffffffffffffffeUL,
                                   __len___2);
    } else {
    }
  }
  pstat->flags = pstat->flags & -513;
  pstat->qos_option = 0U;
  pstat->qos_info = 0U;
  pstat->has_legacy_ac = 1U;
  pstat->uapsd_vo = 0U;
  pstat->uapsd_vi = 0U;
  pstat->uapsd_be = 0U;
  pstat->uapsd_bk = 0U;
  if (pmlmepriv->qos_option != 0U) {
    end = pos + (unsigned long )left;
    p = pos;
    ldv_54756:
    left = (int )((unsigned int )((long )end) - (unsigned int )((long )p));
    p = cfg80211_find_ie(221, p, left);
    if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
      tmp___2 = memcmp((void const *)p + 2U, (void const *)(& WMM_IE), 6UL);
      if (tmp___2 == 0) {
        pstat->flags = pstat->flags | 512;
        pstat->qos_option = 1U;
        pstat->qos_info = *(p + 8UL);
        pstat->max_sp_len = (unsigned int )((u8 )((int )pstat->qos_info >> 5)) & 3U;
        if (((int )pstat->qos_info & 15) != 15) {
          pstat->has_legacy_ac = 1U;
        } else {
          pstat->has_legacy_ac = 0U;
        }
        if (((int )pstat->qos_info & 15) != 0) {
          if ((int )pstat->qos_info & 1) {
            pstat->uapsd_vo = 3U;
          } else {
            pstat->uapsd_vo = 0U;
          }
          if (((unsigned long )pstat->qos_info & 2UL) != 0UL) {
            pstat->uapsd_vi = 3U;
          } else {
            pstat->uapsd_vi = 0U;
          }
          if (((unsigned long )pstat->qos_info & 4UL) != 0UL) {
            pstat->uapsd_bk = 3U;
          } else {
            pstat->uapsd_bk = 0U;
          }
          if (((unsigned long )pstat->qos_info & 8UL) != 0UL) {
            pstat->uapsd_be = 3U;
          } else {
            pstat->uapsd_be = 0U;
          }
        } else {
        }
        goto ldv_54755;
      } else {
      }
    } else {
      goto ldv_54755;
    }
    p = p + ((unsigned long )*(p + 1UL) + 2UL);
    goto ldv_54756;
    ldv_54755: ;
  } else {
  }
  memset((void *)(& pstat->htpriv.ht_cap), 0, 26UL);
  p = cfg80211_find_ie(45, pos, left);
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) > 25U) {
    pstat->flags = pstat->flags | 2048;
    pstat->flags = pstat->flags | 512;
    __len___3 = 26UL;
    if (__len___3 > 63UL) {
      __ret___3 = memcpy((void *)(& pstat->htpriv.ht_cap), (void const *)p + 2U,
                           __len___3);
    } else {
      __ret___3 = memcpy((void *)(& pstat->htpriv.ht_cap), (void const *)p + 2U,
                                   __len___3);
    }
  } else {
    pstat->flags = pstat->flags & -2049;
  }
  if (pmlmepriv->htpriv.ht_option == 0U && ((unsigned long )pstat->flags & 2048UL) != 0UL) {
    status = 1U;
    goto OnAssocReq23aFail;
  } else {
  }
  if (((unsigned long )pstat->flags & 2048UL) != 0UL && (((unsigned long )pstat->wpa2_pairwise_cipher & 8UL) != 0UL || ((unsigned long )pstat->wpa_pairwise_cipher & 8UL) != 0UL)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: HT: %02x:%02x:%02x:%02x:%02x:%02x tried to use TKIP with HT association\n",
             (int )*((u8 *)(& pstat->hwaddr)), (int )*((u8 *)(& pstat->hwaddr) + 1UL),
             (int )*((u8 *)(& pstat->hwaddr) + 2UL), (int )*((u8 *)(& pstat->hwaddr) + 3UL),
             (int )*((u8 *)(& pstat->hwaddr) + 4UL), (int )*((u8 *)(& pstat->hwaddr) + 5UL));
    } else {
    }
  } else {
  }
  pstat->flags = (int )((unsigned int )pstat->flags | 2147483648U);
  i = 0;
  goto ldv_54762;
  ldv_54761: ;
  if (((int )pstat->bssrateset[i] & 127) > 22) {
    pstat->flags = pstat->flags & 2147483647;
    goto ldv_54760;
  } else {
  }
  i = i + 1;
  ldv_54762: ;
  if ((u32 )i < pstat->bssratelen) {
    goto ldv_54761;
  } else {
  }
  ldv_54760: ;
  if (((int )pstat->capability & 32) != 0) {
    pstat->flags = pstat->flags | 128;
  } else {
    pstat->flags = pstat->flags & -129;
  }
  if ((unsigned int )status != 0U) {
    goto OnAssocReq23aFail;
  } else {
  }
  if (pstat->aid != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU:   old AID %d\n", pstat->aid);
    } else {
    }
  } else {
    pstat->aid = 1U;
    goto ldv_54765;
    ldv_54764: ;
    if ((unsigned long )pstapriv->sta_aid[pstat->aid - 1U] == (unsigned long )((struct sta_info *)0)) {
      goto ldv_54763;
    } else {
    }
    pstat->aid = pstat->aid + 1U;
    ldv_54765: ;
    if (pstat->aid <= 32U) {
      goto ldv_54764;
    } else {
    }
    ldv_54763: ;
    if (pstat->aid > 32U) {
      pstat->aid = 32U;
    } else {
    }
    if (pstat->aid > (uint )pstapriv->max_num_sta) {
      pstat->aid = 0U;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU:   no room for more AIDs\n");
      } else {
      }
      status = 17U;
      goto OnAssocReq23aFail;
    } else {
      pstapriv->sta_aid[pstat->aid - 1U] = pstat;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: allocate new AID = (%d)\n", pstat->aid);
      } else {
      }
    }
  }
  pstat->state = pstat->state & 4294959103U;
  pstat->state = pstat->state | 16384U;
  spin_lock_bh(& pstapriv->auth_list_lock);
  tmp___3 = list_empty((struct list_head const *)(& pstat->auth_list));
  if (tmp___3 == 0) {
    list_del_init(& pstat->auth_list);
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
  } else {
  }
  spin_unlock_bh(& pstapriv->auth_list_lock);
  spin_lock_bh(& pstapriv->asoc_list_lock);
  tmp___4 = list_empty((struct list_head const *)(& pstat->asoc_list));
  if (tmp___4 != 0) {
    pstat->expire_to = pstapriv->expire_to;
    list_add_tail(& pstat->asoc_list, & pstapriv->asoc_list);
    pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt + 1);
  } else {
  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  if (((unsigned long )pstat != (unsigned long )((struct sta_info *)0) && (pstat->state & 16384U) != 0U) && (unsigned int )status == 0U) {
    bss_cap_update_on_sta_join23a(padapter, pstat);
    sta_info_update23a(padapter, pstat);
    tmp___5 = ieee80211_is_assoc_req((int )mgmt->frame_control);
    if (tmp___5 != 0) {
      issue_assocrsp(padapter, (int )status, pstat, 16);
    } else {
      issue_assocrsp(padapter, (int )status, pstat, 48);
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: indicate_sta_join_event to upper layer - hostapd\n");
    } else {
    }
    rtw_cfg80211_indicate_sta_assoc(padapter, pframe, pkt_len);
    report_add_sta_event23a(padapter, (unsigned char *)(& pstat->hwaddr), (int )pstat->aid);
  } else {
  }
  return (1);
  asoc_class2_error:
  issue_deauth23a(padapter, (unsigned char *)(& mgmt->sa), (int )status);
  return (0);
  OnAssocReq23aFail:
  pstat->aid = 0U;
  tmp___6 = ieee80211_is_assoc_req((int )mgmt->frame_control);
  if (tmp___6 != 0) {
    issue_assocrsp(padapter, (int )status, pstat, 16);
  } else {
    issue_assocrsp(padapter, (int )status, pstat, 48);
  }
  return (0);
}
}
static int OnAssocRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *pmgmt ;
  int res ;
  int i ;
  unsigned short status ;
  u8 *p ;
  u8 *pframe ;
  int pkt_len ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u16 tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t __len ;
  void *__ret ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  pmgmt = (struct ieee80211_mgmt *)skb->data;
  pframe = skb->data;
  pkt_len = (int )skb->len;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAssocRsp23a");
  } else {
  }
  tmp = myid(& padapter->eeprompriv);
  tmp___0 = ether_addr_equal((u8 const *)tmp, (u8 const *)(& pmgmt->da));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {
  }
  if ((pmlmeinfo->state & 9216U) == 0U) {
    return (1);
  } else {
  }
  if ((pmlmeinfo->state & 16384U) != 0U) {
    return (1);
  } else {
  }
  ldv_del_timer_sync_537(& pmlmeext->link_timer);
  status = pmgmt->u.assoc_resp.status_code;
  if ((unsigned int )status != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: assoc reject, status code: %d\n", (int )status);
    } else {
    }
    pmlmeinfo->state = 0U;
    res = -4;
    goto report_assoc_result;
  } else {
  }
  pmlmeinfo->capability = pmgmt->u.assoc_resp.capab_info;
  pmlmeinfo->slotTime = ((unsigned long )pmlmeinfo->capability & 1024UL) != 0UL ? 9U : 20U;
  tmp___2 = (unsigned int )pmgmt->u.assoc_resp.aid & 16383U;
  pmlmeinfo->aid = tmp___2;
  res = (int )tmp___2;
  i = 30;
  goto ldv_54790;
  ldv_54789:
  p = pframe + (unsigned long )i;
  switch ((int )*p) {
  case 221:
  tmp___3 = memcmp((void const *)p + 2U, (void const *)(& WMM_PARA_OUI23A), 6UL);
  if (tmp___3 == 0) {
    WMM_param_handler23a(padapter, p);
  } else {
  }
  goto ldv_54784;
  case 45:
  HT_caps_handler23a(padapter, p);
  goto ldv_54784;
  case 61:
  HT_info_handler23a(padapter, p);
  goto ldv_54784;
  case 42:
  ERP_IE_handler23a(padapter, p);
  default: ;
  goto ldv_54784;
  }
  ldv_54784:
  i = ((int )*(p + 1UL) + 2) + i;
  ldv_54790: ;
  if (i < pkt_len) {
    goto ldv_54789;
  } else {
  }
  pmlmeinfo->state = pmlmeinfo->state & 4294959103U;
  pmlmeinfo->state = pmlmeinfo->state | 16384U;
  UpdateBrateTbl23a(padapter, (u8 *)(& pmlmeinfo->network.SupportedRates));
  report_assoc_result:
  pmlmepriv->assoc_rsp_len = 0U;
  if (res > 0) {
    kfree((void const *)pmlmepriv->assoc_rsp);
    tmp___4 = kmalloc((size_t )pkt_len, 32U);
    pmlmepriv->assoc_rsp = (u8 *)tmp___4;
    if ((unsigned long )pmlmepriv->assoc_rsp != (unsigned long )((u8 *)0U)) {
      __len = (size_t )pkt_len;
      __ret = memcpy((void *)pmlmepriv->assoc_rsp, (void const *)pframe,
                               __len);
      pmlmepriv->assoc_rsp_len = (u32 )pkt_len;
    } else {
    }
  } else {
    kfree((void const *)pmlmepriv->assoc_rsp);
  }
  report_join_res23a(padapter, res);
  return (1);
}
}
static int OnDeAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  unsigned short reason ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 updated ;
  int tmp___2 ;
  bool tmp___3 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  tmp___0 = ether_addr_equal((u8 const *)(& mgmt->bssid), (u8 const *)tmp);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {
  }
  reason = mgmt->u.deauth.reason_code;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s Reason code(%d)\n", "OnDeAuth23a", (int )reason);
  } else {
  }
  tmp___3 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___3) {
    pstapriv = & padapter->stapriv;
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: OLD_ERROR ap recv deauth reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->sa));
    } else {
    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& mgmt->sa));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      updated = 0U;
      spin_lock_bh(& pstapriv->asoc_list_lock);
      tmp___2 = list_empty((struct list_head const *)(& psta->asoc_list));
      if (tmp___2 == 0) {
        list_del_init(& psta->asoc_list);
        pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
        updated = ap_free_sta23a(padapter, psta, 0, (int )reason);
      } else {
      }
      spin_unlock_bh(& pstapriv->asoc_list_lock);
      associated_clients_update23a(padapter, (int )updated);
    } else {
    }
    return (1);
  } else {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: OLD_ERROR sta recv deauth reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->bssid));
    } else {
    }
    receive_disconnect23a(padapter, (unsigned char *)(& mgmt->bssid), (int )reason);
  }
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
  return (1);
}
}
static int OnDisassoc23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  unsigned short reason ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 updated ;
  int tmp___2 ;
  bool tmp___3 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  tmp___0 = ether_addr_equal((u8 const *)(& mgmt->bssid), (u8 const *)tmp);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {
  }
  reason = mgmt->u.disassoc.reason_code;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s Reason code(%d)\n", "OnDisassoc23a", (int )reason);
  } else {
  }
  tmp___3 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___3) {
    pstapriv = & padapter->stapriv;
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: OLD_ERROR ap recv disassoc reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->sa));
    } else {
    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& mgmt->sa));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      updated = 0U;
      spin_lock_bh(& pstapriv->asoc_list_lock);
      tmp___2 = list_empty((struct list_head const *)(& psta->asoc_list));
      if (tmp___2 == 0) {
        list_del_init(& psta->asoc_list);
        pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
        updated = ap_free_sta23a(padapter, psta, 0, (int )reason);
      } else {
      }
      spin_unlock_bh(& pstapriv->asoc_list_lock);
      associated_clients_update23a(padapter, (int )updated);
    } else {
    }
    return (1);
  } else {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: OLD_ERROR ap recv disassoc reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->bssid));
    } else {
    }
    receive_disconnect23a(padapter, (unsigned char *)(& mgmt->bssid), (int )reason);
  }
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
  return (1);
}
}
static int OnAtim23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAtim23a");
  } else {
  }
  return (1);
}
}
static int on_action_spct23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  {
  return (0);
}
}
static int OnAction23a_qos(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  {
  return (1);
}
}
static int OnAction23a_dls(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  {
  return (1);
}
}
static int OnAction23a_back23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  u8 *addr ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  unsigned char category ;
  unsigned char action ;
  unsigned short tid ;
  unsigned short status ;
  unsigned short capab ;
  unsigned short params ;
  unsigned short reason_code ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct sta_priv *pstapriv ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  {
  psta = (struct sta_info *)0;
  reason_code = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  pstapriv = & padapter->stapriv;
  tmp = myid(& padapter->eeprompriv);
  tmp___0 = ether_addr_equal((u8 const *)tmp, (u8 const *)(& mgmt->da));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "OnAction23a_back23a");
  } else {
  }
  if ((pmlmeinfo->state & 3U) != 3U) {
    if ((pmlmeinfo->state & 16384U) == 0U) {
      return (1);
    } else {
    }
  } else {
  }
  addr = (u8 *)(& mgmt->sa);
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)addr);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (1);
  } else {
  }
  category = mgmt->u.action.category;
  if ((unsigned int )category == 3U) {
    if ((unsigned int )pmlmeinfo->HT_enable == 0U) {
      return (1);
    } else {
    }
    action = mgmt->u.action.u.wme_action.action_code;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, action =%d\n", "OnAction23a_back23a", (int )action);
    } else {
    }
    switch ((int )action) {
    case 0:
    __len = 7UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& pmlmeinfo->ADDBA_req), (void const *)(& mgmt->u.action.u.addba_req.dialog_token),
                       __len);
    } else {
      __ret = memcpy((void *)(& pmlmeinfo->ADDBA_req), (void const *)(& mgmt->u.action.u.addba_req.dialog_token),
                               __len);
    }
    process_addba_req23a(padapter, (u8 *)(& pmlmeinfo->ADDBA_req), addr);
    if ((int )pmlmeinfo->bAcceptAddbaReq) {
      issue_action_BA23a(padapter, (unsigned char const *)addr, 1, 0);
    } else {
      issue_action_BA23a(padapter, (unsigned char const *)addr, 1, 37);
    }
    goto ldv_54864;
    case 1:
    status = get_unaligned_le16((void const *)(& mgmt->u.action.u.addba_resp.status));
    capab = get_unaligned_le16((void const *)(& mgmt->u.action.u.addba_resp.capab));
    tid = (unsigned short )(((int )capab & 60) >> 2);
    if ((unsigned int )status == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: agg_enable for TID =%d\n", (int )tid);
      } else {
      }
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap | (int )((u16 )(1UL << (int )tid));
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    } else {
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    }
    goto ldv_54864;
    case 2:
    params = get_unaligned_le16((void const *)(& mgmt->u.action.u.delba.params));
    tid = (int )params >> 12;
    if (((int )params & 2048) != 0) {
      preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )tid;
      preorder_ctrl->enable = 0U;
      preorder_ctrl->indicate_seq = 65535U;
    } else {
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    }
    reason_code = get_unaligned_le16((void const *)(& mgmt->u.action.u.delba.reason_code));
    goto ldv_54864;
    default: ;
    goto ldv_54864;
    }
    ldv_54864: ;
  } else {
  }
  return (1);
}
}
static int rtw_action_public_decache(struct recv_frame *recv_frame , s32 token )
{
  struct rtw_adapter *adapter ;
  struct mlme_ext_priv *mlmeext ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u16 seq_ctrl ;
  int tmp ;
  {
  adapter = recv_frame->adapter;
  mlmeext = & adapter->mlmeextpriv;
  skb = recv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  seq_ctrl = (u16 )((int )((short )((int )recv_frame->attrib.seq_num << 4)) | ((int )((short )recv_frame->attrib.frag_num) & 15));
  tmp = ieee80211_has_retry((int )hdr->frame_control);
  if (tmp != 0) {
    if (token >= 0) {
      if ((int )mlmeext->action_public_rxseq == (int )seq_ctrl && (int )mlmeext->action_public_dialog_token == token) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s(%s): seq_ctrl = 0x%x, rxseq = 0x%x, token:%d\n",
                 "rtw_action_public_decache", (char *)(& (adapter->pnetdev)->name),
                 (int )seq_ctrl, (int )mlmeext->action_public_rxseq, token);
        } else {
        }
        return (0);
      } else {
      }
    } else
    if ((int )mlmeext->action_public_rxseq == (int )seq_ctrl) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(%s): seq_ctrl = 0x%x, rxseq = 0x%x\n", "rtw_action_public_decache",
               (char *)(& (adapter->pnetdev)->name), (int )seq_ctrl, (int )mlmeext->action_public_rxseq);
      } else {
      }
      return (0);
    } else {
    }
  } else {
  }
  mlmeext->action_public_rxseq = seq_ctrl;
  if (token >= 0) {
    mlmeext->action_public_dialog_token = (u8 )token;
  } else {
  }
  return (1);
}
}
static int on_action_public23a_p2p(struct recv_frame *precv_frame )
{
  struct sk_buff *skb ;
  u8 *pframe ;
  u8 *frame_body ;
  u8 dialogToken ;
  int tmp ;
  {
  skb = precv_frame->pkt;
  pframe = skb->data;
  dialogToken = 0U;
  frame_body = pframe + 24U;
  dialogToken = *(frame_body + 7UL);
  tmp = rtw_action_public_decache(precv_frame, (s32 )dialogToken);
  if (tmp == 0) {
    return (0);
  } else {
  }
  return (1);
}
}
static int on_action_public23a_vendor(struct recv_frame *precv_frame )
{
  unsigned int ret ;
  struct sk_buff *skb ;
  u8 *pframe ;
  u8 *frame_body ;
  int tmp ;
  int tmp___0 ;
  {
  ret = 0U;
  skb = precv_frame->pkt;
  pframe = skb->data;
  frame_body = pframe + 24UL;
  tmp___0 = memcmp((void const *)frame_body + 2U, (void const *)(& P2P_OUI23A),
                   4UL);
  if (tmp___0 == 0) {
    tmp = on_action_public23a_p2p(precv_frame);
    ret = (unsigned int )tmp;
  } else {
  }
  return ((int )ret);
}
}
static unsigned int on_action_public23a_default(struct recv_frame *precv_frame , u8 action )
{
  unsigned int ret ;
  struct sk_buff *skb ;
  u8 *pframe ;
  uint frame_len ;
  u8 *frame_body ;
  u8 token ;
  struct rtw_adapter *adapter ;
  int cnt ;
  char msg[64U] ;
  int tmp ;
  char const *tmp___0 ;
  int tmp___1 ;
  {
  ret = 0U;
  skb = precv_frame->pkt;
  pframe = skb->data;
  frame_len = skb->len;
  frame_body = pframe + 24UL;
  adapter = precv_frame->adapter;
  cnt = 0;
  token = *(frame_body + 2UL);
  tmp = rtw_action_public_decache(precv_frame, (s32 )token);
  if (tmp == 0) {
    goto exit;
  } else {
  }
  tmp___0 = action_public_str23a((int )action);
  tmp___1 = sprintf((char *)(& msg) + (unsigned long )cnt, "%s(token:%u)", tmp___0,
                    (int )token);
  cnt = tmp___1 + cnt;
  rtw_cfg80211_rx_action(adapter, pframe, frame_len, (char const *)(& msg));
  ret = 1U;
  exit: ;
  return (ret);
}
}
static int on_action_public23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  int ret ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 *pframe ;
  u8 *frame_body ;
  u8 category ;
  u8 action ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  {
  ret = 0;
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  pframe = skb->data;
  frame_body = pframe + 24UL;
  tmp = myid(& padapter->eeprompriv);
  tmp___0 = ether_addr_equal((u8 const *)tmp, (u8 const *)(& hdr->addr1));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    goto exit;
  } else {
  }
  category = *frame_body;
  if ((unsigned int )category != 4U) {
    goto exit;
  } else {
  }
  action = *(frame_body + 1UL);
  switch ((int )action) {
  case 9:
  ret = on_action_public23a_vendor(precv_frame);
  goto ldv_54919;
  default:
  tmp___2 = on_action_public23a_default(precv_frame, (int )action);
  ret = (int )tmp___2;
  goto ldv_54919;
  }
  ldv_54919: ;
  exit: ;
  return (ret);
}
}
static int OnAction23a_ht(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  {
  return (1);
}
}
static int OnAction23a_wmm(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  {
  return (1);
}
}
static int OnAction23a_p2p(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  {
  return (1);
}
}
static int OnAction23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  int i ;
  u8 category ;
  struct action_handler *ptable ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  {
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  category = mgmt->u.action.category;
  i = 0;
  goto ldv_54943;
  ldv_54942:
  ptable = (struct action_handler *)(& OnAction23a_tbl) + (unsigned long )i;
  if ((unsigned int )category == ptable->num) {
    (*(ptable->func))(padapter, precv_frame);
  } else {
  }
  i = i + 1;
  ldv_54943: ;
  if ((unsigned int )i <= 8U) {
    goto ldv_54942;
  } else {
  }
  return (1);
}
}
static int DoReserved23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  {
  return (1);
}
}
struct xmit_frame *alloc_mgtxmitframe23a(struct xmit_priv *pxmitpriv )
{
  struct xmit_frame *pmgntframe ;
  struct xmit_buf *pxmitbuf ;
  {
  pmgntframe = rtw_alloc_xmitframe23a_ext(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): alloc xmitframe fail\n", "alloc_mgtxmitframe23a",
             (char *)(& ((pxmitpriv->adapter)->pnetdev)->name));
    } else {
    }
    goto exit;
  } else {
  }
  pxmitbuf = rtw_alloc_xmitbuf23a_ext(pxmitpriv);
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): alloc xmitbuf fail\n", "alloc_mgtxmitframe23a",
             (char *)(& ((pxmitpriv->adapter)->pnetdev)->name));
    } else {
    }
    rtw_free_xmitframe23a(pxmitpriv, pmgntframe);
    pmgntframe = (struct xmit_frame *)0;
    goto exit;
  } else {
  }
  pmgntframe->frame_tag = 3;
  pmgntframe->pxmitbuf = pxmitbuf;
  pmgntframe->buf_addr = pxmitbuf->pbuf;
  pxmitbuf->priv_data = (void *)pmgntframe;
  exit: ;
  return (pmgntframe);
}
}
void update_mgnt_tx_rate23a(struct rtw_adapter *padapter , u8 rate )
{
  struct mlme_ext_priv *pmlmeext ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeext->tx_rate = rate;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(): rate = %x\n", "update_mgnt_tx_rate23a", (int )rate);
  } else {
  }
  return;
}
}
void update_mgntframe_attrib23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib )
{
  struct mlme_ext_priv *pmlmeext ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  memset((void *)pattrib, 0, 112UL);
  pattrib->hdrlen = 24U;
  pattrib->nr_frags = 1U;
  pattrib->priority = 7U;
  pattrib->mac_id = 0U;
  pattrib->qsel = 18U;
  pattrib->pktlen = 0U;
  if ((int )pmlmeext->cur_wireless_mode & 1) {
    pattrib->raid = 6U;
  } else {
    pattrib->raid = 5U;
  }
  pattrib->encrypt = 0U;
  pattrib->bswenc = 0U;
  pattrib->qos_en = 0U;
  pattrib->ht_en = 0U;
  pattrib->bwmode = 0U;
  pattrib->ch_offset = 0U;
  pattrib->sgi = 0U;
  pattrib->seqnum = pmlmeext->mgnt_seq;
  pattrib->retry_ctrl = 1U;
  return;
}
}
void dump_mgntframe23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe )
{
  {
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
    return;
  } else {
  }
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
  return;
}
}
s32 dump_mgntframe23a_and_wait(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ,
                               int timeout_ms )
{
  int ret ;
  unsigned long irqL ;
  struct xmit_priv *pxmitpriv ;
  struct xmit_buf *pxmitbuf ;
  struct submit_ctx sctx ;
  {
  ret = 0;
  pxmitpriv = & padapter->xmitpriv;
  pxmitbuf = pmgntframe->pxmitbuf;
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
    return (ret);
  } else {
  }
  rtw_sctx_init23a(& sctx, timeout_ms);
  pxmitbuf->sctx = & sctx;
  ret = rtl8723au_mgnt_xmit(padapter, pmgntframe);
  if (ret == 1) {
    ret = rtw_sctx_wait23a(& sctx);
  } else {
  }
  ldv_spin_lock();
  pxmitbuf->sctx = (struct submit_ctx *)0;
  spin_unlock_irqrestore(& pxmitpriv->lock_sctx, irqL);
  return (ret);
}
}
s32 dump_mgntframe23a_and_wait_ack23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe )
{
  int ret ;
  u32 timeout_ms ;
  struct xmit_priv *pxmitpriv ;
  int tmp ;
  {
  ret = 0;
  timeout_ms = 500U;
  pxmitpriv = & padapter->xmitpriv;
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
    return (0);
  } else {
  }
  mutex_lock_nested(& pxmitpriv->ack_tx_mutex, 0U);
  pxmitpriv->ack_tx = 1;
  pmgntframe->ack_report = 1U;
  tmp = rtl8723au_mgnt_xmit(padapter, pmgntframe);
  if (tmp == 1) {
    ret = rtw_ack_tx_wait23a(pxmitpriv, timeout_ms);
  } else {
  }
  pxmitpriv->ack_tx = 0;
  mutex_unlock(& pxmitpriv->ack_tx_mutex);
  return (ret);
}
}
static int update_hidden_ssid(u8 *ies , u32 ies_len , u8 hidden_ssid_mode )
{
  u8 *ssid_ie ;
  int ssid_len_ori ;
  int len_diff ;
  u8 *next_ie ;
  u32 remain_len ;
  size_t __len ;
  void *__ret ;
  {
  len_diff = 0;
  ssid_ie = rtw_get_ie23a(ies, 0, & ssid_len_ori, (int )ies_len);
  if ((unsigned long )ssid_ie != (unsigned long )((u8 *)0U) && ssid_len_ori > 0) {
    switch ((int )hidden_ssid_mode) {
    case 1:
    next_ie = ssid_ie + ((unsigned long )ssid_len_ori + 2UL);
    remain_len = 0U;
    remain_len = ((u32 )((long )ies) - (u32 )((long )next_ie)) + ies_len;
    *(ssid_ie + 1UL) = 0U;
    __len = (size_t )remain_len;
    __ret = memcpy((void *)ssid_ie + 2U, (void const *)next_ie, __len);
    len_diff = len_diff - ssid_len_ori;
    goto ldv_55002;
    case 2:
    memset((void *)ssid_ie + 2U, 0, (size_t )ssid_len_ori);
    goto ldv_55002;
    default: ;
    goto ldv_55002;
    }
    ldv_55002: ;
  } else {
  }
  return (len_diff);
}
}
void issue_beacon23a(struct rtw_adapter *padapter , int timeout_ms )
{
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned int rate_len ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 bc_addr[6U] ;
  u8 *wps_ie ;
  u32 wps_ielen ;
  u8 sr ;
  int len_diff ;
  u8 *tmp ;
  u8 *tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  __le16 *tmp___1 ;
  __le16 *tmp___2 ;
  size_t __len___1 ;
  void *__ret___1 ;
  __le16 *tmp___3 ;
  __le16 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u8 erpinfo ;
  u32 ATIMWindow ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  bc_addr[0] = 255U;
  bc_addr[1] = 255U;
  bc_addr[2] = 255U;
  bc_addr[3] = 255U;
  bc_addr[4] = 255U;
  bc_addr[5] = 255U;
  sr = 0U;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, alloc mgnt frame fail\n", "issue_beacon23a");
    } else {
    }
    return;
  } else {
  }
  spin_lock_bh(& pmlmepriv->bcn_update_lock);
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->qsel = 16U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 128U;
  pwlanhdr->seq_ctrl = 0U;
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)(& bc_addr));
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp);
  tmp___0 = get_my_bssid23a(cur_network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___0);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  if ((pmlmeinfo->state & 3U) == 3U) {
    __len = (size_t )cur_network->IELength;
    __ret = memcpy((void *)pframe, (void const *)(& cur_network->IEs),
                             __len);
    len_diff = update_hidden_ssid(pframe + 12U, cur_network->IELength - 12U, (int )pmlmeinfo->hidden_ssid_mode);
    pframe = pframe + (unsigned long )(cur_network->IELength + (u32 )len_diff);
    pattrib->pktlen = pattrib->pktlen + (cur_network->IELength + (u32 )len_diff);
    wps_ie = rtw_get_wps_ie23a(pmgntframe->buf_addr + 76U, pattrib->pktlen - 36U,
                               (u8 *)0U, & wps_ielen);
    if ((unsigned long )wps_ie != (unsigned long )((u8 *)0U) && wps_ielen != 0U) {
      rtw_get_wps_attr_content23a(wps_ie, wps_ielen, 4161, & sr, (uint *)0U);
    } else {
    }
    if ((unsigned int )sr != 0U) {
      set_fwstate(pmlmepriv, 256);
    } else {
      _clr_fwstate_(pmlmepriv, 256);
    }
    goto _issue_bcn;
  } else {
  }
  pframe = pframe + 8UL;
  pattrib->pktlen = pattrib->pktlen + 8U;
  __len___0 = 2UL;
  if (__len___0 > 63UL) {
    tmp___1 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
    __ret___0 = memcpy((void *)pframe, (void const *)tmp___1, __len___0);
  } else {
    tmp___2 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
    __ret___0 = memcpy((void *)pframe, (void const *)tmp___2, __len___0);
  }
  pframe = pframe + 2UL;
  pattrib->pktlen = pattrib->pktlen + 2U;
  __len___1 = 2UL;
  if (__len___1 > 63UL) {
    tmp___3 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
    __ret___1 = memcpy((void *)pframe, (void const *)tmp___3, __len___1);
  } else {
    tmp___4 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
    __ret___1 = memcpy((void *)pframe, (void const *)tmp___4, __len___1);
  }
  pframe = pframe + 2UL;
  pattrib->pktlen = pattrib->pktlen + 2U;
  tmp___5 = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const *)(& cur_network->Ssid.ssid),
                          & pattrib->pktlen);
  pframe = tmp___5;
  rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  tmp___6 = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const *)(& cur_network->SupportedRates),
                          & pattrib->pktlen);
  pframe = tmp___6;
  tmp___7 = rtw_set_ie23a(pframe, 3, 1U, (u8 const *)(& cur_network->DSConfig),
                          & pattrib->pktlen);
  pframe = tmp___7;
  erpinfo = 0U;
  ATIMWindow = 0U;
  tmp___8 = rtw_set_ie23a(pframe, 6, 2U, (u8 const *)(& ATIMWindow), & pattrib->pktlen);
  pframe = tmp___8;
  tmp___9 = rtw_set_ie23a(pframe, 42, 1U, (u8 const *)(& erpinfo), & pattrib->pktlen);
  pframe = tmp___9;
  if (rate_len > 8U) {
    tmp___10 = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const *)(& cur_network->SupportedRates) + 8U,
                             & pattrib->pktlen);
    pframe = tmp___10;
  } else {
  }
  _issue_bcn:
  pmlmepriv->update_bcn = 0U;
  spin_unlock_bh(& pmlmepriv->bcn_update_lock);
  if (pattrib->pktlen + 32U > 512U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: beacon frame too large\n");
    } else {
    }
    return;
  } else {
  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  if (timeout_ms > 0) {
    dump_mgntframe23a_and_wait(padapter, pmgntframe, timeout_ms);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
  }
  return;
}
}
static void issue_probersp(struct rtw_adapter *padapter , unsigned char *da , u8 is_valid_p2p_probereq )
{
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned char *mac ;
  unsigned char *bssid ;
  struct xmit_priv *pxmitpriv ;
  u8 *pwps_ie ;
  uint wps_ielen ;
  u8 *ssid_ie ;
  int ssid_ielen ;
  int ssid_ielen_diff ;
  u8 buf[768U] ;
  u8 *ies ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  unsigned int rate_len ;
  u8 *tmp ;
  uint wps_offset ;
  uint remainder_ielen ;
  u8 *premainder_ie ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  uint remainder_ielen___0 ;
  u8 *remainder_ie ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  size_t __len___5 ;
  void *__ret___5 ;
  size_t __len___6 ;
  void *__ret___6 ;
  __le16 *tmp___0 ;
  __le16 *tmp___1 ;
  size_t __len___7 ;
  void *__ret___7 ;
  __le16 *tmp___2 ;
  __le16 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 erpinfo ;
  u32 ATIMWindow ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, alloc mgnt frame fail\n", "issue_probersp");
    } else {
    }
    return;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  tmp = myid(& padapter->eeprompriv);
  mac = tmp;
  bssid = (unsigned char *)(& cur_network->MacAddress);
  pwlanhdr->frame_control = 80U;
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)da);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)mac);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)bssid);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pattrib->hdrlen = 24U;
  pattrib->pktlen = (u32 )pattrib->hdrlen;
  pframe = pframe + (unsigned long )pattrib->hdrlen;
  if (cur_network->IELength > 768U) {
    return;
  } else {
  }
  if ((pmlmeinfo->state & 3U) == 3U) {
    pwps_ie = rtw_get_wps_ie23a((u8 *)(& cur_network->IEs) + 12UL, cur_network->IELength - 12U,
                                (u8 *)0U, & wps_ielen);
    if (((unsigned long )pmlmepriv->wps_probe_resp_ie != (unsigned long )((u8 *)0U) && (unsigned long )pwps_ie != (unsigned long )((u8 *)0U)) && wps_ielen != 0U) {
      wps_offset = (unsigned int )((long )pwps_ie) - (unsigned int )((long )(& cur_network->IEs));
      premainder_ie = pwps_ie + (unsigned long )wps_ielen;
      remainder_ielen = (cur_network->IELength - wps_offset) - wps_ielen;
      __len = (size_t )wps_offset;
      __ret = memcpy((void *)pframe, (void const *)(& cur_network->IEs),
                               __len);
      pframe = pframe + (unsigned long )wps_offset;
      pattrib->pktlen = pattrib->pktlen + wps_offset;
      wps_ielen = (unsigned int )*(pmlmepriv->wps_probe_resp_ie + 1UL);
      if ((wps_offset + wps_ielen) + 2U <= 768U) {
        __len___0 = (size_t )(wps_ielen + 2U);
        __ret___0 = memcpy((void *)pframe, (void const *)pmlmepriv->wps_probe_resp_ie,
                                     __len___0);
        pframe = pframe + (unsigned long )(wps_ielen + 2U);
        pattrib->pktlen = (pattrib->pktlen + wps_ielen) + 2U;
      } else {
      }
      if (((wps_offset + wps_ielen) + remainder_ielen) + 2U <= 768U) {
        __len___1 = (size_t )remainder_ielen;
        __ret___1 = memcpy((void *)pframe, (void const *)premainder_ie,
                                     __len___1);
        pframe = pframe + (unsigned long )remainder_ielen;
        pattrib->pktlen = pattrib->pktlen + remainder_ielen;
      } else {
      }
    } else {
      __len___2 = (size_t )cur_network->IELength;
      __ret___2 = memcpy((void *)pframe, (void const *)(& cur_network->IEs),
                                   __len___2);
      pframe = pframe + (unsigned long )cur_network->IELength;
      pattrib->pktlen = pattrib->pktlen + cur_network->IELength;
    }
    ies = pmgntframe->buf_addr + 64U;
    ssid_ie = rtw_get_ie23a(ies + 12UL, 0, & ssid_ielen, (int )(((unsigned int )((long )pframe) - (unsigned int )((long )ies)) + 4294967284U));
    ssid_ielen_diff = (int )cur_network->Ssid.ssid_len - ssid_ielen;
    if ((unsigned long )ssid_ie != (unsigned long )((u8 *)0U) && (unsigned int )cur_network->Ssid.ssid_len != 0U) {
      remainder_ie = ssid_ie + 2UL;
      remainder_ielen___0 = (uint )((long )pframe) - (uint )((long )remainder_ie);
      if (GlobalDebugLevel23A > 4U) {
        printk("\016RTL8723AU: OLD_ERROR %s(%s): remainder_ielen > MAX_IE_SZ\n", "issue_probersp",
               (char *)(& (padapter->pnetdev)->name));
      } else {
      }
      if (remainder_ielen___0 > 768U) {
        remainder_ielen___0 = 768U;
      } else {
      }
      __len___3 = (size_t )remainder_ielen___0;
      __ret___3 = memcpy((void *)(& buf), (void const *)remainder_ie,
                                   __len___3);
      __len___4 = (size_t )remainder_ielen___0;
      __ret___4 = memcpy((void *)remainder_ie + (unsigned long )ssid_ielen_diff,
                                   (void const *)(& buf), __len___4);
      *(ssid_ie + 1UL) = cur_network->Ssid.ssid_len;
      __len___5 = (size_t )cur_network->Ssid.ssid_len;
      __ret___5 = memcpy((void *)ssid_ie + 2U, (void const *)(& cur_network->Ssid.ssid),
                                   __len___5);
      pframe = pframe + (unsigned long )ssid_ielen_diff;
      pattrib->pktlen = pattrib->pktlen + (u32 )ssid_ielen_diff;
    } else {
    }
  } else {
    pframe = pframe + 8UL;
    pattrib->pktlen = pattrib->pktlen + 8U;
    __len___6 = 2UL;
    if (__len___6 > 63UL) {
      tmp___0 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
      __ret___6 = memcpy((void *)pframe, (void const *)tmp___0, __len___6);
    } else {
      tmp___1 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
      __ret___6 = memcpy((void *)pframe, (void const *)tmp___1, __len___6);
    }
    pframe = pframe + 2UL;
    pattrib->pktlen = pattrib->pktlen + 2U;
    __len___7 = 2UL;
    if (__len___7 > 63UL) {
      tmp___2 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
      __ret___7 = memcpy((void *)pframe, (void const *)tmp___2, __len___7);
    } else {
      tmp___3 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
      __ret___7 = memcpy((void *)pframe, (void const *)tmp___3, __len___7);
    }
    pframe = pframe + 2UL;
    pattrib->pktlen = pattrib->pktlen + 2U;
    tmp___4 = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const *)(& cur_network->Ssid.ssid),
                            & pattrib->pktlen);
    pframe = tmp___4;
    rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
    tmp___5 = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const *)(& cur_network->SupportedRates),
                            & pattrib->pktlen);
    pframe = tmp___5;
    tmp___6 = rtw_set_ie23a(pframe, 3, 1U, (u8 const *)(& cur_network->DSConfig),
                            & pattrib->pktlen);
    pframe = tmp___6;
    if ((pmlmeinfo->state & 3U) == 1U) {
      erpinfo = 0U;
      ATIMWindow = 0U;
      tmp___7 = rtw_set_ie23a(pframe, 6, 2U, (u8 const *)(& ATIMWindow), & pattrib->pktlen);
      pframe = tmp___7;
      tmp___8 = rtw_set_ie23a(pframe, 42, 1U, (u8 const *)(& erpinfo), & pattrib->pktlen);
      pframe = tmp___8;
    } else {
    }
    if (rate_len > 8U) {
      tmp___9 = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const *)(& cur_network->SupportedRates) + 8U,
                              & pattrib->pktlen);
      pframe = tmp___9;
    } else {
    }
  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
static int _issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                           u8 *da , int wait_ack )
{
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned char *mac ;
  unsigned char bssrate[13U] ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int bssrate_len ;
  u8 bc_addr[6U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  size_t __len ;
  void *__ret ;
  {
  ret = 0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  bssrate_len = 0;
  bc_addr[0] = 255U;
  bc_addr[1] = 255U;
  bc_addr[2] = 255U;
  bc_addr[3] = 255U;
  bc_addr[4] = 255U;
  bc_addr[5] = 255U;
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
    printk("\016+%s\n", "_issue_probereq");
  } else {
  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  tmp = myid(& padapter->eeprompriv);
  mac = tmp;
  pwlanhdr->frame_control = 64U;
  if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)da);
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)da);
  } else {
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)(& bc_addr));
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)(& bc_addr));
  }
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)mac);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  if ((unsigned long )pssid != (unsigned long )((struct cfg80211_ssid *)0)) {
    tmp___0 = rtw_set_ie23a(pframe, 0, (uint )pssid->ssid_len, (u8 const *)(& pssid->ssid),
                            & pattrib->pktlen);
    pframe = tmp___0;
  } else {
    tmp___1 = rtw_set_ie23a(pframe, 0, 0U, (u8 const *)0U, & pattrib->pktlen);
    pframe = tmp___1;
  }
  get_rate_set23a(padapter, (unsigned char *)(& bssrate), & bssrate_len);
  if (bssrate_len > 8) {
    tmp___2 = rtw_set_ie23a(pframe, 1, 8U, (u8 const *)(& bssrate), & pattrib->pktlen);
    pframe = tmp___2;
    tmp___3 = rtw_set_ie23a(pframe, 50, (uint )(bssrate_len + -8), (u8 const *)(& bssrate) + 8U,
                            & pattrib->pktlen);
    pframe = tmp___3;
  } else {
    tmp___4 = rtw_set_ie23a(pframe, 1, (uint )bssrate_len, (u8 const *)(& bssrate),
                            & pattrib->pktlen);
    pframe = tmp___4;
  }
  if (pmlmepriv->wps_probe_req_ie_len != 0U && (unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
    __len = (size_t )pmlmepriv->wps_probe_req_ie_len;
    __ret = memcpy((void *)pframe, (void const *)pmlmepriv->wps_probe_req_ie,
                             __len);
    pframe = pframe + (unsigned long )pmlmepriv->wps_probe_req_ie_len;
    pattrib->pktlen = pattrib->pktlen + pmlmepriv->wps_probe_req_ie_len;
  } else {
  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
    printk("\016issuing probe_req, tx_len =%d\n", pattrib->last_txcmdsz);
  } else {
  }
  if (wait_ack != 0) {
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
    ret = 1;
  }
  exit: ;
  return (ret);
}
}
__inline static void issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                    u8 *da )
{
  {
  _issue_probereq(padapter, pssid, da, 0);
  return;
}
}
static int issue_probereq_ex(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                             u8 *da , int try_cnt , int wait_ms )
{
  int ret ;
  int i ;
  unsigned long start ;
  unsigned int tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u8 tmp___2 ;
  {
  i = 0;
  start = jiffies;
  ldv_55135:
  ret = _issue_probereq(padapter, pssid, da, wait_ms > 0);
  i = i + 1;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto ldv_55134;
  } else {
  }
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
    msleep((unsigned int )wait_ms);
  } else {
  }
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
    goto ldv_55135;
  } else {
  }
  ldv_55134: ;
  if (ret != 0) {
    ret = 1;
    goto exit;
  } else {
  }
  if (try_cnt != 0 && wait_ms != 0) {
    if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        tmp = jiffies_to_msecs((unsigned long )jiffies - start);
        tmp___0 = rtw_get_oper_ch23a(padapter);
        printk("\016RTL8723AU: %s(%s): to %02x:%02x:%02x:%02x:%02x:%02x, ch:%u%s, %d/%d in %u ms\n",
               "issue_probereq_ex", (char *)(& (padapter->pnetdev)->name), (int )*da,
               (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
               (int )*(da + 5UL), (int )tmp___0, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp);
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      tmp___1 = jiffies_to_msecs((unsigned long )jiffies - start);
      tmp___2 = rtw_get_oper_ch23a(padapter);
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_probereq_ex",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___2, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___1);
    } else {
    }
  } else {
  }
  exit: ;
  return (ret);
}
}
static void issue_auth(struct rtw_adapter *padapter , struct sta_info *psta , unsigned short status )
{
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned int val32 ;
  unsigned short val16 ;
  int use_shared_key ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u32 tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  u8 *tmp___11 ;
  u8 *tmp___12 ;
  u8 *tmp___13 ;
  {
  use_shared_key = 0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    return;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 176U;
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)(& psta->hwaddr));
    tmp = myid(& padapter->eeprompriv);
    ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp);
    tmp___0 = myid(& padapter->eeprompriv);
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___0);
    val16 = (unsigned short )psta->authalg;
    if ((unsigned int )status != 0U) {
      val16 = 0U;
    } else {
    }
    if ((unsigned int )val16 != 0U) {
      val16 = val16;
      use_shared_key = 1;
    } else {
    }
    tmp___1 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
    pframe = tmp___1;
    val16 = (unsigned short )psta->auth_seq;
    val16 = val16;
    tmp___2 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
    pframe = tmp___2;
    val16 = status;
    val16 = val16;
    tmp___3 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
    pframe = tmp___3;
    if ((psta->auth_seq == 2U && (psta->state & 512U) != 0U) && use_shared_key == 1) {
      tmp___4 = rtw_set_ie23a(pframe, 16, 128U, (u8 const *)(& psta->chg_txt), & pattrib->pktlen);
      pframe = tmp___4;
    } else {
    }
  } else {
    tmp___5 = get_my_bssid23a(& pmlmeinfo->network);
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)tmp___5);
    tmp___6 = myid(& padapter->eeprompriv);
    ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp___6);
    tmp___7 = get_my_bssid23a(& pmlmeinfo->network);
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___7);
    val16 = pmlmeinfo->auth_algo == 1U;
    if ((unsigned int )val16 != 0U) {
      val16 = val16;
      use_shared_key = 1;
    } else {
    }
    if ((pmlmeinfo->auth_seq == 3U && (pmlmeinfo->state & 512U) != 0U) && use_shared_key == 1) {
      tmp___8 = pmlmeinfo->iv;
      pmlmeinfo->iv = pmlmeinfo->iv + 1U;
      val32 = tmp___8 | (pmlmeinfo->key_index << 30);
      val32 = val32;
      tmp___9 = rtw_set_fixed_ie23a(pframe, 4U, (unsigned char *)(& val32), & pattrib->pktlen);
      pframe = tmp___9;
      pattrib->iv_len = 4U;
    } else {
    }
    tmp___10 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
    pframe = tmp___10;
    val16 = (unsigned short )pmlmeinfo->auth_seq;
    val16 = val16;
    tmp___11 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
    pframe = tmp___11;
    val16 = status;
    val16 = val16;
    tmp___12 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
    pframe = tmp___12;
    if ((pmlmeinfo->auth_seq == 3U && (pmlmeinfo->state & 512U) != 0U) && use_shared_key == 1) {
      tmp___13 = rtw_set_ie23a(pframe, 16, 128U, (u8 const *)(& pmlmeinfo->chg_txt),
                               & pattrib->pktlen);
      pframe = tmp___13;
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 16384U);
      pattrib->hdrlen = 24U;
      pattrib->encrypt = 1027073U;
      pattrib->icv_len = 4U;
      pattrib->pktlen = pattrib->pktlen + (u32 )pattrib->icv_len;
    } else {
    }
  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  rtw_wep_encrypt23a(padapter, pmgntframe);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "issue_auth");
  } else {
  }
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
static void issue_assocrsp(struct rtw_adapter *padapter , unsigned short status ,
                           struct sta_info *pstat , u16 pkt_type )
{
  struct xmit_frame *pmgntframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  unsigned short val ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  u8 const *p ;
  u8 *ie ;
  u8 *tmp ;
  u8 *tmp___0 ;
  __le16 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned char WMM_PARA_IE[6U] ;
  int ie_len ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___8 ;
  u8 *tmp___9 ;
  size_t __len___2 ;
  void *__ret___2 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  ie = (u8 *)(& pnetwork->IEs);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "issue_assocrsp");
  } else {
  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    return;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = pkt_type;
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)(& pstat->hwaddr));
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___0);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pattrib->hdrlen = 24U;
  pattrib->pktlen = pattrib->pktlen + (u32 )pattrib->hdrlen;
  pframe = pframe + (unsigned long )pattrib->hdrlen;
  tmp___1 = rtw_get_capability23a_from_ie(ie);
  val = *tmp___1;
  tmp___2 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val), & pattrib->pktlen);
  pframe = tmp___2;
  status = status;
  tmp___3 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& status), & pattrib->pktlen);
  pframe = tmp___3;
  val = (unsigned int )((unsigned short )pstat->aid) | 49152U;
  tmp___4 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val), & pattrib->pktlen);
  pframe = tmp___4;
  if (pstat->bssratelen <= 8U) {
    tmp___5 = rtw_set_ie23a(pframe, 1, pstat->bssratelen, (u8 const *)(& pstat->bssrateset),
                            & pattrib->pktlen);
    pframe = tmp___5;
  } else {
    tmp___6 = rtw_set_ie23a(pframe, 1, 8U, (u8 const *)(& pstat->bssrateset), & pattrib->pktlen);
    pframe = tmp___6;
    tmp___7 = rtw_set_ie23a(pframe, 50, pstat->bssratelen - 8U, (u8 const *)(& pstat->bssrateset) + 8U,
                            & pattrib->pktlen);
    pframe = tmp___7;
  }
  if (((unsigned long )pstat->flags & 2048UL) != 0UL && pmlmepriv->htpriv.ht_option != 0U) {
    p = cfg80211_find_ie(45, (u8 const *)ie + 12U, (int )(pnetwork->IELength - 12U));
    if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      __len = (size_t )((int )*(p + 1UL) + 2);
      __ret = memcpy((void *)pframe, (void const *)p, __len);
      pframe = pframe + ((unsigned long )*(p + 1UL) + 2UL);
      pattrib->pktlen = (pattrib->pktlen + (u32 )*(p + 1UL)) + 2U;
    } else {
    }
    p = cfg80211_find_ie(61, (u8 const *)ie + 12U, (int )(pnetwork->IELength - 12U));
    if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      __len___0 = (size_t )((int )*(p + 1UL) + 2);
      __ret___0 = memcpy((void *)pframe, (void const *)p, __len___0);
      pframe = pframe + ((unsigned long )*(p + 1UL) + 2UL);
      pattrib->pktlen = (pattrib->pktlen + (u32 )*(p + 1UL)) + 2U;
    } else {
    }
  } else {
  }
  if (((unsigned long )pstat->flags & 512UL) != 0UL && pmlmepriv->qos_option != 0U) {
    WMM_PARA_IE[0] = 0U;
    WMM_PARA_IE[1] = 80U;
    WMM_PARA_IE[2] = 242U;
    WMM_PARA_IE[3] = 2U;
    WMM_PARA_IE[4] = 1U;
    WMM_PARA_IE[5] = 1U;
    ie_len = 0;
    p = (u8 const *)ie + 12U;
    ldv_55185:
    p = cfg80211_find_ie(221, p, (int )((pnetwork->IELength - (u32 )ie_len) - 14U));
    if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
      ie_len = (int )*(p + 1UL);
    } else {
      ie_len = 0;
    }
    if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
      tmp___8 = memcmp((void const *)p + 2U, (void const *)(& WMM_PARA_IE), 6UL);
      if (tmp___8 == 0) {
        __len___1 = (size_t )(ie_len + 2);
        __ret___1 = memcpy((void *)pframe, (void const *)p, __len___1);
        pframe = pframe + ((unsigned long )ie_len + 2UL);
        pattrib->pktlen = (pattrib->pktlen + (u32 )ie_len) + 2U;
        goto ldv_55184;
      } else {
      }
    } else {
    }
    if ((unsigned long )p == (unsigned long )((u8 const *)0U) || ie_len == 0) {
      goto ldv_55184;
    } else {
    }
    p = p + ((unsigned long )ie_len + 2UL);
    goto ldv_55185;
    ldv_55184: ;
  } else {
  }
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 1U) {
    tmp___9 = rtw_set_ie23a(pframe, 221, 6U, (u8 const *)(& REALTEK_96B_IE), & pattrib->pktlen);
    pframe = tmp___9;
  } else {
  }
  if ((unsigned long )pmlmepriv->wps_assoc_resp_ie != (unsigned long )((u8 *)0U) && pmlmepriv->wps_assoc_resp_ie_len != 0U) {
    __len___2 = (size_t )pmlmepriv->wps_assoc_resp_ie_len;
    __ret___2 = memcpy((void *)pframe, (void const *)pmlmepriv->wps_assoc_resp_ie,
                                 __len___2);
    pframe = pframe + (unsigned long )pmlmepriv->wps_assoc_resp_ie_len;
    pattrib->pktlen = pattrib->pktlen + pmlmepriv->wps_assoc_resp_ie_len;
  } else {
  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
static void issue_assocreq(struct rtw_adapter *padapter )
{
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  u8 const *p ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned int i ;
  unsigned int j ;
  unsigned int index ;
  unsigned char rf_type ;
  unsigned char bssrate[13U] ;
  unsigned char sta_bssrate[13U] ;
  struct registry_priv *pregpriv ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bssrate_len ;
  int sta_bssrate_len ;
  int pie_len ;
  int bcn_fixed_size ;
  u8 *pie ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  size_t __len ;
  void *__ret ;
  __le16 *tmp___2 ;
  __le16 *tmp___3 ;
  u8 *tmp___4 ;
  unsigned int tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  bool tmp___10 ;
  bool tmp___11 ;
  u8 *tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  u8 plen ;
  int tmp___15 ;
  u8 *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  u8 *tmp___20 ;
  void *tmp___21 ;
  size_t __len___3 ;
  void *__ret___3 ;
  {
  ret = 0;
  index = 0U;
  pregpriv = & padapter->registrypriv;
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  bssrate_len = 0;
  sta_bssrate_len = 0;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 0U;
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)tmp);
  tmp___0 = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp___0);
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___1);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  __len = 2UL;
  if (__len > 63UL) {
    tmp___2 = rtw_get_capability23a_from_ie((u8 *)(& pmlmeinfo->network.IEs));
    __ret = memcpy((void *)pframe, (void const *)tmp___2, __len);
  } else {
    tmp___3 = rtw_get_capability23a_from_ie((u8 *)(& pmlmeinfo->network.IEs));
    __ret = memcpy((void *)pframe, (void const *)tmp___3, __len);
  }
  pframe = pframe + 2UL;
  pattrib->pktlen = pattrib->pktlen + 2U;
  put_unaligned_le16(3, (void *)pframe);
  pframe = pframe + 2UL;
  pattrib->pktlen = pattrib->pktlen + 2U;
  tmp___4 = rtw_set_ie23a(pframe, 0, (uint )pmlmeinfo->network.Ssid.ssid_len, (u8 const *)(& pmlmeinfo->network.Ssid.ssid),
                          & pattrib->pktlen);
  pframe = tmp___4;
  get_rate_set23a(padapter, (unsigned char *)(& sta_bssrate), & sta_bssrate_len);
  if ((unsigned int )pmlmeext->cur_channel == 14U) {
    sta_bssrate_len = 4;
  } else {
  }
  i = 0U;
  goto ldv_55220;
  ldv_55219: ;
  if ((unsigned int )pmlmeinfo->network.SupportedRates[i] == 0U) {
    goto ldv_55218;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: network.SupportedRates[%d]=%02X\n", i, (int )pmlmeinfo->network.SupportedRates[i]);
  } else {
  }
  i = i + 1U;
  ldv_55220: ;
  if (i <= 15U) {
    goto ldv_55219;
  } else {
  }
  ldv_55218:
  i = 0U;
  goto ldv_55227;
  ldv_55226: ;
  if ((unsigned int )pmlmeinfo->network.SupportedRates[i] == 0U) {
    goto ldv_55221;
  } else {
  }
  j = 0U;
  goto ldv_55224;
  ldv_55223: ;
  if (((unsigned int )pmlmeinfo->network.SupportedRates[i] | 128U) == ((unsigned int )sta_bssrate[j] | 128U)) {
    goto ldv_55222;
  } else {
  }
  j = j + 1U;
  ldv_55224: ;
  if ((unsigned int )sta_bssrate_len > j) {
    goto ldv_55223;
  } else {
  }
  ldv_55222: ;
  if ((unsigned int )sta_bssrate_len == j) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): the rate[%d]=%02X is not supported by STA!\n",
             "issue_assocreq", i, (int )pmlmeinfo->network.SupportedRates[i]);
    } else {
    }
  } else {
    tmp___5 = index;
    index = index + 1U;
    bssrate[tmp___5] = pmlmeinfo->network.SupportedRates[i];
  }
  i = i + 1U;
  ldv_55227: ;
  if (i <= 15U) {
    goto ldv_55226;
  } else {
  }
  ldv_55221:
  bssrate_len = (int )index;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bssrate_len = %d\n", bssrate_len);
  } else {
  }
  if (bssrate_len == 0) {
    rtw_free_xmitbuf23a(pxmitpriv, pmgntframe->pxmitbuf);
    rtw_free_xmitframe23a(pxmitpriv, pmgntframe);
    goto exit;
  } else {
  }
  if (bssrate_len > 8) {
    tmp___6 = rtw_set_ie23a(pframe, 1, 8U, (u8 const *)(& bssrate), & pattrib->pktlen);
    pframe = tmp___6;
    tmp___7 = rtw_set_ie23a(pframe, 50, (uint )(bssrate_len + -8), (u8 const *)(& bssrate) + 8U,
                            & pattrib->pktlen);
    pframe = tmp___7;
  } else {
    tmp___8 = rtw_set_ie23a(pframe, 1, (uint )bssrate_len, (u8 const *)(& bssrate),
                            & pattrib->pktlen);
    pframe = tmp___8;
  }
  bcn_fixed_size = 12;
  pie = (u8 *)(& pmlmeinfo->network.IEs) + (unsigned long )bcn_fixed_size;
  pie_len = (int )(pmlmeinfo->network.IELength - (u32 )bcn_fixed_size);
  p = cfg80211_find_ie(48, (u8 const *)pie, pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
    tmp___9 = rtw_set_ie23a(pframe, 48, (uint )*(p + 1UL), p + 2UL, & pattrib->pktlen);
    pframe = tmp___9;
  } else {
  }
  if (padapter->mlmepriv.htpriv.ht_option == 1U) {
    p = cfg80211_find_ie(45, (u8 const *)pie, pie_len);
    if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
      tmp___13 = is_ap_in_tkip23a(padapter);
      if (tmp___13) {
        tmp___14 = 0;
      } else {
        tmp___14 = 1;
      }
      if (tmp___14) {
        __len___0 = 32UL;
        if (__len___0 > 63UL) {
          __ret___0 = memcpy((void *)(& pmlmeinfo->HT_caps), (void const *)p + 2U,
                               __len___0);
        } else {
          __ret___0 = memcpy((void *)(& pmlmeinfo->HT_caps), (void const *)p + 2U,
                                       __len___0);
        }
        if ((unsigned int )pregpriv->cbw40_enable == 0U) {
          pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 65469U;
        } else {
          pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info | 2U;
        }
        pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info | 12U;
        rf_type = rtl8723a_get_rf_type(padapter);
        switch ((int )rf_type) {
        case 3: ;
        if ((unsigned int )pregpriv->rx_stbc != 0U) {
          pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info | 256U;
        } else {
        }
        __len___1 = 16UL;
        if (__len___1 > 63UL) {
          __ret___1 = memcpy((void *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate),
                               (void const *)(& MCS_rate_1R23A), __len___1);
        } else {
          __ret___1 = memcpy((void *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate),
                                       (void const *)(& MCS_rate_1R23A), __len___1);
        }
        goto ldv_55235;
        case 2: ;
        case 0: ;
        default: ;
        if ((((unsigned int )pregpriv->rx_stbc == 3U || (((int )pmlmeext->cur_wireless_mode & 8) != 0 && (unsigned int )pregpriv->rx_stbc == 1U)) || (((int )pmlmeext->cur_wireless_mode & 16) != 0 && (unsigned int )pregpriv->rx_stbc == 2U)) || (unsigned int )pregpriv->wifi_spec == 1U) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: declare supporting RX STBC\n");
          } else {
          }
          pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info | 512U;
        } else {
        }
        __len___2 = 16UL;
        if (__len___2 > 63UL) {
          __ret___2 = memcpy((void *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate),
                               (void const *)(& MCS_rate_2R23A), __len___2);
        } else {
          __ret___2 = memcpy((void *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate),
                                       (void const *)(& MCS_rate_2R23A), __len___2);
        }
        goto ldv_55235;
        }
        ldv_55235:
        pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info;
        tmp___10 = rtl8723a_BT_coexist(padapter);
        if ((int )tmp___10) {
          tmp___11 = rtl8723a_BT_using_antenna_1(padapter);
          if ((int )tmp___11) {
            pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 252U;
          } else {
          }
        } else {
        }
        tmp___12 = rtw_set_ie23a(pframe, 45, (uint )*(p + 1UL), (u8 const *)(& pmlmeinfo->HT_caps),
                                 & pattrib->pktlen);
        pframe = tmp___12;
      } else {
      }
    } else {
    }
  } else {
  }
  i = (unsigned int )bcn_fixed_size;
  goto ldv_55247;
  ldv_55246:
  p = (u8 const *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
  switch ((int )*p) {
  case 221:
  tmp___17 = memcmp((void const *)p + 2U, (void const *)(& RTW_WPA_OUI23A_TYPE),
                    4UL);
  if (tmp___17 == 0) {
    goto _L;
  } else {
    tmp___18 = memcmp((void const *)p + 2U, (void const *)(& WMM_OUI23A), 4UL);
    if (tmp___18 == 0) {
      goto _L;
    } else {
      tmp___19 = memcmp((void const *)p + 2U, (void const *)(& WPS_OUI23A), 4UL);
      if (tmp___19 == 0) {
        _L:
        plen = *(p + 1UL);
        if ((unsigned int )padapter->registrypriv.wifi_spec == 0U) {
          tmp___15 = memcmp((void const *)p + 2U, (void const *)(& WPS_OUI23A),
                            4UL);
          if (tmp___15 == 0) {
            plen = 14U;
          } else {
          }
        } else {
        }
        tmp___16 = rtw_set_ie23a(pframe, 221, (uint )plen, p + 2UL, & pattrib->pktlen);
        pframe = tmp___16;
      } else {
      }
    }
  }
  goto ldv_55244;
  default: ;
  goto ldv_55244;
  }
  ldv_55244:
  i = ((unsigned int )*(p + 1UL) + i) + 2U;
  ldv_55247: ;
  if (pmlmeinfo->network.IELength > i) {
    goto ldv_55246;
  } else {
  }
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 1U) {
    tmp___20 = rtw_set_ie23a(pframe, 221, 6U, (u8 const *)(& REALTEK_96B_IE), & pattrib->pktlen);
    pframe = tmp___20;
  } else {
  }
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  ret = 1;
  exit:
  pmlmepriv->assoc_req_len = 0U;
  if (ret == 1) {
    kfree((void const *)pmlmepriv->assoc_req);
    tmp___21 = kmalloc((size_t )pattrib->pktlen, 32U);
    pmlmepriv->assoc_req = (u8 *)tmp___21;
    if ((unsigned long )pmlmepriv->assoc_req != (unsigned long )((u8 *)0U)) {
      __len___3 = (size_t )pattrib->pktlen;
      __ret___3 = memcpy((void *)pmlmepriv->assoc_req, (void const *)pwlanhdr,
                                   __len___3);
      pmlmepriv->assoc_req_len = pattrib->pktlen;
    } else {
    }
  } else {
    kfree((void const *)pmlmepriv->assoc_req);
  }
  return;
}
}
static int _issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                              int wait_ack )
{
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;
  {
  ret = 0;
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    goto exit;
  } else {
  }
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->retry_ctrl = 0U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 72U;
  if ((pmlmeinfo->state & 3U) == 3U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  } else
  if ((pmlmeinfo->state & 3U) == 2U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  } else {
  }
  if (power_mode != 0U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  } else {
  }
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)da);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___0);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  pattrib->last_txcmdsz = pattrib->pktlen;
  if (wait_ack != 0) {
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
    ret = 1;
  }
  exit: ;
  return (ret);
}
}
int issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                      int try_cnt , int wait_ms )
{
  int ret ;
  int i ;
  unsigned long start ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  unsigned int tmp___0 ;
  u8 tmp___1 ;
  unsigned int tmp___2 ;
  u8 tmp___3 ;
  {
  i = 0;
  start = jiffies;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned long )da == (unsigned long )((unsigned char *)0U)) {
    tmp = get_my_bssid23a(& pmlmeinfo->network);
    da = tmp;
  } else {
  }
  ldv_55280:
  ret = _issue_nulldata23a(padapter, da, power_mode, wait_ms > 0);
  i = i + 1;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto ldv_55279;
  } else {
  }
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
    msleep((unsigned int )wait_ms);
  } else {
  }
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
    goto ldv_55280;
  } else {
  }
  ldv_55279: ;
  if (ret != 0) {
    ret = 1;
    goto exit;
  } else {
  }
  if (try_cnt != 0 && wait_ms != 0) {
    if ((unsigned long )da != (unsigned long )((unsigned char *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
        tmp___1 = rtw_get_oper_ch23a(padapter);
        printk("\016RTL8723AU: %s(%s): to %02x:%02x:%02x:%02x:%02x:%02x, ch:%u%s, %d/%d in %u ms\n",
               "issue_nulldata23a", (char *)(& (padapter->pnetdev)->name), (int )*da,
               (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
               (int )*(da + 5UL), (int )tmp___1, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp___0);
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
      tmp___3 = rtw_get_oper_ch23a(padapter);
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_nulldata23a",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___3, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___2);
    } else {
    }
  } else {
  }
  exit: ;
  return (ret);
}
}
static int _issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da ,
                                  u16 tid , int wait_ack )
{
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_qos_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;
  {
  ret = 0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "_issue_qos_nulldata23a");
  } else {
  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 2U;
  pattrib->qos_en = 1U;
  pattrib->eosp = 1U;
  pattrib->ack_policy = 0U;
  pattrib->mdata = 0U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_qos_hdr *)pframe;
  pwlanhdr->frame_control = 200U;
  if ((pmlmeinfo->state & 3U) == 3U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  } else
  if ((pmlmeinfo->state & 3U) == 2U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  } else {
  }
  if ((unsigned int )pattrib->mdata != 0U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 8192U);
  } else {
  }
  pwlanhdr->qos_ctrl = (unsigned int )tid & 15U;
  pwlanhdr->qos_ctrl = (__le16 )((int )((short )pwlanhdr->qos_ctrl) | ((int )((short )((int )pattrib->ack_policy << 5)) & 96));
  if ((unsigned int )pattrib->eosp != 0U) {
    pwlanhdr->qos_ctrl = (__le16 )((unsigned int )pwlanhdr->qos_ctrl | 16U);
  } else {
  }
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)da);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___0);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 26UL;
  pattrib->pktlen = 26U;
  pattrib->last_txcmdsz = pattrib->pktlen;
  if (wait_ack != 0) {
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
    ret = 1;
  }
  exit: ;
  return (ret);
}
}
int issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , u16 tid ,
                          int try_cnt , int wait_ms )
{
  int ret ;
  int i ;
  unsigned long start ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  unsigned int tmp___0 ;
  u8 tmp___1 ;
  unsigned int tmp___2 ;
  u8 tmp___3 ;
  {
  i = 0;
  start = jiffies;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned long )da == (unsigned long )((unsigned char *)0U)) {
    tmp = get_my_bssid23a(& pmlmeinfo->network);
    da = tmp;
  } else {
  }
  ldv_55312:
  ret = _issue_qos_nulldata23a(padapter, da, (int )tid, wait_ms > 0);
  i = i + 1;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto ldv_55311;
  } else {
  }
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
    msleep((unsigned int )wait_ms);
  } else {
  }
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
    goto ldv_55312;
  } else {
  }
  ldv_55311: ;
  if (ret != 0) {
    ret = 1;
    goto exit;
  } else {
  }
  if (try_cnt != 0 && wait_ms != 0) {
    if ((unsigned long )da != (unsigned long )((unsigned char *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
        tmp___1 = rtw_get_oper_ch23a(padapter);
        printk("\016RTL8723AU: %s(%s): to %02x:%02x:%02x:%02x:%02x:%02x, ch:%u%s, %d/%d in %u ms\n",
               "issue_qos_nulldata23a", (char *)(& (padapter->pnetdev)->name), (int )*da,
               (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
               (int )*(da + 5UL), (int )tmp___1, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp___0);
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
      tmp___3 = rtw_get_oper_ch23a(padapter);
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_qos_nulldata23a",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___3, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___2);
    } else {
    }
  } else {
  }
  exit: ;
  return (ret);
}
}
static int _issue_deauth(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ,
                         u8 wait_ack )
{
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int ret ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ret = 0;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->retry_ctrl = 0U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 192U;
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)da);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___0);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  reason = reason;
  tmp___1 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& reason), & pattrib->pktlen);
  pframe = tmp___1;
  pattrib->last_txcmdsz = pattrib->pktlen;
  if ((unsigned int )wait_ack != 0U) {
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
    dump_mgntframe23a(padapter, pmgntframe);
    ret = 1;
  }
  exit: ;
  return (ret);
}
}
int issue_deauth23a(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason )
{
  int tmp ;
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s to %02x:%02x:%02x:%02x:%02x:%02x\n", "issue_deauth23a",
           (int )*da, (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
           (int )*(da + 5UL));
  } else {
  }
  tmp = _issue_deauth(padapter, da, (int )reason, 0);
  return (tmp);
}
}
static int issue_deauth_ex(struct rtw_adapter *padapter , u8 *da , unsigned short reason ,
                           int try_cnt , int wait_ms )
{
  int ret ;
  int i ;
  unsigned long start ;
  unsigned int tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u8 tmp___2 ;
  {
  i = 0;
  start = jiffies;
  ldv_55347:
  ret = _issue_deauth(padapter, da, (int )reason, wait_ms > 0);
  i = i + 1;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    goto ldv_55346;
  } else {
  }
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
    msleep((unsigned int )wait_ms);
  } else {
  }
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
    goto ldv_55347;
  } else {
  }
  ldv_55346: ;
  if (ret != 0) {
    ret = 1;
    goto exit;
  } else {
  }
  if (try_cnt != 0 && wait_ms != 0) {
    if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        tmp = jiffies_to_msecs((unsigned long )jiffies - start);
        tmp___0 = rtw_get_oper_ch23a(padapter);
        printk("\016RTL8723AU: %s(%s): to %02x:%02x:%02x:%02x:%02x:%02x, ch:%u%s, %d/%d in %u ms\n",
               "issue_deauth_ex", (char *)(& (padapter->pnetdev)->name), (int )*da,
               (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
               (int )*(da + 5UL), (int )tmp___0, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp);
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      tmp___1 = jiffies_to_msecs((unsigned long )jiffies - start);
      tmp___2 = rtw_get_oper_ch23a(padapter);
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_deauth_ex",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___2, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___1);
    } else {
    }
  } else {
  }
  exit: ;
  return (ret);
}
}
void issue_action_spct_ch_switch23a(struct rtw_adapter *padapter , u8 *ra , u8 new_ch ,
                                    u8 ch_offset )
{
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u8 category ;
  u8 action ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 tmp___3 ;
  u8 *tmp___4 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): ra =%02x:%02x:%02x:%02x:%02x:%02x, ch:%u, offset:%u\n",
           "issue_action_spct_ch_switch23a", (char *)(& (padapter->pnetdev)->name),
           (int )*ra, (int )*(ra + 1UL), (int )*(ra + 2UL), (int )*(ra + 3UL), (int )*(ra + 4UL),
           (int )*(ra + 5UL), (int )new_ch, (int )ch_offset);
  } else {
  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    return;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 208U;
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)ra);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)ra);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  category = 0U;
  action = 4U;
  tmp___0 = rtw_set_fixed_ie23a(pframe, 1U, & category, & pattrib->pktlen);
  pframe = tmp___0;
  tmp___1 = rtw_set_fixed_ie23a(pframe, 1U, & action, & pattrib->pktlen);
  pframe = tmp___1;
  tmp___2 = rtw_set_ie23a_ch_switch(pframe, & pattrib->pktlen, 0, (int )new_ch, 0);
  pframe = tmp___2;
  tmp___3 = hal_ch_offset_to_secondary_ch_offset23a((int )ch_offset);
  tmp___4 = rtw_set_ie23a_secondary_ch_offset(pframe, & pattrib->pktlen, (int )tmp___3);
  pframe = tmp___4;
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
void issue_action_BA23a(struct rtw_adapter *padapter , unsigned char const *raddr ,
                        unsigned char action , unsigned short status )
{
  u8 category ;
  u16 start_seq ;
  u16 BA_para_set ;
  u16 reason_code ;
  u16 BA_timeout_value ;
  u16 BA_starting_seqctrl ;
  int max_rx_ampdu_factor ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  u8 *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct registry_priv *pregpriv ;
  u8 tendaAPMac[3U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  {
  category = 3U;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pstapriv = & padapter->stapriv;
  pregpriv = & padapter->registrypriv;
  tendaAPMac[0] = 200U;
  tendaAPMac[1] = 58U;
  tendaAPMac[2] = 53U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, category =%d, action =%d, status =%d\n", "issue_action_BA23a",
           (int )category, (int )action, (int )status);
  } else {
  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    return;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40UL;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 208U;
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), raddr);
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___0);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & category, & pattrib->pktlen);
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & action, & pattrib->pktlen);
  status = status;
  if ((unsigned int )category != 3U) {
    goto out;
  } else {
  }
  switch ((int )action) {
  case 0: ;
  ldv_55392:
  pmlmeinfo->dialogToken = (u8 )((int )pmlmeinfo->dialogToken + 1);
  if ((unsigned int )pmlmeinfo->dialogToken == 0U) {
    goto ldv_55392;
  } else {
  }
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & pmlmeinfo->dialogToken, & pattrib->pktlen);
  tmp___1 = rtl8723a_BT_coexist(padapter);
  if ((int )tmp___1) {
    tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
    if ((int )tmp___2) {
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor != 1U) {
        BA_para_set = 0U;
        BA_para_set = (u16 )((unsigned int )BA_para_set | 2U);
        BA_para_set = (u16 )(((int )((short )((int )status << 2)) & 60) | (int )((short )BA_para_set));
        BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
      } else {
        tmp___3 = memcmp((void const *)raddr, (void const *)(& tendaAPMac), 3UL);
        if (tmp___3 != 0) {
          BA_para_set = 0U;
          BA_para_set = (u16 )((unsigned int )BA_para_set | 2U);
          BA_para_set = (u16 )(((int )((short )((int )status << 2)) & 60) | (int )((short )BA_para_set));
          BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
        } else {
          BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
        }
      }
    } else {
      BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
    }
  } else {
    BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
  }
  BA_para_set = BA_para_set;
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_para_set), & pattrib->pktlen);
  BA_timeout_value = 5000U;
  BA_timeout_value = BA_timeout_value;
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_timeout_value),
                               & pattrib->pktlen);
  psta = rtw_get_stainfo23a(pstapriv, raddr);
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    start_seq = ((unsigned int )psta->sta_xmitpriv.txseq_tid[(int )status & 7] & 4095U) + 1U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: BA_starting_seqctrl = %d for TID =%d\n", (int )start_seq,
             (int )status & 7);
    } else {
    }
    psta->BA_starting_seqctrl[(int )status & 7] = start_seq;
    BA_starting_seqctrl = (int )start_seq << 4U;
  } else {
  }
  BA_starting_seqctrl = BA_starting_seqctrl;
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_starting_seqctrl),
                               & pattrib->pktlen);
  goto ldv_55394;
  case 1:
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & pmlmeinfo->ADDBA_req.dialog_token, & pattrib->pktlen);
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& status), & pattrib->pktlen);
  GetHalDefVar8192CUsb(padapter, 11, (void *)(& max_rx_ampdu_factor));
  if (max_rx_ampdu_factor == 3) {
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 4096);
  } else
  if (max_rx_ampdu_factor == 2) {
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 2048);
  } else
  if (max_rx_ampdu_factor == 1) {
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 1024);
  } else
  if (max_rx_ampdu_factor == 0) {
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 512);
  } else {
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 4096);
  }
  tmp___4 = rtl8723a_BT_coexist(padapter);
  if ((int )tmp___4) {
    tmp___5 = rtl8723a_BT_using_antenna_1(padapter);
    if ((int )tmp___5) {
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor != 1U) {
        BA_para_set = (unsigned int )BA_para_set & 63U;
        BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
      } else {
        tmp___6 = memcmp((void const *)raddr, (void const *)(& tendaAPMac), 3UL);
        if (tmp___6 != 0) {
          BA_para_set = (unsigned int )BA_para_set & 63U;
          BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
        } else {
        }
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )pregpriv->ampdu_amsdu == 0U) {
    BA_para_set = (unsigned int )BA_para_set & 65534U;
  } else
  if ((unsigned int )pregpriv->ampdu_amsdu == 1U) {
    BA_para_set = (unsigned int )BA_para_set | 1U;
  } else {
    BA_para_set = BA_para_set;
  }
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_para_set), & pattrib->pktlen);
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& pmlmeinfo->ADDBA_req.BA_timeout_value),
                               & pattrib->pktlen);
  goto ldv_55394;
  case 2:
  BA_para_set = (unsigned int )((u16 )((int )status << 3)) & 255U;
  BA_para_set = BA_para_set;
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_para_set), & pattrib->pktlen);
  reason_code = 37U;
  reason_code = reason_code;
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& reason_code), & pattrib->pktlen);
  goto ldv_55394;
  default: ;
  goto ldv_55394;
  }
  ldv_55394: ;
  out:
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
static void issue_action_BSSCoexistPacket(struct rtw_adapter *padapter )
{
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  unsigned char category ;
  unsigned char action ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  u8 *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct wlan_network *pnetwork ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct rtw_queue *queue ;
  u8 InfoContent[16U] ;
  unsigned int tmp ;
  u8 ICS[8U][15U] ;
  int i ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 iedata ;
  u8 const *p ;
  struct wlan_bssid_ex *pbss_network ;
  struct list_head const *__mptr ;
  int j ;
  int k ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  queue = & pmlmepriv->scanned_queue;
  InfoContent[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 16U) {
      break;
    } else {
    }
    InfoContent[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if (pmlmepriv->num_FortyMHzIntolerant == 0 || pmlmepriv->num_sta_no_ht == 0) {
    return;
  } else {
  }
  if ((unsigned int )pmlmeinfo->bwmode_updated != 0U) {
    return;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "issue_action_BSSCoexistPacket");
  } else {
  }
  category = 4U;
  action = 0U;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    return;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40UL;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 208U;
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)tmp___0);
  tmp___1 = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp___1);
  tmp___2 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___2);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pframe = pframe + 24UL;
  pattrib->pktlen = 24U;
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & category, & pattrib->pktlen);
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & action, & pattrib->pktlen);
  if (pmlmepriv->num_FortyMHzIntolerant > 0) {
    iedata = 4U;
    pframe = rtw_set_ie23a(pframe, 72, 1U, (u8 const *)(& iedata), & pattrib->pktlen);
  } else {
  }
  if (pmlmepriv->num_sta_no_ht <= 0) {
    goto out;
  } else {
  }
  memset((void *)(& ICS), 0, 120UL);
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  phead = get_list_head(queue);
  plist = phead->next;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_55428;
  ldv_55427:
  __mptr = (struct list_head const *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  pbss_network = & pnetwork->network;
  p = cfg80211_find_ie(45, (u8 const *)(& pbss_network->IEs) + 12U, (int )(pbss_network->IELength - 12U));
  if ((unsigned long )p == (unsigned long )((u8 const *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
    if (pbss_network->DSConfig == 0U || pbss_network->DSConfig > 14U) {
      goto ldv_55426;
    } else {
    }
    ICS[0][pbss_network->DSConfig] = 1U;
    if ((unsigned int )ICS[0][0] == 0U) {
      ICS[0][0] = 1U;
    } else {
    }
  } else {
  }
  ldv_55426:
  plist = ptmp;
  ptmp = plist->next;
  ldv_55428: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_55427;
  } else {
  }
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  i = 0;
  goto ldv_55436;
  ldv_55435: ;
  if ((unsigned int )ICS[i][0] == 1U) {
    k = 0;
    InfoContent[k] = (u8 )i;
    k = k + 1;
    j = 1;
    goto ldv_55433;
    ldv_55432: ;
    if ((unsigned int )ICS[i][j] == 1U) {
      if (k <= 15) {
        InfoContent[k] = (u8 )j;
        k = k + 1;
      } else {
      }
    } else {
    }
    j = j + 1;
    ldv_55433: ;
    if (j <= 14) {
      goto ldv_55432;
    } else {
    }
    pframe = rtw_set_ie23a(pframe, 73, (uint )k, (u8 const *)(& InfoContent), & pattrib->pktlen);
  } else {
  }
  i = i + 1;
  ldv_55436: ;
  if (i <= 7) {
    goto ldv_55435;
  } else {
  }
  out:
  pattrib->last_txcmdsz = pattrib->pktlen;
  dump_mgntframe23a(padapter, pmgntframe);
  return;
}
}
int send_delba23a(struct rtw_adapter *padapter , u8 initiator , u8 *addr )
{
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u16 tid ;
  {
  pstapriv = & padapter->stapriv;
  psta = (struct sta_info *)0;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((pmlmeinfo->state & 3U) != 3U) {
    if ((pmlmeinfo->state & 16384U) == 0U) {
      return (1);
    } else {
    }
  } else {
  }
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)addr);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (1);
  } else {
  }
  if ((unsigned int )initiator == 0U) {
    tid = 0U;
    goto ldv_55449;
    ldv_55448: ;
    if ((unsigned int )psta->recvreorder_ctrl[(int )tid].enable == 1U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: rx agg disable tid(%d)\n", (int )tid);
      } else {
      }
      issue_action_BA23a(padapter, (unsigned char const *)addr, 2, (int )((unsigned short )((int )((short )((int )tid << 1)) | (int )((short )initiator))) & 31);
      psta->recvreorder_ctrl[(int )tid].enable = 0U;
      psta->recvreorder_ctrl[(int )tid].indicate_seq = 65535U;
    } else {
    }
    tid = (u16 )((int )tid + 1);
    ldv_55449: ;
    if ((unsigned int )tid <= 15U) {
      goto ldv_55448;
    } else {
    }
  } else
  if ((unsigned int )initiator == 1U) {
    tid = 0U;
    goto ldv_55452;
    ldv_55451: ;
    if ((int )((unsigned long )psta->htpriv.agg_enable_bitmap >> (int )tid) & 1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: tx agg disable tid(%d)\n", (int )tid);
      } else {
      }
      issue_action_BA23a(padapter, (unsigned char const *)addr, 2, (int )((unsigned short )((int )((short )((int )tid << 1)) | (int )((short )initiator))) & 31);
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    } else {
    }
    tid = (u16 )((int )tid + 1);
    ldv_55452: ;
    if ((unsigned int )tid <= 15U) {
      goto ldv_55451;
    } else {
    }
  } else {
  }
  return (1);
}
}
int send_beacon23a(struct rtw_adapter *padapter )
{
  bool bxmitok ;
  int issue ;
  int poll ;
  unsigned long start ;
  unsigned int passing_time ;
  {
  issue = 0;
  poll = 0;
  start = jiffies;
  rtl8723a_bcn_valid(padapter);
  ldv_55464:
  issue_beacon23a(padapter, 100);
  issue = issue + 1;
  ldv_55462:
  yield();
  bxmitok = rtl8723a_get_bcn_valid(padapter);
  poll = poll + 1;
  if (((poll % 10 != 0 && ! bxmitok) && padapter->bSurpriseRemoved == 0) && padapter->bDriverStopped == 0) {
    goto ldv_55462;
  } else {
  }
  if (((! bxmitok && issue <= 99) && padapter->bSurpriseRemoved == 0) && padapter->bDriverStopped == 0) {
    goto ldv_55464;
  } else {
  }
  if (padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) {
    return (0);
  } else {
  }
  passing_time = jiffies_to_msecs((unsigned long )jiffies - start);
  if (! bxmitok) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s fail! %u ms\n", "send_beacon23a", passing_time);
    } else {
    }
    return (0);
  } else {
    if (passing_time > 100U || issue > 3) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s success, issue:%d, poll:%d, %u ms\n", "send_beacon23a",
               issue, poll, passing_time);
      } else {
      }
    } else {
    }
    return (1);
  }
}
}
bool IsLegal5GChannel(struct rtw_adapter *Adapter , u8 channel )
{
  int i ;
  u8 Channel_5G[45U] ;
  {
  i = 0;
  Channel_5G[0] = 36U;
  Channel_5G[1] = 38U;
  Channel_5G[2] = 40U;
  Channel_5G[3] = 42U;
  Channel_5G[4] = 44U;
  Channel_5G[5] = 46U;
  Channel_5G[6] = 48U;
  Channel_5G[7] = 50U;
  Channel_5G[8] = 52U;
  Channel_5G[9] = 54U;
  Channel_5G[10] = 56U;
  Channel_5G[11] = 58U;
  Channel_5G[12] = 60U;
  Channel_5G[13] = 62U;
  Channel_5G[14] = 64U;
  Channel_5G[15] = 100U;
  Channel_5G[16] = 102U;
  Channel_5G[17] = 104U;
  Channel_5G[18] = 106U;
  Channel_5G[19] = 108U;
  Channel_5G[20] = 110U;
  Channel_5G[21] = 112U;
  Channel_5G[22] = 114U;
  Channel_5G[23] = 116U;
  Channel_5G[24] = 118U;
  Channel_5G[25] = 120U;
  Channel_5G[26] = 122U;
  Channel_5G[27] = 124U;
  Channel_5G[28] = 126U;
  Channel_5G[29] = 128U;
  Channel_5G[30] = 130U;
  Channel_5G[31] = 132U;
  Channel_5G[32] = 134U;
  Channel_5G[33] = 136U;
  Channel_5G[34] = 138U;
  Channel_5G[35] = 140U;
  Channel_5G[36] = 149U;
  Channel_5G[37] = 151U;
  Channel_5G[38] = 153U;
  Channel_5G[39] = 155U;
  Channel_5G[40] = 157U;
  Channel_5G[41] = 159U;
  Channel_5G[42] = 161U;
  Channel_5G[43] = 163U;
  Channel_5G[44] = 165U;
  i = 0;
  goto ldv_55474;
  ldv_55473: ;
  if ((int )Channel_5G[i] == (int )channel) {
    return (1);
  } else {
  }
  i = i + 1;
  ldv_55474: ;
  if ((unsigned int )i <= 44U) {
    goto ldv_55473;
  } else {
  }
  return (0);
}
}
static void rtw_site_survey(struct rtw_adapter *padapter )
{
  unsigned char survey_channel ;
  enum rt_scan_type ScanType ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct rtw_ieee80211_channel *ch ;
  int i ;
  unsigned long tmp ;
  bool tmp___0 ;
  {
  survey_channel = 0U;
  ScanType = 0;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (pmlmeext->sitesurvey_res.channel_idx < (int )pmlmeext->sitesurvey_res.ch_num) {
    ch = (struct rtw_ieee80211_channel *)(& pmlmeext->sitesurvey_res.ch) + (unsigned long )pmlmeext->sitesurvey_res.channel_idx;
    survey_channel = (unsigned char )ch->hw_value;
    ScanType = (ch->flags & 2U) == 0U;
  } else {
  }
  if ((unsigned int )survey_channel != 0U) {
    if (pmlmeext->sitesurvey_res.channel_idx == 0) {
      set_channel_bwmode23a(padapter, (int )survey_channel, 0, 0);
    } else {
      SelectChannel23a(padapter, (int )survey_channel);
    }
    if ((unsigned int )ScanType == 1U) {
      i = 0;
      goto ldv_55486;
      ldv_55485: ;
      if ((unsigned int )pmlmeext->sitesurvey_res.ssid[i].ssid_len != 0U) {
        issue_probereq(padapter, (struct cfg80211_ssid *)(& pmlmeext->sitesurvey_res.ssid) + (unsigned long )i,
                       (u8 *)0U);
        issue_probereq(padapter, (struct cfg80211_ssid *)(& pmlmeext->sitesurvey_res.ssid) + (unsigned long )i,
                       (u8 *)0U);
      } else {
      }
      i = i + 1;
      ldv_55486: ;
      if (i <= 8) {
        goto ldv_55485;
      } else {
      }
      if (pmlmeext->sitesurvey_res.scan_mode == 1) {
        issue_probereq(padapter, (struct cfg80211_ssid *)0, (u8 *)0U);
        issue_probereq(padapter, (struct cfg80211_ssid *)0, (u8 *)0U);
      } else {
      }
    } else {
    }
    tmp = msecs_to_jiffies((unsigned int const )pmlmeext->chan_scan_time);
    ldv_mod_timer_538(& pmlmeext->survey_timer, tmp + (unsigned long )jiffies);
  } else {
    pmlmeext->sitesurvey_res.state = 4;
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
    Set_MSR23a(padapter, (int )((u8 )pmlmeinfo->state) & 3);
    rtl8723a_set_initial_gain(padapter, 255U);
    rtl8723a_odm_support_ability_restore(padapter);
    tmp___0 = is_client_associated_to_ap23a(padapter);
    if ((int )tmp___0) {
      issue_nulldata23a(padapter, (unsigned char *)0U, 0U, 3, 500);
    } else {
    }
    rtl8723a_mlme_sitesurvey(padapter, 0);
    report_surveydone_event23a(padapter);
    pmlmeext->chan_scan_time = 100U;
    pmlmeext->sitesurvey_res.state = 0;
    issue_action_BSSCoexistPacket(padapter);
    issue_action_BSSCoexistPacket(padapter);
    issue_action_BSSCoexistPacket(padapter);
  }
  return;
}
}
int collect_bss_info23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ,
                        struct wlan_bssid_ex *bssid )
{
  int i ;
  u8 const *p ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  unsigned int length ;
  u8 ie_offset ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u16 capab_info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  struct HT_info_element *HT_info ;
  u8 tmp___2 ;
  int tmp___3 ;
  __le16 *tmp___4 ;
  struct mlme_priv *pmlmepriv ;
  struct HT_caps_element *pHT_caps ;
  u8 tmp___5 ;
  {
  skb = precv_frame->pkt;
  mgmt = (struct ieee80211_mgmt *)skb->data;
  pregistrypriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  length = skb->len - 24U;
  if (length > 768U) {
    return (0);
  } else {
  }
  memset((void *)bssid, 0, 863UL);
  tmp___1 = ieee80211_is_beacon((int )mgmt->frame_control);
  if (tmp___1 != 0) {
    bssid->reserved = 1U;
    ie_offset = 36U;
    capab_info = mgmt->u.beacon.capab_info;
  } else {
    tmp___0 = ieee80211_is_probe_req((int )mgmt->frame_control);
    if (tmp___0 != 0) {
      ie_offset = 24U;
      bssid->reserved = 2U;
      capab_info = 0U;
    } else {
      tmp = ieee80211_is_probe_resp((int )mgmt->frame_control);
      if (tmp != 0) {
        ie_offset = 36U;
        bssid->reserved = 3U;
        capab_info = mgmt->u.probe_resp.capab_info;
      } else {
        bssid->reserved = 0U;
        ie_offset = 36U;
        capab_info = mgmt->u.beacon.capab_info;
      }
    }
  }
  ie_offset = (unsigned int )ie_offset - 24U;
  bssid->Length = length + 95U;
  bssid->IELength = length;
  __len = (size_t )bssid->IELength;
  __ret = memcpy((void *)(& bssid->IEs), (void const *)(& mgmt->u), __len);
  bssid->Rssi = (long )precv_frame->attrib.phy_info.RecvSignalPower;
  bssid->PhyInfo.SignalQuality = precv_frame->attrib.phy_info.SignalQuality;
  bssid->PhyInfo.SignalStrength = precv_frame->attrib.phy_info.SignalStrength;
  p = cfg80211_find_ie(0, (u8 const *)(& bssid->IEs) + (unsigned long )ie_offset,
                       (int )(bssid->IELength - (u32 )ie_offset));
  if ((unsigned long )p == (unsigned long )((u8 const *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: marc: cannot find SSID for survey event\n");
    } else {
    }
    return (0);
  } else {
  }
  if ((unsigned int )((unsigned char )*(p + 1UL)) > 32U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info23a",
             4763, (int )*(p + 1UL));
    } else {
    }
    return (0);
  } else {
  }
  __len___0 = (size_t )*(p + 1UL);
  __ret___0 = memcpy((void *)(& bssid->Ssid.ssid), (void const *)p + 2U,
                               __len___0);
  bssid->Ssid.ssid_len = *(p + 1UL);
  memset((void *)(& bssid->SupportedRates), 0, 16UL);
  i = 0;
  p = cfg80211_find_ie(1, (u8 const *)(& bssid->IEs) + (unsigned long )ie_offset,
                       (int )(bssid->IELength - (u32 )ie_offset));
  if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
    if ((unsigned int )((unsigned char )*(p + 1UL)) > 16U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info23a",
               4778, (int )*(p + 1UL));
      } else {
      }
      return (0);
    } else {
    }
    __len___1 = (size_t )*(p + 1UL);
    __ret___1 = memcpy((void *)(& bssid->SupportedRates), (void const *)p + 2U,
                                 __len___1);
    i = (int )*(p + 1UL);
  } else {
  }
  p = cfg80211_find_ie(50, (u8 const *)(& bssid->IEs) + (unsigned long )ie_offset,
                       (int )(bssid->IELength - (u32 )ie_offset));
  if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
    if ((int )*(p + 1UL) > 16 - i) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info23a",
               4790, (int )*(p + 1UL));
      } else {
      }
      return (0);
    } else {
    }
    __len___2 = (size_t )*(p + 1UL);
    __ret___2 = memcpy((void *)(& bssid->SupportedRates) + (unsigned long )i,
                                 (void const *)p + 2U, __len___2);
  } else {
  }
  if (bssid->IELength <= 11U) {
    return (0);
  } else {
  }
  p = cfg80211_find_ie(3, (u8 const *)(& bssid->IEs) + (unsigned long )ie_offset,
                       (int )(bssid->IELength - (u32 )ie_offset));
  bssid->DSConfig = 0U;
  if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
    bssid->DSConfig = (u32 )*(p + 2UL);
  } else {
    p = cfg80211_find_ie(61, (u8 const *)(& bssid->IEs) + (unsigned long )ie_offset,
                         (int )(bssid->IELength - (u32 )ie_offset));
    if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
      HT_info = (struct HT_info_element *)p + 2U;
      bssid->DSConfig = (u32 )HT_info->primary_channel;
    } else {
      tmp___2 = rtw_get_oper_ch23a(padapter);
      bssid->DSConfig = (u32 )tmp___2;
    }
  }
  tmp___3 = ieee80211_is_probe_req((int )mgmt->frame_control);
  if (tmp___3 != 0) {
    bssid->ifmode = 2;
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const *)(& mgmt->sa));
    bssid->Privacy = 1U;
    return (1);
  } else {
  }
  tmp___4 = rtw_get_beacon_interval23a_from_ie((u8 *)(& bssid->IEs));
  bssid->BeaconPeriod = get_unaligned_le16((void const *)tmp___4);
  if ((int )capab_info & 1) {
    bssid->ifmode = 2;
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const *)(& mgmt->sa));
  } else {
    bssid->ifmode = 1;
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const *)(& mgmt->bssid));
  }
  if (((unsigned long )capab_info & 16UL) != 0UL) {
    bssid->Privacy = 1U;
  } else {
    bssid->Privacy = 0U;
  }
  bssid->ATIMWindow = 0U;
  if ((unsigned int )pregistrypriv->wifi_spec == 1U && (unsigned int )pmlmeinfo->bwmode_updated == 0U) {
    pmlmepriv = & padapter->mlmepriv;
    p = cfg80211_find_ie(45, (u8 const *)(& bssid->IEs) + (unsigned long )ie_offset,
                         (int )(bssid->IELength - (u32 )ie_offset));
    if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      pHT_caps = (struct HT_caps_element *)p + 2U;
      if (((unsigned long )pHT_caps->u.HT_cap_element.HT_caps_info & 16384UL) != 0UL) {
        pmlmepriv->num_FortyMHzIntolerant = pmlmepriv->num_FortyMHzIntolerant + 1;
      } else {
      }
    } else {
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht + 1;
    }
  } else {
  }
  tmp___5 = rtw_get_oper_ch23a(padapter);
  if (bssid->DSConfig != (u32 )tmp___5) {
    bssid->PhyInfo.SignalQuality = 101U;
  } else {
  }
  return (1);
}
}
static void start_create_ibss(struct rtw_adapter *padapter )
{
  unsigned short caps ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  int tmp ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  pmlmeext->cur_channel = (unsigned char )pnetwork->DSConfig;
  pmlmeinfo->bcn_interval = get_beacon_interval23a(pnetwork);
  update_wireless_mode23a(padapter);
  caps = rtw_get_capability23a(pnetwork);
  update_capinfo23a(padapter, (int )caps);
  if (((int )caps & 2) != 0) {
    rtl8723a_set_sec_cfg(padapter, 207);
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, 0, 0);
    rtl8723a_SetBeaconRelatedRegisters(padapter);
    pmlmeinfo->state = 1U;
    Set_MSR23a(padapter, (int )((u8 )pmlmeinfo->state) & 3);
    tmp = send_beacon23a(padapter);
    if (tmp == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
        printk("\016issuing beacon frame fail....\n");
      } else {
      }
      report_join_res23a(padapter, -1);
      pmlmeinfo->state = 0U;
    } else {
      hw_var_set_bssid(padapter, (u8 *)(& padapter->registrypriv.dev_network.MacAddress));
      hw_var_set_mlme_join(padapter, 0);
      report_join_res23a(padapter, 1);
      pmlmeinfo->state = pmlmeinfo->state | 16384U;
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: invalid cap:%x\n", "start_create_ibss", (int )caps);
    } else {
    }
    return;
  }
  return;
}
}
static void start_clnt_join(struct rtw_adapter *padapter )
{
  unsigned short caps ;
  u8 val8 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  int beacon_timeout ;
  unsigned int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  pmlmeext->cur_channel = (unsigned char )pnetwork->DSConfig;
  pmlmeinfo->bcn_interval = get_beacon_interval23a(pnetwork);
  update_wireless_mode23a(padapter);
  caps = rtw_get_capability23a(pnetwork);
  update_capinfo23a(padapter, (int )caps);
  if ((int )caps & 1) {
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
    Set_MSR23a(padapter, 2);
    val8 = pmlmeinfo->auth_algo == 2U ? 204U : 207U;
    rtl8723a_set_sec_cfg(padapter, (int )val8);
    tmp = decide_wait_for_beacon_timeout23a((unsigned int )pmlmeinfo->bcn_interval);
    beacon_timeout = (int )tmp;
    tmp___0 = msecs_to_jiffies((unsigned int const )beacon_timeout);
    ldv_mod_timer_539(& pmlmeext->link_timer, tmp___0 + (unsigned long )jiffies);
    tmp___1 = msecs_to_jiffies((unsigned int const )(beacon_timeout + 2400));
    ldv_mod_timer_540(& padapter->mlmepriv.assoc_timer, tmp___1 + (unsigned long )jiffies);
    pmlmeinfo->state = 258U;
  } else
  if (((int )caps & 2) != 0) {
    Set_MSR23a(padapter, 1);
    rtl8723a_set_sec_cfg(padapter, 207);
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
    rtl8723a_SetBeaconRelatedRegisters(padapter);
    pmlmeinfo->state = 1U;
    report_join_res23a(padapter, 1);
  } else {
    return;
  }
  return;
}
}
static void start_clnt_auth(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ldv_del_timer_sync_541(& pmlmeext->link_timer);
  pmlmeinfo->state = pmlmeinfo->state & 4294967039U;
  pmlmeinfo->state = pmlmeinfo->state | 512U;
  pmlmeinfo->auth_seq = 1U;
  pmlmeinfo->reauth_count = 0U;
  pmlmeinfo->reassoc_count = 0U;
  pmlmeinfo->link_count = 0U;
  pmlmeext->retry = 0U;
  issue_deauth23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress), 3);
  if (GlobalDebugLevel23A != 0U) {
    printk("\016RTL8723AU: OLD_ERROR start auth\n");
  } else {
  }
  issue_auth(padapter, (struct sta_info *)0, 0);
  tmp = msecs_to_jiffies(300U);
  ldv_mod_timer_542(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
  return;
}
}
static void start_clnt_assoc(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ldv_del_timer_sync_543(& pmlmeext->link_timer);
  pmlmeinfo->state = pmlmeinfo->state & 4294966527U;
  pmlmeinfo->state = pmlmeinfo->state | 9216U;
  issue_assocreq(padapter);
  tmp = msecs_to_jiffies(300U);
  ldv_mod_timer_544(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
  return;
}
}
int receive_disconnect23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                          unsigned short reason )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  tmp = get_my_bssid23a(& pmlmeinfo->network);
  tmp___0 = ether_addr_equal((u8 const *)MacAddr, (u8 const *)tmp);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "receive_disconnect23a");
  } else {
  }
  if ((pmlmeinfo->state & 3U) == 2U) {
    if ((pmlmeinfo->state & 16384U) != 0U) {
      pmlmeinfo->state = 0U;
      report_del_sta_event23a(padapter, MacAddr, (int )reason);
    } else
    if ((pmlmeinfo->state & 9984U) != 0U) {
      pmlmeinfo->state = 0U;
      report_join_res23a(padapter, -2);
    } else {
    }
  } else {
  }
  return (1);
}
}
static void process_80211d(struct rtw_adapter *padapter , struct wlan_bssid_ex *bssid )
{
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct rt_channel_info *chplan_new ;
  u8 channel ;
  u8 i ;
  u8 const *ie ;
  u8 const *p ;
  struct rt_channel_plan chplan_ap ;
  struct rt_channel_info chplan_sta[38U] ;
  u8 country[4U] ;
  u8 fcn ;
  u8 noc ;
  u8 j ;
  u8 k ;
  size_t __len ;
  void *__ret ;
  u8 const *tmp ;
  u8 const *tmp___0 ;
  u8 tmp___1 ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  pregistrypriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned int )pregistrypriv->enable80211d != 0U && (unsigned int )pmlmeext->update_channel_plan_by_ap_done == 0U) {
    ie = cfg80211_find_ie(7, (u8 const *)(& bssid->IEs) + 12U, (int )(bssid->IELength - 12U));
    if ((unsigned long )ie == (unsigned long )((u8 const *)0U) || (unsigned int )((unsigned char )*(ie + 1UL)) <= 5U) {
      return;
    } else {
    }
    p = ie + 2UL;
    ie = ie + (unsigned long )*(ie + 1UL);
    ie = ie + 2UL;
    __len = 3UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& country), (void const *)p, __len);
    } else {
      __ret = memcpy((void *)(& country), (void const *)p, __len);
    }
    country[3] = 0U;
    p = p + 3UL;
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
      printk("\016%s: 802.11d country =%s\n", "process_80211d", (u8 *)(& country));
    } else {
    }
    i = 0U;
    goto ldv_55580;
    ldv_55579:
    tmp = p;
    p = p + 1;
    fcn = *tmp;
    tmp___0 = p;
    p = p + 1;
    noc = *tmp___0;
    p = p + 1;
    j = 0U;
    goto ldv_55577;
    ldv_55576: ;
    if ((unsigned int )fcn <= 14U) {
      channel = (int )fcn + (int )j;
    } else {
      channel = (unsigned int )j * 4U + (unsigned int )fcn;
    }
    tmp___1 = i;
    i = (u8 )((int )i + 1);
    chplan_ap.Channel[(int )tmp___1] = channel;
    j = (u8 )((int )j + 1);
    ldv_55577: ;
    if ((int )j < (int )noc) {
      goto ldv_55576;
    } else {
    }
    ldv_55580: ;
    if ((long )ie - (long )p > 2L) {
      goto ldv_55579;
    } else {
    }
    chplan_ap.Len = i;
    __len___0 = 304UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& chplan_sta), (void const *)(& pmlmeext->channel_set),
                           __len___0);
    } else {
      __ret___0 = memcpy((void *)(& chplan_sta), (void const *)(& pmlmeext->channel_set),
                                   __len___0);
    }
    memset((void *)(& pmlmeext->channel_set), 0, 304UL);
    chplan_new = (struct rt_channel_info *)(& pmlmeext->channel_set);
    k = 0U;
    j = k;
    i = j;
    if (((int )pregistrypriv->wireless_mode & 2) != 0) {
      ldv_55586: ;
      if (((unsigned int )i == 38U || (unsigned int )chplan_sta[(int )i].ChannelNum == 0U) || (unsigned int )chplan_sta[(int )i].ChannelNum > 14U) {
        goto ldv_55585;
      } else {
      }
      if ((int )chplan_ap.Len == (int )j || (unsigned int )chplan_ap.Channel[(int )j] > 14U) {
        goto ldv_55585;
      } else {
      }
      if ((int )chplan_sta[(int )i].ChannelNum == (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
        (chplan_new + (unsigned long )k)->ScanType = 1;
        i = (u8 )((int )i + 1);
        j = (u8 )((int )j + 1);
        k = (u8 )((int )k + 1);
      } else
      if ((int )chplan_sta[(int )i].ChannelNum < (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
        (chplan_new + (unsigned long )k)->ScanType = 0;
        i = (u8 )((int )i + 1);
        k = (u8 )((int )k + 1);
      } else
      if ((int )chplan_sta[(int )i].ChannelNum > (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
        (chplan_new + (unsigned long )k)->ScanType = 1;
        j = (u8 )((int )j + 1);
        k = (u8 )((int )k + 1);
      } else {
      }
      goto ldv_55586;
      ldv_55585: ;
      goto ldv_55588;
      ldv_55587:
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
      (chplan_new + (unsigned long )k)->ScanType = 0;
      i = (u8 )((int )i + 1);
      k = (u8 )((int )k + 1);
      ldv_55588: ;
      if (((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) && (unsigned int )chplan_sta[(int )i].ChannelNum <= 14U) {
        goto ldv_55587;
      } else {
      }
      goto ldv_55591;
      ldv_55590:
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
      (chplan_new + (unsigned long )k)->ScanType = 1;
      j = (u8 )((int )j + 1);
      k = (u8 )((int )k + 1);
      ldv_55591: ;
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] <= 14U) {
        goto ldv_55590;
      } else {
      }
    } else {
      goto ldv_55594;
      ldv_55593:
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
      (chplan_new + (unsigned long )k)->ScanType = chplan_sta[(int )i].ScanType;
      i = (u8 )((int )i + 1);
      k = (u8 )((int )k + 1);
      ldv_55594: ;
      if (((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) && (unsigned int )chplan_sta[(int )i].ChannelNum <= 14U) {
        goto ldv_55593;
      } else {
      }
      goto ldv_55597;
      ldv_55596:
      j = (u8 )((int )j + 1);
      ldv_55597: ;
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] <= 14U) {
        goto ldv_55596;
      } else {
      }
    }
    if (((int )pregistrypriv->wireless_mode & 4) != 0) {
      ldv_55600: ;
      if ((unsigned int )i == 38U || (unsigned int )chplan_sta[(int )i].ChannelNum == 0U) {
        goto ldv_55599;
      } else {
      }
      if ((int )chplan_ap.Len == (int )j || (unsigned int )chplan_ap.Channel[(int )j] == 0U) {
        goto ldv_55599;
      } else {
      }
      if ((int )chplan_sta[(int )i].ChannelNum == (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
        (chplan_new + (unsigned long )k)->ScanType = 1;
        i = (u8 )((int )i + 1);
        j = (u8 )((int )j + 1);
        k = (u8 )((int )k + 1);
      } else
      if ((int )chplan_sta[(int )i].ChannelNum < (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
        (chplan_new + (unsigned long )k)->ScanType = 0;
        i = (u8 )((int )i + 1);
        k = (u8 )((int )k + 1);
      } else
      if ((int )chplan_sta[(int )i].ChannelNum > (int )chplan_ap.Channel[(int )j]) {
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
        (chplan_new + (unsigned long )k)->ScanType = 1;
        j = (u8 )((int )j + 1);
        k = (u8 )((int )k + 1);
      } else {
      }
      goto ldv_55600;
      ldv_55599: ;
      goto ldv_55602;
      ldv_55601:
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
      (chplan_new + (unsigned long )k)->ScanType = 0;
      i = (u8 )((int )i + 1);
      k = (u8 )((int )k + 1);
      ldv_55602: ;
      if ((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) {
        goto ldv_55601;
      } else {
      }
      goto ldv_55605;
      ldv_55604:
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
      (chplan_new + (unsigned long )k)->ScanType = 1;
      j = (u8 )((int )j + 1);
      k = (u8 )((int )k + 1);
      ldv_55605: ;
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] != 0U) {
        goto ldv_55604;
      } else {
      }
    } else {
      goto ldv_55608;
      ldv_55607:
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
      (chplan_new + (unsigned long )k)->ScanType = chplan_sta[(int )i].ScanType;
      i = (u8 )((int )i + 1);
      k = (u8 )((int )k + 1);
      ldv_55608: ;
      if ((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) {
        goto ldv_55607;
      } else {
      }
    }
    pmlmeext->update_channel_plan_by_ap_done = 1U;
  } else {
  }
  channel = (u8 )bssid->DSConfig;
  chplan_new = (struct rt_channel_info *)(& pmlmeext->channel_set);
  i = 0U;
  goto ldv_55612;
  ldv_55611: ;
  if ((int )(chplan_new + (unsigned long )i)->ChannelNum == (int )channel) {
    if ((unsigned int )(chplan_new + (unsigned long )i)->ScanType == 0U) {
      if ((unsigned int )channel > 51U && (unsigned int )channel <= 144U) {
        goto ldv_55610;
      } else {
      }
      (chplan_new + (unsigned long )i)->ScanType = 1;
      if (GlobalDebugLevel23A > 5U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
        printk("\016%s: change channel %d scan type from passive to active\n", "process_80211d",
               (int )channel);
      } else {
      }
    } else {
    }
    goto ldv_55610;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55612: ;
  if ((unsigned int )i <= 37U && (unsigned int )(chplan_new + (unsigned long )i)->ChannelNum != 0U) {
    goto ldv_55611;
  } else {
  }
  ldv_55610: ;
  return;
}
}
void report_survey_event23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct survey_event *psurvey_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {
  }
  pmlmeext = & padapter->mlmeextpriv;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {
  }
  cmdsz = 871U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const *)pcmd_obj);
    return;
  } else {
  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 863U;
  pc2h_evt_hdr->ID = 8U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  psurvey_evt = (struct survey_event *)pevtcmd + 8U;
  tmp___2 = collect_bss_info23a(padapter, precv_frame, & psurvey_evt->bss);
  if (tmp___2 == 0) {
    kfree((void const *)pcmd_obj);
    kfree((void const *)pevtcmd);
    return;
  } else {
  }
  process_80211d(padapter, & psurvey_evt->bss);
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  pmlmeext->sitesurvey_res.bss_cnt = pmlmeext->sitesurvey_res.bss_cnt + 1;
  return;
}
}
void report_surveydone_event23a(struct rtw_adapter *padapter )
{
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct surveydone_event *psurveydone_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {
  }
  cmdsz = 12U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const *)pcmd_obj);
    return;
  } else {
  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 4U;
  pc2h_evt_hdr->ID = 9U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  psurveydone_evt = (struct surveydone_event *)pevtcmd + 8U;
  psurveydone_evt->bss_cnt = (unsigned int )pmlmeext->sitesurvey_res.bss_cnt;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: survey done event(%x)\n", psurveydone_evt->bss_cnt);
  } else {
  }
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  return;
}
}
void report_join_res23a(struct rtw_adapter *padapter , int res )
{
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct joinbss_event *pjoinbss_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  int tmp___2 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {
  }
  cmdsz = 936U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const *)pcmd_obj);
    return;
  } else {
  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 928U;
  pc2h_evt_hdr->ID = 10U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  pjoinbss_evt = (struct joinbss_event *)pevtcmd + 8U;
  __len = 863UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pjoinbss_evt->network.network), (void const *)(& pmlmeinfo->network),
                     __len);
  } else {
    __ret = memcpy((void *)(& pjoinbss_evt->network.network), (void const *)(& pmlmeinfo->network),
                             __len);
  }
  tmp___2 = res;
  pjoinbss_evt->network.aid = tmp___2;
  pjoinbss_evt->network.join_res = tmp___2;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: report_join_res23a(%d)\n", res);
  } else {
  }
  rtw_joinbss_event_prehandle23a(padapter, (u8 *)(& pjoinbss_evt->network));
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  return;
}
}
void report_del_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             unsigned short reason )
{
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct sta_info *psta ;
  int mac_id ;
  struct stadel_event *pdel_sta_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {
  }
  cmdsz = 20U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const *)pcmd_obj);
    return;
  } else {
  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 12U;
  pc2h_evt_hdr->ID = 12U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  pdel_sta_evt = (struct stadel_event *)pevtcmd + 8U;
  ether_addr_copy((u8 *)(& pdel_sta_evt->macaddr), (u8 const *)MacAddr);
  __len = 2UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pdel_sta_evt->rsvd), (void const *)(& reason), __len);
  } else {
    __ret = memcpy((void *)(& pdel_sta_evt->rsvd), (void const *)(& reason),
                             __len);
  }
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)MacAddr);
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    mac_id = (int )psta->mac_id;
  } else {
    mac_id = -1;
  }
  pdel_sta_evt->mac_id = mac_id;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: report_del_sta_event23a: delete STA, mac_id =%d\n", mac_id);
  } else {
  }
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  return;
}
}
void report_add_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             int cam_idx )
{
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct stassoc_event *padd_sta_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pcmdpriv = & padapter->cmdpriv;
  tmp = kzalloc(128UL, 32U);
  pcmd_obj = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
    return;
  } else {
  }
  cmdsz = 20U;
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
  pevtcmd = (u8 *)tmp___0;
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
    kfree((void const *)pcmd_obj);
    return;
  } else {
  }
  pcmd_obj->cmdcode = 56U;
  pcmd_obj->cmdsz = cmdsz;
  pcmd_obj->parmbuf = pevtcmd;
  pcmd_obj->rsp = (u8 *)0U;
  pcmd_obj->rspsz = 0U;
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
  pc2h_evt_hdr->len = 12U;
  pc2h_evt_hdr->ID = 11U;
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
  padd_sta_evt = (struct stassoc_event *)pevtcmd + 8U;
  ether_addr_copy((u8 *)(& padd_sta_evt->macaddr), (u8 const *)MacAddr);
  padd_sta_evt->cam_id = cam_idx;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: report_add_sta_event23a: add STA\n");
  } else {
  }
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
  return;
}
}
void update_sta_info23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  VCS_update23a(padapter, psta);
  if (pmlmepriv->htpriv.ht_option != 0U) {
    psta->htpriv.ht_option = 1U;
    psta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;
    tmp = support_short_GI23a(padapter, & pmlmeinfo->HT_caps);
    if (tmp != 0) {
      psta->htpriv.sgi = 1U;
    } else {
    }
    psta->qos_option = 1U;
  } else {
    psta->htpriv.ht_option = 0U;
    psta->htpriv.ampdu_enable = 0U;
    psta->htpriv.sgi = 0U;
    psta->qos_option = 0U;
  }
  psta->htpriv.bwmode = pmlmeext->cur_bwmode;
  psta->htpriv.ch_offset = pmlmeext->cur_ch_offset;
  psta->htpriv.agg_enable_bitmap = 0U;
  psta->htpriv.candidate_tid_bitmap = 0U;
  if (pmlmepriv->qos_option != 0U) {
    psta->qos_option = 1U;
  } else {
  }
  psta->state = 1U;
  return;
}
}
void mlmeext_joinbss_event_callback23a(struct rtw_adapter *padapter , int join_res )
{
  struct sta_info *psta ;
  struct sta_info *psta_bmc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_priv *pstapriv ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  pstapriv = & padapter->stapriv;
  if (join_res < 0) {
    hw_var_set_mlme_join(padapter, 1);
    hw_var_set_bssid(padapter, (u8 *)(& null_addr));
    update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
    goto exit_mlmeext_joinbss_event_callback23a;
  } else {
  }
  if ((pmlmeinfo->state & 3U) == 1U) {
    psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
    if ((unsigned long )psta_bmc != (unsigned long )((struct sta_info *)0)) {
      pmlmeinfo->FW_sta_info[psta_bmc->mac_id].psta = psta_bmc;
      update_bmc_sta_support_rate23a(padapter, psta_bmc->mac_id);
      Update_RA_Entry23a(padapter, psta_bmc);
    } else {
    }
  } else {
  }
  rtl8723a_odm_support_ability_set(padapter, 268435455U);
  update_IOT_info23a(padapter);
  HalSetBrateCfg23a(padapter, (u8 *)(& cur_network->SupportedRates));
  rtl8723a_set_beacon_interval(padapter, (int )pmlmeinfo->bcn_interval);
  update_capinfo23a(padapter, (int )pmlmeinfo->capability);
  WMMOnAssocRsp23a(padapter);
  HTOnAssocRsp23a(padapter);
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& cur_network->MacAddress));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
    psta->wireless_mode = pmlmeext->cur_wireless_mode;
    set_sta_rate23a(padapter, psta);
  } else {
  }
  hw_var_set_mlme_join(padapter, 2);
  if ((pmlmeinfo->state & 3U) == 2U) {
    rtw_correct_TSF(padapter);
  } else {
  }
  rtw_lps_ctrl_wk_cmd23a(padapter, 2, 0);
  exit_mlmeext_joinbss_event_callback23a: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: =>%s\n", "mlmeext_joinbss_event_callback23a");
  } else {
  }
  return;
}
}
void mlmeext_sta_add_event_callback23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "mlmeext_sta_add_event_callback23a");
  } else {
  }
  if ((pmlmeinfo->state & 3U) == 1U) {
    if ((pmlmeinfo->state & 16384U) != 0U) {
    } else {
      rtw_correct_TSF(padapter);
      tmp = send_beacon23a(padapter);
      if (tmp != 1) {
        pmlmeinfo->FW_sta_info[psta->mac_id].status = 0U;
        pmlmeinfo->state = pmlmeinfo->state ^ 1U;
        return;
      } else {
      }
      pmlmeinfo->state = pmlmeinfo->state | 16384U;
    }
    hw_var_set_mlme_join(padapter, 2);
  } else {
  }
  pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
  Update_RA_Entry23a(padapter, psta);
  update_sta_info23a(padapter, psta);
  return;
}
}
void mlmeext_sta_del_event_callback23a(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  bool tmp___0 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  tmp = is_client_associated_to_ap23a(padapter);
  if ((int )tmp) {
    goto _L;
  } else {
    tmp___0 = is_IBSS_empty23a(padapter);
    if ((int )tmp___0) {
      _L:
      hw_var_set_mlme_disconnect(padapter);
      hw_var_set_bssid(padapter, (u8 *)(& null_addr));
      update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
      pmlmeext->cur_bwmode = 0U;
      pmlmeext->cur_ch_offset = 0U;
      set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                            (int )pmlmeext->cur_bwmode);
      flush_all_cam_entry23a(padapter);
      pmlmeinfo->state = 0U;
      Set_MSR23a(padapter, 2);
      ldv_del_timer_sync_545(& pmlmeext->link_timer);
    } else {
    }
  }
  return;
}
}
static u8 chk_ap_is_alive(struct rtw_adapter *padapter , struct sta_info *psta )
{
  u8 ret ;
  {
  ret = 0U;
  if ((psta->sta_stats.rx_data_pkts == psta->sta_stats.last_rx_data_pkts && psta->sta_stats.rx_beacon_pkts == psta->sta_stats.last_rx_beacon_pkts) && psta->sta_stats.rx_probersp_pkts == psta->sta_stats.last_rx_probersp_pkts) {
    ret = 0U;
  } else {
    ret = 1U;
  }
  psta->sta_stats.last_rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts;
  psta->sta_stats.last_rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts;
  psta->sta_stats.last_rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts;
  psta->sta_stats.last_rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts;
  psta->sta_stats.last_rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts;
  psta->sta_stats.last_rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts;
  psta->sta_stats.last_rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts;
  psta->sta_stats.last_rx_data_pkts = psta->sta_stats.rx_data_pkts;
  return (ret);
}
}
void linked_status_chk23a(struct rtw_adapter *padapter )
{
  u32 i ;
  struct sta_info *psta ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_priv *pstapriv ;
  int tx_chk ;
  int rx_chk ;
  int rx_chk_limit ;
  bool is_p2p_enable ;
  u8 tmp ;
  u8 backup_oper_channel ;
  u8 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pstapriv = & padapter->stapriv;
  rtl8723a_sreset_linked_status_check(padapter);
  tmp___4 = is_client_associated_to_ap23a(padapter);
  if ((int )tmp___4) {
    tx_chk = 1;
    rx_chk = 1;
    rx_chk_limit = 4;
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pmlmeinfo->network.MacAddress));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      is_p2p_enable = 0;
      tmp = chk_ap_is_alive(padapter, psta);
      if ((unsigned int )tmp == 0U) {
        rx_chk = 0;
      } else {
      }
      if (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts) {
        tx_chk = 0;
      } else {
      }
      if ((unsigned int )pmlmeext->active_keep_alive_check != 0U && (rx_chk == 0 || tx_chk == 0)) {
        backup_oper_channel = 0U;
        tmp___0 = rtw_get_oper_ch23a(padapter);
        if ((int )tmp___0 != (int )pmlmeext->cur_channel) {
          backup_oper_channel = rtw_get_oper_ch23a(padapter);
          SelectChannel23a(padapter, (int )pmlmeext->cur_channel);
        } else {
        }
        if (rx_chk != 1) {
          issue_probereq_ex(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& psta->hwaddr),
                            3, 1);
        } else {
        }
        if (tx_chk != 1) {
          tmp___1 = pmlmeinfo->link_count;
          pmlmeinfo->link_count = pmlmeinfo->link_count + 1U;
          if (tmp___1 == 15U) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else
        _L___0:
        if (rx_chk != 1) {
          _L:
          tx_chk = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr),
                                     0U, 3, 1);
          if (tx_chk == 1 && ! is_p2p_enable) {
            rx_chk = 1;
          } else {
          }
        } else {
        }
        if ((unsigned int )backup_oper_channel != 0U) {
          SelectChannel23a(padapter, (int )backup_oper_channel);
        } else {
        }
      } else {
        if (rx_chk != 1) {
          if (pmlmeext->retry == 0U) {
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
          } else {
          }
        } else {
        }
        if (tx_chk != 1) {
          tmp___2 = pmlmeinfo->link_count;
          pmlmeinfo->link_count = pmlmeinfo->link_count + 1U;
          if (tmp___2 == 15U) {
            tx_chk = issue_nulldata23a(padapter, (unsigned char *)0U, 0U, 1, 0);
          } else {
          }
        } else {
        }
      }
      if (rx_chk == 0) {
        pmlmeext->retry = pmlmeext->retry + 1U;
        if (pmlmeext->retry > (u32 )rx_chk_limit) {
          if (GlobalDebugLevel23A != 0U) {
            printk("\016RTL8723AU: OLD_ERROR %s(%s): disconnect or roaming\n", "linked_status_chk23a",
                   (char *)(& (padapter->pnetdev)->name));
          } else {
          }
          receive_disconnect23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress),
                                65535);
          return;
        } else {
        }
      } else {
        pmlmeext->retry = 0U;
      }
      if (tx_chk == 0) {
        pmlmeinfo->link_count = pmlmeinfo->link_count & 15U;
      } else {
        pxmitpriv->last_tx_pkts = pxmitpriv->tx_pkts;
        pmlmeinfo->link_count = 0U;
      }
    } else {
    }
  } else {
    tmp___3 = is_client_associated_to_ibss23a(padapter);
    if ((int )tmp___3) {
      i = 2U;
      goto ldv_55731;
      ldv_55730: ;
      if (pmlmeinfo->FW_sta_info[i].status == 1U) {
        psta = pmlmeinfo->FW_sta_info[i].psta;
        if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
          goto ldv_55729;
        } else {
        }
        if ((u64 )pmlmeinfo->FW_sta_info[i].rx_pkt == (psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) {
          if (pmlmeinfo->FW_sta_info[i].retry <= 2U) {
            pmlmeinfo->FW_sta_info[i].retry = pmlmeinfo->FW_sta_info[i].retry + 1U;
          } else {
            pmlmeinfo->FW_sta_info[i].retry = 0U;
            pmlmeinfo->FW_sta_info[i].status = 0U;
            report_del_sta_event23a(padapter, (unsigned char *)(& psta->hwaddr), 65535);
          }
        } else {
          pmlmeinfo->FW_sta_info[i].retry = 0U;
          pmlmeinfo->FW_sta_info[i].rx_pkt = ((unsigned int )psta->sta_stats.rx_mgnt_pkts + (unsigned int )psta->sta_stats.rx_ctrl_pkts) + (unsigned int )psta->sta_stats.rx_data_pkts;
        }
      } else {
      }
      ldv_55729:
      i = i + 1U;
      ldv_55731: ;
      if (i <= 31U) {
        goto ldv_55730;
      } else {
      }
    } else {
    }
  }
  return;
}
}
static void survey_timer_hdl(unsigned long data )
{
  struct rtw_adapter *padapter ;
  struct cmd_obj *ph2c ;
  struct sitesurvey_parm *psurveyPara ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_ext_priv *pmlmeext ;
  void *tmp ;
  void *tmp___0 ;
  {
  padapter = (struct rtw_adapter *)data;
  pcmdpriv = & padapter->cmdpriv;
  pmlmeext = & padapter->mlmeextpriv;
  if (pmlmeext->sitesurvey_res.state > 1) {
    if (pmlmeext->sitesurvey_res.state == 3) {
      pmlmeext->sitesurvey_res.channel_idx = pmlmeext->sitesurvey_res.channel_idx + 1;
    } else {
    }
    if ((unsigned int )pmlmeext->scan_abort == 1U) {
      pmlmeext->sitesurvey_res.channel_idx = (int )pmlmeext->sitesurvey_res.ch_num;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s idx:%d\n", "survey_timer_hdl", pmlmeext->sitesurvey_res.channel_idx);
      } else {
      }
      pmlmeext->scan_abort = 0U;
    } else {
    }
    tmp = kzalloc(128UL, 32U);
    ph2c = (struct cmd_obj *)tmp;
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
      goto exit_survey_timer_hdl;
    } else {
    }
    tmp___0 = kzalloc(712UL, 32U);
    psurveyPara = (struct sitesurvey_parm *)tmp___0;
    if ((unsigned long )psurveyPara == (unsigned long )((struct sitesurvey_parm *)0)) {
      kfree((void const *)ph2c);
      goto exit_survey_timer_hdl;
    } else {
    }
    ph2c->cmdcode = 18U;
    ph2c->parmbuf = (u8 *)psurveyPara;
    ph2c->cmdsz = 712U;
    ph2c->rsp = (u8 *)0U;
    ph2c->rspsz = 0U;
    rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  } else {
  }
  exit_survey_timer_hdl: ;
  return;
}
}
static void link_timer_hdl(unsigned long data )
{
  struct rtw_adapter *padapter ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  {
  padapter = (struct rtw_adapter *)data;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((pmlmeinfo->state & 256U) != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link_timer_hdl:no beacon while connecting\n");
    } else {
    }
    pmlmeinfo->state = 0U;
    report_join_res23a(padapter, -3);
  } else
  if ((pmlmeinfo->state & 512U) != 0U) {
    pmlmeinfo->reauth_count = pmlmeinfo->reauth_count + 1U;
    if (pmlmeinfo->reauth_count > 4U) {
      pmlmeinfo->state = 0U;
      report_join_res23a(padapter, -1);
      return;
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link_timer_hdl: auth timeout and try again\n");
    } else {
    }
    pmlmeinfo->auth_seq = 1U;
    issue_auth(padapter, (struct sta_info *)0, 0);
    tmp = msecs_to_jiffies(300U);
    ldv_mod_timer_546(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
  } else
  if ((pmlmeinfo->state & 8192U) != 0U) {
    pmlmeinfo->reassoc_count = pmlmeinfo->reassoc_count + 1U;
    if (pmlmeinfo->reassoc_count > 4U) {
      pmlmeinfo->state = 0U;
      report_join_res23a(padapter, -2);
      return;
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link_timer_hdl: assoc timeout and try again\n");
    } else {
    }
    issue_assocreq(padapter);
    tmp___0 = msecs_to_jiffies(300U);
    ldv_mod_timer_547(& pmlmeext->link_timer, tmp___0 + (unsigned long )jiffies);
  } else {
  }
  return;
}
}
static void addba_timer_hdl(unsigned long data )
{
  struct sta_info *psta ;
  struct ht_priv *phtpriv ;
  {
  psta = (struct sta_info *)data;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {
  }
  phtpriv = & psta->htpriv;
  if (phtpriv->ht_option == 1U && phtpriv->ampdu_enable == 1U) {
    if ((unsigned int )phtpriv->candidate_tid_bitmap != 0U) {
      phtpriv->candidate_tid_bitmap = 0U;
    } else {
    }
  } else {
  }
  return;
}
}
void init_addba_retry_timer23a(struct sta_info *psta )
{
  {
  reg_timer_6(& psta->addba_retry_timer, & addba_timer_hdl, (unsigned long )psta);
  return;
}
}
void init_mlme_ext_timer23a(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  reg_timer_6(& pmlmeext->survey_timer, & survey_timer_hdl, (unsigned long )padapter);
  reg_timer_6(& pmlmeext->link_timer, & link_timer_hdl, (unsigned long )padapter);
  return;
}
}
int NULL_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  {
  return (0);
}
}
int setopmode_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  enum nl80211_iftype type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct setopmode_parm const *psetop ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  psetop = (struct setopmode_parm const *)pbuf;
  switch ((unsigned int )psetop->mode) {
  case 9U: ;
  case 3U:
  pmlmeinfo->state = 3U;
  type = 3;
  goto ldv_55775;
  case 8U: ;
  case 2U:
  pmlmeinfo->state = pmlmeinfo->state & 4294967292U;
  pmlmeinfo->state = pmlmeinfo->state | 2U;
  type = 2;
  goto ldv_55775;
  case 1U:
  type = 1;
  goto ldv_55775;
  default:
  type = 0;
  goto ldv_55775;
  }
  ldv_55775:
  hw_var_set_opmode(padapter, (int )((u8 )type));
  return (0);
}
}
int createbss_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_bssid_ex const *pparm ;
  size_t __len ;
  void *__ret ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  pparm = (struct wlan_bssid_ex const *)pbuf;
  if ((unsigned int )pparm->ifmode == 3U || (unsigned int )pparm->ifmode == 9U) {
    if (pmlmeinfo->state == 3U) {
      return (0);
    } else {
    }
  } else {
  }
  if ((unsigned int )pparm->ifmode == 1U) {
    rtw_joinbss_reset23a(padapter);
    pmlmeext->cur_bwmode = 0U;
    pmlmeext->cur_ch_offset = 0U;
    pmlmeinfo->ERP_enable = 0U;
    pmlmeinfo->WMM_enable = 0U;
    pmlmeinfo->HT_enable = 0U;
    pmlmeinfo->HT_caps_enable = 0U;
    pmlmeinfo->HT_info_enable = 0U;
    rtl8723a_odm_support_ability_backup(padapter);
    rtl8723a_odm_support_ability_clr(padapter, 0U);
    ldv_del_timer_sync_548(& pmlmeext->link_timer);
    flush_all_cam_entry23a(padapter);
    if ((unsigned int )pparm->IELength > 768U) {
      return (4);
    } else {
    }
    __len = 863UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)pnetwork, (void const *)pparm, __len);
    } else {
      __ret = memcpy((void *)pnetwork, (void const *)pparm, __len);
    }
    start_create_ibss(padapter);
  } else {
  }
  return (0);
}
}
int join_cmd_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_bssid_ex const *pparm ;
  struct HT_info_element *pht_info ;
  u32 i ;
  int bcn_fixed_size ;
  u8 *p ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  {
  pregpriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  pparm = (struct wlan_bssid_ex const *)pbuf;
  if ((pmlmeinfo->state & 16384U) != 0U) {
    if ((pmlmeinfo->state & 2U) != 0U) {
      issue_deauth_ex(padapter, (u8 *)(& pnetwork->MacAddress), 3, 5, 100);
    } else {
    }
    pmlmeinfo->state = 0U;
    flush_all_cam_entry23a(padapter);
    ldv_del_timer_sync_549(& pmlmeext->link_timer);
    Set_MSR23a(padapter, 2);
    hw_var_set_mlme_disconnect(padapter);
  } else {
  }
  rtw_joinbss_reset23a(padapter);
  pmlmeext->cur_bwmode = 0U;
  pmlmeext->cur_ch_offset = 0U;
  pmlmeinfo->ERP_enable = 0U;
  pmlmeinfo->WMM_enable = 0U;
  pmlmeinfo->HT_enable = 0U;
  pmlmeinfo->HT_caps_enable = 0U;
  pmlmeinfo->HT_info_enable = 0U;
  pmlmeinfo->bwmode_updated = 0U;
  if ((unsigned int )pparm->IELength > 768U) {
    return (4);
  } else {
  }
  __len = 863UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)pnetwork, (void const *)pbuf, __len);
  } else {
    __ret = memcpy((void *)pnetwork, (void const *)pbuf, __len);
  }
  bcn_fixed_size = 12;
  i = (u32 )bcn_fixed_size;
  goto ldv_55817;
  ldv_55816:
  p = (u8 *)(& pnetwork->IEs) + (unsigned long )i;
  switch ((int )*p) {
  case 221:
  tmp = memcmp((void const *)p + 2U, (void const *)(& WMM_OUI23A), 4UL);
  if (tmp == 0) {
    pmlmeinfo->WMM_enable = 1U;
  } else {
  }
  goto ldv_55808;
  case 45:
  pmlmeinfo->HT_caps_enable = 1U;
  goto ldv_55808;
  case 61:
  pmlmeinfo->HT_info_enable = 1U;
  pht_info = (struct HT_info_element *)p + 2U;
  if ((unsigned int )pregpriv->cbw40_enable != 0U && ((unsigned long )pht_info->infos[0] & 4UL) != 0UL) {
    pmlmeext->cur_bwmode = 1U;
    switch ((int )pht_info->infos[0] & 3) {
    case 1:
    pmlmeext->cur_ch_offset = 1U;
    goto ldv_55812;
    case 3:
    pmlmeext->cur_ch_offset = 2U;
    goto ldv_55812;
    default:
    pmlmeext->cur_ch_offset = 0U;
    goto ldv_55812;
    }
    ldv_55812: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: set ch/bw before connected\n");
    } else {
    }
  } else {
  }
  goto ldv_55808;
  default: ;
  goto ldv_55808;
  }
  ldv_55808:
  i = ((u32 )*(p + 1UL) + i) + 2U;
  ldv_55817: ;
  if (pnetwork->IELength > i) {
    goto ldv_55816;
  } else {
  }
  hw_var_set_bssid(padapter, (u8 *)(& pmlmeinfo->network.MacAddress));
  hw_var_set_mlme_join(padapter, 0);
  ldv_del_timer_sync_550(& pmlmeext->link_timer);
  start_clnt_join(padapter);
  return (0);
}
}
int disconnect_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct disconnect_parm const *param ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  bool tmp ;
  {
  param = (struct disconnect_parm const *)pbuf;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  tmp = is_client_associated_to_ap23a(padapter);
  if ((int )tmp) {
    issue_deauth_ex(padapter, (u8 *)(& pnetwork->MacAddress), 3, (int )((unsigned int )param->deauth_timeout_ms / 100U),
                    100);
  } else {
  }
  hw_var_set_mlme_disconnect(padapter);
  hw_var_set_bssid(padapter, (u8 *)(& null_addr));
  update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
    rtl8723a_set_bcn_func(padapter, 0);
  } else {
  }
  Set_MSR23a(padapter, 2);
  pmlmeinfo->state = 0U;
  pmlmeext->cur_bwmode = 0U;
  pmlmeext->cur_ch_offset = 0U;
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  flush_all_cam_entry23a(padapter);
  ldv_del_timer_sync_551(& pmlmeext->link_timer);
  rtw_free_uc_swdec_pending_queue23a(padapter);
  return (0);
}
}
static int rtw_scan_ch_decision(struct rtw_adapter *padapter , struct rtw_ieee80211_channel *out ,
                                u32 out_num , struct rtw_ieee80211_channel const *in ,
                                u32 in_num )
{
  int i ;
  int j ;
  int scan_ch_num ;
  int set_idx ;
  struct mlme_ext_priv *pmlmeext ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp ;
  int tmp___0 ;
  {
  scan_ch_num = 0;
  pmlmeext = & padapter->mlmeextpriv;
  memset((void *)out, 0, (unsigned long )out_num * 8UL);
  j = 0;
  i = 0;
  goto ldv_55844;
  ldv_55843: ;
  if ((unsigned int )((unsigned short )(in + (unsigned long )i)->hw_value) != 0U && ((unsigned int )(in + (unsigned long )i)->flags & 1U) == 0U) {
    set_idx = rtw_ch_set_search_ch23a((struct rt_channel_info *)(& pmlmeext->channel_set),
                                      (u32 const )(in + (unsigned long )i)->hw_value);
    if (set_idx >= 0) {
      __len = 8UL;
      if (__len > 63UL) {
        __ret = memcpy((void *)out + (unsigned long )j, (void const *)in + (unsigned long )i,
                         __len);
      } else {
        __ret = memcpy((void *)out + (unsigned long )j, (void const *)in + (unsigned long )i,
                                 __len);
      }
      if ((unsigned int )pmlmeext->channel_set[set_idx].ScanType == 0U) {
        (out + (unsigned long )j)->flags = (out + (unsigned long )j)->flags & 2U;
      } else {
      }
      j = j + 1;
    } else {
    }
  } else {
  }
  if ((u32 )j >= out_num) {
    goto ldv_55842;
  } else {
  }
  i = i + 1;
  ldv_55844: ;
  if ((u32 )i < in_num) {
    goto ldv_55843;
  } else {
  }
  ldv_55842: ;
  if (j == 0) {
    i = 0;
    goto ldv_55846;
    ldv_55845:
    (out + (unsigned long )i)->hw_value = (u16 )pmlmeext->channel_set[i].ChannelNum;
    if ((unsigned int )pmlmeext->channel_set[i].ScanType == 0U) {
      (out + (unsigned long )i)->flags = (out + (unsigned long )i)->flags & 2U;
    } else {
    }
    j = j + 1;
    i = i + 1;
    ldv_55846: ;
    if ((int )pmlmeext->max_chan_nums > i) {
      goto ldv_55845;
    } else {
    }
  } else {
  }
  if (padapter->setband == 2U) {
    i = 0;
    goto ldv_55849;
    ldv_55848: ;
    if ((unsigned int )(out + (unsigned long )i)->hw_value > 35U) {
      memset((void *)out + (unsigned long )i, 0, 8UL);
    } else {
      scan_ch_num = scan_ch_num + 1;
    }
    i = i + 1;
    ldv_55849: ;
    if (i < j) {
      goto ldv_55848;
    } else {
    }
    j = scan_ch_num;
  } else
  if (padapter->setband == 1U) {
    i = 0;
    goto ldv_55855;
    ldv_55854: ;
    if ((unsigned int )(out + (unsigned long )i)->hw_value > 35U) {
      __len___0 = 8UL;
      if (__len___0 > 63UL) {
        tmp = scan_ch_num;
        scan_ch_num = scan_ch_num + 1;
        __ret___0 = memcpy((void *)out + (unsigned long )tmp, (void const *)out + (unsigned long )i,
                             __len___0);
      } else {
        tmp___0 = scan_ch_num;
        scan_ch_num = scan_ch_num + 1;
        __ret___0 = memcpy((void *)out + (unsigned long )tmp___0, (void const *)out + (unsigned long )i,
                                     __len___0);
      }
    } else {
    }
    i = i + 1;
    ldv_55855: ;
    if (i < j) {
      goto ldv_55854;
    } else {
    }
    j = scan_ch_num;
  } else {
  }
  return (j);
}
}
int sitesurvey_cmd_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct mlme_ext_priv *pmlmeext ;
  struct sitesurvey_parm const *pparm ;
  u8 bdelayscan ;
  u32 initialgain ;
  u32 i ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  void *tmp___3 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pparm = (struct sitesurvey_parm const *)pbuf;
  bdelayscan = 0U;
  if (pmlmeext->sitesurvey_res.state == 0) {
    pmlmeext->sitesurvey_res.state = 1;
    pmlmeext->sitesurvey_res.bss_cnt = 0;
    pmlmeext->sitesurvey_res.channel_idx = 0;
    i = 0U;
    goto ldv_55870;
    ldv_55869: ;
    if ((unsigned int )((unsigned char )pparm->ssid[i].ssid_len) != 0U) {
      __len = 32UL;
      if (__len > 63UL) {
        __ret = memcpy((void *)(& pmlmeext->sitesurvey_res.ssid[i].ssid), (void const *)(& pparm->ssid[i].ssid),
                         __len);
      } else {
        __ret = memcpy((void *)(& pmlmeext->sitesurvey_res.ssid[i].ssid),
                                 (void const *)(& pparm->ssid[i].ssid), __len);
      }
      pmlmeext->sitesurvey_res.ssid[i].ssid_len = pparm->ssid[i].ssid_len;
    } else {
      pmlmeext->sitesurvey_res.ssid[i].ssid_len = 0U;
    }
    i = i + 1U;
    ldv_55870: ;
    if (i <= 8U) {
      goto ldv_55869;
    } else {
    }
    tmp = rtw_scan_ch_decision(padapter, (struct rtw_ieee80211_channel *)(& pmlmeext->sitesurvey_res.ch),
                               51U, (struct rtw_ieee80211_channel const *)(& pparm->ch),
                               (u32 )pparm->ch_num);
    pmlmeext->sitesurvey_res.ch_num = (u8 )tmp;
    pmlmeext->sitesurvey_res.scan_mode = pparm->scan_mode;
    tmp___1 = is_client_associated_to_ap23a(padapter);
    if ((int )tmp___1) {
      pmlmeext->sitesurvey_res.state = 2;
      tmp___0 = rtw_get_oper_ch23a(padapter);
      if ((int )tmp___0 != (int )pmlmeext->cur_channel) {
        SelectChannel23a(padapter, (int )pmlmeext->cur_channel);
      } else {
      }
      issue_nulldata23a(padapter, (unsigned char *)0U, 1U, 3, 500);
      bdelayscan = 1U;
    } else {
    }
    if ((unsigned int )bdelayscan != 0U) {
      tmp___2 = msecs_to_jiffies(50U);
      ldv_mod_timer_552(& pmlmeext->survey_timer, tmp___2 + (unsigned long )jiffies);
      return (0);
    } else {
    }
  } else {
  }
  if (pmlmeext->sitesurvey_res.state == 1 || pmlmeext->sitesurvey_res.state == 2) {
    rtl8723a_odm_support_ability_backup(padapter);
    rtl8723a_odm_support_ability_clr(padapter, 0U);
    tmp___3 = wdev_priv___0(padapter->rtw_wdev);
    if ((unsigned int )((struct rtw_wdev_priv *)tmp___3)->p2p_enabled == 1U) {
      initialgain = 48U;
    } else {
      initialgain = 30U;
    }
    rtl8723a_set_initial_gain(padapter, initialgain);
    Set_MSR23a(padapter, 0);
    rtl8723a_mlme_sitesurvey(padapter, 1);
    pmlmeext->sitesurvey_res.state = 3;
  } else {
  }
  rtw_site_survey(padapter);
  return (0);
}
}
int setauth_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct setauth_parm const *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pparm = (struct setauth_parm const *)pbuf;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )((unsigned char )pparm->mode) <= 3U) {
    pmlmeinfo->auth_algo = (u32 )pparm->mode;
  } else {
  }
  return (0);
}
}
int setkey_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  unsigned short ctrl ;
  struct setkey_parm const *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char null_sta[6U] ;
  {
  pparm = (struct setkey_parm const *)pbuf;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  null_sta[0] = 0U;
  null_sta[1] = 0U;
  null_sta[2] = 0U;
  null_sta[3] = 0U;
  null_sta[4] = 0U;
  null_sta[5] = 0U;
  if ((unsigned int )((unsigned char )pparm->set_tx) != 0U) {
    pmlmeinfo->key_index = (u32 )pparm->keyid;
  } else {
  }
  ctrl = (unsigned int )(((int )((unsigned short )pparm->algorithm) << 2U) | (int )((unsigned short )pparm->keyid)) | 32768U;
  if (GlobalDebugLevel23A != 0U) {
    printk("\016RTL8723AU: OLD_ERROR set group key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) keyid:%d\n",
           pparm->algorithm, (int )pparm->keyid);
  } else {
  }
  rtl8723a_cam_write(padapter, (int )pparm->keyid, (int )ctrl, (u8 const *)(& null_sta),
                     (u8 const *)(& pparm->key));
  rtl8723a_on_rcr_am(padapter);
  return (0);
}
}
int set_stakey_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  u16 ctrl ;
  u8 cam_id ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct set_stakey_parm const *pparm ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  {
  ctrl = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pparm = (struct set_stakey_parm const *)pbuf;
  cam_id = 4U;
  if (GlobalDebugLevel23A != 0U) {
    printk("\016RTL8723AU: OLD_ERROR set pairwise key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) camid:%d\n",
           pparm->algorithm, (int )cam_id);
  } else {
  }
  if ((pmlmeinfo->state & 3U) == 3U) {
    pstapriv = & padapter->stapriv;
    if ((unsigned int )pparm->algorithm == 0U) {
      clear_cam_entry23a(padapter, (int )pparm->id);
      return (1);
    } else {
    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pparm->addr));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      ctrl = (unsigned int )((int )((u16 )pparm->algorithm) << 2U) | 32768U;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: r871x_set_stakey_hdl23a(): enc_algorithm =%d\n", pparm->algorithm);
      } else {
      }
      if (psta->mac_id == 0U || psta->mac_id > 28U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: r871x_set_stakey_hdl23a():set_stakey failed, mac_id(aid) =%d\n",
                 psta->mac_id);
        } else {
        }
        return (5);
      } else {
      }
      cam_id = (unsigned int )((u8 )psta->mac_id) + 3U;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Write CAM, mac_addr =%x:%x:%x:%x:%x:%x, cam_entry =%d\n",
               (int )pparm->addr[0], (int )pparm->addr[1], (int )pparm->addr[2], (int )pparm->addr[3],
               (int )pparm->addr[4], (int )pparm->addr[5], (int )cam_id);
      } else {
      }
      rtl8723a_cam_write(padapter, (int )cam_id, (int )ctrl, (u8 const *)(& pparm->addr),
                         (u8 const *)(& pparm->key));
      return (1);
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: r871x_set_stakey_hdl23a(): sta has been free\n");
      } else {
      }
      return (5);
    }
  } else {
  }
  if ((unsigned int )pparm->algorithm == 0U) {
    clear_cam_entry23a(padapter, (int )pparm->id);
    return (0);
  } else {
  }
  ctrl = (unsigned int )((int )((u16 )pparm->algorithm) << 2U) | 32768U;
  rtl8723a_cam_write(padapter, (int )cam_id, (int )ctrl, (u8 const *)(& pparm->addr),
                     (u8 const *)(& pparm->key));
  pmlmeinfo->enc_algo = pparm->algorithm;
  return (0);
}
}
int add_ba_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct addBaReq_parm const *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_info *psta ;
  unsigned long tmp ;
  {
  pparm = (struct addBaReq_parm const *)pbuf;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pparm->addr));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (0);
  } else {
  }
  if (((pmlmeinfo->state & 16384U) != 0U && (unsigned int )pmlmeinfo->HT_enable != 0U) || (pmlmeinfo->state & 3U) == 3U) {
    issue_action_BA23a(padapter, (unsigned char const *)(& pparm->addr), 0, (int )((unsigned short )pparm->tid));
    tmp = msecs_to_jiffies(2000U);
    ldv_mod_timer_553(& psta->addba_retry_timer, tmp + (unsigned long )jiffies);
  } else {
    psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )pparm->tid)));
  }
  return (0);
}
}
int set_tx_beacon_cmd23a(struct rtw_adapter *padapter )
{
  struct cmd_obj *ph2c ;
  struct Tx_Beacon_param *ptxBeacon_parm ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 res ;
  int len_diff ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  {
  pcmdpriv = & padapter->cmdpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  res = 1U;
  len_diff = 0;
  tmp = kzalloc(128UL, 32U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0U;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(863UL, 32U);
  ptxBeacon_parm = (struct Tx_Beacon_param *)tmp___0;
  if ((unsigned long )ptxBeacon_parm == (unsigned long )((struct Tx_Beacon_param *)0)) {
    kfree((void const *)ph2c);
    res = 0U;
    goto exit;
  } else {
  }
  __len = 863UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& ptxBeacon_parm->network), (void const *)(& pmlmeinfo->network),
                     __len);
  } else {
    __ret = memcpy((void *)(& ptxBeacon_parm->network), (void const *)(& pmlmeinfo->network),
                             __len);
  }
  len_diff = update_hidden_ssid((u8 *)(& ptxBeacon_parm->network.IEs) + 12UL, ptxBeacon_parm->network.IELength - 12U,
                                (int )pmlmeinfo->hidden_ssid_mode);
  ptxBeacon_parm->network.IELength = ptxBeacon_parm->network.IELength + (u32 )len_diff;
  ph2c->cmdcode = 55U;
  ph2c->parmbuf = (u8 *)ptxBeacon_parm;
  ph2c->cmdsz = 863U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  tmp___1 = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  res = (u8 )tmp___1;
  exit: ;
  return ((int )res);
}
}
int mlme_evt_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  u8 evt_code ;
  u8 evt_seq ;
  u16 evt_sz ;
  struct C2HEvent_Header const *c2h ;
  void (*event_callback)(struct rtw_adapter * , u8 const * ) ;
  {
  c2h = (struct C2HEvent_Header const *)pbuf;
  evt_sz = c2h->len;
  evt_seq = c2h->seq;
  evt_code = c2h->ID;
  if ((unsigned int )evt_code > 24U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016\nEvent Code(%d) mismatch!\n", (int )evt_code);
    } else {
    }
    goto _abort_event_;
  } else {
  }
  if (wlanevents[(int )evt_code].parmsize != 0U && wlanevents[(int )evt_code].parmsize != (u32 )evt_sz) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
      printk("\016\nEvent(%d) Parm Size mismatch (%d vs %d)!\n", (int )evt_code, wlanevents[(int )evt_code].parmsize,
             (int )evt_sz);
    } else {
    }
    goto _abort_event_;
  } else {
  }
  event_callback = wlanevents[(int )evt_code].event_callback;
  (*event_callback)(padapter, pbuf + 8UL);
  _abort_event_: ;
  return (0);
}
}
int h2c_msg_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  {
  if ((unsigned long )pbuf == (unsigned long )((u8 const *)0U)) {
    return (4);
  } else {
  }
  return (0);
}
}
int tx_beacon_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct sta_info *psta_bmc ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct xmit_priv *pxmitpriv ;
  struct sta_priv *pstapriv ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  tmp = send_beacon23a(padapter);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: issue_beacon23a, fail!\n");
    } else {
    }
    return (4);
  } else {
    pxmitpriv = & padapter->xmitpriv;
    pstapriv = & padapter->stapriv;
    psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
    if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
      return (0);
    } else {
    }
    if ((int )pstapriv->tim_bitmap & 1 && psta_bmc->sleepq_len != 0U) {
      msleep(10U);
      spin_lock_bh(& pxmitpriv->lock);
      phead = get_list_head(& psta_bmc->sleep_q);
      plist = phead->next;
      ptmp = plist->next;
      goto ldv_55951;
      ldv_55950:
      __mptr = (struct list_head const *)plist;
      pxmitframe = (struct xmit_frame *)__mptr;
      list_del_init(& pxmitframe->list);
      psta_bmc->sleepq_len = psta_bmc->sleepq_len - 1U;
      if (psta_bmc->sleepq_len != 0U) {
        pxmitframe->attrib.mdata = 1U;
      } else {
        pxmitframe->attrib.mdata = 0U;
      }
      pxmitframe->attrib.triggered = 1U;
      pxmitframe->attrib.qsel = 17U;
      rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
      plist = ptmp;
      ptmp = plist->next;
      ldv_55951: ;
      if ((unsigned long )plist != (unsigned long )phead) {
        goto ldv_55950;
      } else {
      }
      spin_unlock_bh(& pxmitpriv->lock);
    } else {
    }
  }
  return (0);
}
}
int set_ch_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct set_ch_parm const *set_ch_parm ;
  struct mlme_ext_priv *pmlmeext ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned long )pbuf == (unsigned long )((u8 const *)0U)) {
    return (4);
  } else {
  }
  set_ch_parm = (struct set_ch_parm const *)pbuf;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): ch:%u, bw:%u, ch_offset:%u\n", "set_ch_hdl23a",
           (char *)(& (padapter->pnetdev)->name), (int )set_ch_parm->ch, (int )set_ch_parm->bw,
           (int )set_ch_parm->ch_offset);
  } else {
  }
  pmlmeext->cur_channel = set_ch_parm->ch;
  pmlmeext->cur_ch_offset = set_ch_parm->ch_offset;
  pmlmeext->cur_bwmode = set_ch_parm->bw;
  set_channel_bwmode23a(padapter, (int )set_ch_parm->ch, (int )set_ch_parm->ch_offset,
                        (int )set_ch_parm->bw);
  return (0);
}
}
int set_chplan_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct SetChannelPlan_param const *setChannelPlan_param ;
  struct mlme_ext_priv *pmlmeext ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned long )pbuf == (unsigned long )((u8 const *)0U)) {
    return (4);
  } else {
  }
  setChannelPlan_param = (struct SetChannelPlan_param const *)pbuf;
  pmlmeext->max_chan_nums = init_channel_set(padapter, (int )setChannelPlan_param->channel_plan,
                                             (struct rt_channel_info *)(& pmlmeext->channel_set));
  init_channel_list(padapter, (struct rt_channel_info *)(& pmlmeext->channel_set),
                    (int )pmlmeext->max_chan_nums, & pmlmeext->channel_list);
  return (0);
}
}
int led_blink_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  struct LedBlink_param *ledBlink_param ;
  {
  if ((unsigned long )pbuf == (unsigned long )((u8 const *)0U)) {
    return (4);
  } else {
  }
  ledBlink_param = (struct LedBlink_param *)pbuf;
  return (0);
}
}
int set_csa_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  {
  return (5);
}
}
int tdls_hdl23a(struct rtw_adapter *padapter , u8 const *pbuf )
{
  {
  return (5);
}
}
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_6_0 == 0 || ldv_timer_6_0 == 2) {
    ldv_timer_list_6_0 = timer;
    ldv_timer_list_6_0->data = data;
    ldv_timer_6_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_6_1 == 0 || ldv_timer_6_1 == 2) {
    ldv_timer_list_6_1 = timer;
    ldv_timer_list_6_1->data = data;
    ldv_timer_6_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_6_2 == 0 || ldv_timer_6_2 == 2) {
    ldv_timer_list_6_2 = timer;
    ldv_timer_list_6_2->data = data;
    ldv_timer_6_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_6_3 == 0 || ldv_timer_6_3 == 2) {
    ldv_timer_list_6_3 = timer;
    ldv_timer_list_6_3->data = data;
    ldv_timer_6_3 = 1;
    return;
  } else {
  }
  return;
}
}
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& survey_timer_hdl)) {
    activate_suitable_timer_7(timer, data);
  } else {
  }
  return (0);
}
}
void disable_suitable_timer_8(struct timer_list *timer )
{
  {
  if (ldv_timer_8_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_0) {
    ldv_timer_8_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_8_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_1) {
    ldv_timer_8_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_8_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_2) {
    ldv_timer_8_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_8_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_3) {
    ldv_timer_8_3 = 0;
    return;
  } else {
  }
  return;
}
}
void timer_init_6(void)
{
  {
  ldv_timer_6_0 = 0;
  ldv_timer_6_1 = 0;
  ldv_timer_6_2 = 0;
  ldv_timer_6_3 = 0;
  return;
}
}
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_8_0 == (unsigned long )timer) {
    if (ldv_timer_8_0 == 2 || pending_flag != 0) {
      ldv_timer_list_8_0 = timer;
      ldv_timer_list_8_0->data = data;
      ldv_timer_8_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_8_1 == (unsigned long )timer) {
    if (ldv_timer_8_1 == 2 || pending_flag != 0) {
      ldv_timer_list_8_1 = timer;
      ldv_timer_list_8_1->data = data;
      ldv_timer_8_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_8_2 == (unsigned long )timer) {
    if (ldv_timer_8_2 == 2 || pending_flag != 0) {
      ldv_timer_list_8_2 = timer;
      ldv_timer_list_8_2->data = data;
      ldv_timer_8_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_8_3 == (unsigned long )timer) {
    if (ldv_timer_8_3 == 2 || pending_flag != 0) {
      ldv_timer_list_8_3 = timer;
      ldv_timer_list_8_3->data = data;
      ldv_timer_8_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_8(timer, data);
  return;
}
}
void ldv_timer_7(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  survey_timer_hdl(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void disable_suitable_timer_6(struct timer_list *timer )
{
  {
  if (ldv_timer_6_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_0) {
    ldv_timer_6_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_6_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_1) {
    ldv_timer_6_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_6_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_2) {
    ldv_timer_6_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_6_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_3) {
    ldv_timer_6_3 = 0;
    return;
  } else {
  }
  return;
}
}
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_6_0 == (unsigned long )timer) {
    if (ldv_timer_6_0 == 2 || pending_flag != 0) {
      ldv_timer_list_6_0 = timer;
      ldv_timer_list_6_0->data = data;
      ldv_timer_6_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_6_1 == (unsigned long )timer) {
    if (ldv_timer_6_1 == 2 || pending_flag != 0) {
      ldv_timer_list_6_1 = timer;
      ldv_timer_list_6_1->data = data;
      ldv_timer_6_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_6_2 == (unsigned long )timer) {
    if (ldv_timer_6_2 == 2 || pending_flag != 0) {
      ldv_timer_list_6_2 = timer;
      ldv_timer_list_6_2->data = data;
      ldv_timer_6_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_6_3 == (unsigned long )timer) {
    if (ldv_timer_6_3 == 2 || pending_flag != 0) {
      ldv_timer_list_6_3 = timer;
      ldv_timer_list_6_3->data = data;
      ldv_timer_6_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_6(timer, data);
  return;
}
}
void choose_timer_8(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_8_0 == 1) {
    ldv_timer_8_0 = 2;
    ldv_timer_8(ldv_timer_8_0, ldv_timer_list_8_0);
  } else {
  }
  goto ldv_56016;
  case 1: ;
  if (ldv_timer_8_1 == 1) {
    ldv_timer_8_1 = 2;
    ldv_timer_8(ldv_timer_8_1, ldv_timer_list_8_1);
  } else {
  }
  goto ldv_56016;
  case 2: ;
  if (ldv_timer_8_2 == 1) {
    ldv_timer_8_2 = 2;
    ldv_timer_8(ldv_timer_8_2, ldv_timer_list_8_2);
  } else {
  }
  goto ldv_56016;
  case 3: ;
  if (ldv_timer_8_3 == 1) {
    ldv_timer_8_3 = 2;
    ldv_timer_8(ldv_timer_8_3, ldv_timer_list_8_3);
  } else {
  }
  goto ldv_56016;
  default:
  ldv_stop();
  }
  ldv_56016: ;
  return;
}
}
void disable_suitable_timer_7(struct timer_list *timer )
{
  {
  if (ldv_timer_7_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_0) {
    ldv_timer_7_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_7_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_1) {
    ldv_timer_7_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_7_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_2) {
    ldv_timer_7_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_7_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_3) {
    ldv_timer_7_3 = 0;
    return;
  } else {
  }
  return;
}
}
int reg_timer_8(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& link_timer_hdl)) {
    activate_suitable_timer_8(timer, data);
  } else {
  }
  return (0);
}
}
void choose_timer_6(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_6_0 == 1) {
    ldv_timer_6_0 = 2;
    ldv_timer_6(ldv_timer_6_0, ldv_timer_list_6_0);
  } else {
  }
  goto ldv_56034;
  case 1: ;
  if (ldv_timer_6_1 == 1) {
    ldv_timer_6_1 = 2;
    ldv_timer_6(ldv_timer_6_1, ldv_timer_list_6_1);
  } else {
  }
  goto ldv_56034;
  case 2: ;
  if (ldv_timer_6_2 == 1) {
    ldv_timer_6_2 = 2;
    ldv_timer_6(ldv_timer_6_2, ldv_timer_list_6_2);
  } else {
  }
  goto ldv_56034;
  case 3: ;
  if (ldv_timer_6_3 == 1) {
    ldv_timer_6_3 = 2;
    ldv_timer_6(ldv_timer_6_3, ldv_timer_list_6_3);
  } else {
  }
  goto ldv_56034;
  default:
  ldv_stop();
  }
  ldv_56034: ;
  return;
}
}
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& addba_timer_hdl)) {
    activate_suitable_timer_6(timer, data);
  } else {
  }
  return (0);
}
}
void ldv_timer_6(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  addba_timer_hdl(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void timer_init_7(void)
{
  {
  ldv_timer_7_0 = 0;
  ldv_timer_7_1 = 0;
  ldv_timer_7_2 = 0;
  ldv_timer_7_3 = 0;
  return;
}
}
void ldv_timer_8(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  link_timer_hdl(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void choose_timer_7(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_7_0 == 1) {
    ldv_timer_7_0 = 2;
    ldv_timer_7(ldv_timer_7_0, ldv_timer_list_7_0);
  } else {
  }
  goto ldv_56060;
  case 1: ;
  if (ldv_timer_7_1 == 1) {
    ldv_timer_7_1 = 2;
    ldv_timer_7(ldv_timer_7_1, ldv_timer_list_7_1);
  } else {
  }
  goto ldv_56060;
  case 2: ;
  if (ldv_timer_7_2 == 1) {
    ldv_timer_7_2 = 2;
    ldv_timer_7(ldv_timer_7_2, ldv_timer_list_7_2);
  } else {
  }
  goto ldv_56060;
  case 3: ;
  if (ldv_timer_7_3 == 1) {
    ldv_timer_7_3 = 2;
    ldv_timer_7(ldv_timer_7_3, ldv_timer_list_7_3);
  } else {
  }
  goto ldv_56060;
  default:
  ldv_stop();
  }
  ldv_56060: ;
  return;
}
}
void timer_init_8(void)
{
  {
  ldv_timer_8_0 = 0;
  ldv_timer_8_1 = 0;
  ldv_timer_8_2 = 0;
  ldv_timer_8_3 = 0;
  return;
}
}
void activate_suitable_timer_8(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_8_0 == 0 || ldv_timer_8_0 == 2) {
    ldv_timer_list_8_0 = timer;
    ldv_timer_list_8_0->data = data;
    ldv_timer_8_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_8_1 == 0 || ldv_timer_8_1 == 2) {
    ldv_timer_list_8_1 = timer;
    ldv_timer_list_8_1->data = data;
    ldv_timer_8_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_8_2 == 0 || ldv_timer_8_2 == 2) {
    ldv_timer_list_8_2 = timer;
    ldv_timer_list_8_2->data = data;
    ldv_timer_8_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_8_3 == 0 || ldv_timer_8_3 == 2) {
    ldv_timer_list_8_3 = timer;
    ldv_timer_list_8_3->data = data;
    ldv_timer_8_3 = 1;
    return;
  } else {
  }
  return;
}
}
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_7_0 == (unsigned long )timer) {
    if (ldv_timer_7_0 == 2 || pending_flag != 0) {
      ldv_timer_list_7_0 = timer;
      ldv_timer_list_7_0->data = data;
      ldv_timer_7_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_7_1 == (unsigned long )timer) {
    if (ldv_timer_7_1 == 2 || pending_flag != 0) {
      ldv_timer_list_7_1 = timer;
      ldv_timer_list_7_1->data = data;
      ldv_timer_7_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_7_2 == (unsigned long )timer) {
    if (ldv_timer_7_2 == 2 || pending_flag != 0) {
      ldv_timer_list_7_2 = timer;
      ldv_timer_list_7_2->data = data;
      ldv_timer_7_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_7_3 == (unsigned long )timer) {
    if (ldv_timer_7_3 == 2 || pending_flag != 0) {
      ldv_timer_list_7_3 = timer;
      ldv_timer_list_7_3->data = data;
      ldv_timer_7_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_7(timer, data);
  return;
}
}
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_7_0 == 0 || ldv_timer_7_0 == 2) {
    ldv_timer_list_7_0 = timer;
    ldv_timer_list_7_0->data = data;
    ldv_timer_7_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_7_1 == 0 || ldv_timer_7_1 == 2) {
    ldv_timer_list_7_1 = timer;
    ldv_timer_list_7_1->data = data;
    ldv_timer_7_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_7_2 == 0 || ldv_timer_7_2 == 2) {
    ldv_timer_list_7_2 = timer;
    ldv_timer_list_7_2->data = data;
    ldv_timer_7_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_7_3 == 0 || ldv_timer_7_3 == 2) {
    ldv_timer_list_7_3 = timer;
    ldv_timer_list_7_3->data = data;
    ldv_timer_7_3 = 1;
    return;
  } else {
  }
  return;
}
}
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )
{
  {
  ldv_spin_unlock();
  ldv_spin_unlock_irqrestore_508(lock, flags);
  return;
}
}
__inline static void *kmalloc(size_t size , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  ldv_kmalloc_512(size, flags);
  return ((void *)0);
}
}
void *ldv_kmem_cache_alloc_516(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_522(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_524(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_526(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_527(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_528(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_529(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_530(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_531(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_532(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_del_timer_sync_533(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_534(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_535(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_536(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_537(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_538(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_539(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_540(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_541(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_542(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_543(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_544(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_545(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_546(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_547(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_548(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_549(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_550(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___19 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_551(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___20 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_552(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___21 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_553(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___22 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_617(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
void *ldv_kmem_cache_alloc_600(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct timer_list *ldv_timer_list_9_3 ;
int ldv_timer_9_1 ;
int ldv_timer_9_0 ;
int ldv_timer_9_3 ;
struct timer_list *ldv_timer_list_9_2 ;
int ldv_timer_9_2 ;
struct timer_list *ldv_timer_list_9_0 ;
struct timer_list *ldv_timer_list_9_1 ;
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void ldv_timer_9(int state , struct timer_list *timer ) ;
void timer_init_9(void) ;
void activate_suitable_timer_9(struct timer_list *timer , unsigned long data ) ;
int reg_timer_9(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void disable_suitable_timer_9(struct timer_list *timer ) ;
void choose_timer_9(void) ;
__inline static void sema_init(struct semaphore *sem , int val )
{
  struct lock_class_key __key ;
  struct semaphore __constr_expr_0 ;
  {
  __constr_expr_0.lock.raw_lock.ldv_1458.head_tail = 0U;
  __constr_expr_0.lock.magic = 3735899821U;
  __constr_expr_0.lock.owner_cpu = 4294967295U;
  __constr_expr_0.lock.owner = (void *)-1;
  __constr_expr_0.lock.dep_map.key = 0;
  __constr_expr_0.lock.dep_map.class_cache[0] = 0;
  __constr_expr_0.lock.dep_map.class_cache[1] = 0;
  __constr_expr_0.lock.dep_map.name = "(*sem).lock";
  __constr_expr_0.lock.dep_map.cpu = 0;
  __constr_expr_0.lock.dep_map.ip = 0UL;
  __constr_expr_0.count = (unsigned int )val;
  __constr_expr_0.wait_list.next = & sem->wait_list;
  __constr_expr_0.wait_list.prev = & sem->wait_list;
  *sem = __constr_expr_0;
  lockdep_init_map(& sem->lock.dep_map, "semaphore->lock", & __key, 0);
  return;
}
}
extern void down(struct semaphore * ) ;
extern void up(struct semaphore * ) ;
struct sk_buff *ldv_skb_clone_608(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_616(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_610(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_606(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_614(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_615(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_611(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_612(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_613(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
void rtl8723a_set_rpwm(struct rtw_adapter *padapter , u8 val ) ;
bool rtl8723a_get_fwlps_rf_on(struct rtw_adapter *padapter ) ;
void rtw_init_pwrctrl_priv23a(struct rtw_adapter *padapter ) ;
void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter ) ;
void rtw_set_ps_mode23a(struct rtw_adapter *padapter , u8 ps_mode , u8 smart_ps ,
                        u8 bcn_ant_mode ) ;
void rtw_set_rpwm23a(struct rtw_adapter *padapter , u8 pslv ) ;
void LeaveAllPowerSaveMode23a(struct rtw_adapter *Adapter ) ;
void ips_enter23a(struct rtw_adapter *padapter ) ;
int ips_leave23a(struct rtw_adapter *padapter ) ;
enum rt_rf_power_state RfOnOffDetect23a(struct rtw_adapter *pAdapter ) ;
s32 LPS_RF_ON_check23a(struct rtw_adapter *padapter , u32 delay_ms ) ;
int _rtw_pwr_wakeup23a(struct rtw_adapter *padapter , u32 ips_deffer_ms , char const *caller ) ;
int rtw_pm_set_ips23a(struct rtw_adapter *padapter , u8 mode ) ;
int rtw_pm_set_lps23a(struct rtw_adapter *padapter , u8 mode ) ;
int rtw_hw_suspend23a(struct rtw_adapter *padapter ) ;
int rtw_hw_resume23a(struct rtw_adapter *padapter ) ;
int rtw_ips_pwr_up23a(struct rtw_adapter *padapter ) ;
void rtw_ips_pwr_down23a(struct rtw_adapter *padapter ) ;
extern bool rtw_cfg80211_pwr_mgmt(struct rtw_adapter * ) ;
void rtl8723a_set_FwPwrMode_cmd(struct rtw_adapter *padapter , u8 Mode ) ;
void rtl8723a_BT_disable_coexist(struct rtw_adapter *padapter ) ;
bool rtw_sreset_inprogress(struct rtw_adapter *padapter ) ;
void ips_enter23a(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *pwrpriv ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  down(& pwrpriv->lock);
  pwrpriv->bips_processing = 1U;
  pwrpriv->ips_mode = pwrpriv->ips_mode_req;
  pwrpriv->ips_enter23a_cnts = pwrpriv->ips_enter23a_cnts + 1U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ==>ips_enter23a cnts:%d\n", pwrpriv->ips_enter23a_cnts);
  } else {
  }
  rtl8723a_BT_disable_coexist(padapter);
  if ((unsigned int )pwrpriv->change_rfpwrstate == 2U) {
    pwrpriv->bpower_saving = 1U;
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: OLD_ERROR nolinked power save enter\n");
    } else {
    }
    if ((unsigned int )pwrpriv->ips_mode == 2U) {
      pwrpriv->bkeepfwalive = 1U;
    } else {
    }
    rtw_ips_pwr_down23a(padapter);
    pwrpriv->rf_pwrstate = 2;
  } else {
  }
  pwrpriv->bips_processing = 0U;
  up(& pwrpriv->lock);
  return;
}
}
int ips_leave23a(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *pwrpriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  int result ;
  int keyid ;
  u32 tmp ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmepriv = & padapter->mlmepriv;
  result = 1;
  down(& pwrpriv->lock);
  if ((unsigned int )pwrpriv->rf_pwrstate == 2U && pwrpriv->bips_processing == 0U) {
    pwrpriv->bips_processing = 1U;
    pwrpriv->change_rfpwrstate = 0;
    pwrpriv->ips_leave23a_cnts = pwrpriv->ips_leave23a_cnts + 1U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ==>ips_leave23a cnts:%d\n", pwrpriv->ips_leave23a_cnts);
    } else {
    }
    result = rtw_ips_pwr_up23a(padapter);
    if (result == 1) {
      pwrpriv->rf_pwrstate = 0;
    } else {
    }
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: OLD_ERROR nolinked power save leave\n");
    } else {
    }
    if (psecuritypriv->dot11PrivacyAlgrthm == 1027073U || psecuritypriv->dot11PrivacyAlgrthm == 1027077U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: ==>%s, channel(%d), processing(%x)\n", "ips_leave23a",
               (int )padapter->mlmeextpriv.cur_channel, pwrpriv->bips_processing);
      } else {
      }
      set_channel_bwmode23a(padapter, (int )padapter->mlmeextpriv.cur_channel, 0,
                            0);
      keyid = 0;
      goto ldv_54263;
      ldv_54262: ;
      if ((int )((unsigned long )pmlmepriv->key_mask >> keyid) & 1) {
        if ((u32 )keyid == psecuritypriv->dot11PrivacyKeyIndex) {
          result = rtw_set_key23a(padapter, psecuritypriv, keyid, 1);
        } else {
          result = rtw_set_key23a(padapter, psecuritypriv, keyid, 0);
        }
      } else {
      }
      keyid = keyid + 1;
      ldv_54263: ;
      if (keyid <= 3) {
        goto ldv_54262;
      } else {
      }
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      tmp = rtl8723au_read32(padapter, 76U);
      printk("\016RTL8723AU: ==> ips_leave23a.....LED(0x%08x)...\n", tmp);
    } else {
    }
    pwrpriv->bips_processing = 0U;
    pwrpriv->bkeepfwalive = 0U;
    pwrpriv->bpower_saving = 0U;
  } else {
  }
  up(& pwrpriv->lock);
  return (result);
}
}
static bool rtw_pwr_unassociated_idle(struct rtw_adapter *adapter )
{
  struct rtw_adapter *buddy ;
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmit_priv ;
  bool ret ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  struct mlme_priv *b_pmlmepriv ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  {
  buddy = adapter->pbuddy_adapter;
  pmlmepriv = & adapter->mlmepriv;
  pxmit_priv = & adapter->xmitpriv;
  ret = 0;
  if ((long )(adapter->pwrctrlpriv.ips_deny_time - (unsigned long )jiffies) >= 0L) {
    goto exit;
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 2049);
  if ((int )tmp) {
    goto exit;
  } else {
    tmp___0 = check_fwstate(pmlmepriv, 384);
    if ((int )tmp___0) {
      goto exit;
    } else {
      tmp___1 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___1) {
        goto exit;
      } else {
        tmp___2 = check_fwstate(pmlmepriv, 96);
        if ((int )tmp___2) {
          goto exit;
        } else {
        }
      }
    }
  }
  if ((unsigned long )buddy != (unsigned long )((struct rtw_adapter *)0)) {
    b_pmlmepriv = & buddy->mlmepriv;
    tmp___3 = check_fwstate(b_pmlmepriv, 2049);
    if ((int )tmp___3) {
      goto exit;
    } else {
      tmp___4 = check_fwstate(b_pmlmepriv, 384);
      if ((int )tmp___4) {
        goto exit;
      } else {
        tmp___5 = check_fwstate(b_pmlmepriv, 16);
        if ((int )tmp___5) {
          goto exit;
        } else {
          tmp___6 = check_fwstate(b_pmlmepriv, 96);
          if ((int )tmp___6) {
            goto exit;
          } else {
          }
        }
      }
    }
  } else {
  }
  if (pxmit_priv->free_xmitbuf_cnt != 4U || pxmit_priv->free_xmit_extbuf_cnt != 32U) {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: OLD_ERROR There are some pkts to transmit\n");
    } else {
    }
    if (GlobalDebugLevel23A > 6U) {
      printk("\016RTL8723AU: OLD_ERROR free_xmitbuf_cnt: %d, free_xmit_extbuf_cnt: %d\n",
             pxmit_priv->free_xmitbuf_cnt, pxmit_priv->free_xmit_extbuf_cnt);
    } else {
    }
    goto exit;
  } else {
  }
  ret = 1;
  exit: ;
  return (ret);
}
}
void rtw_ps_processor23a(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  enum rt_rf_power_state rfpwrstate ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  pmlmepriv = & padapter->mlmepriv;
  pwrpriv->ps_processing = 1U;
  if (pwrpriv->bips_processing == 1U) {
    goto exit;
  } else {
  }
  if ((unsigned int )padapter->pwrctrlpriv.bHWPwrPindetect != 0U) {
    rfpwrstate = RfOnOffDetect23a(padapter);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: @@@@- #2  %s ==> rfstate:%s\n", "rtw_ps_processor23a",
             (unsigned int )rfpwrstate == 0U ? (char *)"rf_on" : (char *)"rf_off");
    } else {
    }
    if ((unsigned int )pwrpriv->rf_pwrstate != (unsigned int )rfpwrstate) {
      if ((unsigned int )rfpwrstate == 2U) {
        pwrpriv->change_rfpwrstate = 2;
        pwrpriv->brfoffbyhw = 1U;
        padapter->bCardDisableWOHSM = 1;
        rtw_hw_suspend23a(padapter);
      } else {
        pwrpriv->change_rfpwrstate = 0;
        rtw_hw_resume23a(padapter);
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: current rf_pwrstate(%s)\n", (unsigned int )pwrpriv->rf_pwrstate == 2U ? (char *)"rf_off" : (char *)"rf_on");
      } else {
      }
    } else {
    }
    pwrpriv->pwr_state_check_cnts = (u8 )((int )pwrpriv->pwr_state_check_cnts + 1);
  } else {
  }
  if ((unsigned int )pwrpriv->ips_mode_req == 0U) {
    goto exit;
  } else {
  }
  tmp = rtw_pwr_unassociated_idle(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    goto exit;
  } else {
  }
  if ((unsigned int )pwrpriv->rf_pwrstate == 0U && ((unsigned int )pwrpriv->pwr_state_check_cnts & 3U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      tmp___1 = get_fwstate(pmlmepriv);
      printk("\016RTL8723AU: ==>%s .fw_state(%x)\n", "rtw_ps_processor23a", tmp___1);
    } else {
    }
    pwrpriv->change_rfpwrstate = 2;
    ips_enter23a(padapter);
  } else {
  }
  exit:
  tmp___2 = msecs_to_jiffies((unsigned int const )padapter->pwrctrlpriv.pwr_state_check_interval);
  ldv_mod_timer_617(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp___2 + (unsigned long )jiffies);
  pwrpriv->ps_processing = 0U;
  return;
}
}
static void pwr_state_check_handler(unsigned long data )
{
  struct rtw_adapter *padapter ;
  {
  padapter = (struct rtw_adapter *)data;
  rtw_ps_cmd23a(padapter);
  return;
}
}
void rtw_set_rpwm23a(struct rtw_adapter *padapter , u8 pslv )
{
  u8 rpwm ;
  struct pwrctrl_priv *pwrpriv ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  pslv = (unsigned int )pslv & 15U;
  if ((unsigned int )pwrpriv->btcoex_rfon != 0U) {
    if ((unsigned int )pslv <= 11U) {
      pslv = 4U;
    } else {
    }
  } else {
  }
  if ((int )((unsigned char )pwrpriv->rpwm) == (int )pslv) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
      printk("\016%s: Already set rpwm[0x%02X], new = 0x%02X!\n", "rtw_set_rpwm23a",
             (int )pwrpriv->rpwm, (int )pslv);
    } else {
    }
    return;
  } else {
  }
  if (padapter->bSurpriseRemoved == 1 || (unsigned int )padapter->hw_init_completed == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
      printk("\016%s: SurpriseRemoved(%d) hw_init_completed(%d)\n", "rtw_set_rpwm23a",
             padapter->bSurpriseRemoved, (int )padapter->hw_init_completed);
    } else {
    }
    pwrpriv->cpwm = 12U;
    return;
  } else {
  }
  if (padapter->bDriverStopped == 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
      printk("\016%s: change power state(0x%02X) when DriverStopped\n", "rtw_set_rpwm23a",
             (int )pslv);
    } else {
    }
    if ((unsigned int )pslv <= 1U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
        printk("\016%s: Reject to enter PS_STATE(0x%02X) lower than S2 when DriverStopped!!\n",
               "rtw_set_rpwm23a", (int )pslv);
      } else {
      }
      return;
    } else {
    }
  } else {
  }
  rpwm = (u8 )((int )((unsigned char )pwrpriv->tog) | (int )pslv);
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 6);
    printk("\016rtw_set_rpwm23a: rpwm = 0x%02x cpwm = 0x%02x\n", (int )rpwm, (int )pwrpriv->cpwm);
  } else {
  }
  pwrpriv->rpwm = pslv;
  rtl8723a_set_rpwm(padapter, (int )rpwm);
  pwrpriv->tog = (unsigned int )pwrpriv->tog + 128U;
  pwrpriv->cpwm = pslv;
  return;
}
}
static bool PS_RDY_CHECK(struct rtw_adapter *padapter )
{
  unsigned long delta_time ;
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  pmlmepriv = & padapter->mlmepriv;
  delta_time = (unsigned long )jiffies - pwrpriv->DelayLPSLastTimeStamp;
  if (delta_time <= 249UL) {
    return (0);
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {
    tmp___1 = check_fwstate(pmlmepriv, 2048);
    if ((int )tmp___1) {
      return (0);
    } else {
      tmp___2 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___2) {
        return (0);
      } else {
        tmp___3 = check_fwstate(pmlmepriv, 64);
        if ((int )tmp___3) {
          return (0);
        } else {
          tmp___4 = check_fwstate(pmlmepriv, 32);
          if ((int )tmp___4) {
            return (0);
          } else {
          }
        }
      }
    }
  }
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
    return (0);
  } else {
  }
  if (padapter->securitypriv.dot11AuthAlgrthm == 2U && (unsigned int )*((unsigned char *)padapter + 11436UL) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Group handshake still in progress !!!\n");
    } else {
    }
    return (0);
  } else {
  }
  tmp___5 = rtw_cfg80211_pwr_mgmt(padapter);
  if (tmp___5) {
    tmp___6 = 0;
  } else {
    tmp___6 = 1;
  }
  if (tmp___6) {
    return (0);
  } else {
  }
  return (1);
}
}
void rtw_set_ps_mode23a(struct rtw_adapter *padapter , u8 ps_mode , u8 smart_ps ,
                        u8 bcn_ant_mode )
{
  struct pwrctrl_priv *pwrpriv ;
  bool tmp ;
  bool tmp___0 ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 6);
    printk("\016%s: PowerMode =%d Smart_PS =%d\n", "rtw_set_ps_mode23a", (int )ps_mode,
           (int )smart_ps);
  } else {
  }
  if ((unsigned int )ps_mode > 10U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
      printk("\016ps_mode:%d error\n", (int )ps_mode);
    } else {
    }
    return;
  } else {
  }
  if ((int )pwrpriv->pwr_mode == (int )ps_mode) {
    if ((unsigned int )ps_mode == 0U) {
      return;
    } else {
    }
    if ((int )pwrpriv->smart_ps == (int )smart_ps && (int )pwrpriv->bcn_ant_mode == (int )bcn_ant_mode) {
      return;
    } else {
    }
  } else {
  }
  if ((unsigned int )ps_mode == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: rtw_set_ps_mode23a: Leave 802.11 power save\n");
    } else {
    }
    pwrpriv->pwr_mode = ps_mode;
    rtw_set_rpwm23a(padapter, 12);
    rtl8723a_set_FwPwrMode_cmd(padapter, (int )ps_mode);
    pwrpriv->bFwCurrentInPSMode = 0U;
  } else {
    tmp = PS_RDY_CHECK(padapter);
    if ((int )tmp) {
      goto _L;
    } else {
      tmp___0 = rtl8723a_BT_using_antenna_1(padapter);
      if ((int )tmp___0) {
        _L:
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s: Enter 802.11 power save\n", "rtw_set_ps_mode23a");
        } else {
        }
        pwrpriv->bFwCurrentInPSMode = 1U;
        pwrpriv->pwr_mode = ps_mode;
        pwrpriv->smart_ps = smart_ps;
        pwrpriv->bcn_ant_mode = bcn_ant_mode;
        rtl8723a_set_FwPwrMode_cmd(padapter, (int )ps_mode);
        rtw_set_rpwm23a(padapter, 2);
      } else {
      }
    }
  }
  return;
}
}
s32 LPS_RF_ON_check23a(struct rtw_adapter *padapter , u32 delay_ms )
{
  unsigned long start_time ;
  unsigned long end_time ;
  u8 bAwake ;
  s32 err ;
  unsigned long tmp ;
  bool tmp___0 ;
  {
  bAwake = 0U;
  err = 0;
  start_time = jiffies;
  tmp = msecs_to_jiffies(delay_ms);
  end_time = tmp + start_time;
  ldv_54329:
  tmp___0 = rtl8723a_get_fwlps_rf_on(padapter);
  bAwake = (u8 )tmp___0;
  if ((unsigned int )bAwake == 1U) {
    goto ldv_54321;
  } else {
  }
  if (padapter->bSurpriseRemoved == 1) {
    err = -2;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: device surprise removed!!\n", "LPS_RF_ON_check23a");
    } else {
    }
    goto ldv_54321;
  } else {
  }
  if ((long )(end_time - (unsigned long )jiffies) < 0L) {
    err = -1;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: Wait for FW LPS leave more than %u ms!\n", "LPS_RF_ON_check23a",
             delay_ms);
    } else {
    }
    goto ldv_54321;
  } else {
  }
  __const_udelay(429500UL);
  goto ldv_54329;
  ldv_54321: ;
  return (err);
}
}
void LPS_Enter23a(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *pwrpriv ;
  bool tmp ;
  int tmp___0 ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  tmp = PS_RDY_CHECK(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  if ((unsigned int )pwrpriv->bLeisurePs != 0U) {
    if ((unsigned int )pwrpriv->LpsIdleCount > 1U) {
      if ((unsigned int )pwrpriv->pwr_mode == 0U) {
        pwrpriv->bpower_saving = 1U;
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s smart_ps:%d\n", "LPS_Enter23a", (int )pwrpriv->smart_ps);
        } else {
        }
        rtw_set_ps_mode23a(padapter, (int )pwrpriv->power_mgnt, (int )pwrpriv->smart_ps,
                           0);
      } else {
      }
    } else {
      pwrpriv->LpsIdleCount = (u8 )((int )pwrpriv->LpsIdleCount + 1);
    }
  } else {
  }
  return;
}
}
void LPS_Leave23a(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *pwrpriv ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  if ((unsigned int )pwrpriv->bLeisurePs != 0U) {
    if ((unsigned int )pwrpriv->pwr_mode != 0U) {
      rtw_set_ps_mode23a(padapter, 0, 0, 0);
      if ((unsigned int )pwrpriv->pwr_mode == 0U) {
        LPS_RF_ON_check23a(padapter, 100U);
      } else {
      }
    } else {
    }
  } else {
  }
  pwrpriv->bpower_saving = 0U;
  return;
}
}
void LeaveAllPowerSaveMode23a(struct rtw_adapter *Adapter )
{
  struct mlme_priv *pmlmepriv ;
  u8 enqueue ;
  bool tmp ;
  {
  pmlmepriv = & Adapter->mlmepriv;
  enqueue = 0U;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    rtw_lps_ctrl_wk_cmd23a(Adapter, 5, (int )enqueue);
  } else {
  }
  return;
}
}
void rtw_init_pwrctrl_priv23a(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *pwrctrlpriv ;
  {
  pwrctrlpriv = & padapter->pwrctrlpriv;
  sema_init(& pwrctrlpriv->lock, 1);
  pwrctrlpriv->rf_pwrstate = 0;
  pwrctrlpriv->ips_enter23a_cnts = 0U;
  pwrctrlpriv->ips_leave23a_cnts = 0U;
  pwrctrlpriv->bips_processing = 0U;
  pwrctrlpriv->ips_mode = padapter->registrypriv.ips_mode;
  pwrctrlpriv->ips_mode_req = padapter->registrypriv.ips_mode;
  pwrctrlpriv->pwr_state_check_interval = 2000;
  pwrctrlpriv->pwr_state_check_cnts = 0U;
  pwrctrlpriv->bInSuspend = 0U;
  pwrctrlpriv->bkeepfwalive = 0U;
  pwrctrlpriv->LpsIdleCount = 0U;
  pwrctrlpriv->power_mgnt = padapter->registrypriv.power_mgnt;
  pwrctrlpriv->bLeisurePs = (unsigned int )pwrctrlpriv->power_mgnt != 0U;
  pwrctrlpriv->bFwCurrentInPSMode = 0U;
  pwrctrlpriv->rpwm = 0U;
  pwrctrlpriv->cpwm = 12U;
  pwrctrlpriv->pwr_mode = 0U;
  pwrctrlpriv->smart_ps = padapter->registrypriv.smart_ps;
  pwrctrlpriv->bcn_ant_mode = 0U;
  pwrctrlpriv->tog = 128U;
  pwrctrlpriv->btcoex_rfon = 0U;
  reg_timer_6(& pwrctrlpriv->pwr_state_check_timer, & pwr_state_check_handler, (unsigned long )padapter);
  return;
}
}
void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter )
{
  {
  return;
}
}
int _rtw_pwr_wakeup23a(struct rtw_adapter *padapter , u32 ips_deffer_ms , char const *caller )
{
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  int ret ;
  unsigned long start ;
  unsigned long new_deny_time ;
  unsigned long tmp ;
  unsigned int tmp___0 ;
  bool tmp___1 ;
  unsigned int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  unsigned int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  unsigned long tmp___8 ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  pmlmepriv = & padapter->mlmepriv;
  ret = 1;
  start = jiffies;
  tmp = msecs_to_jiffies(ips_deffer_ms);
  new_deny_time = tmp + (unsigned long )jiffies;
  if ((long )(pwrpriv->ips_deny_time - new_deny_time) < 0L) {
    pwrpriv->ips_deny_time = new_deny_time;
  } else {
  }
  if ((unsigned int )pwrpriv->ps_processing != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait ps_processing...\n", "_rtw_pwr_wakeup23a");
    } else {
    }
    goto ldv_54374;
    ldv_54373:
    msleep(10U);
    ldv_54374: ;
    if ((unsigned int )pwrpriv->ps_processing != 0U) {
      tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
      if (tmp___0 <= 3000U) {
        goto ldv_54373;
      } else {
        goto ldv_54375;
      }
    } else {
    }
    ldv_54375: ;
    if ((unsigned int )pwrpriv->ps_processing != 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s wait ps_processing timeout\n", "_rtw_pwr_wakeup23a");
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait ps_processing done\n", "_rtw_pwr_wakeup23a");
    } else {
    }
  } else {
  }
  tmp___4 = rtw_sreset_inprogress(padapter);
  if ((int )tmp___4) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait sreset_inprogress...\n", "_rtw_pwr_wakeup23a");
    } else {
    }
    goto ldv_54377;
    ldv_54376:
    msleep(10U);
    ldv_54377:
    tmp___1 = rtw_sreset_inprogress(padapter);
    if ((int )tmp___1) {
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
      if (tmp___2 <= 4000U) {
        goto ldv_54376;
      } else {
        goto ldv_54378;
      }
    } else {
    }
    ldv_54378:
    tmp___3 = rtw_sreset_inprogress(padapter);
    if ((int )tmp___3) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s wait sreset_inprogress timeout\n", "_rtw_pwr_wakeup23a");
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait sreset_inprogress done\n", "_rtw_pwr_wakeup23a");
    } else {
    }
  } else {
  }
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait bInSuspend...\n", "_rtw_pwr_wakeup23a");
    } else {
    }
    goto ldv_54380;
    ldv_54379:
    msleep(10U);
    ldv_54380: ;
    if ((unsigned int )pwrpriv->bInSuspend != 0U) {
      tmp___5 = jiffies_to_msecs((unsigned long )jiffies - start);
      if (tmp___5 <= 3000U) {
        goto ldv_54379;
      } else {
        goto ldv_54381;
      }
    } else {
    }
    ldv_54381: ;
    if ((unsigned int )pwrpriv->bInSuspend != 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s wait bInSuspend timeout\n", "_rtw_pwr_wakeup23a");
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s wait bInSuspend done\n", "_rtw_pwr_wakeup23a");
    } else {
    }
  } else {
  }
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
    ret = 0;
    goto exit;
  } else {
  }
  tmp___6 = check_fwstate(pmlmepriv, 1);
  if ((int )tmp___6) {
    ret = 1;
    goto exit;
  } else {
  }
  if ((unsigned int )pwrpriv->rf_pwrstate == 2U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s call ips_leave23a....\n", "_rtw_pwr_wakeup23a");
    } else {
    }
    tmp___7 = ips_leave23a(padapter);
    if (tmp___7 == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: ======> ips_leave23a fail.............\n");
      } else {
      }
      ret = 0;
      goto exit;
    } else {
    }
  } else {
  }
  if ((padapter->bDriverStopped != 0 || padapter->bup == 0) || (unsigned int )padapter->hw_init_completed == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: bDriverStopped =%d, bup =%d, hw_init_completed =%u\n",
             caller, padapter->bDriverStopped, padapter->bup, (int )padapter->hw_init_completed);
    } else {
    }
    ret = 0;
    goto exit;
  } else {
  }
  exit:
  tmp___8 = msecs_to_jiffies(ips_deffer_ms);
  new_deny_time = tmp___8 + (unsigned long )jiffies;
  if ((long )(pwrpriv->ips_deny_time - new_deny_time) < 0L) {
    pwrpriv->ips_deny_time = new_deny_time;
  } else {
  }
  return (ret);
}
}
int rtw_pm_set_lps23a(struct rtw_adapter *padapter , u8 mode )
{
  int ret ;
  struct pwrctrl_priv *pwrctrlpriv ;
  {
  ret = 0;
  pwrctrlpriv = & padapter->pwrctrlpriv;
  if ((unsigned int )mode <= 10U) {
    if ((int )pwrctrlpriv->power_mgnt != (int )mode) {
      if ((unsigned int )mode == 0U) {
        LeaveAllPowerSaveMode23a(padapter);
      } else {
        pwrctrlpriv->LpsIdleCount = 2U;
      }
      pwrctrlpriv->power_mgnt = mode;
      pwrctrlpriv->bLeisurePs = (unsigned int )pwrctrlpriv->power_mgnt != 0U;
    } else {
    }
  } else {
    ret = -22;
  }
  return (ret);
}
}
int rtw_pm_set_ips23a(struct rtw_adapter *padapter , u8 mode )
{
  struct pwrctrl_priv *pwrctrlpriv ;
  int tmp ;
  {
  pwrctrlpriv = & padapter->pwrctrlpriv;
  if ((unsigned int )mode == 1U || (unsigned int )mode == 2U) {
    pwrctrlpriv->ips_mode_req = mode;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s %s\n", "rtw_pm_set_ips23a", (unsigned int )mode == 1U ? (char *)"IPS_NORMAL" : (char *)"IPS_LEVEL_2");
    } else {
    }
    return (0);
  } else
  if ((unsigned int )mode == 0U) {
    pwrctrlpriv->ips_mode_req = mode;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s %s\n", "rtw_pm_set_ips23a", (char *)"IPS_NONE");
    } else {
    }
    if (padapter->bSurpriseRemoved == 0) {
      tmp = _rtw_pwr_wakeup23a(padapter, 2000U, "rtw_pm_set_ips23a");
      if (tmp == 0) {
        return (-14);
      } else {
      }
    } else {
    }
  } else {
    return (-22);
  }
  return (0);
}
}
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_9_0 == (unsigned long )timer) {
    if (ldv_timer_9_0 == 2 || pending_flag != 0) {
      ldv_timer_list_9_0 = timer;
      ldv_timer_list_9_0->data = data;
      ldv_timer_9_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_9_1 == (unsigned long )timer) {
    if (ldv_timer_9_1 == 2 || pending_flag != 0) {
      ldv_timer_list_9_1 = timer;
      ldv_timer_list_9_1->data = data;
      ldv_timer_9_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_9_2 == (unsigned long )timer) {
    if (ldv_timer_9_2 == 2 || pending_flag != 0) {
      ldv_timer_list_9_2 = timer;
      ldv_timer_list_9_2->data = data;
      ldv_timer_9_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_9_3 == (unsigned long )timer) {
    if (ldv_timer_9_3 == 2 || pending_flag != 0) {
      ldv_timer_list_9_3 = timer;
      ldv_timer_list_9_3->data = data;
      ldv_timer_9_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_9(timer, data);
  return;
}
}
void ldv_timer_9(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  pwr_state_check_handler(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void timer_init_9(void)
{
  {
  ldv_timer_9_0 = 0;
  ldv_timer_9_1 = 0;
  ldv_timer_9_2 = 0;
  ldv_timer_9_3 = 0;
  return;
}
}
void activate_suitable_timer_9(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_9_0 == 0 || ldv_timer_9_0 == 2) {
    ldv_timer_list_9_0 = timer;
    ldv_timer_list_9_0->data = data;
    ldv_timer_9_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_9_1 == 0 || ldv_timer_9_1 == 2) {
    ldv_timer_list_9_1 = timer;
    ldv_timer_list_9_1->data = data;
    ldv_timer_9_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_9_2 == 0 || ldv_timer_9_2 == 2) {
    ldv_timer_list_9_2 = timer;
    ldv_timer_list_9_2->data = data;
    ldv_timer_9_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_9_3 == 0 || ldv_timer_9_3 == 2) {
    ldv_timer_list_9_3 = timer;
    ldv_timer_list_9_3->data = data;
    ldv_timer_9_3 = 1;
    return;
  } else {
  }
  return;
}
}
int reg_timer_9(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& pwr_state_check_handler)) {
    activate_suitable_timer_9(timer, data);
  } else {
  }
  return (0);
}
}
void disable_suitable_timer_9(struct timer_list *timer )
{
  {
  if (ldv_timer_9_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_0) {
    ldv_timer_9_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_9_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_1) {
    ldv_timer_9_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_9_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_2) {
    ldv_timer_9_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_9_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_3) {
    ldv_timer_9_3 = 0;
    return;
  } else {
  }
  return;
}
}
void choose_timer_9(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_9_0 == 1) {
    ldv_timer_9_0 = 2;
    ldv_timer_9(ldv_timer_9_0, ldv_timer_list_9_0);
  } else {
  }
  goto ldv_54430;
  case 1: ;
  if (ldv_timer_9_1 == 1) {
    ldv_timer_9_1 = 2;
    ldv_timer_9(ldv_timer_9_1, ldv_timer_list_9_1);
  } else {
  }
  goto ldv_54430;
  case 2: ;
  if (ldv_timer_9_2 == 1) {
    ldv_timer_9_2 = 2;
    ldv_timer_9(ldv_timer_9_2, ldv_timer_list_9_2);
  } else {
  }
  goto ldv_54430;
  case 3: ;
  if (ldv_timer_9_3 == 1) {
    ldv_timer_9_3 = 2;
    ldv_timer_9(ldv_timer_9_3, ldv_timer_list_9_3);
  } else {
  }
  goto ldv_54430;
  default:
  ldv_stop();
  }
  ldv_54430: ;
  return;
}
}
void *ldv_kmem_cache_alloc_600(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_606(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_608(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_610(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_611(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_612(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_613(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_614(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_615(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_616(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_mod_timer_617(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static void list_add(struct list_head *new , struct list_head *head )
{
  {
  __list_add(new, head, head->next);
  return;
}
}
extern void warn_slowpath_null(char const * , int const ) ;
extern void _raw_spin_lock(raw_spinlock_t * ) ;
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
__inline static void ldv_spin_lock_629(spinlock_t *lock )
{
  {
  _raw_spin_lock(& lock->ldv_6347.rlock);
  return;
}
}
__inline static void spin_lock(spinlock_t *lock ) ;
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void ldv_spin_unlock_633(spinlock_t *lock )
{
  {
  _raw_spin_unlock(& lock->ldv_6347.rlock);
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
int ldv_mod_timer_661(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_662(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_664(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_665(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_663(struct timer_list *ldv_func_arg1 ) ;
void *ldv_kmem_cache_alloc_644(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct timer_list *ldv_timer_list_10_2 ;
struct timer_list *ldv_timer_list_10_0 ;
int ldv_timer_10_2 ;
struct timer_list *ldv_timer_list_10_1 ;
int ldv_timer_10_0 ;
int ldv_timer_10_1 ;
struct timer_list *ldv_timer_list_10_3 ;
int ldv_timer_10_3 ;
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) ;
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void ldv_timer_10(int state , struct timer_list *timer ) ;
void disable_suitable_timer_10(struct timer_list *timer ) ;
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data ) ;
void timer_init_10(void) ;
void choose_timer_10(void) ;
struct sk_buff *ldv_skb_clone_652(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_660(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_654(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_650(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_658(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_659(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
__inline static int skb_queue_empty(struct sk_buff_head const *list )
{
  {
  return ((unsigned long )((struct sk_buff const *)list->next) == (unsigned long )((struct sk_buff const *)list));
}
}
__inline static struct sk_buff *skb_peek(struct sk_buff_head const *list_ )
{
  struct sk_buff *skb ;
  {
  skb = list_->next;
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)list_)) {
    skb = (struct sk_buff *)0;
  } else {
  }
  return (skb);
}
}
__inline static void __skb_queue_head_init(struct sk_buff_head *list )
{
  struct sk_buff *tmp ;
  {
  tmp = (struct sk_buff *)list;
  list->next = tmp;
  list->prev = tmp;
  list->qlen = 0U;
  return;
}
}
__inline static void __skb_unlink(struct sk_buff *skb , struct sk_buff_head *list )
{
  struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *tmp ;
  {
  list->qlen = list->qlen - 1U;
  next = skb->next;
  prev = skb->prev;
  tmp = (struct sk_buff *)0;
  skb->prev = tmp;
  skb->next = tmp;
  next->prev = prev;
  prev->next = next;
  return;
}
}
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list )
{
  struct sk_buff *skb ;
  struct sk_buff *tmp ;
  {
  tmp = skb_peek((struct sk_buff_head const *)list);
  skb = tmp;
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
    __skb_unlink(skb, list);
  } else {
  }
  return (skb);
}
}
__inline static unsigned char *skb_tail_pointer(struct sk_buff const *skb )
{
  {
  return ((unsigned char *)skb->head + (unsigned long )skb->tail);
}
}
extern unsigned char *skb_put(struct sk_buff * , unsigned int ) ;
extern unsigned char *skb_pull(struct sk_buff * , unsigned int ) ;
extern void skb_trim(struct sk_buff * , unsigned int ) ;
struct sk_buff *ldv___netdev_alloc_skb_655(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_656(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_657(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason ) ;
__inline static void dev_kfree_skb_any(struct sk_buff *skb )
{
  {
  __dev_kfree_skb_any(skb, 1);
  return;
}
}
extern int netif_rx(struct sk_buff * ) ;
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
__inline static int ieee80211_has_tods(__le16 fc )
{
  {
  return (((int )fc & 256) != 0);
}
}
__inline static int ieee80211_has_fromds(__le16 fc )
{
  {
  return (((int )fc & 512) != 0);
}
}
__inline static int ieee80211_has_a4(__le16 fc )
{
  __le16 tmp ;
  {
  tmp = 768U;
  return (((int )fc & (int )tmp) == (int )tmp);
}
}
__inline static int ieee80211_has_morefrags(__le16 fc )
{
  {
  return (((int )fc & 1024) != 0);
}
}
__inline static int ieee80211_has_pm(__le16 fc )
{
  {
  return (((int )fc & 4096) != 0);
}
}
__inline static int ieee80211_has_moredata(__le16 fc )
{
  {
  return (((int )fc & 8192) != 0);
}
}
__inline static int ieee80211_has_protected(__le16 fc )
{
  {
  return (((int )fc & 16384) != 0);
}
}
__inline static int ieee80211_has_order(__le16 fc )
{
  {
  return ((int )((short )fc) < 0);
}
}
__inline static int ieee80211_is_ctl(__le16 fc )
{
  {
  return (((int )fc & 12) == 4);
}
}
__inline static int ieee80211_is_data(__le16 fc )
{
  {
  return (((int )fc & 12) == 8);
}
}
__inline static int ieee80211_is_data_qos(__le16 fc )
{
  {
  return (((int )fc & 140) == 136);
}
}
__inline static int ieee80211_is_pspoll(__le16 fc )
{
  {
  return (((int )fc & 252) == 164);
}
}
__inline static int ieee80211_is_nullfunc(__le16 fc )
{
  {
  return (((int )fc & 252) == 72);
}
}
__inline static u8 *ieee80211_get_qos_ctl(struct ieee80211_hdr *hdr )
{
  int tmp ;
  {
  tmp = ieee80211_has_a4((int )hdr->frame_control);
  if (tmp != 0) {
    return ((u8 *)hdr + 30UL);
  } else {
    return ((u8 *)hdr + 24UL);
  }
}
}
__inline static u8 *ieee80211_get_SA(struct ieee80211_hdr *hdr )
{
  int tmp ;
  int tmp___0 ;
  {
  tmp = ieee80211_has_a4((int )hdr->frame_control);
  if (tmp != 0) {
    return ((u8 *)(& hdr->addr4));
  } else {
  }
  tmp___0 = ieee80211_has_fromds((int )hdr->frame_control);
  if (tmp___0 != 0) {
    return ((u8 *)(& hdr->addr3));
  } else {
  }
  return ((u8 *)(& hdr->addr2));
}
}
__inline static u8 *ieee80211_get_DA(struct ieee80211_hdr *hdr )
{
  int tmp ;
  {
  tmp = ieee80211_has_tods((int )hdr->frame_control);
  if (tmp != 0) {
    return ((u8 *)(& hdr->addr3));
  } else {
    return ((u8 *)(& hdr->addr1));
  }
}
}
extern unsigned char const rfc1042_header[6U] ;
extern unsigned char const bridge_tunnel_header[6U] ;
extern void ieee80211_amsdu_to_8023s(struct sk_buff * , struct sk_buff_head * , u8 const * ,
                                     enum nl80211_iftype , unsigned int const ,
                                     bool ) ;
__inline static u32 CHKBIT(u32 x )
{
  int __ret_warn_on ;
  long tmp ;
  {
  __ret_warn_on = x > 31U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("drivers/staging/rtl8723au/include/osdep_service.h", 70);
  } else {
  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (x > 31U) {
    return (0U);
  } else {
  }
  return ((u32 )(1UL << (int )x));
}
}
void stop_sta_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void wakeup_sta_to_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void xmit_delivery_enabled_frames23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
struct recv_frame *rtw_alloc_recvframe23a(struct rtw_queue *pfree_recv_queue ) ;
int rtw_free_recvframe23a(struct recv_frame *precvframe ) ;
int rtw_enqueue_recvframe23a(struct recv_frame *precvframe , struct rtw_queue *queue ) ;
int rtw_enqueue_recvbuf23a_to_head(struct recv_buf *precvbuf , struct rtw_queue *queue ) ;
int rtw_enqueue_recvbuf23a(struct recv_buf *precvbuf , struct rtw_queue *queue ) ;
struct recv_buf *rtw_dequeue_recvbuf23a(struct rtw_queue *queue ) ;
void rtw_reordering_ctrl_timeout_handler23a(unsigned long pcontext ) ;
void _rtw_init_sta_recv_priv23a(struct sta_recv_priv *psta_recvpriv ) ;
void rtw_seccalctkipmic23a(u8 *key , u8 *header , u8 *data , u32 data_len , u8 *mic_code ,
                           u8 pri ) ;
int rtw_aes_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
int rtw_tkip_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
void rtw_wep_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
__inline static u8 *get_bssid(struct mlme_priv *pmlmepriv )
{
  {
  return ((u8 *)(& pmlmepriv->cur_network.network.MacAddress));
}
}
int _rtw_init_recv_priv23a(struct recv_priv *precvpriv , struct rtw_adapter *padapter ) ;
void _rtw_free_recv_priv23a(struct recv_priv *precvpriv ) ;
int rtw_recv_entry23a(struct recv_frame *rframe ) ;
int rtw_recv_indicatepkt23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void rtw_handle_tkip_mic_err23a(struct rtw_adapter *padapter , u8 bgroup ) ;
int rtl8723au_init_recv_priv(struct rtw_adapter *padapter ) ;
void rtl8723au_free_recv_priv(struct rtw_adapter *padapter ) ;
void rtw_signal_stat_timer_hdl23a(unsigned long data ) ;
void _rtw_init_sta_recv_priv23a(struct sta_recv_priv *psta_recvpriv )
{
  struct lock_class_key __key ;
  {
  spinlock_check(& psta_recvpriv->lock);
  __raw_spin_lock_init(& psta_recvpriv->lock.ldv_6347.rlock, "&(&psta_recvpriv->lock)->rlock",
                       & __key);
  _rtw_init_queue23a(& psta_recvpriv->defrag_q);
  return;
}
}
int _rtw_init_recv_priv23a(struct recv_priv *precvpriv , struct rtw_adapter *padapter )
{
  struct recv_frame *precvframe ;
  int i ;
  int res ;
  struct lock_class_key __key ;
  void *tmp ;
  unsigned long tmp___0 ;
  {
  res = 1;
  spinlock_check(& precvpriv->lock);
  __raw_spin_lock_init(& precvpriv->lock.ldv_6347.rlock, "&(&precvpriv->lock)->rlock",
                       & __key);
  _rtw_init_queue23a(& precvpriv->free_recv_queue);
  _rtw_init_queue23a(& precvpriv->recv_pending_queue);
  _rtw_init_queue23a(& precvpriv->uc_swdec_pending_queue);
  precvpriv->adapter = padapter;
  i = 0;
  goto ldv_51704;
  ldv_51703:
  tmp = kzalloc(144UL, 208U);
  precvframe = (struct recv_frame *)tmp;
  if ((unsigned long )precvframe == (unsigned long )((struct recv_frame *)0)) {
    goto ldv_51702;
  } else {
  }
  INIT_LIST_HEAD(& precvframe->list);
  list_add_tail(& precvframe->list, & precvpriv->free_recv_queue.queue);
  precvframe->adapter = padapter;
  precvframe = precvframe + 1;
  i = i + 1;
  ldv_51704: ;
  if (i <= 255) {
    goto ldv_51703;
  } else {
  }
  ldv_51702:
  precvpriv->free_recvframe_cnt = i;
  precvpriv->rx_pending_cnt = 1U;
  res = rtl8723au_init_recv_priv(padapter);
  reg_timer_6(& precvpriv->signal_stat_timer, & rtw_signal_stat_timer_hdl23a, (unsigned long )padapter);
  precvpriv->signal_stat_sampling_interval = 1000U;
  tmp___0 = msecs_to_jiffies(precvpriv->signal_stat_sampling_interval);
  ldv_mod_timer_661(& precvpriv->signal_stat_timer, tmp___0 + (unsigned long )jiffies);
  return (res);
}
}
void _rtw_free_recv_priv23a(struct recv_priv *precvpriv )
{
  struct rtw_adapter *padapter ;
  struct recv_frame *precvframe ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head const *__mptr ;
  {
  padapter = precvpriv->adapter;
  rtw_free_uc_swdec_pending_queue23a(padapter);
  plist = precvpriv->free_recv_queue.queue.next;
  ptmp = plist->next;
  goto ldv_51715;
  ldv_51714:
  __mptr = (struct list_head const *)plist;
  precvframe = (struct recv_frame *)__mptr;
  list_del_init(& precvframe->list);
  kfree((void const *)precvframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_51715: ;
  if ((unsigned long )(& precvpriv->free_recv_queue.queue) != (unsigned long )plist) {
    goto ldv_51714;
  } else {
  }
  rtl8723au_free_recv_priv(padapter);
  return;
}
}
struct recv_frame *rtw_alloc_recvframe23a(struct rtw_queue *pfree_recv_queue )
{
  struct recv_frame *pframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  spin_lock_bh(& pfree_recv_queue->lock);
  tmp = list_empty((struct list_head const *)(& pfree_recv_queue->queue));
  if (tmp != 0) {
    pframe = (struct recv_frame *)0;
  } else {
    phead = get_list_head(pfree_recv_queue);
    plist = phead->next;
    __mptr = (struct list_head const *)plist;
    pframe = (struct recv_frame *)__mptr;
    list_del_init(& pframe->list);
    padapter = pframe->adapter;
    if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
      precvpriv = & padapter->recvpriv;
      if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )pfree_recv_queue) {
        precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt - 1;
      } else {
      }
    } else {
    }
  }
  spin_unlock_bh(& pfree_recv_queue->lock);
  return (pframe);
}
}
int rtw_free_recvframe23a(struct recv_frame *precvframe )
{
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *pfree_recv_queue ;
  struct list_head *tmp ;
  {
  padapter = precvframe->adapter;
  precvpriv = & padapter->recvpriv;
  if ((unsigned long )precvframe->pkt != (unsigned long )((struct sk_buff *)0)) {
    dev_kfree_skb_any(precvframe->pkt);
    precvframe->pkt = (struct sk_buff *)0;
  } else {
  }
  pfree_recv_queue = & precvpriv->free_recv_queue;
  spin_lock_bh(& pfree_recv_queue->lock);
  list_del_init(& precvframe->list);
  tmp = get_list_head(pfree_recv_queue);
  list_add_tail(& precvframe->list, tmp);
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
    if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )pfree_recv_queue) {
      precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt + 1;
    } else {
    }
  } else {
  }
  spin_unlock_bh(& pfree_recv_queue->lock);
  return (1);
}
}
int rtw_enqueue_recvframe23a(struct recv_frame *precvframe , struct rtw_queue *queue )
{
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct list_head *tmp ;
  {
  padapter = precvframe->adapter;
  precvpriv = & padapter->recvpriv;
  spin_lock_bh(& queue->lock);
  list_del_init(& precvframe->list);
  tmp = get_list_head(queue);
  list_add_tail(& precvframe->list, tmp);
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
    if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )queue) {
      precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt + 1;
    } else {
    }
  } else {
  }
  spin_unlock_bh(& queue->lock);
  return (1);
}
}
static void rtw_free_recvframe23a_queue(struct rtw_queue *pframequeue )
{
  struct recv_frame *hdr ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct list_head const *__mptr ;
  {
  spin_lock(& pframequeue->lock);
  phead = get_list_head(pframequeue);
  plist = phead->next;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_51749;
  ldv_51748:
  __mptr = (struct list_head const *)plist;
  hdr = (struct recv_frame *)__mptr;
  rtw_free_recvframe23a(hdr);
  plist = ptmp;
  ptmp = plist->next;
  ldv_51749: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_51748;
  } else {
  }
  spin_unlock(& pframequeue->lock);
  return;
}
}
u32 rtw_free_uc_swdec_pending_queue23a(struct rtw_adapter *adapter )
{
  u32 cnt ;
  struct recv_frame *pending_frame ;
  {
  cnt = 0U;
  goto ldv_51758;
  ldv_51757:
  rtw_free_recvframe23a(pending_frame);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: dequeue uc_swdec_pending_queue\n", "rtw_free_uc_swdec_pending_queue23a");
  } else {
  }
  cnt = cnt + 1U;
  ldv_51758:
  pending_frame = rtw_alloc_recvframe23a(& adapter->recvpriv.uc_swdec_pending_queue);
  if ((unsigned long )pending_frame != (unsigned long )((struct recv_frame *)0)) {
    goto ldv_51757;
  } else {
  }
  return (cnt);
}
}
int rtw_enqueue_recvbuf23a_to_head(struct recv_buf *precvbuf , struct rtw_queue *queue )
{
  struct list_head *tmp ;
  {
  spin_lock_bh(& queue->lock);
  list_del_init(& precvbuf->list);
  tmp = get_list_head(queue);
  list_add(& precvbuf->list, tmp);
  spin_unlock_bh(& queue->lock);
  return (1);
}
}
int rtw_enqueue_recvbuf23a(struct recv_buf *precvbuf , struct rtw_queue *queue )
{
  unsigned long irqL ;
  struct list_head *tmp ;
  {
  ldv_spin_lock();
  list_del_init(& precvbuf->list);
  tmp = get_list_head(queue);
  list_add_tail(& precvbuf->list, tmp);
  spin_unlock_irqrestore(& queue->lock, irqL);
  return (1);
}
}
struct recv_buf *rtw_dequeue_recvbuf23a(struct rtw_queue *queue )
{
  unsigned long irqL ;
  struct recv_buf *precvbuf ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  ldv_spin_lock();
  tmp = list_empty((struct list_head const *)(& queue->queue));
  if (tmp != 0) {
    precvbuf = (struct recv_buf *)0;
  } else {
    phead = get_list_head(queue);
    plist = phead->next;
    __mptr = (struct list_head const *)plist;
    precvbuf = (struct recv_buf *)__mptr;
    list_del_init(& precvbuf->list);
  }
  spin_unlock_irqrestore(& queue->lock, irqL);
  return (precvbuf);
}
}
int recvframe_chkmic(struct rtw_adapter *adapter , struct recv_frame *precvframe ) ;
int recvframe_chkmic(struct rtw_adapter *adapter , struct recv_frame *precvframe )
{
  int i ;
  int res ;
  u32 datalen ;
  u8 miccode[8U] ;
  u8 bmic_err ;
  u8 brpt_micerror ;
  u8 *pframe ;
  u8 *payload ;
  u8 *pframemic ;
  u8 *mickey ;
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  int i___0 ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  {
  res = 1;
  bmic_err = 0U;
  brpt_micerror = 1U;
  prxattrib = & precvframe->attrib;
  psecuritypriv = & adapter->securitypriv;
  pmlmeext = & adapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  stainfo = rtw_get_stainfo23a(& adapter->stapriv, (u8 const *)(& prxattrib->ta));
  if (prxattrib->encrypt == 1027074U) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
      printk("\016\n recvframe_chkmic:prxattrib->encrypt == WLAN_CIPHER_SUITE_TKIP\n");
    } else {
    }
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
      printk("\016\n recvframe_chkmic:da = 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
             (int )prxattrib->ra[0], (int )prxattrib->ra[1], (int )prxattrib->ra[2],
             (int )prxattrib->ra[3], (int )prxattrib->ra[4], (int )prxattrib->ra[5]);
    } else {
    }
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
      tmp = is_multicast_ether_addr((u8 const *)(& prxattrib->ra));
      if ((int )tmp) {
        mickey = (u8 *)(& psecuritypriv->dot118021XGrprxmickey[(int )prxattrib->key_index].skey);
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
          printk("\016\n recvframe_chkmic: bcmc key\n");
        } else {
        }
        if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
          res = 0;
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
            printk("\016\n recvframe_chkmic:didn\'t install group key!!!!!!\n");
          } else {
          }
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: \n recvframe_chkmic:didn\'t install group key!!!!!!\n");
          } else {
          }
          goto exit;
        } else {
        }
      } else {
        mickey = (u8 *)(& stainfo->dot11tkiprxmickey.skey);
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("\016\n recvframe_chkmic: unicast key\n");
        } else {
        }
      }
      datalen = ((((precvframe->pkt)->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len) - (unsigned int )prxattrib->icv_len) - 8U;
      pframe = (precvframe->pkt)->data;
      payload = pframe + ((unsigned long )prxattrib->hdrlen + (unsigned long )prxattrib->iv_len);
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
        printk("\016\n prxattrib->iv_len =%d prxattrib->icv_len =%d\n", (int )prxattrib->iv_len,
               (int )prxattrib->icv_len);
      } else {
      }
      rtw_seccalctkipmic23a(mickey, pframe, payload, datalen, (u8 *)(& miccode), (int )prxattrib->priority);
      pframemic = payload + (unsigned long )datalen;
      bmic_err = 0U;
      i = 0;
      goto ldv_51802;
      ldv_51801: ;
      if ((int )miccode[i] != (int )*(pframemic + (unsigned long )i)) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("\016recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x) ",
                 i, (int )miccode[i], i, (int )*(pframemic + (unsigned long )i));
        } else {
        }
        bmic_err = 1U;
      } else {
      }
      i = i + 1;
      ldv_51802: ;
      if (i <= 7) {
        goto ldv_51801;
      } else {
      }
      if ((unsigned int )bmic_err == 1U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("\016\n *(pframemic-8)-*(pframemic-1) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                 (int )*(pframemic + 0xfffffffffffffff8UL), (int )*(pframemic + 0xfffffffffffffff9UL),
                 (int )*(pframemic + 0xfffffffffffffffaUL), (int )*(pframemic + 0xfffffffffffffffbUL),
                 (int )*(pframemic + 0xfffffffffffffffcUL), (int )*(pframemic + 0xfffffffffffffffdUL),
                 (int )*(pframemic + 0xfffffffffffffffeUL), (int )*(pframemic + 0xffffffffffffffffUL));
        } else {
        }
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("\016\n *(pframemic-16)-*(pframemic-9) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                 (int )*(pframemic + 0xfffffffffffffff0UL), (int )*(pframemic + 0xfffffffffffffff1UL),
                 (int )*(pframemic + 0xfffffffffffffff2UL), (int )*(pframemic + 0xfffffffffffffff3UL),
                 (int )*(pframemic + 0xfffffffffffffff4UL), (int )*(pframemic + 0xfffffffffffffff5UL),
                 (int )*(pframemic + 0xfffffffffffffff6UL), (int )*(pframemic + 0xfffffffffffffff7UL));
        } else {
        }
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("\016\n ====== demp packet (len =%d) ======\n", (precvframe->pkt)->len);
        } else {
        }
        i___0 = 0;
        goto ldv_51806;
        ldv_51805: ;
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("px%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x", (int )*((precvframe->pkt)->data + (unsigned long )i___0),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 1UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 2UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 3UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 4UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 5UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 6UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 7UL)));
        } else {
        }
        i___0 = i___0 + 8;
        ldv_51806: ;
        if ((unsigned int )i___0 < (precvframe->pkt)->len) {
          goto ldv_51805;
        } else {
        }
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("\016\n ====== demp packet end [len =%d]======\n", (precvframe->pkt)->len);
        } else {
        }
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("\016\n hrdlen =%d,\n", (int )prxattrib->hdrlen);
        } else {
        }
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("\016ra = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x psecuritypriv->binstallGrpkey =%d ",
                 (int )prxattrib->ra[0], (int )prxattrib->ra[1], (int )prxattrib->ra[2],
                 (int )prxattrib->ra[3], (int )prxattrib->ra[4], (int )prxattrib->ra[5],
                 (int )psecuritypriv->binstallGrpkey);
        } else {
        }
        tmp___0 = is_multicast_ether_addr((u8 const *)(& prxattrib->ra));
        if ((int )tmp___0 && (u32 )prxattrib->key_index != pmlmeinfo->key_index) {
          brpt_micerror = 0U;
        } else {
        }
        if ((unsigned int )prxattrib->bdecrypted == 1U && (unsigned int )brpt_micerror == 1U) {
          tmp___1 = is_multicast_ether_addr((u8 const *)(& prxattrib->ra));
          rtw_handle_tkip_mic_err23a(adapter, (int )tmp___1);
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
            printk("\016 mic error :prxattrib->bdecrypted =%d ", (int )prxattrib->bdecrypted);
          } else {
          }
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU:  mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {
          }
        } else {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
            printk("\016 mic error :prxattrib->bdecrypted =%d ", (int )prxattrib->bdecrypted);
          } else {
          }
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU:  mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {
          }
        }
        res = 0;
      } else
      if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
        tmp___2 = is_multicast_ether_addr((u8 const *)(& prxattrib->ra));
        if ((int )tmp___2) {
          psecuritypriv->bcheck_grpkey = 1U;
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
            printk("\016psecuritypriv->bcheck_grpkey = true");
          } else {
          }
        } else {
        }
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016recvframe_chkmic: rtw_get_stainfo23a ==NULL!!!\n");
    } else {
    }
    skb_trim(precvframe->pkt, (precvframe->pkt)->len - 8U);
  } else {
  }
  exit: ;
  return (res);
}
}
struct recv_frame *decryptor(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
struct recv_frame *decryptor(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct recv_frame *return_packet ;
  int res ;
  u8 *iv ;
  {
  prxattrib = & precv_frame->attrib;
  psecuritypriv = & padapter->securitypriv;
  return_packet = precv_frame;
  res = 1;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
    printk("\016prxstat->decrypted =%x prxattrib->encrypt = 0x%03x\n", (int )prxattrib->bdecrypted,
           prxattrib->encrypt);
  } else {
  }
  if (prxattrib->encrypt != 0U) {
    iv = (precv_frame->pkt)->data + (unsigned long )prxattrib->hdrlen;
    prxattrib->key_index = (u8 )((int )*(iv + 3UL) >> 6);
    if ((unsigned int )prxattrib->key_index > 4U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: prxattrib->key_index(%d) > WEP_KEYS\n", (int )prxattrib->key_index);
      } else {
      }
      switch (prxattrib->encrypt) {
      case 1027073U: ;
      case 1027077U:
      prxattrib->key_index = (u8 )psecuritypriv->dot11PrivacyKeyIndex;
      goto ldv_51822;
      case 1027074U: ;
      case 1027076U: ;
      default:
      prxattrib->key_index = (u8 )psecuritypriv->dot118021XGrpKeyid;
      goto ldv_51822;
      }
      ldv_51822: ;
    } else {
    }
  } else {
  }
  if (prxattrib->encrypt != 0U && (unsigned int )prxattrib->bdecrypted == 0U) {
    psecuritypriv->hw_decrypted = 0U;
    switch (prxattrib->encrypt) {
    case 1027073U: ;
    case 1027077U:
    rtw_wep_decrypt23a(padapter, precv_frame);
    goto ldv_51828;
    case 1027074U:
    res = rtw_tkip_decrypt23a(padapter, precv_frame);
    goto ldv_51828;
    case 1027076U:
    res = rtw_aes_decrypt23a(padapter, precv_frame);
    goto ldv_51828;
    default: ;
    goto ldv_51828;
    }
    ldv_51828: ;
  } else
  if (((unsigned int )prxattrib->bdecrypted == 1U && prxattrib->encrypt != 0U) && ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) != 0U || prxattrib->encrypt != 1027074U)) {
    psecuritypriv->hw_decrypted = 1U;
  } else {
  }
  if (res == 0) {
    rtw_free_recvframe23a(return_packet);
    return_packet = (struct recv_frame *)0;
  } else {
  }
  return (return_packet);
}
}
static struct recv_frame *portctrl(struct rtw_adapter *adapter , struct recv_frame *precv_frame )
{
  u8 *psta_addr ;
  u8 *ptr ;
  uint auth_alg ;
  struct recv_frame *pfhdr ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct recv_frame *prtnframe ;
  u16 ether_type ;
  u16 eapol_type ;
  struct rx_pkt_attrib *pattrib ;
  {
  eapol_type = 34958U;
  pstapriv = & adapter->stapriv;
  auth_alg = adapter->securitypriv.dot11AuthAlgrthm;
  pfhdr = precv_frame;
  pattrib = & pfhdr->attrib;
  psta_addr = (u8 *)(& pattrib->ta);
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)psta_addr);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
    printk("\016########portctrl:adapter->securitypriv.dot11AuthAlgrthm =%d\n", adapter->securitypriv.dot11AuthAlgrthm);
  } else {
  }
  if (auth_alg == 2U) {
    ptr = (pfhdr->pkt)->data + (unsigned long )pfhdr->attrib.hdrlen;
    ether_type = (u16 )((int )((short )((int )*(ptr + 6UL) << 8)) | (int )((short )*(ptr + 7UL)));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0) && psta->ieee8021x_blocked != 0U) {
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
        printk("\016########portctrl:psta->ieee8021x_blocked ==1\n");
      } else {
      }
      if ((int )ether_type == (int )eapol_type) {
        prtnframe = precv_frame;
      } else {
        rtw_free_recvframe23a(precv_frame);
        prtnframe = (struct recv_frame *)0;
      }
    } else {
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
        printk("\016########portctrl:psta->ieee8021x_blocked ==0\n");
      } else {
      }
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
        printk("\016portctrl:precv_frame->hdr.attrib.privacy =%x\n", (int )precv_frame->attrib.privacy);
      } else {
      }
      if ((unsigned int )pattrib->bdecrypted == 0U) {
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
          printk("\016portctrl:prxstat->decrypted =%x\n", (int )pattrib->bdecrypted);
        } else {
        }
      } else {
      }
      prtnframe = precv_frame;
      if ((int )ether_type == (int )eapol_type) {
        if (GlobalDebugLevel23A > 5U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
          printk("\016########portctrl:ether_type == 0x888e\n");
        } else {
        }
        prtnframe = precv_frame;
      } else
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
        printk("\016########portctrl:ether_type = 0x%04x\n", (int )ether_type);
      } else {
      }
    }
  } else {
    prtnframe = precv_frame;
  }
  return (prtnframe);
}
}
int recv_decache(struct recv_frame *precv_frame , u8 bretry , struct stainfo_rxcache *prxcache ) ;
int recv_decache(struct recv_frame *precv_frame , u8 bretry , struct stainfo_rxcache *prxcache )
{
  int tid ;
  u16 seq_ctrl ;
  {
  tid = (int )precv_frame->attrib.priority;
  seq_ctrl = (u16 )((int )((short )((int )precv_frame->attrib.seq_num << 4)) | ((int )((short )precv_frame->attrib.frag_num) & 15));
  if (tid > 15) {
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
      printk("\016recv_decache, (tid>15)! seq_ctrl = 0x%x, tid = 0x%x\n", (int )seq_ctrl,
             tid);
    } else {
    }
    return (0);
  } else {
  }
  if ((int )prxcache->tid_rxseq[tid] == (int )seq_ctrl) {
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
      printk("\016recv_decache, seq_ctrl = 0x%x, tid = 0x%x, tid_rxseq = 0x%x\n",
             (int )seq_ctrl, tid, (int )prxcache->tid_rxseq[tid]);
    } else {
    }
    return (0);
  } else {
  }
  prxcache->tid_rxseq[tid] = seq_ctrl;
  return (1);
}
}
void process23a_pwrbit_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void process23a_pwrbit_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  unsigned char pwrbit ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  int tmp ;
  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  pattrib = & precv_frame->attrib;
  pstapriv = & padapter->stapriv;
  psta = (struct sta_info *)0;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->src));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    tmp = ieee80211_has_pm((int )hdr->frame_control);
    pwrbit = (unsigned char )tmp;
    if ((unsigned int )pwrbit != 0U) {
      if ((psta->state & 4U) == 0U) {
        stop_sta_xmit23a(padapter, psta);
      } else {
      }
    } else
    if ((psta->state & 4U) != 0U) {
      wakeup_sta_to_xmit23a(padapter, psta);
    } else {
    }
  } else {
  }
  return;
}
}
void process_wmmps_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
void process_wmmps_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  u8 wmmps_ac ;
  {
  pattrib = & precv_frame->attrib;
  pstapriv = & padapter->stapriv;
  psta = (struct sta_info *)0;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->src));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {
  }
  if (psta->qos_option == 0U) {
    return;
  } else {
  }
  if (((int )psta->qos_info & 15) == 0) {
    return;
  } else {
  }
  if ((psta->state & 4U) != 0U) {
    wmmps_ac = 0U;
    switch ((int )pattrib->priority) {
    case 1: ;
    case 2:
    wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
    goto ldv_51883;
    case 4: ;
    case 5:
    wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
    goto ldv_51883;
    case 6: ;
    case 7:
    wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
    goto ldv_51883;
    case 0: ;
    case 3: ;
    default:
    wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
    goto ldv_51883;
    }
    ldv_51883: ;
    if ((unsigned int )wmmps_ac != 0U) {
      if (psta->sleepq_ac_len != 0U) {
        xmit_delivery_enabled_frames23a(padapter, psta);
      } else {
        issue_qos_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), (int )pattrib->priority,
                              0, 0);
      }
    } else {
    }
  } else {
  }
  return;
}
}
static void count_rx_stats(struct rtw_adapter *padapter , struct recv_frame *prframe ,
                           struct sta_info *sta )
{
  int sz ;
  struct sta_info *psta ;
  struct stainfo_stats *pstats ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_priv *precvpriv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  psta = (struct sta_info *)0;
  pstats = (struct stainfo_stats *)0;
  pattrib = & prframe->attrib;
  precvpriv = & padapter->recvpriv;
  sz = (int )(prframe->pkt)->len;
  precvpriv->rx_bytes = precvpriv->rx_bytes + (u64 )sz;
  padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod = padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod + 1U;
  tmp = is_broadcast_ether_addr((u8 const *)(& pattrib->dst));
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    tmp___1 = is_multicast_ether_addr((u8 const *)(& pattrib->dst));
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod = padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod + 1U;
    } else {
    }
  } else {
  }
  if ((unsigned long )sta != (unsigned long )((struct sta_info *)0)) {
    psta = sta;
  } else {
    psta = prframe->psta;
  }
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    pstats = & psta->sta_stats;
    pstats->rx_data_pkts = pstats->rx_data_pkts + 1ULL;
    pstats->rx_bytes = pstats->rx_bytes + (u64 )sz;
  } else {
  }
  return;
}
}
static int sta2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                              struct sta_info **psta )
{
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int ret ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  u8 *mybssid ;
  u8 *tmp ;
  u8 *myhwaddr ;
  u8 *tmp___0 ;
  u8 *sta_addr ;
  int bmcast ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  bool tmp___19 ;
  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  ret = 1;
  pattrib = & precv_frame->attrib;
  pstapriv = & adapter->stapriv;
  pmlmepriv = & adapter->mlmepriv;
  tmp = get_bssid(pmlmepriv);
  mybssid = tmp;
  tmp___0 = myid(& adapter->eeprompriv);
  myhwaddr = tmp___0;
  sta_addr = (u8 *)0U;
  tmp___1 = is_multicast_ether_addr((u8 const *)(& pattrib->dst));
  bmcast = (int )tmp___1;
  tmp___18 = check_fwstate(pmlmepriv, 32);
  if ((int )tmp___18) {
    goto _L;
  } else {
    tmp___19 = check_fwstate(pmlmepriv, 64);
    if ((int )tmp___19) {
      _L:
      tmp___2 = ether_addr_equal((u8 const *)myhwaddr, (u8 const *)(& pattrib->src));
      if ((int )tmp___2) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
          printk("\016 SA == myself\n");
        } else {
        }
        ret = 0;
        goto exit;
      } else {
      }
      tmp___3 = ether_addr_equal((u8 const *)myhwaddr, (u8 const *)(& pattrib->dst));
      if (tmp___3) {
        tmp___4 = 0;
      } else {
        tmp___4 = 1;
      }
      if (tmp___4 && bmcast == 0) {
        ret = 0;
        goto exit;
      } else {
      }
      tmp___5 = ether_addr_equal((u8 const *)(& pattrib->bssid), (u8 const *)"");
      if ((int )tmp___5) {
        ret = 0;
        goto exit;
      } else {
        tmp___6 = ether_addr_equal((u8 const *)mybssid, (u8 const *)"");
        if ((int )tmp___6) {
          ret = 0;
          goto exit;
        } else {
          tmp___7 = ether_addr_equal((u8 const *)(& pattrib->bssid), (u8 const *)mybssid);
          if (tmp___7) {
            tmp___8 = 0;
          } else {
            tmp___8 = 1;
          }
          if (tmp___8) {
            ret = 0;
            goto exit;
          } else {
          }
        }
      }
      sta_addr = (u8 *)(& pattrib->src);
    } else {
      tmp___17 = check_fwstate(pmlmepriv, 8);
      if ((int )tmp___17) {
        tmp___9 = ether_addr_equal((u8 const *)(& pattrib->bssid), (u8 const *)(& pattrib->src));
        if (tmp___9) {
          tmp___10 = 0;
        } else {
          tmp___10 = 1;
        }
        if (tmp___10) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
            printk("\016bssid != TA under STATION_MODE; drop pkt\n");
          } else {
          }
          ret = 0;
          goto exit;
        } else {
        }
        sta_addr = (u8 *)(& pattrib->bssid);
      } else {
        tmp___16 = check_fwstate(pmlmepriv, 16);
        if ((int )tmp___16) {
          if (bmcast != 0) {
            tmp___11 = is_multicast_ether_addr((u8 const *)(& pattrib->bssid));
            if (tmp___11) {
              tmp___12 = 0;
            } else {
              tmp___12 = 1;
            }
            if (tmp___12) {
              ret = 0;
              goto exit;
            } else {
            }
          } else {
            tmp___13 = ether_addr_equal((u8 const *)(& pattrib->bssid), (u8 const *)(& pattrib->dst));
            if (tmp___13) {
              tmp___14 = 0;
            } else {
              tmp___14 = 1;
            }
            if (tmp___14) {
              ret = 0;
              goto exit;
            } else {
            }
            sta_addr = (u8 *)(& pattrib->src);
          }
        } else {
          tmp___15 = check_fwstate(pmlmepriv, 65536);
          if ((int )tmp___15) {
            ether_addr_copy((u8 *)(& pattrib->dst), (u8 const *)(& hdr->addr1));
            ether_addr_copy((u8 *)(& pattrib->src), (u8 const *)(& hdr->addr2));
            ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const *)(& hdr->addr3));
            ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)(& pattrib->dst));
            ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)(& pattrib->src));
            sta_addr = mybssid;
          } else {
            ret = 0;
          }
        }
      }
    }
  }
  if (bmcast != 0) {
    *psta = rtw_get_bcmc_stainfo23a(adapter);
  } else {
    *psta = rtw_get_stainfo23a(pstapriv, (u8 const *)sta_addr);
  }
  if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016can\'t get psta under sta2sta_data_frame ; drop pkt\n");
    } else {
    }
    ret = 0;
    goto exit;
  } else {
  }
  exit: ;
  return (ret);
}
}
int ap2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) ;
int ap2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta )
{
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  int ret ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  u8 *mybssid ;
  u8 *tmp ;
  u8 *myhwaddr ;
  u8 *tmp___0 ;
  int bmcast ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  pattrib = & precv_frame->attrib;
  ret = 1;
  pstapriv = & adapter->stapriv;
  pmlmepriv = & adapter->mlmepriv;
  tmp = get_bssid(pmlmepriv);
  mybssid = tmp;
  tmp___0 = myid(& adapter->eeprompriv);
  myhwaddr = tmp___0;
  tmp___1 = is_multicast_ether_addr((u8 const *)(& pattrib->dst));
  bmcast = (int )tmp___1;
  tmp___14 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___14) {
    tmp___15 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___15) {
      goto _L___2;
    } else {
      tmp___16 = check_fwstate(pmlmepriv, 128);
      if ((int )tmp___16) {
        _L___2:
        tmp___2 = ether_addr_equal((u8 const *)myhwaddr, (u8 const *)(& pattrib->src));
        if ((int )tmp___2) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
            printk("\016 SA == myself\n");
          } else {
          }
          ret = 0;
          goto exit;
        } else {
        }
        tmp___3 = ether_addr_equal((u8 const *)myhwaddr, (u8 const *)(& pattrib->dst));
        if (tmp___3) {
          tmp___4 = 0;
        } else {
          tmp___4 = 1;
        }
        if (tmp___4 && bmcast == 0) {
          if (GlobalDebugLevel23A > 6U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
            printk("\016 ap2sta_data_frame:  compare DA fail; DA =%02x:%02x:%02x:%02x:%02x:%02x\n",
                   (int )*((u8 *)(& pattrib->dst)), (int )*((u8 *)(& pattrib->dst) + 1UL),
                   (int )*((u8 *)(& pattrib->dst) + 2UL), (int )*((u8 *)(& pattrib->dst) + 3UL),
                   (int )*((u8 *)(& pattrib->dst) + 4UL), (int )*((u8 *)(& pattrib->dst) + 5UL));
          } else {
          }
          ret = 0;
          goto exit;
        } else {
        }
        tmp___5 = ether_addr_equal((u8 const *)(& pattrib->bssid), (u8 const *)"");
        if ((int )tmp___5) {
          goto _L;
        } else {
          tmp___6 = ether_addr_equal((u8 const *)mybssid, (u8 const *)"");
          if ((int )tmp___6) {
            goto _L;
          } else {
            tmp___7 = ether_addr_equal((u8 const *)(& pattrib->bssid), (u8 const *)mybssid);
            if (tmp___7) {
              tmp___8 = 0;
            } else {
              tmp___8 = 1;
            }
            if (tmp___8) {
              _L:
              if (GlobalDebugLevel23A > 6U) {
                printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
                printk("\016 ap2sta_data_frame:  compare BSSID fail ; BSSID =%02x:%02x:%02x:%02x:%02x:%02x\n",
                       (int )*((u8 *)(& pattrib->bssid)), (int )*((u8 *)(& pattrib->bssid) + 1UL),
                       (int )*((u8 *)(& pattrib->bssid) + 2UL), (int )*((u8 *)(& pattrib->bssid) + 3UL),
                       (int )*((u8 *)(& pattrib->bssid) + 4UL), (int )*((u8 *)(& pattrib->bssid) + 5UL));
              } else {
              }
              if (GlobalDebugLevel23A > 6U) {
                printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
                printk("\016mybssid =%02x:%02x:%02x:%02x:%02x:%02x\n", (int )*mybssid,
                       (int )*(mybssid + 1UL), (int )*(mybssid + 2UL), (int )*(mybssid + 3UL),
                       (int )*(mybssid + 4UL), (int )*(mybssid + 5UL));
              } else {
              }
              if (bmcast == 0) {
                if (GlobalDebugLevel23A > 3U) {
                  printk("\016RTL8723AU: issue_deauth23a to the nonassociated ap =%02x:%02x:%02x:%02x:%02x:%02x for the reason(7)\n",
                         (int )*((u8 *)(& pattrib->bssid)), (int )*((u8 *)(& pattrib->bssid) + 1UL),
                         (int )*((u8 *)(& pattrib->bssid) + 2UL), (int )*((u8 *)(& pattrib->bssid) + 3UL),
                         (int )*((u8 *)(& pattrib->bssid) + 4UL), (int )*((u8 *)(& pattrib->bssid) + 5UL));
                } else {
                }
                issue_deauth23a(adapter, (unsigned char *)(& pattrib->bssid), 7);
              } else {
              }
              ret = 0;
              goto exit;
            } else {
            }
          }
        }
        if (bmcast != 0) {
          *psta = rtw_get_bcmc_stainfo23a(adapter);
        } else {
          *psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->bssid));
        }
        if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
            printk("\016ap2sta: can\'t get psta under STATION_MODE ; drop pkt\n");
          } else {
          }
          ret = 0;
          goto exit;
        } else {
        }
        tmp___9 = ieee80211_is_nullfunc((int )hdr->frame_control);
        if (tmp___9 != 0) {
          count_rx_stats(adapter, precv_frame, *psta);
          ret = 2;
          goto exit;
        } else {
        }
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1:
    tmp___12 = check_fwstate(pmlmepriv, 65536);
    if ((int )tmp___12) {
      tmp___13 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___13) {
        ether_addr_copy((u8 *)(& pattrib->dst), (u8 const *)(& hdr->addr1));
        ether_addr_copy((u8 *)(& pattrib->src), (u8 const *)(& hdr->addr2));
        ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const *)(& hdr->addr3));
        ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)(& pattrib->dst));
        ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)(& pattrib->src));
        ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const *)mybssid);
        *psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->bssid));
        if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
            printk("\016can\'t get psta under MP_MODE ; drop pkt\n");
          } else {
          }
          ret = 0;
          goto exit;
        } else {
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0:
      tmp___11 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___11) {
        ret = 2;
        goto exit;
      } else {
        tmp___10 = ether_addr_equal((u8 const *)myhwaddr, (u8 const *)(& pattrib->dst));
        if ((int )tmp___10 && bmcast == 0) {
          *psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->bssid));
          if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
            if (GlobalDebugLevel23A > 3U) {
              printk("\016RTL8723AU: issue_deauth23a to the ap =%02x:%02x:%02x:%02x:%02x:%02x for the reason(7)\n",
                     (int )*((u8 *)(& pattrib->bssid)), (int )*((u8 *)(& pattrib->bssid) + 1UL),
                     (int )*((u8 *)(& pattrib->bssid) + 2UL), (int )*((u8 *)(& pattrib->bssid) + 3UL),
                     (int )*((u8 *)(& pattrib->bssid) + 4UL), (int )*((u8 *)(& pattrib->bssid) + 5UL));
            } else {
            }
            issue_deauth23a(adapter, (unsigned char *)(& pattrib->bssid), 7);
          } else {
          }
        } else {
        }
        ret = 0;
      }
    }
  }
  exit: ;
  return (ret);
}
}
int sta2ap_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) ;
int sta2ap_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta )
{
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  unsigned char *mybssid ;
  u8 *tmp ;
  int ret ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u8 *myhwaddr ;
  u8 *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  {
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  pattrib = & precv_frame->attrib;
  pstapriv = & adapter->stapriv;
  pmlmepriv = & adapter->mlmepriv;
  tmp = get_bssid(pmlmepriv);
  mybssid = tmp;
  ret = 1;
  tmp___7 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___7) {
    tmp___0 = ether_addr_equal((u8 const *)(& pattrib->bssid), (u8 const *)mybssid);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      ret = 0;
      goto exit;
    } else {
    }
    *psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->src));
    if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
        printk("\016can\'t get psta under AP_MODE; drop pkt\n");
      } else {
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: issue_deauth23a to sta =%02x:%02x:%02x:%02x:%02x:%02x for the reason(7)\n",
               (int )*((u8 *)(& pattrib->src)), (int )*((u8 *)(& pattrib->src) + 1UL),
               (int )*((u8 *)(& pattrib->src) + 2UL), (int )*((u8 *)(& pattrib->src) + 3UL),
               (int )*((u8 *)(& pattrib->src) + 4UL), (int )*((u8 *)(& pattrib->src) + 5UL));
      } else {
      }
      issue_deauth23a(adapter, (unsigned char *)(& pattrib->src), 7);
      ret = 2;
      goto exit;
    } else {
    }
    process23a_pwrbit_data(adapter, precv_frame);
    tmp___2 = ieee80211_is_data_qos((int )hdr->frame_control);
    if (tmp___2 != 0) {
      process_wmmps_data(adapter, precv_frame);
    } else {
    }
    tmp___3 = ieee80211_is_nullfunc((int )hdr->frame_control);
    if (tmp___3 != 0) {
      count_rx_stats(adapter, precv_frame, *psta);
      ret = 2;
      goto exit;
    } else {
    }
  } else {
    tmp___4 = myid(& adapter->eeprompriv);
    myhwaddr = tmp___4;
    tmp___5 = ether_addr_equal((u8 const *)(& pattrib->ra), (u8 const *)myhwaddr);
    if (tmp___5) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
    if (tmp___6) {
      ret = 2;
      goto exit;
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: issue_deauth23a to sta =%02x:%02x:%02x:%02x:%02x:%02x for the reason(7)\n",
             (int )*((u8 *)(& pattrib->src)), (int )*((u8 *)(& pattrib->src) + 1UL),
             (int )*((u8 *)(& pattrib->src) + 2UL), (int )*((u8 *)(& pattrib->src) + 3UL),
             (int )*((u8 *)(& pattrib->src) + 4UL), (int )*((u8 *)(& pattrib->src) + 5UL));
    } else {
    }
    issue_deauth23a(adapter, (unsigned char *)(& pattrib->src), 7);
    ret = 2;
    goto exit;
  }
  exit: ;
  return (ret);
}
}
static int validate_recv_ctrl_frame(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct ieee80211_pspoll *psp ;
  u16 aid ;
  u8 wmmps_ac ;
  struct sta_info *psta ;
  struct list_head *xmitframe_plist ;
  struct list_head *xmitframe_phead ;
  struct xmit_frame *pxmitframe ;
  struct xmit_priv *pxmitpriv ;
  struct list_head const *__mptr ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  int tmp___6 ;
  u32 tmp___7 ;
  int tmp___8 ;
  {
  pattrib = & precv_frame->attrib;
  pstapriv = & padapter->stapriv;
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  tmp = ieee80211_is_ctl((int )hdr->frame_control);
  if (tmp == 0) {
    return (0);
  } else {
  }
  tmp___0 = myid(& padapter->eeprompriv);
  tmp___1 = ether_addr_equal((u8 const *)(& hdr->addr1), (u8 const *)tmp___0);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    return (0);
  } else {
  }
  tmp___8 = ieee80211_is_pspoll((int )hdr->frame_control);
  if (tmp___8 != 0) {
    psp = (struct ieee80211_pspoll *)hdr;
    wmmps_ac = 0U;
    psta = (struct sta_info *)0;
    aid = (unsigned int )psp->aid & 16383U;
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& hdr->addr2));
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0) || psta->aid != (uint )aid) {
      return (0);
    } else {
    }
    psta->sta_stats.rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts + 1ULL;
    switch ((int )pattrib->priority) {
    case 1: ;
    case 2:
    wmmps_ac = (unsigned int )psta->uapsd_bk & 1U;
    goto ldv_51968;
    case 4: ;
    case 5:
    wmmps_ac = (unsigned int )psta->uapsd_vi & 1U;
    goto ldv_51968;
    case 6: ;
    case 7:
    wmmps_ac = (unsigned int )psta->uapsd_vo & 1U;
    goto ldv_51968;
    case 0: ;
    case 3: ;
    default:
    wmmps_ac = (unsigned int )psta->uapsd_be & 1U;
    goto ldv_51968;
    }
    ldv_51968: ;
    if ((unsigned int )wmmps_ac != 0U) {
      return (0);
    } else {
    }
    if ((psta->state & 1024U) != 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s alive check-rx ps-poll\n", "validate_recv_ctrl_frame");
      } else {
      }
      psta->expire_to = pstapriv->expire_to;
      psta->state = psta->state ^ 1024U;
    } else {
    }
    if ((psta->state & 4U) != 0U) {
      tmp___7 = CHKBIT(psta->aid);
      if (((u32 )pstapriv->sta_dz_bitmap & tmp___7) != 0U) {
        pxmitpriv = & padapter->xmitpriv;
        spin_lock_bh(& pxmitpriv->lock);
        xmitframe_phead = get_list_head(& psta->sleep_q);
        xmitframe_plist = xmitframe_phead->next;
        tmp___6 = list_empty((struct list_head const *)xmitframe_phead);
        if (tmp___6 == 0) {
          __mptr = (struct list_head const *)xmitframe_plist;
          pxmitframe = (struct xmit_frame *)__mptr;
          xmitframe_plist = xmitframe_plist->next;
          list_del_init(& pxmitframe->list);
          psta->sleepq_len = psta->sleepq_len - 1U;
          if (psta->sleepq_len != 0U) {
            pxmitframe->attrib.mdata = 1U;
          } else {
            pxmitframe->attrib.mdata = 0U;
          }
          pxmitframe->attrib.triggered = 1U;
          rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
          if (psta->sleepq_len == 0U) {
            tmp___3 = CHKBIT(psta->aid);
            pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___3));
            update_beacon23a(padapter, 5, (u8 *)0U, 0);
          } else {
          }
          spin_unlock_bh(& pxmitpriv->lock);
        } else {
          spin_unlock_bh(& pxmitpriv->lock);
          tmp___5 = CHKBIT(psta->aid);
          if (((u32 )pstapriv->tim_bitmap & tmp___5) != 0U) {
            if (psta->sleepq_len == 0U) {
              if (GlobalDebugLevel23A > 3U) {
                printk("\016RTL8723AU: no buffered packets to xmit\n");
              } else {
              }
              issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 0,
                                0);
            } else {
              if (GlobalDebugLevel23A > 3U) {
                printk("\016RTL8723AU: error!psta->sleepq_len =%d\n", psta->sleepq_len);
              } else {
              }
              psta->sleepq_len = 0U;
            }
            tmp___4 = CHKBIT(psta->aid);
            pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___4));
            update_beacon23a(padapter, 5, (u8 *)0U, 0);
          } else {
          }
        }
      } else {
      }
    } else {
    }
  } else {
  }
  return (0);
}
}
struct recv_frame *recvframe_chk_defrag23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
static int validate_recv_mgnt_frame(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct sta_info *psta ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  {
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
    printk("\016+validate_recv_mgnt_frame\n");
  } else {
  }
  precv_frame = recvframe_chk_defrag23a(padapter, precv_frame);
  if ((unsigned long )precv_frame == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
      printk("\016%s: fragment packet\n", "validate_recv_mgnt_frame");
    } else {
    }
    return (1);
  } else {
  }
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& hdr->addr2));
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    psta->sta_stats.rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts + 1ULL;
    tmp___4 = ieee80211_is_beacon((int )hdr->frame_control);
    if (tmp___4 != 0) {
      psta->sta_stats.rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts + 1ULL;
    } else {
      tmp___3 = ieee80211_is_probe_req((int )hdr->frame_control);
      if (tmp___3 != 0) {
        psta->sta_stats.rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts + 1ULL;
      } else {
        tmp___2 = ieee80211_is_probe_resp((int )hdr->frame_control);
        if (tmp___2 != 0) {
          tmp___1 = ether_addr_equal((u8 const *)(& padapter->eeprompriv.mac_addr),
                                     (u8 const *)(& hdr->addr1));
          if ((int )tmp___1) {
            psta->sta_stats.rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts + 1ULL;
          } else {
            tmp = is_broadcast_ether_addr((u8 const *)(& hdr->addr1));
            if ((int )tmp) {
              psta->sta_stats.rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts + 1ULL;
            } else {
              tmp___0 = is_multicast_ether_addr((u8 const *)(& hdr->addr1));
              if ((int )tmp___0) {
                psta->sta_stats.rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts + 1ULL;
              } else {
                psta->sta_stats.rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts + 1ULL;
              }
            }
          }
        } else {
        }
      }
    }
  } else {
  }
  mgt_dispatcher23a(padapter, precv_frame);
  return (1);
}
}
static int validate_recv_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame )
{
  u8 bretry ;
  u8 *psa ;
  u8 *pda ;
  struct sta_info *psta ;
  struct rx_pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  int ret ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  int tmp___0 ;
  __le16 *qptr ;
  u8 *tmp___1 ;
  u16 qos_ctrl ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  {
  psta = (struct sta_info *)0;
  pattrib = & precv_frame->attrib;
  psecuritypriv = & adapter->securitypriv;
  ret = 1;
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  tmp = ieee80211_has_retry((int )hdr->frame_control);
  bretry = (u8 )tmp;
  pda = ieee80211_get_DA(hdr);
  psa = ieee80211_get_SA(hdr);
  ether_addr_copy((u8 *)(& pattrib->dst), (u8 const *)pda);
  ether_addr_copy((u8 *)(& pattrib->src), (u8 const *)psa);
  switch ((int )hdr->frame_control & 768) {
  case 0:
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const *)(& hdr->addr3));
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)pda);
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)psa);
  ret = sta2sta_data_frame(adapter, precv_frame, & psta);
  goto ldv_52008;
  case 512:
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const *)(& hdr->addr2));
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)pda);
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)(& hdr->addr2));
  ret = ap2sta_data_frame(adapter, precv_frame, & psta);
  goto ldv_52008;
  case 256:
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const *)(& hdr->addr1));
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)(& hdr->addr1));
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)psa);
  ret = sta2ap_data_frame(adapter, precv_frame, & psta);
  goto ldv_52008;
  case 768:
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const *)(& hdr->addr1));
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)(& hdr->addr1));
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)(& hdr->addr2));
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
    printk("\016 case 3\n");
  } else {
  }
  goto ldv_52008;
  }
  ldv_52008: ;
  if (ret == 0 || ret == 2) {
    goto exit;
  } else {
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016 after to_fr_ds_chk; psta == NULL\n");
    } else {
    }
    ret = 0;
    goto exit;
  } else {
  }
  precv_frame->psta = psta;
  pattrib->hdrlen = 24U;
  tmp___0 = ieee80211_has_a4((int )hdr->frame_control);
  if (tmp___0 != 0) {
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 6U;
  } else {
  }
  if ((unsigned int )pattrib->qos == 1U) {
    tmp___1 = ieee80211_get_qos_ctl(hdr);
    qptr = (__le16 *)tmp___1;
    qos_ctrl = *qptr;
    pattrib->priority = (unsigned int )((u8 )qos_ctrl) & 15U;
    pattrib->ack_policy = (unsigned int )((u8 )((int )qos_ctrl >> 5)) & 3U;
    pattrib->amsdu = (u8 )(((int )qos_ctrl & 128) >> 7);
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 2U;
    if ((unsigned int )pattrib->priority != 0U && (unsigned int )pattrib->priority != 3U) {
      adapter->recvpriv.bIsAnyNonBEPkts = 1U;
    } else {
    }
  } else {
    pattrib->priority = 0U;
    pattrib->ack_policy = 0U;
    pattrib->amsdu = 0U;
  }
  if ((unsigned int )pattrib->order != 0U) {
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 4U;
  } else {
  }
  precv_frame->preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )pattrib->priority;
  tmp___2 = recv_decache(precv_frame, (int )bretry, & psta->sta_recvpriv.rxcache);
  if (tmp___2 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016decache : drop pkt\n");
    } else {
    }
    ret = 0;
    goto exit;
  } else {
  }
  if ((unsigned int )pattrib->privacy != 0U) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
      printk("\016validate_recv_data_frame:pattrib->privacy =%x\n", (int )pattrib->privacy);
    } else {
    }
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
      tmp___3 = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
      printk("\016\n ^^^^^^^^^^^is_multicast_ether_addr(pattrib->ra(0x%02x)) =%d^^^^^^^^^^^^^^^6\n",
             (int )pattrib->ra[0], (int )tmp___3);
    } else {
    }
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U:
    pattrib->encrypt = psecuritypriv->dot11PrivacyAlgrthm;
    goto ldv_52018;
    case 2U:
    tmp___4 = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
    if ((int )tmp___4) {
      pattrib->encrypt = psecuritypriv->dot118021XGrpPrivacy;
    } else {
      pattrib->encrypt = psta->dot118021XPrivacy;
    }
    goto ldv_52018;
    }
    ldv_52018: ;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
      printk("\016\n pattrib->encrypt =%d\n", pattrib->encrypt);
    } else {
    }
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U:
    pattrib->iv_len = 4U;
    pattrib->icv_len = 4U;
    goto ldv_52022;
    case 1027074U:
    pattrib->iv_len = 8U;
    pattrib->icv_len = 4U;
    goto ldv_52022;
    case 1027076U:
    pattrib->iv_len = 8U;
    pattrib->icv_len = 8U;
    goto ldv_52022;
    default:
    pattrib->iv_len = 0U;
    pattrib->icv_len = 0U;
    goto ldv_52022;
    }
    ldv_52022: ;
  } else {
    pattrib->encrypt = 0U;
    pattrib->iv_len = 0U;
    pattrib->icv_len = 0U;
  }
  exit: ;
  return (ret);
}
}
static void dump_rx_pkt(struct sk_buff *skb , u16 type , int level )
{
  int i ;
  u8 *ptr ;
  {
  if ((level == 1 || (level == 2 && (unsigned int )type == 0U)) || (level == 3 && (unsigned int )type == 8U)) {
    ptr = skb->data;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: #############################\n");
    } else {
    }
    i = 0;
    goto ldv_52034;
    ldv_52033: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", (int )*(ptr + (unsigned long )i),
             (int )*(ptr + ((unsigned long )i + 1UL)), (int )*(ptr + ((unsigned long )i + 2UL)),
             (int )*(ptr + ((unsigned long )i + 3UL)), (int )*(ptr + ((unsigned long )i + 4UL)),
             (int )*(ptr + ((unsigned long )i + 5UL)), (int )*(ptr + ((unsigned long )i + 6UL)),
             (int )*(ptr + ((unsigned long )i + 7UL)));
    } else {
    }
    i = i + 8;
    ldv_52034: ;
    if (i <= 63) {
      goto ldv_52033;
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: #############################\n");
    } else {
    }
  } else {
  }
  return;
}
}
static int validate_recv_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame )
{
  u8 type ;
  u8 subtype ;
  int retval ;
  struct rx_pkt_attrib *pattrib ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 ver ;
  u8 bDumpRxPkt ;
  u16 seq_ctrl ;
  u16 fctl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  struct recv_priv *precvpriv ;
  {
  retval = 1;
  pattrib = & precv_frame->attrib;
  skb = precv_frame->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  fctl = hdr->frame_control;
  ver = (unsigned int )((u8 )fctl) & 3U;
  type = (unsigned int )((u8 )fctl) & 12U;
  subtype = (unsigned int )((u8 )fctl) & 240U;
  if ((unsigned int )ver != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016validate_recv_data_frame fail! (ver!= 0)\n");
    } else {
    }
    retval = 0;
    goto exit;
  } else {
  }
  seq_ctrl = hdr->seq_ctrl;
  pattrib->frag_num = (unsigned int )((u8 )seq_ctrl) & 15U;
  pattrib->seq_num = (u16 )((int )seq_ctrl >> 4);
  tmp = ieee80211_has_pm((int )hdr->frame_control);
  pattrib->pw_save = (u8 )tmp;
  tmp___0 = ieee80211_has_morefrags((int )hdr->frame_control);
  pattrib->mfrag = (u8 )tmp___0;
  tmp___1 = ieee80211_has_moredata((int )hdr->frame_control);
  pattrib->mdata = (u8 )tmp___1;
  tmp___2 = ieee80211_has_protected((int )hdr->frame_control);
  pattrib->privacy = (u8 )tmp___2;
  tmp___3 = ieee80211_has_order((int )hdr->frame_control);
  pattrib->order = (u8 )tmp___3;
  GetHalDefVar8192CUsb(adapter, 6, (void *)(& bDumpRxPkt));
  tmp___4 = ldv__builtin_expect((unsigned int )bDumpRxPkt == 1U, 0L);
  if (tmp___4 != 0L) {
    dump_rx_pkt(skb, (int )type, (int )bDumpRxPkt);
  } else {
  }
  switch ((int )type) {
  case 0:
  retval = validate_recv_mgnt_frame(adapter, precv_frame);
  if (retval == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016validate_recv_mgnt_frame fail\n");
    } else {
    }
  } else {
  }
  retval = 0;
  goto ldv_52052;
  case 4:
  retval = validate_recv_ctrl_frame(adapter, precv_frame);
  if (retval == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016validate_recv_ctrl_frame fail\n");
    } else {
    }
  } else {
  }
  retval = 0;
  goto ldv_52052;
  case 8:
  pattrib->qos = (int )((signed char )subtype) < 0;
  retval = validate_recv_data_frame(adapter, precv_frame);
  if (retval == 0) {
    precvpriv = & adapter->recvpriv;
    precvpriv->rx_drop = precvpriv->rx_drop + 1ULL;
  } else {
  }
  goto ldv_52052;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
    printk("\016validate_recv_data_frame fail! type = 0x%x\n", (int )type);
  } else {
  }
  retval = 0;
  goto ldv_52052;
  }
  ldv_52052: ;
  exit: ;
  return (retval);
}
}
static int wlanhdr_to_ethhdr(struct recv_frame *precvframe )
{
  u16 eth_type ;
  u16 len ;
  u16 hdrlen ;
  u8 bsnaphdr ;
  u8 *psnap ;
  int ret ;
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  struct sk_buff *skb ;
  u8 *ptr ;
  struct rx_pkt_attrib *pattrib ;
  bool tmp ;
  bool tmp___0 ;
  unsigned char *tmp___1 ;
  size_t __len ;
  void *__ret ;
  unsigned char *tmp___2 ;
  bool tmp___3 ;
  __u16 tmp___4 ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  ret = 1;
  adapter = precvframe->adapter;
  pmlmepriv = & adapter->mlmepriv;
  skb = precvframe->pkt;
  pattrib = & precvframe->attrib;
  ptr = skb->data;
  hdrlen = (u16 )pattrib->hdrlen;
  psnap = ptr + (unsigned long )hdrlen;
  eth_type = (u16 )((int )((short )((int )*(psnap + 6UL) << 8)) | (int )((short )*(psnap + 7UL)));
  tmp = ether_addr_equal((u8 const *)psnap, (u8 const *)(& rfc1042_header));
  if (((int )tmp && (unsigned int )eth_type != 33011U) && (unsigned int )eth_type != 33079U) {
    bsnaphdr = 1U;
    hdrlen = (unsigned int )hdrlen + 6U;
  } else {
    tmp___0 = ether_addr_equal((u8 const *)psnap, (u8 const *)(& bridge_tunnel_header));
    if ((int )tmp___0) {
      bsnaphdr = 1U;
      hdrlen = (unsigned int )hdrlen + 6U;
    } else {
      bsnaphdr = 0U;
      eth_type = (u16 )((int )((short )((int )*psnap << 8)) | (int )((short )*(psnap + 1UL)));
    }
  }
  len = (int )((u16 )skb->len) - (int )hdrlen;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
    printk("\016\n === pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n", (int )pattrib->hdrlen,
           (int )pattrib->iv_len);
  } else {
  }
  pattrib->eth_type = eth_type;
  tmp___3 = check_fwstate(pmlmepriv, 65536);
  if ((int )tmp___3) {
    ptr = ptr + (unsigned long )hdrlen;
    *ptr = 135U;
    *(ptr + 1UL) = 18U;
    eth_type = 34578U;
    tmp___1 = skb_pull(skb, (unsigned int )hdrlen - 36U);
    ptr = tmp___1;
    __len = 24UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)ptr, (void const *)skb->head, __len);
    } else {
      __ret = memcpy((void *)ptr, (void const *)skb->head, __len);
    }
    ptr = ptr + 24UL;
  } else {
    tmp___2 = skb_pull(skb, ((unsigned int )hdrlen + ((unsigned int )bsnaphdr != 0U ? 2U : 0U)) - 14U);
    ptr = tmp___2;
  }
  ether_addr_copy(ptr, (u8 const *)(& pattrib->dst));
  ether_addr_copy(ptr + 6UL, (u8 const *)(& pattrib->src));
  if ((unsigned int )bsnaphdr == 0U) {
    tmp___4 = __fswab16((int )len);
    len = tmp___4;
    __len___0 = 2UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)ptr + 12U, (void const *)(& len), __len___0);
    } else {
      __ret___0 = memcpy((void *)ptr + 12U, (void const *)(& len), __len___0);
    }
  } else {
  }
  return (ret);
}
}
struct recv_frame *recvframe_defrag(struct rtw_adapter *adapter , struct rtw_queue *defrag_q ) ;
struct recv_frame *recvframe_defrag(struct rtw_adapter *adapter , struct rtw_queue *defrag_q )
{
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  u8 *data ;
  u8 wlanhdr_offset ;
  u8 curfragnum ;
  struct recv_frame *pnfhdr ;
  struct recv_frame *prframe ;
  struct recv_frame *pnextrframe ;
  struct rtw_queue *pfree_recv_queue ;
  struct sk_buff *skb ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  size_t __len ;
  void *__ret ;
  unsigned char *tmp___0 ;
  {
  curfragnum = 0U;
  pfree_recv_queue = & adapter->recvpriv.free_recv_queue;
  phead = get_list_head(defrag_q);
  plist = phead->next;
  __mptr = (struct list_head const *)plist;
  prframe = (struct recv_frame *)__mptr;
  list_del_init(& prframe->list);
  skb = prframe->pkt;
  if ((int )prframe->attrib.frag_num != (int )curfragnum) {
    rtw_free_recvframe23a(prframe);
    rtw_free_recvframe23a_queue(defrag_q);
    return ((struct recv_frame *)0);
  } else {
  }
  curfragnum = (u8 )((int )curfragnum + 1);
  phead = get_list_head(defrag_q);
  data = (prframe->pkt)->data;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_52103;
  ldv_52102:
  __mptr___0 = (struct list_head const *)plist;
  pnfhdr = (struct recv_frame *)__mptr___0;
  pnextrframe = pnfhdr;
  if ((int )pnfhdr->attrib.frag_num != (int )curfragnum) {
    rtw_free_recvframe23a(prframe);
    rtw_free_recvframe23a_queue(defrag_q);
    return ((struct recv_frame *)0);
  } else {
  }
  curfragnum = (u8 )((int )curfragnum + 1);
  wlanhdr_offset = (int )pnfhdr->attrib.hdrlen + (int )pnfhdr->attrib.iv_len;
  skb_pull(pnfhdr->pkt, (unsigned int )wlanhdr_offset);
  skb_trim(skb, skb->len - (unsigned int )prframe->attrib.icv_len);
  __len = (size_t )(pnfhdr->pkt)->len;
  tmp___0 = skb_tail_pointer((struct sk_buff const *)skb);
  __ret = memcpy((void *)tmp___0, (void const *)(pnfhdr->pkt)->data, __len);
  skb_put(skb, (pnfhdr->pkt)->len);
  prframe->attrib.icv_len = pnfhdr->attrib.icv_len;
  plist = ptmp;
  ptmp = plist->next;
  ldv_52103: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_52102;
  } else {
  }
  rtw_free_recvframe23a_queue(defrag_q);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
    printk("\016Performance defrag!!!!!\n");
  } else {
  }
  return (prframe);
}
}
struct recv_frame *recvframe_chk_defrag23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  u8 ismfrag ;
  u8 fragnum ;
  u8 *psta_addr ;
  struct recv_frame *pfhdr ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct list_head *phead ;
  struct recv_frame *prtnframe ;
  struct rtw_queue *pfree_recv_queue ;
  struct rtw_queue *pdefrag_q ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  prtnframe = (struct recv_frame *)0;
  pstapriv = & padapter->stapriv;
  pfhdr = precv_frame;
  pfree_recv_queue = & padapter->recvpriv.free_recv_queue;
  ismfrag = pfhdr->attrib.mfrag;
  fragnum = pfhdr->attrib.frag_num;
  psta_addr = (u8 *)(& pfhdr->attrib.ta);
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)psta_addr);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    hdr = (struct ieee80211_hdr *)(pfhdr->pkt)->data;
    tmp = ieee80211_is_data((int )hdr->frame_control);
    if (tmp == 0) {
      psta = rtw_get_bcmc_stainfo23a(padapter);
      pdefrag_q = & psta->sta_recvpriv.defrag_q;
    } else {
      pdefrag_q = (struct rtw_queue *)0;
    }
  } else {
    pdefrag_q = & psta->sta_recvpriv.defrag_q;
  }
  if ((unsigned int )ismfrag == 0U && (unsigned int )fragnum == 0U) {
    prtnframe = precv_frame;
  } else {
  }
  if ((unsigned int )ismfrag == 1U) {
    if ((unsigned long )pdefrag_q != (unsigned long )((struct rtw_queue *)0)) {
      if ((unsigned int )fragnum == 0U) {
        tmp___0 = list_empty((struct list_head const *)(& pdefrag_q->queue));
        if (tmp___0 == 0) {
          rtw_free_recvframe23a_queue(pdefrag_q);
        } else {
        }
      } else {
      }
      phead = get_list_head(pdefrag_q);
      list_add_tail(& pfhdr->list, phead);
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
        printk("\016Enqueuq: ismfrag = %d, fragnum = %d\n", (int )ismfrag, (int )fragnum);
      } else {
      }
      prtnframe = (struct recv_frame *)0;
    } else {
      rtw_free_recvframe23a(precv_frame);
      prtnframe = (struct recv_frame *)0;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
        printk("\016Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",
               (int )ismfrag, (int )fragnum);
      } else {
      }
    }
  } else {
  }
  if ((unsigned int )ismfrag == 0U && (unsigned int )fragnum != 0U) {
    if ((unsigned long )pdefrag_q != (unsigned long )((struct rtw_queue *)0)) {
      phead = get_list_head(pdefrag_q);
      list_add_tail(& pfhdr->list, phead);
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
        printk("\016defrag: ismfrag = %d, fragnum = %d\n", (int )ismfrag, (int )fragnum);
      } else {
      }
      precv_frame = recvframe_defrag(padapter, pdefrag_q);
      prtnframe = precv_frame;
    } else {
      rtw_free_recvframe23a(precv_frame);
      prtnframe = (struct recv_frame *)0;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
        printk("\016Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",
               (int )ismfrag, (int )fragnum);
      } else {
      }
    }
  } else {
  }
  if ((unsigned long )prtnframe != (unsigned long )((struct recv_frame *)0) && (unsigned int )prtnframe->attrib.privacy != 0U) {
    tmp___1 = recvframe_chkmic(padapter, prtnframe);
    if (tmp___1 == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
        printk("\016recvframe_chkmic(padapter,  prtnframe) ==_FAIL\n");
      } else {
      }
      rtw_free_recvframe23a(prtnframe);
      prtnframe = (struct recv_frame *)0;
    } else {
    }
  } else {
  }
  return (prtnframe);
}
}
int amsdu_to_msdu(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
int amsdu_to_msdu(struct rtw_adapter *padapter , struct recv_frame *prframe )
{
  struct rx_pkt_attrib *pattrib ;
  struct sk_buff *skb ;
  struct sk_buff *sub_skb ;
  struct sk_buff_head skb_list ;
  int tmp ;
  {
  pattrib = & prframe->attrib;
  skb = prframe->pkt;
  skb_pull(skb, (unsigned int )prframe->attrib.hdrlen);
  __skb_queue_head_init(& skb_list);
  ieee80211_amsdu_to_8023s(skb, & skb_list, (u8 const *)0U, 0, 0U, 0);
  goto ldv_52132;
  ldv_52131:
  sub_skb = __skb_dequeue(& skb_list);
  sub_skb->protocol = eth_type_trans(sub_skb, padapter->pnetdev);
  sub_skb->dev = padapter->pnetdev;
  sub_skb->ip_summed = 0U;
  netif_rx(sub_skb);
  ldv_52132:
  tmp = skb_queue_empty((struct sk_buff_head const *)(& skb_list));
  if (tmp == 0) {
    goto ldv_52131;
  } else {
  }
  prframe->pkt = (struct sk_buff *)0;
  rtw_free_recvframe23a(prframe);
  return (1);
}
}
int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl , u16 seq_num ) ;
int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl , u16 seq_num )
{
  u8 wsize ;
  u16 wend ;
  {
  wsize = preorder_ctrl->wsize_b;
  wend = (unsigned int )((u16 )((unsigned int )((int )preorder_ctrl->indicate_seq + (int )((unsigned short )wsize)) + 65535U)) & 4095U;
  if ((unsigned int )preorder_ctrl->indicate_seq == 65535U) {
    preorder_ctrl->indicate_seq = seq_num;
  } else {
  }
  if ((((int )seq_num - (int )preorder_ctrl->indicate_seq) & 2048) != 0) {
    return (0);
  } else {
  }
  if ((int )preorder_ctrl->indicate_seq == (int )seq_num) {
    preorder_ctrl->indicate_seq = (unsigned int )((u16 )((unsigned int )preorder_ctrl->indicate_seq + 1U)) & 4095U;
  } else
  if ((((int )wend - (int )seq_num) & 2048) != 0) {
    if ((int )seq_num >= (int )wsize + -1) {
      preorder_ctrl->indicate_seq = (unsigned int )((int )seq_num - (int )((u16 )wsize)) + 1U;
    } else {
      preorder_ctrl->indicate_seq = (unsigned int )((int )seq_num - (int )((u16 )wsize)) + 4097U;
    }
  } else {
  }
  return (1);
}
}
static int enqueue_reorder_recvframe23a(struct recv_reorder_ctrl *preorder_ctrl ,
                                        struct recv_frame *prframe )
{
  struct rx_pkt_attrib *pattrib ;
  struct rtw_queue *ppending_recvframe_queue ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct recv_frame *hdr ;
  struct rx_pkt_attrib *pnextattrib ;
  struct list_head const *__mptr ;
  {
  pattrib = & prframe->attrib;
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  phead = get_list_head(ppending_recvframe_queue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_52159;
  ldv_52158:
  __mptr = (struct list_head const *)plist;
  hdr = (struct recv_frame *)__mptr;
  pnextattrib = & hdr->attrib;
  if ((((int )pnextattrib->seq_num - (int )pattrib->seq_num) & 2048) != 0) {
    goto ldv_52156;
  } else
  if ((int )pnextattrib->seq_num == (int )pattrib->seq_num) {
    return (0);
  } else {
    goto ldv_52157;
  }
  ldv_52156:
  plist = ptmp;
  ptmp = plist->next;
  ldv_52159: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_52158;
  } else {
  }
  ldv_52157:
  list_del_init(& prframe->list);
  list_add_tail(& prframe->list, plist);
  return (1);
}
}
int recv_indicatepkts_in_order(struct rtw_adapter *padapter , struct recv_reorder_ctrl *preorder_ctrl ,
                               int bforced ) ;
int recv_indicatepkts_in_order(struct rtw_adapter *padapter , struct recv_reorder_ctrl *preorder_ctrl ,
                               int bforced )
{
  struct list_head *phead ;
  struct list_head *plist ;
  struct recv_frame *prframe ;
  struct rx_pkt_attrib *pattrib ;
  int bPktInBuf ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *ppending_recvframe_queue ;
  int tmp ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  int tmp___0 ;
  int tmp___1 ;
  {
  bPktInBuf = 0;
  precvpriv = & padapter->recvpriv;
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  phead = get_list_head(ppending_recvframe_queue);
  plist = phead->next;
  if (bforced != 0) {
    tmp = list_empty((struct list_head const *)phead);
    if (tmp != 0) {
      return (1);
    } else {
    }
    __mptr = (struct list_head const *)plist;
    prframe = (struct recv_frame *)__mptr;
    pattrib = & prframe->attrib;
    preorder_ctrl->indicate_seq = pattrib->seq_num;
  } else {
  }
  goto ldv_52182;
  ldv_52181:
  __mptr___0 = (struct list_head const *)plist;
  prframe = (struct recv_frame *)__mptr___0;
  pattrib = & prframe->attrib;
  if ((((int )preorder_ctrl->indicate_seq - (int )pattrib->seq_num) & 2048) == 0) {
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
      printk("\016recv_indicatepkts_in_order: indicate =%d seq =%d amsdu =%d\n", (int )preorder_ctrl->indicate_seq,
             (int )pattrib->seq_num, (int )pattrib->amsdu);
    } else {
    }
    plist = plist->next;
    list_del_init(& prframe->list);
    if ((int )preorder_ctrl->indicate_seq == (int )pattrib->seq_num) {
      preorder_ctrl->indicate_seq = (unsigned int )((u16 )((unsigned int )preorder_ctrl->indicate_seq + 1U)) & 4095U;
    } else {
    }
    if ((unsigned int )pattrib->amsdu == 0U) {
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
        rtw_recv_indicatepkt23a(padapter, prframe);
      } else {
      }
    } else {
      tmp___0 = amsdu_to_msdu(padapter, prframe);
      if (tmp___0 != 1) {
        rtw_free_recvframe23a(prframe);
      } else {
      }
    }
    bPktInBuf = 0;
  } else {
    bPktInBuf = 1;
    goto ldv_52180;
  }
  ldv_52182:
  tmp___1 = list_empty((struct list_head const *)phead);
  if (tmp___1 == 0) {
    goto ldv_52181;
  } else {
  }
  ldv_52180: ;
  return (bPktInBuf);
}
}
int recv_indicatepkt_reorder(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
int recv_indicatepkt_reorder(struct rtw_adapter *padapter , struct recv_frame *prframe )
{
  int retval ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct rtw_queue *ppending_recvframe_queue ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  {
  retval = 1;
  pattrib = & prframe->attrib;
  preorder_ctrl = prframe->preorder_ctrl;
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  if ((unsigned int )pattrib->amsdu == 0U) {
    wlanhdr_to_ethhdr(prframe);
    if (((unsigned int )pattrib->qos != 1U || (unsigned int )pattrib->eth_type == 2054U) || (unsigned int )pattrib->ack_policy != 0U) {
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
        if (GlobalDebugLevel23A > 5U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
          printk("\016@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n");
        } else {
        }
        rtw_recv_indicatepkt23a(padapter, prframe);
        return (1);
      } else {
      }
      return (0);
    } else {
    }
    if ((unsigned int )preorder_ctrl->enable == 0U) {
      preorder_ctrl->indicate_seq = pattrib->seq_num;
      rtw_recv_indicatepkt23a(padapter, prframe);
      preorder_ctrl->indicate_seq = (u16 )(((int )preorder_ctrl->indicate_seq + 1) % 4096);
      return (1);
    } else {
    }
  } else
  if ((unsigned int )preorder_ctrl->enable == 0U) {
    preorder_ctrl->indicate_seq = pattrib->seq_num;
    retval = amsdu_to_msdu(padapter, prframe);
    preorder_ctrl->indicate_seq = (u16 )(((int )preorder_ctrl->indicate_seq + 1) % 4096);
    return (retval);
  } else {
  }
  spin_lock_bh(& ppending_recvframe_queue->lock);
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
    printk("\016recv_indicatepkt_reorder: indicate =%d seq =%d\n", (int )preorder_ctrl->indicate_seq,
           (int )pattrib->seq_num);
  } else {
  }
  tmp = check_indicate_seq(preorder_ctrl, (int )pattrib->seq_num);
  if (tmp == 0) {
    goto _err_exit;
  } else {
  }
  tmp___0 = enqueue_reorder_recvframe23a(preorder_ctrl, prframe);
  if (tmp___0 == 0) {
    goto _err_exit;
  } else {
  }
  tmp___2 = recv_indicatepkts_in_order(padapter, preorder_ctrl, 0);
  if (tmp___2 == 1) {
    tmp___1 = msecs_to_jiffies(50U);
    ldv_mod_timer_662(& preorder_ctrl->reordering_ctrl_timer, tmp___1 + (unsigned long )jiffies);
    spin_unlock_bh(& ppending_recvframe_queue->lock);
  } else {
    spin_unlock_bh(& ppending_recvframe_queue->lock);
    ldv_del_timer_sync_663(& preorder_ctrl->reordering_ctrl_timer);
  }
  return (1);
  _err_exit:
  spin_unlock_bh(& ppending_recvframe_queue->lock);
  return (0);
}
}
void rtw_reordering_ctrl_timeout_handler23a(unsigned long pcontext )
{
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct rtw_adapter *padapter ;
  struct rtw_queue *ppending_recvframe_queue ;
  unsigned long tmp ;
  int tmp___0 ;
  {
  preorder_ctrl = (struct recv_reorder_ctrl *)pcontext;
  padapter = preorder_ctrl->padapter;
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    return;
  } else {
  }
  spin_lock_bh(& ppending_recvframe_queue->lock);
  tmp___0 = recv_indicatepkts_in_order(padapter, preorder_ctrl, 1);
  if (tmp___0 == 1) {
    tmp = msecs_to_jiffies(50U);
    ldv_mod_timer_664(& preorder_ctrl->reordering_ctrl_timer, tmp + (unsigned long )jiffies);
  } else {
  }
  spin_unlock_bh(& ppending_recvframe_queue->lock);
  return;
}
}
int process_recv_indicatepkts(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
int process_recv_indicatepkts(struct rtw_adapter *padapter , struct recv_frame *prframe )
{
  int retval ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  int tmp ;
  {
  retval = 1;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  if (phtpriv->ht_option == 1U) {
    tmp = recv_indicatepkt_reorder(padapter, prframe);
    if (tmp != 1) {
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
        retval = 0;
        return (retval);
      } else {
      }
    } else {
    }
  } else {
    retval = wlanhdr_to_ethhdr(prframe);
    if (retval != 1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
        printk("\016wlanhdr_to_ethhdr: drop pkt\n");
      } else {
      }
      return (retval);
    } else {
    }
    if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
      if (GlobalDebugLevel23A > 5U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
        printk("\016@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n");
      } else {
      }
      rtw_recv_indicatepkt23a(padapter, prframe);
    } else {
      if (GlobalDebugLevel23A > 5U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
        printk("\016@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n");
      } else {
      }
      if (GlobalDebugLevel23A > 5U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
        printk("\016recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped,
               padapter->bSurpriseRemoved);
      } else {
      }
      retval = 0;
      return (retval);
    }
  }
  return (retval);
}
}
static int recv_func_prehandle(struct rtw_adapter *padapter , struct recv_frame *rframe )
{
  int ret ;
  {
  ret = 1;
  ret = validate_recv_frame(padapter, rframe);
  if (ret != 1) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
      printk("\016recv_func: validate_recv_frame fail! drop pkt\n");
    } else {
    }
    rtw_free_recvframe23a(rframe);
    goto exit;
  } else {
  }
  exit: ;
  return (ret);
}
}
static int recv_func_posthandle(struct rtw_adapter *padapter , struct recv_frame *prframe )
{
  int ret ;
  struct recv_frame *orig_prframe ;
  struct recv_priv *precvpriv ;
  {
  ret = 1;
  orig_prframe = prframe;
  precvpriv = & padapter->recvpriv;
  prframe = decryptor(padapter, prframe);
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016decryptor: drop pkt\n");
    } else {
    }
    ret = 0;
    goto _recv_data_drop;
  } else {
  }
  prframe = recvframe_chk_defrag23a(padapter, prframe);
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016recvframe_chk_defrag23a: drop pkt\n");
    } else {
    }
    goto _recv_data_drop;
  } else {
  }
  if ((unsigned int )prframe->attrib.iv_len != 0U) {
    skb_pull(prframe->pkt, (unsigned int )prframe->attrib.iv_len);
  } else {
  }
  if ((unsigned int )prframe->attrib.icv_len != 0U) {
    skb_trim(prframe->pkt, (prframe->pkt)->len - (unsigned int )prframe->attrib.icv_len);
  } else {
  }
  prframe = portctrl(padapter, prframe);
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016portctrl: drop pkt\n");
    } else {
    }
    ret = 0;
    goto _recv_data_drop;
  } else {
  }
  count_rx_stats(padapter, prframe, (struct sta_info *)0);
  ret = process_recv_indicatepkts(padapter, prframe);
  if (ret != 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016recv_func: process_recv_indicatepkts fail!\n");
    } else {
    }
    rtw_free_recvframe23a(orig_prframe);
    goto _recv_data_drop;
  } else {
  }
  return (ret);
  _recv_data_drop:
  precvpriv->rx_drop = precvpriv->rx_drop + 1ULL;
  return (ret);
}
}
int rtw_recv_entry23a(struct recv_frame *rframe )
{
  int ret ;
  int r ;
  struct rtw_adapter *padapter ;
  struct rx_pkt_attrib *prxattrib ;
  struct recv_priv *recvpriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *mlmepriv ;
  struct recv_frame *pending_frame ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  padapter = rframe->adapter;
  prxattrib = & rframe->attrib;
  recvpriv = & padapter->recvpriv;
  psecuritypriv = & padapter->securitypriv;
  mlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(mlmepriv, 8);
  if ((int )tmp && (unsigned int )*((unsigned char *)psecuritypriv + 836UL) != 0U) {
    goto ldv_52238;
    ldv_52237:
    r = recv_func_posthandle(padapter, pending_frame);
    if (r == 1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s: dequeue uc_swdec_pending_queue\n", "rtw_recv_entry23a");
      } else {
      }
    } else {
    }
    ldv_52238:
    pending_frame = rtw_alloc_recvframe23a(& padapter->recvpriv.uc_swdec_pending_queue);
    if ((unsigned long )pending_frame != (unsigned long )((struct recv_frame *)0)) {
      goto ldv_52237;
    } else {
    }
  } else {
  }
  ret = recv_func_prehandle(padapter, rframe);
  if (ret == 1) {
    tmp___0 = check_fwstate(mlmepriv, 8);
    if ((int )tmp___0) {
      tmp___1 = is_multicast_ether_addr((u8 const *)(& prxattrib->ra));
      if (tmp___1) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      if (tmp___2) {
        if (prxattrib->encrypt != 0U) {
          if ((unsigned int )prxattrib->bdecrypted == 0U) {
            if (psecuritypriv->dot11PrivacyAlgrthm != 1027073U && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
              if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
                rtw_enqueue_recvframe23a(rframe, & padapter->recvpriv.uc_swdec_pending_queue);
                if (GlobalDebugLevel23A > 3U) {
                  printk("\016RTL8723AU: %s: no key, enqueue uc_swdec_pending_queue\n",
                         "rtw_recv_entry23a");
                } else {
                }
                goto exit;
              } else {
              }
            } else {
            }
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
    ret = recv_func_posthandle(padapter, rframe);
    recvpriv->rx_pkts = recvpriv->rx_pkts + 1ULL;
  } else {
  }
  exit: ;
  return (ret);
}
}
void rtw_signal_stat_timer_hdl23a(unsigned long data )
{
  struct rtw_adapter *adapter ;
  struct recv_priv *recvpriv ;
  u32 tmp_s ;
  u32 tmp_q ;
  u8 avg_signal_strength ;
  u8 avg_signal_qual ;
  u32 num_signal_strength ;
  u32 num_signal_qual ;
  u8 _alpha ;
  s32 tmp ;
  s32 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  {
  adapter = (struct rtw_adapter *)data;
  recvpriv = & adapter->recvpriv;
  avg_signal_strength = 0U;
  avg_signal_qual = 0U;
  num_signal_strength = 0U;
  num_signal_qual = 0U;
  _alpha = 3U;
  if ((unsigned int )adapter->recvpriv.is_signal_dbg != 0U) {
    adapter->recvpriv.signal_strength = adapter->recvpriv.signal_strength_dbg;
    tmp = translate_percentage_to_dbm((u32 )adapter->recvpriv.signal_strength_dbg);
    adapter->recvpriv.rssi = (signed char )tmp;
  } else {
    if ((unsigned int )recvpriv->signal_strength_data.update_req == 0U) {
      avg_signal_strength = recvpriv->signal_strength_data.avg_val;
      num_signal_strength = recvpriv->signal_strength_data.total_num;
      recvpriv->signal_strength_data.update_req = 1U;
    } else {
    }
    if ((unsigned int )recvpriv->signal_qual_data.update_req == 0U) {
      avg_signal_qual = recvpriv->signal_qual_data.avg_val;
      num_signal_qual = recvpriv->signal_qual_data.total_num;
      recvpriv->signal_qual_data.update_req = 1U;
    } else {
    }
    tmp___1 = check_fwstate(& adapter->mlmepriv, 2048);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      tmp_s = (u32 )((int )avg_signal_strength + ((int )_alpha + -1) * (int )recvpriv->signal_strength);
      if (tmp_s % (u32 )_alpha != 0U) {
        tmp_s = tmp_s / (u32 )_alpha + 1U;
      } else {
        tmp_s = tmp_s / (u32 )_alpha;
      }
      if (tmp_s > 100U) {
        tmp_s = 100U;
      } else {
      }
      tmp_q = (u32 )((int )avg_signal_qual + ((int )_alpha + -1) * (int )recvpriv->signal_qual);
      if (tmp_q % (u32 )_alpha != 0U) {
        tmp_q = tmp_q / (u32 )_alpha + 1U;
      } else {
        tmp_q = tmp_q / (u32 )_alpha;
      }
      if (tmp_q > 100U) {
        tmp_q = 100U;
      } else {
      }
      recvpriv->signal_strength = (u8 )tmp_s;
      tmp___0 = translate_percentage_to_dbm(tmp_s);
      recvpriv->rssi = (signed char )tmp___0;
      recvpriv->signal_qual = (u8 )tmp_q;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s signal_strength:%3u, rssi:%3d, signal_qual:%3u, num_signal_strength:%u, num_signal_qual:%u\n",
               "rtw_signal_stat_timer_hdl23a", (int )recvpriv->signal_strength, (int )recvpriv->rssi,
               (int )recvpriv->signal_qual, num_signal_strength, num_signal_qual);
      } else {
      }
    } else {
    }
  }
  tmp___3 = msecs_to_jiffies(recvpriv->signal_stat_sampling_interval);
  ldv_mod_timer_665(& recvpriv->signal_stat_timer, tmp___3 + (unsigned long )jiffies);
  return;
}
}
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_10_0 == (unsigned long )timer) {
    if (ldv_timer_10_0 == 2 || pending_flag != 0) {
      ldv_timer_list_10_0 = timer;
      ldv_timer_list_10_0->data = data;
      ldv_timer_10_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_10_1 == (unsigned long )timer) {
    if (ldv_timer_10_1 == 2 || pending_flag != 0) {
      ldv_timer_list_10_1 = timer;
      ldv_timer_list_10_1->data = data;
      ldv_timer_10_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_10_2 == (unsigned long )timer) {
    if (ldv_timer_10_2 == 2 || pending_flag != 0) {
      ldv_timer_list_10_2 = timer;
      ldv_timer_list_10_2->data = data;
      ldv_timer_10_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_10_3 == (unsigned long )timer) {
    if (ldv_timer_10_3 == 2 || pending_flag != 0) {
      ldv_timer_list_10_3 = timer;
      ldv_timer_list_10_3->data = data;
      ldv_timer_10_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_10(timer, data);
  return;
}
}
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& rtw_signal_stat_timer_hdl23a)) {
    activate_suitable_timer_10(timer, data);
  } else {
  }
  return (0);
}
}
void ldv_timer_10(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  rtw_signal_stat_timer_hdl23a(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void disable_suitable_timer_10(struct timer_list *timer )
{
  {
  if (ldv_timer_10_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_0) {
    ldv_timer_10_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_10_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_1) {
    ldv_timer_10_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_10_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_2) {
    ldv_timer_10_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_10_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_3) {
    ldv_timer_10_3 = 0;
    return;
  } else {
  }
  return;
}
}
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_10_0 == 0 || ldv_timer_10_0 == 2) {
    ldv_timer_list_10_0 = timer;
    ldv_timer_list_10_0->data = data;
    ldv_timer_10_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_10_1 == 0 || ldv_timer_10_1 == 2) {
    ldv_timer_list_10_1 = timer;
    ldv_timer_list_10_1->data = data;
    ldv_timer_10_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_10_2 == 0 || ldv_timer_10_2 == 2) {
    ldv_timer_list_10_2 = timer;
    ldv_timer_list_10_2->data = data;
    ldv_timer_10_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_10_3 == 0 || ldv_timer_10_3 == 2) {
    ldv_timer_list_10_3 = timer;
    ldv_timer_list_10_3->data = data;
    ldv_timer_10_3 = 1;
    return;
  } else {
  }
  return;
}
}
void timer_init_10(void)
{
  {
  ldv_timer_10_0 = 0;
  ldv_timer_10_1 = 0;
  ldv_timer_10_2 = 0;
  ldv_timer_10_3 = 0;
  return;
}
}
void choose_timer_10(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_10_0 == 1) {
    ldv_timer_10_0 = 2;
    ldv_timer_10(ldv_timer_10_0, ldv_timer_list_10_0);
  } else {
  }
  goto ldv_52283;
  case 1: ;
  if (ldv_timer_10_1 == 1) {
    ldv_timer_10_1 = 2;
    ldv_timer_10(ldv_timer_10_1, ldv_timer_list_10_1);
  } else {
  }
  goto ldv_52283;
  case 2: ;
  if (ldv_timer_10_2 == 1) {
    ldv_timer_10_2 = 2;
    ldv_timer_10(ldv_timer_10_2, ldv_timer_list_10_2);
  } else {
  }
  goto ldv_52283;
  case 3: ;
  if (ldv_timer_10_3 == 1) {
    ldv_timer_10_3 = 2;
    ldv_timer_10(ldv_timer_10_3, ldv_timer_list_10_3);
  } else {
  }
  goto ldv_52283;
  default:
  ldv_stop();
  }
  ldv_52283: ;
  return;
}
}
__inline static void spin_lock(spinlock_t *lock )
{
  {
  ldv_spin_lock();
  ldv_spin_lock_629(lock);
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock )
{
  {
  ldv_spin_unlock();
  ldv_spin_unlock_633(lock);
  return;
}
}
void *ldv_kmem_cache_alloc_644(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_650(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_652(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_654(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_655(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_656(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_657(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_658(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_659(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_660(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_mod_timer_661(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_662(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_663(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_664(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_665(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
void *ldv_kmem_cache_alloc_696(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_704(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_712(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_706(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_702(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_710(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_711(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_707(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_708(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_709(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
void rtw_secmicsetkey23a(struct mic_data *pmicdata , u8 *key ) ;
void rtw_secmicappend23abyte23a(struct mic_data *pmicdata , u8 b ) ;
void rtw_secmicappend23a(struct mic_data *pmicdata , u8 *src , u32 nbytes ) ;
void rtw_secgetmic23a(struct mic_data *pmicdata , u8 *dst ) ;
int rtw_aes_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
int rtw_tkip_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
void rtw_use_tkipkey_handler23a(void *FunctionContext ) ;
static void arcfour_init(struct arc4context *parc4ctx , u8 *key , u32 key_len )
{
  u32 t ;
  u32 u ;
  u32 keyindex ;
  u32 stateindex ;
  u8 *state ;
  u32 counter ;
  {
  state = (u8 *)(& parc4ctx->state);
  parc4ctx->x = 0U;
  parc4ctx->y = 0U;
  counter = 0U;
  goto ldv_51423;
  ldv_51422:
  *(state + (unsigned long )counter) = (unsigned char )counter;
  counter = counter + 1U;
  ldv_51423: ;
  if (counter <= 255U) {
    goto ldv_51422;
  } else {
  }
  keyindex = 0U;
  stateindex = 0U;
  counter = 0U;
  goto ldv_51426;
  ldv_51425:
  t = (u32 )*(state + (unsigned long )counter);
  stateindex = (((u32 )*(key + (unsigned long )keyindex) + stateindex) + t) & 255U;
  u = (u32 )*(state + (unsigned long )stateindex);
  *(state + (unsigned long )stateindex) = (unsigned char )t;
  *(state + (unsigned long )counter) = (unsigned char )u;
  keyindex = keyindex + 1U;
  if (keyindex >= key_len) {
    keyindex = 0U;
  } else {
  }
  counter = counter + 1U;
  ldv_51426: ;
  if (counter <= 255U) {
    goto ldv_51425;
  } else {
  }
  return;
}
}
static u32 arcfour_byte(struct arc4context *parc4ctx )
{
  u32 x ;
  u32 y ;
  u32 sx ;
  u32 sy ;
  u8 *state ;
  {
  state = (u8 *)(& parc4ctx->state);
  x = (parc4ctx->x + 1U) & 255U;
  sx = (u32 )*(state + (unsigned long )x);
  y = (parc4ctx->y + sx) & 255U;
  sy = (u32 )*(state + (unsigned long )y);
  parc4ctx->x = x;
  parc4ctx->y = y;
  *(state + (unsigned long )y) = (unsigned char )sx;
  *(state + (unsigned long )x) = (unsigned char )sy;
  return ((u32 )*(state + ((unsigned long )(sx + sy) & 255UL)));
}
}
static void arcfour_encrypt(struct arc4context *parc4ctx , u8 *dest , u8 *src , u32 len )
{
  u32 i ;
  u32 tmp ;
  {
  i = 0U;
  goto ldv_51444;
  ldv_51443:
  tmp = arcfour_byte(parc4ctx);
  *(dest + (unsigned long )i) = (u8 )((int )*(src + (unsigned long )i) ^ (int )((unsigned char )tmp));
  i = i + 1U;
  ldv_51444: ;
  if (i < len) {
    goto ldv_51443;
  } else {
  }
  return;
}
}
static int bcrc32initialized = 0;
static u32 crc32_table[256U] ;
static u8 crc32_reverseBit(u8 data )
{
  u8 retval ;
  {
  retval = (u8 )((((((((int )((signed char )((int )data << 7)) | ((int )((signed char )((int )data << 5)) & 64)) | ((int )((signed char )((int )data << 3)) & 32)) | ((int )((signed char )((int )data << 1)) & 16)) | ((int )((signed char )((int )data >> 1)) & 8)) | ((int )((signed char )((int )data >> 3)) & 4)) | ((int )((signed char )((int )data >> 5)) & 2)) | (int )((signed char )((int )data >> 7)));
  return (retval);
}
}
static void crc32_init(void)
{
  int i ;
  int j ;
  u32 c ;
  u8 *p ;
  u8 *p1 ;
  u8 k ;
  {
  if (bcrc32initialized == 1) {
    return;
  } else {
    p = (u8 *)(& c);
    c = 305397760U;
    i = 0;
    goto ldv_51465;
    ldv_51464:
    k = crc32_reverseBit((int )((unsigned char )i));
    c = (unsigned int )k << 24;
    j = 8;
    goto ldv_51462;
    ldv_51461:
    c = (int )c < 0 ? (c << 1) ^ 79764919U : c << 1;
    j = j - 1;
    ldv_51462: ;
    if (j > 0) {
      goto ldv_51461;
    } else {
    }
    p1 = (u8 *)(& crc32_table) + (unsigned long )i;
    *p1 = crc32_reverseBit((int )*(p + 3UL));
    *(p1 + 1UL) = crc32_reverseBit((int )*(p + 2UL));
    *(p1 + 2UL) = crc32_reverseBit((int )*(p + 1UL));
    *(p1 + 3UL) = crc32_reverseBit((int )*p);
    i = i + 1;
    ldv_51465: ;
    if (i <= 255) {
      goto ldv_51464;
    } else {
    }
    bcrc32initialized = 1;
  }
  return;
}
}
static u32 getcrc32(u8 *buf , int len )
{
  u8 *p ;
  u32 crc ;
  {
  if (bcrc32initialized == 0) {
    crc32_init();
  } else {
  }
  crc = 4294967295U;
  p = buf;
  goto ldv_51474;
  ldv_51473:
  crc = crc32_table[((u32 )*p ^ crc) & 255U] ^ (crc >> 8);
  p = p + 1;
  len = len - 1;
  ldv_51474: ;
  if (len > 0) {
    goto ldv_51473;
  } else {
  }
  return (~ crc);
}
}
void rtw_wep_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  unsigned char crc[4U] ;
  struct arc4context mycontext ;
  int curfragnum ;
  int length ;
  int index ;
  u32 keylength ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 wepkey[16U] ;
  u8 hw_hdr_offset ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  hw_hdr_offset = 0U;
  pattrib = & pxmitframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  pxmitpriv = & padapter->xmitpriv;
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
    return;
  } else {
  }
  hw_hdr_offset = 40U;
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
  if (pattrib->encrypt != 1027073U && pattrib->encrypt != 1027077U) {
    return;
  } else {
  }
  index = (int )psecuritypriv->dot11PrivacyKeyIndex;
  keylength = (u32 )psecuritypriv->wep_key[index].keylen;
  curfragnum = 0;
  goto ldv_51501;
  ldv_51500:
  iv = pframe + (unsigned long )pattrib->hdrlen;
  __len = 3UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& wepkey), (void const *)iv, __len);
  } else {
    __ret = memcpy((void *)(& wepkey), (void const *)iv, __len);
  }
  __len___0 = (size_t )keylength;
  __ret___0 = memcpy((void *)(& wepkey) + 3U, (void const *)(& psecuritypriv->wep_key[index].key),
                               __len___0);
  payload = pframe + ((unsigned long )pattrib->iv_len + (unsigned long )pattrib->hdrlen);
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
    *((u32 *)(& crc)) = getcrc32(payload, length);
    arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
  } else {
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
    *((u32 *)(& crc)) = getcrc32(payload, length);
    arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
  curfragnum = curfragnum + 1;
  ldv_51501: ;
  if ((int )pattrib->nr_frags > curfragnum) {
    goto ldv_51500;
  } else {
  }
  return;
}
}
void rtw_wep_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe )
{
  u8 crc[4U] ;
  struct arc4context mycontext ;
  int length ;
  u32 keylength ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 wepkey[16U] ;
  u8 keyindex ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  prxattrib = & precvframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  skb = precvframe->pkt;
  pframe = skb->data;
  if (prxattrib->encrypt != 1027073U && prxattrib->encrypt != 1027077U) {
    return;
  } else {
  }
  iv = pframe + (unsigned long )prxattrib->hdrlen;
  keyindex = prxattrib->key_index;
  keylength = (u32 )psecuritypriv->wep_key[(int )keyindex].keylen;
  __len = 3UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& wepkey), (void const *)iv, __len);
  } else {
    __ret = memcpy((void *)(& wepkey), (void const *)iv, __len);
  }
  __len___0 = (size_t )keylength;
  __ret___0 = memcpy((void *)(& wepkey) + 3U, (void const *)(& psecuritypriv->wep_key[(int )keyindex].key),
                               __len___0);
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
  payload = pframe + ((unsigned long )prxattrib->iv_len + (unsigned long )prxattrib->hdrlen);
  arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
  arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
  *((u32 *)(& crc)) = getcrc32(payload, length + -4);
  if ((((int )crc[3] != (int )*(payload + ((unsigned long )length + 0xffffffffffffffffUL)) || (int )crc[2] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffeUL))) || (int )crc[1] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffdUL))) || (int )crc[0] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffcUL))) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
      printk("\016rtw_wep_decrypt23a:icv error crc[3](%x)!= payload[length-1](%x) || crc[2](%x)!= payload[length-2](%x) || crc[1](%x)!= payload[length-3](%x) || crc[0](%x)!= payload[length-4](%x)\n",
             (int )crc[3], (int )*(payload + ((unsigned long )length + 0xffffffffffffffffUL)),
             (int )crc[2], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffeUL)),
             (int )crc[1], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffdUL)),
             (int )crc[0], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffcUL)));
    } else {
    }
  } else {
  }
  return;
}
}
static u32 secmicgetuint32(u8 *p )
{
  s32 i ;
  u32 res ;
  u8 *tmp ;
  {
  res = 0U;
  i = 0;
  goto ldv_51531;
  ldv_51530:
  tmp = p;
  p = p + 1;
  res = ((unsigned int )*tmp << i * 8) | res;
  i = i + 1;
  ldv_51531: ;
  if (i <= 3) {
    goto ldv_51530;
  } else {
  }
  return (res);
}
}
static void secmicputuint32(u8 *p , u32 val )
{
  long i ;
  u8 *tmp ;
  {
  i = 0L;
  goto ldv_51539;
  ldv_51538:
  tmp = p;
  p = p + 1;
  *tmp = (unsigned char )val;
  val = val >> 8;
  i = i + 1L;
  ldv_51539: ;
  if (i <= 3L) {
    goto ldv_51538;
  } else {
  }
  return;
}
}
static void secmicclear(struct mic_data *pmicdata )
{
  {
  pmicdata->L = pmicdata->K0;
  pmicdata->R = pmicdata->K1;
  pmicdata->nBytesInM = 0U;
  pmicdata->M = 0U;
  return;
}
}
void rtw_secmicsetkey23a(struct mic_data *pmicdata , u8 *key )
{
  {
  pmicdata->K0 = secmicgetuint32(key);
  pmicdata->K1 = secmicgetuint32(key + 4UL);
  secmicclear(pmicdata);
  return;
}
}
void rtw_secmicappend23abyte23a(struct mic_data *pmicdata , u8 b )
{
  {
  pmicdata->M = pmicdata->M | (u32 )((unsigned long )b << (int )(pmicdata->nBytesInM * 8U));
  pmicdata->nBytesInM = pmicdata->nBytesInM + 1U;
  if (pmicdata->nBytesInM > 3U) {
    pmicdata->L = pmicdata->L ^ pmicdata->M;
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 15) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 15UL)));
    pmicdata->L = pmicdata->L + pmicdata->R;
    pmicdata->R = pmicdata->R ^ (((pmicdata->L & 4278255360U) >> 8) | ((pmicdata->L & 16711935U) << 8));
    pmicdata->L = pmicdata->L + pmicdata->R;
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 29) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 29UL)));
    pmicdata->L = pmicdata->L + pmicdata->R;
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 2) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 2UL)));
    pmicdata->L = pmicdata->L + pmicdata->R;
    pmicdata->M = 0U;
    pmicdata->nBytesInM = 0U;
  } else {
  }
  return;
}
}
void rtw_secmicappend23a(struct mic_data *pmicdata , u8 *src , u32 nbytes )
{
  u8 *tmp ;
  {
  goto ldv_51558;
  ldv_51557:
  tmp = src;
  src = src + 1;
  rtw_secmicappend23abyte23a(pmicdata, (int )*tmp);
  nbytes = nbytes - 1U;
  ldv_51558: ;
  if (nbytes != 0U) {
    goto ldv_51557;
  } else {
  }
  return;
}
}
void rtw_secgetmic23a(struct mic_data *pmicdata , u8 *dst )
{
  {
  rtw_secmicappend23abyte23a(pmicdata, 90);
  rtw_secmicappend23abyte23a(pmicdata, 0);
  rtw_secmicappend23abyte23a(pmicdata, 0);
  rtw_secmicappend23abyte23a(pmicdata, 0);
  rtw_secmicappend23abyte23a(pmicdata, 0);
  goto ldv_51565;
  ldv_51564:
  rtw_secmicappend23abyte23a(pmicdata, 0);
  ldv_51565: ;
  if (pmicdata->nBytesInM != 0U) {
    goto ldv_51564;
  } else {
  }
  secmicputuint32(dst, pmicdata->L);
  secmicputuint32(dst + 4UL, pmicdata->R);
  secmicclear(pmicdata);
  return;
}
}
void rtw_seccalctkipmic23a(u8 *key , u8 *header , u8 *data , u32 data_len , u8 *mic_code ,
                           u8 pri )
{
  struct mic_data micdata ;
  u8 priority[4U] ;
  {
  priority[0] = 0U;
  priority[1] = 0U;
  priority[2] = 0U;
  priority[3] = 0U;
  rtw_secmicsetkey23a(& micdata, key);
  priority[0] = pri;
  if ((int )*(header + 1UL) & 1) {
    rtw_secmicappend23a(& micdata, header + 16UL, 6U);
    if (((int )*(header + 1UL) & 2) != 0) {
      rtw_secmicappend23a(& micdata, header + 24UL, 6U);
    } else {
      rtw_secmicappend23a(& micdata, header + 10UL, 6U);
    }
  } else {
    rtw_secmicappend23a(& micdata, header + 4UL, 6U);
    if (((int )*(header + 1UL) & 2) != 0) {
      rtw_secmicappend23a(& micdata, header + 16UL, 6U);
    } else {
      rtw_secmicappend23a(& micdata, header + 10UL, 6U);
    }
  }
  rtw_secmicappend23a(& micdata, (u8 *)(& priority), 4U);
  rtw_secmicappend23a(& micdata, data, data_len);
  rtw_secgetmic23a(& micdata, mic_code);
  return;
}
}
static unsigned short const Sbox1[2U][256U] = { { 50853U, 63620U, 61081U, 63117U,
            65293U, 54973U, 57009U, 37204U,
            24656U, 515U, 52905U, 22141U,
            59161U, 46434U, 19942U, 60570U,
            36677U, 8093U, 35136U, 64135U,
            61205U, 45803U, 36553U, 64267U,
            16876U, 45927U, 24573U, 17898U,
            9151U, 21495U, 58518U, 39771U,
            30146U, 57628U, 15790U, 19562U,
            27738U, 32321U, 62722U, 33615U,
            26716U, 20980U, 53556U, 63752U,
            58003U, 43891U, 25171U, 10815U,
            2060U, 38226U, 18021U, 40286U,
            12328U, 14241U, 2575U, 12213U,
            3593U, 9270U, 7067U, 57149U,
            52518U, 20073U, 32717U, 60063U,
            4635U, 7582U, 22644U, 13358U,
            13869U, 56498U, 46318U, 23547U,
            42230U, 30285U, 46945U, 32206U,
            21115U, 56638U, 24177U, 5015U,
            42741U, 47464U, 0U, 49452U,
            16480U, 58143U, 31176U, 46829U,
            54462U, 36166U, 26585U, 29259U,
            38110U, 39124U, 45288U, 34122U,
            47979U, 50474U, 20453U, 60694U,
            34501U, 39639U, 26197U, 4500U,
            35535U, 59664U, 1030U, 65153U,
            41200U, 30788U, 9658U, 19427U,
            41715U, 24062U, 32960U, 1418U,
            16301U, 8636U, 28744U, 61700U,
            25567U, 30657U, 44917U, 16995U,
            8240U, 58650U, 64782U, 49005U,
            33100U, 6164U, 9781U, 49967U,
            48865U, 13730U, 35020U, 11833U,
            37719U, 22002U, 64642U, 31303U,
            51372U, 47847U, 12843U, 59029U,
            49312U, 6552U, 40657U, 41855U,
            17510U, 21630U, 15275U, 2947U,
            36042U, 50985U, 27603U, 10300U,
            42873U, 48354U, 5661U, 44406U,
            56123U, 25686U, 29774U, 5150U,
            37595U, 3082U, 18540U, 47332U,
            40797U, 48494U, 17391U, 50342U,
            14760U, 12708U, 54071U, 62091U,
            54578U, 35651U, 28249U, 55991U,
            396U, 45412U, 40146U, 18912U,
            55476U, 44282U, 62215U, 53029U,
            51887U, 62606U, 18409U, 4120U,
            28629U, 61576U, 19055U, 23666U,
            14372U, 22513U, 29639U, 38737U,
            52003U, 41340U, 59548U, 15905U,
            38621U, 25052U, 3462U, 3973U,
            57488U, 31810U, 29124U, 52394U,
            37080U, 1541U, 63233U, 7186U,
            49827U, 27231U, 44793U, 27088U,
            6033U, 39256U, 14887U, 10169U,
            55608U, 60179U, 11187U, 8755U,
            53947U, 43376U, 1929U, 13223U,
            11702U, 15394U, 5522U, 51488U,
            34633U, 43775U, 20600U, 42362U,
            911U, 23032U, 2432U, 6679U,
            26074U, 55089U, 33990U, 53432U,
            33475U, 10672U, 23159U, 7697U,
            31691U, 43260U, 28118U, 11322U},
   { 42438U, 34040U, 39406U, 36342U,
            3583U, 48598U, 45534U, 21649U,
            20576U, 770U, 43470U, 32086U,
            6631U, 25269U, 58957U, 39660U,
            17807U, 40223U, 16521U, 34810U,
            5615U, 60338U, 51598U, 3067U,
            60481U, 26547U, 64863U, 59973U,
            48931U, 63315U, 38628U, 23451U,
            49781U, 7393U, 44605U, 27212U,
            23148U, 16766U, 757U, 20355U,
            23656U, 62545U, 13521U, 2297U,
            37858U, 29611U, 21346U, 16170U,
            3080U, 21141U, 25926U, 24221U,
            10288U, 41271U, 3850U, 46383U,
            2318U, 13860U, 39707U, 15839U,
            9933U, 26958U, 52607U, 40938U,
            6930U, 40477U, 29784U, 11828U,
            11574U, 45788U, 61108U, 64347U,
            63140U, 19830U, 25015U, 52861U,
            31570U, 16093U, 29022U, 38675U,
            62886U, 26809U, 0U, 11457U,
            24640U, 8163U, 51321U, 60854U,
            48852U, 18061U, 55655U, 19314U,
            56980U, 54424U, 59568U, 19077U,
            27579U, 10949U, 58703U, 5869U,
            50566U, 55194U, 21862U, 37905U,
            53130U, 4329U, 1540U, 33278U,
            61600U, 17528U, 47653U, 58187U,
            62370U, 65117U, 49280U, 35333U,
            44351U, 48161U, 18544U, 1265U,
            57187U, 49527U, 30127U, 25410U,
            12320U, 6885U, 3837U, 28095U,
            19585U, 5144U, 13606U, 12227U,
            57790U, 41525U, 52360U, 14638U,
            22419U, 62037U, 33532U, 18298U,
            44232U, 59322U, 11058U, 38374U,
            41152U, 38937U, 53662U, 32675U,
            26180U, 32340U, 43835U, 33547U,
            51852U, 10695U, 54123U, 15400U,
            31143U, 58044U, 7446U, 30381U,
            15323U, 22116U, 20084U, 7700U,
            56210U, 2572U, 27720U, 58552U,
            23967U, 28349U, 61251U, 42692U,
            43065U, 42033U, 14291U, 35826U,
            13013U, 17291U, 22894U, 47066U,
            35841U, 25777U, 53916U, 57417U,
            46296U, 64172U, 2035U, 9679U,
            45002U, 36596U, 59719U, 6160U,
            54639U, 35056U, 28490U, 29276U,
            9272U, 61783U, 51059U, 20887U,
            9163U, 31905U, 40168U, 8510U,
            56726U, 56417U, 34317U, 34063U,
            37088U, 17020U, 50289U, 43724U,
            55440U, 1286U, 503U, 4636U,
            41922U, 24426U, 63918U, 53353U,
            37143U, 22681U, 10042U, 47399U,
            14553U, 5099U, 45867U, 13090U,
            48082U, 28841U, 35079U, 42803U,
            46637U, 8764U, 37397U, 8393U,
            18823U, 65450U, 30800U, 31397U,
            36611U, 63577U, 32777U, 5914U,
            55909U, 12759U, 50820U, 47312U,
            50050U, 45097U, 30554U, 4382U,
            52091U, 64680U, 54893U, 14892U}};
static void phase1(u16 *p1k , u8 const *tk , u8 const *ta , u32 iv32 )
{
  int i ;
  {
  *p1k = (unsigned short )iv32;
  *(p1k + 1UL) = (unsigned short )(iv32 >> 16);
  *(p1k + 2UL) = (u16 )((int )((short )*ta) ^ (int )((short )((int )*(ta + 1UL) << 8)));
  *(p1k + 3UL) = (u16 )((int )((short )*(ta + 2UL)) ^ (int )((short )((int )*(ta + 3UL) << 8)));
  *(p1k + 4UL) = (u16 )((int )((short )*(ta + 4UL)) ^ (int )((short )((int )*(ta + 5UL) << 8)));
  i = 0;
  goto ldv_51586;
  ldv_51585:
  *p1k = (int )*p1k + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 4UL)) ^ ((int )((signed char )*(tk + (unsigned long )((i & 1) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 4UL) ^ ((int )*(tk + (unsigned long )((i & 1) * 2)) ^ ((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 1UL) = (int )*(p1k + 1UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*p1k) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 2) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 2) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*p1k ^ ((int )*(tk + (unsigned long )(((i & 1) + 2) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 2) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 2UL) = (int )*(p1k + 2UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 1UL)) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 4) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 4) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 1UL) ^ ((int )*(tk + (unsigned long )(((i & 1) + 4) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 4) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 3UL) = (int )*(p1k + 3UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 2UL)) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 6) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 6) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 2UL) ^ ((int )*(tk + (unsigned long )(((i & 1) + 6) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 6) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 4UL) = (int )*(p1k + 4UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 3UL)) ^ ((int )((signed char )*(tk + (unsigned long )((i & 1) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 3UL) ^ ((int )*(tk + (unsigned long )((i & 1) * 2)) ^ ((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8))) >> 8))])));
  *(p1k + 4UL) = (int )*(p1k + 4UL) + (int )((u16 )i);
  i = i + 1;
  ldv_51586: ;
  if (i <= 7) {
    goto ldv_51585;
  } else {
  }
  return;
}
}
static void phase2(u8 *rc4key , u8 const *tk , u16 const *p1k , u16 iv16 )
{
  int i ;
  u16 PPK[6U] ;
  {
  i = 0;
  goto ldv_51597;
  ldv_51596:
  PPK[i] = *(p1k + (unsigned long )i);
  i = i + 1;
  ldv_51597: ;
  if (i <= 4) {
    goto ldv_51596;
  } else {
  }
  PPK[5] = (int )((u16 )*(p1k + 4UL)) + (int )iv16;
  PPK[0] = (int )PPK[0] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[5]) ^ ((int )((signed char )*tk) ^ (int )((signed char )((int )*(tk + 1UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[5] ^ ((int )*tk ^ ((int )*(tk + 1UL) << 8))) >> 8))])));
  PPK[1] = (int )PPK[1] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[0]) ^ ((int )((signed char )*(tk + 2UL)) ^ (int )((signed char )((int )*(tk + 3UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[0] ^ ((int )*(tk + 2UL) ^ ((int )*(tk + 3UL) << 8))) >> 8))])));
  PPK[2] = (int )PPK[2] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[1]) ^ ((int )((signed char )*(tk + 4UL)) ^ (int )((signed char )((int )*(tk + 5UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[1] ^ ((int )*(tk + 4UL) ^ ((int )*(tk + 5UL) << 8))) >> 8))])));
  PPK[3] = (int )PPK[3] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[2]) ^ ((int )((signed char )*(tk + 6UL)) ^ (int )((signed char )((int )*(tk + 7UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[2] ^ ((int )*(tk + 6UL) ^ ((int )*(tk + 7UL) << 8))) >> 8))])));
  PPK[4] = (int )PPK[4] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[3]) ^ ((int )((signed char )*(tk + 8UL)) ^ (int )((signed char )((int )*(tk + 9UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[3] ^ ((int )*(tk + 8UL) ^ ((int )*(tk + 9UL) << 8))) >> 8))])));
  PPK[5] = (int )PPK[5] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[4]) ^ ((int )((signed char )*(tk + 10UL)) ^ (int )((signed char )((int )*(tk + 11UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[4] ^ ((int )*(tk + 10UL) ^ ((int )*(tk + 11UL) << 8))) >> 8))])));
  PPK[0] = (int )PPK[0] + (int )((u16 )(((int )((short )(((int )PPK[5] ^ ((int )*(tk + 12UL) ^ ((int )*(tk + 13UL) << 8))) >> 1)) & 32767) ^ (int )((short )(((int )PPK[5] ^ ((int )*(tk + 12UL) ^ ((int )*(tk + 13UL) << 8))) << 15))));
  PPK[1] = (int )PPK[1] + (int )((u16 )(((int )((short )(((int )PPK[0] ^ ((int )*(tk + 14UL) ^ ((int )*(tk + 15UL) << 8))) >> 1)) & 32767) ^ (int )((short )(((int )PPK[0] ^ ((int )*(tk + 14UL) ^ ((int )*(tk + 15UL) << 8))) << 15))));
  PPK[2] = (int )PPK[2] + (int )((u16 )((int )((short )((int )PPK[1] >> 1)) ^ (int )((short )((int )PPK[1] << 15))));
  PPK[3] = (int )PPK[3] + (int )((u16 )((int )((short )((int )PPK[2] >> 1)) ^ (int )((short )((int )PPK[2] << 15))));
  PPK[4] = (int )PPK[4] + (int )((u16 )((int )((short )((int )PPK[3] >> 1)) ^ (int )((short )((int )PPK[3] << 15))));
  PPK[5] = (int )PPK[5] + (int )((u16 )((int )((short )((int )PPK[4] >> 1)) ^ (int )((short )((int )PPK[4] << 15))));
  *rc4key = (unsigned char )((int )iv16 >> 8);
  *(rc4key + 1UL) = ((unsigned int )((u8 )((int )iv16 >> 8)) & 95U) | 32U;
  *(rc4key + 2UL) = (unsigned char )iv16;
  *(rc4key + 3UL) = (unsigned char )(((int )PPK[5] ^ ((int )*tk ^ ((int )*(tk + 1UL) << 8))) >> 1);
  i = 0;
  goto ldv_51600;
  ldv_51599:
  *(rc4key + (unsigned long )((i + 2) * 2)) = (unsigned char )PPK[i];
  *(rc4key + (unsigned long )(i * 2 + 5)) = (unsigned char )((int )PPK[i] >> 8);
  i = i + 1;
  ldv_51600: ;
  if (i <= 5) {
    goto ldv_51599;
  } else {
  }
  return;
}
}
int rtw_tkip_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  u16 pnl ;
  u32 pnh ;
  u8 rc4key[16U] ;
  u8 ttkey[16U] ;
  u8 crc[4U] ;
  u8 hw_hdr_offset ;
  struct arc4context mycontext ;
  int curfragnum ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 *prwskey ;
  union pn48 dot11txpn ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  bool tmp ;
  {
  hw_hdr_offset = 0U;
  pattrib = & pxmitframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  pxmitpriv = & padapter->xmitpriv;
  res = 1;
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
    return (0);
  } else {
  }
  hw_hdr_offset = 40U;
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
  if (pattrib->encrypt == 1027074U) {
    if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
      stainfo = pattrib->psta;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s, call rtw_get_stainfo()\n", "rtw_tkip_encrypt23a");
      } else {
      }
      stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pattrib->ra));
    }
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
      if ((stainfo->state & 1U) == 0U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_tkip_encrypt23a",
                 stainfo->state);
        } else {
        }
        return (0);
      } else {
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
        printk("\016rtw_tkip_encrypt23a: stainfo!= NULL!!!\n");
      } else {
      }
      tmp = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
      if ((int )tmp) {
        prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey);
      } else {
        prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
      }
      prwskeylen = 16U;
      curfragnum = 0;
      goto ldv_51628;
      ldv_51627:
      iv = pframe + (unsigned long )pattrib->hdrlen;
      payload = pframe + ((unsigned long )pattrib->iv_len + (unsigned long )pattrib->hdrlen);
      dot11txpn._byte_.TSC0 = *(iv + 2UL);
      dot11txpn._byte_.TSC1 = *iv;
      dot11txpn._byte_.TSC2 = *(iv + 4UL);
      dot11txpn._byte_.TSC3 = *(iv + 5UL);
      dot11txpn._byte_.TSC4 = *(iv + 6UL);
      dot11txpn._byte_.TSC5 = *(iv + 7UL);
      pnl = (unsigned short )dot11txpn.val;
      pnh = (unsigned int )(dot11txpn.val >> 16);
      phase1((u16 *)(& ttkey), (u8 const *)prwskey, (u8 const *)(& pattrib->ta),
             pnh);
      phase2((u8 *)(& rc4key), (u8 const *)prwskey, (u16 const *)(& ttkey), (int )pnl);
      if (curfragnum + 1 == (int )pattrib->nr_frags) {
        length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 7);
          printk("\016pattrib->iv_len =%x, pattrib->icv_len =%x\n", (int )pattrib->iv_len,
                 (int )pattrib->icv_len);
        } else {
        }
        *((u32 *)(& crc)) = getcrc32(payload, length);
        arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
        arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
        arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                        4U);
      } else {
        length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
        *((u32 *)(& crc)) = getcrc32(payload, length);
        arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
        arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
        arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                        4U);
        pframe = pframe + (unsigned long )pxmitpriv->frag_len;
        pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
      }
      curfragnum = curfragnum + 1;
      ldv_51628: ;
      if ((int )pattrib->nr_frags > curfragnum) {
        goto ldv_51627;
      } else {
      }
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
        printk("\016rtw_tkip_encrypt23a: stainfo == NULL!!!\n");
      } else {
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_tkip_encrypt23a");
      } else {
      }
      res = 0;
    }
  } else {
  }
  return (res);
}
}
int rtw_tkip_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe )
{
  u16 pnl ;
  u32 pnh ;
  u8 rc4key[16U] ;
  u8 ttkey[16U] ;
  u8 crc[4U] ;
  struct arc4context mycontext ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 *prwskey ;
  union pn48 dot11txpn ;
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  int res ;
  bool tmp ;
  {
  prxattrib = & precvframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  skb = precvframe->pkt;
  res = 1;
  pframe = skb->data;
  if (prxattrib->encrypt == 1027074U) {
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& prxattrib->ta));
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
      tmp = is_multicast_ether_addr((u8 const *)(& prxattrib->ra));
      if ((int )tmp) {
        if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
          res = 0;
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: %s:rx bc/mc packets, but didn\'t install group key!!!!!!!!!!\n",
                   "rtw_tkip_decrypt23a");
          } else {
          }
          goto exit;
        } else {
        }
        prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[(int )prxattrib->key_index].skey);
        prwskeylen = 16U;
      } else {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
          printk("\016rtw_tkip_decrypt23a: stainfo!= NULL!!!\n");
        } else {
        }
        prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
        prwskeylen = 16U;
      }
      iv = pframe + (unsigned long )prxattrib->hdrlen;
      payload = pframe + ((unsigned long )prxattrib->iv_len + (unsigned long )prxattrib->hdrlen);
      length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
      dot11txpn._byte_.TSC0 = *(iv + 2UL);
      dot11txpn._byte_.TSC1 = *iv;
      dot11txpn._byte_.TSC2 = *(iv + 4UL);
      dot11txpn._byte_.TSC3 = *(iv + 5UL);
      dot11txpn._byte_.TSC4 = *(iv + 6UL);
      dot11txpn._byte_.TSC5 = *(iv + 7UL);
      pnl = (unsigned short )dot11txpn.val;
      pnh = (unsigned int )(dot11txpn.val >> 16);
      phase1((u16 *)(& ttkey), (u8 const *)prwskey, (u8 const *)(& prxattrib->ta),
             pnh);
      phase2((u8 *)(& rc4key), (u8 const *)prwskey, (u16 const *)(& ttkey), (int )pnl);
      arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
      arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
      *((u32 *)(& crc)) = getcrc32(payload, length + -4);
      if ((((int )crc[3] != (int )*(payload + ((unsigned long )length + 0xffffffffffffffffUL)) || (int )crc[2] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffeUL))) || (int )crc[1] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffdUL))) || (int )crc[0] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffcUL))) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
          printk("\016rtw_wep_decrypt23a:icv error crc[3](%x)!= payload[length-1](%x) || crc[2](%x)!= payload[length-2](%x) || crc[1](%x)!= payload[length-3](%x) || crc[0](%x)!= payload[length-4](%x)\n",
                 (int )crc[3], (int )*(payload + ((unsigned long )length + 0xffffffffffffffffUL)),
                 (int )crc[2], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffeUL)),
                 (int )crc[1], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffdUL)),
                 (int )crc[0], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffcUL)));
        } else {
        }
        res = 0;
      } else {
      }
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
        printk("\016rtw_tkip_decrypt23a: stainfo == NULL!!!\n");
      } else {
      }
      res = 0;
    }
  } else {
  }
  exit: ;
  return (res);
}
}
static u8 sbox_table[256U] =
  { 99U, 124U, 119U, 123U,
        242U, 107U, 111U, 197U,
        48U, 1U, 103U, 43U,
        254U, 215U, 171U, 118U,
        202U, 130U, 201U, 125U,
        250U, 89U, 71U, 240U,
        173U, 212U, 162U, 175U,
        156U, 164U, 114U, 192U,
        183U, 253U, 147U, 38U,
        54U, 63U, 247U, 204U,
        52U, 165U, 229U, 241U,
        113U, 216U, 49U, 21U,
        4U, 199U, 35U, 195U,
        24U, 150U, 5U, 154U,
        7U, 18U, 128U, 226U,
        235U, 39U, 178U, 117U,
        9U, 131U, 44U, 26U,
        27U, 110U, 90U, 160U,
        82U, 59U, 214U, 179U,
        41U, 227U, 47U, 132U,
        83U, 209U, 0U, 237U,
        32U, 252U, 177U, 91U,
        106U, 203U, 190U, 57U,
        74U, 76U, 88U, 207U,
        208U, 239U, 170U, 251U,
        67U, 77U, 51U, 133U,
        69U, 249U, 2U, 127U,
        80U, 60U, 159U, 168U,
        81U, 163U, 64U, 143U,
        146U, 157U, 56U, 245U,
        188U, 182U, 218U, 33U,
        16U, 255U, 243U, 210U,
        205U, 12U, 19U, 236U,
        95U, 151U, 68U, 23U,
        196U, 167U, 126U, 61U,
        100U, 93U, 25U, 115U,
        96U, 129U, 79U, 220U,
        34U, 42U, 144U, 136U,
        70U, 238U, 184U, 20U,
        222U, 94U, 11U, 219U,
        224U, 50U, 58U, 10U,
        73U, 6U, 36U, 92U,
        194U, 211U, 172U, 98U,
        145U, 149U, 228U, 121U,
        231U, 200U, 55U, 109U,
        141U, 213U, 78U, 169U,
        108U, 86U, 244U, 234U,
        101U, 122U, 174U, 8U,
        186U, 120U, 37U, 46U,
        28U, 166U, 180U, 198U,
        232U, 221U, 116U, 31U,
        75U, 189U, 139U, 138U,
        112U, 62U, 181U, 102U,
        72U, 3U, 246U, 14U,
        97U, 53U, 87U, 185U,
        134U, 193U, 29U, 158U,
        225U, 248U, 152U, 17U,
        105U, 217U, 142U, 148U,
        155U, 30U, 135U, 233U,
        206U, 85U, 40U, 223U,
        140U, 161U, 137U, 13U,
        191U, 230U, 66U, 104U,
        65U, 153U, 45U, 15U,
        176U, 84U, 187U, 22U};
static void construct_mic_header2(u8 *mic_header2 , u8 *mpdu , int a4_exists , int qc_exists ) ;
static void xor_128(u8 *a , u8 *b , u8 *out )
{
  int i ;
  {
  i = 0;
  goto ldv_51667;
  ldv_51666:
  *(out + (unsigned long )i) = (u8 )((int )*(a + (unsigned long )i) ^ (int )*(b + (unsigned long )i));
  i = i + 1;
  ldv_51667: ;
  if (i <= 15) {
    goto ldv_51666;
  } else {
  }
  return;
}
}
static void xor_32(u8 *a , u8 *b , u8 *out )
{
  int i ;
  {
  i = 0;
  goto ldv_51676;
  ldv_51675:
  *(out + (unsigned long )i) = (u8 )((int )*(a + (unsigned long )i) ^ (int )*(b + (unsigned long )i));
  i = i + 1;
  ldv_51676: ;
  if (i <= 3) {
    goto ldv_51675;
  } else {
  }
  return;
}
}
static u8 sbox(u8 a )
{
  {
  return (sbox_table[(int )a]);
}
}
static void next_key(u8 *key , int round )
{
  u8 rcon___0 ;
  u8 sbox_key[4U] ;
  u8 rcon_table[12U] ;
  {
  rcon_table[0] = 1U;
  rcon_table[1] = 2U;
  rcon_table[2] = 4U;
  rcon_table[3] = 8U;
  rcon_table[4] = 16U;
  rcon_table[5] = 32U;
  rcon_table[6] = 64U;
  rcon_table[7] = 128U;
  rcon_table[8] = 27U;
  rcon_table[9] = 54U;
  rcon_table[10] = 54U;
  rcon_table[11] = 54U;
  sbox_key[0] = sbox((int )*(key + 13UL));
  sbox_key[1] = sbox((int )*(key + 14UL));
  sbox_key[2] = sbox((int )*(key + 15UL));
  sbox_key[3] = sbox((int )*(key + 12UL));
  rcon___0 = rcon_table[round];
  xor_32(key, (u8 *)(& sbox_key), key);
  *key = (u8 )((int )*key ^ (int )rcon___0);
  xor_32(key + 4UL, key, key + 4UL);
  xor_32(key + 8UL, key + 4UL, key + 8UL);
  xor_32(key + 12UL, key + 8UL, key + 12UL);
  return;
}
}
static void byte_sub(u8 *in , u8 *out )
{
  int i ;
  {
  i = 0;
  goto ldv_51694;
  ldv_51693:
  *(out + (unsigned long )i) = sbox((int )*(in + (unsigned long )i));
  i = i + 1;
  ldv_51694: ;
  if (i <= 15) {
    goto ldv_51693;
  } else {
  }
  return;
}
}
static void shift_row(u8 *in , u8 *out )
{
  {
  *out = *in;
  *(out + 1UL) = *(in + 5UL);
  *(out + 2UL) = *(in + 10UL);
  *(out + 3UL) = *(in + 15UL);
  *(out + 4UL) = *(in + 4UL);
  *(out + 5UL) = *(in + 9UL);
  *(out + 6UL) = *(in + 14UL);
  *(out + 7UL) = *(in + 3UL);
  *(out + 8UL) = *(in + 8UL);
  *(out + 9UL) = *(in + 13UL);
  *(out + 10UL) = *(in + 2UL);
  *(out + 11UL) = *(in + 7UL);
  *(out + 12UL) = *(in + 12UL);
  *(out + 13UL) = *(in + 1UL);
  *(out + 14UL) = *(in + 6UL);
  *(out + 15UL) = *(in + 11UL);
  return;
}
}
static void mix_column(u8 *in , u8 *out )
{
  int i ;
  u8 add1b[4U] ;
  u8 add1bf7[4U] ;
  u8 rotl[4U] ;
  u8 swap_halfs[4U] ;
  u8 andf7[4U] ;
  u8 rotr___0[4U] ;
  u8 temp[4U] ;
  u8 tempb[4U] ;
  {
  i = 0;
  goto ldv_51714;
  ldv_51713: ;
  if ((int )((signed char )*(in + (unsigned long )i)) < 0) {
    add1b[i] = 27U;
  } else {
    add1b[i] = 0U;
  }
  i = i + 1;
  ldv_51714: ;
  if (i <= 3) {
    goto ldv_51713;
  } else {
  }
  swap_halfs[0] = *(in + 2UL);
  swap_halfs[1] = *(in + 3UL);
  swap_halfs[2] = *in;
  swap_halfs[3] = *(in + 1UL);
  rotl[0] = *(in + 3UL);
  rotl[1] = *in;
  rotl[2] = *(in + 1UL);
  rotl[3] = *(in + 2UL);
  andf7[0] = (unsigned int )*in & 127U;
  andf7[1] = (unsigned int )*(in + 1UL) & 127U;
  andf7[2] = (unsigned int )*(in + 2UL) & 127U;
  andf7[3] = (unsigned int )*(in + 3UL) & 127U;
  i = 3;
  goto ldv_51717;
  ldv_51716:
  andf7[i] = (int )andf7[i] << 1U;
  if ((int )((signed char )andf7[i + -1]) < 0) {
    andf7[i] = (u8 )((unsigned int )andf7[i] | 1U);
  } else {
  }
  i = i - 1;
  ldv_51717: ;
  if (i > 0) {
    goto ldv_51716;
  } else {
  }
  andf7[0] = (int )andf7[0] << 1U;
  andf7[0] = (unsigned int )andf7[0] & 254U;
  xor_32((u8 *)(& add1b), (u8 *)(& andf7), (u8 *)(& add1bf7));
  xor_32(in, (u8 *)(& add1bf7), (u8 *)(& rotr___0));
  temp[0] = rotr___0[0];
  rotr___0[0] = rotr___0[1];
  rotr___0[1] = rotr___0[2];
  rotr___0[2] = rotr___0[3];
  rotr___0[3] = temp[0];
  xor_32((u8 *)(& add1bf7), (u8 *)(& rotr___0), (u8 *)(& temp));
  xor_32((u8 *)(& swap_halfs), (u8 *)(& rotl), (u8 *)(& tempb));
  xor_32((u8 *)(& temp), (u8 *)(& tempb), out);
  return;
}
}
static void aes128k128d(u8 *key , u8 *data , u8 *ciphertext )
{
  int round ;
  int i ;
  u8 intermediatea[16U] ;
  u8 intermediateb[16U] ;
  u8 round_key[16U] ;
  {
  i = 0;
  goto ldv_51730;
  ldv_51729:
  round_key[i] = *(key + (unsigned long )i);
  i = i + 1;
  ldv_51730: ;
  if (i <= 15) {
    goto ldv_51729;
  } else {
  }
  round = 0;
  goto ldv_51733;
  ldv_51732: ;
  if (round == 0) {
    xor_128((u8 *)(& round_key), data, ciphertext);
    next_key((u8 *)(& round_key), round);
  } else
  if (round == 10) {
    byte_sub(ciphertext, (u8 *)(& intermediatea));
    shift_row((u8 *)(& intermediatea), (u8 *)(& intermediateb));
    xor_128((u8 *)(& intermediateb), (u8 *)(& round_key), ciphertext);
  } else {
    byte_sub(ciphertext, (u8 *)(& intermediatea));
    shift_row((u8 *)(& intermediatea), (u8 *)(& intermediateb));
    mix_column((u8 *)(& intermediateb), (u8 *)(& intermediatea));
    mix_column((u8 *)(& intermediateb) + 4UL, (u8 *)(& intermediatea) + 4UL);
    mix_column((u8 *)(& intermediateb) + 8UL, (u8 *)(& intermediatea) + 8UL);
    mix_column((u8 *)(& intermediateb) + 12UL, (u8 *)(& intermediatea) + 12UL);
    xor_128((u8 *)(& intermediatea), (u8 *)(& round_key), ciphertext);
    next_key((u8 *)(& round_key), round);
  }
  round = round + 1;
  ldv_51733: ;
  if (round <= 10) {
    goto ldv_51732;
  } else {
  }
  return;
}
}
static void construct_mic_iv(u8 *mic_iv , int qc_exists , int a4_exists , u8 *mpdu ,
                             uint payload_length , u8 *pn_vector )
{
  int i ;
  {
  *mic_iv = 89U;
  if (qc_exists != 0 && a4_exists != 0) {
    *(mic_iv + 1UL) = (unsigned int )*(mpdu + 30UL) & 15U;
  } else {
  }
  if (qc_exists != 0 && a4_exists == 0) {
    *(mic_iv + 1UL) = (unsigned int )*(mpdu + 24UL) & 15U;
  } else {
  }
  if (qc_exists == 0) {
    *(mic_iv + 1UL) = 0U;
  } else {
  }
  i = 2;
  goto ldv_51745;
  ldv_51744:
  *(mic_iv + (unsigned long )i) = *(mpdu + ((unsigned long )i + 8UL));
  i = i + 1;
  ldv_51745: ;
  if (i <= 7) {
    goto ldv_51744;
  } else {
  }
  i = 8;
  goto ldv_51748;
  ldv_51747:
  *(mic_iv + (unsigned long )i) = *(pn_vector + (unsigned long )(13 - i));
  i = i + 1;
  ldv_51748: ;
  if (i <= 13) {
    goto ldv_51747;
  } else {
  }
  *(mic_iv + 14UL) = (unsigned char )(payload_length / 256U);
  *(mic_iv + 15UL) = (unsigned char )payload_length;
  return;
}
}
static void construct_mic_header1(u8 *mic_header1 , int header_length , u8 *mpdu )
{
  {
  *mic_header1 = (unsigned char )((header_length + -2) / 256);
  *(mic_header1 + 1UL) = (unsigned char )((header_length + -2) % 256);
  *(mic_header1 + 2UL) = (unsigned int )*mpdu & 207U;
  *(mic_header1 + 3UL) = (unsigned int )*(mpdu + 1UL) & 199U;
  *(mic_header1 + 4UL) = *(mpdu + 4UL);
  *(mic_header1 + 5UL) = *(mpdu + 5UL);
  *(mic_header1 + 6UL) = *(mpdu + 6UL);
  *(mic_header1 + 7UL) = *(mpdu + 7UL);
  *(mic_header1 + 8UL) = *(mpdu + 8UL);
  *(mic_header1 + 9UL) = *(mpdu + 9UL);
  *(mic_header1 + 10UL) = *(mpdu + 10UL);
  *(mic_header1 + 11UL) = *(mpdu + 11UL);
  *(mic_header1 + 12UL) = *(mpdu + 12UL);
  *(mic_header1 + 13UL) = *(mpdu + 13UL);
  *(mic_header1 + 14UL) = *(mpdu + 14UL);
  *(mic_header1 + 15UL) = *(mpdu + 15UL);
  return;
}
}
static void construct_mic_header2(u8 *mic_header2 , u8 *mpdu , int a4_exists , int qc_exists )
{
  int i ;
  {
  i = 0;
  goto ldv_51763;
  ldv_51762:
  *(mic_header2 + (unsigned long )i) = 0U;
  i = i + 1;
  ldv_51763: ;
  if (i <= 15) {
    goto ldv_51762;
  } else {
  }
  *mic_header2 = *(mpdu + 16UL);
  *(mic_header2 + 1UL) = *(mpdu + 17UL);
  *(mic_header2 + 2UL) = *(mpdu + 18UL);
  *(mic_header2 + 3UL) = *(mpdu + 19UL);
  *(mic_header2 + 4UL) = *(mpdu + 20UL);
  *(mic_header2 + 5UL) = *(mpdu + 21UL);
  *(mic_header2 + 6UL) = 0U;
  *(mic_header2 + 7UL) = 0U;
  if (qc_exists == 0 && a4_exists != 0) {
    i = 0;
    goto ldv_51766;
    ldv_51765:
    *(mic_header2 + (unsigned long )(i + 8)) = *(mpdu + (unsigned long )(i + 24));
    i = i + 1;
    ldv_51766: ;
    if (i <= 5) {
      goto ldv_51765;
    } else {
    }
  } else {
  }
  if (qc_exists != 0 && a4_exists == 0) {
    *(mic_header2 + 8UL) = (unsigned int )*(mpdu + 24UL) & 15U;
    *(mic_header2 + 9UL) = 0U;
  } else {
  }
  if (qc_exists != 0 && a4_exists != 0) {
    i = 0;
    goto ldv_51769;
    ldv_51768:
    *(mic_header2 + (unsigned long )(i + 8)) = *(mpdu + (unsigned long )(i + 24));
    i = i + 1;
    ldv_51769: ;
    if (i <= 5) {
      goto ldv_51768;
    } else {
    }
    *(mic_header2 + 14UL) = (unsigned int )*(mpdu + 30UL) & 15U;
    *(mic_header2 + 15UL) = 0U;
  } else {
  }
  return;
}
}
static void construct_ctr_preload(u8 *ctr_preload , int a4_exists , int qc_exists ,
                                  u8 *mpdu , u8 *pn_vector , int c )
{
  int i ;
  {
  i = 0;
  i = 0;
  goto ldv_51781;
  ldv_51780:
  *(ctr_preload + (unsigned long )i) = 0U;
  i = i + 1;
  ldv_51781: ;
  if (i <= 15) {
    goto ldv_51780;
  } else {
  }
  i = 0;
  *ctr_preload = 1U;
  if (qc_exists != 0 && a4_exists != 0) {
    *(ctr_preload + 1UL) = (unsigned int )*(mpdu + 30UL) & 15U;
  } else {
  }
  if (qc_exists != 0 && a4_exists == 0) {
    *(ctr_preload + 1UL) = (unsigned int )*(mpdu + 24UL) & 15U;
  } else {
  }
  i = 2;
  goto ldv_51784;
  ldv_51783:
  *(ctr_preload + (unsigned long )i) = *(mpdu + ((unsigned long )i + 8UL));
  i = i + 1;
  ldv_51784: ;
  if (i <= 7) {
    goto ldv_51783;
  } else {
  }
  i = 8;
  goto ldv_51787;
  ldv_51786:
  *(ctr_preload + (unsigned long )i) = *(pn_vector + (unsigned long )(13 - i));
  i = i + 1;
  ldv_51787: ;
  if (i <= 13) {
    goto ldv_51786;
  } else {
  }
  *(ctr_preload + 14UL) = (unsigned char )(c / 256);
  *(ctr_preload + 15UL) = (unsigned char )(c % 256);
  return;
}
}
static void bitwise_xor(u8 *ina , u8 *inb___0 , u8 *out )
{
  int i ;
  {
  i = 0;
  goto ldv_51796;
  ldv_51795:
  *(out + (unsigned long )i) = (u8 )((int )*(ina + (unsigned long )i) ^ (int )*(inb___0 + (unsigned long )i));
  i = i + 1;
  ldv_51796: ;
  if (i <= 15) {
    goto ldv_51795;
  } else {
  }
  return;
}
}
static int aes_cipher(u8 *key , uint hdrlen , u8 *pframe , uint plen )
{
  uint qc_exists ;
  uint a4_exists ;
  uint i ;
  uint j ;
  uint payload_remainder ;
  uint num_blocks ;
  uint payload_index ;
  u8 pn_vector[6U] ;
  u8 mic_iv[16U] ;
  u8 mic_header1[16U] ;
  u8 mic_header2[16U] ;
  u8 ctr_preload[16U] ;
  u8 chain_buffer[16U] ;
  u8 aes_out[16U] ;
  u8 padded_buffer[16U] ;
  u8 mic[8U] ;
  struct ieee80211_hdr *hdr ;
  u16 frsubtype ;
  int tmp ;
  uint tmp___0 ;
  uint tmp___1 ;
  uint tmp___2 ;
  uint tmp___3 ;
  {
  hdr = (struct ieee80211_hdr *)pframe;
  frsubtype = (unsigned int )hdr->frame_control & 240U;
  memset((void *)(& mic_iv), 0, 16UL);
  memset((void *)(& mic_header1), 0, 16UL);
  memset((void *)(& mic_header2), 0, 16UL);
  memset((void *)(& ctr_preload), 0, 16UL);
  memset((void *)(& chain_buffer), 0, 16UL);
  memset((void *)(& aes_out), 0, 16UL);
  memset((void *)(& padded_buffer), 0, 16UL);
  if (hdrlen == 24U || hdrlen == 26U) {
    a4_exists = 0U;
  } else {
    a4_exists = 1U;
  }
  tmp = ieee80211_is_data((int )hdr->frame_control);
  if (tmp != 0) {
    if (((unsigned int )frsubtype == 16U || (unsigned int )frsubtype == 32U) || (unsigned int )frsubtype == 48U) {
      qc_exists = 1U;
      if (hdrlen != 26U) {
        hdrlen = hdrlen + 2U;
      } else {
      }
    } else
    if ((((unsigned int )frsubtype == 128U || (unsigned int )frsubtype == 144U) || (unsigned int )frsubtype == 160U) || (unsigned int )frsubtype == 176U) {
      if (hdrlen != 26U) {
        hdrlen = hdrlen + 2U;
      } else {
      }
      qc_exists = 1U;
    } else {
      qc_exists = 0U;
    }
  } else {
    qc_exists = 0U;
  }
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
  construct_mic_iv((u8 *)(& mic_iv), (int )qc_exists, (int )a4_exists, pframe, plen,
                   (u8 *)(& pn_vector));
  construct_mic_header1((u8 *)(& mic_header1), (int )hdrlen, pframe);
  construct_mic_header2((u8 *)(& mic_header2), pframe, (int )a4_exists, (int )qc_exists);
  payload_remainder = plen & 15U;
  num_blocks = plen / 16U;
  payload_index = hdrlen + 8U;
  aes128k128d(key, (u8 *)(& mic_iv), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header1), (u8 *)(& chain_buffer));
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header2), (u8 *)(& chain_buffer));
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  i = 0U;
  goto ldv_51823;
  ldv_51822:
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
  payload_index = payload_index + 16U;
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  i = i + 1U;
  ldv_51823: ;
  if (i < num_blocks) {
    goto ldv_51822;
  } else {
  }
  if (payload_remainder != 0U) {
    j = 0U;
    goto ldv_51826;
    ldv_51825:
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_51826: ;
    if (j <= 15U) {
      goto ldv_51825;
    } else {
    }
    j = 0U;
    goto ldv_51829;
    ldv_51828:
    tmp___0 = payload_index;
    payload_index = payload_index + 1U;
    padded_buffer[j] = *(pframe + (unsigned long )tmp___0);
    j = j + 1U;
    ldv_51829: ;
    if (j < payload_remainder) {
      goto ldv_51828;
    } else {
    }
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  } else {
  }
  j = 0U;
  goto ldv_51832;
  ldv_51831:
  mic[j] = aes_out[j];
  j = j + 1U;
  ldv_51832: ;
  if (j <= 7U) {
    goto ldv_51831;
  } else {
  }
  j = 0U;
  goto ldv_51835;
  ldv_51834:
  *(pframe + (unsigned long )(payload_index + j)) = mic[j];
  j = j + 1U;
  ldv_51835: ;
  if (j <= 7U) {
    goto ldv_51834;
  } else {
  }
  payload_index = hdrlen + 8U;
  i = 0U;
  goto ldv_51841;
  ldv_51840:
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), (int )(i + 1U));
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_51838;
  ldv_51837:
  tmp___1 = payload_index;
  payload_index = payload_index + 1U;
  *(pframe + (unsigned long )tmp___1) = chain_buffer[j];
  j = j + 1U;
  ldv_51838: ;
  if (j <= 15U) {
    goto ldv_51837;
  } else {
  }
  i = i + 1U;
  ldv_51841: ;
  if (i < num_blocks) {
    goto ldv_51840;
  } else {
  }
  if (payload_remainder != 0U) {
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          pframe, (u8 *)(& pn_vector), (int )(num_blocks + 1U));
    j = 0U;
    goto ldv_51844;
    ldv_51843:
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_51844: ;
    if (j <= 15U) {
      goto ldv_51843;
    } else {
    }
    j = 0U;
    goto ldv_51847;
    ldv_51846:
    padded_buffer[j] = *(pframe + (unsigned long )(payload_index + j));
    j = j + 1U;
    ldv_51847: ;
    if (j < payload_remainder) {
      goto ldv_51846;
    } else {
    }
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    j = 0U;
    goto ldv_51850;
    ldv_51849:
    tmp___2 = payload_index;
    payload_index = payload_index + 1U;
    *(pframe + (unsigned long )tmp___2) = chain_buffer[j];
    j = j + 1U;
    ldv_51850: ;
    if (j < payload_remainder) {
      goto ldv_51849;
    } else {
    }
  } else {
  }
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), 0);
  j = 0U;
  goto ldv_51853;
  ldv_51852:
  padded_buffer[j] = 0U;
  j = j + 1U;
  ldv_51853: ;
  if (j <= 15U) {
    goto ldv_51852;
  } else {
  }
  j = 0U;
  goto ldv_51856;
  ldv_51855:
  padded_buffer[j] = *(pframe + (unsigned long )(((j + hdrlen) + plen) + 8U));
  j = j + 1U;
  ldv_51856: ;
  if (j <= 7U) {
    goto ldv_51855;
  } else {
  }
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_51859;
  ldv_51858:
  tmp___3 = payload_index;
  payload_index = payload_index + 1U;
  *(pframe + (unsigned long )tmp___3) = chain_buffer[j];
  j = j + 1U;
  ldv_51859: ;
  if (j <= 7U) {
    goto ldv_51858;
  } else {
  }
  return (1);
}
}
int rtw_aes_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  int curfragnum ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *prwskey ;
  u8 hw_hdr_offset ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  bool tmp ;
  {
  hw_hdr_offset = 0U;
  pattrib = & pxmitframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  pxmitpriv = & padapter->xmitpriv;
  res = 1;
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
    return (0);
  } else {
  }
  hw_hdr_offset = 40U;
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
  if (pattrib->encrypt != 1027076U) {
    return (0);
  } else {
  }
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    stainfo = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_aes_encrypt23a");
    } else {
    }
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pattrib->ra));
  }
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
      printk("\016rtw_aes_encrypt23a: stainfo == NULL!!!\n");
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_aes_encrypt23a");
    } else {
    }
    res = 0;
    goto out;
  } else {
  }
  if ((stainfo->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_aes_encrypt23a",
             stainfo->state);
    } else {
    }
    return (0);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
    printk("\016rtw_aes_encrypt23a: stainfo!= NULL!!!\n");
  } else {
  }
  tmp = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
  if ((int )tmp) {
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey);
  } else {
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
  prwskeylen = 16U;
  curfragnum = 0;
  goto ldv_51879;
  ldv_51878: ;
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
    aes_cipher(prwskey, (uint )pattrib->hdrlen, pframe, (uint )length);
  } else {
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
    aes_cipher(prwskey, (uint )pattrib->hdrlen, pframe, (uint )length);
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
  curfragnum = curfragnum + 1;
  ldv_51879: ;
  if ((int )pattrib->nr_frags > curfragnum) {
    goto ldv_51878;
  } else {
  }
  out: ;
  return (res);
}
}
static int aes_decipher(u8 *key , uint hdrlen , u8 *pframe , uint plen )
{
  u8 message[2048U] ;
  uint qc_exists ;
  uint a4_exists ;
  uint i ;
  uint j ;
  uint payload_remainder ;
  uint num_blocks ;
  uint payload_index ;
  int res ;
  u8 pn_vector[6U] ;
  u8 mic_iv[16U] ;
  u8 mic_header1[16U] ;
  u8 mic_header2[16U] ;
  u8 ctr_preload[16U] ;
  u8 chain_buffer[16U] ;
  u8 aes_out[16U] ;
  u8 padded_buffer[16U] ;
  u8 mic[8U] ;
  struct ieee80211_hdr *hdr ;
  u16 frsubtype ;
  int tmp ;
  uint tmp___0 ;
  uint tmp___1 ;
  size_t __len ;
  void *__ret ;
  uint tmp___2 ;
  uint tmp___3 ;
  uint tmp___4 ;
  uint tmp___5 ;
  {
  res = 1;
  hdr = (struct ieee80211_hdr *)pframe;
  frsubtype = (unsigned int )hdr->frame_control & 240U;
  memset((void *)(& mic_iv), 0, 16UL);
  memset((void *)(& mic_header1), 0, 16UL);
  memset((void *)(& mic_header2), 0, 16UL);
  memset((void *)(& ctr_preload), 0, 16UL);
  memset((void *)(& chain_buffer), 0, 16UL);
  memset((void *)(& aes_out), 0, 16UL);
  memset((void *)(& padded_buffer), 0, 16UL);
  num_blocks = (plen - 8U) / 16U;
  payload_remainder = (plen - 8U) & 15U;
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
  if (hdrlen == 24U || hdrlen == 26U) {
    a4_exists = 0U;
  } else {
    a4_exists = 1U;
  }
  tmp = ieee80211_is_data((int )hdr->frame_control);
  if (tmp != 0) {
    if (((unsigned int )frsubtype == 16U || (unsigned int )frsubtype == 32U) || (unsigned int )frsubtype == 48U) {
      qc_exists = 1U;
      if (hdrlen != 24U) {
        hdrlen = hdrlen + 2U;
      } else {
      }
    } else
    if ((((unsigned int )frsubtype == 128U || (unsigned int )frsubtype == 144U) || (unsigned int )frsubtype == 160U) || (unsigned int )frsubtype == 176U) {
      if (hdrlen != 24U) {
        hdrlen = hdrlen + 2U;
      } else {
      }
      qc_exists = 1U;
    } else {
      qc_exists = 0U;
    }
  } else {
    qc_exists = 0U;
  }
  payload_index = hdrlen + 8U;
  i = 0U;
  goto ldv_51911;
  ldv_51910:
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), (int )(i + 1U));
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_51908;
  ldv_51907:
  tmp___0 = payload_index;
  payload_index = payload_index + 1U;
  *(pframe + (unsigned long )tmp___0) = chain_buffer[j];
  j = j + 1U;
  ldv_51908: ;
  if (j <= 15U) {
    goto ldv_51907;
  } else {
  }
  i = i + 1U;
  ldv_51911: ;
  if (i < num_blocks) {
    goto ldv_51910;
  } else {
  }
  if (payload_remainder != 0U) {
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          pframe, (u8 *)(& pn_vector), (int )(num_blocks + 1U));
    j = 0U;
    goto ldv_51914;
    ldv_51913:
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_51914: ;
    if (j <= 15U) {
      goto ldv_51913;
    } else {
    }
    j = 0U;
    goto ldv_51917;
    ldv_51916:
    padded_buffer[j] = *(pframe + (unsigned long )(payload_index + j));
    j = j + 1U;
    ldv_51917: ;
    if (j < payload_remainder) {
      goto ldv_51916;
    } else {
    }
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    j = 0U;
    goto ldv_51920;
    ldv_51919:
    tmp___1 = payload_index;
    payload_index = payload_index + 1U;
    *(pframe + (unsigned long )tmp___1) = chain_buffer[j];
    j = j + 1U;
    ldv_51920: ;
    if (j < payload_remainder) {
      goto ldv_51919;
    } else {
    }
  } else {
  }
  if ((hdrlen + plen) + 8U <= 2048U) {
    __len = (size_t )((hdrlen + plen) + 8U);
    __ret = memcpy((void *)(& message), (void const *)pframe, __len);
  } else {
  }
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
  construct_mic_iv((u8 *)(& mic_iv), (int )qc_exists, (int )a4_exists, (u8 *)(& message),
                   plen - 8U, (u8 *)(& pn_vector));
  construct_mic_header1((u8 *)(& mic_header1), (int )hdrlen, (u8 *)(& message));
  construct_mic_header2((u8 *)(& mic_header2), (u8 *)(& message), (int )a4_exists,
                        (int )qc_exists);
  payload_remainder = (plen - 8U) & 15U;
  num_blocks = (plen - 8U) / 16U;
  payload_index = hdrlen + 8U;
  aes128k128d(key, (u8 *)(& mic_iv), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header1), (u8 *)(& chain_buffer));
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header2), (u8 *)(& chain_buffer));
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  i = 0U;
  goto ldv_51926;
  ldv_51925:
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& message) + (unsigned long )payload_index,
              (u8 *)(& chain_buffer));
  payload_index = payload_index + 16U;
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  i = i + 1U;
  ldv_51926: ;
  if (i < num_blocks) {
    goto ldv_51925;
  } else {
  }
  if (payload_remainder != 0U) {
    j = 0U;
    goto ldv_51929;
    ldv_51928:
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_51929: ;
    if (j <= 15U) {
      goto ldv_51928;
    } else {
    }
    j = 0U;
    goto ldv_51932;
    ldv_51931:
    tmp___2 = payload_index;
    payload_index = payload_index + 1U;
    padded_buffer[j] = message[tmp___2];
    j = j + 1U;
    ldv_51932: ;
    if (j < payload_remainder) {
      goto ldv_51931;
    } else {
    }
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  } else {
  }
  j = 0U;
  goto ldv_51935;
  ldv_51934:
  mic[j] = aes_out[j];
  j = j + 1U;
  ldv_51935: ;
  if (j <= 7U) {
    goto ldv_51934;
  } else {
  }
  j = 0U;
  goto ldv_51938;
  ldv_51937:
  message[payload_index + j] = mic[j];
  j = j + 1U;
  ldv_51938: ;
  if (j <= 7U) {
    goto ldv_51937;
  } else {
  }
  payload_index = hdrlen + 8U;
  i = 0U;
  goto ldv_51944;
  ldv_51943:
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, (u8 *)(& message),
                        (u8 *)(& pn_vector), (int )(i + 1U));
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& message) + (unsigned long )payload_index,
              (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_51941;
  ldv_51940:
  tmp___3 = payload_index;
  payload_index = payload_index + 1U;
  message[tmp___3] = chain_buffer[j];
  j = j + 1U;
  ldv_51941: ;
  if (j <= 15U) {
    goto ldv_51940;
  } else {
  }
  i = i + 1U;
  ldv_51944: ;
  if (i < num_blocks) {
    goto ldv_51943;
  } else {
  }
  if (payload_remainder != 0U) {
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          (u8 *)(& message), (u8 *)(& pn_vector), (int )(num_blocks + 1U));
    j = 0U;
    goto ldv_51947;
    ldv_51946:
    padded_buffer[j] = 0U;
    j = j + 1U;
    ldv_51947: ;
    if (j <= 15U) {
      goto ldv_51946;
    } else {
    }
    j = 0U;
    goto ldv_51950;
    ldv_51949:
    padded_buffer[j] = message[payload_index + j];
    j = j + 1U;
    ldv_51950: ;
    if (j < payload_remainder) {
      goto ldv_51949;
    } else {
    }
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
    j = 0U;
    goto ldv_51953;
    ldv_51952:
    tmp___4 = payload_index;
    payload_index = payload_index + 1U;
    message[tmp___4] = chain_buffer[j];
    j = j + 1U;
    ldv_51953: ;
    if (j < payload_remainder) {
      goto ldv_51952;
    } else {
    }
  } else {
  }
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, (u8 *)(& message),
                        (u8 *)(& pn_vector), 0);
  j = 0U;
  goto ldv_51956;
  ldv_51955:
  padded_buffer[j] = 0U;
  j = j + 1U;
  ldv_51956: ;
  if (j <= 15U) {
    goto ldv_51955;
  } else {
  }
  j = 0U;
  goto ldv_51959;
  ldv_51958:
  padded_buffer[j] = message[(j + hdrlen) + plen];
  j = j + 1U;
  ldv_51959: ;
  if (j <= 7U) {
    goto ldv_51958;
  } else {
  }
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
  j = 0U;
  goto ldv_51962;
  ldv_51961:
  tmp___5 = payload_index;
  payload_index = payload_index + 1U;
  message[tmp___5] = chain_buffer[j];
  j = j + 1U;
  ldv_51962: ;
  if (j <= 7U) {
    goto ldv_51961;
  } else {
  }
  i = 0U;
  goto ldv_51965;
  ldv_51964: ;
  if ((int )*(pframe + (unsigned long )((hdrlen + plen) + i)) != (int )message[(hdrlen + plen) + i]) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
      printk("\016aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x)\n",
             i, (int )*(pframe + (unsigned long )((hdrlen + plen) + i)), (int )message[(hdrlen + plen) + i]);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x)\n",
             i, (int )*(pframe + (unsigned long )((hdrlen + plen) + i)), (int )message[(hdrlen + plen) + i]);
    } else {
    }
    res = 0;
  } else {
  }
  i = i + 1U;
  ldv_51965: ;
  if (i <= 7U) {
    goto ldv_51964;
  } else {
  }
  return (res);
}
}
int rtw_aes_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe )
{
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  int length ;
  u8 *pframe ;
  u8 *prwskey ;
  int res ;
  bool tmp ;
  {
  prxattrib = & precvframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  skb = precvframe->pkt;
  res = 1;
  pframe = skb->data;
  if (prxattrib->encrypt != 1027076U) {
    return (0);
  } else {
  }
  stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& prxattrib->ta));
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
      printk("\016rtw_aes_encrypt23a: stainfo == NULL!!!\n");
    } else {
    }
    res = 0;
    goto exit;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
    printk("\016rtw_aes_decrypt23a: stainfo!= NULL!!!\n");
  } else {
  }
  tmp = is_multicast_ether_addr((u8 const *)(& prxattrib->ra));
  if ((int )tmp) {
    if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
      res = 0;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s:rx bc/mc packets, but didn\'t install group key!!!!!!!!!!\n",
               "rtw_aes_decrypt23a");
      } else {
      }
      goto exit;
    } else {
    }
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[(int )prxattrib->key_index].skey);
    if (psecuritypriv->dot118021XGrpKeyid != (u32 )prxattrib->key_index) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: not match packet_index =%d, install_index =%d\n", (int )prxattrib->key_index,
               psecuritypriv->dot118021XGrpKeyid);
      } else {
      }
      res = 0;
      goto exit;
    } else {
    }
  } else {
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
  res = aes_decipher(prwskey, (uint )prxattrib->hdrlen, pframe, (uint )length);
  exit: ;
  return (res);
}
}
void rtw_use_tkipkey_handler23a(void *FunctionContext )
{
  struct rtw_adapter *padapter ;
  {
  padapter = (struct rtw_adapter *)FunctionContext;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
    printk("\016^^^rtw_use_tkipkey_handler23a ^^^\n");
  } else {
  }
  padapter->securitypriv.busetkipkey = 1U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
    printk("\016^^^rtw_use_tkipkey_handler23a padapter->securitypriv.busetkipkey =%d^^^\n",
           (int )padapter->securitypriv.busetkipkey);
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_696(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_702(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_704(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_706(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_707(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_708(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_709(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_710(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_711(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_712(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
__inline static void set_bit(long nr , unsigned long volatile *addr )
{
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile *)addr)): "Ir" (nr): "memory");
  return;
}
}
__inline static int test_and_set_bit(long nr , unsigned long volatile *addr )
{
  char c ;
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
  return ((int )((signed char )c) != 0);
}
}
__inline static int test_and_clear_bit(long nr , unsigned long volatile *addr )
{
  char c ;
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
  return ((int )((signed char )c) != 0);
}
}
__inline static int constant_test_bit(long nr , unsigned long const volatile *addr )
{
  {
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
extern void __mutex_init(struct mutex * , char const * , struct lock_class_key * ) ;
int ldv_mod_timer_755(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
void *ldv_kmem_cache_alloc_738(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_746(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_754(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_748(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_744(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_752(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_753(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_749(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_750(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_751(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
extern void __tasklet_hi_schedule(struct tasklet_struct * ) ;
__inline static void tasklet_hi_schedule(struct tasklet_struct *t )
{
  int tmp ;
  {
  tmp = test_and_set_bit(0L, (unsigned long volatile *)(& t->state));
  if (tmp == 0) {
    __tasklet_hi_schedule(t);
  } else {
  }
  return;
}
}
extern void tasklet_kill(struct tasklet_struct * ) ;
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device const *dev ,
                                                         unsigned int index )
{
  {
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
extern void __netif_schedule(struct Qdisc * ) ;
__inline static void netif_tx_wake_queue(struct netdev_queue *dev_queue )
{
  int tmp ;
  {
  tmp = test_and_clear_bit(0L, (unsigned long volatile *)(& dev_queue->state));
  if (tmp != 0) {
    __netif_schedule(dev_queue->qdisc);
  } else {
  }
  return;
}
}
__inline static void netif_tx_wake_all_queues(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_40894;
  ldv_40893:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_wake_queue(txq);
  i = i + 1U;
  ldv_40894: ;
  if (dev->num_tx_queues > i) {
    goto ldv_40893;
  } else {
  }
  return;
}
}
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue )
{
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  {
  __ret_warn_on = (unsigned long )dev_queue == (unsigned long )((struct netdev_queue *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("include/linux/netdevice.h", 2212);
  } else {
  }
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    printk("\016netif_stop_queue() cannot be called before register_netdev()\n");
    return;
  } else {
  }
  set_bit(0L, (unsigned long volatile *)(& dev_queue->state));
  return;
}
}
__inline static void netif_tx_stop_all_queues(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_40910;
  ldv_40909:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_stop_queue(txq);
  i = i + 1U;
  ldv_40910: ;
  if (dev->num_tx_queues > i) {
    goto ldv_40909;
  } else {
  }
  return;
}
}
__inline static bool netif_tx_queue_stopped(struct netdev_queue const *dev_queue )
{
  int tmp ;
  {
  tmp = constant_test_bit(0L, (unsigned long const volatile *)(& dev_queue->state));
  return (tmp != 0);
}
}
__inline static int rtw_netif_queue_stopped(struct net_device *pnetdev )
{
  struct netdev_queue *tmp ;
  bool tmp___0 ;
  struct netdev_queue *tmp___1 ;
  bool tmp___2 ;
  struct netdev_queue *tmp___3 ;
  bool tmp___4 ;
  struct netdev_queue *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  {
  tmp = netdev_get_tx_queue((struct net_device const *)pnetdev, 0U);
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue const *)tmp);
  if ((int )tmp___0) {
    tmp___1 = netdev_get_tx_queue((struct net_device const *)pnetdev, 1U);
    tmp___2 = netif_tx_queue_stopped((struct netdev_queue const *)tmp___1);
    if ((int )tmp___2) {
      tmp___3 = netdev_get_tx_queue((struct net_device const *)pnetdev, 2U);
      tmp___4 = netif_tx_queue_stopped((struct netdev_queue const *)tmp___3);
      if ((int )tmp___4) {
        tmp___5 = netdev_get_tx_queue((struct net_device const *)pnetdev, 3U);
        tmp___6 = netif_tx_queue_stopped((struct netdev_queue const *)tmp___5);
        if ((int )tmp___6) {
          tmp___7 = 1;
        } else {
          tmp___7 = 0;
        }
      } else {
        tmp___7 = 0;
      }
    } else {
      tmp___7 = 0;
    }
  } else {
    tmp___7 = 0;
  }
  return (tmp___7);
}
}
void rtw_cancel_all_timer23a(struct rtw_adapter *padapter ) ;
void rtw_ap_restore_network(struct rtw_adapter *padapter ) ;
void rtw_sreset_init(struct rtw_adapter *padapter ) ;
void rtw_sreset_reset_value(struct rtw_adapter *padapter ) ;
u8 rtw_sreset_get_wifi_status(struct rtw_adapter *padapter ) ;
void sreset_set_wifi_error_status23a(struct rtw_adapter *padapter , u32 status ) ;
void sreset_set_trigger_point(struct rtw_adapter *padapter , s32 tgp ) ;
void rtw_sreset_init(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  struct lock_class_key __key ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  __mutex_init(& psrtpriv->silentreset_mutex, "&psrtpriv->silentreset_mutex", & __key);
  psrtpriv->silent_reset_inprogress = 0U;
  psrtpriv->Wifi_Error_Status = 0U;
  psrtpriv->last_tx_time = 0UL;
  psrtpriv->last_tx_complete_time = 0UL;
  return;
}
}
void rtw_sreset_reset_value(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  psrtpriv->silent_reset_inprogress = 0U;
  psrtpriv->Wifi_Error_Status = 0U;
  psrtpriv->last_tx_time = 0UL;
  psrtpriv->last_tx_complete_time = 0UL;
  return;
}
}
u8 rtw_sreset_get_wifi_status(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  u8 status ;
  u32 val32 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  status = 0U;
  val32 = 0U;
  if ((unsigned int )psrtpriv->silent_reset_inprogress != 0U) {
    return (status);
  } else {
  }
  val32 = rtl8723au_read32(padapter, 528U);
  if (val32 == 3941264106U) {
    psrtpriv->Wifi_Error_Status = 64U;
  } else
  if (val32 != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: txdmastatu(%x)\n", val32);
    } else {
    }
    psrtpriv->Wifi_Error_Status = 8U;
  } else {
  }
  if ((unsigned int )psrtpriv->Wifi_Error_Status != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ==>%s error_status(0x%x)\n", "rtw_sreset_get_wifi_status",
             (int )psrtpriv->Wifi_Error_Status);
    } else {
    }
    status = (unsigned int )psrtpriv->Wifi_Error_Status & 249U;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ==> %s wifi_status(0x%x)\n", "rtw_sreset_get_wifi_status",
           (int )status);
  } else {
  }
  psrtpriv->Wifi_Error_Status = 0U;
  return (status);
}
}
void sreset_set_wifi_error_status23a(struct rtw_adapter *padapter , u32 status )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->srestpriv.Wifi_Error_Status = (u8 )status;
  return;
}
}
void sreset_set_trigger_point(struct rtw_adapter *padapter , s32 tgp )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->srestpriv.dbg_trigger_point = tgp;
  return;
}
}
bool rtw_sreset_inprogress(struct rtw_adapter *padapter )
{
  struct rtw_adapter *primary_adapter ;
  struct hal_data_8723a *pHalData ;
  {
  primary_adapter = (padapter->dvobj)->if1;
  pHalData = (struct hal_data_8723a *)primary_adapter->HalData;
  return ((unsigned int )pHalData->srestpriv.silent_reset_inprogress != 0U);
}
}
static void sreset_restore_security_station(struct rtw_adapter *padapter )
{
  struct mlme_priv *mlmepriv ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 val8 ;
  u8 *tmp ;
  {
  mlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  pmlmeinfo = & padapter->mlmeextpriv.mlmext_info;
  if (pmlmeinfo->auth_algo == 2U) {
    val8 = 204U;
  } else {
    val8 = 207U;
  }
  rtl8723a_set_sec_cfg(padapter, (int )val8);
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
    tmp = get_bssid(mlmepriv);
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)tmp);
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    } else {
      rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
      rtw_set_key23a(padapter, & padapter->securitypriv, (int )padapter->securitypriv.dot118021XGrpKeyid,
                     0);
    }
  } else {
  }
  return;
}
}
static void sreset_restore_network_station(struct rtw_adapter *padapter )
{
  struct mlme_priv *mlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 threshold ;
  {
  mlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  rtw_setopmode_cmd23a(padapter, 2);
  if (mlmepriv->htpriv.ht_option != 0U) {
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
      threshold = 1U;
    } else {
      threshold = 0U;
    }
  } else {
    threshold = 1U;
  }
  rtl8723a_set_rxdma_agg_pg_th(padapter, (int )threshold);
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  hw_var_set_bssid(padapter, (u8 *)(& pmlmeinfo->network.MacAddress));
  hw_var_set_mlme_join(padapter, 0);
  Set_MSR23a(padapter, (int )((u8 )pmlmeinfo->state) & 3);
  mlmeext_joinbss_event_callback23a(padapter, 1);
  rtl8723au_write8(padapter, 1244U, (int )((u8 )padapter->xmitpriv.nqos_ssn));
  sreset_restore_security_station(padapter);
  return;
}
}
static void sreset_restore_network_status(struct rtw_adapter *padapter )
{
  struct mlme_priv *mlmepriv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  {
  mlmepriv = & padapter->mlmepriv;
  tmp___5 = check_fwstate(mlmepriv, 8);
  if ((int )tmp___5) {
    if (GlobalDebugLevel23A > 3U) {
      tmp = get_fwstate(mlmepriv);
      printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_STATION_STATE\n", "sreset_restore_network_status",
             (char *)(& (padapter->pnetdev)->name), tmp);
    } else {
    }
    sreset_restore_network_station(padapter);
  } else {
    tmp___4 = check_fwstate(mlmepriv, 16);
    if ((int )tmp___4) {
      if (GlobalDebugLevel23A > 3U) {
        tmp___0 = get_fwstate(mlmepriv);
        printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_AP_STATE\n", "sreset_restore_network_status",
               (char *)(& (padapter->pnetdev)->name), tmp___0);
      } else {
      }
      rtw_ap_restore_network(padapter);
    } else {
      tmp___3 = check_fwstate(mlmepriv, 32);
      if ((int )tmp___3) {
        if (GlobalDebugLevel23A > 3U) {
          tmp___1 = get_fwstate(mlmepriv);
          printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_ADHOC_STATE\n", "sreset_restore_network_status",
                 (char *)(& (padapter->pnetdev)->name), tmp___1);
        } else {
        }
      } else
      if (GlobalDebugLevel23A > 3U) {
        tmp___2 = get_fwstate(mlmepriv);
        printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - ???\n", "sreset_restore_network_status",
               (char *)(& (padapter->pnetdev)->name), tmp___2);
      } else {
      }
    }
  }
  return;
}
}
static void sreset_stop_adapter(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmitpriv ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pxmitpriv = & padapter->xmitpriv;
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "sreset_stop_adapter", (char *)(& (padapter->pnetdev)->name));
  } else {
  }
  tmp = rtw_netif_queue_stopped(padapter->pnetdev);
  if (tmp == 0) {
    netif_tx_stop_all_queues(padapter->pnetdev);
  } else {
  }
  rtw_cancel_all_timer23a(padapter);
  tasklet_kill(& pxmitpriv->xmit_tasklet);
  tmp___0 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___0) {
    rtw_scan_abort23a(padapter);
  } else {
  }
  tmp___1 = check_fwstate(pmlmepriv, 128);
  if ((int )tmp___1) {
    rtw23a_join_to_handler((unsigned long )padapter);
  } else {
  }
  return;
}
}
static void sreset_start_adapter(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmitpriv ;
  bool tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pxmitpriv = & padapter->xmitpriv;
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "sreset_start_adapter", (char *)(& (padapter->pnetdev)->name));
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    sreset_restore_network_status(padapter);
  } else {
  }
  tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  tmp___0 = msecs_to_jiffies(2000U);
  ldv_mod_timer_755(& padapter->mlmepriv.dynamic_chk_timer, tmp___0 + (unsigned long )jiffies);
  tmp___1 = rtw_netif_queue_stopped(padapter->pnetdev);
  if (tmp___1 != 0) {
    netif_tx_wake_all_queues(padapter->pnetdev);
  } else {
  }
  return;
}
}
void rtw_sreset_reset(struct rtw_adapter *active_adapter )
{
  struct rtw_adapter *padapter ;
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  struct pwrctrl_priv *pwrpriv ;
  unsigned long start ;
  unsigned int tmp ;
  {
  padapter = (active_adapter->dvobj)->if1;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  pwrpriv = & padapter->pwrctrlpriv;
  start = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_sreset_reset");
  } else {
  }
  psrtpriv->Wifi_Error_Status = 0U;
  mutex_lock_nested(& psrtpriv->silentreset_mutex, 0U);
  psrtpriv->silent_reset_inprogress = 1U;
  pwrpriv->change_rfpwrstate = 2;
  sreset_stop_adapter(padapter);
  ips_enter23a(padapter);
  ips_leave23a(padapter);
  sreset_start_adapter(padapter);
  psrtpriv->silent_reset_inprogress = 0U;
  mutex_unlock(& psrtpriv->silentreset_mutex);
  if (GlobalDebugLevel23A > 3U) {
    tmp = jiffies_to_msecs((unsigned long )jiffies - start);
    printk("\016RTL8723AU: %s done in %d ms\n", "rtw_sreset_reset", tmp);
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_738(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_744(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_746(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_748(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_749(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_750(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_751(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_752(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_753(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_754(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_mod_timer_755(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
int ldv_del_timer_sync_799(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_800(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_801(struct timer_list *ldv_func_arg1 ) ;
void *ldv_kmem_cache_alloc_782(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_790(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_798(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_792(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_788(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_796(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_797(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_793(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_794(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_795(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
void rtw_free_xmitframe_queue23a(struct xmit_priv *pxmitpriv , struct rtw_queue *pframequeue ) ;
void _rtw_init_sta_xmit_priv23a(struct sta_xmit_priv *psta_xmitpriv ) ;
__inline static u32 wifi_mac_hash(u8 const *mac )
{
  u32 x ;
  {
  x = (u32 )*mac;
  x = (x << 2) ^ (u32 )*(mac + 1UL);
  x = (x << 2) ^ (u32 )*(mac + 2UL);
  x = (x << 2) ^ (u32 )*(mac + 3UL);
  x = (x << 2) ^ (u32 )*(mac + 4UL);
  x = (x << 2) ^ (u32 )*(mac + 5UL);
  x = (x >> 8) ^ x;
  x = x & 31U;
  return (x);
}
}
int _rtw_init_sta_priv23a(struct sta_priv *pstapriv ) ;
int _rtw_free_sta_priv23a(struct sta_priv *pstapriv ) ;
void rtw_init_recv_timer23a(struct recv_reorder_ctrl *preorder_ctrl ) ;
static void _rtw_init_stainfo(struct sta_info *psta )
{
  struct lock_class_key __key ;
  {
  memset((void *)psta, 0, 5656UL);
  spinlock_check(& psta->lock);
  __raw_spin_lock_init(& psta->lock.ldv_6347.rlock, "&(&psta->lock)->rlock", & __key);
  INIT_LIST_HEAD(& psta->list);
  INIT_LIST_HEAD(& psta->hash_list);
  _rtw_init_queue23a(& psta->sleep_q);
  psta->sleepq_len = 0U;
  _rtw_init_sta_xmit_priv23a(& psta->sta_xmitpriv);
  _rtw_init_sta_recv_priv23a(& psta->sta_recvpriv);
  INIT_LIST_HEAD(& psta->asoc_list);
  INIT_LIST_HEAD(& psta->auth_list);
  psta->expire_to = 0U;
  psta->flags = 0;
  psta->capability = 0U;
  psta->bpairwise_key_installed = 0U;
  psta->nonerp_set = 0U;
  psta->no_short_slot_time_set = 0U;
  psta->no_short_preamble_set = 0U;
  psta->no_ht_gf_set = 0U;
  psta->no_ht_set = 0U;
  psta->ht_20mhz_set = 0U;
  psta->keep_alive_trycnt = 0U;
  return;
}
}
int _rtw_init_sta_priv23a(struct sta_priv *pstapriv )
{
  int i ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  {
  spinlock_check(& pstapriv->sta_hash_lock);
  __raw_spin_lock_init(& pstapriv->sta_hash_lock.ldv_6347.rlock, "&(&pstapriv->sta_hash_lock)->rlock",
                       & __key);
  pstapriv->asoc_sta_count = 0;
  i = 0;
  goto ldv_54245;
  ldv_54244:
  INIT_LIST_HEAD((struct list_head *)(& pstapriv->sta_hash) + (unsigned long )i);
  i = i + 1;
  ldv_54245: ;
  if (i <= 31) {
    goto ldv_54244;
  } else {
  }
  pstapriv->sta_dz_bitmap = 0U;
  pstapriv->tim_bitmap = 0U;
  INIT_LIST_HEAD(& pstapriv->asoc_list);
  INIT_LIST_HEAD(& pstapriv->auth_list);
  spinlock_check(& pstapriv->asoc_list_lock);
  __raw_spin_lock_init(& pstapriv->asoc_list_lock.ldv_6347.rlock, "&(&pstapriv->asoc_list_lock)->rlock",
                       & __key___0);
  spinlock_check(& pstapriv->auth_list_lock);
  __raw_spin_lock_init(& pstapriv->auth_list_lock.ldv_6347.rlock, "&(&pstapriv->auth_list_lock)->rlock",
                       & __key___1);
  pstapriv->asoc_list_cnt = 0U;
  pstapriv->auth_list_cnt = 0U;
  pstapriv->auth_to = 3U;
  pstapriv->assoc_to = 3U;
  pstapriv->expire_to = 3U;
  pstapriv->max_num_sta = 32U;
  return (1);
}
}
int _rtw_free_sta_priv23a(struct sta_priv *pstapriv )
{
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  int index ;
  int i ;
  struct list_head const *__mptr ;
  {
  if ((unsigned long )pstapriv != (unsigned long )((struct sta_priv *)0)) {
    spin_lock_bh(& pstapriv->sta_hash_lock);
    index = 0;
    goto ldv_54268;
    ldv_54267:
    phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
    plist = phead->next;
    ptmp = plist->next;
    goto ldv_54265;
    ldv_54264:
    __mptr = (struct list_head const *)plist;
    psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
    i = 0;
    goto ldv_54262;
    ldv_54261:
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
    ldv_del_timer_sync_799(& preorder_ctrl->reordering_ctrl_timer);
    i = i + 1;
    ldv_54262: ;
    if (i <= 15) {
      goto ldv_54261;
    } else {
    }
    plist = ptmp;
    ptmp = plist->next;
    ldv_54265: ;
    if ((unsigned long )plist != (unsigned long )phead) {
      goto ldv_54264;
    } else {
    }
    index = index + 1;
    ldv_54268: ;
    if (index <= 31) {
      goto ldv_54267;
    } else {
    }
    spin_unlock_bh(& pstapriv->sta_hash_lock);
  } else {
  }
  return (1);
}
}
struct sta_info *rtw_alloc_stainfo23a(struct sta_priv *pstapriv , u8 *hwaddr , gfp_t gfp )
{
  struct list_head *phash_list ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  s32 index ;
  int i ;
  u16 wRxSeqInitialValue ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  u32 tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  i = 0;
  wRxSeqInitialValue = 65535U;
  tmp = kmalloc(5656UL, gfp);
  psta = (struct sta_info *)tmp;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return ((struct sta_info *)0);
  } else {
  }
  spin_lock_bh(& pstapriv->sta_hash_lock);
  _rtw_init_stainfo(psta);
  psta->padapter = pstapriv->padapter;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& psta->hwaddr), (void const *)hwaddr, __len);
  } else {
    __ret = memcpy((void *)(& psta->hwaddr), (void const *)hwaddr, __len);
  }
  tmp___0 = wifi_mac_hash((u8 const *)hwaddr);
  index = (s32 )tmp___0;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 7);
    printk("\016rtw_alloc_stainfo23a: index  = %x", index);
  } else {
  }
  if (index > 31) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 4);
      printk("\016ERROR => rtw_alloc_stainfo23a: index >= NUM_STA");
    } else {
    }
    psta = (struct sta_info *)0;
    goto exit;
  } else {
  }
  phash_list = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
  list_add_tail(& psta->hash_list, phash_list);
  pstapriv->asoc_sta_count = pstapriv->asoc_sta_count + 1;
  i = 0;
  goto ldv_54289;
  ldv_54288:
  __len___0 = 2UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& psta->sta_recvpriv.rxcache.tid_rxseq) + (unsigned long )i,
                         (void const *)(& wRxSeqInitialValue), __len___0);
  } else {
    __ret___0 = memcpy((void *)(& psta->sta_recvpriv.rxcache.tid_rxseq) + (unsigned long )i,
                                 (void const *)(& wRxSeqInitialValue), __len___0);
  }
  i = i + 1;
  ldv_54289: ;
  if (i <= 15) {
    goto ldv_54288;
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 7);
    printk("\016alloc number_%d stainfo  with hwaddr = %pM\n", pstapriv->asoc_sta_count,
           hwaddr);
  } else {
  }
  init_addba_retry_timer23a(psta);
  i = 0;
  goto ldv_54292;
  ldv_54291:
  preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
  preorder_ctrl->padapter = pstapriv->padapter;
  preorder_ctrl->enable = 0U;
  preorder_ctrl->indicate_seq = 65535U;
  preorder_ctrl->wend_b = 65535U;
  preorder_ctrl->wsize_b = 64U;
  _rtw_init_queue23a(& preorder_ctrl->pending_recvframe_queue);
  rtw_init_recv_timer23a(preorder_ctrl);
  i = i + 1;
  ldv_54292: ;
  if (i <= 15) {
    goto ldv_54291;
  } else {
  }
  psta->rssi_stat.UndecoratedSmoothedPWDB = -1;
  psta->rssi_stat.UndecoratedSmoothedCCK = -1;
  psta->RxMgmtFrameSeqNum = 65535U;
  exit:
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return (psta);
}
}
int rtw_free_stainfo23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_xmit_priv *pstaxmitpriv ;
  struct xmit_priv *pxmitpriv ;
  struct sta_priv *pstapriv ;
  struct hw_xmit *phwxmit ;
  int i ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct recv_frame *prframe ;
  struct rtw_queue *ppending_recvframe_queue ;
  struct list_head const *__mptr ;
  int tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pstapriv = & padapter->stapriv;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    goto exit;
  } else {
  }
  spin_lock_bh(& psta->lock);
  psta->state = psta->state & 4294967294U;
  spin_unlock_bh(& psta->lock);
  pstaxmitpriv = & psta->sta_xmitpriv;
  spin_lock_bh(& pxmitpriv->lock);
  rtw_free_xmitframe_queue23a(pxmitpriv, & psta->sleep_q);
  psta->sleepq_len = 0U;
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->vo_q.sta_pending);
  list_del_init(& pstaxmitpriv->vo_q.tx_pending);
  phwxmit = pxmitpriv->hwxmits;
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->vo_q.qcnt;
  pstaxmitpriv->vo_q.qcnt = 0;
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->vi_q.sta_pending);
  list_del_init(& pstaxmitpriv->vi_q.tx_pending);
  phwxmit = pxmitpriv->hwxmits + 1UL;
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->vi_q.qcnt;
  pstaxmitpriv->vi_q.qcnt = 0;
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->be_q.sta_pending);
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
  phwxmit = pxmitpriv->hwxmits + 2UL;
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->be_q.qcnt;
  pstaxmitpriv->be_q.qcnt = 0;
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->bk_q.sta_pending);
  list_del_init(& pstaxmitpriv->bk_q.tx_pending);
  phwxmit = pxmitpriv->hwxmits + 3UL;
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->bk_q.qcnt;
  pstaxmitpriv->bk_q.qcnt = 0;
  spin_unlock_bh(& pxmitpriv->lock);
  list_del_init(& psta->hash_list);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 4);
    printk("\016\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n",
           pstapriv->asoc_sta_count, (int )psta->hwaddr[0], (int )psta->hwaddr[1],
           (int )psta->hwaddr[2], (int )psta->hwaddr[3], (int )psta->hwaddr[4], (int )psta->hwaddr[5]);
  } else {
  }
  pstapriv->asoc_sta_count = pstapriv->asoc_sta_count - 1;
  ldv_del_timer_sync_800(& psta->addba_retry_timer);
  i = 0;
  goto ldv_54315;
  ldv_54314:
  preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
  ldv_del_timer_sync_801(& preorder_ctrl->reordering_ctrl_timer);
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
  spin_lock_bh(& ppending_recvframe_queue->lock);
  phead = get_list_head(ppending_recvframe_queue);
  plist = phead->next;
  goto ldv_54312;
  ldv_54311:
  __mptr = (struct list_head const *)plist;
  prframe = (struct recv_frame *)__mptr;
  plist = plist->next;
  list_del_init(& prframe->list);
  rtw_free_recvframe23a(prframe);
  ldv_54312:
  tmp = list_empty((struct list_head const *)phead);
  if (tmp == 0) {
    goto ldv_54311;
  } else {
  }
  spin_unlock_bh(& ppending_recvframe_queue->lock);
  i = i + 1;
  ldv_54315: ;
  if (i <= 15) {
    goto ldv_54314;
  } else {
  }
  if ((psta->state & 16U) == 0U) {
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 0);
  } else {
  }
  spin_lock_bh(& pstapriv->auth_list_lock);
  tmp___0 = list_empty((struct list_head const *)(& psta->auth_list));
  if (tmp___0 == 0) {
    list_del_init(& psta->auth_list);
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
  } else {
  }
  spin_unlock_bh(& pstapriv->auth_list_lock);
  psta->expire_to = 0U;
  psta->sleepq_ac_len = 0U;
  psta->qos_info = 0U;
  psta->max_sp_len = 0U;
  psta->uapsd_bk = 0U;
  psta->uapsd_be = 0U;
  psta->uapsd_vi = 0U;
  psta->uapsd_vo = 0U;
  psta->has_legacy_ac = 0U;
  tmp___1 = CHKBIT(psta->aid);
  pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap & ~ ((int )((u16 )tmp___1));
  tmp___2 = CHKBIT(psta->aid);
  pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___2));
  if (psta->aid != 0U && (unsigned long )pstapriv->sta_aid[psta->aid - 1U] == (unsigned long )psta) {
    pstapriv->sta_aid[psta->aid - 1U] = (struct sta_info *)0;
    psta->aid = 0U;
  } else {
  }
  kfree((void const *)psta);
  exit: ;
  return (1);
}
}
void rtw_free_all_stainfo23a(struct rtw_adapter *padapter )
{
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct sta_info *pbcmc_stainfo ;
  struct sta_info *tmp ;
  s32 index ;
  struct list_head const *__mptr ;
  {
  pstapriv = & padapter->stapriv;
  tmp = rtw_get_bcmc_stainfo23a(padapter);
  pbcmc_stainfo = tmp;
  if (pstapriv->asoc_sta_count == 1) {
    return;
  } else {
  }
  spin_lock_bh(& pstapriv->sta_hash_lock);
  index = 0;
  goto ldv_54333;
  ldv_54332:
  phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_54330;
  ldv_54329:
  __mptr = (struct list_head const *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
  if ((unsigned long )pbcmc_stainfo != (unsigned long )psta) {
    rtw_free_stainfo23a(padapter, psta);
  } else {
  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_54330: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54329;
  } else {
  }
  index = index + 1;
  ldv_54333: ;
  if (index <= 31) {
    goto ldv_54332;
  } else {
  }
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return;
}
}
struct sta_info *rtw_get_stainfo23a(struct sta_priv *pstapriv , u8 const *hwaddr )
{
  struct list_head *plist ;
  struct list_head *phead ;
  struct sta_info *psta ;
  u32 index ;
  u8 const *addr ;
  u8 bc_addr[6U] ;
  bool tmp ;
  struct list_head const *__mptr ;
  int tmp___0 ;
  {
  psta = (struct sta_info *)0;
  bc_addr[0] = 255U;
  bc_addr[1] = 255U;
  bc_addr[2] = 255U;
  bc_addr[3] = 255U;
  bc_addr[4] = 255U;
  bc_addr[5] = 255U;
  if ((unsigned long )hwaddr == (unsigned long )((u8 const *)0U)) {
    return ((struct sta_info *)0);
  } else {
  }
  tmp = is_multicast_ether_addr(hwaddr);
  if ((int )tmp) {
    addr = (u8 const *)(& bc_addr);
  } else {
    addr = hwaddr;
  }
  index = wifi_mac_hash(addr);
  spin_lock_bh(& pstapriv->sta_hash_lock);
  phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
  plist = phead->next;
  goto ldv_54349;
  ldv_54348:
  __mptr = (struct list_head const *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
  tmp___0 = memcmp((void const *)(& psta->hwaddr), (void const *)addr, 6UL);
  if (tmp___0 == 0) {
    goto ldv_54347;
  } else {
  }
  psta = (struct sta_info *)0;
  plist = plist->next;
  ldv_54349: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54348;
  } else {
  }
  ldv_54347:
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return (psta);
}
}
int rtw_init_bcmc_stainfo23a(struct rtw_adapter *padapter )
{
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  int res ;
  unsigned char bcast_addr[6U] ;
  {
  pstapriv = & padapter->stapriv;
  res = 1;
  bcast_addr[0] = 255U;
  bcast_addr[1] = 255U;
  bcast_addr[2] = 255U;
  bcast_addr[3] = 255U;
  bcast_addr[4] = 255U;
  bcast_addr[5] = 255U;
  psta = rtw_alloc_stainfo23a(pstapriv, (u8 *)(& bcast_addr), 208U);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 4);
      printk("\016rtw_alloc_stainfo23a fail");
    } else {
    }
    return (res);
  } else {
  }
  psta->mac_id = 1U;
  ptxservq = & psta->sta_xmitpriv.be_q;
  return (1);
}
}
struct sta_info *rtw_get_bcmc_stainfo23a(struct rtw_adapter *padapter )
{
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 bc_addr[6U] ;
  {
  pstapriv = & padapter->stapriv;
  bc_addr[0] = 255U;
  bc_addr[1] = 255U;
  bc_addr[2] = 255U;
  bc_addr[3] = 255U;
  bc_addr[4] = 255U;
  bc_addr[5] = 255U;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& bc_addr));
  return (psta);
}
}
bool rtw_access_ctrl23a(struct rtw_adapter *padapter , u8 *mac_addr )
{
  bool res ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_wlan_acl_node *paclnode ;
  bool match ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  res = 1;
  match = 0;
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  pacl_node_q = & pacl_list->acl_node_q;
  spin_lock_bh(& pacl_node_q->lock);
  phead = get_list_head(pacl_node_q);
  plist = phead->next;
  goto ldv_54380;
  ldv_54379:
  __mptr = (struct list_head const *)plist;
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
  tmp = memcmp((void const *)(& paclnode->addr), (void const *)mac_addr, 6UL);
  if (tmp == 0) {
    if ((unsigned int )paclnode->valid != 0U) {
      match = 1;
      goto ldv_54378;
    } else {
    }
  } else {
  }
  plist = plist->next;
  ldv_54380: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54379;
  } else {
  }
  ldv_54378:
  spin_unlock_bh(& pacl_node_q->lock);
  if (pacl_list->mode == 1) {
    res = (int )match ? 0 : 1;
  } else
  if (pacl_list->mode == 2) {
    res = (int )match != 0;
  } else {
    res = 1;
  }
  return (res);
}
}
void *ldv_kmem_cache_alloc_782(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_788(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_790(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_792(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_793(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_794(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_795(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_796(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_797(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_798(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_del_timer_sync_799(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_800(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_801(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
extern void __init_waitqueue_head(wait_queue_head_t * , char const * , struct lock_class_key * ) ;
extern void mutex_destroy(struct mutex * ) ;
__inline static void init_completion(struct completion *x )
{
  struct lock_class_key __key ;
  {
  x->done = 0U;
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
  return;
}
}
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long ) ;
extern void complete(struct completion * ) ;
void *ldv_kmem_cache_alloc_830(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_838(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_846(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_840(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_836(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_844(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_845(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_841(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_842(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_843(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
extern void tasklet_init(struct tasklet_struct * , void (*)(unsigned long ) , unsigned long ) ;
void rtw23a_sctx_done_err(struct submit_ctx **sctx , int status ) ;
void rtw_sctx_done23a(struct submit_ctx **sctx ) ;
s32 rtw_free_xmitbuf_ext23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) ;
struct xmit_buf *rtw_alloc_xmitbuf23a(struct xmit_priv *pxmitpriv ) ;
void rtw_count_tx_stats23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ,
                           int sz ) ;
s32 rtw_put_snap23a(u8 *data , u16 h_proto ) ;
struct tx_servq *rtw_get_sta_pending23a(struct rtw_adapter *padapter , struct sta_info *psta ,
                                        int up___0 , u8 *ac ) ;
s32 rtw_xmitframe_enqueue23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
struct xmit_frame *rtw_dequeue_xframe23a(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit_i ,
                                         int entry ) ;
s32 rtw_xmit23a_classifier(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
u32 rtw_calculate_wlan_pkt_size_by_attribue23a(struct pkt_attrib *pattrib ) ;
s32 rtw_xmitframe_coalesce23a(struct rtw_adapter *padapter , struct sk_buff *skb ,
                              struct xmit_frame *pxmitframe ) ;
s32 rtw_txframes_pending23a(struct rtw_adapter *padapter ) ;
s32 rtw_txframes_sta_ac_pending23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) ;
void rtw_init_hwxmits23a(struct hw_xmit *phwxmit , int entry ) ;
int _rtw_init_xmit_priv23a(struct xmit_priv *pxmitpriv , struct rtw_adapter *padapter ) ;
void _rtw_free_xmit_priv23a(struct xmit_priv *pxmitpriv ) ;
void rtw_alloc_hwxmits23a(struct rtw_adapter *padapter ) ;
void rtw_free_hwxmits23a(struct rtw_adapter *padapter ) ;
int rtw_xmit23a(struct rtw_adapter *padapter , struct sk_buff *skb ) ;
int xmitframe_enqueue_for_sleeping_sta23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
u8 qos_acm23a(u8 acm_mask , u8 priority ) ;
u32 rtw_get_ff_hwaddr23a(struct xmit_frame *pxmitframe ) ;
void rtw_ack_tx_done23a(struct xmit_priv *pxmitpriv , int status ) ;
int rtw_os_xmit_resource_alloc23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ,
                                  u32 alloc_sz ) ;
void rtw_os_xmit_resource_free23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ) ;
void rtw_os_pkt_complete23a(struct rtw_adapter *padapter , struct sk_buff *pkt ) ;
void rtw_os_xmit_complete23a(struct rtw_adapter *padapter , struct xmit_frame *pxframe ) ;
void rtl8723au_xmit_tasklet(void *priv ) ;
bool rtl8723au_hal_xmit(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
static u8 P802_1H_OUI[3U] = { 0U, 0U, 248U};
static u8 RFC1042_OUI[3U] = { 0U, 0U, 0U};
static void _init_txservq(struct tx_servq *ptxservq )
{
  {
  INIT_LIST_HEAD(& ptxservq->tx_pending);
  _rtw_init_queue23a(& ptxservq->sta_pending);
  ptxservq->qcnt = 0;
  return;
}
}
void _rtw_init_sta_xmit_priv23a(struct sta_xmit_priv *psta_xmitpriv )
{
  struct lock_class_key __key ;
  {
  spinlock_check(& psta_xmitpriv->lock);
  __raw_spin_lock_init(& psta_xmitpriv->lock.ldv_6347.rlock, "&(&psta_xmitpriv->lock)->rlock",
                       & __key);
  _init_txservq(& psta_xmitpriv->be_q);
  _init_txservq(& psta_xmitpriv->bk_q);
  _init_txservq(& psta_xmitpriv->vi_q);
  _init_txservq(& psta_xmitpriv->vo_q);
  INIT_LIST_HEAD(& psta_xmitpriv->legacy_dz);
  INIT_LIST_HEAD(& psta_xmitpriv->apsd);
  return;
}
}
int _rtw_init_xmit_priv23a(struct xmit_priv *pxmitpriv , struct rtw_adapter *padapter )
{
  int i ;
  struct xmit_buf *pxmitbuf ;
  struct xmit_frame *pxframe ;
  int res ;
  u32 max_xmit_extbuf_size ;
  u32 num_xmit_extbuf ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct lock_class_key __key___1 ;
  {
  res = 1;
  max_xmit_extbuf_size = 1536U;
  num_xmit_extbuf = 32U;
  spinlock_check(& pxmitpriv->lock);
  __raw_spin_lock_init(& pxmitpriv->lock.ldv_6347.rlock, "&(&pxmitpriv->lock)->rlock",
                       & __key);
  spinlock_check(& pxmitpriv->lock_sctx);
  __raw_spin_lock_init(& pxmitpriv->lock_sctx.ldv_6347.rlock, "&(&pxmitpriv->lock_sctx)->rlock",
                       & __key___0);
  sema_init(& pxmitpriv->xmit_sema, 0);
  sema_init(& pxmitpriv->terminate_xmitthread_sema, 0);
  pxmitpriv->adapter = padapter;
  _rtw_init_queue23a(& pxmitpriv->be_pending);
  _rtw_init_queue23a(& pxmitpriv->bk_pending);
  _rtw_init_queue23a(& pxmitpriv->vi_pending);
  _rtw_init_queue23a(& pxmitpriv->vo_pending);
  _rtw_init_queue23a(& pxmitpriv->bm_pending);
  _rtw_init_queue23a(& pxmitpriv->free_xmit_queue);
  i = 0;
  goto ldv_51630;
  ldv_51629:
  tmp = kzalloc(176UL, 208U);
  pxframe = (struct xmit_frame *)tmp;
  if ((unsigned long )pxframe == (unsigned long )((struct xmit_frame *)0)) {
    goto ldv_51628;
  } else {
  }
  INIT_LIST_HEAD(& pxframe->list);
  pxframe->padapter = padapter;
  pxframe->frame_tag = 0;
  list_add_tail(& pxframe->list, & pxmitpriv->free_xmit_queue.queue);
  i = i + 1;
  ldv_51630: ;
  if (i <= 255) {
    goto ldv_51629;
  } else {
  }
  ldv_51628:
  pxmitpriv->free_xmitframe_cnt = i;
  pxmitpriv->frag_len = 2346U;
  _rtw_init_queue23a(& pxmitpriv->free_xmitbuf_queue);
  INIT_LIST_HEAD(& pxmitpriv->xmitbuf_list);
  _rtw_init_queue23a(& pxmitpriv->pending_xmitbuf_queue);
  i = 0;
  goto ldv_51633;
  ldv_51632:
  tmp___0 = kzalloc(200UL, 208U);
  pxmitbuf = (struct xmit_buf *)tmp___0;
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    goto fail;
  } else {
  }
  INIT_LIST_HEAD(& pxmitbuf->list);
  INIT_LIST_HEAD(& pxmitbuf->list2);
  pxmitbuf->padapter = padapter;
  res = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf, 2560U);
  if (res == 0) {
    goto fail;
  } else {
  }
  list_add_tail(& pxmitbuf->list, & pxmitpriv->free_xmitbuf_queue.queue);
  list_add_tail(& pxmitbuf->list2, & pxmitpriv->xmitbuf_list);
  i = i + 1;
  ldv_51633: ;
  if (i <= 3) {
    goto ldv_51632;
  } else {
  }
  pxmitpriv->free_xmitbuf_cnt = 4U;
  _rtw_init_queue23a(& pxmitpriv->free_xframe_ext_queue);
  i = 0;
  goto ldv_51637;
  ldv_51636:
  tmp___1 = kzalloc(176UL, 208U);
  pxframe = (struct xmit_frame *)tmp___1;
  if ((unsigned long )pxframe == (unsigned long )((struct xmit_frame *)0)) {
    goto ldv_51635;
  } else {
  }
  INIT_LIST_HEAD(& pxframe->list);
  pxframe->padapter = padapter;
  pxframe->frame_tag = 0;
  pxframe->pkt = (struct sk_buff *)0;
  pxframe->buf_addr = (u8 *)0U;
  pxframe->pxmitbuf = (struct xmit_buf *)0;
  pxframe->ext_tag = 1U;
  list_add_tail(& pxframe->list, & pxmitpriv->free_xframe_ext_queue.queue);
  i = i + 1;
  ldv_51637: ;
  if ((u32 )i < num_xmit_extbuf) {
    goto ldv_51636;
  } else {
  }
  ldv_51635:
  pxmitpriv->free_xframe_ext_cnt = i;
  _rtw_init_queue23a(& pxmitpriv->free_xmit_extbuf_queue);
  INIT_LIST_HEAD(& pxmitpriv->xmitextbuf_list);
  i = 0;
  goto ldv_51640;
  ldv_51639:
  tmp___2 = kzalloc(200UL, 208U);
  pxmitbuf = (struct xmit_buf *)tmp___2;
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    goto fail;
  } else {
  }
  INIT_LIST_HEAD(& pxmitbuf->list);
  INIT_LIST_HEAD(& pxmitbuf->list2);
  pxmitbuf->padapter = padapter;
  res = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf, max_xmit_extbuf_size + 512U);
  if (res == 0) {
    goto exit;
  } else {
  }
  list_add_tail(& pxmitbuf->list, & pxmitpriv->free_xmit_extbuf_queue.queue);
  list_add_tail(& pxmitbuf->list2, & pxmitpriv->xmitextbuf_list);
  i = i + 1;
  ldv_51640: ;
  if ((u32 )i < num_xmit_extbuf) {
    goto ldv_51639;
  } else {
  }
  pxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf;
  rtw_alloc_hwxmits23a(padapter);
  rtw_init_hwxmits23a(pxmitpriv->hwxmits, (int )pxmitpriv->hwxmit_entry);
  i = 0;
  goto ldv_51643;
  ldv_51642:
  pxmitpriv->wmm_para_seq[i] = (u8 )i;
  i = i + 1;
  ldv_51643: ;
  if (i <= 3) {
    goto ldv_51642;
  } else {
  }
  pxmitpriv->txirp_cnt = 1U;
  sema_init(& pxmitpriv->tx_retevt, 0);
  pxmitpriv->beq_cnt = 0;
  pxmitpriv->bkq_cnt = 0;
  pxmitpriv->viq_cnt = 0;
  pxmitpriv->voq_cnt = 0;
  pxmitpriv->ack_tx = 0;
  __mutex_init(& pxmitpriv->ack_tx_mutex, "&pxmitpriv->ack_tx_mutex", & __key___1);
  rtw_sctx_init23a(& pxmitpriv->ack_tx_ops, 0);
  tasklet_init(& padapter->xmitpriv.xmit_tasklet, (void (*)(unsigned long ))(& rtl8723au_xmit_tasklet),
               (unsigned long )padapter);
  exit: ;
  return (res);
  fail: ;
  goto exit;
}
}
void _rtw_free_xmit_priv23a(struct xmit_priv *pxmitpriv )
{
  struct rtw_adapter *padapter ;
  struct xmit_frame *pxframe ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  struct list_head const *__mptr___1 ;
  struct list_head const *__mptr___2 ;
  {
  padapter = pxmitpriv->adapter;
  plist = pxmitpriv->free_xmit_queue.queue.next;
  ptmp = plist->next;
  goto ldv_51658;
  ldv_51657:
  __mptr = (struct list_head const *)plist;
  pxframe = (struct xmit_frame *)__mptr;
  list_del_init(& pxframe->list);
  rtw_os_xmit_complete23a(padapter, pxframe);
  kfree((void const *)pxframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_51658: ;
  if ((unsigned long )(& pxmitpriv->free_xmit_queue.queue) != (unsigned long )plist) {
    goto ldv_51657;
  } else {
  }
  plist = pxmitpriv->xmitbuf_list.next;
  ptmp = plist->next;
  goto ldv_51663;
  ldv_51662:
  __mptr___0 = (struct list_head const *)plist;
  pxmitbuf = (struct xmit_buf *)__mptr___0 + 0xfffffffffffffff0UL;
  list_del_init(& pxmitbuf->list2);
  rtw_os_xmit_resource_free23a(padapter, pxmitbuf);
  kfree((void const *)pxmitbuf);
  plist = ptmp;
  ptmp = plist->next;
  ldv_51663: ;
  if ((unsigned long )(& pxmitpriv->xmitbuf_list) != (unsigned long )plist) {
    goto ldv_51662;
  } else {
  }
  plist = pxmitpriv->free_xframe_ext_queue.queue.next;
  ptmp = plist->next;
  goto ldv_51668;
  ldv_51667:
  __mptr___1 = (struct list_head const *)plist;
  pxframe = (struct xmit_frame *)__mptr___1;
  list_del_init(& pxframe->list);
  rtw_os_xmit_complete23a(padapter, pxframe);
  kfree((void const *)pxframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_51668: ;
  if ((unsigned long )(& pxmitpriv->free_xframe_ext_queue.queue) != (unsigned long )plist) {
    goto ldv_51667;
  } else {
  }
  plist = pxmitpriv->xmitextbuf_list.next;
  ptmp = plist->next;
  goto ldv_51673;
  ldv_51672:
  __mptr___2 = (struct list_head const *)plist;
  pxmitbuf = (struct xmit_buf *)__mptr___2 + 0xfffffffffffffff0UL;
  list_del_init(& pxmitbuf->list2);
  rtw_os_xmit_resource_free23a(padapter, pxmitbuf);
  kfree((void const *)pxmitbuf);
  plist = ptmp;
  ptmp = plist->next;
  ldv_51673: ;
  if ((unsigned long )(& pxmitpriv->xmitextbuf_list) != (unsigned long )plist) {
    goto ldv_51672;
  } else {
  }
  rtw_free_hwxmits23a(padapter);
  mutex_destroy(& pxmitpriv->ack_tx_mutex);
  return;
}
}
static void update_attrib_vcs_info(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  u32 sz ;
  struct pkt_attrib *pattrib ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 HTOpMode ;
  {
  pattrib = & pxmitframe->attrib;
  psta = pattrib->psta;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "update_attrib_vcs_info");
    } else {
    }
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "update_attrib_vcs_info");
    } else {
    }
    return;
  } else {
  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "update_attrib_vcs_info",
             psta->state);
    } else {
    }
    return;
  } else {
  }
  if ((unsigned int )pattrib->nr_frags != 1U) {
    sz = padapter->xmitpriv.frag_len;
  } else {
    sz = pattrib->last_txcmdsz;
  }
  if ((unsigned int )pmlmeext->cur_wireless_mode <= 7U || (unsigned int )padapter->registrypriv.wifi_spec != 0U) {
    if ((u32 )padapter->registrypriv.rts_thresh < sz) {
      pattrib->vcs_mode = 1U;
    } else
    if ((unsigned int )psta->rtsen != 0U) {
      pattrib->vcs_mode = 1U;
    } else
    if ((unsigned int )psta->cts2self != 0U) {
      pattrib->vcs_mode = 2U;
    } else {
      pattrib->vcs_mode = 0U;
    }
  } else {
    ldv_51687: ;
    if (((unsigned int )pmlmeinfo->assoc_AP_vendor == 5U && (unsigned int )pattrib->ampdu_en != 0U) && padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
      pattrib->vcs_mode = 2U;
      goto ldv_51685;
    } else {
    }
    if ((unsigned int )psta->rtsen != 0U || (unsigned int )psta->cts2self != 0U) {
      if ((unsigned int )psta->rtsen != 0U) {
        pattrib->vcs_mode = 1U;
      } else
      if ((unsigned int )psta->cts2self != 0U) {
        pattrib->vcs_mode = 2U;
      } else {
      }
      goto ldv_51685;
    } else {
    }
    if ((unsigned int )pattrib->ht_en != 0U) {
      HTOpMode = pmlmeinfo->HT_protection;
      if (((unsigned int )pmlmeext->cur_bwmode != 0U && ((unsigned int )HTOpMode == 2U || (unsigned int )HTOpMode == 3U)) || ((unsigned int )pmlmeext->cur_bwmode == 0U && (unsigned int )HTOpMode == 3U)) {
        pattrib->vcs_mode = 1U;
        goto ldv_51685;
      } else {
      }
    } else {
    }
    if ((u32 )padapter->registrypriv.rts_thresh < sz) {
      pattrib->vcs_mode = 1U;
      goto ldv_51685;
    } else {
    }
    if ((unsigned int )pattrib->ampdu_en != 0U) {
      pattrib->vcs_mode = 1U;
      goto ldv_51685;
    } else {
    }
    pattrib->vcs_mode = 0U;
    goto ldv_51685;
    goto ldv_51687;
    ldv_51685: ;
  }
  return;
}
}
static void update_attrib_phy_info(struct pkt_attrib *pattrib , struct sta_info *psta )
{
  {
  pattrib->mdata = 0U;
  pattrib->eosp = 0U;
  pattrib->triggered = 0U;
  pattrib->qos_en = (u8 )psta->qos_option;
  pattrib->raid = psta->raid;
  pattrib->ht_en = (u8 )psta->htpriv.ht_option;
  pattrib->bwmode = psta->htpriv.bwmode;
  pattrib->ch_offset = psta->htpriv.ch_offset;
  pattrib->sgi = psta->htpriv.sgi;
  pattrib->ampdu_en = 0U;
  pattrib->retry_ctrl = 0U;
  return;
}
}
u8 qos_acm23a(u8 acm_mask , u8 priority )
{
  u8 change_priority ;
  {
  change_priority = priority;
  switch ((int )priority) {
  case 0: ;
  case 3: ;
  if (((unsigned long )acm_mask & 2UL) != 0UL) {
    change_priority = 1U;
  } else {
  }
  goto ldv_51699;
  case 1: ;
  case 2: ;
  goto ldv_51699;
  case 4: ;
  case 5: ;
  if (((unsigned long )acm_mask & 4UL) != 0UL) {
    change_priority = 0U;
  } else {
  }
  goto ldv_51699;
  case 6: ;
  case 7: ;
  if (((unsigned long )acm_mask & 8UL) != 0UL) {
    change_priority = 5U;
  } else {
  }
  goto ldv_51699;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: qos_acm23a(): invalid pattrib->priority: %d!!!\n", (int )priority);
  } else {
  }
  change_priority = 0U;
  goto ldv_51699;
  }
  ldv_51699: ;
  return (change_priority);
}
}
static void set_qos(struct sk_buff *skb , struct pkt_attrib *pattrib )
{
  u8 *pframe ;
  struct iphdr *ip_hdr___0 ;
  u8 UserPriority ;
  {
  pframe = skb->data;
  UserPriority = 0U;
  if ((unsigned int )pattrib->ether_type == 2048U) {
    ip_hdr___0 = (struct iphdr *)pframe + 14U;
    UserPriority = (u8 )((int )ip_hdr___0->tos >> 5);
  } else
  if ((unsigned int )pattrib->ether_type == 34958U) {
    UserPriority = 7U;
  } else {
  }
  pattrib->priority = UserPriority;
  pattrib->hdrlen = 26U;
  pattrib->type = 136U;
  return;
}
}
static int update_attrib(struct rtw_adapter *padapter , struct sk_buff *skb , struct pkt_attrib *pattrib )
{
  struct sta_info *psta ;
  int bmcast ;
  struct sta_priv *pstapriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  int res ;
  struct ethhdr *ehdr ;
  __u16 tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  u8 *pframe ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  {
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmepriv = & padapter->mlmepriv;
  res = 1;
  ehdr = (struct ethhdr *)skb->data;
  tmp = __fswab16((int )ehdr->h_proto);
  pattrib->ether_type = tmp;
  ether_addr_copy((u8 *)(& pattrib->dst), (u8 const *)(& ehdr->h_dest));
  ether_addr_copy((u8 *)(& pattrib->src), (u8 const *)(& ehdr->h_source));
  pattrib->pctrl = 0U;
  tmp___4 = check_fwstate(pmlmepriv, 32);
  if ((int )tmp___4) {
    ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)(& pattrib->dst));
    ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)(& pattrib->src));
  } else {
    tmp___5 = check_fwstate(pmlmepriv, 64);
    if ((int )tmp___5) {
      ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)(& pattrib->dst));
      ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)(& pattrib->src));
    } else {
      tmp___3 = check_fwstate(pmlmepriv, 8);
      if ((int )tmp___3) {
        tmp___0 = get_bssid(pmlmepriv);
        ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)tmp___0);
        ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)(& pattrib->src));
      } else {
        tmp___2 = check_fwstate(pmlmepriv, 16);
        if ((int )tmp___2) {
          ether_addr_copy((u8 *)(& pattrib->ra), (u8 const *)(& pattrib->dst));
          tmp___1 = get_bssid(pmlmepriv);
          ether_addr_copy((u8 *)(& pattrib->ta), (u8 const *)tmp___1);
        } else {
        }
      }
    }
  }
  pattrib->pktlen = skb->len - 14U;
  if ((unsigned int )pattrib->ether_type == 2048U) {
    pattrib->dhcp_pkt = 0U;
    if (pattrib->pktlen > 306U) {
      if ((unsigned int )pattrib->ether_type == 2048U) {
        pframe = skb->data;
        pframe = pframe + 14UL;
        if (((unsigned int )*(pframe + 21UL) == 68U && (unsigned int )*(pframe + 23UL) == 67U) || ((unsigned int )*(pframe + 21UL) == 67U && (unsigned int )*(pframe + 23UL) == 68U)) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
            printk("\016======================update_attrib: get DHCP Packet\n");
          } else {
          }
          pattrib->dhcp_pkt = 1U;
        } else {
        }
      } else {
      }
    } else {
    }
  } else
  if ((unsigned int )pattrib->ether_type == 34958U) {
    if (GlobalDebugLevel23A != 0U) {
      printk("\016RTL8723AU: OLD_ERROR send eapol packet\n");
    } else {
    }
  } else {
  }
  if ((unsigned int )pattrib->ether_type == 34958U || (unsigned int )pattrib->dhcp_pkt == 1U) {
    rtw_set_scan_deny(padapter, 3000U);
  } else {
  }
  if (((unsigned int )pattrib->ether_type == 2054U || (unsigned int )pattrib->ether_type == 34958U) || (unsigned int )pattrib->dhcp_pkt == 1U) {
    rtw_lps_ctrl_wk_cmd23a(padapter, 4, 1);
  } else {
  }
  tmp___6 = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
  bmcast = (int )tmp___6;
  if (bmcast != 0) {
    psta = rtw_get_bcmc_stainfo23a(padapter);
  } else {
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->ra));
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
      if (GlobalDebugLevel23A > 2U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 3);
        printk("\016\nupdate_attrib => get sta_info fail, ra:%02x:%02x:%02x:%02x:%02x:%02x\n",
               (int )*((u8 *)(& pattrib->ra)), (int )*((u8 *)(& pattrib->ra) + 1UL),
               (int )*((u8 *)(& pattrib->ra) + 2UL), (int )*((u8 *)(& pattrib->ra) + 3UL),
               (int )*((u8 *)(& pattrib->ra) + 4UL), (int )*((u8 *)(& pattrib->ra) + 5UL));
      } else {
      }
      res = 0;
      goto exit;
    } else {
      tmp___7 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___7 && (psta->state & 1U) == 0U) {
        res = 0;
        goto exit;
      } else {
      }
    }
  }
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    pattrib->mac_id = (u8 )psta->mac_id;
    pattrib->psta = psta;
  } else {
    if (GlobalDebugLevel23A > 2U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 3);
      printk("\016\nupdate_attrib => get sta_info fail, ra:%02x:%02x:%02x:%02x:%02x:%02x\n",
             (int )*((u8 *)(& pattrib->ra)), (int )*((u8 *)(& pattrib->ra) + 1UL),
             (int )*((u8 *)(& pattrib->ra) + 2UL), (int )*((u8 *)(& pattrib->ra) + 3UL),
             (int )*((u8 *)(& pattrib->ra) + 4UL), (int )*((u8 *)(& pattrib->ra) + 5UL));
    } else {
    }
    res = 0;
    goto exit;
  }
  pattrib->ack_policy = 0U;
  pattrib->pkt_hdrlen = 14U;
  pattrib->hdrlen = 24U;
  pattrib->type = 8U;
  pattrib->priority = 0U;
  tmp___8 = check_fwstate(pmlmepriv, 112);
  if ((int )tmp___8) {
    if (psta->qos_option != 0U) {
      set_qos(skb, pattrib);
    } else {
    }
  } else
  if (pmlmepriv->qos_option != 0U) {
    set_qos(skb, pattrib);
    if ((unsigned int )pmlmepriv->acm_mask != 0U) {
      pattrib->priority = qos_acm23a((int )pmlmepriv->acm_mask, (int )pattrib->priority);
    } else {
    }
  } else {
  }
  if (psta->ieee8021x_blocked == 1U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016\n psta->ieee8021x_blocked == true\n");
    } else {
    }
    pattrib->encrypt = 0U;
    if ((unsigned int )pattrib->ether_type != 34958U) {
      tmp___9 = check_fwstate(pmlmepriv, 65536);
      if (tmp___9) {
        tmp___10 = 0;
      } else {
        tmp___10 = 1;
      }
      if (tmp___10) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
          printk("\016\npsta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n",
                 (int )pattrib->ether_type);
        } else {
        }
        res = 0;
        goto exit;
      } else {
      }
    } else {
    }
  } else {
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U:
    pattrib->encrypt = psecuritypriv->dot11PrivacyAlgrthm;
    goto ldv_51731;
    case 2U: ;
    if (bmcast != 0) {
      pattrib->encrypt = psecuritypriv->dot118021XGrpPrivacy;
    } else {
      pattrib->encrypt = psta->dot118021XPrivacy;
    }
    goto ldv_51731;
    }
    ldv_51731: ;
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U:
    pattrib->key_idx = (unsigned char )psecuritypriv->dot11PrivacyKeyIndex;
    goto ldv_51736;
    case 2U: ;
    if (bmcast != 0) {
      pattrib->key_idx = (unsigned char )psecuritypriv->dot118021XGrpKeyid;
    } else {
      pattrib->key_idx = 0U;
    }
    goto ldv_51736;
    default:
    pattrib->key_idx = 0U;
    goto ldv_51736;
    }
    ldv_51736: ;
  }
  switch (pattrib->encrypt) {
  case 1027073U: ;
  case 1027077U:
  pattrib->iv_len = 4U;
  pattrib->icv_len = 4U;
  goto ldv_51741;
  case 1027074U:
  pattrib->iv_len = 8U;
  pattrib->icv_len = 4U;
  if ((unsigned int )*((unsigned char *)padapter + 11436UL) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016\npadapter->securitypriv.busetkipkey(%d) == false drop packet\n",
             (int )padapter->securitypriv.busetkipkey);
    } else {
    }
    res = 0;
    goto exit;
  } else {
  }
  goto ldv_51741;
  case 1027076U: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016pattrib->encrypt =%d (WLAN_CIPHER_SUITE_CCMP)\n", pattrib->encrypt);
  } else {
  }
  pattrib->iv_len = 8U;
  pattrib->icv_len = 8U;
  goto ldv_51741;
  default:
  pattrib->iv_len = 0U;
  pattrib->icv_len = 0U;
  goto ldv_51741;
  }
  ldv_51741: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016update_attrib: encrypt =%d\n", pattrib->encrypt);
  } else {
  }
  if (pattrib->encrypt != 0U && (unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
    pattrib->bswenc = 1U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016update_attrib: encrypt =%d bswenc = true\n", pattrib->encrypt);
    } else {
    }
  } else {
    pattrib->bswenc = 0U;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
      printk("\016update_attrib: bswenc = false\n");
    } else {
    }
  }
  update_attrib_phy_info(pattrib, psta);
  exit: ;
  return (res);
}
}
static int xmitframe_addmic(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  struct mic_data micdata ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int curfragnum ;
  int length ;
  u8 *pframe ;
  u8 *payload ;
  u8 mic[8U] ;
  u8 priority[4U] ;
  u8 hw_hdr_offset ;
  int bmcst ;
  bool tmp ;
  u8 null_key[16U] ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  {
  pattrib = & pxmitframe->attrib;
  psecuritypriv = & padapter->securitypriv;
  pxmitpriv = & padapter->xmitpriv;
  priority[0] = 0U;
  priority[1] = 0U;
  priority[2] = 0U;
  priority[3] = 0U;
  hw_hdr_offset = 0U;
  tmp = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
  bmcst = (int )tmp;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    stainfo = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "xmitframe_addmic");
    } else {
    }
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pattrib->ra));
  }
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "xmitframe_addmic");
    } else {
    }
    return (0);
  } else {
  }
  if ((stainfo->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "xmitframe_addmic",
             stainfo->state);
    } else {
    }
    return (0);
  } else {
  }
  hw_hdr_offset = 40U;
  if (pattrib->encrypt == 1027074U) {
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
      null_key[0] = 0U;
      null_key[1] = 0U;
      null_key[2] = 0U;
      null_key[3] = 0U;
      null_key[4] = 0U;
      null_key[5] = 0U;
      null_key[6] = 0U;
      null_key[7] = 0U;
      null_key[8] = 0U;
      null_key[9] = 0U;
      null_key[10] = 0U;
      null_key[11] = 0U;
      null_key[12] = 0U;
      null_key[13] = 0U;
      null_key[14] = 0U;
      null_key[15] = 0U;
      pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
      if (bmcst != 0) {
        tmp___0 = memcmp((void const *)(& psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey),
                         (void const *)(& null_key), 16UL);
        if (tmp___0 == 0) {
          return (0);
        } else {
        }
        rtw_secmicsetkey23a(& micdata, (u8 *)(& psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey));
      } else {
        tmp___1 = memcmp((void const *)(& stainfo->dot11tkiptxmickey.skey), (void const *)(& null_key),
                         16UL);
        if (tmp___1 == 0) {
          return (0);
        } else {
        }
        rtw_secmicsetkey23a(& micdata, (u8 *)(& stainfo->dot11tkiptxmickey.skey));
      }
      if ((int )*(pframe + 1UL) & 1) {
        rtw_secmicappend23a(& micdata, pframe + 16UL, 6U);
        if (((int )*(pframe + 1UL) & 2) != 0) {
          rtw_secmicappend23a(& micdata, pframe + 24UL, 6U);
        } else {
          rtw_secmicappend23a(& micdata, pframe + 10UL, 6U);
        }
      } else {
        rtw_secmicappend23a(& micdata, pframe + 4UL, 6U);
        if (((int )*(pframe + 1UL) & 2) != 0) {
          rtw_secmicappend23a(& micdata, pframe + 16UL, 6U);
        } else {
          rtw_secmicappend23a(& micdata, pframe + 10UL, 6U);
        }
      }
      if ((unsigned int )pattrib->qos_en != 0U) {
        priority[0] = pxmitframe->attrib.priority;
      } else {
      }
      rtw_secmicappend23a(& micdata, (u8 *)(& priority), 4U);
      payload = pframe;
      curfragnum = 0;
      goto ldv_51765;
      ldv_51764:
      payload = (u8 *)(((unsigned long )payload + 3UL) & 0xfffffffffffffffcUL);
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
        printk("\016=== curfragnum =%d, pframe = 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
               curfragnum, (int )*payload, (int )*(payload + 1UL), (int )*(payload + 2UL),
               (int )*(payload + 3UL), (int )*(payload + 4UL), (int )*(payload + 5UL),
               (int )*(payload + 6UL), (int )*(payload + 7UL));
      } else {
      }
      payload = payload + ((unsigned long )pattrib->hdrlen + (unsigned long )pattrib->iv_len);
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
        printk("\016curfragnum =%d pattrib->hdrlen =%d pattrib->iv_len =%d", curfragnum,
               (int )pattrib->hdrlen, (int )pattrib->iv_len);
      } else {
      }
      if (curfragnum + 1 == (int )pattrib->nr_frags) {
        length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - ((unsigned int )pattrib->bswenc != 0U ? (u32 )pattrib->icv_len : 0U));
        rtw_secmicappend23a(& micdata, payload, (u32 )length);
        payload = payload + (unsigned long )length;
      } else {
        length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - ((unsigned int )pattrib->bswenc != 0U ? (uint )pattrib->icv_len : 0U));
        rtw_secmicappend23a(& micdata, payload, (u32 )length);
        payload = payload + ((unsigned long )length + (unsigned long )pattrib->icv_len);
        if (GlobalDebugLevel23A > 3U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
          printk("\016curfragnum =%d length =%d pattrib->icv_len =%d", curfragnum,
                 length, (int )pattrib->icv_len);
        } else {
        }
      }
      curfragnum = curfragnum + 1;
      ldv_51765: ;
      if ((int )pattrib->nr_frags > curfragnum) {
        goto ldv_51764;
      } else {
      }
      rtw_secgetmic23a(& micdata, (u8 *)(& mic));
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
        printk("\016xmitframe_addmic: before add mic code!!\n");
      } else {
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
        printk("\016xmitframe_addmic: pattrib->last_txcmdsz =%d!!!\n", pattrib->last_txcmdsz);
      } else {
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
        printk("\016xmitframe_addmic: mic[0]= 0x%.2x , mic[1]=0x%.2x , mic[2]= 0x%.2x , mic[3]= 0x%.2x\nmic[4]= 0x%.2x , mic[5]= 0x%.2x , mic[6]= 0x%.2x , mic[7]= 0x%.2x !!!!\n",
               (int )mic[0], (int )mic[1], (int )mic[2], (int )mic[3], (int )mic[4],
               (int )mic[5], (int )mic[6], (int )mic[7]);
      } else {
      }
      __len = 8UL;
      if (__len > 63UL) {
        __ret = memcpy((void *)payload, (void const *)(& mic), __len);
      } else {
        __ret = memcpy((void *)payload, (void const *)(& mic), __len);
      }
      pattrib->last_txcmdsz = pattrib->last_txcmdsz + 8U;
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
        printk("\016\n ======== last pkt ========\n");
      } else {
      }
      payload = payload + (8UL - (unsigned long )pattrib->last_txcmdsz);
      curfragnum = 0;
      goto ldv_51771;
      ldv_51770: ;
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
        printk("\016 %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x ", (int )*(payload + (unsigned long )curfragnum),
               (int )*(payload + ((unsigned long )curfragnum + 1UL)), (int )*(payload + ((unsigned long )curfragnum + 2UL)),
               (int )*(payload + ((unsigned long )curfragnum + 3UL)), (int )*(payload + ((unsigned long )curfragnum + 4UL)),
               (int )*(payload + ((unsigned long )curfragnum + 5UL)), (int )*(payload + ((unsigned long )curfragnum + 6UL)),
               (int )*(payload + ((unsigned long )curfragnum + 7UL)));
      } else {
      }
      curfragnum = curfragnum + 8;
      ldv_51771: ;
      if ((u32 )curfragnum < pattrib->last_txcmdsz) {
        goto ldv_51770;
      } else {
      }
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016xmitframe_addmic: rtw_get_stainfo23a ==NULL!!!\n");
    } else {
    }
  } else {
  }
  return (1);
}
}
static int xmitframe_swencrypt(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  struct pkt_attrib *pattrib ;
  {
  pattrib = & pxmitframe->attrib;
  if ((unsigned int )pattrib->bswenc != 0U) {
    if (GlobalDebugLevel23A > 2U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 3);
      printk("\016### xmitframe_swencrypt\n");
    } else {
    }
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U:
    rtw_wep_encrypt23a(padapter, pxmitframe);
    goto ldv_51780;
    case 1027074U:
    rtw_tkip_encrypt23a(padapter, pxmitframe);
    goto ldv_51780;
    case 1027076U:
    rtw_aes_encrypt23a(padapter, pxmitframe);
    goto ldv_51780;
    default: ;
    goto ldv_51780;
    }
    ldv_51780: ;
  } else
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 6);
    printk("\016### xmitframe_hwencrypt\n");
  } else {
  }
  return (1);
}
}
static int rtw_make_wlanhdr(struct rtw_adapter *padapter , u8 *hdr , struct pkt_attrib *pattrib )
{
  struct ieee80211_hdr *pwlanhdr ;
  struct ieee80211_qos_hdr *qoshdr ;
  struct mlme_priv *pmlmepriv ;
  u8 qos_option ;
  int res ;
  struct sta_info *psta ;
  int bmcst ;
  bool tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  u16 tx_seq ;
  {
  pwlanhdr = (struct ieee80211_hdr *)hdr;
  pmlmepriv = & padapter->mlmepriv;
  qos_option = 0U;
  res = 1;
  tmp = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
  bmcst = (int )tmp;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_make_wlanhdr");
    } else {
    }
    if (bmcst != 0) {
      psta = rtw_get_bcmc_stainfo23a(padapter);
    } else {
      psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pattrib->ra));
    }
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_make_wlanhdr");
    } else {
    }
    return (0);
  } else {
  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_make_wlanhdr",
             psta->state);
    } else {
    }
    return (0);
  } else {
  }
  memset((void *)hdr, 0, 64UL);
  pwlanhdr->frame_control = pattrib->type;
  if (((int )pattrib->type & 8) != 0) {
    tmp___7 = check_fwstate(pmlmepriv, 8);
    if ((int )tmp___7) {
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
      tmp___0 = get_bssid(pmlmepriv);
      ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)tmp___0);
      ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)(& pattrib->src));
      ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)(& pattrib->dst));
      if (pmlmepriv->qos_option != 0U) {
        qos_option = 1U;
      } else {
      }
    } else {
      tmp___6 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___6) {
        pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
        ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)(& pattrib->dst));
        tmp___1 = get_bssid(pmlmepriv);
        ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)tmp___1);
        ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)(& pattrib->src));
        if (psta->qos_option != 0U) {
          qos_option = 1U;
        } else {
        }
      } else {
        tmp___4 = check_fwstate(pmlmepriv, 32);
        if ((int )tmp___4) {
          goto _L;
        } else {
          tmp___5 = check_fwstate(pmlmepriv, 64);
          if ((int )tmp___5) {
            _L:
            ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)(& pattrib->dst));
            ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)(& pattrib->src));
            tmp___2 = get_bssid(pmlmepriv);
            ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___2);
            if (psta->qos_option != 0U) {
              qos_option = 1U;
            } else {
            }
          } else {
            if (GlobalDebugLevel23A > 3U) {
              printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
              tmp___3 = get_fwstate(pmlmepriv);
              printk("\016fw_state:%x is not allowed to xmit frame\n", tmp___3);
            } else {
            }
            res = 0;
            goto exit;
          }
        }
      }
    }
    if ((unsigned int )pattrib->mdata != 0U) {
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 8192U);
    } else {
    }
    if (pattrib->encrypt != 0U) {
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 16384U);
    } else {
    }
    if ((unsigned int )qos_option != 0U) {
      qoshdr = (struct ieee80211_qos_hdr *)hdr;
      qoshdr->qos_ctrl = (unsigned int )((unsigned short )pattrib->priority) & 15U;
      qoshdr->qos_ctrl = (__le16 )((int )((short )qoshdr->qos_ctrl) | ((int )((short )((int )pattrib->ack_policy << 5)) & 96));
      if ((unsigned int )pattrib->eosp != 0U) {
        qoshdr->qos_ctrl = (__le16 )((unsigned int )qoshdr->qos_ctrl | 16U);
      } else {
      }
    } else {
    }
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] = (u16 )((int )psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] + 1);
      psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] = (unsigned int )psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] & 4095U;
      pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority];
      pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pattrib->seqnum << 4)) & 65520U;
      if ((unsigned int )pattrib->ht_en != 0U && psta->htpriv.ampdu_enable != 0U) {
        if ((unsigned int )pattrib->priority > 15U) {
          printk("\f%s: Invalid pattrib->priority %i\n", "rtw_make_wlanhdr", (int )pattrib->priority);
        } else {
        }
        if ((int )((unsigned long )psta->htpriv.agg_enable_bitmap >> (int )pattrib->priority) & 1) {
          pattrib->ampdu_en = 1U;
        } else {
        }
      } else {
      }
      if ((unsigned int )pattrib->ampdu_en != 0U) {
        tx_seq = psta->BA_starting_seqctrl[(int )pattrib->priority & 15];
        if ((((int )pattrib->seqnum - (int )tx_seq) & 2048) != 0) {
          pattrib->ampdu_en = 0U;
        } else
        if ((int )pattrib->seqnum == (int )tx_seq) {
          psta->BA_starting_seqctrl[(int )pattrib->priority & 15] = (unsigned int )((u16 )((unsigned int )tx_seq + 1U)) & 4095U;
          pattrib->ampdu_en = 1U;
        } else {
          psta->BA_starting_seqctrl[(int )pattrib->priority & 15] = (unsigned int )((u16 )((unsigned int )pattrib->seqnum + 1U)) & 4095U;
          pattrib->ampdu_en = 1U;
        }
      } else {
      }
    } else {
    }
  } else {
  }
  exit: ;
  return (res);
}
}
s32 rtw_txframes_pending23a(struct rtw_adapter *padapter )
{
  struct xmit_priv *pxmitpriv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  tmp = list_empty((struct list_head const *)(& pxmitpriv->be_pending.queue));
  if (tmp == 0) {
    tmp___3 = 1;
  } else {
    tmp___0 = list_empty((struct list_head const *)(& pxmitpriv->bk_pending.queue));
    if (tmp___0 == 0) {
      tmp___3 = 1;
    } else {
      tmp___1 = list_empty((struct list_head const *)(& pxmitpriv->vi_pending.queue));
      if (tmp___1 == 0) {
        tmp___3 = 1;
      } else {
        tmp___2 = list_empty((struct list_head const *)(& pxmitpriv->vo_pending.queue));
        if (tmp___2 == 0) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      }
    }
  }
  return (tmp___3);
}
}
s32 rtw_txframes_sta_ac_pending23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib )
{
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  int priority ;
  {
  priority = (int )pattrib->priority;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_txframes_sta_ac_pending23a");
    } else {
    }
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_txframes_sta_ac_pending23a");
    } else {
    }
    return (0);
  } else {
  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_txframes_sta_ac_pending23a",
             psta->state);
    } else {
    }
    return (0);
  } else {
  }
  switch (priority) {
  case 1: ;
  case 2:
  ptxservq = & psta->sta_xmitpriv.bk_q;
  goto ldv_51813;
  case 4: ;
  case 5:
  ptxservq = & psta->sta_xmitpriv.vi_q;
  goto ldv_51813;
  case 6: ;
  case 7:
  ptxservq = & psta->sta_xmitpriv.vo_q;
  goto ldv_51813;
  case 0: ;
  case 3: ;
  default:
  ptxservq = & psta->sta_xmitpriv.be_q;
  goto ldv_51813;
  }
  ldv_51813: ;
  return (ptxservq->qcnt);
}
}
u32 rtw_calculate_wlan_pkt_size_by_attribue23a(struct pkt_attrib *pattrib )
{
  u32 len ;
  {
  len = 0U;
  len = (u32 )((int )pattrib->hdrlen + (int )pattrib->iv_len);
  len = len + 8U;
  len = pattrib->pktlen + len;
  if (pattrib->encrypt == 1027074U) {
    len = len + 8U;
  } else {
  }
  len = ((unsigned int )pattrib->bswenc != 0U ? (u32 )pattrib->icv_len : 0U) + len;
  return (len);
}
}
s32 rtw_xmitframe_coalesce23a(struct rtw_adapter *padapter , struct sk_buff *skb ,
                              struct xmit_frame *pxmitframe )
{
  struct sta_info *psta ;
  struct xmit_priv *pxmitpriv ;
  struct pkt_attrib *pattrib ;
  struct ieee80211_hdr *hdr ;
  s32 frg_inx ;
  s32 frg_len ;
  s32 mpdu_len ;
  s32 llc_sz ;
  s32 mem_sz ;
  u8 *pframe ;
  u8 *mem_start ;
  u8 hw_hdr_offset ;
  u8 *pbuf_start ;
  u8 *pdata ;
  int data_len ;
  s32 bmcst ;
  bool tmp ;
  int res ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  s32 __min1 ;
  s32 __min2 ;
  s32 __min1___0 ;
  s32 __min2___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  int tmp___1 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pattrib = & pxmitframe->attrib;
  pdata = skb->data;
  data_len = (int )skb->len;
  tmp = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
  bmcst = (s32 )tmp;
  res = 1;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_xmitframe_coalesce23a");
    } else {
    }
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_xmitframe_coalesce23a");
    } else {
    }
    return (0);
  } else {
  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_xmitframe_coalesce23a",
             psta->state);
    } else {
    }
    return (0);
  } else {
  }
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ==> %s buf_addr == NULL\n", "rtw_xmitframe_coalesce23a");
    } else {
    }
    return (0);
  } else {
  }
  pbuf_start = pxmitframe->buf_addr;
  hw_hdr_offset = 40U;
  mem_start = pbuf_start + (unsigned long )hw_hdr_offset;
  tmp___0 = rtw_make_wlanhdr(padapter, mem_start, pattrib);
  if (tmp___0 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016%s: rtw_make_wlanhdr fail; drop pkt\n", "rtw_xmitframe_coalesce23a");
    } else {
    }
    res = 0;
    goto exit;
  } else {
  }
  pdata = pdata + (unsigned long )pattrib->pkt_hdrlen;
  data_len = data_len - (int )pattrib->pkt_hdrlen;
  frg_inx = 0;
  frg_len = (s32 )(pxmitpriv->frag_len - 4U);
  ldv_51873:
  llc_sz = 0;
  mpdu_len = frg_len;
  pframe = mem_start;
  hdr = (struct ieee80211_hdr *)mem_start;
  pframe = pframe + (unsigned long )pattrib->hdrlen;
  mpdu_len = mpdu_len - (int )pattrib->hdrlen;
  if ((unsigned int )pattrib->iv_len != 0U) {
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      switch (pattrib->encrypt) {
      case 1027073U: ;
      case 1027077U:
      pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
      pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
      pattrib->iv[2] = psta->dot11txpn._byte_.TSC2;
      pattrib->iv[3] = (u8 )((int )pattrib->key_idx << 6);
      psta->dot11txpn.val = psta->dot11txpn.val != 16777215ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      goto ldv_51851;
      case 1027074U: ;
      if (bmcst != 0) {
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC1;
        pattrib->iv[1] = ((unsigned int )psta->dot11txpn._byte_.TSC1 & 95U) | 32U;
        pattrib->iv[2] = psta->dot11txpn._byte_.TSC0;
        pattrib->iv[3] = (u8 )((int )((signed char )((int )pattrib->key_idx << 6)) | 32);
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      } else {
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC1;
        pattrib->iv[1] = ((unsigned int )psta->dot11txpn._byte_.TSC1 & 95U) | 32U;
        pattrib->iv[2] = psta->dot11txpn._byte_.TSC0;
        pattrib->iv[3] = 32U;
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      }
      goto ldv_51851;
      case 1027076U: ;
      if (bmcst != 0) {
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
        pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
        pattrib->iv[2] = 0U;
        pattrib->iv[3] = (u8 )((int )((signed char )((int )pattrib->key_idx << 6)) | 32);
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      } else {
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
        pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
        pattrib->iv[2] = 0U;
        pattrib->iv[3] = 32U;
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      }
      goto ldv_51851;
      }
      ldv_51851: ;
    } else {
    }
    __len = (size_t )pattrib->iv_len;
    __ret = memcpy((void *)pframe, (void const *)(& pattrib->iv), __len);
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 6);
      printk("\016rtw_xmiaframe_coalesce23a: keyid =%d pattrib->iv[3]=%.2x pframe =%.2x %.2x %.2x %.2x\n",
             padapter->securitypriv.dot11PrivacyKeyIndex, (int )pattrib->iv[3], (int )*pframe,
             (int )*(pframe + 1UL), (int )*(pframe + 2UL), (int )*(pframe + 3UL));
    } else {
    }
    pframe = pframe + (unsigned long )pattrib->iv_len;
    mpdu_len = mpdu_len - (int )pattrib->iv_len;
  } else {
  }
  if (frg_inx == 0) {
    llc_sz = rtw_put_snap23a(pframe, (int )pattrib->ether_type);
    pframe = pframe + (unsigned long )llc_sz;
    mpdu_len = mpdu_len - llc_sz;
  } else {
  }
  if ((unsigned int )pattrib->icv_len != 0U && (unsigned int )pattrib->bswenc != 0U) {
    mpdu_len = mpdu_len - (int )pattrib->icv_len;
  } else {
  }
  if (bmcst != 0) {
    __min1 = data_len;
    __min2 = (s32 )pattrib->pktlen;
    mem_sz = __min1 < __min2 ? __min1 : __min2;
  } else {
    __min1___0 = data_len;
    __min2___0 = mpdu_len;
    mem_sz = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
  }
  __len___0 = (size_t )mem_sz;
  __ret___0 = memcpy((void *)pframe, (void const *)pdata, __len___0);
  pframe = pframe + (unsigned long )mem_sz;
  pdata = pdata + (unsigned long )mem_sz;
  data_len = data_len - mem_sz;
  if ((unsigned int )pattrib->icv_len != 0U && (unsigned int )pattrib->bswenc != 0U) {
    __len___1 = (size_t )pattrib->icv_len;
    __ret___1 = memcpy((void *)pframe, (void const *)(& pattrib->icv),
                                 __len___1);
    pframe = pframe + (unsigned long )pattrib->icv_len;
  } else {
  }
  frg_inx = frg_inx + 1;
  if (bmcst != 0 || data_len <= 0) {
    pattrib->nr_frags = (u8 )frg_inx;
    pattrib->last_txcmdsz = (u32 )(((((int )pattrib->hdrlen + (int )pattrib->iv_len) + ((unsigned int )pattrib->nr_frags == 1U ? llc_sz : 0)) + ((unsigned int )pattrib->bswenc != 0U ? (int )pattrib->icv_len : 0)) + mem_sz);
    hdr->frame_control = (unsigned int )hdr->frame_control & 64511U;
    goto ldv_51869;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
    printk("\016%s: There\'re still something in packet!\n", "rtw_xmitframe_coalesce23a");
  } else {
  }
  hdr->frame_control = (__le16 )((unsigned int )hdr->frame_control | 1024U);
  mem_start = (u8 *)((unsigned long )hw_hdr_offset + (((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL));
  __len___2 = (size_t )pattrib->hdrlen;
  __ret___2 = memcpy((void *)mem_start, (void const *)pbuf_start + (unsigned long )hw_hdr_offset,
                               __len___2);
  goto ldv_51873;
  ldv_51869:
  tmp___1 = xmitframe_addmic(padapter, pxmitframe);
  if (tmp___1 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");
    } else {
    }
    res = 0;
    goto exit;
  } else {
  }
  xmitframe_swencrypt(padapter, pxmitframe);
  if (bmcst == 0) {
    update_attrib_vcs_info(padapter, pxmitframe);
  } else {
    pattrib->vcs_mode = 0U;
  }
  exit: ;
  return (res);
}
}
s32 rtw_put_snap23a(u8 *data , u16 h_proto )
{
  struct ieee80211_snap_hdr *snap ;
  u8 *oui ;
  __u16 tmp ;
  {
  snap = (struct ieee80211_snap_hdr *)data;
  snap->dsap = 170U;
  snap->ssap = 170U;
  snap->ctrl = 3U;
  if ((unsigned int )h_proto == 33079U || (unsigned int )h_proto == 33011U) {
    oui = (u8 *)(& P802_1H_OUI);
  } else {
    oui = (u8 *)(& RFC1042_OUI);
  }
  snap->oui[0] = *oui;
  snap->oui[1] = *(oui + 1UL);
  snap->oui[2] = *(oui + 2UL);
  tmp = __fswab16((int )h_proto);
  *((u16 *)data + 6U) = tmp;
  return (8);
}
}
void rtw_update_protection23a(struct rtw_adapter *padapter , u8 *ie , uint ie_len )
{
  struct xmit_priv *pxmitpriv ;
  struct registry_priv *pregistrypriv ;
  uint protection ;
  u8 const *p ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pregistrypriv = & padapter->registrypriv;
  switch ((int )pxmitpriv->vcs_setting) {
  case 0:
  pxmitpriv->vcs = 0U;
  goto ldv_51890;
  case 1: ;
  goto ldv_51890;
  case 2: ;
  default:
  p = cfg80211_find_ie(42, (u8 const *)ie, (int )ie_len);
  if ((unsigned long )p == (unsigned long )((u8 const *)0U)) {
    pxmitpriv->vcs = 0U;
  } else {
    protection = (uint )*(p + 2UL) & 2U;
    if (protection != 0U) {
      if ((unsigned int )pregistrypriv->vcs_type == 1U) {
        pxmitpriv->vcs = 1U;
      } else {
        pxmitpriv->vcs = 2U;
      }
    } else {
      pxmitpriv->vcs = 0U;
    }
  }
  goto ldv_51890;
  }
  ldv_51890: ;
  return;
}
}
void rtw_count_tx_stats23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ,
                           int sz )
{
  struct sta_info *psta ;
  struct stainfo_stats *pstats ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  {
  psta = (struct sta_info *)0;
  pstats = (struct stainfo_stats *)0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  if ((pxmitframe->frame_tag & 15) == 1) {
    pxmitpriv->tx_bytes = pxmitpriv->tx_bytes + (u64 )sz;
    pmlmepriv->LinkDetectInfo.NumTxOkInPeriod = pmlmepriv->LinkDetectInfo.NumTxOkInPeriod + 1U;
    psta = pxmitframe->attrib.psta;
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      pstats = & psta->sta_stats;
      pstats->tx_pkts = pstats->tx_pkts + 1ULL;
      pstats->tx_bytes = pstats->tx_bytes + (u64 )sz;
    } else {
    }
  } else {
  }
  return;
}
}
struct xmit_buf *rtw_alloc_xmitbuf23a_ext(struct xmit_priv *pxmitpriv )
{
  unsigned long irqL ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *phead ;
  struct rtw_queue *pfree_queue ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  pxmitbuf = (struct xmit_buf *)0;
  pfree_queue = & pxmitpriv->free_xmit_extbuf_queue;
  ldv_spin_lock();
  phead = get_list_head(pfree_queue);
  tmp = list_empty((struct list_head const *)phead);
  if (tmp == 0) {
    __mptr = (struct list_head const *)phead->next;
    pxmitbuf = (struct xmit_buf *)__mptr;
    list_del_init(& pxmitbuf->list);
    pxmitpriv->free_xmit_extbuf_cnt = pxmitpriv->free_xmit_extbuf_cnt - 1U;
    pxmitbuf->priv_data = (void *)0;
    pxmitbuf->ext_tag = 1U;
    if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_alloc_xmitbuf23a_ext");
      } else {
      }
      rtw23a_sctx_done_err(& pxmitbuf->sctx, 3);
    } else {
    }
  } else {
  }
  spin_unlock_irqrestore(& pfree_queue->lock, irqL);
  return (pxmitbuf);
}
}
s32 rtw_free_xmitbuf_ext23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf )
{
  unsigned long irqL ;
  struct rtw_queue *pfree_queue ;
  struct list_head *tmp ;
  {
  pfree_queue = & pxmitpriv->free_xmit_extbuf_queue;
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    return (0);
  } else {
  }
  ldv_spin_lock();
  list_del_init(& pxmitbuf->list);
  tmp = get_list_head(pfree_queue);
  list_add_tail(& pxmitbuf->list, tmp);
  pxmitpriv->free_xmit_extbuf_cnt = pxmitpriv->free_xmit_extbuf_cnt + 1U;
  spin_unlock_irqrestore(& pfree_queue->lock, irqL);
  return (1);
}
}
struct xmit_buf *rtw_alloc_xmitbuf23a(struct xmit_priv *pxmitpriv )
{
  unsigned long irqL ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *phead ;
  struct rtw_queue *pfree_xmitbuf_queue ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  pxmitbuf = (struct xmit_buf *)0;
  pfree_xmitbuf_queue = & pxmitpriv->free_xmitbuf_queue;
  ldv_spin_lock();
  phead = get_list_head(pfree_xmitbuf_queue);
  tmp = list_empty((struct list_head const *)phead);
  if (tmp == 0) {
    __mptr = (struct list_head const *)phead->next;
    pxmitbuf = (struct xmit_buf *)__mptr;
    list_del_init(& pxmitbuf->list);
    pxmitpriv->free_xmitbuf_cnt = pxmitpriv->free_xmitbuf_cnt - 1U;
    pxmitbuf->priv_data = (void *)0;
    pxmitbuf->ext_tag = 0U;
    pxmitbuf->flags = 0U;
    if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_alloc_xmitbuf23a");
      } else {
      }
      rtw23a_sctx_done_err(& pxmitbuf->sctx, 3);
    } else {
    }
  } else {
  }
  spin_unlock_irqrestore(& pfree_xmitbuf_queue->lock, irqL);
  return (pxmitbuf);
}
}
s32 rtw_free_xmitbuf23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf )
{
  unsigned long irqL ;
  struct rtw_queue *pfree_xmitbuf_queue ;
  struct list_head *tmp ;
  {
  pfree_xmitbuf_queue = & pxmitpriv->free_xmitbuf_queue;
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    return (0);
  } else {
  }
  if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_free_xmitbuf23a");
    } else {
    }
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 4);
  } else {
  }
  if ((unsigned int )pxmitbuf->ext_tag != 0U) {
    rtw_free_xmitbuf_ext23a(pxmitpriv, pxmitbuf);
  } else {
    ldv_spin_lock();
    list_del_init(& pxmitbuf->list);
    tmp = get_list_head(pfree_xmitbuf_queue);
    list_add_tail(& pxmitbuf->list, tmp);
    pxmitpriv->free_xmitbuf_cnt = pxmitpriv->free_xmitbuf_cnt + 1U;
    spin_unlock_irqrestore(& pfree_xmitbuf_queue->lock, irqL);
  }
  return (1);
}
}
static void rtw_init_xmitframe(struct xmit_frame *pxframe )
{
  {
  if ((unsigned long )pxframe != (unsigned long )((struct xmit_frame *)0)) {
    pxframe->buf_addr = (u8 *)0U;
    pxframe->pxmitbuf = (struct xmit_buf *)0;
    memset((void *)(& pxframe->attrib), 0, 112UL);
    pxframe->frame_tag = 1;
    pxframe->pkt = (struct sk_buff *)0;
    pxframe->pkt_offset = 1;
    pxframe->ack_report = 0U;
  } else {
  }
  return;
}
}
static struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv )
{
  struct xmit_frame *pxframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_queue *pfree_xmit_queue ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  pxframe = (struct xmit_frame *)0;
  pfree_xmit_queue = & pxmitpriv->free_xmit_queue;
  spin_lock_bh(& pfree_xmit_queue->lock);
  tmp = list_empty((struct list_head const *)(& pfree_xmit_queue->queue));
  if (tmp != 0) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
      printk("\016rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {
    }
    pxframe = (struct xmit_frame *)0;
  } else {
    phead = get_list_head(pfree_xmit_queue);
    plist = phead->next;
    __mptr = (struct list_head const *)plist;
    pxframe = (struct xmit_frame *)__mptr;
    list_del_init(& pxframe->list);
    pxmitpriv->free_xmitframe_cnt = pxmitpriv->free_xmitframe_cnt - 1;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
      printk("\016rtw_alloc_xmitframe():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {
    }
  }
  spin_unlock_bh(& pfree_xmit_queue->lock);
  rtw_init_xmitframe(pxframe);
  return (pxframe);
}
}
struct xmit_frame *rtw_alloc_xmitframe23a_ext(struct xmit_priv *pxmitpriv )
{
  struct xmit_frame *pxframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_queue *queue ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  pxframe = (struct xmit_frame *)0;
  queue = & pxmitpriv->free_xframe_ext_queue;
  spin_lock_bh(& queue->lock);
  tmp = list_empty((struct list_head const *)(& queue->queue));
  if (tmp != 0) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
      printk("\016rtw_alloc_xmitframe23a_ext:%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {
    }
    pxframe = (struct xmit_frame *)0;
  } else {
    phead = get_list_head(queue);
    plist = phead->next;
    __mptr = (struct list_head const *)plist;
    pxframe = (struct xmit_frame *)__mptr;
    list_del_init(& pxframe->list);
    pxmitpriv->free_xframe_ext_cnt = pxmitpriv->free_xframe_ext_cnt - 1;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
      printk("\016rtw_alloc_xmitframe23a_ext():free_xmitframe_cnt =%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {
    }
  }
  spin_unlock_bh(& queue->lock);
  rtw_init_xmitframe(pxframe);
  return (pxframe);
}
}
s32 rtw_free_xmitframe23a(struct xmit_priv *pxmitpriv , struct xmit_frame *pxmitframe )
{
  struct rtw_queue *queue ;
  struct rtw_adapter *padapter ;
  struct sk_buff *pndis_pkt ;
  struct list_head *tmp ;
  {
  queue = (struct rtw_queue *)0;
  padapter = pxmitpriv->adapter;
  pndis_pkt = (struct sk_buff *)0;
  if ((unsigned long )pxmitframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016====== rtw_free_xmitframe23a():pxmitframe == NULL!!!!!!!!!!\n");
    } else {
    }
    goto exit;
  } else {
  }
  if ((unsigned long )pxmitframe->pkt != (unsigned long )((struct sk_buff *)0)) {
    pndis_pkt = pxmitframe->pkt;
    pxmitframe->pkt = (struct sk_buff *)0;
  } else {
  }
  if ((unsigned int )pxmitframe->ext_tag == 0U) {
    queue = & pxmitpriv->free_xmit_queue;
  } else
  if ((unsigned int )pxmitframe->ext_tag == 1U) {
    queue = & pxmitpriv->free_xframe_ext_queue;
  } else {
  }
  if ((unsigned long )queue == (unsigned long )((struct rtw_queue *)0)) {
    goto check_pkt_complete;
  } else {
  }
  spin_lock_bh(& queue->lock);
  list_del_init(& pxmitframe->list);
  tmp = get_list_head(queue);
  list_add_tail(& pxmitframe->list, tmp);
  if ((unsigned int )pxmitframe->ext_tag == 0U) {
    pxmitpriv->free_xmitframe_cnt = pxmitpriv->free_xmitframe_cnt + 1;
    if (GlobalDebugLevel23A > 7U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 8);
      printk("\016rtw_free_xmitframe23a():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {
    }
  } else
  if ((unsigned int )pxmitframe->ext_tag == 1U) {
    pxmitpriv->free_xframe_ext_cnt = pxmitpriv->free_xframe_ext_cnt + 1;
    if (GlobalDebugLevel23A > 7U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 8);
      printk("\016rtw_free_xmitframe23a():free_xframe_ext_cnt =%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {
    }
  } else {
  }
  spin_unlock_bh(& queue->lock);
  check_pkt_complete: ;
  if ((unsigned long )pndis_pkt != (unsigned long )((struct sk_buff *)0)) {
    rtw_os_pkt_complete23a(padapter, pndis_pkt);
  } else {
  }
  exit: ;
  return (1);
}
}
void rtw_free_xmitframe_queue23a(struct xmit_priv *pxmitpriv , struct rtw_queue *pframequeue )
{
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct list_head const *__mptr ;
  {
  spin_lock_bh(& pframequeue->lock);
  phead = get_list_head(pframequeue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_51977;
  ldv_51976:
  __mptr = (struct list_head const *)plist;
  pxmitframe = (struct xmit_frame *)__mptr;
  rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_51977: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_51976;
  } else {
  }
  spin_unlock_bh(& pframequeue->lock);
  return;
}
}
s32 rtw_xmitframe_enqueue23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  s32 tmp ;
  {
  tmp = rtw_xmit23a_classifier(padapter, pxmitframe);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016rtw_xmitframe_enqueue23a: drop xmit pkt for classifier fail\n");
    } else {
    }
    return (0);
  } else {
  }
  return (1);
}
}
static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit ,
                                                struct tx_servq *ptxservq , struct rtw_queue *pframe_queue )
{
  struct list_head *phead ;
  struct xmit_frame *pxmitframe ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  pxmitframe = (struct xmit_frame *)0;
  phead = get_list_head(pframe_queue);
  tmp = list_empty((struct list_head const *)phead);
  if (tmp == 0) {
    __mptr = (struct list_head const *)phead->next;
    pxmitframe = (struct xmit_frame *)__mptr;
    list_del_init(& pxmitframe->list);
    ptxservq->qcnt = ptxservq->qcnt - 1;
  } else {
  }
  return (pxmitframe);
}
}
struct xmit_frame *rtw_dequeue_xframe23a(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit_i ,
                                         int entry )
{
  struct list_head *sta_plist ;
  struct list_head *sta_phead ;
  struct list_head *ptmp ;
  struct hw_xmit *phwxmit ;
  struct tx_servq *ptxservq ;
  struct rtw_queue *pframe_queue ;
  struct xmit_frame *pxmitframe ;
  struct rtw_adapter *padapter ;
  struct registry_priv *pregpriv ;
  int i ;
  int inx[4U] ;
  int j ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  ptxservq = (struct tx_servq *)0;
  pframe_queue = (struct rtw_queue *)0;
  pxmitframe = (struct xmit_frame *)0;
  padapter = pxmitpriv->adapter;
  pregpriv = & padapter->registrypriv;
  inx[0] = 0;
  inx[1] = 1;
  inx[2] = 2;
  inx[3] = 3;
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
    j = 0;
    goto ldv_52011;
    ldv_52010:
    inx[j] = (int )pxmitpriv->wmm_para_seq[j];
    j = j + 1;
    ldv_52011: ;
    if (j <= 3) {
      goto ldv_52010;
    } else {
    }
  } else {
  }
  spin_lock_bh(& pxmitpriv->lock);
  i = 0;
  goto ldv_52020;
  ldv_52019:
  phwxmit = phwxmit_i + (unsigned long )inx[i];
  sta_phead = get_list_head(phwxmit->sta_queue);
  sta_plist = sta_phead->next;
  ptmp = sta_plist->next;
  goto ldv_52017;
  ldv_52016:
  __mptr = (struct list_head const *)sta_plist;
  ptxservq = (struct tx_servq *)__mptr;
  pframe_queue = & ptxservq->sta_pending;
  pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
  if ((unsigned long )pxmitframe != (unsigned long )((struct xmit_frame *)0)) {
    phwxmit->accnt = phwxmit->accnt - 1;
    tmp = list_empty((struct list_head const *)(& pframe_queue->queue));
    if (tmp != 0) {
      list_del_init(& ptxservq->tx_pending);
    } else {
    }
    goto exit;
  } else {
  }
  sta_plist = ptmp;
  ptmp = sta_plist->next;
  ldv_52017: ;
  if ((unsigned long )sta_plist != (unsigned long )sta_phead) {
    goto ldv_52016;
  } else {
  }
  i = i + 1;
  ldv_52020: ;
  if (i < entry) {
    goto ldv_52019;
  } else {
  }
  exit:
  spin_unlock_bh(& pxmitpriv->lock);
  return (pxmitframe);
}
}
struct tx_servq *rtw_get_sta_pending23a(struct rtw_adapter *padapter , struct sta_info *psta ,
                                        int up___0 , u8 *ac )
{
  struct tx_servq *ptxservq ;
  {
  ptxservq = (struct tx_servq *)0;
  switch (up___0) {
  case 1: ;
  case 2:
  ptxservq = & psta->sta_xmitpriv.bk_q;
  *ac = 3U;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016rtw_get_sta_pending23a : BK\n");
  } else {
  }
  goto ldv_52031;
  case 4: ;
  case 5:
  ptxservq = & psta->sta_xmitpriv.vi_q;
  *ac = 1U;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016rtw_get_sta_pending23a : VI\n");
  } else {
  }
  goto ldv_52031;
  case 6: ;
  case 7:
  ptxservq = & psta->sta_xmitpriv.vo_q;
  *ac = 0U;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016rtw_get_sta_pending23a : VO\n");
  } else {
  }
  goto ldv_52031;
  case 0: ;
  case 3: ;
  default:
  ptxservq = & psta->sta_xmitpriv.be_q;
  *ac = 2U;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016rtw_get_sta_pending23a : BE\n");
  } else {
  }
  goto ldv_52031;
  }
  ldv_52031: ;
  return (ptxservq);
}
}
s32 rtw_xmit23a_classifier(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  struct pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct hw_xmit *phwxmits ;
  u8 ac_index ;
  int res ;
  struct list_head *tmp ;
  int tmp___0 ;
  struct list_head *tmp___1 ;
  {
  pattrib = & pxmitframe->attrib;
  pstapriv = & padapter->stapriv;
  phwxmits = padapter->xmitpriv.hwxmits;
  res = 1;
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_xmit23a_classifier");
    } else {
    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: rtw_xmit23a_classifier: psta == NULL\n");
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016rtw_xmit23a_classifier: psta == NULL\n");
    } else {
    }
    goto exit;
  } else {
  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_xmit23a_classifier",
             psta->state);
    } else {
    }
    return (0);
  } else {
  }
  ptxservq = rtw_get_sta_pending23a(padapter, psta, (int )pattrib->priority, & ac_index);
  tmp___0 = list_empty((struct list_head const *)(& ptxservq->tx_pending));
  if (tmp___0 != 0) {
    tmp = get_list_head((phwxmits + (unsigned long )ac_index)->sta_queue);
    list_add_tail(& ptxservq->tx_pending, tmp);
  } else {
  }
  tmp___1 = get_list_head(& ptxservq->sta_pending);
  list_add_tail(& pxmitframe->list, tmp___1);
  ptxservq->qcnt = ptxservq->qcnt + 1;
  (phwxmits + (unsigned long )ac_index)->accnt = (phwxmits + (unsigned long )ac_index)->accnt + 1;
  exit: ;
  return (res);
}
}
void rtw_alloc_hwxmits23a(struct rtw_adapter *padapter )
{
  struct hw_xmit *hwxmits ;
  struct xmit_priv *pxmitpriv ;
  int size ;
  void *tmp ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pxmitpriv->hwxmit_entry = 4U;
  size = ((int )pxmitpriv->hwxmit_entry + 1) * 16;
  tmp = kzalloc((size_t )size, 208U);
  pxmitpriv->hwxmits = (struct hw_xmit *)tmp;
  hwxmits = pxmitpriv->hwxmits;
  if ((unsigned int )pxmitpriv->hwxmit_entry == 5U) {
    hwxmits->sta_queue = & pxmitpriv->bm_pending;
    (hwxmits + 1UL)->sta_queue = & pxmitpriv->vo_pending;
    (hwxmits + 2UL)->sta_queue = & pxmitpriv->vi_pending;
    (hwxmits + 3UL)->sta_queue = & pxmitpriv->bk_pending;
    (hwxmits + 4UL)->sta_queue = & pxmitpriv->be_pending;
  } else
  if ((unsigned int )pxmitpriv->hwxmit_entry == 4U) {
    hwxmits->sta_queue = & pxmitpriv->vo_pending;
    (hwxmits + 1UL)->sta_queue = & pxmitpriv->vi_pending;
    (hwxmits + 2UL)->sta_queue = & pxmitpriv->be_pending;
    (hwxmits + 3UL)->sta_queue = & pxmitpriv->bk_pending;
  } else {
  }
  return;
}
}
void rtw_free_hwxmits23a(struct rtw_adapter *padapter )
{
  struct hw_xmit *hwxmits ;
  struct xmit_priv *pxmitpriv ;
  {
  pxmitpriv = & padapter->xmitpriv;
  hwxmits = pxmitpriv->hwxmits;
  kfree((void const *)hwxmits);
  return;
}
}
void rtw_init_hwxmits23a(struct hw_xmit *phwxmit , int entry )
{
  int i ;
  {
  i = 0;
  goto ldv_52069;
  ldv_52068:
  phwxmit->accnt = 0;
  i = i + 1;
  phwxmit = phwxmit + 1;
  ldv_52069: ;
  if (i < entry) {
    goto ldv_52068;
  } else {
  }
  return;
}
}
u32 rtw_get_ff_hwaddr23a(struct xmit_frame *pxmitframe )
{
  u32 addr ;
  struct pkt_attrib *pattrib ;
  {
  pattrib = & pxmitframe->attrib;
  switch ((int )pattrib->qsel) {
  case 0: ;
  case 3:
  addr = 2U;
  goto ldv_52078;
  case 1: ;
  case 2:
  addr = 3U;
  goto ldv_52078;
  case 4: ;
  case 5:
  addr = 1U;
  goto ldv_52078;
  case 6: ;
  case 7:
  addr = 0U;
  goto ldv_52078;
  case 16:
  addr = 4U;
  goto ldv_52078;
  case 17:
  addr = 6U;
  goto ldv_52078;
  case 18: ;
  default:
  addr = 5U;
  goto ldv_52078;
  }
  ldv_52078: ;
  return (addr);
}
}
static void do_queue_select(struct rtw_adapter *padapter , struct pkt_attrib *pattrib )
{
  u8 qsel ;
  {
  qsel = pattrib->priority;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016### do_queue_select priority =%d , qsel = %d\n", (int )pattrib->priority,
           (int )qsel);
  } else {
  }
  pattrib->qsel = qsel;
  return;
}
}
int rtw_xmit23a(struct rtw_adapter *padapter , struct sk_buff *skb )
{
  struct xmit_priv *pxmitpriv ;
  struct xmit_frame *pxmitframe ;
  int res ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  pxmitframe = (struct xmit_frame *)0;
  pxmitframe = rtw_alloc_xmitframe(pxmitpriv);
  if ((unsigned long )pxmitframe == (unsigned long )((struct xmit_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 4);
      printk("\016rtw_xmit23a: no more pxmitframe\n");
    } else {
    }
    return (-1);
  } else {
  }
  res = update_attrib(padapter, skb, & pxmitframe->attrib);
  if (res == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 4);
      printk("\016rtw_xmit23a: update attrib fail\n");
    } else {
    }
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    return (-1);
  } else {
  }
  pxmitframe->pkt = skb;
  do_queue_select(padapter, & pxmitframe->attrib);
  spin_lock_bh(& pxmitpriv->lock);
  tmp = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
  if (tmp != 0) {
    spin_unlock_bh(& pxmitpriv->lock);
    return (1);
  } else {
  }
  spin_unlock_bh(& pxmitpriv->lock);
  tmp___0 = rtl8723au_hal_xmit(padapter, pxmitframe);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (1);
  } else {
  }
  return (0);
}
}
int xmitframe_enqueue_for_sleeping_sta23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  int ret ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct pkt_attrib *pattrib ;
  struct mlme_priv *pmlmepriv ;
  int bmcst ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct list_head *tmp___2 ;
  u8 wmmps_ac ;
  struct list_head *tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  {
  ret = 0;
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  pattrib = & pxmitframe->attrib;
  pmlmepriv = & padapter->mlmepriv;
  tmp = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
  bmcst = (int )tmp;
  tmp___0 = check_fwstate(pmlmepriv, 16);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (ret);
  } else {
  }
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
    psta = pattrib->psta;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "xmitframe_enqueue_for_sleeping_sta23a");
    } else {
    }
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->ra));
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta == NUL\n", "xmitframe_enqueue_for_sleeping_sta23a");
    } else {
    }
    return (0);
  } else {
  }
  if ((psta->state & 1U) == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "xmitframe_enqueue_for_sleeping_sta23a",
             psta->state);
    } else {
    }
    return (0);
  } else {
  }
  if ((unsigned int )pattrib->triggered == 1U) {
    if (bmcst != 0) {
      pattrib->qsel = 17U;
    } else {
    }
    return (ret);
  } else {
  }
  if (bmcst != 0) {
    spin_lock_bh(& psta->sleep_q.lock);
    if ((unsigned int )pstapriv->sta_dz_bitmap != 0U) {
      list_del_init(& pxmitframe->list);
      tmp___2 = get_list_head(& psta->sleep_q);
      list_add_tail(& pxmitframe->list, tmp___2);
      psta->sleepq_len = psta->sleepq_len + 1U;
      pstapriv->tim_bitmap = (u16 )((unsigned int )pstapriv->tim_bitmap | 1U);
      pstapriv->sta_dz_bitmap = (u16 )((unsigned int )pstapriv->sta_dz_bitmap | 1U);
      update_beacon23a(padapter, 5, (u8 *)0U, 0);
      ret = 1;
    } else {
    }
    spin_unlock_bh(& psta->sleep_q.lock);
    return (ret);
  } else {
  }
  spin_lock_bh(& psta->sleep_q.lock);
  if ((psta->state & 4U) != 0U) {
    wmmps_ac = 0U;
    tmp___5 = CHKBIT(psta->aid);
    if (((u32 )pstapriv->sta_dz_bitmap & tmp___5) != 0U) {
      list_del_init(& pxmitframe->list);
      tmp___3 = get_list_head(& psta->sleep_q);
      list_add_tail(& pxmitframe->list, tmp___3);
      psta->sleepq_len = psta->sleepq_len + 1U;
      switch ((int )pattrib->priority) {
      case 1: ;
      case 2:
      wmmps_ac = (unsigned int )psta->uapsd_bk & 1U;
      goto ldv_52115;
      case 4: ;
      case 5:
      wmmps_ac = (unsigned int )psta->uapsd_vi & 1U;
      goto ldv_52115;
      case 6: ;
      case 7:
      wmmps_ac = (unsigned int )psta->uapsd_vo & 1U;
      goto ldv_52115;
      case 0: ;
      case 3: ;
      default:
      wmmps_ac = (unsigned int )psta->uapsd_be & 1U;
      goto ldv_52115;
      }
      ldv_52115: ;
      if ((unsigned int )wmmps_ac != 0U) {
        psta->sleepq_ac_len = psta->sleepq_ac_len + 1U;
      } else {
      }
      if (((unsigned int )psta->has_legacy_ac != 0U && (unsigned int )wmmps_ac == 0U) || ((unsigned int )psta->has_legacy_ac == 0U && (unsigned int )wmmps_ac != 0U)) {
        tmp___4 = CHKBIT(psta->aid);
        pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap | (int )((u16 )tmp___4);
        if (psta->sleepq_len == 1U) {
          update_beacon23a(padapter, 5, (u8 *)0U, 0);
        } else {
        }
      } else {
      }
      ret = 1;
    } else {
    }
  } else {
  }
  spin_unlock_bh(& psta->sleep_q.lock);
  return (ret);
}
}
static void dequeue_xmitframes_to_sleeping_queue(struct rtw_adapter *padapter , struct sta_info *psta ,
                                                 struct rtw_queue *pframequeue )
{
  int ret ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  u8 ac_index ;
  struct tx_servq *ptxservq ;
  struct pkt_attrib *pattrib ;
  struct xmit_frame *pxmitframe ;
  struct hw_xmit *phwxmits ;
  struct list_head const *__mptr ;
  {
  phwxmits = padapter->xmitpriv.hwxmits;
  phead = get_list_head(pframequeue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_52140;
  ldv_52139:
  __mptr = (struct list_head const *)plist;
  pxmitframe = (struct xmit_frame *)__mptr;
  ret = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
  if (ret == 1) {
    pattrib = & pxmitframe->attrib;
    ptxservq = rtw_get_sta_pending23a(padapter, psta, (int )pattrib->priority, & ac_index);
    ptxservq->qcnt = ptxservq->qcnt - 1;
    (phwxmits + (unsigned long )ac_index)->accnt = (phwxmits + (unsigned long )ac_index)->accnt - 1;
  } else {
  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_52140: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_52139;
  } else {
  }
  return;
}
}
void stop_sta_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  struct sta_info *psta_bmc ;
  struct sta_xmit_priv *pstaxmitpriv ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  u32 tmp ;
  {
  pstapriv = & padapter->stapriv;
  pxmitpriv = & padapter->xmitpriv;
  pstaxmitpriv = & psta->sta_xmitpriv;
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
  spin_lock_bh(& pxmitpriv->lock);
  psta->state = psta->state | 4U;
  tmp = CHKBIT(psta->aid);
  pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap | (int )((u16 )tmp);
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->vo_q.sta_pending);
  list_del_init(& pstaxmitpriv->vo_q.tx_pending);
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->vi_q.sta_pending);
  list_del_init(& pstaxmitpriv->vi_q.tx_pending);
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->be_q.sta_pending);
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->bk_q.sta_pending);
  list_del_init(& pstaxmitpriv->bk_q.tx_pending);
  pstaxmitpriv = & psta_bmc->sta_xmitpriv;
  dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, & pstaxmitpriv->be_q.sta_pending);
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
  spin_unlock_bh(& pxmitpriv->lock);
  return;
}
}
void wakeup_sta_to_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  u8 update_mask ;
  u8 wmmps_ac ;
  struct sta_info *psta_bmc ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  struct list_head const *__mptr ;
  u32 tmp ;
  u32 tmp___0 ;
  struct list_head const *__mptr___0 ;
  {
  update_mask = 0U;
  wmmps_ac = 0U;
  pxmitframe = (struct xmit_frame *)0;
  pstapriv = & padapter->stapriv;
  pxmitpriv = & padapter->xmitpriv;
  spin_lock_bh(& pxmitpriv->lock);
  phead = get_list_head(& psta->sleep_q);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_52176;
  ldv_52175:
  __mptr = (struct list_head const *)plist;
  pxmitframe = (struct xmit_frame *)__mptr;
  list_del_init(& pxmitframe->list);
  switch ((int )pxmitframe->attrib.priority) {
  case 1: ;
  case 2:
  wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
  goto ldv_52167;
  case 4: ;
  case 5:
  wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
  goto ldv_52167;
  case 6: ;
  case 7:
  wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
  goto ldv_52167;
  case 0: ;
  case 3: ;
  default:
  wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
  goto ldv_52167;
  }
  ldv_52167:
  psta->sleepq_len = psta->sleepq_len - 1U;
  if (psta->sleepq_len != 0U) {
    pxmitframe->attrib.mdata = 1U;
  } else {
    pxmitframe->attrib.mdata = 0U;
  }
  if ((unsigned int )wmmps_ac != 0U) {
    psta->sleepq_ac_len = psta->sleepq_ac_len - 1U;
    if (psta->sleepq_ac_len != 0U) {
      pxmitframe->attrib.mdata = 1U;
      pxmitframe->attrib.eosp = 0U;
    } else {
      pxmitframe->attrib.mdata = 0U;
      pxmitframe->attrib.eosp = 1U;
    }
  } else {
  }
  pxmitframe->attrib.triggered = 1U;
  rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
  plist = ptmp;
  ptmp = plist->next;
  ldv_52176: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_52175;
  } else {
  }
  if (psta->sleepq_len == 0U) {
    tmp = CHKBIT(psta->aid);
    pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp));
    update_mask = 1U;
    if ((psta->state & 4U) != 0U) {
      psta->state = psta->state ^ 4U;
    } else {
    }
    if ((psta->state & 1024U) != 0U) {
      psta->expire_to = pstapriv->expire_to;
      psta->state = psta->state ^ 1024U;
    } else {
    }
    tmp___0 = CHKBIT(psta->aid);
    pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap & ~ ((int )((u16 )tmp___0));
  } else {
  }
  spin_unlock_bh(& pxmitpriv->lock);
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
  if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {
  }
  if (((int )pstapriv->sta_dz_bitmap & 65534) == 0) {
    spin_lock_bh(& pxmitpriv->lock);
    phead = get_list_head(& psta_bmc->sleep_q);
    plist = phead->next;
    ptmp = plist->next;
    goto ldv_52181;
    ldv_52180:
    __mptr___0 = (struct list_head const *)plist;
    pxmitframe = (struct xmit_frame *)__mptr___0;
    list_del_init(& pxmitframe->list);
    psta_bmc->sleepq_len = psta_bmc->sleepq_len - 1U;
    if (psta_bmc->sleepq_len != 0U) {
      pxmitframe->attrib.mdata = 1U;
    } else {
      pxmitframe->attrib.mdata = 0U;
    }
    pxmitframe->attrib.triggered = 1U;
    rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
    plist = ptmp;
    ptmp = plist->next;
    ldv_52181: ;
    if ((unsigned long )plist != (unsigned long )phead) {
      goto ldv_52180;
    } else {
    }
    if (psta_bmc->sleepq_len == 0U) {
      pstapriv->tim_bitmap = (unsigned int )pstapriv->tim_bitmap & 65534U;
      pstapriv->sta_dz_bitmap = (unsigned int )pstapriv->sta_dz_bitmap & 65534U;
      update_mask = (u8 )((unsigned int )update_mask | 2U);
    } else {
    }
    spin_unlock_bh(& pxmitpriv->lock);
  } else {
  }
  if ((unsigned int )update_mask != 0U) {
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
  } else {
  }
  return;
}
}
void xmit_delivery_enabled_frames23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  u8 wmmps_ac ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  struct list_head const *__mptr ;
  u32 tmp ;
  {
  wmmps_ac = 0U;
  pstapriv = & padapter->stapriv;
  pxmitpriv = & padapter->xmitpriv;
  spin_lock_bh(& pxmitpriv->lock);
  phead = get_list_head(& psta->sleep_q);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_52208;
  ldv_52207:
  __mptr = (struct list_head const *)plist;
  pxmitframe = (struct xmit_frame *)__mptr;
  switch ((int )pxmitframe->attrib.priority) {
  case 1: ;
  case 2:
  wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
  goto ldv_52198;
  case 4: ;
  case 5:
  wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
  goto ldv_52198;
  case 6: ;
  case 7:
  wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
  goto ldv_52198;
  case 0: ;
  case 3: ;
  default:
  wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
  goto ldv_52198;
  }
  ldv_52198: ;
  if ((unsigned int )wmmps_ac == 0U) {
    goto ldv_52206;
  } else {
  }
  list_del_init(& pxmitframe->list);
  psta->sleepq_len = psta->sleepq_len - 1U;
  psta->sleepq_ac_len = psta->sleepq_ac_len - 1U;
  if (psta->sleepq_ac_len != 0U) {
    pxmitframe->attrib.mdata = 1U;
    pxmitframe->attrib.eosp = 0U;
  } else {
    pxmitframe->attrib.mdata = 0U;
    pxmitframe->attrib.eosp = 1U;
  }
  pxmitframe->attrib.triggered = 1U;
  rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
  if ((psta->sleepq_ac_len == 0U && (unsigned int )psta->has_legacy_ac == 0U) && (unsigned int )wmmps_ac != 0U) {
    tmp = CHKBIT(psta->aid);
    pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp));
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
  } else {
  }
  ldv_52206:
  plist = ptmp;
  ptmp = plist->next;
  ldv_52208: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_52207;
  } else {
  }
  spin_unlock_bh(& pxmitpriv->lock);
  return;
}
}
void rtw_sctx_init23a(struct submit_ctx *sctx , int timeout_ms )
{
  {
  sctx->timeout_ms = (u32 )timeout_ms;
  init_completion(& sctx->done);
  sctx->status = -1;
  return;
}
}
int rtw_sctx_wait23a(struct submit_ctx *sctx )
{
  int ret ;
  unsigned long expire ;
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  {
  ret = 0;
  status = 0;
  if (sctx->timeout_ms != 0U) {
    tmp = msecs_to_jiffies(sctx->timeout_ms);
    expire = tmp;
  } else {
    expire = 9223372036854775807UL;
  }
  tmp___0 = wait_for_completion_timeout(& sctx->done, expire);
  if (tmp___0 == 0UL) {
    status = 2;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s timeout\n", "rtw_sctx_wait23a");
    } else {
    }
  } else {
    status = sctx->status;
  }
  if (status == 0) {
    ret = 1;
  } else {
  }
  return (ret);
}
}
static bool rtw_sctx_chk_waring_status(int status )
{
  {
  switch (status) {
  case 1: ;
  case 3: ;
  case 4: ;
  case 9: ;
  case 10: ;
  return (1);
  default: ;
  return (0);
  }
}
}
void rtw23a_sctx_done_err(struct submit_ctx **sctx , int status )
{
  bool tmp ;
  {
  if ((unsigned long )*sctx != (unsigned long )((struct submit_ctx *)0)) {
    tmp = rtw_sctx_chk_waring_status(status);
    if ((int )tmp) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s status:%d\n", "rtw23a_sctx_done_err", status);
      } else {
      }
    } else {
    }
    (*sctx)->status = status;
    complete(& (*sctx)->done);
    *sctx = (struct submit_ctx *)0;
  } else {
  }
  return;
}
}
void rtw_sctx_done23a(struct submit_ctx **sctx )
{
  {
  rtw23a_sctx_done_err(sctx, 0);
  return;
}
}
int rtw_ack_tx_wait23a(struct xmit_priv *pxmitpriv , u32 timeout_ms )
{
  struct submit_ctx *pack_tx_ops ;
  int tmp ;
  {
  pack_tx_ops = & pxmitpriv->ack_tx_ops;
  pack_tx_ops->timeout_ms = timeout_ms;
  pack_tx_ops->status = -1;
  tmp = rtw_sctx_wait23a(pack_tx_ops);
  return (tmp);
}
}
void rtw_ack_tx_done23a(struct xmit_priv *pxmitpriv , int status )
{
  struct submit_ctx *pack_tx_ops ;
  {
  pack_tx_ops = & pxmitpriv->ack_tx_ops;
  if (pxmitpriv->ack_tx != 0) {
    rtw23a_sctx_done_err(& pack_tx_ops, status);
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s ack_tx not set\n", "rtw_ack_tx_done23a");
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_830(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_836(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_838(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_840(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_841(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_842(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_843(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_844(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_845(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_846(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_872(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_880(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_888(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_882(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_878(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_886(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_887(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_883(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_884(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_885(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
void PHY_SetBWMode23a8723A(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ,
                           unsigned char Offset ) ;
void PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) ;
void rtw_hal_update_ra_mask23a(struct sta_info *psta , u8 rssi_level ) ;
void rtl8723a_set_ampdu_min_space(struct rtw_adapter *padapter , u8 MinSpacingToSet ) ;
void rtl8723a_set_ampdu_factor(struct rtw_adapter *padapter , u8 FactorToSet ) ;
void rtl8723a_set_acm_ctrl(struct rtw_adapter *padapter , u8 ctrl ) ;
void rtl8723a_set_media_status(struct rtw_adapter *padapter , u8 status ) ;
void rtl8723a_set_slot_time(struct rtw_adapter *padapter , u8 slottime ) ;
void rtl8723a_ack_preamble(struct rtw_adapter *padapter , u8 bShortPreamble ) ;
void rtl8723a_cam_invalid_all(struct rtw_adapter *padapter ) ;
void rtl8723a_set_resp_sifs(struct rtw_adapter *padapter , u8 r2t1 , u8 r2t2 , u8 t2t1 ,
                            u8 t2t2 ) ;
void rtl8723a_set_ac_param_vo(struct rtw_adapter *padapter , u32 vo ) ;
void rtl8723a_set_ac_param_vi(struct rtw_adapter *padapter , u32 vi ) ;
void rtl8723a_set_ac_param_be(struct rtw_adapter *padapter , u32 be ) ;
void rtl8723a_set_ac_param_bk(struct rtw_adapter *padapter , u32 bk ) ;
unsigned char networktype_to_raid23a(unsigned char network_type ) ;
u8 judge_network_type23a(struct rtw_adapter *padapter , unsigned char *rate , int ratelen ) ;
__inline void rtw_set_oper_ch23a(struct rtw_adapter *adapter , u8 ch ) ;
__inline void rtw_set_oper_bw23a(struct rtw_adapter *adapter , u8 bw ) ;
__inline void rtw_set_oper_ch23aoffset23a(struct rtw_adapter *adapter , u8 offset ) ;
void invalidate_cam_all23a(struct rtw_adapter *padapter ) ;
unsigned int update_basic_rate23a(unsigned char *ptn , unsigned int ptn_sz ) ;
unsigned int update_supported_rate23a(unsigned char *ptn , unsigned int ptn_sz ) ;
unsigned int update_MSC_rate23a(struct HT_caps_element *pHT_caps ) ;
unsigned char get_highest_rate_idx23a(u32 mask ) ;
bool is_ap_in_wep23a(struct rtw_adapter *padapter ) ;
bool should_forbid_n_rate23a(struct rtw_adapter *padapter ) ;
int cckrates_included23a(unsigned char *rate , int ratelen ) ;
int cckratesonly_included23a(unsigned char *rate , int ratelen ) ;
int rtw_handle_dualmac23a(struct rtw_adapter *adapter , bool init ) ;
static unsigned char ARTHEROS_OUI1[3U] = { 0U, 3U, 127U};
static unsigned char ARTHEROS_OUI2[3U] = { 0U, 19U, 116U};
static unsigned char BROADCOM_OUI1[3U] = { 0U, 16U, 24U};
static unsigned char BROADCOM_OUI2[3U] = { 0U, 10U, 247U};
static unsigned char CISCO_OUI[3U] = { 0U, 64U, 150U};
static unsigned char MARVELL_OUI[3U] = { 0U, 80U, 67U};
static unsigned char RALINK_OUI[3U] = { 0U, 12U, 67U};
static unsigned char REALTEK_OUI[3U] = { 0U, 224U, 76U};
static unsigned char AIRGOCAP_OUI[3U] = { 0U, 10U, 245U};
static unsigned char EPIGRAM_OUI[3U] = { 0U, 144U, 76U};
static unsigned char WPA_TKIP_CIPHER[4U] = { 0U, 80U, 242U, 2U};
static unsigned char RSN_TKIP_CIPHER[4U] = { 0U, 15U, 172U, 2U};
static u8 rtw_basic_rate_cck[4U] = { 130U, 132U, 139U, 150U};
static u8 rtw_basic_rate_ofdm[3U] = { 140U, 152U, 176U};
static u8 rtw_basic_rate_mix[7U] = { 130U, 132U, 139U, 150U,
        140U, 152U, 176U};
int cckrates_included23a(unsigned char *rate , int ratelen )
{
  int i ;
  {
  i = 0;
  goto ldv_51428;
  ldv_51427: ;
  if (((((int )*(rate + (unsigned long )i) & 127) == 2 || ((int )*(rate + (unsigned long )i) & 127) == 4) || ((int )*(rate + (unsigned long )i) & 127) == 11) || ((int )*(rate + (unsigned long )i) & 127) == 22) {
    return (1);
  } else {
  }
  i = i + 1;
  ldv_51428: ;
  if (i < ratelen) {
    goto ldv_51427;
  } else {
  }
  return (0);
}
}
int cckratesonly_included23a(unsigned char *rate , int ratelen )
{
  int i ;
  {
  i = 0;
  goto ldv_51436;
  ldv_51435: ;
  if (((((int )*(rate + (unsigned long )i) & 127) != 2 && ((int )*(rate + (unsigned long )i) & 127) != 4) && ((int )*(rate + (unsigned long )i) & 127) != 11) && ((int )*(rate + (unsigned long )i) & 127) != 22) {
    return (0);
  } else {
  }
  i = i + 1;
  ldv_51436: ;
  if (i < ratelen) {
    goto ldv_51435;
  } else {
  }
  return (1);
}
}
unsigned char networktype_to_raid23a(unsigned char network_type )
{
  unsigned char raid ;
  {
  switch ((int )network_type) {
  case 1:
  raid = 6U;
  goto ldv_51443;
  case 4: ;
  case 2:
  raid = 5U;
  goto ldv_51443;
  case 3:
  raid = 4U;
  goto ldv_51443;
  case 8: ;
  case 16:
  raid = 3U;
  goto ldv_51443;
  case 20: ;
  case 10:
  raid = 1U;
  goto ldv_51443;
  case 11:
  raid = 0U;
  goto ldv_51443;
  default:
  raid = 4U;
  goto ldv_51443;
  }
  ldv_51443: ;
  return (raid);
}
}
u8 judge_network_type23a(struct rtw_adapter *padapter , unsigned char *rate , int ratelen )
{
  u8 network_type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;
  int tmp___0 ;
  {
  network_type = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
      network_type = 16U;
    } else {
    }
    network_type = (u8 )((unsigned int )network_type | 4U);
  } else {
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
      network_type = 8U;
    } else {
    }
    tmp___0 = cckratesonly_included23a(rate, ratelen);
    if (tmp___0 == 1) {
      network_type = (u8 )((unsigned int )network_type | 1U);
    } else {
      tmp = cckrates_included23a(rate, ratelen);
      if (tmp == 1) {
        network_type = (u8 )((unsigned int )network_type | 3U);
      } else {
        network_type = (u8 )((unsigned int )network_type | 2U);
      }
    }
  }
  return (network_type);
}
}
static unsigned char ratetbl_val_2wifirate(unsigned char rate )
{
  unsigned char val ;
  {
  val = 0U;
  switch ((int )rate & 127) {
  case 0:
  val = 2U;
  goto ldv_51466;
  case 1:
  val = 4U;
  goto ldv_51466;
  case 2:
  val = 11U;
  goto ldv_51466;
  case 3:
  val = 22U;
  goto ldv_51466;
  case 4:
  val = 12U;
  goto ldv_51466;
  case 5:
  val = 18U;
  goto ldv_51466;
  case 6:
  val = 24U;
  goto ldv_51466;
  case 7:
  val = 36U;
  goto ldv_51466;
  case 8:
  val = 48U;
  goto ldv_51466;
  case 9:
  val = 72U;
  goto ldv_51466;
  case 10:
  val = 96U;
  goto ldv_51466;
  case 11:
  val = 108U;
  goto ldv_51466;
  }
  ldv_51466: ;
  return (val);
}
}
static int is_basicrate(struct rtw_adapter *padapter , unsigned char rate )
{
  int i ;
  unsigned char val ;
  struct mlme_ext_priv *pmlmeext ;
  unsigned char tmp ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  i = 0;
  goto ldv_51486;
  ldv_51485:
  val = pmlmeext->basicrate[i];
  if ((unsigned int )val != 255U && (unsigned int )val != 254U) {
    tmp = ratetbl_val_2wifirate((int )val);
    if ((int )tmp == (int )rate) {
      return (1);
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_51486: ;
  if (i <= 12) {
    goto ldv_51485;
  } else {
  }
  return (0);
}
}
static unsigned int ratetbl2rateset(struct rtw_adapter *padapter , unsigned char *rateset )
{
  int i ;
  unsigned char rate ;
  unsigned int len ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;
  {
  len = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  i = 0;
  goto ldv_51502;
  ldv_51501:
  rate = pmlmeext->datarate[i];
  switch ((int )rate) {
  case 255: ;
  return (len);
  case 254: ;
  goto ldv_51498;
  default:
  rate = ratetbl_val_2wifirate((int )rate);
  tmp = is_basicrate(padapter, (int )rate);
  if (tmp == 1) {
    rate = (unsigned int )rate | 128U;
  } else {
  }
  *(rateset + (unsigned long )len) = rate;
  len = len + 1U;
  goto ldv_51500;
  }
  ldv_51500: ;
  ldv_51498:
  i = i + 1;
  ldv_51502: ;
  if (i <= 12) {
    goto ldv_51501;
  } else {
  }
  return (len);
}
}
void get_rate_set23a(struct rtw_adapter *padapter , unsigned char *pbssrate , int *bssrate_len )
{
  unsigned char supportedrates[13U] ;
  unsigned int tmp ;
  size_t __len ;
  void *__ret ;
  {
  memset((void *)(& supportedrates), 0, 13UL);
  tmp = ratetbl2rateset(padapter, (unsigned char *)(& supportedrates));
  *bssrate_len = (int )tmp;
  __len = (size_t )*bssrate_len;
  __ret = memcpy((void *)pbssrate, (void const *)(& supportedrates), __len);
  return;
}
}
void UpdateBrateTbl23a(struct rtw_adapter *Adapter , u8 *mBratesOS )
{
  u8 i ;
  u8 rate ;
  {
  i = 0U;
  goto ldv_51529;
  ldv_51528:
  rate = (unsigned int )*(mBratesOS + (unsigned long )i) & 127U;
  switch ((int )rate) {
  case 2: ;
  case 4: ;
  case 11: ;
  case 22: ;
  case 12: ;
  case 24: ;
  case 48:
  *(mBratesOS + (unsigned long )i) = (u8 )((unsigned int )*(mBratesOS + (unsigned long )i) | 128U);
  goto ldv_51526;
  default: ;
  goto ldv_51526;
  }
  ldv_51526:
  i = (u8 )((int )i + 1);
  ldv_51529: ;
  if ((unsigned int )i <= 15U) {
    goto ldv_51528;
  } else {
  }
  return;
}
}
void Update23aTblForSoftAP(u8 *bssrateset , u32 bssratelen )
{
  u8 i ;
  u8 rate ;
  {
  i = 0U;
  goto ldv_51543;
  ldv_51542:
  rate = (unsigned int )*(bssrateset + (unsigned long )i) & 127U;
  switch ((int )rate) {
  case 2: ;
  case 4: ;
  case 11: ;
  case 22:
  *(bssrateset + (unsigned long )i) = (u8 )((unsigned int )*(bssrateset + (unsigned long )i) | 128U);
  goto ldv_51541;
  }
  ldv_51541:
  i = (u8 )((int )i + 1);
  ldv_51543: ;
  if ((u32 )i < bssratelen) {
    goto ldv_51542;
  } else {
  }
  return;
}
}
void Set_MSR23a(struct rtw_adapter *padapter , u8 type )
{
  {
  rtl8723a_set_media_status(padapter, (int )type);
  return;
}
}
__inline void rtw_set_oper_ch23a(struct rtw_adapter *adapter , u8 ch )
{
  {
  (adapter->dvobj)->oper_channel = ch;
  return;
}
}
__inline void rtw_set_oper_bw23a(struct rtw_adapter *adapter , u8 bw )
{
  {
  (adapter->dvobj)->oper_bwmode = bw;
  return;
}
}
__inline void rtw_set_oper_ch23aoffset23a(struct rtw_adapter *adapter , u8 offset )
{
  {
  (adapter->dvobj)->oper_ch_offset = offset;
  return;
}
}
void SelectChannel23a(struct rtw_adapter *padapter , unsigned char channel )
{
  {
  mutex_lock_nested(& (padapter->dvobj)->setch_mutex, 0U);
  rtw_set_oper_ch23a(padapter, (int )channel);
  PHY_SwChnl8723A(padapter, (int )channel);
  mutex_unlock(& (padapter->dvobj)->setch_mutex);
  return;
}
}
static void set_bwmode(struct rtw_adapter *padapter , unsigned short bwmode , unsigned char channel_offset )
{
  {
  mutex_lock_nested(& (padapter->dvobj)->setbw_mutex, 0U);
  rtw_set_oper_bw23a(padapter, (int )((u8 )bwmode));
  rtw_set_oper_ch23aoffset23a(padapter, (int )channel_offset);
  PHY_SetBWMode23a8723A(padapter, (enum ht_channel_width )bwmode, (int )channel_offset);
  mutex_unlock(& (padapter->dvobj)->setbw_mutex);
  return;
}
}
void set_channel_bwmode23a(struct rtw_adapter *padapter , unsigned char channel ,
                           unsigned char channel_offset , unsigned short bwmode )
{
  u8 center_ch ;
  {
  if ((unsigned int )padapter->bNotifyChannelChange != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: [%s] ch = %d, offset = %d, bwmode = %d\n", "set_channel_bwmode23a",
             (int )channel, (int )channel_offset, (int )bwmode);
    } else {
    }
  } else {
  }
  if ((unsigned int )bwmode == 0U || (unsigned int )channel_offset == 0U) {
    center_ch = channel;
  } else
  if ((unsigned int )channel_offset == 1U) {
    center_ch = (unsigned int )channel + 2U;
  } else {
    center_ch = (unsigned int )channel + 254U;
  }
  mutex_lock_nested(& (padapter->dvobj)->setch_mutex, 0U);
  rtw_set_oper_ch23a(padapter, (int )channel);
  rtw_set_oper_bw23a(padapter, (int )((u8 )bwmode));
  rtw_set_oper_ch23aoffset23a(padapter, (int )channel_offset);
  PHY_SwChnl8723A(padapter, (int )center_ch);
  mutex_unlock(& (padapter->dvobj)->setch_mutex);
  set_bwmode(padapter, (int )bwmode, (int )channel_offset);
  return;
}
}
u16 get_beacon_interval23a(struct wlan_bssid_ex *bss )
{
  unsigned short val ;
  size_t __len ;
  void *__ret ;
  __le16 *tmp ;
  __le16 *tmp___0 ;
  {
  __len = 2UL;
  if (__len > 63UL) {
    tmp = rtw_get_beacon_interval23a_from_ie((u8 *)(& bss->IEs));
    __ret = memcpy((void *)(& val), (void const *)tmp, __len);
  } else {
    tmp___0 = rtw_get_beacon_interval23a_from_ie((u8 *)(& bss->IEs));
    __ret = memcpy((void *)(& val), (void const *)tmp___0, __len);
  }
  return (val);
}
}
bool is_client_associated_to_ap23a(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return (0);
  } else {
  }
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((pmlmeinfo->state & 16384U) != 0U && (pmlmeinfo->state & 3U) == 2U) {
    return (1);
  } else {
    return (0);
  }
}
}
bool is_client_associated_to_ibss23a(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((pmlmeinfo->state & 16384U) != 0U && (pmlmeinfo->state & 3U) == 1U) {
    return (1);
  } else {
    return (0);
  }
}
}
bool is_IBSS_empty23a(struct rtw_adapter *padapter )
{
  unsigned int i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  i = 2U;
  goto ldv_51614;
  ldv_51613: ;
  if (pmlmeinfo->FW_sta_info[i].status == 1U) {
    return (0);
  } else {
  }
  i = i + 1U;
  ldv_51614: ;
  if (i <= 31U) {
    goto ldv_51613;
  } else {
  }
  return (1);
}
}
unsigned int decide_wait_for_beacon_timeout23a(unsigned int bcn_interval )
{
  {
  if (bcn_interval << 2 <= 5999U) {
    return (6000U);
  } else
  if (bcn_interval << 2 > 20000U) {
    return (20000U);
  } else {
    return (bcn_interval << 2);
  }
}
}
void invalidate_cam_all23a(struct rtw_adapter *padapter )
{
  {
  rtl8723a_cam_invalid_all(padapter);
  return;
}
}
void clear_cam_entry23a(struct rtw_adapter *padapter , u8 entry )
{
  unsigned char null_sta[6U] ;
  unsigned char null_key[16U] ;
  {
  null_sta[0] = 0U;
  null_sta[1] = 0U;
  null_sta[2] = 0U;
  null_sta[3] = 0U;
  null_sta[4] = 0U;
  null_sta[5] = 0U;
  null_key[0] = 0U;
  null_key[1] = 0U;
  null_key[2] = 0U;
  null_key[3] = 0U;
  null_key[4] = 0U;
  null_key[5] = 0U;
  null_key[6] = 0U;
  null_key[7] = 0U;
  null_key[8] = 0U;
  null_key[9] = 0U;
  null_key[10] = 0U;
  null_key[11] = 0U;
  null_key[12] = 0U;
  null_key[13] = 0U;
  null_key[14] = 0U;
  null_key[15] = 0U;
  rtl8723a_cam_write(padapter, (int )entry, 0, (u8 const *)(& null_sta), (u8 const *)(& null_key));
  return;
}
}
int allocate_fw_sta_entry23a(struct rtw_adapter *padapter )
{
  unsigned int mac_id ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  mac_id = 2U;
  goto ldv_51636;
  ldv_51635: ;
  if (pmlmeinfo->FW_sta_info[mac_id].status == 0U) {
    pmlmeinfo->FW_sta_info[mac_id].status = 1U;
    pmlmeinfo->FW_sta_info[mac_id].retry = 0U;
    goto ldv_51634;
  } else {
  }
  mac_id = mac_id + 1U;
  ldv_51636: ;
  if (mac_id <= 31U) {
    goto ldv_51635;
  } else {
  }
  ldv_51634: ;
  return ((int )mac_id);
}
}
void flush_all_cam_entry23a(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  rtl8723a_cam_invalid_all(padapter);
  memset((void *)(& pmlmeinfo->FW_sta_info), 0, 1280UL);
  return;
}
}
int WMM_param_handler23a(struct rtw_adapter *padapter , u8 *p )
{
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (pmlmepriv->qos_option == 0U) {
    pmlmeinfo->WMM_enable = 0U;
    return (0);
  } else {
  }
  pmlmeinfo->WMM_enable = 1U;
  __len = 18UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pmlmeinfo->WMM_param), (void const *)p + 8U, __len);
  } else {
    __ret = memcpy((void *)(& pmlmeinfo->WMM_param), (void const *)p + 8U,
                             __len);
  }
  return (1);
}
}
void WMMOnAssocRsp23a(struct rtw_adapter *padapter )
{
  u8 ACI ;
  u8 ACM ;
  u8 AIFS ;
  u8 ECWMin ;
  u8 ECWMax ;
  u8 aSifsTime ;
  u8 acm_mask ;
  u16 TXOP ;
  u32 acParm ;
  u32 i ;
  u32 edca[4U] ;
  u32 inx[4U] ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct xmit_priv *pxmitpriv ;
  struct registry_priv *pregpriv ;
  u32 j ;
  u32 tmp ;
  u32 change_inx ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pxmitpriv = & padapter->xmitpriv;
  pregpriv = & padapter->registrypriv;
  if ((unsigned int )pmlmeinfo->WMM_enable == 0U) {
    padapter->mlmepriv.acm_mask = 0U;
    return;
  } else {
  }
  acm_mask = 0U;
  if ((unsigned int )pmlmeext->cur_wireless_mode == 1U) {
    aSifsTime = 10U;
  } else {
    aSifsTime = 16U;
  }
  i = 0U;
  goto ldv_51677;
  ldv_51676:
  ACI = (unsigned int )((u8 )((int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5)) & 3U;
  ACM = (unsigned int )((u8 )((int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4)) & 1U;
  AIFS = ((unsigned int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 15U) * (unsigned int )pmlmeinfo->slotTime + (unsigned int )aSifsTime;
  ECWMin = (unsigned int )pmlmeinfo->WMM_param.ac_param[i].CW & 15U;
  ECWMax = (u8 )((int )pmlmeinfo->WMM_param.ac_param[i].CW >> 4);
  TXOP = pmlmeinfo->WMM_param.ac_param[i].TXOP_limit;
  acParm = (u32 )((((int )AIFS | ((int )ECWMin << 8)) | ((int )ECWMax << 12)) | ((int )TXOP << 16));
  switch ((int )ACI) {
  case 0:
  rtl8723a_set_ac_param_be(padapter, acParm);
  acm_mask = ((unsigned int )ACM != 0U ? 2U : 0U) | (unsigned int )acm_mask;
  edca[2] = acParm;
  goto ldv_51672;
  case 1:
  rtl8723a_set_ac_param_bk(padapter, acParm);
  edca[3] = acParm;
  goto ldv_51672;
  case 2:
  rtl8723a_set_ac_param_vi(padapter, acParm);
  acm_mask = ((unsigned int )ACM != 0U ? 4U : 0U) | (unsigned int )acm_mask;
  edca[1] = acParm;
  goto ldv_51672;
  case 3:
  rtl8723a_set_ac_param_vo(padapter, acParm);
  acm_mask = ((unsigned int )ACM != 0U ? 8U : 0U) | (unsigned int )acm_mask;
  edca[0] = acParm;
  goto ldv_51672;
  }
  ldv_51672: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: WMM(%x): %x, %x\n", (int )ACI, (int )ACM, acParm);
  } else {
  }
  i = i + 1U;
  ldv_51677: ;
  if (i <= 3U) {
    goto ldv_51676;
  } else {
  }
  if ((unsigned int )padapter->registrypriv.acm_method == 1U) {
    rtl8723a_set_acm_ctrl(padapter, (int )acm_mask);
  } else {
    padapter->mlmepriv.acm_mask = acm_mask;
  }
  inx[0] = 0U;
  inx[1] = 1U;
  inx[2] = 2U;
  inx[3] = 3U;
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
    change_inx = 0U;
    i = 0U;
    goto ldv_51686;
    ldv_51685:
    j = i + 1U;
    goto ldv_51683;
    ldv_51682: ;
    if ((edca[j] & 65535U) < (edca[i] & 65535U)) {
      change_inx = 1U;
    } else
    if (((edca[j] ^ edca[i]) & 65535U) == 0U) {
      if (edca[j] >> 16 > edca[i] >> 16) {
        change_inx = 1U;
      } else {
      }
    } else {
    }
    if (change_inx != 0U) {
      tmp = edca[i];
      edca[i] = edca[j];
      edca[j] = tmp;
      tmp = inx[i];
      inx[i] = inx[j];
      inx[j] = tmp;
      change_inx = 0U;
    } else {
    }
    j = j + 1U;
    ldv_51683: ;
    if (j <= 3U) {
      goto ldv_51682;
    } else {
    }
    i = i + 1U;
    ldv_51686: ;
    if (i <= 3U) {
      goto ldv_51685;
    } else {
    }
  } else {
  }
  i = 0U;
  goto ldv_51689;
  ldv_51688:
  pxmitpriv->wmm_para_seq[i] = (u8 )inx[i];
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: wmm_para_seq(%d): %d\n", i, (int )pxmitpriv->wmm_para_seq[i]);
  } else {
  }
  i = i + 1U;
  ldv_51689: ;
  if (i <= 3U) {
    goto ldv_51688;
  } else {
  }
  return;
}
}
static void bwmode_update_check(struct rtw_adapter *padapter , u8 *p )
{
  struct HT_info_element *pHT_info ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct registry_priv *pregistrypriv ;
  struct ht_priv *phtpriv ;
  unsigned char new_bwmode ;
  unsigned char new_ch_offset ;
  struct sta_info *psta ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_priv *pstapriv ;
  struct ht_priv *phtpriv_sta ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pregistrypriv = & padapter->registrypriv;
  phtpriv = & pmlmepriv->htpriv;
  if ((unsigned long )p == (unsigned long )((u8 *)0U)) {
    return;
  } else {
  }
  if (phtpriv->ht_option == 0U) {
    return;
  } else {
  }
  if ((unsigned int )*(p + 1UL) > 22U) {
    return;
  } else {
  }
  pHT_info = (struct HT_info_element *)p + 2U;
  if (((unsigned long )pHT_info->infos[0] & 4UL) != 0UL && (unsigned int )pregistrypriv->cbw40_enable != 0U) {
    new_bwmode = 1U;
    switch ((int )pHT_info->infos[0] & 3) {
    case 1:
    new_ch_offset = 1U;
    goto ldv_51704;
    case 3:
    new_ch_offset = 2U;
    goto ldv_51704;
    default:
    new_ch_offset = 0U;
    goto ldv_51704;
    }
    ldv_51704: ;
  } else {
    new_bwmode = 0U;
    new_ch_offset = 0U;
  }
  if ((int )pmlmeext->cur_bwmode != (int )new_bwmode || (int )pmlmeext->cur_ch_offset != (int )new_ch_offset) {
    pmlmeinfo->bwmode_updated = 1U;
    pmlmeext->cur_bwmode = new_bwmode;
    pmlmeext->cur_ch_offset = new_ch_offset;
    HT_info_handler23a(padapter, p);
  } else {
    pmlmeinfo->bwmode_updated = 0U;
  }
  if ((unsigned int )pmlmeinfo->bwmode_updated != 0U) {
    cur_network = & pmlmeinfo->network;
    pstapriv = & padapter->stapriv;
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& cur_network->MacAddress));
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      phtpriv_sta = & psta->htpriv;
      if (phtpriv_sta->ht_option != 0U) {
        phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
        phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
      } else {
        phtpriv_sta->bwmode = 0U;
        phtpriv_sta->ch_offset = 0U;
      }
    } else {
    }
  } else {
  }
  return;
}
}
void HT_caps_handler23a(struct rtw_adapter *padapter , u8 *p )
{
  unsigned int i ;
  u8 rf_type ;
  u8 max_AMPDU_len ;
  u8 min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  if ((unsigned long )p == (unsigned long )((u8 *)0U)) {
    return;
  } else {
  }
  if (phtpriv->ht_option == 0U) {
    return;
  } else {
  }
  pmlmeinfo->HT_caps_enable = 1U;
  i = 0U;
  goto ldv_51724;
  ldv_51723: ;
  if (i != 2U) {
    pmlmeinfo->HT_caps.u.HT_cap[i] = (int )pmlmeinfo->HT_caps.u.HT_cap[i] & (int )*(p + (unsigned long )(i + 2U));
  } else {
    if (((int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 3) > ((int )*(p + (unsigned long )(i + 2U)) & 3)) {
      max_AMPDU_len = (unsigned int )*(p + (unsigned long )(i + 2U)) & 3U;
    } else {
      max_AMPDU_len = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 3U;
    }
    if (((int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 28) > ((int )*(p + (unsigned long )(i + 2U)) & 28)) {
      min_MPDU_spacing = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 28U;
    } else {
      min_MPDU_spacing = (unsigned int )*(p + (unsigned long )(i + 2U)) & 28U;
    }
    pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para = (int )max_AMPDU_len | (int )min_MPDU_spacing;
  }
  i = i + 1U;
  ldv_51724: ;
  if ((unsigned int )*(p + 1UL) > i) {
    goto ldv_51723;
  } else {
  }
  pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info;
  pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps;
  rf_type = rtl8723a_get_rf_type(padapter);
  i = 0U;
  goto ldv_51727;
  ldv_51726: ;
  if ((unsigned int )rf_type == 3U || (unsigned int )rf_type == 0U) {
    pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] = (int )pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] & (int )MCS_rate_1R23A[i];
  } else {
    pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] = (int )pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] & (int )MCS_rate_2R23A[i];
  }
  i = i + 1U;
  ldv_51727: ;
  if (i <= 15U) {
    goto ldv_51726;
  } else {
  }
  return;
}
}
void HT_info_handler23a(struct rtw_adapter *padapter , u8 *p )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  size_t __len ;
  void *__ret ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv = & pmlmepriv->htpriv;
  if ((unsigned long )p == (unsigned long )((u8 *)0U)) {
    return;
  } else {
  }
  if (phtpriv->ht_option == 0U) {
    return;
  } else {
  }
  if ((unsigned int )*(p + 1UL) > 22U) {
    return;
  } else {
  }
  pmlmeinfo->HT_info_enable = 1U;
  __len = (size_t )*(p + 1UL);
  __ret = memcpy((void *)(& pmlmeinfo->HT_info), (void const *)p + 2U,
                           __len);
  return;
}
}
void HTOnAssocRsp23a(struct rtw_adapter *padapter )
{
  unsigned char max_AMPDU_len ;
  unsigned char min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "HTOnAssocRsp23a");
  } else {
  }
  if ((unsigned int )pmlmeinfo->HT_info_enable != 0U && (unsigned int )pmlmeinfo->HT_caps_enable != 0U) {
    pmlmeinfo->HT_enable = 1U;
  } else {
    pmlmeinfo->HT_enable = 0U;
    return;
  }
  max_AMPDU_len = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 3U;
  min_MPDU_spacing = (unsigned char )(((int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 28) >> 2);
  rtl8723a_set_ampdu_min_space(padapter, (int )min_MPDU_spacing);
  rtl8723a_set_ampdu_factor(padapter, (int )max_AMPDU_len);
  return;
}
}
void ERP_IE_handler23a(struct rtw_adapter *padapter , u8 *p )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )*(p + 1UL) > 1U) {
    return;
  } else {
  }
  pmlmeinfo->ERP_enable = 1U;
  __len = (size_t )*(p + 1UL);
  __ret = memcpy((void *)(& pmlmeinfo->ERP_IE), (void const *)p + 2U,
                           __len);
  return;
}
}
void VCS_update23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pregpriv = & padapter->registrypriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  switch ((int )pregpriv->vrtl_carrier_sense) {
  case 0:
  psta->rtsen = 0U;
  psta->cts2self = 0U;
  goto ldv_51765;
  case 1: ;
  if ((unsigned int )pregpriv->vcs_type == 1U) {
    psta->rtsen = 1U;
    psta->cts2self = 0U;
  } else {
    psta->rtsen = 0U;
    psta->cts2self = 1U;
  }
  goto ldv_51765;
  case 2: ;
  default: ;
  if ((unsigned int )pmlmeinfo->ERP_enable != 0U && ((unsigned long )pmlmeinfo->ERP_IE & 2UL) != 0UL) {
    if ((unsigned int )pregpriv->vcs_type == 1U) {
      psta->rtsen = 1U;
      psta->cts2self = 0U;
    } else {
      psta->rtsen = 0U;
      psta->cts2self = 1U;
    }
  } else {
    psta->rtsen = 0U;
    psta->cts2self = 0U;
  }
  goto ldv_51765;
  }
  ldv_51765: ;
  return;
}
}
int rtw_check_bcn_info23a(struct rtw_adapter *Adapter , struct ieee80211_mgmt *mgmt ,
                          u32 pkt_len )
{
  struct wlan_network *cur_network ;
  struct HT_info_element *pht_info ;
  struct ieee80211_ht_cap *pht_cap ;
  struct wlan_bssid_ex *bssid ;
  unsigned short val16 ;
  u16 wpa_len ;
  u16 rsn_len ;
  u8 encryp_protocol ;
  int group_cipher ;
  int pairwise_cipher ;
  int is_8021x ;
  int r ;
  u32 bcn_channel ;
  unsigned short ht_cap_info ;
  unsigned char ht_info_infos_0 ;
  int len ;
  int pie_len ;
  int ie_offset ;
  u8 const *p ;
  u8 *pie ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___5 ;
  {
  cur_network = & Adapter->mlmepriv.cur_network;
  wpa_len = 0U;
  rsn_len = 0U;
  group_cipher = 0;
  pairwise_cipher = 0;
  is_8021x = 0;
  tmp = is_client_associated_to_ap23a(Adapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (1);
  } else {
  }
  tmp___1 = ieee80211_is_beacon((int )mgmt->frame_control);
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
  if (tmp___2 != 0L) {
    printk("\f%s: received a non beacon frame!\n", "rtw_check_bcn_info23a");
    return (0);
  } else {
  }
  len = (int )(pkt_len - 24U);
  if (len > 768) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s IE too long for survey event\n", "rtw_check_bcn_info23a");
    } else {
    }
    return (0);
  } else {
  }
  tmp___3 = memcmp((void const *)(& cur_network->network.MacAddress), (void const *)(& mgmt->bssid),
                   6UL);
  if (tmp___3 != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Oops: rtw_check_network_encrypt linked but recv other bssid bcn\n%02x:%02x:%02x:%02x:%02x:%02x%02x:%02x:%02x:%02x:%02x:%02x",
             (int )*((u8 *)(& mgmt->bssid)), (int )*((u8 *)(& mgmt->bssid) + 1UL),
             (int )*((u8 *)(& mgmt->bssid) + 2UL), (int )*((u8 *)(& mgmt->bssid) + 3UL),
             (int )*((u8 *)(& mgmt->bssid) + 4UL), (int )*((u8 *)(& mgmt->bssid) + 5UL),
             (int )*((u8 *)(& cur_network->network.MacAddress)), (int )*((u8 *)(& cur_network->network.MacAddress) + 1UL),
             (int )*((u8 *)(& cur_network->network.MacAddress) + 2UL), (int )*((u8 *)(& cur_network->network.MacAddress) + 3UL),
             (int )*((u8 *)(& cur_network->network.MacAddress) + 4UL), (int )*((u8 *)(& cur_network->network.MacAddress) + 5UL));
    } else {
    }
    return (1);
  } else {
  }
  tmp___4 = kzalloc(863UL, 32U);
  bssid = (struct wlan_bssid_ex *)tmp___4;
  if ((unsigned long )bssid == (unsigned long )((struct wlan_bssid_ex *)0)) {
    return (0);
  } else {
  }
  bssid->reserved = 1U;
  bssid->Length = (u32 )len + 95U;
  bssid->IELength = (u32 )len;
  __len = (size_t )len;
  __ret = memcpy((void *)(& bssid->IEs), (void const *)(& mgmt->u), __len);
  ie_offset = 12;
  pie = (u8 *)(& bssid->IEs) + (unsigned long )ie_offset;
  pie_len = (int )(pkt_len - (u32 )ie_offset);
  p = cfg80211_find_ie(45, (u8 const *)pie, pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_cap = (struct ieee80211_ht_cap *)p + 2U;
    ht_cap_info = pht_cap->cap_info;
  } else {
    pht_cap = (struct ieee80211_ht_cap *)0;
    ht_cap_info = 0U;
  }
  p = cfg80211_find_ie(61, (u8 const *)pie, pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_info = (struct HT_info_element *)p + 2U;
    ht_info_infos_0 = pht_info->infos[0];
  } else {
    pht_info = (struct HT_info_element *)0;
    ht_info_infos_0 = 0U;
  }
  if ((int )cur_network->BcnInfo.ht_cap_info != (int )ht_cap_info || (((int )ht_info_infos_0 ^ (int )cur_network->BcnInfo.ht_info_infos_0) & 3) != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s bcn now: ht_cap_info:%x ht_info_infos_0:%x\n", "rtw_check_bcn_info23a",
             (int )ht_cap_info, (int )ht_info_infos_0);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s bcn link: ht_cap_info:%x ht_info_infos_0:%x\n", "rtw_check_bcn_info23a",
             (int )cur_network->BcnInfo.ht_cap_info, (int )cur_network->BcnInfo.ht_info_infos_0);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s bw mode change, disconnect\n", "rtw_check_bcn_info23a");
    } else {
    }
    cur_network->BcnInfo.ht_cap_info = ht_cap_info;
    cur_network->BcnInfo.ht_info_infos_0 = ht_info_infos_0;
  } else {
  }
  p = cfg80211_find_ie(3, (u8 const *)pie, pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
    bcn_channel = (u32 )*(p + 2UL);
  } else {
    p = cfg80211_find_ie(61, (u8 const *)pie, pie_len);
    if ((unsigned long )pht_info != (unsigned long )((struct HT_info_element *)0)) {
      bcn_channel = (u32 )pht_info->primary_channel;
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Oops: %s we don\'t find channel IE, so don\'t check it\n",
               "rtw_check_bcn_info23a");
      } else {
      }
      bcn_channel = (u32 )Adapter->mlmeextpriv.cur_channel;
    }
  }
  if ((u32 )Adapter->mlmeextpriv.cur_channel != bcn_channel) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s beacon channel:%d cur channel:%d disconnect\n", "rtw_check_bcn_info23a",
             bcn_channel, (int )Adapter->mlmeextpriv.cur_channel);
    } else {
    }
    goto _mismatch;
  } else {
  }
  p = cfg80211_find_ie(0, (u8 const *)pie, pie_len);
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    __len___0 = (size_t )*(p + 1UL);
    __ret___0 = memcpy((void *)(& bssid->Ssid.ssid), (void const *)p + 2U,
                                 __len___0);
    bssid->Ssid.ssid_len = *(p + 1UL);
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s marc: cannot find SSID for survey event\n", "rtw_check_bcn_info23a");
    } else {
    }
    bssid->Ssid.ssid_len = 0U;
    bssid->Ssid.ssid[0] = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016%s bssid.Ssid.Ssid:%s bssid.Ssid.SsidLength:%d cur_network->network.Ssid.Ssid:%s len:%d\n",
           "rtw_check_bcn_info23a", (u8 *)(& bssid->Ssid.ssid), (int )bssid->Ssid.ssid_len,
           (u8 *)(& cur_network->network.Ssid.ssid), (int )cur_network->network.Ssid.ssid_len);
  } else {
  }
  tmp___5 = memcmp((void const *)(& bssid->Ssid.ssid), (void const *)(& cur_network->network.Ssid.ssid),
                   32UL);
  if (tmp___5 != 0 || (int )bssid->Ssid.ssid_len != (int )cur_network->network.Ssid.ssid_len) {
    if ((unsigned int )bssid->Ssid.ssid[0] != 0U && (unsigned int )bssid->Ssid.ssid_len != 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(), SSID is not match return FAIL\n", "rtw_check_bcn_info23a");
      } else {
      }
      goto _mismatch;
    } else {
    }
  } else {
  }
  val16 = rtw_get_capability23a(bssid);
  if (((unsigned long )val16 & 16UL) != 0UL) {
    bssid->Privacy = 1U;
  } else {
    bssid->Privacy = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016%s(): cur_network->network.Privacy is %d, bssid.Privacy is %d\n",
           "rtw_check_bcn_info23a", cur_network->network.Privacy, bssid->Privacy);
  } else {
  }
  if (cur_network->network.Privacy != bssid->Privacy) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(), privacy is not match return FAIL\n", "rtw_check_bcn_info23a");
    } else {
    }
    goto _mismatch;
  } else {
  }
  rtw_get_sec_ie23a((u8 *)(& bssid->IEs), bssid->IELength, (u8 *)0U, & rsn_len, (u8 *)0U,
                    & wpa_len);
  if ((unsigned int )rsn_len != 0U) {
    encryp_protocol = 3U;
  } else
  if ((unsigned int )wpa_len != 0U) {
    encryp_protocol = 2U;
  } else
  if (bssid->Privacy != 0U) {
    encryp_protocol = 1U;
  } else {
    encryp_protocol = 0U;
  }
  if ((int )cur_network->BcnInfo.encryp_protocol != (int )encryp_protocol) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): enctyp is not match, return FAIL\n", "rtw_check_bcn_info23a");
    } else {
    }
    goto _mismatch;
  } else {
  }
  if ((unsigned int )encryp_protocol == 2U || (unsigned int )encryp_protocol == 3U) {
    p = cfg80211_find_vendor_ie(20722U, 1, (u8 const *)pie, pie_len);
    if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
      r = rtw_parse_wpa_ie23a(p, (int )*(p + 1UL) + 2, & group_cipher, & pairwise_cipher,
                              & is_8021x);
      if (r == 1) {
        if (GlobalDebugLevel23A > 6U) {
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
          printk("\016%s pnetwork->pairwise_cipher: %d, group_cipher is %d, is_8021x is %d\n",
                 "rtw_check_bcn_info23a", pairwise_cipher, group_cipher, is_8021x);
        } else {
        }
      } else {
      }
    } else {
      p = cfg80211_find_ie(48, (u8 const *)pie, pie_len);
      if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
        r = rtw_parse_wpa2_ie23a(p, (int )*(p + 1UL) + 2, & group_cipher, & pairwise_cipher,
                                 & is_8021x);
        if (r == 1) {
          if (GlobalDebugLevel23A > 6U) {
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
            printk("\016%s pnetwork->pairwise_cipher: %d, pnetwork->group_cipher is %d, is_802x is %d\n",
                   "rtw_check_bcn_info23a", pairwise_cipher, group_cipher, is_8021x);
          } else {
          }
        } else {
        }
      } else {
      }
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
      printk("\016%s cur_network->group_cipher is %d: %d\n", "rtw_check_bcn_info23a",
             cur_network->BcnInfo.group_cipher, group_cipher);
    } else {
    }
    if (cur_network->BcnInfo.pairwise_cipher != pairwise_cipher || cur_network->BcnInfo.group_cipher != group_cipher) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s pairwise_cipher(%x:%x) or group_cipher (%x:%x) is not match, return FAIL\n",
               "rtw_check_bcn_info23a", pairwise_cipher, cur_network->BcnInfo.pairwise_cipher,
               group_cipher, cur_network->BcnInfo.group_cipher);
      } else {
      }
      goto _mismatch;
    } else {
    }
    if (cur_network->BcnInfo.is_8021x != is_8021x) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s authentication is not match, return FAIL\n", "rtw_check_bcn_info23a");
      } else {
      }
      goto _mismatch;
    } else {
    }
  } else {
  }
  kfree((void const *)bssid);
  return (1);
  _mismatch:
  kfree((void const *)bssid);
  return (0);
}
}
void update_beacon23a_info(struct rtw_adapter *padapter , u8 *pframe , uint pkt_len ,
                           struct sta_info *psta )
{
  unsigned int i ;
  unsigned int len ;
  u8 *p ;
  {
  len = pkt_len - 36U;
  i = 0U;
  goto ldv_51816;
  ldv_51815:
  p = pframe + ((unsigned long )i + 36UL);
  switch ((int )*p) {
  case 61:
  bwmode_update_check(padapter, p);
  goto ldv_51812;
  case 42:
  ERP_IE_handler23a(padapter, p);
  VCS_update23a(padapter, psta);
  goto ldv_51812;
  default: ;
  goto ldv_51812;
  }
  ldv_51812:
  i = ((unsigned int )*(p + 1UL) + i) + 2U;
  ldv_51816: ;
  if (i < len) {
    goto ldv_51815;
  } else {
  }
  return;
}
}
bool is_ap_in_tkip23a(struct rtw_adapter *padapter )
{
  u32 i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 const *p ;
  int bcn_fixed_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u16 tmp___2 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  bcn_fixed_size = 12;
  tmp___2 = rtw_get_capability23a(cur_network);
  if (((int )tmp___2 & 16) != 0) {
    i = (u32 )bcn_fixed_size;
    goto ldv_51832;
    ldv_51831:
    p = (u8 const *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
    switch ((int )*p) {
    case 221:
    tmp = memcmp((void const *)p + 2U, (void const *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
    if (tmp == 0) {
      tmp___0 = memcmp((void const *)p + 14U, (void const *)(& WPA_TKIP_CIPHER),
                       4UL);
      if (tmp___0 == 0) {
        return (1);
      } else {
      }
    } else {
    }
    goto ldv_51828;
    case 48:
    tmp___1 = memcmp((void const *)p + 10U, (void const *)(& RSN_TKIP_CIPHER),
                     4UL);
    if (tmp___1 == 0) {
      return (1);
    } else {
    }
    goto ldv_51828;
    default: ;
    goto ldv_51828;
    }
    ldv_51828:
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_51832: ;
    if (pmlmeinfo->network.IELength > i) {
      goto ldv_51831;
    } else {
    }
    return (0);
  } else {
    return (0);
  }
}
}
bool should_forbid_n_rate23a(struct rtw_adapter *padapter )
{
  u32 i ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *cur_network ;
  u8 const *p ;
  int bcn_fixed_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u16 tmp___4 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network.network;
  bcn_fixed_size = 12;
  tmp___4 = rtw_get_capability23a(cur_network);
  if (((int )tmp___4 & 16) != 0) {
    i = (u32 )bcn_fixed_size;
    goto ldv_51847;
    ldv_51846:
    p = (u8 const *)(& cur_network->IEs) + (unsigned long )i;
    switch ((int )*p) {
    case 221:
    tmp = memcmp((void const *)p + 2U, (void const *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
    if (tmp == 0) {
      tmp___0 = memcmp((void const *)p + 14U, (void const *)(& WPA_CIPHER_SUITE_CCMP23A),
                       4UL);
      if (tmp___0 == 0) {
        return (0);
      } else {
        tmp___1 = memcmp((void const *)p + 18U, (void const *)(& WPA_CIPHER_SUITE_CCMP23A),
                         4UL);
        if (tmp___1 == 0) {
          return (0);
        } else {
        }
      }
    } else {
    }
    goto ldv_51843;
    case 48:
    tmp___2 = memcmp((void const *)p + 10U, (void const *)(& RSN_CIPHER_SUITE_CCMP23A),
                     4UL);
    if (tmp___2 == 0) {
      return (0);
    } else {
      tmp___3 = memcmp((void const *)p + 14U, (void const *)(& RSN_CIPHER_SUITE_CCMP23A),
                       4UL);
      if (tmp___3 == 0) {
        return (0);
      } else {
      }
    }
    default: ;
    goto ldv_51843;
    }
    ldv_51843:
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_51847: ;
    if (cur_network->IELength > i) {
      goto ldv_51846;
    } else {
    }
    return (1);
  } else {
    return (0);
  }
}
}
bool is_ap_in_wep23a(struct rtw_adapter *padapter )
{
  u32 i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 const *p ;
  int bcn_fixed_size ;
  int tmp ;
  u16 tmp___0 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  bcn_fixed_size = 12;
  tmp___0 = rtw_get_capability23a(cur_network);
  if (((int )tmp___0 & 16) != 0) {
    i = (u32 )bcn_fixed_size;
    goto ldv_51863;
    ldv_51862:
    p = (u8 const *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
    switch ((int )*p) {
    case 221:
    tmp = memcmp((void const *)p + 2U, (void const *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
    if (tmp == 0) {
      return (0);
    } else {
    }
    goto ldv_51859;
    case 48: ;
    return (0);
    default: ;
    goto ldv_51859;
    }
    ldv_51859:
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_51863: ;
    if (pmlmeinfo->network.IELength > i) {
      goto ldv_51862;
    } else {
    }
    return (1);
  } else {
    return (0);
  }
}
}
static int wifirate2_ratetbl_inx23a(unsigned char rate )
{
  int inx ;
  {
  inx = 0;
  rate = (unsigned int )rate & 127U;
  switch ((int )rate) {
  case 108:
  inx = 11;
  goto ldv_51870;
  case 96:
  inx = 10;
  goto ldv_51870;
  case 72:
  inx = 9;
  goto ldv_51870;
  case 48:
  inx = 8;
  goto ldv_51870;
  case 36:
  inx = 7;
  goto ldv_51870;
  case 24:
  inx = 6;
  goto ldv_51870;
  case 18:
  inx = 5;
  goto ldv_51870;
  case 12:
  inx = 4;
  goto ldv_51870;
  case 22:
  inx = 3;
  goto ldv_51870;
  case 11:
  inx = 2;
  goto ldv_51870;
  case 4:
  inx = 1;
  goto ldv_51870;
  case 2:
  inx = 0;
  goto ldv_51870;
  }
  ldv_51870: ;
  return (inx);
}
}
unsigned int update_basic_rate23a(unsigned char *ptn , unsigned int ptn_sz )
{
  unsigned int i ;
  unsigned int num_of_rate ;
  unsigned int mask ;
  int tmp ;
  {
  mask = 0U;
  num_of_rate = 13U < ptn_sz ? 13U : ptn_sz;
  i = 0U;
  goto ldv_51890;
  ldv_51889: ;
  if ((int )((signed char )*(ptn + (unsigned long )i)) < 0) {
    tmp = wifirate2_ratetbl_inx23a((int )*(ptn + (unsigned long )i));
    mask = (unsigned int )(1 << tmp) | mask;
  } else {
  }
  i = i + 1U;
  ldv_51890: ;
  if (i < num_of_rate) {
    goto ldv_51889;
  } else {
  }
  return (mask);
}
}
unsigned int update_supported_rate23a(unsigned char *ptn , unsigned int ptn_sz )
{
  unsigned int i ;
  unsigned int num_of_rate ;
  unsigned int mask ;
  int tmp ;
  {
  mask = 0U;
  num_of_rate = 13U < ptn_sz ? 13U : ptn_sz;
  i = 0U;
  goto ldv_51900;
  ldv_51899:
  tmp = wifirate2_ratetbl_inx23a((int )*(ptn + (unsigned long )i));
  mask = (unsigned int )(1 << tmp) | mask;
  i = i + 1U;
  ldv_51900: ;
  if (i < num_of_rate) {
    goto ldv_51899;
  } else {
  }
  return (mask);
}
}
unsigned int update_MSC_rate23a(struct HT_caps_element *pHT_caps )
{
  unsigned int mask ;
  {
  mask = 0U;
  mask = (unsigned int )(((int )pHT_caps->u.HT_cap_element.MCS_rate[0] << 12) | ((int )pHT_caps->u.HT_cap_element.MCS_rate[1] << 20));
  return (mask);
}
}
int support_short_GI23a(struct rtw_adapter *padapter , struct HT_caps_element *pHT_caps )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char bit_offset ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )pmlmeinfo->HT_enable == 0U) {
    return (0);
  } else {
  }
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 4U) {
    return (0);
  } else {
  }
  bit_offset = (int )pmlmeext->cur_bwmode & 1 ? 6U : 5U;
  if (((int )pHT_caps->u.HT_cap_element.HT_caps_info >> (int )bit_offset) & 1) {
    return (1);
  } else {
    return (0);
  }
}
}
unsigned char get_highest_rate_idx23a(u32 mask )
{
  int i ;
  unsigned char rate_idx ;
  {
  rate_idx = 0U;
  i = 27;
  goto ldv_51920;
  ldv_51919: ;
  if ((int )((unsigned long )mask >> i) & 1) {
    rate_idx = (unsigned char )i;
    goto ldv_51918;
  } else {
  }
  i = i - 1;
  ldv_51920: ;
  if (i >= 0) {
    goto ldv_51919;
  } else {
  }
  ldv_51918: ;
  return (rate_idx);
}
}
void Update_RA_Entry23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  {
  rtw_hal_update_ra_mask23a(psta, 0);
  return;
}
}
static void enable_rate_adaptive(struct rtw_adapter *padapter , struct sta_info *psta )
{
  {
  Update_RA_Entry23a(padapter, psta);
  return;
}
}
void set_sta_rate23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  {
  enable_rate_adaptive(padapter, psta);
  return;
}
}
void update_tx_basic_rate23a(struct rtw_adapter *padapter , u8 wirelessmode )
{
  unsigned char supported_rates[16U] ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  {
  memset((void *)(& supported_rates), 0, 16UL);
  if ((unsigned int )wirelessmode == 1U) {
    __len = 4UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& supported_rates), (void const *)(& rtw_basic_rate_cck),
                       __len);
    } else {
      __ret = memcpy((void *)(& supported_rates), (void const *)(& rtw_basic_rate_cck),
                               __len);
    }
  } else
  if ((int )wirelessmode & 1) {
    __len___0 = 7UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& supported_rates), (void const *)(& rtw_basic_rate_mix),
                           __len___0);
    } else {
      __ret___0 = memcpy((void *)(& supported_rates), (void const *)(& rtw_basic_rate_mix),
                                   __len___0);
    }
  } else {
    __len___1 = 3UL;
    if (__len___1 > 63UL) {
      __ret___1 = memcpy((void *)(& supported_rates), (void const *)(& rtw_basic_rate_ofdm),
                           __len___1);
    } else {
      __ret___1 = memcpy((void *)(& supported_rates), (void const *)(& rtw_basic_rate_ofdm),
                                   __len___1);
    }
  }
  if ((int )wirelessmode & 1) {
    update_mgnt_tx_rate23a(padapter, 2);
  } else {
    update_mgnt_tx_rate23a(padapter, 12);
  }
  HalSetBrateCfg23a(padapter, (u8 *)(& supported_rates));
  return;
}
}
unsigned char check_assoc_AP23a(u8 *pframe , uint len )
{
  int i ;
  int bcn_fixed_size ;
  u8 epigram_vendor_flag ;
  u8 ralink_vendor_flag ;
  u8 const *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  {
  epigram_vendor_flag = 0U;
  ralink_vendor_flag = 0U;
  bcn_fixed_size = 12;
  i = bcn_fixed_size;
  goto ldv_51960;
  ldv_51959:
  p = (u8 const *)pframe + (unsigned long )i;
  switch ((int )*p) {
  case 221:
  tmp___8 = memcmp((void const *)p + 2U, (void const *)(& ARTHEROS_OUI1), 3UL);
  if (tmp___8 == 0) {
    goto _L___0;
  } else {
    tmp___9 = memcmp((void const *)p + 2U, (void const *)(& ARTHEROS_OUI2), 3UL);
    if (tmp___9 == 0) {
      _L___0:
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: link to Artheros AP\n");
      } else {
      }
      return (5U);
    } else {
      tmp___5 = memcmp((void const *)p + 2U, (void const *)(& BROADCOM_OUI1),
                       3UL);
      if (tmp___5 == 0) {
        goto _L;
      } else {
        tmp___6 = memcmp((void const *)p + 2U, (void const *)(& BROADCOM_OUI2),
                         3UL);
        if (tmp___6 == 0) {
          goto _L;
        } else {
          tmp___7 = memcmp((void const *)p + 2U, (void const *)(& BROADCOM_OUI2),
                           3UL);
          if (tmp___7 == 0) {
            _L:
            if (GlobalDebugLevel23A > 3U) {
              printk("\016RTL8723AU: link to Broadcom AP\n");
            } else {
            }
            return (3U);
          } else {
            tmp___4 = memcmp((void const *)p + 2U, (void const *)(& MARVELL_OUI),
                             3UL);
            if (tmp___4 == 0) {
              if (GlobalDebugLevel23A > 3U) {
                printk("\016RTL8723AU: link to Marvell AP\n");
              } else {
              }
              return (8U);
            } else {
              tmp___3 = memcmp((void const *)p + 2U, (void const *)(& RALINK_OUI),
                               3UL);
              if (tmp___3 == 0) {
                if ((unsigned int )ralink_vendor_flag == 0U) {
                  ralink_vendor_flag = 1U;
                } else {
                  if (GlobalDebugLevel23A > 3U) {
                    printk("\016RTL8723AU: link to Ralink AP\n");
                  } else {
                  }
                  return (4U);
                }
              } else {
                tmp___2 = memcmp((void const *)p + 2U, (void const *)(& CISCO_OUI),
                                 3UL);
                if (tmp___2 == 0) {
                  if (GlobalDebugLevel23A > 3U) {
                    printk("\016RTL8723AU: link to Cisco AP\n");
                  } else {
                  }
                  return (6U);
                } else {
                  tmp___1 = memcmp((void const *)p + 2U, (void const *)(& REALTEK_OUI),
                                   3UL);
                  if (tmp___1 == 0) {
                    if (GlobalDebugLevel23A > 3U) {
                      printk("\016RTL8723AU: link to Realtek 96B\n");
                    } else {
                    }
                    return (1U);
                  } else {
                    tmp___0 = memcmp((void const *)p + 2U, (void const *)(& AIRGOCAP_OUI),
                                     3UL);
                    if (tmp___0 == 0) {
                      if (GlobalDebugLevel23A > 3U) {
                        printk("\016RTL8723AU: link to Airgo Cap\n");
                      } else {
                      }
                      return (11U);
                    } else {
                      tmp = memcmp((void const *)p + 2U, (void const *)(& EPIGRAM_OUI),
                                   3UL);
                      if (tmp == 0) {
                        epigram_vendor_flag = 1U;
                        if ((unsigned int )ralink_vendor_flag != 0U) {
                          if (GlobalDebugLevel23A > 3U) {
                            printk("\016RTL8723AU: link to Tenda W311R AP\n");
                          } else {
                          }
                          return (16U);
                        } else
                        if (GlobalDebugLevel23A > 3U) {
                          printk("\016RTL8723AU: Capture EPIGRAM_OUI\n");
                        } else {
                        }
                      } else {
                        goto ldv_51957;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  default: ;
  goto ldv_51957;
  }
  ldv_51957:
  i = ((int )*(p + 1UL) + 2) + i;
  ldv_51960: ;
  if ((uint )i < len) {
    goto ldv_51959;
  } else {
  }
  if ((unsigned int )ralink_vendor_flag != 0U && (unsigned int )epigram_vendor_flag == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link to Ralink AP\n");
    } else {
    }
    return (4U);
  } else
  if ((unsigned int )ralink_vendor_flag != 0U && (unsigned int )epigram_vendor_flag != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link to Tenda W311R AP\n");
    } else {
    }
    return (16U);
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: link to new AP\n");
    } else {
    }
    return (0U);
  }
}
}
void update_IOT_info23a(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  switch ((int )pmlmeinfo->assoc_AP_vendor) {
  case 8:
  pmlmeinfo->turboMode_cts2self = 1U;
  pmlmeinfo->turboMode_rtsen = 0U;
  goto ldv_51968;
  case 4:
  pmlmeinfo->turboMode_cts2self = 0U;
  pmlmeinfo->turboMode_rtsen = 1U;
  rtl8723a_odm_support_ability_clr(padapter, 4294967291U);
  goto ldv_51968;
  case 1:
  rtl8723a_odm_support_ability_clr(padapter, 4294967291U);
  goto ldv_51968;
  default:
  pmlmeinfo->turboMode_cts2self = 0U;
  pmlmeinfo->turboMode_rtsen = 1U;
  goto ldv_51968;
  }
  ldv_51968: ;
  return;
}
}
void update_capinfo23a(struct rtw_adapter *Adapter , u16 updateCap )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pmlmeext = & Adapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (((int )updateCap & 32) != 0) {
    if ((unsigned int )pmlmeinfo->preamble_mode != 3U) {
      pmlmeinfo->preamble_mode = 3U;
      rtl8723a_ack_preamble(Adapter, 1);
    } else {
    }
  } else
  if ((unsigned int )pmlmeinfo->preamble_mode != 1U) {
    pmlmeinfo->preamble_mode = 1U;
    rtl8723a_ack_preamble(Adapter, 0);
  } else {
  }
  if (((int )updateCap & 2) != 0) {
    pmlmeinfo->slotTime = 20U;
  } else
  if (((int )pmlmeext->cur_wireless_mode & 10) != 0) {
    if (((int )updateCap & 1024) != 0) {
      if ((unsigned int )pmlmeinfo->slotTime != 9U) {
        pmlmeinfo->slotTime = 9U;
      } else {
      }
    } else
    if ((unsigned int )pmlmeinfo->slotTime != 20U) {
      pmlmeinfo->slotTime = 20U;
    } else {
    }
  } else
  if (((int )pmlmeext->cur_wireless_mode & 20) != 0) {
    pmlmeinfo->slotTime = 9U;
  } else {
    pmlmeinfo->slotTime = 20U;
  }
  rtl8723a_set_slot_time(Adapter, (int )pmlmeinfo->slotTime);
  return;
}
}
void update_wireless_mode23a(struct rtw_adapter *padapter )
{
  int ratelen ;
  int network_type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  unsigned char *rate ;
  uint tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  network_type = 0;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  rate = (unsigned char *)(& cur_network->SupportedRates);
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  ratelen = (int )tmp;
  if ((unsigned int )pmlmeinfo->HT_info_enable != 0U && (unsigned int )pmlmeinfo->HT_caps_enable != 0U) {
    pmlmeinfo->HT_enable = 1U;
  } else {
  }
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
      network_type = 16;
    } else {
    }
    network_type = network_type | 4;
  } else {
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
      network_type = 8;
    } else {
    }
    tmp___1 = cckratesonly_included23a(rate, ratelen);
    if (tmp___1 == 1) {
      network_type = network_type | 1;
    } else {
      tmp___0 = cckrates_included23a(rate, ratelen);
      if (tmp___0 == 1) {
        network_type = network_type | 3;
      } else {
        network_type = network_type | 2;
      }
    }
  }
  pmlmeext->cur_wireless_mode = (unsigned char )((int )((signed char )padapter->registrypriv.wireless_mode) & (int )((signed char )network_type));
  rtl8723a_set_resp_sifs(padapter, 8, 8, 10, 10);
  if ((int )pmlmeext->cur_wireless_mode & 1) {
    update_mgnt_tx_rate23a(padapter, 2);
  } else {
    update_mgnt_tx_rate23a(padapter, 12);
  }
  return;
}
}
void update_bmc_sta_support_rate23a(struct rtw_adapter *padapter , u32 mac_id )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((int )pmlmeext->cur_wireless_mode & 1) {
    __len = 4UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                       (void const *)(& rtw_basic_rate_cck), __len);
    } else {
      __ret = memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                               (void const *)(& rtw_basic_rate_cck), __len);
    }
  } else {
    __len___0 = 3UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                           (void const *)(& rtw_basic_rate_ofdm), __len___0);
    } else {
      __ret___0 = memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                                   (void const *)(& rtw_basic_rate_ofdm), __len___0);
    }
  }
  return;
}
}
int update_sta_support_rate23a(struct rtw_adapter *padapter , u8 *pvar_ie , uint var_ie_len ,
                               int cam_idx )
{
  int supportRateNum ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 const *p ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  supportRateNum = 0;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  p = cfg80211_find_ie(1, (u8 const *)pvar_ie, (int )var_ie_len);
  if ((unsigned long )p == (unsigned long )((u8 const *)0U)) {
    return (0);
  } else {
  }
  __len = (size_t )*(p + 1UL);
  __ret = memcpy((void *)(& pmlmeinfo->FW_sta_info[cam_idx].SupportedRates),
                           (void const *)p + 2U, __len);
  supportRateNum = (int )*(p + 1UL);
  p = cfg80211_find_ie(50, (u8 const *)pvar_ie, (int )var_ie_len);
  if ((unsigned long )p != (unsigned long )((u8 const *)0U)) {
    __len___0 = (size_t )*(p + 1UL);
    __ret___0 = memcpy((void *)(& pmlmeinfo->FW_sta_info[cam_idx].SupportedRates) + (unsigned long )supportRateNum,
                                 (void const *)p + 2U, __len___0);
  } else {
  }
  return (1);
}
}
void process_addba_req23a(struct rtw_adapter *padapter , u8 *paddba_req , u8 *addr )
{
  struct sta_info *psta ;
  u16 tid ;
  u16 start_seq ;
  u16 param ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_priv *pstapriv ;
  struct ADDBA_request *preq ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pstapriv = & padapter->stapriv;
  preq = (struct ADDBA_request *)paddba_req;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)addr);
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    start_seq = (u16 )((int )preq->BA_starting_seqctrl >> 4);
    param = preq->BA_para_set;
    tid = (unsigned int )((u16 )((int )param >> 2)) & 15U;
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )tid;
    preorder_ctrl->indicate_seq = 65535U;
    preorder_ctrl->enable = (u8 )pmlmeinfo->bAcceptAddbaReq;
  } else {
  }
  return;
}
}
static struct rtw_adapter *pbuddy_padapter ;
int rtw_handle_dualmac23a(struct rtw_adapter *adapter , bool init )
{
  int status ;
  {
  status = 1;
  if ((int )init) {
    if ((unsigned long )pbuddy_padapter == (unsigned long )((struct rtw_adapter *)0)) {
      pbuddy_padapter = adapter;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(): pbuddy_padapter == NULL, Set pbuddy_padapter\n",
               "rtw_handle_dualmac23a");
      } else {
      }
    } else {
      adapter->pbuddy_adapter = pbuddy_padapter;
      pbuddy_padapter->pbuddy_adapter = adapter;
      pbuddy_padapter = (struct rtw_adapter *)0;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s(): pbuddy_padapter exist, Exchange Information\n",
               "rtw_handle_dualmac23a");
      } else {
      }
    }
  } else {
    pbuddy_padapter = (struct rtw_adapter *)0;
  }
  return (status);
}
}
void *ldv_kmem_cache_alloc_872(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_878(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_880(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_882(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_883(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_884(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_885(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_886(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_887(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_888(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_914(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_922(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_930(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_924(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_920(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_928(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_929(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_925(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_926(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_927(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
void dump_chip_info23a(struct hal_version ChipVersion ) ;
u8 hal_com_get_channel_plan23a(struct rtw_adapter *padapter , u8 hw_channel_plan ,
                               u8 sw_channel_plan , u8 def_channel_plan , bool AutoLoadFail ) ;
u8 MRateToHwRate23a(u8 rate ) ;
bool Hal_MappingOutPipe23a(struct rtw_adapter *pAdapter , u8 NumOutPipe ) ;
void rtl8723a_set_media_status1(struct rtw_adapter *padapter , u8 status ) ;
void rtl8723a_check_bssid(struct rtw_adapter *padapter , u8 val ) ;
void rtl8723a_off_rcr_am(struct rtw_adapter *padapter ) ;
void rtl8723a_cam_empty_entry(struct rtw_adapter *padapter , u8 ucIndex ) ;
void rtl8723a_fifo_cleanup(struct rtw_adapter *padapter ) ;
void rtl8723a_set_nav_upper(struct rtw_adapter *padapter , u32 usNavUpper ) ;
bool rtl8723a_BT_enabled(struct rtw_adapter *padapter ) ;
void ODM_Write_DIG23a(struct dm_odm_t *pDM_Odm , u8 CurrentIGI ) ;
void SetBcnCtrlReg23a(struct rtw_adapter *padapter , u8 SetBits , u8 ClearBits ) ;
int rtl8723au_write32(struct rtw_adapter *padapter , u32 addr , u32 val ) ;
void dump_chip_info23a(struct hal_version ChipVersion )
{
  int cnt ;
  u8 buf[128U] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  {
  cnt = 0;
  tmp = sprintf((char *)(& buf) + (unsigned long )cnt, "Chip Version Info: CHIP_8723A_");
  cnt = tmp + cnt;
  tmp___0 = sprintf((char *)(& buf) + (unsigned long )cnt, "%s_", (unsigned int )ChipVersion.ChipType == 1U ? (char *)"Normal_Chip" : (char *)"Test_Chip");
  cnt = tmp___0 + cnt;
  tmp___1 = sprintf((char *)(& buf) + (unsigned long )cnt, "%s_", (unsigned int )ChipVersion.VendorType == 0U ? (char *)"TSMC" : (char *)"UMC");
  cnt = tmp___1 + cnt;
  if ((unsigned int )ChipVersion.CUTVersion == 0U) {
    tmp___2 = sprintf((char *)(& buf) + (unsigned long )cnt, "A_CUT_");
    cnt = tmp___2 + cnt;
  } else
  if ((unsigned int )ChipVersion.CUTVersion == 1U) {
    tmp___3 = sprintf((char *)(& buf) + (unsigned long )cnt, "B_CUT_");
    cnt = tmp___3 + cnt;
  } else
  if ((unsigned int )ChipVersion.CUTVersion == 2U) {
    tmp___4 = sprintf((char *)(& buf) + (unsigned long )cnt, "C_CUT_");
    cnt = tmp___4 + cnt;
  } else
  if ((unsigned int )ChipVersion.CUTVersion == 3U) {
    tmp___5 = sprintf((char *)(& buf) + (unsigned long )cnt, "D_CUT_");
    cnt = tmp___5 + cnt;
  } else
  if ((unsigned int )ChipVersion.CUTVersion == 4U) {
    tmp___6 = sprintf((char *)(& buf) + (unsigned long )cnt, "E_CUT_");
    cnt = tmp___6 + cnt;
  } else {
    tmp___7 = sprintf((char *)(& buf) + (unsigned long )cnt, "UNKNOWN_CUT(%d)_", (unsigned int )ChipVersion.CUTVersion);
    cnt = tmp___7 + cnt;
  }
  if ((unsigned int )ChipVersion.RFType == 0U) {
    tmp___8 = sprintf((char *)(& buf) + (unsigned long )cnt, "1T1R_");
    cnt = tmp___8 + cnt;
  } else
  if ((unsigned int )ChipVersion.RFType == 1U) {
    tmp___9 = sprintf((char *)(& buf) + (unsigned long )cnt, "1T2R_");
    cnt = tmp___9 + cnt;
  } else
  if ((unsigned int )ChipVersion.RFType == 2U) {
    tmp___10 = sprintf((char *)(& buf) + (unsigned long )cnt, "2T2R_");
    cnt = tmp___10 + cnt;
  } else {
    tmp___11 = sprintf((char *)(& buf) + (unsigned long )cnt, "UNKNOWN_RFTYPE(%d)_",
                       (unsigned int )ChipVersion.RFType);
    cnt = tmp___11 + cnt;
  }
  tmp___12 = sprintf((char *)(& buf) + (unsigned long )cnt, "RomVer(%d)\n", (int )ChipVersion.ROMVer);
  cnt = tmp___12 + cnt;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s", (u8 *)(& buf));
  } else {
  }
  return;
}
}
u8 hal_com_get_channel_plan23a(struct rtw_adapter *padapter , u8 hw_channel_plan ,
                               u8 sw_channel_plan , u8 def_channel_plan , bool AutoLoadFail )
{
  u8 swConfig ;
  u8 chnlPlan ;
  {
  swConfig = 1U;
  if (! AutoLoadFail) {
    if ((unsigned int )sw_channel_plan > 65U && (unsigned int )sw_channel_plan != 127U) {
      swConfig = 0U;
    } else {
    }
    if ((int )((signed char )hw_channel_plan) < 0) {
      swConfig = 0U;
    } else {
    }
  } else {
  }
  if ((unsigned int )swConfig == 1U) {
    chnlPlan = sw_channel_plan;
  } else {
    chnlPlan = (unsigned int )hw_channel_plan & 127U;
  }
  if ((unsigned int )chnlPlan > 65U && (unsigned int )chnlPlan != 127U) {
    chnlPlan = def_channel_plan;
  } else {
  }
  return (chnlPlan);
}
}
u8 MRateToHwRate23a(u8 rate )
{
  u8 ret ;
  {
  ret = 0U;
  switch ((int )rate) {
  case 2:
  ret = 0U;
  goto ldv_54262;
  case 4:
  ret = 1U;
  goto ldv_54262;
  case 11:
  ret = 2U;
  goto ldv_54262;
  case 22:
  ret = 3U;
  goto ldv_54262;
  case 12:
  ret = 4U;
  goto ldv_54262;
  case 18:
  ret = 5U;
  goto ldv_54262;
  case 24:
  ret = 6U;
  goto ldv_54262;
  case 36:
  ret = 7U;
  goto ldv_54262;
  case 48:
  ret = 8U;
  goto ldv_54262;
  case 72:
  ret = 9U;
  goto ldv_54262;
  case 96:
  ret = 10U;
  goto ldv_54262;
  case 108:
  ret = 11U;
  goto ldv_54262;
  default: ;
  goto ldv_54262;
  }
  ldv_54262: ;
  return (ret);
}
}
void HalSetBrateCfg23a(struct rtw_adapter *padapter , u8 *mBratesOS )
{
  struct hal_data_8723a *pHalData ;
  u8 i ;
  u8 is_brate ;
  u8 brate ;
  u16 brate_cfg ;
  u8 rate_index ;
  u8 tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  brate_cfg = 0U;
  i = 0U;
  goto ldv_54299;
  ldv_54298:
  is_brate = (unsigned int )*(mBratesOS + (unsigned long )i) & 128U;
  brate = (unsigned int )*(mBratesOS + (unsigned long )i) & 127U;
  if ((unsigned int )is_brate != 0U) {
    switch ((int )brate) {
    case 2:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 1U);
    goto ldv_54286;
    case 4:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 2U);
    goto ldv_54286;
    case 11:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 4U);
    goto ldv_54286;
    case 22:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 8U);
    goto ldv_54286;
    case 12:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 16U);
    goto ldv_54286;
    case 18:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 32U);
    goto ldv_54286;
    case 24:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 64U);
    goto ldv_54286;
    case 36:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 128U);
    goto ldv_54286;
    case 48:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 256U);
    goto ldv_54286;
    case 72:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 512U);
    goto ldv_54286;
    case 96:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 1024U);
    goto ldv_54286;
    case 108:
    brate_cfg = (u16 )((unsigned int )brate_cfg | 2048U);
    goto ldv_54286;
    }
    ldv_54286: ;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54299: ;
  if ((unsigned int )i <= 15U) {
    goto ldv_54298;
  } else {
  }
  brate_cfg = ((unsigned int )brate_cfg & 336U) | 13U;
  pHalData->BasicRateSet = brate_cfg;
  brate_cfg = (u16 )((unsigned int )brate_cfg | 1U);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", (int )brate_cfg);
  } else {
  }
  rtl8723au_write8(padapter, 1088U, (int )((u8 )brate_cfg));
  rtl8723au_write8(padapter, 1089U, (int )((u8 )((int )brate_cfg >> 8)));
  tmp = rtl8723au_read8(padapter, 1090U);
  rtl8723au_write8(padapter, 1090U, (int )tmp & 240);
  rate_index = 0U;
  goto ldv_54302;
  ldv_54301:
  brate_cfg = (u16 )((int )brate_cfg >> 1);
  rate_index = (u8 )((int )rate_index + 1);
  ldv_54302: ;
  if ((unsigned int )brate_cfg > 1U) {
    goto ldv_54301;
  } else {
  }
  rtl8723au_write8(padapter, 1152U, (int )rate_index);
  return;
}
}
static void _OneOutPipeMapping(struct rtw_adapter *pAdapter )
{
  struct dvobj_priv *pdvobjpriv ;
  {
  pdvobjpriv = pAdapter->dvobj;
  pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
  pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  return;
}
}
static void _TwoOutPipeMapping(struct rtw_adapter *pAdapter , bool bWIFICfg )
{
  struct dvobj_priv *pdvobjpriv ;
  {
  pdvobjpriv = pAdapter->dvobj;
  if ((int )bWIFICfg) {
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  } else {
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  }
  return;
}
}
static void _ThreeOutPipeMapping(struct rtw_adapter *pAdapter , bool bWIFICfg )
{
  struct dvobj_priv *pdvobjpriv ;
  {
  pdvobjpriv = pAdapter->dvobj;
  if ((int )bWIFICfg) {
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[2];
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  } else {
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[1];
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[2];
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[2];
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  }
  return;
}
}
bool Hal_MappingOutPipe23a(struct rtw_adapter *pAdapter , u8 NumOutPipe )
{
  struct registry_priv *pregistrypriv ;
  bool bWIFICfg ;
  bool result ;
  {
  pregistrypriv = & pAdapter->registrypriv;
  bWIFICfg = (unsigned int )pregistrypriv->wifi_spec != 0U;
  result = 1;
  switch ((int )NumOutPipe) {
  case 2:
  _TwoOutPipeMapping(pAdapter, (int )bWIFICfg);
  goto ldv_54326;
  case 3:
  _ThreeOutPipeMapping(pAdapter, (int )bWIFICfg);
  goto ldv_54326;
  case 1:
  _OneOutPipeMapping(pAdapter);
  goto ldv_54326;
  default:
  result = 0;
  goto ldv_54326;
  }
  ldv_54326: ;
  return (result);
}
}
void c2h_evt_clear23a(struct rtw_adapter *adapter )
{
  {
  rtl8723au_write8(adapter, 431U, 0);
  return;
}
}
s32 c2h_evt_read23a(struct rtw_adapter *adapter , u8 *buf )
{
  int ret ;
  struct c2h_evt_hdr *c2h_evt ;
  int i ;
  u8 trigger ;
  int __i ;
  u8 *ptr ;
  int __i___0 ;
  u8 *ptr___0 ;
  {
  ret = 0;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    goto exit;
  } else {
  }
  trigger = rtl8723au_read8(adapter, 431U);
  if ((unsigned int )trigger == 0U) {
    goto exit;
  } else
  if ((unsigned int )trigger != 255U) {
    goto clear_evt;
  } else {
  }
  c2h_evt = (struct c2h_evt_hdr *)buf;
  memset((void *)c2h_evt, 0, 16UL);
  *buf = rtl8723au_read8(adapter, 416U);
  *(buf + 1UL) = rtl8723au_read8(adapter, 417U);
  if (GlobalDebugLevel23A > 6U) {
    ptr = (u8 *)(& c2h_evt);
    printk("\016%s", (char *)"RTL8723AU: ");
    printk("\016c2h_evt_read23a(): ");
    __i = 0;
    goto ldv_54346;
    ldv_54345:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((unsigned int )(__i + 1) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((unsigned int )(__i + 1) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1;
    ldv_54346: ;
    if (__i <= 7) {
      goto ldv_54345;
    } else {
    }
    printk("\n");
  } else {
  }
  i = 0;
  goto ldv_54350;
  ldv_54349:
  c2h_evt->payload[i] = rtl8723au_read8(adapter, (u32 )i + 418U);
  i = i + 1;
  ldv_54350: ;
  if ((int )c2h_evt->plen > i) {
    goto ldv_54349;
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    ptr___0 = (u8 *)(& c2h_evt->payload);
    printk("\016%s", (char *)"RTL8723AU: ");
    printk("\016c2h_evt_read23a(): Command Content:\n");
    __i___0 = 0;
    goto ldv_54355;
    ldv_54354:
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((unsigned int )(__i___0 + 1) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((unsigned int )(__i___0 + 1) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i___0 = __i___0 + 1;
    ldv_54355: ;
    if ((int )c2h_evt->plen > __i___0) {
      goto ldv_54354;
    } else {
    }
    printk("\n");
  } else {
  }
  ret = 1;
  clear_evt:
  c2h_evt_clear23a(adapter);
  exit: ;
  return (ret);
}
}
void rtl8723a_set_ampdu_min_space(struct rtw_adapter *padapter , u8 MinSpacingToSet )
{
  u8 SecMinSpace ;
  u8 tmp ;
  {
  if ((unsigned int )MinSpacingToSet <= 7U) {
    switch (padapter->securitypriv.dot11PrivacyAlgrthm) {
    case 0U: ;
    case 1027076U:
    SecMinSpace = 0U;
    goto ldv_54364;
    case 1027073U: ;
    case 1027077U: ;
    case 1027074U:
    SecMinSpace = 6U;
    goto ldv_54364;
    default:
    SecMinSpace = 7U;
    goto ldv_54364;
    }
    ldv_54364: ;
    if ((int )MinSpacingToSet < (int )SecMinSpace) {
      MinSpacingToSet = SecMinSpace;
    } else {
    }
    tmp = rtl8723au_read8(padapter, 1116U);
    MinSpacingToSet = (u8 )(((int )((signed char )tmp) & -8) | (int )((signed char )MinSpacingToSet));
    rtl8723au_write8(padapter, 1116U, (int )MinSpacingToSet);
  } else {
  }
  return;
}
}
void rtl8723a_set_ampdu_factor(struct rtw_adapter *padapter , u8 FactorToSet )
{
  u8 RegToSet_Normal[4U] ;
  u8 MaxAggNum ;
  u8 *pRegToSet ;
  u8 index ;
  bool tmp ;
  bool tmp___0 ;
  {
  RegToSet_Normal[0] = 65U;
  RegToSet_Normal[1] = 168U;
  RegToSet_Normal[2] = 114U;
  RegToSet_Normal[3] = 185U;
  index = 0U;
  pRegToSet = (u8 *)(& RegToSet_Normal);
  tmp = rtl8723a_BT_enabled(padapter);
  if ((int )tmp) {
    tmp___0 = rtl8723a_BT_using_antenna_1(padapter);
    if ((int )tmp___0) {
      MaxAggNum = 8U;
    } else {
      MaxAggNum = 15U;
    }
  } else {
    MaxAggNum = 15U;
  }
  if ((unsigned int )FactorToSet <= 3U) {
    FactorToSet = (u8 )(1 << ((int )FactorToSet + 2));
    if ((int )FactorToSet > (int )MaxAggNum) {
      FactorToSet = MaxAggNum;
    } else {
    }
    index = 0U;
    goto ldv_54378;
    ldv_54377: ;
    if (((int )*(pRegToSet + (unsigned long )index) & 240) > (int )FactorToSet << 4) {
      *(pRegToSet + (unsigned long )index) = (u8 )(((int )((signed char )*(pRegToSet + (unsigned long )index)) & 15) | (int )((signed char )((int )FactorToSet << 4)));
    } else {
    }
    if (((int )*(pRegToSet + (unsigned long )index) & 15) > (int )FactorToSet) {
      *(pRegToSet + (unsigned long )index) = (u8 )(((int )((signed char )*(pRegToSet + (unsigned long )index)) & -16) | (int )((signed char )FactorToSet));
    } else {
    }
    rtl8723au_write8(padapter, (u32 )((int )index + 1112), (int )*(pRegToSet + (unsigned long )index));
    index = (u8 )((int )index + 1);
    ldv_54378: ;
    if ((unsigned int )index <= 3U) {
      goto ldv_54377;
    } else {
    }
  } else {
  }
  return;
}
}
void rtl8723a_set_acm_ctrl(struct rtw_adapter *padapter , u8 ctrl )
{
  u8 hwctrl ;
  {
  hwctrl = 0U;
  if ((unsigned int )ctrl != 0U) {
    hwctrl = (u8 )((unsigned int )hwctrl | 1U);
    if (((unsigned long )ctrl & 2UL) != 0UL) {
      hwctrl = (u8 )((unsigned int )hwctrl | 2U);
    } else {
    }
    if (((unsigned long )ctrl & 4UL) != 0UL) {
      hwctrl = (u8 )((unsigned int )hwctrl | 4U);
    } else {
    }
    if (((unsigned long )ctrl & 8UL) != 0UL) {
      hwctrl = (u8 )((unsigned int )hwctrl | 8U);
    } else {
    }
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: [HW_VAR_ACM_CTRL] Write 0x%02X\n", (int )hwctrl);
  } else {
  }
  rtl8723au_write8(padapter, 1472U, (int )hwctrl);
  return;
}
}
void rtl8723a_set_media_status(struct rtw_adapter *padapter , u8 status )
{
  u8 val8 ;
  u8 tmp ;
  {
  tmp = rtl8723au_read8(padapter, 258U);
  val8 = (unsigned int )tmp & 12U;
  val8 = (u8 )((int )val8 | (int )status);
  rtl8723au_write8(padapter, 258U, (int )val8);
  return;
}
}
void rtl8723a_set_media_status1(struct rtw_adapter *padapter , u8 status )
{
  u8 val8 ;
  u8 tmp ;
  {
  tmp = rtl8723au_read8(padapter, 258U);
  val8 = (unsigned int )tmp & 3U;
  val8 = (u8 )((int )((signed char )((int )status << 2)) | (int )((signed char )val8));
  rtl8723au_write8(padapter, 258U, (int )val8);
  return;
}
}
void rtl8723a_set_bcn_func(struct rtw_adapter *padapter , u8 val )
{
  {
  if ((unsigned int )val != 0U) {
    SetBcnCtrlReg23a(padapter, 12, 0);
  } else {
    SetBcnCtrlReg23a(padapter, 0, 12);
  }
  return;
}
}
void rtl8723a_check_bssid(struct rtw_adapter *padapter , u8 val )
{
  u32 val32 ;
  {
  val32 = rtl8723au_read32(padapter, 1544U);
  if ((unsigned int )val != 0U) {
    val32 = val32 | 192U;
  } else {
    val32 = val32 & 4294967103U;
  }
  rtl8723au_write32(padapter, 1544U, val32);
  return;
}
}
void rtl8723a_mlme_sitesurvey(struct rtw_adapter *padapter , u8 flag )
{
  u32 v32 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 v32___0 ;
  bool tmp ;
  {
  if ((unsigned int )flag != 0U) {
    v32 = rtl8723au_read32(padapter, 1544U);
    v32 = v32 & 4294967167U;
    rtl8723au_write32(padapter, 1544U, v32);
    rtl8723au_write16(padapter, 1700U, 0);
    SetBcnCtrlReg23a(padapter, 16, 0);
  } else {
    pmlmeext = & padapter->mlmeextpriv;
    pmlmeinfo = & pmlmeext->mlmext_info;
    tmp = is_client_associated_to_ap23a(padapter);
    if (((int )tmp || (pmlmeinfo->state & 3U) == 1U) || (pmlmeinfo->state & 3U) == 3U) {
      rtl8723au_write16(padapter, 1700U, 65535);
      SetBcnCtrlReg23a(padapter, 0, 16);
    } else {
    }
    v32___0 = rtl8723au_read32(padapter, 1544U);
    v32___0 = v32___0 | 128U;
    rtl8723au_write32(padapter, 1544U, v32___0);
  }
  rtl8723a_BT_wifiscan_notify(padapter, (unsigned int )flag != 0U);
  return;
}
}
void rtl8723a_on_rcr_am(struct rtw_adapter *padapter )
{
  u32 tmp ;
  u32 tmp___0 ;
  {
  tmp = rtl8723au_read32(padapter, 1544U);
  rtl8723au_write32(padapter, 1544U, tmp | 4U);
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = rtl8723au_read32(padapter, 1544U);
    printk("\016RTL8723AU: %s, %d, RCR = %x \n", "rtl8723a_on_rcr_am", 810, tmp___0);
  } else {
  }
  return;
}
}
void rtl8723a_off_rcr_am(struct rtw_adapter *padapter )
{
  u32 tmp ;
  u32 tmp___0 ;
  {
  tmp = rtl8723au_read32(padapter, 1544U);
  rtl8723au_write32(padapter, 1544U, tmp & 4294967291U);
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = rtl8723au_read32(padapter, 1544U);
    printk("\016RTL8723AU: %s, %d, RCR = %x \n", "rtl8723a_off_rcr_am", 818, tmp___0);
  } else {
  }
  return;
}
}
void rtl8723a_set_slot_time(struct rtw_adapter *padapter , u8 slottime )
{
  u8 u1bAIFS ;
  u8 aSifsTime ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  rtl8723au_write8(padapter, 1307U, (int )slottime);
  if ((unsigned int )pmlmeinfo->WMM_enable == 0U) {
    if ((unsigned int )pmlmeext->cur_wireless_mode == 1U) {
      aSifsTime = 10U;
    } else {
      aSifsTime = 16U;
    }
    u1bAIFS = (unsigned int )pmlmeinfo->slotTime * 2U + (unsigned int )aSifsTime;
    rtl8723au_write8(padapter, 1280U, (int )u1bAIFS);
    rtl8723au_write8(padapter, 1284U, (int )u1bAIFS);
    rtl8723au_write8(padapter, 1288U, (int )u1bAIFS);
    rtl8723au_write8(padapter, 1292U, (int )u1bAIFS);
  } else {
  }
  return;
}
}
void rtl8723a_ack_preamble(struct rtw_adapter *padapter , u8 bShortPreamble )
{
  struct hal_data_8723a *pHalData ;
  u8 regTmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  regTmp = (int )pHalData->nCur40MhzPrimeSC << 5U;
  if ((unsigned int )bShortPreamble != 0U) {
    regTmp = (u8 )((unsigned int )regTmp | 128U);
  } else {
  }
  rtl8723au_write8(padapter, 1090U, (int )regTmp);
  return;
}
}
void rtl8723a_set_sec_cfg(struct rtw_adapter *padapter , u8 sec )
{
  {
  rtl8723au_write8(padapter, 1664U, (int )sec);
  return;
}
}
void rtl8723a_cam_empty_entry(struct rtw_adapter *padapter , u8 ucIndex )
{
  u8 i ;
  u32 ulCommand ;
  u32 ulContent ;
  u32 ulEncAlgo ;
  {
  ulCommand = 0U;
  ulContent = 0U;
  ulEncAlgo = 4U;
  i = 0U;
  goto ldv_54447;
  ldv_54446: ;
  if ((unsigned int )i == 0U) {
    ulContent = (u32 )(((int )ucIndex & 3) | ((int )((unsigned short )ulEncAlgo) << 2)) | ulContent;
  } else {
    ulContent = 0U;
  }
  ulCommand = (u32 )((int )ucIndex * 8 + (int )i);
  ulCommand = ulCommand | 2147549184U;
  rtl8723au_write32(padapter, 1652U, ulContent);
  rtl8723au_write32(padapter, 1648U, ulCommand);
  i = (u8 )((int )i + 1);
  ldv_54447: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_54446;
  } else {
  }
  return;
}
}
void rtl8723a_cam_invalid_all(struct rtw_adapter *padapter )
{
  {
  rtl8723au_write32(padapter, 1648U, 3221225472U);
  return;
}
}
void rtl8723a_cam_write(struct rtw_adapter *padapter , u8 entry , u16 ctrl , u8 const *mac ,
                        u8 const *key )
{
  u32 cmd ;
  unsigned int i ;
  unsigned int val ;
  unsigned int addr ;
  int j ;
  {
  addr = (unsigned int )((int )entry << 3);
  j = 5;
  goto ldv_54469;
  ldv_54468: ;
  switch (j) {
  case 0:
  val = (unsigned int )(((int )ctrl | ((int )*mac << 16)) | ((int )*(mac + 1UL) << 24));
  goto ldv_54465;
  case 1:
  val = (unsigned int )((((int )*(mac + 2UL) | ((int )*(mac + 3UL) << 8)) | ((int )*(mac + 4UL) << 16)) | ((int )*(mac + 5UL) << 24));
  goto ldv_54465;
  default:
  i = (unsigned int )((j + -2) << 2);
  val = (unsigned int )((((int )*(key + (unsigned long )i) | ((int )*(key + (unsigned long )(i + 1U)) << 8)) | ((int )*(key + (unsigned long )(i + 2U)) << 16)) | ((int )*(key + (unsigned long )(i + 3U)) << 24));
  goto ldv_54465;
  }
  ldv_54465:
  rtl8723au_write32(padapter, 1652U, val);
  cmd = (addr + (unsigned int )j) | 2147549184U;
  rtl8723au_write32(padapter, 1648U, cmd);
  j = j - 1;
  ldv_54469: ;
  if (j >= 0) {
    goto ldv_54468;
  } else {
  }
  return;
}
}
void rtl8723a_fifo_cleanup(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *pwrpriv ;
  u8 trycnt ;
  u32 v32 ;
  u32 tmp ;
  u8 tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  trycnt = 100U;
  rtl8723au_write8(padapter, 1314U, 255);
  padapter->xmitpriv.nqos_ssn = rtl8723au_read16(padapter, 1244U);
  if ((unsigned int )pwrpriv->bkeepfwalive != 1U) {
    v32 = rtl8723au_read32(padapter, 644U);
    v32 = v32 | 262144U;
    rtl8723au_write32(padapter, 644U, v32);
    ldv_54478:
    tmp = rtl8723au_read32(padapter, 644U);
    v32 = tmp & 131072U;
    if (v32 == 0U) {
      goto ldv_54477;
    } else {
    }
    tmp___0 = trycnt;
    trycnt = (u8 )((int )trycnt - 1);
    if ((unsigned int )tmp___0 != 0U) {
      goto ldv_54478;
    } else {
    }
    ldv_54477: ;
    if ((unsigned int )trycnt == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Stop RX DMA failed......\n");
      } else {
      }
    } else {
    }
    rtl8723au_write16(padapter, 532U, 0);
    rtl8723au_write32(padapter, 512U, 2147483648U);
    __ms = 10UL;
    goto ldv_54481;
    ldv_54480:
    __const_udelay(4295000UL);
    ldv_54481:
    tmp___1 = __ms;
    __ms = __ms - 1UL;
    if (tmp___1 != 0UL) {
      goto ldv_54480;
    } else {
    }
  } else {
  }
  return;
}
}
void rtl8723a_bcn_valid(struct rtw_adapter *padapter )
{
  u8 tmp ;
  {
  tmp = rtl8723au_read8(padapter, 522U);
  rtl8723au_write8(padapter, 522U, (int )((unsigned int )tmp | 1U));
  return;
}
}
bool rtl8723a_get_bcn_valid(struct rtw_adapter *padapter )
{
  bool retval ;
  u8 tmp ;
  {
  tmp = rtl8723au_read8(padapter, 522U);
  retval = ((int )tmp & 1) != 0;
  return (retval);
}
}
void rtl8723a_set_beacon_interval(struct rtw_adapter *padapter , u16 interval )
{
  {
  rtl8723au_write16(padapter, 1364U, (int )interval);
  return;
}
}
void rtl8723a_set_resp_sifs(struct rtw_adapter *padapter , u8 r2t1 , u8 r2t2 , u8 t2t1 ,
                            u8 t2t2 )
{
  {
  rtl8723au_write8(padapter, 1596U, (int )r2t1);
  rtl8723au_write8(padapter, 1597U, (int )r2t2);
  rtl8723au_write8(padapter, 1598U, (int )t2t1);
  rtl8723au_write8(padapter, 1599U, (int )t2t2);
  return;
}
}
void rtl8723a_set_ac_param_vo(struct rtw_adapter *padapter , u32 vo )
{
  {
  rtl8723au_write32(padapter, 1280U, vo);
  return;
}
}
void rtl8723a_set_ac_param_vi(struct rtw_adapter *padapter , u32 vi )
{
  {
  rtl8723au_write32(padapter, 1284U, vi);
  return;
}
}
void rtl8723a_set_ac_param_be(struct rtw_adapter *padapter , u32 be )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->AcParam_BE = be;
  rtl8723au_write32(padapter, 1288U, be);
  return;
}
}
void rtl8723a_set_ac_param_bk(struct rtw_adapter *padapter , u32 bk )
{
  {
  rtl8723au_write32(padapter, 1292U, bk);
  return;
}
}
void rtl8723a_set_rxdma_agg_pg_th(struct rtw_adapter *padapter , u8 val )
{
  {
  rtl8723au_write8(padapter, 640U, (int )val);
  return;
}
}
void rtl8723a_set_nav_upper(struct rtw_adapter *padapter , u32 usNavUpper )
{
  {
  if (usNavUpper > 32640U) {
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 6);
      printk("\016The setting value (0x%08X us) of NAV_UPPER is larger than (%d * 0xFF)!!!\n",
             usNavUpper, 128);
    } else {
    }
    return;
  } else {
  }
  usNavUpper = (usNavUpper + 127U) / 128U;
  rtl8723au_write8(padapter, 1618U, (int )((unsigned char )usNavUpper));
  return;
}
}
void rtl8723a_set_initial_gain(struct rtw_adapter *padapter , u32 rx_gain )
{
  struct hal_data_8723a *pHalData ;
  struct dig_t *pDigTable ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pDigTable = & pHalData->odmpriv.DM_DigTable;
  if (rx_gain == 255U) {
    ODM_Write_DIG23a(& pHalData->odmpriv, (int )pDigTable->BackupIGValue);
  } else {
    pDigTable->BackupIGValue = pDigTable->CurIGValue;
    ODM_Write_DIG23a(& pHalData->odmpriv, (int )((u8 )rx_gain));
  }
  return;
}
}
void rtl8723a_odm_support_ability_restore(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->odmpriv.SupportAbility = pHalData->odmpriv.BK_SupportAbility;
  return;
}
}
void rtl8723a_odm_support_ability_backup(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->odmpriv.BK_SupportAbility = pHalData->odmpriv.SupportAbility;
  return;
}
}
void rtl8723a_odm_support_ability_set(struct rtw_adapter *padapter , u32 val )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (val == 268435455U) {
    pHalData->dmpriv.DMFlag = pHalData->dmpriv.InitDMFlag;
    pHalData->odmpriv.SupportAbility = pHalData->dmpriv.InitODMFlag;
  } else {
    pHalData->odmpriv.SupportAbility = pHalData->odmpriv.SupportAbility | val;
  }
  return;
}
}
void rtl8723a_odm_support_ability_clr(struct rtw_adapter *padapter , u32 val )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->odmpriv.SupportAbility = pHalData->odmpriv.SupportAbility & val;
  return;
}
}
void rtl8723a_set_rpwm(struct rtw_adapter *padapter , u8 val )
{
  {
  rtl8723au_write8(padapter, 65112U, (int )val);
  return;
}
}
u8 rtl8723a_get_rf_type(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  return (pHalData->rf_type);
}
}
bool rtl8723a_get_fwlps_rf_on(struct rtw_adapter *padapter )
{
  bool retval ;
  u32 valRCR ;
  {
  if (padapter->bSurpriseRemoved == 1 || (unsigned int )padapter->pwrctrlpriv.rf_pwrstate == 2U) {
    retval = 1;
  } else {
    valRCR = rtl8723au_read32(padapter, 1544U);
    if ((valRCR & 458752U) != 0U) {
      retval = 0;
    } else {
      retval = 1;
    }
  }
  return (retval);
}
}
bool rtl8723a_chk_hi_queue_empty(struct rtw_adapter *padapter )
{
  u32 hgq ;
  {
  hgq = rtl8723au_read32(padapter, 1044U);
  return ((hgq & 65280U) == 0U);
}
}
void *ldv_kmem_cache_alloc_914(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_920(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_922(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_924(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_925(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_926(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_927(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_928(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_929(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_930(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_956(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_964(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_972(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_966(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_962(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_970(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
int ldv_pskb_expand_head_971(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_967(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_968(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_969(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
void add_RATid23a(struct rtw_adapter *padapter , struct sta_info *psta , u8 rssi_level ) ;
void rtl8723a_update_ramask(struct rtw_adapter *padapter , u32 mac_id , u8 rssi_level ) ;
void rtw_hal_update_ra_mask23a(struct sta_info *psta , u8 rssi_level )
{
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  {
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {
  }
  padapter = psta->padapter;
  pmlmepriv = & padapter->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    add_RATid23a(padapter, psta, (int )rssi_level);
  } else {
    rtl8723a_update_ramask(padapter, psta->mac_id, (int )rssi_level);
  }
  return;
}
}
void *ldv_kmem_cache_alloc_956(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_962(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_964(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_966(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_967(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_968(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_969(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_970(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_971(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_972(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_998(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1006(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1014(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1008(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1004(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1012(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1013(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1009(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1010(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1011(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct wlan_pwr_cfg rtl8723AU_power_on_flow[16U] ;
struct wlan_pwr_cfg rtl8723AU_radio_off_flow[16U] ;
struct wlan_pwr_cfg rtl8723AU_card_disable_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_card_enable_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_suspend_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_resume_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_hwpdn_flow[31U] ;
struct wlan_pwr_cfg rtl8723AU_enter_lps_flow[16U] ;
struct wlan_pwr_cfg rtl8723AU_leave_lps_flow[16U] ;
struct wlan_pwr_cfg rtl8723AU_power_on_flow[16U] =
  { {32U, 255U, 15U, 3U, 0U, 1U, 1U, 1U},
        {103U, 255U, 15U, 3U, 0U, 1U, 16U, 0U},
        {1U, 255U, 15U, 3U, 0U, 3U, 1U, 1U},
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U},
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U},
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U},
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U},
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U},
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U},
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_radio_off_flow[16U] = { {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U},
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U},
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U},
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 32U},
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 0U},
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_card_disable_flow[31U] =
  { {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U},
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U},
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U},
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 32U},
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 0U},
        {7U, 255U, 15U, 1U, 0U, 1U, 255U, 32U},
        {5U, 255U, 15U, 3U, 0U, 1U, 24U, 8U},
        {5U, 255U, 15U, 4U, 0U, 1U, 4U, 4U},
        {74U, 255U, 15U, 2U, 0U, 1U, 1U, 1U},
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 16U},
        {134U, 255U, 15U, 1U, 3U, 1U, 1U, 1U},
        {134U, 255U, 15U, 1U, 3U, 2U, 2U, 0U},
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_card_enable_flow[31U] =
  { {5U, 255U, 15U, 15U, 0U, 1U, 136U, 0U},
        {134U, 255U, 15U, 1U, 3U, 1U, 1U, 0U},
        {134U, 255U, 15U, 1U, 3U, 2U, 2U, 2U},
        {74U, 255U, 15U, 2U, 0U, 1U, 1U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U},
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 0U},
        {769U, 255U, 15U, 4U, 0U, 1U, 255U, 0U},
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 1U},
        {103U, 255U, 15U, 3U, 0U, 1U, 16U, 0U},
        {1U, 255U, 15U, 3U, 0U, 3U, 1U, 1U},
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U},
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U},
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U},
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U},
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U},
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U},
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_suspend_flow[31U] =
  { {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U},
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U},
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U},
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 32U},
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 0U},
        {5U, 255U, 15U, 4U, 0U, 1U, 24U, 24U},
        {5U, 255U, 15U, 3U, 0U, 1U, 24U, 8U},
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 16U},
        {7U, 255U, 15U, 1U, 0U, 1U, 255U, 32U},
        {5U, 255U, 15U, 4U, 0U, 1U, 24U, 24U},
        {134U, 255U, 15U, 1U, 3U, 1U, 1U, 1U},
        {134U, 255U, 15U, 1U, 3U, 2U, 2U, 0U},
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_resume_flow[31U] =
  { {5U, 255U, 15U, 15U, 0U, 1U, 136U, 0U},
        {134U, 255U, 15U, 1U, 3U, 1U, 1U, 0U},
        {134U, 255U, 15U, 1U, 3U, 2U, 2U, 2U},
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U},
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 1U},
        {103U, 255U, 15U, 3U, 0U, 1U, 16U, 0U},
        {1U, 255U, 15U, 3U, 0U, 3U, 1U, 1U},
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U},
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U},
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U},
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U},
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U},
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U},
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_hwpdn_flow[31U] =
  { {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U},
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U},
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U},
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 32U},
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 0U},
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 16U},
        {7U, 255U, 15U, 3U, 0U, 1U, 255U, 32U},
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 0U},
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 128U},
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_enter_lps_flow[16U] =
  { {769U, 255U, 15U, 4U, 0U, 1U, 255U, 255U},
        {1314U, 255U, 15U, 15U, 0U, 1U, 255U, 255U},
        {1528U, 255U, 15U, 15U, 0U, 2U, 255U, 0U},
        {1529U, 255U, 15U, 15U, 0U, 2U, 255U, 0U},
        {1530U, 255U, 15U, 15U, 0U, 2U, 255U, 0U},
        {1531U, 255U, 15U, 15U, 0U, 2U, 255U, 0U},
        {2U, 255U, 15U, 15U, 0U, 1U, 1U, 0U},
        {2U, 255U, 15U, 15U, 0U, 3U, 0U, 0U},
        {2U, 255U, 15U, 15U, 0U, 1U, 2U, 0U},
        {256U, 255U, 15U, 15U, 0U, 1U, 255U, 3U},
        {257U, 255U, 15U, 15U, 0U, 1U, 2U, 0U},
        {147U, 255U, 15U, 1U, 0U, 1U, 255U, 0U},
        {1363U, 255U, 15U, 15U, 0U, 1U, 32U, 32U},
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
struct wlan_pwr_cfg rtl8723AU_leave_lps_flow[16U] =
  { {128U, 255U, 15U, 1U, 3U, 1U, 255U, 132U},
        {65112U, 255U, 15U, 2U, 0U, 1U, 255U, 132U},
        {865U, 255U, 15U, 4U, 0U, 1U, 255U, 132U},
        {2U, 255U, 15U, 15U, 0U, 3U, 0U, 1U},
        {8U, 255U, 15U, 15U, 0U, 1U, 16U, 0U},
        {265U, 255U, 15U, 15U, 0U, 2U, 128U, 0U},
        {41U, 255U, 15U, 15U, 0U, 1U, 192U, 0U},
        {257U, 255U, 15U, 15U, 0U, 1U, 2U, 2U},
        {256U, 255U, 15U, 15U, 0U, 1U, 255U, 255U},
        {2U, 255U, 15U, 15U, 0U, 1U, 3U, 3U},
        {1314U, 255U, 15U, 15U, 0U, 1U, 255U, 0U},
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
void *ldv_kmem_cache_alloc_998(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1004(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1006(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1008(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1009(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1010(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1011(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1012(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1013(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1014(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1040(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1048(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1056(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1050(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1046(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1054(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1055(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1051(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1052(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1053(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
u32 Rtl8723UPHY_REG_Array_PG[336U] ;
u32 Rtl8723UMACPHY_Array_PG[1U] ;
u32 Rtl8723UPHY_REG_Array_PG[336U] =
  { 3584U, 4294967295U, 168561676U, 3588U,
        4294967295U, 33818120U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 168561934U, 3604U,
        4294967295U, 33818120U, 3608U, 4294967295U,
        168561934U, 3612U, 4294967295U, 33818120U,
        2096U, 4294967295U, 168561676U, 2100U,
        4294967295U, 33818120U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 168561934U, 2120U,
        4294967295U, 33818120U, 2124U, 4294967295U,
        168561934U, 2152U, 4294967295U, 33818120U,
        3584U, 4294967295U, 0U, 3588U,
        4294967295U, 0U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 0U, 2100U,
        4294967295U, 0U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 67372036U, 3588U,
        4294967295U, 131588U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 101058054U, 3604U,
        4294967295U, 132102U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 67372036U, 2100U,
        4294967295U, 131588U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 101058054U, 2120U,
        4294967295U, 132102U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 0U, 3588U,
        4294967295U, 0U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 0U, 2100U,
        4294967295U, 0U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 0U, 3588U,
        4294967295U, 0U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 0U, 2100U,
        4294967295U, 0U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 67372036U, 3588U,
        4294967295U, 131588U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 67372036U, 2100U,
        4294967295U, 131588U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 0U, 3588U,
        4294967295U, 0U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 0U, 2100U,
        4294967295U, 0U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U};
u32 Rtl8723UMACPHY_Array_PG[1U] = { 0U};
void *ldv_kmem_cache_alloc_1040(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1046(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1048(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1050(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1051(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1052(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1053(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1054(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1055(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1056(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1082(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1090(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1098(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1092(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1088(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1096(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1097(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1093(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1094(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1095(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
u32 PHY_QueryBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask ) ;
void PHY_SetBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask , u32 Data ) ;
u32 PHY_QueryRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                   u32 BitMask ) ;
void PHY_SetRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) ;
u32 OFDMSwingTable23A[43U] ;
u8 CCKSwingTable_Ch1_Ch1323A[33U][8U] ;
u8 CCKSwingTable_Ch1423A[33U][8U] ;
void rtl8723a_phy_iq_calibrate(struct rtw_adapter *pAdapter , bool bReCovery ) ;
void rtl8723a_phy_lc_calibrate(struct rtw_adapter *pAdapter ) ;
void rtl8723a_phy_ap_calibrate(struct rtw_adapter *pAdapter , char delta ) ;
void rtl8723a_odm_check_tx_power_tracking(struct rtw_adapter *Adapter ) ;
static void odm_TXPowerTrackingCallback_ThermalMeter_92C(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 ThermalValue ;
  u8 delta ;
  u8 delta_LCK ;
  u8 delta_IQK ;
  u8 delta_HP ;
  int ele_A ;
  int ele_D ;
  int TempCCk ;
  int X ;
  int value32 ;
  int Y ;
  int ele_C ;
  s8 OFDM_index[2U] ;
  s8 CCK_index ;
  s8 OFDM_index_old[2U] ;
  unsigned int tmp ;
  s8 CCK_index_old ;
  int i ;
  bool is2T ;
  u8 OFDM_min_index ;
  u8 rf ;
  u8 ThermalValue_HP_count ;
  u32 ThermalValue_HP ;
  s32 index_mapping_HP[15U] ;
  s8 index_HP ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  ThermalValue = 0U;
  CCK_index = 0;
  OFDM_index_old[0] = 0;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {
    }
    OFDM_index_old[tmp] = (signed char)0;
    tmp = tmp + 1U;
  }
  CCK_index_old = 0;
  i = 0;
  is2T = (bool )(((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U);
  OFDM_min_index = 6U;
  ThermalValue_HP_count = 0U;
  ThermalValue_HP = 0U;
  index_mapping_HP[0] = 0;
  index_mapping_HP[1] = 1;
  index_mapping_HP[2] = 3;
  index_mapping_HP[3] = 4;
  index_mapping_HP[4] = 6;
  index_mapping_HP[5] = 7;
  index_mapping_HP[6] = 9;
  index_mapping_HP[7] = 10;
  index_mapping_HP[8] = 12;
  index_mapping_HP[9] = 13;
  index_mapping_HP[10] = 15;
  index_mapping_HP[11] = 16;
  index_mapping_HP[12] = 18;
  index_mapping_HP[13] = 19;
  index_mapping_HP[14] = 21;
  pdmpriv->TXPowerTrackingCallbackCnt = pdmpriv->TXPowerTrackingCallbackCnt + 1U;
  pdmpriv->bTXPowerTrackingInit = 1U;
  if ((unsigned int )pHalData->CurrentChannel == 14U && (unsigned int )pdmpriv->bCCKinCH14 == 0U) {
    pdmpriv->bCCKinCH14 = 1U;
  } else
  if ((unsigned int )pHalData->CurrentChannel != 14U && (unsigned int )pdmpriv->bCCKinCH14 != 0U) {
    pdmpriv->bCCKinCH14 = 0U;
  } else {
  }
  tmp___0 = PHY_QueryRFReg(Adapter, 0, 36U, 31U);
  ThermalValue = (unsigned char )tmp___0;
  rtl8723a_phy_ap_calibrate(Adapter, (int )((char )((int )ThermalValue - (int )pHalData->EEPROMThermalMeter)));
  if ((int )is2T) {
    rf = 2U;
  } else {
    rf = 1U;
  }
  if ((unsigned int )ThermalValue != 0U) {
    tmp___1 = PHY_QueryBBReg(Adapter, 3200U, 4294967295U);
    ele_D = (int )tmp___1 & -4194304;
    i = 0;
    goto ldv_54274;
    ldv_54273: ;
    if ((u32 )ele_D == (OFDMSwingTable23A[i] & 4290772992U)) {
      OFDM_index_old[0] = (s8 )i;
      goto ldv_54272;
    } else {
    }
    i = i + 1;
    ldv_54274: ;
    if (i <= 36) {
      goto ldv_54273;
    } else {
    }
    ldv_54272: ;
    if ((int )is2T) {
      tmp___2 = PHY_QueryBBReg(Adapter, 3208U, 4294967295U);
      ele_D = (int )tmp___2 & -4194304;
      i = 0;
      goto ldv_54277;
      ldv_54276: ;
      if ((u32 )ele_D == (OFDMSwingTable23A[i] & 4290772992U)) {
        OFDM_index_old[1] = (s8 )i;
        goto ldv_54275;
      } else {
      }
      i = i + 1;
      ldv_54277: ;
      if (i <= 36) {
        goto ldv_54276;
      } else {
      }
      ldv_54275: ;
    } else {
    }
    tmp___3 = PHY_QueryBBReg(Adapter, 2596U, 4294967295U);
    TempCCk = (int )tmp___3 & 1061109567;
    i = 0;
    goto ldv_54280;
    ldv_54279: ;
    if ((unsigned int )pdmpriv->bCCKinCH14 != 0U) {
      tmp___4 = memcmp((void const *)(& TempCCk), (void const *)(& CCKSwingTable_Ch1423A) + ((unsigned long )i + 2UL),
                       4UL);
      if (tmp___4 == 0) {
        CCK_index_old = (s8 )i;
        goto ldv_54278;
      } else {
      }
    } else {
      tmp___5 = memcmp((void const *)(& TempCCk), (void const *)(& CCKSwingTable_Ch1_Ch1323A) + ((unsigned long )i + 2UL),
                       4UL);
      if (tmp___5 == 0) {
        CCK_index_old = (s8 )i;
        goto ldv_54278;
      } else {
      }
    }
    i = i + 1;
    ldv_54280: ;
    if (i <= 32) {
      goto ldv_54279;
    } else {
    }
    ldv_54278: ;
    if ((unsigned int )pdmpriv->ThermalValue == 0U) {
      pdmpriv->ThermalValue = pHalData->EEPROMThermalMeter;
      pdmpriv->ThermalValue_LCK = ThermalValue;
      pdmpriv->ThermalValue_IQK = ThermalValue;
      pdmpriv->ThermalValue_DPK = pHalData->EEPROMThermalMeter;
      i = 0;
      goto ldv_54282;
      ldv_54281:
      pdmpriv->OFDM_index_HP[i] = (u8 )OFDM_index_old[i];
      pdmpriv->OFDM_index[i] = (u8 )OFDM_index_old[i];
      i = i + 1;
      ldv_54282: ;
      if ((int )rf > i) {
        goto ldv_54281;
      } else {
      }
      pdmpriv->CCK_index_HP = (u8 )CCK_index_old;
      pdmpriv->CCK_index = (u8 )CCK_index_old;
    } else {
    }
    if ((unsigned int )pHalData->BoardType == 1U) {
      pdmpriv->ThermalValue_HP[(int )pdmpriv->ThermalValue_HP_index] = ThermalValue;
      pdmpriv->ThermalValue_HP_index = (u8 )((int )pdmpriv->ThermalValue_HP_index + 1);
      if ((unsigned int )pdmpriv->ThermalValue_HP_index == 8U) {
        pdmpriv->ThermalValue_HP_index = 0U;
      } else {
      }
      i = 0;
      goto ldv_54285;
      ldv_54284: ;
      if ((unsigned int )pdmpriv->ThermalValue_HP[i] != 0U) {
        ThermalValue_HP = (u32 )pdmpriv->ThermalValue_HP[i] + ThermalValue_HP;
        ThermalValue_HP_count = (u8 )((int )ThermalValue_HP_count + 1);
      } else {
      }
      i = i + 1;
      ldv_54285: ;
      if (i <= 7) {
        goto ldv_54284;
      } else {
      }
      if ((unsigned int )ThermalValue_HP_count != 0U) {
        ThermalValue = (unsigned char )(ThermalValue_HP / (u32 )ThermalValue_HP_count);
      } else {
      }
    } else {
    }
    delta = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
    if ((unsigned int )pHalData->BoardType == 1U) {
      if ((unsigned int )pdmpriv->bDoneTxpower != 0U) {
        delta_HP = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
      } else {
        delta_HP = (int )pHalData->EEPROMThermalMeter < (int )ThermalValue ? (int )ThermalValue - (int )pHalData->EEPROMThermalMeter : (int )pHalData->EEPROMThermalMeter - (int )ThermalValue;
      }
    } else {
      delta_HP = 0U;
    }
    delta_LCK = (int )pdmpriv->ThermalValue_LCK < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue_LCK : (int )pdmpriv->ThermalValue_LCK - (int )ThermalValue;
    delta_IQK = (int )pdmpriv->ThermalValue_IQK < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue_IQK : (int )pdmpriv->ThermalValue_IQK - (int )ThermalValue;
    if ((unsigned int )delta_LCK > 1U) {
      pdmpriv->ThermalValue_LCK = ThermalValue;
      rtl8723a_phy_lc_calibrate(Adapter);
    } else {
    }
    if (((unsigned int )delta != 0U || (unsigned int )delta_HP != 0U) && (unsigned int )pdmpriv->TxPowerTrackControl != 0U) {
      if ((unsigned int )pHalData->BoardType == 1U) {
        pdmpriv->bDoneTxpower = 1U;
        delta_HP = (int )pHalData->EEPROMThermalMeter < (int )ThermalValue ? (int )ThermalValue - (int )pHalData->EEPROMThermalMeter : (int )pHalData->EEPROMThermalMeter - (int )ThermalValue;
        if ((unsigned int )delta_HP > 14U) {
          index_HP = (s8 )index_mapping_HP[14];
        } else {
          index_HP = (s8 )index_mapping_HP[(int )delta_HP];
        }
        if ((int )pHalData->EEPROMThermalMeter < (int )ThermalValue) {
          i = 0;
          goto ldv_54288;
          ldv_54287:
          OFDM_index[i] = (s8 )((int )pdmpriv->OFDM_index_HP[i] - (int )((unsigned char )index_HP));
          i = i + 1;
          ldv_54288: ;
          if ((int )rf > i) {
            goto ldv_54287;
          } else {
          }
          CCK_index = (s8 )((int )pdmpriv->CCK_index_HP - (int )((unsigned char )index_HP));
        } else {
          i = 0;
          goto ldv_54291;
          ldv_54290:
          OFDM_index[i] = (s8 )((int )pdmpriv->OFDM_index_HP[i] + (int )((unsigned char )index_HP));
          i = i + 1;
          ldv_54291: ;
          if ((int )rf > i) {
            goto ldv_54290;
          } else {
          }
          CCK_index = (s8 )((int )pdmpriv->CCK_index_HP + (int )((unsigned char )index_HP));
        }
        delta_HP = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
      } else
      if ((int )pdmpriv->ThermalValue < (int )ThermalValue) {
        i = 0;
        goto ldv_54294;
        ldv_54293:
        pdmpriv->OFDM_index[i] = (int )pdmpriv->OFDM_index[i] - (int )delta;
        i = i + 1;
        ldv_54294: ;
        if ((int )rf > i) {
          goto ldv_54293;
        } else {
        }
        pdmpriv->CCK_index = (int )pdmpriv->CCK_index - (int )delta;
      } else {
        i = 0;
        goto ldv_54297;
        ldv_54296:
        pdmpriv->OFDM_index[i] = (int )pdmpriv->OFDM_index[i] + (int )delta;
        i = i + 1;
        ldv_54297: ;
        if ((int )rf > i) {
          goto ldv_54296;
        } else {
        }
        pdmpriv->CCK_index = (int )pdmpriv->CCK_index + (int )delta;
      }
      if ((unsigned int )pHalData->BoardType != 1U) {
        if ((int )pHalData->EEPROMThermalMeter < (int )ThermalValue) {
          i = 0;
          goto ldv_54300;
          ldv_54299:
          OFDM_index[i] = (s8 )((unsigned int )pdmpriv->OFDM_index[i] + 1U);
          i = i + 1;
          ldv_54300: ;
          if ((int )rf > i) {
            goto ldv_54299;
          } else {
          }
          CCK_index = (s8 )((unsigned int )pdmpriv->CCK_index + 1U);
        } else {
          i = 0;
          goto ldv_54303;
          ldv_54302:
          OFDM_index[i] = (s8 )pdmpriv->OFDM_index[i];
          i = i + 1;
          ldv_54303: ;
          if ((int )rf > i) {
            goto ldv_54302;
          } else {
          }
          CCK_index = (s8 )pdmpriv->CCK_index;
        }
      } else {
      }
      i = 0;
      goto ldv_54306;
      ldv_54305: ;
      if ((int )OFDM_index[i] > 36) {
        OFDM_index[i] = 36;
      } else
      if ((int )OFDM_index[i] < (int )OFDM_min_index) {
        OFDM_index[i] = (s8 )OFDM_min_index;
      } else {
      }
      i = i + 1;
      ldv_54306: ;
      if ((int )rf > i) {
        goto ldv_54305;
      } else {
      }
      if ((int )CCK_index > 32) {
        CCK_index = 32;
      } else
      if ((int )CCK_index < 0) {
        CCK_index = 0;
      } else {
      }
    } else {
    }
    if ((unsigned int )pdmpriv->TxPowerTrackControl != 0U && ((unsigned int )delta != 0U || (unsigned int )delta_HP != 0U)) {
      ele_D = (int )(OFDMSwingTable23A[(int )OFDM_index[0]] >> 22);
      X = pdmpriv->RegE94;
      Y = pdmpriv->RegE9C;
      if (X != 0) {
        if ((X & 512) != 0) {
          X = (int )((unsigned int )X | 4294966272U);
        } else {
        }
        ele_A = (X * ele_D >> 8) & 1023;
        if ((Y & 512) != 0) {
          Y = (int )((unsigned int )Y | 4294966272U);
        } else {
        }
        ele_C = (Y * ele_D >> 8) & 1023;
        value32 = ((ele_D << 22) | ((ele_C & 63) << 16)) | ele_A;
        PHY_SetBBReg(Adapter, 3200U, 4294967295U, (u32 )value32);
        value32 = (ele_C & 960) >> 6;
        PHY_SetBBReg(Adapter, 3220U, 4026531840U, (u32 )value32);
        value32 = (X * ele_D >> 7) & 1;
        PHY_SetBBReg(Adapter, 3148U, 2147483648U, (u32 )value32);
        value32 = (Y * ele_D >> 7) & 1;
        PHY_SetBBReg(Adapter, 3148U, 536870912U, (u32 )value32);
      } else {
        PHY_SetBBReg(Adapter, 3200U, 4294967295U, OFDMSwingTable23A[(int )OFDM_index[0]]);
        PHY_SetBBReg(Adapter, 3220U, 4026531840U, 0U);
        PHY_SetBBReg(Adapter, 3148U, 2684354560U, 0U);
      }
      if ((unsigned int )pdmpriv->bCCKinCH14 == 0U) {
        rtl8723au_write8(Adapter, 2594U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][0]);
        rtl8723au_write8(Adapter, 2595U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][1]);
        rtl8723au_write8(Adapter, 2596U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][2]);
        rtl8723au_write8(Adapter, 2597U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][3]);
        rtl8723au_write8(Adapter, 2598U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][4]);
        rtl8723au_write8(Adapter, 2599U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][5]);
        rtl8723au_write8(Adapter, 2600U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][6]);
        rtl8723au_write8(Adapter, 2601U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][7]);
      } else {
        rtl8723au_write8(Adapter, 2594U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][0]);
        rtl8723au_write8(Adapter, 2595U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][1]);
        rtl8723au_write8(Adapter, 2596U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][2]);
        rtl8723au_write8(Adapter, 2597U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][3]);
        rtl8723au_write8(Adapter, 2598U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][4]);
        rtl8723au_write8(Adapter, 2599U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][5]);
        rtl8723au_write8(Adapter, 2600U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][6]);
        rtl8723au_write8(Adapter, 2601U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][7]);
      }
      if ((int )is2T) {
        ele_D = (int )(OFDMSwingTable23A[(int )((unsigned char )OFDM_index[1])] >> 22);
        X = pdmpriv->RegEB4;
        Y = pdmpriv->RegEBC;
        if (X != 0) {
          if ((X & 512) != 0) {
            X = (int )((unsigned int )X | 4294966272U);
          } else {
          }
          ele_A = (X * ele_D >> 8) & 1023;
          if ((Y & 512) != 0) {
            Y = (int )((unsigned int )Y | 4294966272U);
          } else {
          }
          ele_C = (Y * ele_D >> 8) & 1023;
          value32 = ((ele_D << 22) | ((ele_C & 63) << 16)) | ele_A;
          PHY_SetBBReg(Adapter, 3208U, 4294967295U, (u32 )value32);
          value32 = (ele_C & 960) >> 6;
          PHY_SetBBReg(Adapter, 3228U, 4026531840U, (u32 )value32);
          value32 = (X * ele_D >> 7) & 1;
          PHY_SetBBReg(Adapter, 3148U, 134217728U, (u32 )value32);
          value32 = (Y * ele_D >> 7) & 1;
          PHY_SetBBReg(Adapter, 3148U, 33554432U, (u32 )value32);
        } else {
          PHY_SetBBReg(Adapter, 3208U, 4294967295U, OFDMSwingTable23A[(int )OFDM_index[1]]);
          PHY_SetBBReg(Adapter, 3228U, 4026531840U, 0U);
          PHY_SetBBReg(Adapter, 3148U, 167772160U, 0U);
        }
      } else {
      }
    } else {
    }
    if ((unsigned int )delta_IQK > 3U) {
      pdmpriv->ThermalValue_IQK = ThermalValue;
      rtl8723a_phy_iq_calibrate(Adapter, 0);
    } else {
    }
    if ((unsigned int )pdmpriv->TxPowerTrackControl != 0U) {
      pdmpriv->ThermalValue = ThermalValue;
    } else {
    }
  } else {
  }
  pdmpriv->TXPowercount = 0U;
  return;
}
}
static void ODM_TXPowerTracking92CDirectCall(struct rtw_adapter *Adapter )
{
  {
  odm_TXPowerTrackingCallback_ThermalMeter_92C(Adapter);
  return;
}
}
static void odm_CheckTXPowerTracking_ThermalMeter(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *podmpriv ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  podmpriv = & pHalData->odmpriv;
  if ((podmpriv->SupportAbility & 16777216U) == 0U) {
    return;
  } else {
  }
  if ((unsigned int )pdmpriv->TM_Trigger == 0U) {
    PHY_SetRFReg(Adapter, 0, 36U, 1048575U, 96U);
    pdmpriv->TM_Trigger = 1U;
    return;
  } else {
    ODM_TXPowerTracking92CDirectCall(Adapter);
    pdmpriv->TM_Trigger = 0U;
  }
  return;
}
}
void rtl8723a_odm_check_tx_power_tracking(struct rtw_adapter *Adapter )
{
  {
  odm_CheckTXPowerTracking_ThermalMeter(Adapter);
  return;
}
}
static u8 _PHY_PathA_IQK(struct rtw_adapter *pAdapter , bool configPathB )
{
  u32 regEAC ;
  u32 regE94 ;
  u32 regE9C ;
  u32 regEA4 ;
  u8 result ;
  struct hal_data_8723a *pHalData ;
  {
  result = 0U;
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  PHY_SetBBReg(pAdapter, 3632U, 4294967295U, 268471327U);
  PHY_SetBBReg(pAdapter, 3636U, 4294967295U, 268471327U);
  PHY_SetBBReg(pAdapter, 3640U, 4294967295U, 2182349058U);
  PHY_SetBBReg(pAdapter, 3644U, 4294967295U, (int )configPathB ? 672530946U : (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) ? 672530946U : 672531714U));
  if ((int )configPathB) {
    PHY_SetBBReg(pAdapter, 3664U, 4294967295U, 268471330U);
    PHY_SetBBReg(pAdapter, 3668U, 4294967295U, 268471330U);
    PHY_SetBBReg(pAdapter, 3672U, 4294967295U, 2182349058U);
    PHY_SetBBReg(pAdapter, 3676U, 4294967295U, 672530946U);
  } else {
  }
  PHY_SetBBReg(pAdapter, 3660U, 4294967295U, 1059025U);
  PHY_SetBBReg(pAdapter, 3656U, 4294967295U, 4177526784U);
  PHY_SetBBReg(pAdapter, 3656U, 4294967295U, 4160749568U);
  __const_udelay(4295000UL);
  regEAC = PHY_QueryBBReg(pAdapter, 3756U, 4294967295U);
  regE94 = PHY_QueryBBReg(pAdapter, 3732U, 4294967295U);
  regE9C = PHY_QueryBBReg(pAdapter, 3740U, 4294967295U);
  regEA4 = PHY_QueryBBReg(pAdapter, 3748U, 4294967295U);
  if ((((unsigned long )regEAC & 268435456UL) == 0UL && (regE94 & 67043328U) >> 16 != 322U) && (regE9C & 67043328U) >> 16 != 66U) {
    result = (u8 )((unsigned int )result | 1U);
  } else {
    return (result);
  }
  if ((((unsigned long )regEAC & 134217728UL) == 0UL && (regEA4 & 67043328U) >> 16 != 306U) && (regEAC & 67043328U) >> 16 != 54U) {
    result = (u8 )((unsigned int )result | 2U);
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Path A Rx IQK fail!!\n");
  } else {
  }
  return (result);
}
}
static u8 _PHY_PathB_IQK(struct rtw_adapter *pAdapter )
{
  u32 regEAC ;
  u32 regEB4 ;
  u32 regEBC ;
  u32 regEC4 ;
  u32 regECC ;
  u8 result ;
  {
  result = 0U;
  PHY_SetBBReg(pAdapter, 3680U, 4294967295U, 2U);
  PHY_SetBBReg(pAdapter, 3680U, 4294967295U, 0U);
  __const_udelay(4295000UL);
  regEAC = PHY_QueryBBReg(pAdapter, 3756U, 4294967295U);
  regEB4 = PHY_QueryBBReg(pAdapter, 3764U, 4294967295U);
  regEBC = PHY_QueryBBReg(pAdapter, 3772U, 4294967295U);
  regEC4 = PHY_QueryBBReg(pAdapter, 3780U, 4294967295U);
  regECC = PHY_QueryBBReg(pAdapter, 3788U, 4294967295U);
  if (((int )regEAC >= 0 && (regEB4 & 67043328U) >> 16 != 322U) && (regEBC & 67043328U) >> 16 != 66U) {
    result = (u8 )((unsigned int )result | 1U);
  } else {
    return (result);
  }
  if ((((unsigned long )regEAC & 1073741824UL) == 0UL && (regEC4 & 67043328U) >> 16 != 306U) && (regECC & 67043328U) >> 16 != 54U) {
    result = (u8 )((unsigned int )result | 2U);
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Path B Rx IQK fail!!\n");
  } else {
  }
  return (result);
}
}
static void _PHY_PathAFillIQKMatrix(struct rtw_adapter *pAdapter , bool bIQKOK , int (*result)[8U] ,
                                    u8 final_candidate , bool bTxOnly )
{
  u32 Oldval_0 ;
  u32 X ;
  u32 TX0_A ;
  u32 reg ;
  s32 Y ;
  s32 TX0_C ;
  u32 tmp ;
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Path A IQ Calibration %s !\n", (int )bIQKOK ? (char *)"Success" : (char *)"Failed");
  } else {
  }
  if ((unsigned int )final_candidate == 255U) {
    return;
  } else
  if ((int )bIQKOK) {
    tmp = PHY_QueryBBReg(pAdapter, 3200U, 4294967295U);
    Oldval_0 = tmp >> 22;
    X = (u32 )(*(result + (unsigned long )final_candidate))[0];
    if ((X & 512U) != 0U) {
      X = X | 4294966272U;
    } else {
    }
    TX0_A = X * Oldval_0 >> 8;
    PHY_SetBBReg(pAdapter, 3200U, 1023U, TX0_A);
    PHY_SetBBReg(pAdapter, 3148U, 2147483648U, (X * Oldval_0 >> 7) & 1U);
    Y = (*(result + (unsigned long )final_candidate))[1];
    if ((Y & 512) != 0) {
      Y = (s32 )((unsigned int )Y | 4294966272U);
    } else {
    }
    TX0_C = (s32 )((u32 )Y * Oldval_0 >> 8);
    PHY_SetBBReg(pAdapter, 3220U, 4026531840U, (u32 )((TX0_C & 960) >> 6));
    PHY_SetBBReg(pAdapter, 3200U, 4128768U, (u32 )TX0_C & 63U);
    PHY_SetBBReg(pAdapter, 3148U, 536870912U, ((u32 )Y * Oldval_0 >> 7) & 1U);
    if ((int )bTxOnly) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: _PHY_PathAFillIQKMatrix only Tx OK\n");
      } else {
      }
      return;
    } else {
    }
    reg = (u32 )(*(result + (unsigned long )final_candidate))[2];
    PHY_SetBBReg(pAdapter, 3092U, 1023U, reg);
    reg = (u32 )(*(result + (unsigned long )final_candidate))[3] & 63U;
    PHY_SetBBReg(pAdapter, 3092U, 64512U, reg);
    reg = (u32 )((*(result + (unsigned long )final_candidate))[3] >> 6) & 15U;
    PHY_SetBBReg(pAdapter, 3232U, 4026531840U, reg);
  } else {
  }
  return;
}
}
static void _PHY_PathBFillIQKMatrix(struct rtw_adapter *pAdapter , bool bIQKOK , int (*result)[8U] ,
                                    u8 final_candidate , bool bTxOnly )
{
  u32 Oldval_1 ;
  u32 X ;
  u32 TX1_A ;
  u32 reg ;
  s32 Y ;
  s32 TX1_C ;
  u32 tmp ;
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Path B IQ Calibration %s !\n", (int )bIQKOK ? (char *)"Success" : (char *)"Failed");
  } else {
  }
  if ((unsigned int )final_candidate == 255U) {
    return;
  } else
  if ((int )bIQKOK) {
    tmp = PHY_QueryBBReg(pAdapter, 3208U, 4294967295U);
    Oldval_1 = tmp >> 22;
    X = (u32 )(*(result + (unsigned long )final_candidate))[4];
    if ((X & 512U) != 0U) {
      X = X | 4294966272U;
    } else {
    }
    TX1_A = X * Oldval_1 >> 8;
    PHY_SetBBReg(pAdapter, 3208U, 1023U, TX1_A);
    PHY_SetBBReg(pAdapter, 3148U, 134217728U, (X * Oldval_1 >> 7) & 1U);
    Y = (*(result + (unsigned long )final_candidate))[5];
    if ((Y & 512) != 0) {
      Y = (s32 )((unsigned int )Y | 4294966272U);
    } else {
    }
    TX1_C = (s32 )((u32 )Y * Oldval_1 >> 8);
    PHY_SetBBReg(pAdapter, 3228U, 4026531840U, (u32 )((TX1_C & 960) >> 6));
    PHY_SetBBReg(pAdapter, 3208U, 4128768U, (u32 )TX1_C & 63U);
    PHY_SetBBReg(pAdapter, 3148U, 33554432U, ((u32 )Y * Oldval_1 >> 7) & 1U);
    if ((int )bTxOnly) {
      return;
    } else {
    }
    reg = (u32 )(*(result + (unsigned long )final_candidate))[6];
    PHY_SetBBReg(pAdapter, 3100U, 1023U, reg);
    reg = (u32 )(*(result + (unsigned long )final_candidate))[7] & 63U;
    PHY_SetBBReg(pAdapter, 3100U, 64512U, reg);
    reg = (u32 )((*(result + (unsigned long )final_candidate))[7] >> 6) & 15U;
    PHY_SetBBReg(pAdapter, 3192U, 61440U, reg);
  } else {
  }
  return;
}
}
static void _PHY_SaveADDARegisters(struct rtw_adapter *pAdapter , u32 *ADDAReg , u32 *ADDABackup ,
                                   u32 RegisterNum )
{
  u32 i ;
  {
  i = 0U;
  goto ldv_54373;
  ldv_54372:
  *(ADDABackup + (unsigned long )i) = PHY_QueryBBReg(pAdapter, *(ADDAReg + (unsigned long )i),
                                                     4294967295U);
  i = i + 1U;
  ldv_54373: ;
  if (i < RegisterNum) {
    goto ldv_54372;
  } else {
  }
  return;
}
}
static void _PHY_SaveMACRegisters(struct rtw_adapter *pAdapter , u32 *MACReg , u32 *MACBackup )
{
  u32 i ;
  u8 tmp ;
  {
  i = 0U;
  goto ldv_54382;
  ldv_54381:
  tmp = rtl8723au_read8(pAdapter, *(MACReg + (unsigned long )i));
  *(MACBackup + (unsigned long )i) = (u32 )tmp;
  i = i + 1U;
  ldv_54382: ;
  if (i <= 2U) {
    goto ldv_54381;
  } else {
  }
  *(MACBackup + (unsigned long )i) = rtl8723au_read32(pAdapter, *(MACReg + (unsigned long )i));
  return;
}
}
static void _PHY_ReloadADDARegisters(struct rtw_adapter *pAdapter , u32 *ADDAReg ,
                                     u32 *ADDABackup , u32 RegiesterNum )
{
  u32 i ;
  {
  i = 0U;
  goto ldv_54392;
  ldv_54391:
  PHY_SetBBReg(pAdapter, *(ADDAReg + (unsigned long )i), 4294967295U, *(ADDABackup + (unsigned long )i));
  i = i + 1U;
  ldv_54392: ;
  if (i < RegiesterNum) {
    goto ldv_54391;
  } else {
  }
  return;
}
}
static void _PHY_ReloadMACRegisters(struct rtw_adapter *pAdapter , u32 *MACReg , u32 *MACBackup )
{
  u32 i ;
  {
  i = 0U;
  goto ldv_54401;
  ldv_54400:
  rtl8723au_write8(pAdapter, *(MACReg + (unsigned long )i), (int )((unsigned char )*(MACBackup + (unsigned long )i)));
  i = i + 1U;
  ldv_54401: ;
  if (i <= 2U) {
    goto ldv_54400;
  } else {
  }
  rtl8723au_write32(pAdapter, *(MACReg + (unsigned long )i), *(MACBackup + (unsigned long )i));
  return;
}
}
static void _PHY_PathADDAOn(struct rtw_adapter *pAdapter , u32 *ADDAReg , bool isPathAOn ,
                            bool is2T )
{
  u32 pathOn ;
  u32 i ;
  {
  pathOn = (int )isPathAOn ? 81470884U : 186328484U;
  if (! is2T) {
    pathOn = 198911392U;
    PHY_SetBBReg(pAdapter, *ADDAReg, 4294967295U, 186328480U);
  } else {
    PHY_SetBBReg(pAdapter, *ADDAReg, 4294967295U, pathOn);
  }
  i = 1U;
  goto ldv_54412;
  ldv_54411:
  PHY_SetBBReg(pAdapter, *(ADDAReg + (unsigned long )i), 4294967295U, pathOn);
  i = i + 1U;
  ldv_54412: ;
  if (i <= 15U) {
    goto ldv_54411;
  } else {
  }
  return;
}
}
static void _PHY_MACSettingCalibration(struct rtw_adapter *pAdapter , u32 *MACReg ,
                                       u32 *MACBackup )
{
  u32 i ;
  {
  i = 0U;
  rtl8723au_write8(pAdapter, *(MACReg + (unsigned long )i), 63);
  i = 1U;
  goto ldv_54421;
  ldv_54420:
  rtl8723au_write8(pAdapter, *(MACReg + (unsigned long )i), (int )((unsigned char )*(MACBackup + (unsigned long )i)) & 247);
  i = i + 1U;
  ldv_54421: ;
  if (i <= 2U) {
    goto ldv_54420;
  } else {
  }
  rtl8723au_write8(pAdapter, *(MACReg + (unsigned long )i), (int )((unsigned char )*(MACBackup + (unsigned long )i)) & 223);
  return;
}
}
static void _PHY_PathAStandBy(struct rtw_adapter *pAdapter )
{
  {
  PHY_SetBBReg(pAdapter, 3624U, 4294967295U, 0U);
  PHY_SetBBReg(pAdapter, 2112U, 4294967295U, 65536U);
  PHY_SetBBReg(pAdapter, 3624U, 4294967295U, 2155872256U);
  return;
}
}
static void _PHY_PIModeSwitch(struct rtw_adapter *pAdapter , bool PIMode )
{
  u32 mode ;
  {
  mode = (int )PIMode ? 16777472U : 16777216U;
  PHY_SetBBReg(pAdapter, 2080U, 4294967295U, mode);
  PHY_SetBBReg(pAdapter, 2088U, 4294967295U, mode);
  return;
}
}
static bool _PHY_SimularityCompare(struct rtw_adapter *pAdapter , int (*result)[8U] ,
                                   u8 c1 , u8 c2 )
{
  u32 i ;
  u32 j ;
  u32 diff ;
  u32 SimularityBitMap ;
  u32 bound ;
  struct hal_data_8723a *pHalData ;
  u8 final_candidate[2U] ;
  bool bResult ;
  bool is2T ;
  {
  bound = 0U;
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  final_candidate[0] = 255U;
  final_candidate[1] = 255U;
  bResult = 1;
  is2T = (bool )(((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U);
  if ((int )is2T) {
    bound = 8U;
  } else {
    bound = 4U;
  }
  SimularityBitMap = 0U;
  i = 0U;
  goto ldv_54447;
  ldv_54446:
  diff = (u32 )((*(result + (unsigned long )c1))[i] > (*(result + (unsigned long )c2))[i] ? (*(result + (unsigned long )c1))[i] - (*(result + (unsigned long )c2))[i] : (*(result + (unsigned long )c2))[i] - (*(result + (unsigned long )c1))[i]);
  if (diff > 5U) {
    if ((i == 2U || i == 6U) && SimularityBitMap == 0U) {
      if ((*(result + (unsigned long )c1))[i] + (*(result + (unsigned long )c1))[i + 1U] == 0) {
        final_candidate[i / 4U] = c2;
      } else
      if ((*(result + (unsigned long )c2))[i] + (*(result + (unsigned long )c2))[i + 1U] == 0) {
        final_candidate[i / 4U] = c1;
      } else {
        SimularityBitMap = (u32 )(1 << (int )i) | SimularityBitMap;
      }
    } else {
      SimularityBitMap = (u32 )(1 << (int )i) | SimularityBitMap;
    }
  } else {
  }
  i = i + 1U;
  ldv_54447: ;
  if (i < bound) {
    goto ldv_54446;
  } else {
  }
  if (SimularityBitMap == 0U) {
    i = 0U;
    goto ldv_54453;
    ldv_54452: ;
    if ((unsigned int )final_candidate[i] != 255U) {
      j = i * 4U;
      goto ldv_54450;
      ldv_54449:
      (*(result + 3UL))[j] = (*(result + (unsigned long )final_candidate[i]))[j];
      j = j + 1U;
      ldv_54450: ;
      if ((i + 1U) * 4U - 2U > j) {
        goto ldv_54449;
      } else {
      }
      bResult = 0;
    } else {
    }
    i = i + 1U;
    ldv_54453: ;
    if (bound / 4U > i) {
      goto ldv_54452;
    } else {
    }
    return (bResult);
  } else
  if ((SimularityBitMap & 15U) == 0U) {
    i = 0U;
    goto ldv_54456;
    ldv_54455:
    (*(result + 3UL))[i] = (*(result + (unsigned long )c1))[i];
    i = i + 1U;
    ldv_54456: ;
    if (i <= 3U) {
      goto ldv_54455;
    } else {
    }
    return (0);
  } else
  if ((SimularityBitMap & 240U) == 0U && (int )is2T) {
    i = 4U;
    goto ldv_54459;
    ldv_54458:
    (*(result + 3UL))[i] = (*(result + (unsigned long )c1))[i];
    i = i + 1U;
    ldv_54459: ;
    if (i <= 7U) {
      goto ldv_54458;
    } else {
    }
    return (0);
  } else {
    return (0);
  }
}
}
static void _PHY_IQCalibrate(struct rtw_adapter *pAdapter , int (*result)[8U] , u8 t ,
                             bool is2T )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u32 i ;
  u8 PathAOK ;
  u8 PathBOK ;
  u32 ADDA_REG[16U] ;
  u32 IQK_MAC_REG[4U] ;
  u32 IQK_BB_REG_92C[9U] ;
  u32 retryCount ;
  u32 bbvalue ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  ADDA_REG[0] = 2140U;
  ADDA_REG[1] = 3692U;
  ADDA_REG[2] = 3696U;
  ADDA_REG[3] = 3700U;
  ADDA_REG[4] = 3704U;
  ADDA_REG[5] = 3708U;
  ADDA_REG[6] = 3712U;
  ADDA_REG[7] = 3716U;
  ADDA_REG[8] = 3720U;
  ADDA_REG[9] = 3724U;
  ADDA_REG[10] = 3792U;
  ADDA_REG[11] = 3796U;
  ADDA_REG[12] = 3800U;
  ADDA_REG[13] = 3804U;
  ADDA_REG[14] = 3808U;
  ADDA_REG[15] = 3820U;
  IQK_MAC_REG[0] = 1314U;
  IQK_MAC_REG[1] = 1360U;
  IQK_MAC_REG[2] = 1361U;
  IQK_MAC_REG[3] = 64U;
  IQK_BB_REG_92C[0] = 3076U;
  IQK_BB_REG_92C[1] = 3080U;
  IQK_BB_REG_92C[2] = 2164U;
  IQK_BB_REG_92C[3] = 2920U;
  IQK_BB_REG_92C[4] = 2924U;
  IQK_BB_REG_92C[5] = 2160U;
  IQK_BB_REG_92C[6] = 2144U;
  IQK_BB_REG_92C[7] = 2148U;
  IQK_BB_REG_92C[8] = 2048U;
  retryCount = 2U;
  if ((unsigned int )t == 0U) {
    bbvalue = PHY_QueryBBReg(pAdapter, 2048U, 4294967295U);
    _PHY_SaveADDARegisters(pAdapter, (u32 *)(& ADDA_REG), (u32 *)(& pdmpriv->ADDA_backup),
                           16U);
    _PHY_SaveMACRegisters(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
    _PHY_SaveADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup),
                           9U);
  } else {
  }
  _PHY_PathADDAOn(pAdapter, (u32 *)(& ADDA_REG), 1, (int )is2T);
  if ((unsigned int )t == 0U) {
    tmp = PHY_QueryBBReg(pAdapter, 2080U, 256U);
    pdmpriv->bRfPiEnable = (unsigned char )tmp;
  } else {
  }
  if ((unsigned int )pdmpriv->bRfPiEnable == 0U) {
    _PHY_PIModeSwitch(pAdapter, 1);
  } else {
  }
  PHY_SetBBReg(pAdapter, 2048U, 16777216U, 0U);
  PHY_SetBBReg(pAdapter, 3076U, 4294967295U, 60839424U);
  PHY_SetBBReg(pAdapter, 3080U, 4294967295U, 524516U);
  PHY_SetBBReg(pAdapter, 2164U, 4294967295U, 572538880U);
  PHY_SetBBReg(pAdapter, 2160U, 1024U, 1U);
  PHY_SetBBReg(pAdapter, 2160U, 67108864U, 1U);
  PHY_SetBBReg(pAdapter, 2144U, 1024U, 0U);
  PHY_SetBBReg(pAdapter, 2148U, 1024U, 0U);
  if ((int )is2T) {
    PHY_SetBBReg(pAdapter, 2112U, 4294967295U, 65536U);
    PHY_SetBBReg(pAdapter, 2116U, 4294967295U, 65536U);
  } else {
  }
  _PHY_MACSettingCalibration(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
  PHY_SetBBReg(pAdapter, 2920U, 4294967295U, 524288U);
  if ((int )is2T) {
    PHY_SetBBReg(pAdapter, 2924U, 4294967295U, 524288U);
  } else {
  }
  PHY_SetBBReg(pAdapter, 3624U, 4294967295U, 2155872256U);
  PHY_SetBBReg(pAdapter, 3648U, 4294967295U, 16808960U);
  PHY_SetBBReg(pAdapter, 3652U, 4294967295U, 16795648U);
  i = 0U;
  goto ldv_54479;
  ldv_54478:
  PathAOK = _PHY_PathA_IQK(pAdapter, (int )is2T);
  if ((unsigned int )PathAOK == 3U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Path A IQK Success!!\n");
    } else {
    }
    tmp___0 = PHY_QueryBBReg(pAdapter, 3732U, 4294967295U);
    (*(result + (unsigned long )t))[0] = (int )((tmp___0 & 67043328U) >> 16);
    tmp___1 = PHY_QueryBBReg(pAdapter, 3740U, 4294967295U);
    (*(result + (unsigned long )t))[1] = (int )((tmp___1 & 67043328U) >> 16);
    tmp___2 = PHY_QueryBBReg(pAdapter, 3748U, 4294967295U);
    (*(result + (unsigned long )t))[2] = (int )((tmp___2 & 67043328U) >> 16);
    tmp___3 = PHY_QueryBBReg(pAdapter, 3756U, 4294967295U);
    (*(result + (unsigned long )t))[3] = (int )((tmp___3 & 67043328U) >> 16);
    goto ldv_54477;
  } else
  if (retryCount - 1U == i && (unsigned int )PathAOK == 1U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Path A IQK Only  Tx Success!!\n");
    } else {
    }
    tmp___4 = PHY_QueryBBReg(pAdapter, 3732U, 4294967295U);
    (*(result + (unsigned long )t))[0] = (int )((tmp___4 & 67043328U) >> 16);
    tmp___5 = PHY_QueryBBReg(pAdapter, 3740U, 4294967295U);
    (*(result + (unsigned long )t))[1] = (int )((tmp___5 & 67043328U) >> 16);
  } else {
  }
  i = i + 1U;
  ldv_54479: ;
  if (i < retryCount) {
    goto ldv_54478;
  } else {
  }
  ldv_54477: ;
  if ((unsigned int )PathAOK == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Path A IQK failed!!\n");
    } else {
    }
  } else {
  }
  if ((int )is2T) {
    _PHY_PathAStandBy(pAdapter);
    _PHY_PathADDAOn(pAdapter, (u32 *)(& ADDA_REG), 0, (int )is2T);
    i = 0U;
    goto ldv_54482;
    ldv_54481:
    PathBOK = _PHY_PathB_IQK(pAdapter);
    if ((unsigned int )PathBOK == 3U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Path B IQK Success!!\n");
      } else {
      }
      tmp___6 = PHY_QueryBBReg(pAdapter, 3764U, 4294967295U);
      (*(result + (unsigned long )t))[4] = (int )((tmp___6 & 67043328U) >> 16);
      tmp___7 = PHY_QueryBBReg(pAdapter, 3772U, 4294967295U);
      (*(result + (unsigned long )t))[5] = (int )((tmp___7 & 67043328U) >> 16);
      tmp___8 = PHY_QueryBBReg(pAdapter, 3780U, 4294967295U);
      (*(result + (unsigned long )t))[6] = (int )((tmp___8 & 67043328U) >> 16);
      tmp___9 = PHY_QueryBBReg(pAdapter, 3788U, 4294967295U);
      (*(result + (unsigned long )t))[7] = (int )((tmp___9 & 67043328U) >> 16);
      goto ldv_54480;
    } else
    if (retryCount - 1U == i && (unsigned int )PathBOK == 1U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Path B Only Tx IQK Success!!\n");
      } else {
      }
      tmp___10 = PHY_QueryBBReg(pAdapter, 3764U, 4294967295U);
      (*(result + (unsigned long )t))[4] = (int )((tmp___10 & 67043328U) >> 16);
      tmp___11 = PHY_QueryBBReg(pAdapter, 3772U, 4294967295U);
      (*(result + (unsigned long )t))[5] = (int )((tmp___11 & 67043328U) >> 16);
    } else {
    }
    i = i + 1U;
    ldv_54482: ;
    if (i < retryCount) {
      goto ldv_54481;
    } else {
    }
    ldv_54480: ;
    if ((unsigned int )PathBOK == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Path B IQK failed!!\n");
      } else {
      }
    } else {
    }
  } else {
  }
  PHY_SetBBReg(pAdapter, 3624U, 4294967295U, 0U);
  if ((unsigned int )t != 0U) {
    if ((unsigned int )pdmpriv->bRfPiEnable == 0U) {
      _PHY_PIModeSwitch(pAdapter, 0);
    } else {
    }
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& ADDA_REG), (u32 *)(& pdmpriv->ADDA_backup),
                             16U);
    _PHY_ReloadMACRegisters(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup),
                             9U);
    PHY_SetBBReg(pAdapter, 2112U, 4294967295U, 208595U);
    if ((int )is2T) {
      PHY_SetBBReg(pAdapter, 2116U, 4294967295U, 208595U);
    } else {
    }
    PHY_SetBBReg(pAdapter, 3632U, 4294967295U, 16813056U);
    PHY_SetBBReg(pAdapter, 3636U, 4294967295U, 16813056U);
  } else {
  }
  return;
}
}
static void _PHY_LCCalibrate(struct rtw_adapter *pAdapter , bool is2T )
{
  u8 tmpReg ;
  u32 RF_Amode ;
  u32 RF_Bmode ;
  u32 LC_Cal ;
  {
  RF_Amode = 0U;
  RF_Bmode = 0U;
  tmpReg = rtl8723au_read8(pAdapter, 3331U);
  if (((int )tmpReg & 112) != 0) {
    rtl8723au_write8(pAdapter, 3331U, (int )tmpReg & 143);
  } else {
    rtl8723au_write8(pAdapter, 1314U, 255);
  }
  if (((int )tmpReg & 112) != 0) {
    RF_Amode = PHY_QueryRFReg(pAdapter, 0, 0U, 4095U);
    if ((int )is2T) {
      RF_Bmode = PHY_QueryRFReg(pAdapter, 1, 0U, 4095U);
    } else {
    }
    PHY_SetRFReg(pAdapter, 0, 0U, 4095U, (RF_Amode & 589823U) | 65536U);
    if ((int )is2T) {
      PHY_SetRFReg(pAdapter, 1, 0U, 4095U, (RF_Bmode & 589823U) | 65536U);
    } else {
    }
  } else {
  }
  LC_Cal = PHY_QueryRFReg(pAdapter, 0, 24U, 4095U);
  PHY_SetRFReg(pAdapter, 0, 24U, 4095U, LC_Cal | 32768U);
  msleep(100U);
  if (((int )tmpReg & 112) != 0) {
    rtl8723au_write8(pAdapter, 3331U, (int )tmpReg);
    PHY_SetRFReg(pAdapter, 0, 0U, 4095U, RF_Amode);
    if ((int )is2T) {
      PHY_SetRFReg(pAdapter, 1, 0U, 4095U, RF_Bmode);
    } else {
    }
  } else {
    rtl8723au_write8(pAdapter, 1314U, 0);
  }
  return;
}
}
void rtl8723a_phy_iq_calibrate(struct rtw_adapter *pAdapter , bool bReCovery )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  s32 result[4U][8U] ;
  u8 i ;
  u8 final_candidate ;
  bool bPathAOK ;
  bool bPathBOK ;
  s32 RegE94 ;
  s32 RegE9C ;
  s32 RegEA4 ;
  s32 RegEAC ;
  s32 RegEB4 ;
  s32 RegEBC ;
  s32 RegEC4 ;
  s32 RegECC ;
  s32 RegTmp ;
  bool is12simular ;
  bool is13simular ;
  bool is23simular ;
  bool bStartContTx ;
  bool bSingleTone ;
  bool bCarrierSuppression ;
  u32 IQK_BB_REG_92C[9U] ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;
  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  RegTmp = 0;
  bStartContTx = 0;
  bSingleTone = 0;
  bCarrierSuppression = 0;
  IQK_BB_REG_92C[0] = 3092U;
  IQK_BB_REG_92C[1] = 3100U;
  IQK_BB_REG_92C[2] = 3148U;
  IQK_BB_REG_92C[3] = 3192U;
  IQK_BB_REG_92C[4] = 3200U;
  IQK_BB_REG_92C[5] = 3208U;
  IQK_BB_REG_92C[6] = 3220U;
  IQK_BB_REG_92C[7] = 3228U;
  IQK_BB_REG_92C[8] = 3232U;
  if (((int )bStartContTx || (int )bSingleTone) || (int )bCarrierSuppression) {
    return;
  } else {
  }
  if ((int )bReCovery) {
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup_recover),
                             9U);
    return;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: IQK:Start!!!\n");
  } else {
  }
  i = 0U;
  goto ldv_54519;
  ldv_54518:
  result[0][(int )i] = 0;
  result[1][(int )i] = 0;
  result[2][(int )i] = 0;
  result[3][(int )i] = 0;
  i = (u8 )((int )i + 1);
  ldv_54519: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_54518;
  } else {
  }
  final_candidate = 255U;
  bPathAOK = 0;
  bPathBOK = 0;
  is12simular = 0;
  is23simular = 0;
  is13simular = 0;
  i = 0U;
  goto ldv_54526;
  ldv_54525: ;
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U) {
    _PHY_IQCalibrate(pAdapter, (int (*)[8])(& result), (int )i, 1);
  } else {
    _PHY_IQCalibrate(pAdapter, (int (*)[8])(& result), (int )i, 0);
  }
  if ((unsigned int )i == 1U) {
    is12simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 0, 1);
    if ((int )is12simular) {
      final_candidate = 0U;
      goto ldv_54521;
    } else {
    }
  } else {
  }
  if ((unsigned int )i == 2U) {
    is13simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 0, 2);
    if ((int )is13simular) {
      final_candidate = 0U;
      goto ldv_54521;
    } else {
    }
    is23simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 1, 2);
    if ((int )is23simular) {
      final_candidate = 1U;
    } else {
      i = 0U;
      goto ldv_54523;
      ldv_54522:
      RegTmp = result[3][(int )i] + RegTmp;
      i = (u8 )((int )i + 1);
      ldv_54523: ;
      if ((unsigned int )i <= 7U) {
        goto ldv_54522;
      } else {
      }
      if (RegTmp != 0) {
        final_candidate = 3U;
      } else {
        final_candidate = 255U;
      }
    }
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54526: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_54525;
  } else {
  }
  ldv_54521:
  i = 0U;
  goto ldv_54528;
  ldv_54527:
  RegE94 = result[(int )i][0];
  RegE9C = result[(int )i][1];
  RegEA4 = result[(int )i][2];
  RegEAC = result[(int )i][3];
  RegEB4 = result[(int )i][4];
  RegEBC = result[(int )i][5];
  RegEC4 = result[(int )i][6];
  RegECC = result[(int )i][7];
  i = (u8 )((int )i + 1);
  ldv_54528: ;
  if ((unsigned int )i <= 3U) {
    goto ldv_54527;
  } else {
  }
  if ((unsigned int )final_candidate != 255U) {
    RegE94 = result[(int )final_candidate][0];
    pdmpriv->RegE94 = RegE94;
    RegE9C = result[(int )final_candidate][1];
    pdmpriv->RegE9C = RegE9C;
    RegEA4 = result[(int )final_candidate][2];
    RegEAC = result[(int )final_candidate][3];
    RegEB4 = result[(int )final_candidate][4];
    pdmpriv->RegEB4 = RegEB4;
    RegEBC = result[(int )final_candidate][5];
    pdmpriv->RegEBC = RegEBC;
    RegEC4 = result[(int )final_candidate][6];
    RegECC = result[(int )final_candidate][7];
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: IQK: final_candidate is %x\n", (int )final_candidate);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: IQK: RegE94 =%x RegE9C =%x RegEA4 =%x RegEAC =%x RegEB4 =%x RegEBC =%x RegEC4 =%x RegECC =%x\n ",
             RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC);
    } else {
    }
    bPathBOK = 1;
    bPathAOK = bPathBOK;
  } else {
    tmp___0 = 256;
    pdmpriv->RegEB4 = tmp___0;
    tmp = tmp___0;
    pdmpriv->RegE94 = tmp;
    RegEB4 = tmp;
    RegE94 = RegEB4;
    tmp___2 = 0;
    pdmpriv->RegEBC = tmp___2;
    tmp___1 = tmp___2;
    pdmpriv->RegE9C = tmp___1;
    RegEBC = tmp___1;
    RegE9C = RegEBC;
  }
  if (RegE94 != 0) {
    _PHY_PathAFillIQKMatrix(pAdapter, (int )bPathAOK, (int (*)[8])(& result), (int )final_candidate,
                            RegEA4 == 0);
  } else {
  }
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U) {
    if (RegEB4 != 0) {
      _PHY_PathBFillIQKMatrix(pAdapter, (int )bPathBOK, (int (*)[8])(& result), (int )final_candidate,
                              RegEC4 == 0);
    } else {
    }
  } else {
  }
  _PHY_SaveADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup_recover),
                         9U);
  return;
}
}
void rtl8723a_phy_lc_calibrate(struct rtw_adapter *pAdapter )
{
  struct hal_data_8723a *pHalData ;
  struct mlme_ext_priv *pmlmeext ;
  bool bStartContTx ;
  bool bSingleTone ;
  bool bCarrierSuppression ;
  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pmlmeext = & pAdapter->mlmeextpriv;
  bStartContTx = 0;
  bSingleTone = 0;
  bCarrierSuppression = 0;
  if (((int )bStartContTx || (int )bSingleTone) || (int )bCarrierSuppression) {
    return;
  } else {
  }
  if (pmlmeext->sitesurvey_res.state == 3) {
    return;
  } else {
  }
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U) {
    _PHY_LCCalibrate(pAdapter, 1);
  } else {
    _PHY_LCCalibrate(pAdapter, 0);
  }
  return;
}
}
void rtl8723a_phy_ap_calibrate(struct rtw_adapter *pAdapter , char delta )
{
  {
  return;
}
}
void *ldv_kmem_cache_alloc_1082(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1088(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1090(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1092(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1093(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1094(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1095(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1096(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1097(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1098(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1124(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1132(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1140(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1134(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1130(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1138(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1139(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1135(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1136(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1137(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void ODM_ReadAndConfig_AGC_TAB_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
void ODM_ReadAndConfig_PHY_REG_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
void ODM_ReadAndConfig_PHY_REG_MP_8723A(struct dm_odm_t *pDM_Odm ) ;
void ODM_ReadAndConfig_PHY_REG_PG_8723A(struct dm_odm_t *pDM_Odm ) ;
void odm_ConfigBB_AGC_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask , u32 Data ) ;
void odm_ConfigBB_PHY_REG_PG_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask ,
                                   u32 Data ) ;
void odm_ConfigBB_PHY_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask , u32 Data ) ;
static bool CheckCondition(u32 const Condition , u32 const Hex )
{
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;
  {
  _board = (unsigned int )Hex & 255U;
  _interface = ((unsigned int )Hex & 65280U) >> 8;
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
  cond = Condition;
  if ((unsigned int )Condition == 3452816845U) {
    return (1);
  } else {
  }
  cond = (unsigned int )Condition & 255U;
  if (_board == cond && cond != 0U) {
    return (0);
  } else {
  }
  cond = (unsigned int )Condition & 65280U;
  cond = cond >> 8;
  if ((_interface & cond) == 0U && cond != 7U) {
    return (0);
  } else {
  }
  cond = (unsigned int )Condition & 16711680U;
  cond = cond >> 16;
  if ((_platform & cond) == 0U && cond != 15U) {
    return (0);
  } else {
  }
  return (1);
}
}
static u32 Array_AGC_TAB_1T_8723A[320U] =
  { 3192U, 2063597569U, 3192U, 2063663105U,
        3192U, 2063728641U, 3192U, 2063794177U,
        3192U, 2063859713U, 3192U, 2063925249U,
        3192U, 2047213569U, 3192U, 2030501889U,
        3192U, 2013790209U, 3192U, 1997078529U,
        3192U, 1980366849U, 3192U, 1963655169U,
        3192U, 1946943489U, 3192U, 1930231809U,
        3192U, 1913520129U, 3192U, 1896808449U,
        3192U, 1880096769U, 3192U, 1863385089U,
        3192U, 1846673409U, 3192U, 1829961729U,
        3192U, 1813250049U, 3192U, 1796538369U,
        3192U, 1779826689U, 3192U, 1763115009U,
        3192U, 1746403329U, 3192U, 1729691649U,
        3192U, 1712979969U, 3192U, 1696268289U,
        3192U, 1679556609U, 3192U, 1662844929U,
        3192U, 1646133249U, 3192U, 1629421569U,
        3192U, 1612709889U, 3192U, 1226899457U,
        3192U, 1210187777U, 3192U, 1193476097U,
        3192U, 1176764417U, 3192U, 1160052737U,
        3192U, 1143341057U, 3192U, 1126629377U,
        3192U, 1109917697U, 3192U, 1093206017U,
        3192U, 1076494337U, 3192U, 640352257U,
        3192U, 623640577U, 3192U, 606928897U,
        3192U, 590217217U, 3192U, 573505537U,
        3192U, 556793857U, 3192U, 540082177U,
        3192U, 103940097U, 3192U, 87228417U,
        3192U, 70516737U, 3192U, 53805057U,
        3192U, 37093377U, 3192U, 20381697U,
        3192U, 3670017U, 3192U, 3735553U,
        3192U, 3801089U, 3192U, 3866625U,
        3192U, 3932161U, 3192U, 3997697U,
        3192U, 4063233U, 3192U, 4128769U,
        3192U, 2067791873U, 3192U, 2067857409U,
        3192U, 2067922945U, 3192U, 2067988481U,
        3192U, 2068054017U, 3192U, 2068119553U,
        3192U, 2051407873U, 3192U, 2034696193U,
        3192U, 2017984513U, 3192U, 2001272833U,
        3192U, 1984561153U, 3192U, 1967849473U,
        3192U, 1951137793U, 3192U, 1934426113U,
        3192U, 1917714433U, 3192U, 1901002753U,
        3192U, 1884291073U, 3192U, 1867579393U,
        3192U, 1850867713U, 3192U, 1834156033U,
        3192U, 1817444353U, 3192U, 1800732673U,
        3192U, 1784020993U, 3192U, 1767309313U,
        3192U, 1750597633U, 3192U, 1733885953U,
        3192U, 1717174273U, 3192U, 1700462593U,
        3192U, 1683750913U, 3192U, 1667039233U,
        3192U, 1650327553U, 3192U, 1633615873U,
        3192U, 1616904193U, 3192U, 1231093761U,
        3192U, 1214382081U, 3192U, 1197670401U,
        3192U, 1180958721U, 3192U, 1164247041U,
        3192U, 1147535361U, 3192U, 1130823681U,
        3192U, 1114112001U, 3192U, 1097400321U,
        3192U, 1080688641U, 3192U, 644546561U,
        3192U, 627834881U, 3192U, 611123201U,
        3192U, 594411521U, 3192U, 577699841U,
        3192U, 560988161U, 3192U, 544276481U,
        3192U, 108134401U, 3192U, 91422721U,
        3192U, 74711041U, 3192U, 57999361U,
        3192U, 41287681U, 3192U, 24576001U,
        3192U, 7864321U, 3192U, 7929857U,
        3192U, 7995393U, 3192U, 8060929U,
        3192U, 8126465U, 3192U, 8192001U,
        3192U, 8257537U, 3192U, 8323073U,
        3192U, 939524126U, 3192U, 939589662U,
        3192U, 939655198U, 3192U, 939720734U,
        3192U, 939786270U, 3192U, 939851806U,
        3192U, 939917342U, 3192U, 939982878U,
        3192U, 940048414U, 3192U, 1007222814U,
        3192U, 1040842782U, 3192U, 1074462750U,
        3192U, 1141637150U, 3192U, 1208811550U,
        3192U, 1275985950U, 3192U, 1343160350U,
        3192U, 1376780318U, 3192U, 1443954718U,
        3192U, 1511129118U, 3192U, 1578303518U,
        3192U, 1611923486U, 3192U, 1611989022U,
        3192U, 1612054558U, 3192U, 1645674526U,
        3192U, 1645740062U, 3192U, 1645805598U,
        3192U, 1645871134U, 3192U, 1645936670U,
        3192U, 1646002206U, 3192U, 1646067742U,
        3192U, 1646133278U, 3192U, 1646198814U};
void ODM_ReadAndConfig_AGC_TAB_1T_8723A(struct dm_odm_t *pDM_Odm )
{
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;
  {
  platform = 4U;
  interfaceValue = pDM_Odm->SupportInterface;
  board = pDM_Odm->BoardType;
  ArrayLen = 320U;
  Array = (u32 *)(& Array_AGC_TAB_1T_8723A);
  hex = (u32 )board;
  hex = (u32 )((int )interfaceValue << 8) + hex;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_54232;
  ldv_54231:
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigBB_AGC_8723A(pDM_Odm, v1, 4294967295U, v2);
    goto ldv_54221;
  } else {
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54223;
      ldv_54222:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54223: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54222;
      } else {
      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54226;
      ldv_54225:
      odm_ConfigBB_AGC_8723A(pDM_Odm, v1, 4294967295U, v2);
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54226: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54225;
      } else {
      }
      goto ldv_54229;
      ldv_54228:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54229: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_54228;
      } else {
      }
    }
  }
  ldv_54221:
  i = i + 2U;
  ldv_54232: ;
  if (i < ArrayLen) {
    goto ldv_54231;
  } else {
  }
  return;
}
}
static u32 Array_PHY_REG_1T_8723A[388U] =
  { 2048U, 2147745792U, 2052U, 3U,
        2056U, 64512U, 2060U, 10U,
        2064U, 268440369U, 2068U, 34356496U,
        2072U, 35652485U, 2076U, 0U,
        2080U, 16777472U, 2084U, 3735556U,
        2088U, 0U, 2092U, 0U,
        2096U, 0U, 2100U, 0U,
        2104U, 0U, 2108U, 0U,
        2112U, 65536U, 2116U, 0U,
        2120U, 0U, 2124U, 0U,
        2128U, 0U, 2132U, 0U,
        2136U, 1452955290U, 2140U, 1779108U,
        2144U, 1727398160U, 2148U, 102695216U,
        2152U, 0U, 2156U, 842150400U,
        2160U, 117442400U, 2164U, 570441728U,
        2168U, 2056U, 2172U, 0U,
        2176U, 3221762160U, 2180U, 1237U,
        2184U, 0U, 2188U, 3435135168U,
        2192U, 2048U, 2196U, 4294967294U,
        2200U, 1076895760U, 2204U, 7364688U,
        2304U, 0U, 2308U, 35U,
        2312U, 0U, 2316U, 2165444881U,
        2560U, 13649864U, 2564U, 2164195340U,
        2568U, 2357428992U, 2572U, 778572303U,
        2576U, 2499853176U, 2580U, 286539816U,
        2584U, 8917271U, 2588U, 2299793152U,
        2592U, 437977088U, 2596U, 151917335U,
        2600U, 516U, 2604U, 13828096U,
        2672U, 270515968U, 2676U, 7U,
        2680U, 2304U, 3072U, 1208425792U,
        3076U, 60839441U, 3080U, 228U,
        3084U, 1819044972U, 3088U, 142606336U,
        3092U, 1073742080U, 3096U, 142606336U,
        3100U, 1073742080U, 3104U, 0U,
        3108U, 0U, 3112U, 0U,
        3116U, 0U, 3120U, 1776921668U,
        4279173407U, 43981U, 3124U, 1184256719U,
        3452816845U, 52685U, 3124U, 1184256687U,
        4279173407U, 57005U, 3128U, 1232689556U,
        3132U, 177706780U, 3136U, 528236607U,
        3140U, 65719U, 3144U, 3959554311U,
        3148U, 8323967U, 3152U, 1767126048U,
        3156U, 1136394388U, 3160U, 1767126048U,
        3164U, 1128005780U, 3168U, 0U,
        4279173407U, 43981U, 3172U, 1897301131U,
        3452816845U, 52685U, 3172U, 1897038987U,
        4279173407U, 57005U, 3176U, 1203768319U,
        3180U, 54U, 3184U, 746520589U,
        3188U, 25563355U, 3192U, 31U,
        3196U, 12129810U, 3200U, 1073742080U,
        3204U, 552992768U, 3208U, 1073742080U,
        3212U, 538968064U, 3216U, 1185824U,
        3220U, 0U, 3224U, 1185824U,
        3228U, 32639U, 3232U, 0U,
        3236U, 128U, 3240U, 0U,
        3244U, 0U, 3248U, 0U,
        3252U, 0U, 3256U, 0U,
        3260U, 671088640U, 3264U, 0U,
        3268U, 0U, 3272U, 0U,
        3276U, 0U, 3280U, 0U,
        3284U, 0U, 3288U, 1689396263U,
        3292U, 7760178U, 3296U, 2236962U,
        3300U, 0U, 3304U, 929317634U,
        3308U, 798479372U, 3328U, 526144U,
        3332U, 132097U, 3336U, 36991U,
        3340U, 536936961U, 3344U, 2690855731U,
        3348U, 859028547U, 3352U, 2056215403U,
        3372U, 3432487285U, 3376U, 0U,
        3380U, 2153807872U, 3384U, 0U,
        3388U, 160403U, 3392U, 0U,
        3396U, 0U, 3400U, 0U,
        3404U, 0U, 3408U, 1681331210U,
        3412U, 0U, 3416U, 0U,
        3420U, 805511268U, 3424U, 1179901544U,
        3428U, 72452668U, 3432U, 8449U,
        3436U, 706747414U, 3440U, 403846702U,
        3444U, 841753120U, 3448U, 932900U,
        3584U, 707406378U, 3588U, 707406378U,
        3592U, 59779626U, 3600U, 707406378U,
        3604U, 707406378U, 3608U, 707406378U,
        3612U, 707406378U, 3624U, 0U,
        3632U, 268491807U, 3636U, 268471327U,
        3640U, 34865410U, 3644U, 1746273474U,
        3648U, 16808960U, 3652U, 16795648U,
        3656U, 4211081216U, 3660U, 10449U,
        3664U, 268491807U, 3668U, 268471327U,
        3672U, 34865410U, 3676U, 672533765U,
        3680U, 8U, 3688U, 1779108U,
        3692U, 1662723488U, 3696U, 1662723488U,
        3700U, 135996832U, 3704U, 135996832U,
        3708U, 135996832U, 3712U, 135996832U,
        3716U, 1662723488U, 3720U, 135996832U,
        3724U, 1662723488U, 3792U, 1662723488U,
        3796U, 1662723488U, 3800U, 1662723488U,
        3804U, 1779104U, 3808U, 1779104U,
        3820U, 1796941216U, 3860U, 3U,
        3916U, 0U, 3840U, 768U};
void ODM_ReadAndConfig_PHY_REG_1T_8723A(struct dm_odm_t *pDM_Odm )
{
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;
  {
  hex = 0U;
  i = 0U;
  platform = 4U;
  interfaceValue = pDM_Odm->SupportInterface;
  board = pDM_Odm->BoardType;
  ArrayLen = 388U;
  Array = (u32 *)(& Array_PHY_REG_1T_8723A);
  hex = (u32 )board + hex;
  hex = (u32 )((int )interfaceValue << 8) + hex;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_54258;
  ldv_54257:
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigBB_PHY_8723A(pDM_Odm, v1, 4294967295U, v2);
    goto ldv_54247;
  } else {
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54249;
      ldv_54248:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54249: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54248;
      } else {
      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54252;
      ldv_54251:
      odm_ConfigBB_PHY_8723A(pDM_Odm, v1, 4294967295U, v2);
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54252: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54251;
      } else {
      }
      goto ldv_54255;
      ldv_54254:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54255: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_54254;
      } else {
      }
    }
  }
  ldv_54247:
  i = i + 2U;
  ldv_54258: ;
  if (i < ArrayLen) {
    goto ldv_54257;
  } else {
  }
  return;
}
}
static u32 Array_PHY_REG_MP_8723A[4U] = { 3120U, 1776921674U, 3132U, 177706776U};
void ODM_ReadAndConfig_PHY_REG_MP_8723A(struct dm_odm_t *pDM_Odm )
{
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;
  {
  hex = 0U;
  i = 0U;
  platform = 4U;
  interfaceValue = pDM_Odm->SupportInterface;
  board = pDM_Odm->BoardType;
  ArrayLen = 4U;
  Array = (u32 *)(& Array_PHY_REG_MP_8723A);
  hex = (u32 )board + hex;
  hex = (u32 )((int )interfaceValue << 8) + hex;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_54284;
  ldv_54283:
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigBB_PHY_8723A(pDM_Odm, v1, 4294967295U, v2);
    goto ldv_54273;
  } else {
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54275;
      ldv_54274:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54275: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54274;
      } else {
      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54278;
      ldv_54277:
      odm_ConfigBB_PHY_8723A(pDM_Odm, v1, 4294967295U, v2);
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54278: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54277;
      } else {
      }
      goto ldv_54281;
      ldv_54280:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54281: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_54280;
      } else {
      }
    }
  }
  ldv_54273:
  i = i + 2U;
  ldv_54284: ;
  if (i < ArrayLen) {
    goto ldv_54283;
  } else {
  }
  return;
}
}
static u32 Array_PHY_REG_PG_8723A[336U] =
  { 3584U, 4294967295U, 168561676U, 3588U,
        4294967295U, 33818120U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 168561934U, 3604U,
        4294967295U, 33818120U, 3608U, 4294967295U,
        168561934U, 3612U, 4294967295U, 33818120U,
        2096U, 4294967295U, 168561676U, 2100U,
        4294967295U, 33818120U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 168561934U, 2120U,
        4294967295U, 33818120U, 2124U, 4294967295U,
        168561934U, 2152U, 4294967295U, 33818120U,
        3584U, 4294967295U, 0U, 3588U,
        4294967295U, 0U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 0U, 2100U,
        4294967295U, 0U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 67372036U, 3588U,
        4294967295U, 131588U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 101058054U, 3604U,
        4294967295U, 132102U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 67372036U, 2100U,
        4294967295U, 131588U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 101058054U, 2120U,
        4294967295U, 132102U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 0U, 3588U,
        4294967295U, 0U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 0U, 2100U,
        4294967295U, 0U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 0U, 3588U,
        4294967295U, 0U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 0U, 2100U,
        4294967295U, 0U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 67372036U, 3588U,
        4294967295U, 131588U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 67372036U, 2100U,
        4294967295U, 131588U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U,
        3584U, 4294967295U, 0U, 3588U,
        4294967295U, 0U, 3592U, 65280U,
        0U, 2156U, 4294967040U, 0U,
        3600U, 4294967295U, 0U, 3604U,
        4294967295U, 0U, 3608U, 4294967295U,
        0U, 3612U, 4294967295U, 0U,
        2096U, 4294967295U, 0U, 2100U,
        4294967295U, 0U, 2104U, 4294967040U,
        0U, 2156U, 255U, 0U,
        2108U, 4294967295U, 0U, 2120U,
        4294967295U, 0U, 2124U, 4294967295U,
        0U, 2152U, 4294967295U, 0U};
void ODM_ReadAndConfig_PHY_REG_PG_8723A(struct dm_odm_t *pDM_Odm )
{
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  u32 v3 ;
  bool tmp ;
  int tmp___0 ;
  {
  hex = 0U;
  i = 0U;
  platform = 4U;
  interfaceValue = pDM_Odm->SupportInterface;
  board = pDM_Odm->BoardType;
  ArrayLen = 336U;
  Array = (u32 *)(& Array_PHY_REG_PG_8723A);
  hex = (u32 )board + hex;
  hex = (u32 )((int )interfaceValue << 8) + hex;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_54305;
  ldv_54304:
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  v3 = *(Array + (unsigned long )(i + 2U));
  if (v1 <= 3452816844U) {
    odm_ConfigBB_PHY_REG_PG_8723A(pDM_Odm, v1, v2, v3);
    goto ldv_54300;
  } else {
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      v3 = *(Array + (unsigned long )(i + 2U));
      goto ldv_54302;
      ldv_54301:
      i = i + 3U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      v3 = *(Array + (unsigned long )(i + 1U));
      ldv_54302: ;
      if (v2 != 57005U) {
        goto ldv_54301;
      } else {
      }
    } else {
    }
  }
  ldv_54300:
  i = i + 3U;
  ldv_54305: ;
  if (i < ArrayLen) {
    goto ldv_54304;
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_1124(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1130(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1132(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1134(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1135(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1136(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1137(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1138(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1139(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1140(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1166(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1174(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1182(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1176(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1180(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1181(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1177(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1178(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1179(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void ODM_ReadAndConfig_MAC_REG_8723A(struct dm_odm_t *pDM_Odm ) ;
void odm_ConfigMAC_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u8 Data ) ;
static bool CheckCondition___0(u32 const Condition , u32 const Hex )
{
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;
  {
  _board = (unsigned int )Hex & 255U;
  _interface = ((unsigned int )Hex & 65280U) >> 8;
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
  cond = Condition;
  if ((unsigned int )Condition == 3452816845U) {
    return (1);
  } else {
  }
  cond = (unsigned int )Condition & 255U;
  if (_board == cond && cond != 0U) {
    return (0);
  } else {
  }
  cond = (unsigned int )Condition & 65280U;
  cond = cond >> 8;
  if ((_interface & cond) == 0U && cond != 7U) {
    return (0);
  } else {
  }
  cond = (unsigned int )Condition & 16711680U;
  cond = cond >> 16;
  if ((_platform & cond) == 0U && cond != 15U) {
    return (0);
  } else {
  }
  return (1);
}
}
static u32 Array_MAC_REG_8723A[172U] =
  { 1056U, 128U, 1059U, 0U,
        1072U, 0U, 1073U, 0U,
        1074U, 0U, 1075U, 1U,
        1076U, 4U, 1077U, 5U,
        1078U, 6U, 1079U, 7U,
        1080U, 0U, 1081U, 0U,
        1082U, 0U, 1083U, 1U,
        1084U, 4U, 1085U, 5U,
        1086U, 6U, 1087U, 7U,
        1088U, 93U, 1089U, 1U,
        1090U, 0U, 1092U, 21U,
        1093U, 240U, 1094U, 15U,
        1095U, 0U, 1112U, 65U,
        1113U, 168U, 1114U, 114U,
        1115U, 185U, 1120U, 102U,
        1121U, 102U, 1122U, 8U,
        1123U, 3U, 1224U, 255U,
        1225U, 8U, 1228U, 255U,
        1229U, 255U, 1230U, 1U,
        1280U, 38U, 1281U, 162U,
        1282U, 47U, 1283U, 0U,
        1284U, 40U, 1285U, 163U,
        1286U, 94U, 1287U, 0U,
        1288U, 43U, 1289U, 164U,
        1290U, 94U, 1291U, 0U,
        1292U, 79U, 1293U, 164U,
        1294U, 0U, 1295U, 0U,
        1298U, 28U, 1300U, 10U,
        1301U, 16U, 1302U, 10U,
        1303U, 16U, 1306U, 22U,
        1316U, 15U, 1317U, 79U,
        1350U, 64U, 1351U, 0U,
        1360U, 16U, 1361U, 16U,
        1369U, 2U, 1370U, 2U,
        1373U, 255U, 1541U, 48U,
        1544U, 14U, 1545U, 42U,
        1618U, 32U, 1596U, 10U,
        1597U, 10U, 1598U, 14U,
        1599U, 14U, 1646U, 5U,
        1792U, 33U, 1793U, 67U,
        1794U, 101U, 1795U, 135U,
        1800U, 33U, 1801U, 67U,
        1802U, 101U, 1803U, 135U};
void ODM_ReadAndConfig_MAC_REG_8723A(struct dm_odm_t *pDM_Odm )
{
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;
  {
  hex = 0U;
  i = 0U;
  platform = 4U;
  interfaceValue = pDM_Odm->SupportInterface;
  board = pDM_Odm->BoardType;
  ArrayLen = 172U;
  Array = (u32 *)(& Array_MAC_REG_8723A);
  hex = (u32 )board + hex;
  hex = (u32 )((int )interfaceValue << 8) + hex;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_54232;
  ldv_54231:
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigMAC_8723A(pDM_Odm, v1, (int )((unsigned char )v2));
    goto ldv_54221;
  } else {
    tmp = CheckCondition___0(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54223;
      ldv_54222:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54223: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54222;
      } else {
      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54226;
      ldv_54225:
      odm_ConfigMAC_8723A(pDM_Odm, v1, (int )((unsigned char )v2));
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54226: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54225;
      } else {
      }
      goto ldv_54229;
      ldv_54228:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54229: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_54228;
      } else {
      }
    }
  }
  ldv_54221:
  i = i + 2U;
  ldv_54232: ;
  if (i < ArrayLen) {
    goto ldv_54231;
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_1166(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1174(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1176(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1177(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1178(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1179(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1180(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1181(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1182(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1208(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1216(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1224(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1218(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1214(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1222(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1223(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1219(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1220(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1221(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void ODM_ReadAndConfig_RadioA_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
void odm_ConfigRF_RadioA_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data ) ;
static bool CheckCondition___1(u32 const Condition , u32 const Hex )
{
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;
  {
  _board = (unsigned int )Hex & 255U;
  _interface = ((unsigned int )Hex & 65280U) >> 8;
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
  cond = Condition;
  if ((unsigned int )Condition == 3452816845U) {
    return (1);
  } else {
  }
  cond = (unsigned int )Condition & 255U;
  if (_board == cond && cond != 0U) {
    return (0);
  } else {
  }
  cond = (unsigned int )Condition & 65280U;
  cond = cond >> 8;
  if ((_interface & cond) == 0U && cond != 7U) {
    return (0);
  } else {
  }
  cond = (unsigned int )Condition & 16711680U;
  cond = cond >> 16;
  if ((_platform & cond) == 0U && cond != 15U) {
    return (0);
  } else {
  }
  return (1);
}
}
static u32 Array_RadioA_1T_8723A[312U] =
  { 0U, 196953U, 1U, 201348U,
        2U, 622592U, 4279173407U, 43981U,
        3U, 101475U, 3452816845U, 52685U,
        3U, 236643U, 4279173407U, 57005U,
        4U, 135399U, 9U, 132175U,
        10U, 107505U, 11U, 83847U,
        12U, 562942U, 13U, 57388U,
        14U, 236775U, 15U, 1105U,
        25U, 0U, 26U, 197461U,
        27U, 395776U, 28U, 1033080U,
        29U, 660048U, 30U, 591U,
        31U, 0U, 32U, 46612U,
        33U, 442368U, 34U, 0U,
        35U, 5464U, 36U, 96U,
        37U, 1155U, 38U, 323584U,
        39U, 968665U, 40U, 358192U,
        41U, 18307U, 42U, 1U,
        43U, 135988U, 42U, 0U,
        43U, 84U, 42U, 1U,
        43U, 2056U, 43U, 340787U,
        44U, 12U, 42U, 2U,
        43U, 2056U, 43U, 373555U,
        44U, 13U, 42U, 3U,
        43U, 2056U, 43U, 406323U,
        44U, 13U, 42U, 4U,
        43U, 2056U, 43U, 439091U,
        44U, 13U, 42U, 5U,
        43U, 2056U, 43U, 471859U,
        44U, 13U, 42U, 6U,
        43U, 1801U, 43U, 373555U,
        44U, 13U, 42U, 7U,
        43U, 1801U, 43U, 406323U,
        44U, 13U, 42U, 8U,
        43U, 1546U, 43U, 308019U,
        44U, 13U, 42U, 9U,
        43U, 1546U, 43U, 340787U,
        44U, 13U, 42U, 10U,
        43U, 1546U, 43U, 373555U,
        44U, 13U, 42U, 11U,
        43U, 1546U, 43U, 406323U,
        44U, 13U, 42U, 12U,
        43U, 1546U, 43U, 439091U,
        44U, 13U, 42U, 13U,
        43U, 1546U, 43U, 471859U,
        44U, 13U, 42U, 14U,
        43U, 1291U, 43U, 419430U,
        44U, 26U, 42U, 917504U,
        16U, 262159U, 17U, 930300U,
        16U, 393231U, 17U, 1047032U,
        16U, 131087U, 17U, 132089U,
        16U, 196623U, 17U, 1045760U,
        16U, 0U, 17U, 0U,
        16U, 524303U, 17U, 258304U,
        16U, 589839U, 17U, 143616U,
        18U, 204800U, 18U, 462848U,
        18U, 720896U, 18U, 1032192U,
        19U, 165811U, 19U, 148663U,
        19U, 132267U, 19U, 115871U,
        19U, 99475U, 19U, 82587U,
        19U, 66201U, 19U, 49820U,
        19U, 33184U, 19U, 16556U,
        19U, 32U, 20U, 103500U,
        20U, 365636U, 20U, 627788U,
        20U, 889924U, 4279173407U, 43981U,
        21U, 62500U, 21U, 324644U,
        21U, 586788U, 21U, 848932U,
        3452816845U, 52685U, 21U, 62580U,
        21U, 324727U, 21U, 586837U,
        21U, 848981U, 4279173407U, 57005U,
        22U, 825U, 22U, 262969U,
        22U, 525113U, 4279173407U, 43981U,
        22U, 787286U, 3452816845U, 52685U,
        22U, 787302U, 4279173407U, 57005U,
        0U, 65881U, 24U, 62465U,
        254U, 0U, 254U, 0U,
        31U, 3U, 254U, 0U,
        254U, 0U, 30U, 583U,
        31U, 0U, 0U, 196953U};
void ODM_ReadAndConfig_RadioA_1T_8723A(struct dm_odm_t *pDM_Odm )
{
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;
  {
  hex = 0U;
  i = 0U;
  platform = 4U;
  interfaceValue = pDM_Odm->SupportInterface;
  board = pDM_Odm->BoardType;
  ArrayLen = 312U;
  Array = (u32 *)(& Array_RadioA_1T_8723A);
  hex = (u32 )board + hex;
  hex = (u32 )((int )interfaceValue << 8) + hex;
  hex = (u32 )((int )platform << 16) + hex;
  hex = hex + 4278190080U;
  i = 0U;
  goto ldv_54232;
  ldv_54231:
  v1 = *(Array + (unsigned long )i);
  v2 = *(Array + (unsigned long )(i + 1U));
  if (v1 <= 3452816844U) {
    odm_ConfigRF_RadioA_8723A(pDM_Odm, v1, v2);
    goto ldv_54221;
  } else {
    tmp = CheckCondition___1(*(Array + (unsigned long )i), hex);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54223;
      ldv_54222:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54223: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54222;
      } else {
      }
      i = i - 2U;
    } else {
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      goto ldv_54226;
      ldv_54225:
      odm_ConfigRF_RadioA_8723A(pDM_Odm, v1, v2);
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54226: ;
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
        goto ldv_54225;
      } else {
      }
      goto ldv_54229;
      ldv_54228:
      i = i + 2U;
      v1 = *(Array + (unsigned long )i);
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54229: ;
      if (v2 != 57005U && ArrayLen - 2U > i) {
        goto ldv_54228;
      } else {
      }
    }
  }
  ldv_54221:
  i = i + 2U;
  ldv_54232: ;
  if (i < ArrayLen) {
    goto ldv_54231;
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_1208(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1214(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1216(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1218(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1219(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1220(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1221(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1222(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1223(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1224(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1250(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
extern void __udelay(unsigned long ) ;
struct sk_buff *ldv_skb_clone_1258(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1266(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1260(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1256(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1264(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1265(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1261(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1262(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1263(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
u8 HalPwrSeqCmdParsing23a(struct rtw_adapter *padapter , u8 CutVersion , u8 FabVersion ,
                          u8 InterfaceType , struct wlan_pwr_cfg *PwrSeqCmd ) ;
u8 HalPwrSeqCmdParsing23a(struct rtw_adapter *padapter , u8 CutVersion , u8 FabVersion ,
                          u8 InterfaceType , struct wlan_pwr_cfg *PwrSeqCmd )
{
  struct wlan_pwr_cfg PwrCfgCmd ;
  u8 bPollingBit ;
  u32 AryIdx ;
  u8 value ;
  u32 offset ;
  u32 pollingCount ;
  u32 maxPollingCnt ;
  u32 tmp ;
  {
  PwrCfgCmd.offset = 0U;
  PwrCfgCmd.cut_msk = (unsigned char)0;
  PwrCfgCmd.fab_msk = (unsigned char)0;
  PwrCfgCmd.interface_msk = (unsigned char)0;
  PwrCfgCmd.base = (unsigned char)0;
  PwrCfgCmd.cmd = (unsigned char)0;
  PwrCfgCmd.msk = (unsigned char)0;
  PwrCfgCmd.value = (unsigned char)0;
  bPollingBit = 0U;
  AryIdx = 0U;
  value = 0U;
  offset = 0U;
  pollingCount = 0U;
  maxPollingCnt = 5000U;
  ldv_51491:
  PwrCfgCmd = *(PwrSeqCmd + (unsigned long )AryIdx);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016HalPwrSeqCmdParsing23a: offset(%#x) cut_msk(%#x) fab_msk(%#x) interface_msk(%#x) base(%#x) cmd(%#x) msk(%#x) value(%#x)\n",
           (int )PwrCfgCmd.offset, (int )PwrCfgCmd.cut_msk, (int )PwrCfgCmd.fab_msk,
           (int )PwrCfgCmd.interface_msk, (int )PwrCfgCmd.base, (int )PwrCfgCmd.cmd,
           (int )PwrCfgCmd.msk, (int )PwrCfgCmd.value);
  } else {
  }
  if ((((int )PwrCfgCmd.fab_msk & (int )FabVersion) != 0 && (unsigned int )((int )PwrCfgCmd.cut_msk & (int )CutVersion) != 0U) && ((int )PwrCfgCmd.interface_msk & (int )InterfaceType) != 0) {
    switch ((int )PwrCfgCmd.cmd) {
    case 0: ;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_READ\n");
    } else {
    }
    goto ldv_51483;
    case 1: ;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_WRITE\n");
    } else {
    }
    offset = (u32 )PwrCfgCmd.offset;
    value = rtl8723au_read8(padapter, offset);
    value = (u8 )(~ ((int )((signed char )PwrCfgCmd.msk)) & (int )((signed char )value));
    value = (u8 )(((int )PwrCfgCmd.value & (int )PwrCfgCmd.msk) | (int )value);
    rtl8723au_write8(padapter, offset, (int )value);
    goto ldv_51483;
    case 2: ;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_POLLING\n");
    } else {
    }
    bPollingBit = 0U;
    offset = (u32 )PwrCfgCmd.offset;
    ldv_51486:
    value = rtl8723au_read8(padapter, offset);
    value = (u8 )((int )PwrCfgCmd.msk & (int )value);
    if (((int )PwrCfgCmd.value & (int )PwrCfgCmd.msk) == (int )value) {
      bPollingBit = 1U;
    } else {
      __const_udelay(42950UL);
    }
    tmp = pollingCount;
    pollingCount = pollingCount + 1U;
    if (tmp > maxPollingCnt) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: Fail to polling Offset[%#x]\n", offset);
      } else {
      }
      return (0U);
    } else {
    }
    if ((unsigned int )bPollingBit == 0U) {
      goto ldv_51486;
    } else {
    }
    goto ldv_51483;
    case 3: ;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_DELAY\n");
    } else {
    }
    if ((unsigned int )PwrCfgCmd.value == 0U) {
      __udelay((unsigned long )PwrCfgCmd.offset);
    } else {
      __udelay((unsigned long )((int )PwrCfgCmd.offset * 1000));
    }
    goto ldv_51483;
    case 4: ;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_END\n");
    } else {
    }
    return (1U);
    default: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
      printk("\016HalPwrSeqCmdParsing23a: Unknown CMD!!\n");
    } else {
    }
    goto ldv_51483;
    }
    ldv_51483: ;
  } else {
  }
  AryIdx = AryIdx + 1U;
  goto ldv_51491;
  return (1U);
}
}
void *ldv_kmem_cache_alloc_1250(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1256(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1258(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1260(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1261(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1262(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1263(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1264(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1265(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1266(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1292(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1300(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1308(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1302(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1298(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1306(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1307(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1303(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1304(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1305(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void ODM_Write1Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u8 Data ) ;
void ODM_SetBBReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask , u32 Data ) ;
void ODM_SetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) ;
void odm_ConfigRFReg_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data , enum RF_RADIO_PATH RF_PATH ,
                           u32 RegAddr ) ;
void odm_ConfigRF_RadioB_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data ) ;
void odm_ConfigRFReg_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data , enum RF_RADIO_PATH RF_PATH ,
                           u32 RegAddr )
{
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;
  {
  if (Addr == 254U) {
    msleep(50U);
  } else
  if (Addr == 253U) {
    if (1) {
      __const_udelay(21475000UL);
    } else {
      __ms = 5UL;
      goto ldv_54209;
      ldv_54208:
      __const_udelay(4295000UL);
      ldv_54209:
      tmp = __ms;
      __ms = __ms - 1UL;
      if (tmp != 0UL) {
        goto ldv_54208;
      } else {
      }
    }
  } else
  if (Addr == 252U) {
    if (1) {
      __const_udelay(4295000UL);
    } else {
      __ms___0 = 1UL;
      goto ldv_54213;
      ldv_54212:
      __const_udelay(4295000UL);
      ldv_54213:
      tmp___0 = __ms___0;
      __ms___0 = __ms___0 - 1UL;
      if (tmp___0 != 0UL) {
        goto ldv_54212;
      } else {
      }
    }
  } else
  if (Addr == 251U) {
    __const_udelay(214750UL);
  } else
  if (Addr == 250U) {
    __const_udelay(21475UL);
  } else
  if (Addr == 249U) {
    __const_udelay(4295UL);
  } else {
    ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, 1048575U, Data);
    __const_udelay(4295UL);
  }
  return;
}
}
void odm_ConfigRF_RadioA_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data )
{
  u32 content ;
  u32 maskforPhySet ;
  {
  content = 4096U;
  maskforPhySet = content & 57344U;
  odm_ConfigRFReg_8723A(pDM_Odm, Addr, Data, 0, Addr | maskforPhySet);
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===> ODM_ConfigRFWithHeaderFile23a: [RadioA] %08X %08X\n", "odm_ConfigRF_RadioA_8723A",
           Addr, Data);
  } else {
  }
  return;
}
}
void odm_ConfigRF_RadioB_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data )
{
  u32 content ;
  u32 maskforPhySet ;
  {
  content = 4097U;
  maskforPhySet = content & 57344U;
  odm_ConfigRFReg_8723A(pDM_Odm, Addr, Data, 1, Addr | maskforPhySet);
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===> ODM_ConfigRFWithHeaderFile23a: [RadioB] %08X %08X\n", "odm_ConfigRF_RadioB_8723A",
           Addr, Data);
  } else {
  }
  return;
}
}
void odm_ConfigMAC_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u8 Data )
{
  {
  ODM_Write1Byte(pDM_Odm, Addr, (int )Data);
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===> ODM_ConfigMACWithHeaderFile23a: [MAC_REG] %08X %08X\n", "odm_ConfigMAC_8723A",
           Addr, (int )Data);
  } else {
  }
  return;
}
}
void odm_ConfigBB_AGC_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask , u32 Data )
{
  {
  ODM_SetBBReg(pDM_Odm, Addr, Bitmask, Data);
  __const_udelay(4295UL);
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===> ODM_ConfigBBWithHeaderFile23a: [AGC_TAB] %08X %08X\n", "odm_ConfigBB_AGC_8723A",
           Addr, Data);
  } else {
  }
  return;
}
}
void odm_ConfigBB_PHY_REG_PG_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask ,
                                   u32 Data )
{
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;
  {
  if (Addr == 254U) {
    msleep(50U);
  } else
  if (Addr == 253U) {
    if (1) {
      __const_udelay(21475000UL);
    } else {
      __ms = 5UL;
      goto ldv_54252;
      ldv_54251:
      __const_udelay(4295000UL);
      ldv_54252:
      tmp = __ms;
      __ms = __ms - 1UL;
      if (tmp != 0UL) {
        goto ldv_54251;
      } else {
      }
    }
  } else
  if (Addr == 252U) {
    if (1) {
      __const_udelay(4295000UL);
    } else {
      __ms___0 = 1UL;
      goto ldv_54256;
      ldv_54255:
      __const_udelay(4295000UL);
      ldv_54256:
      tmp___0 = __ms___0;
      __ms___0 = __ms___0 - 1UL;
      if (tmp___0 != 0UL) {
        goto ldv_54255;
      } else {
      }
    }
  } else
  if (Addr == 251U) {
    __const_udelay(214750UL);
  } else
  if (Addr == 250U) {
    __const_udelay(21475UL);
  } else
  if (Addr == 249U) {
    __const_udelay(4295UL);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===> ODM_ConfigBBWithHeaderFile23a: [PHY_REG] %08X %08X %08X\n",
           "odm_ConfigBB_PHY_REG_PG_8723A", Addr, Bitmask, Data);
  } else {
  }
  return;
}
}
void odm_ConfigBB_PHY_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask , u32 Data )
{
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;
  {
  if (Addr == 254U) {
    msleep(50U);
  } else
  if (Addr == 253U) {
    if (1) {
      __const_udelay(21475000UL);
    } else {
      __ms = 5UL;
      goto ldv_54267;
      ldv_54266:
      __const_udelay(4295000UL);
      ldv_54267:
      tmp = __ms;
      __ms = __ms - 1UL;
      if (tmp != 0UL) {
        goto ldv_54266;
      } else {
      }
    }
  } else
  if (Addr == 252U) {
    if (1) {
      __const_udelay(4295000UL);
    } else {
      __ms___0 = 1UL;
      goto ldv_54271;
      ldv_54270:
      __const_udelay(4295000UL);
      ldv_54271:
      tmp___0 = __ms___0;
      __ms___0 = __ms___0 - 1UL;
      if (tmp___0 != 0UL) {
        goto ldv_54270;
      } else {
      }
    }
  } else
  if (Addr == 251U) {
    __const_udelay(214750UL);
  } else
  if (Addr == 250U) {
    __const_udelay(21475UL);
  } else
  if (Addr == 249U) {
    __const_udelay(4295UL);
  } else
  if (Addr == 2596U) {
    pDM_Odm->RFCalibrateInfo.RegA24 = Data;
  } else {
  }
  ODM_SetBBReg(pDM_Odm, Addr, Bitmask, Data);
  __const_udelay(4295UL);
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===> ODM_ConfigBBWithHeaderFile23a: [PHY_REG] %08X %08X\n", "odm_ConfigBB_PHY_8723A",
           Addr, Data);
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_1292(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1298(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1300(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1302(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1303(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1304(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1305(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1306(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1307(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1308(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1334(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1342(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1350(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1344(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1340(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1348(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1349(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1345(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1346(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1347(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
u32 GlobalDebugLevel23A ;
void ODM_InitDebugSetting23a(struct dm_odm_t *pDM_Odm ) ;
void ODM_InitDebugSetting23a(struct dm_odm_t *pDM_Odm )
{
  {
  pDM_Odm->DebugLevel = 5U;
  pDM_Odm->DebugComponents = 0ULL;
  return;
}
}
void *ldv_kmem_cache_alloc_1334(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1340(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1342(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1344(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1345(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1346(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1347(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1348(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1349(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1350(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1376(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1384(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1392(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1386(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1382(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1390(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1391(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1387(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1388(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1389(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
u8 ODM_Read1Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr ) ;
u16 ODM_Read2Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr ) ;
u32 ODM_Read4Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr ) ;
void ODM_Write2Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u16 Data ) ;
void ODM_Write4Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 Data ) ;
void ODM_SetMACReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask , u32 Data ) ;
u32 ODM_GetMACReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask ) ;
u32 ODM_GetBBReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask ) ;
u32 ODM_GetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                 u32 BitMask ) ;
u8 ODM_Read1Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr )
{
  struct rtw_adapter *Adapter ;
  u8 tmp ;
  {
  Adapter = pDM_Odm->Adapter;
  tmp = rtl8723au_read8(Adapter, RegAddr);
  return (tmp);
}
}
u16 ODM_Read2Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr )
{
  struct rtw_adapter *Adapter ;
  u16 tmp ;
  {
  Adapter = pDM_Odm->Adapter;
  tmp = rtl8723au_read16(Adapter, RegAddr);
  return (tmp);
}
}
u32 ODM_Read4Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr )
{
  struct rtw_adapter *Adapter ;
  u32 tmp ;
  {
  Adapter = pDM_Odm->Adapter;
  tmp = rtl8723au_read32(Adapter, RegAddr);
  return (tmp);
}
}
void ODM_Write1Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u8 Data )
{
  struct rtw_adapter *Adapter ;
  {
  Adapter = pDM_Odm->Adapter;
  rtl8723au_write8(Adapter, RegAddr, (int )Data);
  return;
}
}
void ODM_Write2Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u16 Data )
{
  struct rtw_adapter *Adapter ;
  {
  Adapter = pDM_Odm->Adapter;
  rtl8723au_write16(Adapter, RegAddr, (int )Data);
  return;
}
}
void ODM_Write4Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 Data )
{
  struct rtw_adapter *Adapter ;
  {
  Adapter = pDM_Odm->Adapter;
  rtl8723au_write32(Adapter, RegAddr, Data);
  return;
}
}
void ODM_SetMACReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask , u32 Data )
{
  struct rtw_adapter *Adapter ;
  {
  Adapter = pDM_Odm->Adapter;
  PHY_SetBBReg(Adapter, RegAddr, BitMask, Data);
  return;
}
}
u32 ODM_GetMACReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask )
{
  struct rtw_adapter *Adapter ;
  u32 tmp ;
  {
  Adapter = pDM_Odm->Adapter;
  tmp = PHY_QueryBBReg(Adapter, RegAddr, BitMask);
  return (tmp);
}
}
void ODM_SetBBReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask , u32 Data )
{
  struct rtw_adapter *Adapter ;
  {
  Adapter = pDM_Odm->Adapter;
  PHY_SetBBReg(Adapter, RegAddr, BitMask, Data);
  return;
}
}
u32 ODM_GetBBReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask )
{
  struct rtw_adapter *Adapter ;
  u32 tmp ;
  {
  Adapter = pDM_Odm->Adapter;
  tmp = PHY_QueryBBReg(Adapter, RegAddr, BitMask);
  return (tmp);
}
}
void ODM_SetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data )
{
  struct rtw_adapter *Adapter ;
  {
  Adapter = pDM_Odm->Adapter;
  PHY_SetRFReg(Adapter, eRFPath, RegAddr, BitMask, Data);
  return;
}
}
u32 ODM_GetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                 u32 BitMask )
{
  struct rtw_adapter *Adapter ;
  u32 tmp ;
  {
  Adapter = pDM_Odm->Adapter;
  tmp = PHY_QueryRFReg(Adapter, eRFPath, RegAddr, BitMask);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1376(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1382(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1384(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1386(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1387(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1388(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1389(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1390(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1391(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1392(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1418(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1426(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1434(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1428(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1424(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1432(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1433(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1429(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1430(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1431(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void ODM_SwAntDivChkPerPktRssi(struct dm_odm_t *pDM_Odm , u8 StationID , struct phy_info *pPhyInfo ) ;
void odm_Init_RSSIForDM23a(struct dm_odm_t *pDM_Odm ) ;
void ODM_PhyStatusQuery23a(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                           u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) ;
void ODM_MacStatusQuery23a(struct dm_odm_t *pDM_Odm , u8 *pMacStatus , u8 MacID ,
                           bool bPacketMatchBSSID , bool bPacketToSelf , bool bPacketBeacon ) ;
int ODM_ConfigRFWithHeaderFile23a(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH Content ,
                                  enum RF_RADIO_PATH eRFPath ) ;
int ODM_ConfigBBWithHeaderFile23a(struct dm_odm_t *pDM_Odm , enum odm_bb_config_type ConfigType ) ;
int ODM_ConfigMACWithHeaderFile23a(struct dm_odm_t *pDM_Odm ) ;
static u8 odm_QueryRxPwrPercentage(s8 AntPower )
{
  {
  if ((int )AntPower < -99 || (int )AntPower > 19) {
    return (0U);
  } else
  if ((int )AntPower >= 0) {
    return (100U);
  } else {
    return ((unsigned int )((u8 )AntPower) + 100U);
  }
}
}
static s32 odm_SignalScaleMapping_92CSeries(struct dm_odm_t *pDM_Odm , s32 CurrSig )
{
  s32 RetSig ;
  {
  RetSig = 0;
  if ((unsigned int )pDM_Odm->SupportInterface == 2U || (unsigned int )pDM_Odm->SupportInterface == 4U) {
    if (CurrSig > 50 && CurrSig <= 100) {
      RetSig = 100;
    } else
    if (CurrSig > 40 && CurrSig <= 50) {
      RetSig = CurrSig * 2;
    } else
    if (CurrSig > 30 && CurrSig <= 40) {
      RetSig = CurrSig + 36;
    } else
    if (CurrSig > 20 && CurrSig <= 30) {
      RetSig = CurrSig + 34;
    } else
    if (CurrSig > 9 && CurrSig <= 20) {
      RetSig = ((CurrSig + -10) * 2) / 3 + 42;
    } else
    if (CurrSig > 4 && CurrSig <= 9) {
      RetSig = (CurrSig * 3 + -15) / 2 + 22;
    } else
    if (CurrSig > 0 && CurrSig <= 4) {
      RetSig = ((CurrSig + -1) * 3) / 2 + 6;
    } else {
      RetSig = CurrSig;
    }
  } else {
  }
  return (RetSig);
}
}
static s32 odm_SignalScaleMapping(struct dm_odm_t *pDM_Odm , s32 CurrSig )
{
  s32 tmp ;
  {
  tmp = odm_SignalScaleMapping_92CSeries(pDM_Odm, CurrSig);
  return (tmp);
}
}
static u8 odm_EVMdbToPercentage(s8 Value )
{
  s8 ret_val ;
  {
  ret_val = Value;
  if ((int )ret_val >= 0) {
    ret_val = 0;
  } else {
  }
  if ((int )ret_val < -32) {
    ret_val = -33;
  } else {
  }
  ret_val = (s8 )(- ((int )((unsigned char )ret_val)));
  ret_val = (s8 )((unsigned int )((unsigned char )ret_val) * 3U);
  if ((int )ret_val == 99) {
    ret_val = 100;
  } else {
  }
  return ((u8 )ret_val);
}
}
static void odm_RxPhyStatus92CSeries_Parsing(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                             u8 *pPhyStatus , struct odm_packet_info *pPktinfo )
{
  struct phy_status_rpt *pPhyStaRpt ;
  u8 i ;
  u8 Max_spatial_stream ;
  s8 rx_pwr[4U] ;
  s8 rx_pwr_all ;
  u8 EVM ;
  u8 PWDB_ALL ;
  u8 PWDB_ALL_BT ;
  u8 RSSI ;
  u8 total_rssi ;
  u8 isCCKrate ;
  u8 rf_rx_num ;
  u8 cck_highpwr ;
  u8 report ;
  u8 cck_agc_rpt ;
  u8 SQ ;
  u8 SQ_rpt ;
  s8 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  {
  pPhyStaRpt = (struct phy_status_rpt *)pPhyStatus;
  rx_pwr_all = 0;
  PWDB_ALL = 0U;
  total_rssi = 0U;
  isCCKrate = 0U;
  rf_rx_num = 0U;
  cck_highpwr = 0U;
  isCCKrate = (unsigned int )pPktinfo->Rate <= 3U;
  pPhyInfo->RxMIMOSignalQuality[0] = 255U;
  pPhyInfo->RxMIMOSignalQuality[1] = 255U;
  if ((unsigned int )isCCKrate != 0U) {
    pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK + 1ULL;
    cck_highpwr = (u8 )pDM_Odm->bCckHighPower;
    cck_agc_rpt = pPhyStaRpt->cck_agc_rpt_ofdm_cfosho_a;
    if ((unsigned int )cck_highpwr == 0U) {
      report = (int )cck_agc_rpt >> 6;
      switch ((int )report) {
      case 3:
      rx_pwr_all = (s8 )(210U - ((unsigned int )cck_agc_rpt & 62U));
      goto ldv_54238;
      case 2:
      rx_pwr_all = (s8 )(230U - ((unsigned int )cck_agc_rpt & 62U));
      goto ldv_54238;
      case 1:
      rx_pwr_all = (s8 )(244U - ((unsigned int )cck_agc_rpt & 62U));
      goto ldv_54238;
      case 0:
      rx_pwr_all = (s8 )(16U - ((unsigned int )cck_agc_rpt & 62U));
      goto ldv_54238;
      }
      ldv_54238: ;
    } else {
      report = (u8 )(((int )cck_agc_rpt & 96) >> 5);
      switch ((int )report) {
      case 3:
      rx_pwr_all = (s8 )(210U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
      goto ldv_54243;
      case 2:
      rx_pwr_all = (s8 )(230U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
      goto ldv_54243;
      case 1:
      rx_pwr_all = (s8 )(244U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
      goto ldv_54243;
      case 0:
      rx_pwr_all = (s8 )(16U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
      goto ldv_54243;
      }
      ldv_54243: ;
    }
    PWDB_ALL = odm_QueryRxPwrPercentage((int )rx_pwr_all);
    if ((unsigned int )pDM_Odm->BoardType == 1U) {
      if ((int )((signed char )cck_agc_rpt) >= 0) {
        PWDB_ALL = (unsigned int )PWDB_ALL <= 94U ? (unsigned int )PWDB_ALL + 6U : 100U;
      } else
      if ((unsigned int )PWDB_ALL > 38U) {
        PWDB_ALL = (unsigned int )PWDB_ALL + 240U;
      } else {
        PWDB_ALL = (unsigned int )PWDB_ALL <= 16U ? (u8 )((int )PWDB_ALL >> 2) : (unsigned int )PWDB_ALL + 244U;
      }
      if ((unsigned int )PWDB_ALL > 25U && (unsigned int )PWDB_ALL <= 60U) {
        PWDB_ALL = (unsigned int )PWDB_ALL + 6U;
      } else {
      }
    } else
    if ((unsigned int )PWDB_ALL > 99U) {
      PWDB_ALL = (unsigned int )PWDB_ALL + 248U;
    } else
    if ((unsigned int )PWDB_ALL > 50U && (unsigned int )PWDB_ALL <= 68U) {
      PWDB_ALL = (unsigned int )PWDB_ALL + 4U;
    } else {
    }
    pPhyInfo->RxPWDBAll = PWDB_ALL;
    pPhyInfo->BTRxRSSIPercentage = PWDB_ALL;
    pPhyInfo->RecvSignalPower = rx_pwr_all;
    if ((int )pPktinfo->bPacketMatchBSSID) {
      SQ_rpt = pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all;
      if ((unsigned int )SQ_rpt > 64U) {
        SQ = 0U;
      } else
      if ((unsigned int )SQ_rpt <= 19U) {
        SQ = 100U;
      } else {
        SQ = (u8 )(((int )SQ_rpt * -100 + 6400) / 44);
      }
      pPhyInfo->SignalQuality = SQ;
      pPhyInfo->RxMIMOSignalQuality[0] = SQ;
      pPhyInfo->RxMIMOSignalQuality[1] = 255U;
    } else {
    }
  } else {
    pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM + 1ULL;
    i = 0U;
    goto ldv_54250;
    ldv_54249: ;
    if ((int )((unsigned long )pDM_Odm->RFPathRxEnable >> (int )i) & 1) {
      rf_rx_num = (u8 )((int )rf_rx_num + 1);
    } else {
    }
    rx_pwr[(int )i] = (s8 )((unsigned int )((unsigned char )(((int )pPhyStaRpt->path_agc[(int )i].gain & 63) + -55)) * 2U);
    pPhyInfo->RxPwr[(int )i] = (u8 )rx_pwr[(int )i];
    RSSI = odm_QueryRxPwrPercentage((int )rx_pwr[(int )i]);
    total_rssi = (int )total_rssi + (int )RSSI;
    if ((unsigned int )pDM_Odm->BoardType == 1U) {
      if ((unsigned int )pPhyStaRpt->path_agc[(int )i].trsw == 1U) {
        RSSI = (unsigned int )RSSI <= 94U ? (unsigned int )RSSI + 6U : 100U;
      } else {
        RSSI = (unsigned int )RSSI <= 16U ? (u8 )((int )RSSI >> 3) : (unsigned int )RSSI + 240U;
      }
      if ((unsigned int )RSSI <= 34U && (unsigned int )RSSI > 3U) {
        RSSI = (unsigned int )RSSI + 252U;
      } else {
      }
    } else {
    }
    pPhyInfo->RxMIMOSignalStrength[(int )i] = RSSI;
    tmp = (s8 )((unsigned int )pPhyStaRpt->path_rxsnr[(int )i] / 2U);
    pDM_Odm->PhyDbgInfo.RxSNRdB[(int )i] = tmp;
    pPhyInfo->RxSNR[(int )i] = (u8 )tmp;
    i = (u8 )((int )i + 1);
    ldv_54250: ;
    if ((unsigned int )i <= 1U) {
      goto ldv_54249;
    } else {
    }
    rx_pwr_all = (s8 )((unsigned int )((int )pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all >> 1) + 146U);
    PWDB_ALL = odm_QueryRxPwrPercentage((int )rx_pwr_all);
    PWDB_ALL_BT = PWDB_ALL;
    pPhyInfo->RxPWDBAll = PWDB_ALL;
    pPhyInfo->BTRxRSSIPercentage = PWDB_ALL_BT;
    pPhyInfo->RxPower = rx_pwr_all;
    pPhyInfo->RecvSignalPower = rx_pwr_all;
    if ((unsigned int )pPktinfo->Rate > 19U && (unsigned int )pPktinfo->Rate <= 27U) {
      Max_spatial_stream = 2U;
    } else {
      Max_spatial_stream = 1U;
    }
    i = 0U;
    goto ldv_54253;
    ldv_54252:
    EVM = odm_EVMdbToPercentage((int )pPhyStaRpt->stream_rxevm[(int )i]);
    if ((int )pPktinfo->bPacketMatchBSSID) {
      if ((unsigned int )i == 0U) {
        pPhyInfo->SignalQuality = EVM;
      } else {
      }
      pPhyInfo->RxMIMOSignalQuality[(int )i] = EVM;
    } else {
    }
    i = (u8 )((int )i + 1);
    ldv_54253: ;
    if ((int )i < (int )Max_spatial_stream) {
      goto ldv_54252;
    } else {
    }
  }
  if ((unsigned int )isCCKrate != 0U) {
    tmp___0 = odm_SignalScaleMapping(pDM_Odm, (s32 )PWDB_ALL);
    pPhyInfo->SignalStrength = (unsigned char )tmp___0;
  } else
  if ((unsigned int )rf_rx_num != 0U) {
    total_rssi = (u8 )((int )total_rssi / (int )rf_rx_num);
    tmp___1 = odm_SignalScaleMapping(pDM_Odm, (s32 )total_rssi);
    pPhyInfo->SignalStrength = (unsigned char )tmp___1;
  } else {
  }
  return;
}
}
void odm_Init_RSSIForDM23a(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
static void odm_Process_RSSIForDM(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                  struct odm_packet_info *pPktinfo )
{
  s32 UndecoratedSmoothedPWDB ;
  s32 UndecoratedSmoothedCCK ;
  s32 UndecoratedSmoothedOFDM ;
  s32 RSSI_Ave ;
  u8 isCCKrate ;
  u8 RSSI_max ;
  u8 RSSI_min ;
  u8 i ;
  u32 OFDM_pkt ;
  u32 Weighting ;
  struct sta_info *pEntry ;
  {
  isCCKrate = 0U;
  OFDM_pkt = 0U;
  Weighting = 0U;
  if ((unsigned int )pPktinfo->StationID == 255U) {
    return;
  } else {
  }
  pEntry = pDM_Odm->pODM_StaInfo[(int )pPktinfo->StationID];
  if ((unsigned long )pEntry == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {
  }
  if (! pPktinfo->bPacketMatchBSSID) {
    return;
  } else {
  }
  isCCKrate = (unsigned int )pPktinfo->Rate <= 3U;
  UndecoratedSmoothedCCK = pEntry->rssi_stat.UndecoratedSmoothedCCK;
  UndecoratedSmoothedOFDM = pEntry->rssi_stat.UndecoratedSmoothedOFDM;
  UndecoratedSmoothedPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
  if ((int )pPktinfo->bPacketToSelf || (int )pPktinfo->bPacketBeacon) {
    if ((unsigned int )isCCKrate == 0U) {
      if ((unsigned int )pPhyInfo->RxMIMOSignalStrength[1] == 0U) {
        RSSI_Ave = (s32 )pPhyInfo->RxMIMOSignalStrength[0];
      } else {
        if ((int )pPhyInfo->RxMIMOSignalStrength[0] > (int )pPhyInfo->RxMIMOSignalStrength[1]) {
          RSSI_max = pPhyInfo->RxMIMOSignalStrength[0];
          RSSI_min = pPhyInfo->RxMIMOSignalStrength[1];
        } else {
          RSSI_max = pPhyInfo->RxMIMOSignalStrength[1];
          RSSI_min = pPhyInfo->RxMIMOSignalStrength[0];
        }
        if ((int )RSSI_max - (int )RSSI_min <= 2) {
          RSSI_Ave = (s32 )RSSI_max;
        } else
        if ((int )RSSI_max - (int )RSSI_min <= 5) {
          RSSI_Ave = (int )RSSI_max + -1;
        } else
        if ((int )RSSI_max - (int )RSSI_min <= 9) {
          RSSI_Ave = (int )RSSI_max + -2;
        } else {
          RSSI_Ave = (int )RSSI_max + -3;
        }
      }
      if (UndecoratedSmoothedOFDM <= 0) {
        UndecoratedSmoothedOFDM = (s32 )pPhyInfo->RxPWDBAll;
      } else
      if ((unsigned int )pPhyInfo->RxPWDBAll > (unsigned int )UndecoratedSmoothedOFDM) {
        UndecoratedSmoothedOFDM = (UndecoratedSmoothedOFDM * 19 + RSSI_Ave) / 20;
        UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM + 1;
      } else {
        UndecoratedSmoothedOFDM = (UndecoratedSmoothedOFDM * 19 + RSSI_Ave) / 20;
      }
      pEntry->rssi_stat.PacketMap = (pEntry->rssi_stat.PacketMap << 1) | 1ULL;
    } else {
      RSSI_Ave = (s32 )pPhyInfo->RxPWDBAll;
      if (UndecoratedSmoothedCCK <= 0) {
        UndecoratedSmoothedCCK = (s32 )pPhyInfo->RxPWDBAll;
      } else
      if ((unsigned int )pPhyInfo->RxPWDBAll > (unsigned int )UndecoratedSmoothedCCK) {
        UndecoratedSmoothedCCK = (UndecoratedSmoothedCCK * 19 + (int )pPhyInfo->RxPWDBAll) / 20;
        UndecoratedSmoothedCCK = UndecoratedSmoothedCCK + 1;
      } else {
        UndecoratedSmoothedCCK = (UndecoratedSmoothedCCK * 19 + (int )pPhyInfo->RxPWDBAll) / 20;
      }
      pEntry->rssi_stat.PacketMap = pEntry->rssi_stat.PacketMap << 1;
    }
    if ((unsigned int )pEntry->rssi_stat.ValidBit > 63U) {
      pEntry->rssi_stat.ValidBit = 64U;
    } else {
      pEntry->rssi_stat.ValidBit = (u8 )((int )pEntry->rssi_stat.ValidBit + 1);
    }
    i = 0U;
    goto ldv_54275;
    ldv_54274:
    OFDM_pkt = ((u32 )((unsigned char )(pEntry->rssi_stat.PacketMap >> (int )i)) & 1U) + OFDM_pkt;
    i = (u8 )((int )i + 1);
    ldv_54275: ;
    if ((int )pEntry->rssi_stat.ValidBit > (int )i) {
      goto ldv_54274;
    } else {
    }
    if ((unsigned int )pEntry->rssi_stat.ValidBit == 64U) {
      Weighting = 64U < OFDM_pkt << 4 ? 64U : OFDM_pkt << 4;
      UndecoratedSmoothedPWDB = (s32 )((Weighting * (u32 )UndecoratedSmoothedOFDM + (64U - Weighting) * (u32 )UndecoratedSmoothedCCK) >> 6);
    } else
    if ((unsigned int )pEntry->rssi_stat.ValidBit != 0U) {
      UndecoratedSmoothedPWDB = (s32 )((OFDM_pkt * (u32 )UndecoratedSmoothedOFDM + ((u32 )pEntry->rssi_stat.ValidBit - OFDM_pkt) * (u32 )UndecoratedSmoothedCCK) / (u32 )pEntry->rssi_stat.ValidBit);
    } else {
      UndecoratedSmoothedPWDB = 0;
    }
    pEntry->rssi_stat.UndecoratedSmoothedCCK = UndecoratedSmoothedCCK;
    pEntry->rssi_stat.UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM;
    pEntry->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
  } else {
  }
  return;
}
}
static void ODM_PhyStatusQuery23a_92CSeries(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                            u8 *pPhyStatus , struct odm_packet_info *pPktinfo )
{
  {
  odm_RxPhyStatus92CSeries_Parsing(pDM_Odm, pPhyInfo, pPhyStatus, pPktinfo);
  if ((int )pDM_Odm->RSSI_test) {
    if ((int )pPktinfo->bPacketToSelf || (int )pPktinfo->bPacketBeacon) {
      ODM_SwAntDivChkPerPktRssi(pDM_Odm, (int )pPktinfo->StationID, pPhyInfo);
    } else {
    }
  } else {
    odm_Process_RSSIForDM(pDM_Odm, pPhyInfo, pPktinfo);
  }
  return;
}
}
void ODM_PhyStatusQuery23a(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                           u8 *pPhyStatus , struct odm_packet_info *pPktinfo )
{
  {
  ODM_PhyStatusQuery23a_92CSeries(pDM_Odm, pPhyInfo, pPhyStatus, pPktinfo);
  return;
}
}
void ODM_MacStatusQuery23a(struct dm_odm_t *pDM_Odm , u8 *pMacStatus , u8 MacID ,
                           bool bPacketMatchBSSID , bool bPacketToSelf , bool bPacketBeacon )
{
  {
  return;
}
}
int ODM_ConfigRFWithHeaderFile23a(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH Content ,
                                  enum RF_RADIO_PATH eRFPath )
{
  {
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ===>ODM_ConfigRFWithHeaderFile23a\n", "ODM_ConfigRFWithHeaderFile23a");
  } else {
  }
  if (pDM_Odm->SupportICType == 8U) {
    if ((unsigned int )eRFPath == 0U) {
      ODM_ReadAndConfig_RadioA_1T_8723A(pDM_Odm);
    } else {
    }
    if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s():  ===> ODM_ConfigRFWithHeaderFile23a() Radio_A:Rtl8723RadioA_1TArray\n",
             "ODM_ConfigRFWithHeaderFile23a");
    } else {
    }
    if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s():  ===> ODM_ConfigRFWithHeaderFile23a() Radio_B:Rtl8723RadioB_1TArray\n",
             "ODM_ConfigRFWithHeaderFile23a");
    } else {
    }
  } else {
  }
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 4U) {
    printk("[ODM-8723A] ");
    printk("%s(): ODM_ConfigRFWithHeaderFile23a: Radio No %x\n", "ODM_ConfigRFWithHeaderFile23a",
           (unsigned int )eRFPath);
  } else {
  }
  return (1);
}
}
int ODM_ConfigBBWithHeaderFile23a(struct dm_odm_t *pDM_Odm , enum odm_bb_config_type ConfigType )
{
  {
  if (pDM_Odm->SupportICType == 8U) {
    if ((unsigned int )ConfigType == 0U) {
      ODM_ReadAndConfig_PHY_REG_1T_8723A(pDM_Odm);
    } else
    if ((unsigned int )ConfigType == 1U) {
      ODM_ReadAndConfig_AGC_TAB_1T_8723A(pDM_Odm);
    } else {
    }
    if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s():  ===> phy_ConfigBBWithHeaderFile() phy:Rtl8723AGCTAB_1TArray\n",
             "ODM_ConfigBBWithHeaderFile23a");
    } else {
    }
    if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s():  ===> phy_ConfigBBWithHeaderFile() agc:Rtl8723PHY_REG_1TArray\n",
             "ODM_ConfigBBWithHeaderFile23a");
    } else {
    }
  } else {
  }
  return (1);
}
}
int ODM_ConfigMACWithHeaderFile23a(struct dm_odm_t *pDM_Odm )
{
  {
  if (pDM_Odm->SupportICType == 8U) {
    ODM_ReadAndConfig_MAC_REG_8723A(pDM_Odm);
  } else {
  }
  return (1);
}
}
void *ldv_kmem_cache_alloc_1418(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1424(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1426(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1428(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1429(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1430(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1431(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1432(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1433(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1434(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1460(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1468(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1476(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1470(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1466(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1474(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1475(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1471(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1472(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1473(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void ODM_Write_CCK_CCA_Thres23a(struct dm_odm_t *pDM_Odm , u8 CurCCK_CCAThres ) ;
void ODM_RF_Saving23a(struct dm_odm_t *pDM_Odm , u8 bForceInNormal ) ;
void ODM_SwAntDivRestAfterLink(struct dm_odm_t *pDM_Odm ) ;
void ODM_TXPowerTrackingCheck23a(struct dm_odm_t *pDM_Odm ) ;
bool ODM_RAStateCheck23a(struct dm_odm_t *pDM_Odm , s32 RSSI , bool bForceUpdate ,
                         u8 *pRATRState ) ;
u32 ConvertTo_dB23a(u32 Value ) ;
u32 GetPSDData(struct dm_odm_t *pDM_Odm , unsigned int point , u8 initial_gain_psd ) ;
void odm_DIG23abyRSSI_LPS(struct dm_odm_t *pDM_Odm ) ;
u32 ODM_Get_Rate_Bitmap23a(struct dm_odm_t *pDM_Odm , u32 macid , u32 ra_mask , u8 rssi_level ) ;
void ODM23a_DMInit(struct dm_odm_t *pDM_Odm ) ;
void ODM_DMWatchdog23a(struct dm_odm_t *pDM_Odm ) ;
void ODM_CmnInfoInit23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , u32 Value ) ;
void ODM23a_CmnInfoHook(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , void *pValue ) ;
void ODM_CmnInfoPtrArrayHook23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo ,
                                u16 Index , void *pValue ) ;
void ODM_CmnInfoUpdate23a(struct dm_odm_t *pDM_Odm , u32 CmnInfo , u64 Value ) ;
void ODM_SingleDualAntennaDefaultSetting(struct dm_odm_t *pDM_Odm ) ;
bool ODM_SingleDualAntennaDetection(struct dm_odm_t *pDM_Odm , u8 mode ) ;
void odm_dtc(struct dm_odm_t *pDM_Odm ) ;
bool rtl8723a_BT_disable_EDCA_turbo(struct rtw_adapter *padapter ) ;
int rtl8723a_set_rssi_cmd(struct rtw_adapter *padapter , u8 *param ) ;
static u16 const dB_Invert_Table[8U][12U] =
  { { 1U, 1U, 1U, 2U,
            2U, 2U, 2U, 3U,
            3U, 3U, 4U, 4U},
   { 4U, 5U, 6U, 6U,
            7U, 8U, 9U, 10U,
            11U, 13U, 14U, 16U},
   { 18U, 20U, 22U, 25U,
            28U, 32U, 35U, 40U,
            45U, 50U, 56U, 63U},
   { 71U, 79U, 89U, 100U,
            112U, 126U, 141U, 158U,
            178U, 200U, 224U, 251U},
   { 282U, 316U, 355U, 398U,
            447U, 501U, 562U, 631U,
            708U, 794U, 891U, 1000U},
   { 1122U, 1259U, 1413U, 1585U,
            1778U, 1995U, 2239U, 2512U,
            2818U, 3162U, 3548U, 3981U},
   { 4467U, 5012U, 5623U, 6310U,
            7079U, 7943U, 8913U, 10000U,
            11220U, 12589U, 14125U, 15849U},
   { 17783U, 19953U, 22387U, 25119U,
            28184U, 31623U, 35481U, 39811U,
            44668U, 50119U, 56234U, 65535U}};
static u32 EDCAParam[17U][3U] =
  { { 6202411U, 6202411U, 6202411U},
   { 42063U, 6202447U, 6177564U},
   { 6202411U, 6202411U, 6202411U},
   { 6202155U, 6202411U, 6177570U},
   { 6202402U, 42063U, 42063U},
   { 6202146U, 42544U, 42063U},
   { 6177570U, 6177570U, 6177570U},
   { 6202447U, 42063U, 6202411U},
   { 6202411U, 6202411U, 6202411U},
   { 6202411U, 42544U, 6177564U}};
u32 OFDMSwingTable23A[43U] =
  { 2139095550U, 2021655010U, 1908408775U, 1803551150U,
        1698693525U, 1606418815U, 1514144105U, 1430258005U,
        1350566210U, 1275068720U, 1203765535U, 1136656655U,
        1073742080U, 1015021810U, 956301540U, 901775575U,
        851443915U, 805306560U, 759169205U, 717226155U,
        679477410U, 637534360U, 603979920U, 570425480U,
        536871040U, 507510905U, 478150770U, 452984940U,
        427819110U, 402653280U, 381681755U, 360710230U,
        339738705U, 318767180U, 301989960U, 285212740U,
        268435520U, 251658300U, 239075385U, 226492470U,
        213909555U, 201326640U, 188743725U};
u8 CCKSwingTable_Ch1_Ch1323A[33U][8U] =
  { { 54U, 53U, 46U, 37U,
            28U, 18U, 9U, 4U},
   { 51U, 50U, 43U, 35U,
            26U, 17U, 8U, 4U},
   { 48U, 47U, 41U, 33U,
            25U, 16U, 8U, 3U},
   { 45U, 45U, 39U, 31U,
            24U, 15U, 8U, 3U},
   { 43U, 42U, 37U, 30U,
            22U, 14U, 7U, 3U},
   { 40U, 40U, 34U, 28U,
            21U, 13U, 7U, 3U},
   { 38U, 37U, 33U, 27U,
            20U, 13U, 6U, 3U},
   { 36U, 35U, 31U, 25U,
            19U, 12U, 6U, 3U},
   { 34U, 33U, 29U, 24U,
            17U, 11U, 6U, 2U},
   { 32U, 32U, 27U, 22U,
            17U, 8U, 5U, 2U},
   { 31U, 30U, 26U, 21U,
            16U, 10U, 5U, 2U},
   { 29U, 28U, 24U, 20U,
            15U, 10U, 5U, 2U},
   { 27U, 26U, 23U, 19U,
            14U, 9U, 4U, 2U},
   { 26U, 25U, 22U, 18U,
            13U, 9U, 4U, 2U},
   { 24U, 23U, 21U, 17U,
            12U, 8U, 4U, 2U},
   { 23U, 22U, 19U, 16U,
            12U, 8U, 4U, 2U},
   { 22U, 21U, 18U, 15U,
            11U, 7U, 4U, 1U},
   { 20U, 20U, 17U, 14U,
            11U, 7U, 3U, 2U},
   { 19U, 19U, 16U, 13U,
            10U, 6U, 3U, 1U},
   { 18U, 18U, 15U, 12U,
            9U, 6U, 3U, 1U},
   { 17U, 17U, 15U, 12U,
            9U, 6U, 3U, 1U},
   { 16U, 16U, 14U, 11U,
            8U, 5U, 3U, 1U},
   { 15U, 15U, 13U, 11U,
            8U, 5U, 3U, 1U},
   { 14U, 14U, 12U, 10U,
            8U, 5U, 2U, 1U},
   { 13U, 13U, 12U, 10U,
            7U, 5U, 2U, 1U},
   { 13U, 12U, 11U, 9U,
            7U, 4U, 2U, 1U},
   { 12U, 12U, 10U, 9U,
            6U, 4U, 2U, 1U},
   { 11U, 11U, 10U, 8U,
            6U, 4U, 2U, 1U},
   { 11U, 10U, 9U, 8U,
            6U, 4U, 2U, 1U},
   { 10U, 10U, 9U, 7U,
            5U, 3U, 2U, 1U},
   { 10U, 9U, 8U, 7U,
            5U, 3U, 2U, 1U},
   { 9U, 9U, 8U, 6U,
            5U, 3U, 1U, 1U},
   { 9U, 8U, 7U, 6U,
            4U, 3U, 1U, 1U}};
u8 CCKSwingTable_Ch1423A[33U][8U] =
  { { 54U, 53U, 46U, 27U,
            0U, 0U, 0U, 0U},
   { 51U, 50U, 43U, 25U,
            0U, 0U, 0U, 0U},
   { 48U, 47U, 41U, 24U,
            0U, 0U, 0U, 0U},
   { 45U, 45U, 23U, 23U,
            0U, 0U, 0U, 0U},
   { 43U, 42U, 37U, 21U,
            0U, 0U, 0U, 0U},
   { 40U, 40U, 36U, 20U,
            0U, 0U, 0U, 0U},
   { 38U, 37U, 33U, 19U,
            0U, 0U, 0U, 0U},
   { 36U, 35U, 31U, 18U,
            0U, 0U, 0U, 0U},
   { 34U, 33U, 29U, 17U,
            0U, 0U, 0U, 0U},
   { 32U, 32U, 27U, 16U,
            0U, 0U, 0U, 0U},
   { 31U, 30U, 26U, 15U,
            0U, 0U, 0U, 0U},
   { 29U, 28U, 24U, 14U,
            0U, 0U, 0U, 0U},
   { 27U, 26U, 23U, 14U,
            0U, 0U, 0U, 0U},
   { 26U, 25U, 22U, 13U,
            0U, 0U, 0U, 0U},
   { 24U, 23U, 21U, 12U,
            0U, 0U, 0U, 0U},
   { 23U, 22U, 19U, 11U,
            0U, 0U, 0U, 0U},
   { 22U, 21U, 18U, 11U,
            0U, 0U, 0U, 0U},
   { 20U, 20U, 17U, 10U,
            0U, 0U, 0U, 0U},
   { 19U, 19U, 16U, 10U,
            0U, 0U, 0U, 0U},
   { 18U, 18U, 15U, 9U,
            0U, 0U, 0U, 0U},
   { 17U, 17U, 15U, 9U,
            0U, 0U, 0U, 0U},
   { 16U, 16U, 14U, 8U,
            0U, 0U, 0U, 0U},
   { 15U, 15U, 13U, 8U,
            0U, 0U, 0U, 0U},
   { 14U, 14U, 12U, 7U,
            0U, 0U, 0U, 0U},
   { 13U, 13U, 12U, 7U,
            0U, 0U, 0U, 0U},
   { 13U, 12U, 11U, 6U,
            0U, 0U, 0U, 0U},
   { 12U, 12U, 10U, 6U,
            0U, 0U, 0U, 0U},
   { 11U, 11U, 10U, 6U,
            0U, 0U, 0U, 0U},
   { 11U, 10U, 9U, 5U,
            0U, 0U, 0U, 0U},
   { 10U, 10U, 9U, 5U,
            0U, 0U, 0U, 0U},
   { 10U, 9U, 8U, 5U,
            0U, 0U, 0U, 0U},
   { 9U, 9U, 8U, 5U,
            0U, 0U, 0U, 0U},
   { 9U, 8U, 7U, 4U,
            0U, 0U, 0U, 0U}};
void odm_CommonInfoSelfInit23a(struct dm_odm_t *pDM_Odm ) ;
void odm_CommonInfoSelfUpdate23a(struct dm_odm_t *pDM_Odm ) ;
void odm_CmnInfoInit_Debug23a(struct dm_odm_t *pDM_Odm ) ;
void odm_CmnInfoHook_Debug23a(struct dm_odm_t *pDM_Odm ) ;
void odm_CmnInfoUpdate_Debug23a(struct dm_odm_t *pDM_Odm ) ;
void odm_FalseAlarmCounterStatistics23a(struct dm_odm_t *pDM_Odm ) ;
void odm_DIG23aInit(struct dm_odm_t *pDM_Odm ) ;
void odm_DIG23a(struct dm_odm_t *pDM_Odm ) ;
void odm_CCKPacketDetectionThresh23a(struct dm_odm_t *pDM_Odm ) ;
void odm23a_DynBBPSInit(struct dm_odm_t *pDM_Odm ) ;
void odm_DynamicBBPowerSaving23a(struct dm_odm_t *pDM_Odm ) ;
void odm_1R_CCA23a(struct dm_odm_t *pDM_Odm ) ;
void odm_RefreshRateAdaptiveMask23aMP23a(struct dm_odm_t *pDM_Odm ) ;
void odm_RefreshRateAdaptiveMask23aCE23a(struct dm_odm_t *pDM_Odm ) ;
void odm_RefreshRateAdaptiveMask23aAPADSL23a(struct dm_odm_t *pDM_Odm ) ;
void odm_DynamicTxPower23aInit(struct dm_odm_t *pDM_Odm ) ;
void odm_RSSIMonitorInit(struct dm_odm_t *pDM_Odm ) ;
void odm_RSSIMonitorCheck23aMP(struct dm_odm_t *pDM_Odm ) ;
void odm_RSSIMonitorCheck23aCE(struct dm_odm_t *pDM_Odm ) ;
void odm_RSSIMonitorCheck23aAP(struct dm_odm_t *pDM_Odm ) ;
void odm_RSSIMonitorCheck23a(struct dm_odm_t *pDM_Odm ) ;
void odm_SwAntDivInit(struct dm_odm_t *pDM_Odm ) ;
void odm_SwAntDivChkAntSwitch(struct dm_odm_t *pDM_Odm , u8 Step ) ;
void odm_SwAntDivChkAntSwitchCallback23a(unsigned long data ) ;
void odm_RefreshRateAdaptiveMask23a(struct dm_odm_t *pDM_Odm ) ;
void odm_TXPowerTrackingCheckAP(struct dm_odm_t *pDM_Odm ) ;
void odm_RateAdaptiveMaskInit23a(struct dm_odm_t *pDM_Odm ) ;
void odm_TXPowerTrackingThermalMeterInit23a(struct dm_odm_t *pDM_Odm ) ;
void odm_TXPowerTrackingInit23a(struct dm_odm_t *pDM_Odm ) ;
void odm_TXPowerTrackingCheckMP(struct dm_odm_t *pDM_Odm ) ;
void odm_TXPowerTrackingCheckCE23a(struct dm_odm_t *pDM_Odm ) ;
void odm_EdcaTurboCheck23a(struct dm_odm_t *pDM_Odm ) ;
void ODM_EdcaTurboInit23a(struct dm_odm_t *pDM_Odm ) ;
void odm_EdcaTurboCheck23aCE23a(struct dm_odm_t *pDM_Odm ) ;
void odm_InitHybridAntDiv23a(struct dm_odm_t *pDM_Odm ) ;
void odm_HwAntDiv23a(struct dm_odm_t *pDM_Odm ) ;
void ODM23a_DMInit(struct dm_odm_t *pDM_Odm )
{
  {
  odm_CommonInfoSelfInit23a(pDM_Odm);
  odm_CmnInfoInit_Debug23a(pDM_Odm);
  odm_DIG23aInit(pDM_Odm);
  odm_RateAdaptiveMaskInit23a(pDM_Odm);
  if ((pDM_Odm->SupportICType & 31U) != 0U) {
    odm23a_DynBBPSInit(pDM_Odm);
    odm_DynamicTxPower23aInit(pDM_Odm);
    odm_TXPowerTrackingInit23a(pDM_Odm);
    ODM_EdcaTurboInit23a(pDM_Odm);
    if (((unsigned int )pDM_Odm->AntDivType == 1U || (unsigned int )pDM_Odm->AntDivType == 2U) || (unsigned int )pDM_Odm->AntDivType == 4U) {
      odm_InitHybridAntDiv23a(pDM_Odm);
    } else
    if ((unsigned int )pDM_Odm->AntDivType == 5U) {
      odm_SwAntDivInit(pDM_Odm);
    } else {
    }
  } else {
  }
  return;
}
}
void ODM_DMWatchdog23a(struct dm_odm_t *pDM_Odm )
{
  {
  odm_CmnInfoHook_Debug23a(pDM_Odm);
  odm_CmnInfoUpdate_Debug23a(pDM_Odm);
  odm_CommonInfoSelfUpdate23a(pDM_Odm);
  odm_FalseAlarmCounterStatistics23a(pDM_Odm);
  odm_RSSIMonitorCheck23a(pDM_Odm);
  if ((unsigned int )(pDM_Odm->Adapter)->pwrctrlpriv.pwr_mode != 0U && (pDM_Odm->SupportICType & 8U) != 0U) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): ----Step1: odm_DIG23a is in LPS mode\n", "ODM_DMWatchdog23a");
    } else {
    }
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): ---Step2: 8723AS is in LPS mode\n", "ODM_DMWatchdog23a");
    } else {
    }
    odm_DIG23abyRSSI_LPS(pDM_Odm);
  } else {
    odm_DIG23a(pDM_Odm);
  }
  odm_CCKPacketDetectionThresh23a(pDM_Odm);
  if ((int )*(pDM_Odm->pbPowerSaving)) {
    return;
  } else {
  }
  odm_RefreshRateAdaptiveMask23a(pDM_Odm);
  odm_DynamicBBPowerSaving23a(pDM_Odm);
  if (((unsigned int )pDM_Odm->AntDivType == 1U || (unsigned int )pDM_Odm->AntDivType == 2U) || (unsigned int )pDM_Odm->AntDivType == 4U) {
    odm_HwAntDiv23a(pDM_Odm);
  } else
  if ((unsigned int )pDM_Odm->AntDivType == 5U) {
    odm_SwAntDivChkAntSwitch(pDM_Odm, 0);
  } else {
  }
  if ((pDM_Odm->SupportICType & 31U) != 0U) {
    ODM_TXPowerTrackingCheck23a(pDM_Odm);
    odm_EdcaTurboCheck23a(pDM_Odm);
  } else {
  }
  odm_dtc(pDM_Odm);
  return;
}
}
void ODM_CmnInfoInit23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , u32 Value )
{
  {
  switch ((unsigned int )CmnInfo) {
  case 1U:
  pDM_Odm->SupportAbility = Value;
  goto ldv_54354;
  case 0U: ;
  goto ldv_54354;
  case 2U:
  pDM_Odm->SupportInterface = (unsigned char )Value;
  goto ldv_54354;
  case 3U:
  pDM_Odm->bIsMPChip = (unsigned int )((unsigned char )Value) != 0U;
  goto ldv_54354;
  case 4U:
  pDM_Odm->SupportICType = Value;
  goto ldv_54354;
  case 5U:
  pDM_Odm->CutVersion = (unsigned char )Value;
  goto ldv_54354;
  case 6U:
  pDM_Odm->FabVersion = (unsigned char )Value;
  goto ldv_54354;
  case 7U:
  pDM_Odm->RFType = (unsigned char )Value;
  goto ldv_54354;
  case 45U:
  pDM_Odm->AntDivType = (unsigned char )Value;
  goto ldv_54354;
  case 8U:
  pDM_Odm->BoardType = (unsigned char )Value;
  goto ldv_54354;
  case 9U:
  pDM_Odm->ExtLNA = (unsigned char )Value;
  goto ldv_54354;
  case 10U:
  pDM_Odm->ExtPA = (unsigned char )Value;
  goto ldv_54354;
  case 11U:
  pDM_Odm->ExtTRSW = (unsigned char )Value;
  goto ldv_54354;
  case 12U:
  pDM_Odm->PatchID = (unsigned char )Value;
  goto ldv_54354;
  case 13U:
  pDM_Odm->bInHctTest = Value != 0U;
  goto ldv_54354;
  case 14U:
  pDM_Odm->bWIFITest = Value != 0U;
  goto ldv_54354;
  case 15U:
  pDM_Odm->bDualMacSmartConcurrent = Value != 0U;
  goto ldv_54354;
  default: ;
  goto ldv_54354;
  }
  ldv_54354:
  pDM_Odm->BbSwingIdxOfdm = 12U;
  pDM_Odm->BbSwingIdxOfdmCurrent = 12U;
  pDM_Odm->BbSwingFlagOfdm = 0;
  return;
}
}
void ODM23a_CmnInfoHook(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , void *pValue )
{
  {
  switch ((unsigned int )CmnInfo) {
  case 16U:
  pDM_Odm->pMacPhyMode = (u8 *)pValue;
  goto ldv_54378;
  case 17U:
  pDM_Odm->pNumTxBytesUnicast = (u64 *)pValue;
  goto ldv_54378;
  case 18U:
  pDM_Odm->pNumRxBytesUnicast = (u64 *)pValue;
  goto ldv_54378;
  case 19U:
  pDM_Odm->pWirelessMode = (u8 *)pValue;
  goto ldv_54378;
  case 20U:
  pDM_Odm->pBandType = (u8 *)pValue;
  goto ldv_54378;
  case 21U:
  pDM_Odm->pSecChOffset = (u8 *)pValue;
  goto ldv_54378;
  case 22U:
  pDM_Odm->pSecurity = (u8 *)pValue;
  goto ldv_54378;
  case 23U:
  pDM_Odm->pBandWidth = (u8 *)pValue;
  goto ldv_54378;
  case 24U:
  pDM_Odm->pChannel = (u8 *)pValue;
  goto ldv_54378;
  case 25U:
  pDM_Odm->pbGetValueFromOtherMac = (bool *)pValue;
  goto ldv_54378;
  case 26U:
  pDM_Odm->pBuddyAdapter = (struct rtw_adapter **)pValue;
  goto ldv_54378;
  case 27U:
  pDM_Odm->pbMasterOfDMSP = (bool *)pValue;
  goto ldv_54378;
  case 28U:
  pDM_Odm->pbScanInProcess = (bool *)pValue;
  goto ldv_54378;
  case 29U:
  pDM_Odm->pbPowerSaving = (bool *)pValue;
  goto ldv_54378;
  case 30U:
  pDM_Odm->pOnePathCCA = (u8 *)pValue;
  goto ldv_54378;
  case 31U:
  pDM_Odm->pbDriverStopped = (bool *)pValue;
  goto ldv_54378;
  case 32U:
  pDM_Odm->pbDriverIsGoingToPnpSetPowerSleep = (bool *)pValue;
  goto ldv_54378;
  case 33U:
  pDM_Odm->pinit_adpt_in_progress = (bool *)pValue;
  goto ldv_54378;
  case 34U:
  pDM_Odm->pAntennaTest = (u8 *)pValue;
  goto ldv_54378;
  case 35U:
  pDM_Odm->pbNet_closed = (bool *)pValue;
  goto ldv_54378;
  default: ;
  goto ldv_54378;
  }
  ldv_54378: ;
  return;
}
}
void ODM_CmnInfoPtrArrayHook23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo ,
                                u16 Index , void *pValue )
{
  {
  switch ((unsigned int )CmnInfo) {
  case 51U:
  pDM_Odm->pODM_StaInfo[(int )Index] = (struct sta_info *)pValue;
  goto ldv_54406;
  default: ;
  goto ldv_54406;
  }
  ldv_54406: ;
  return;
}
}
void ODM_CmnInfoUpdate23a(struct dm_odm_t *pDM_Odm , u32 CmnInfo , u64 Value )
{
  {
  switch (CmnInfo) {
  case 1U:
  pDM_Odm->SupportAbility = (unsigned int )Value;
  goto ldv_54414;
  case 7U:
  pDM_Odm->RFType = (unsigned char )Value;
  goto ldv_54414;
  case 37U:
  pDM_Odm->bWIFI_Direct = Value != 0ULL;
  goto ldv_54414;
  case 38U:
  pDM_Odm->bWIFI_Display = Value != 0ULL;
  goto ldv_54414;
  case 39U:
  pDM_Odm->bLinked = Value != 0ULL;
  goto ldv_54414;
  case 40U:
  pDM_Odm->RSSI_Min = (unsigned char )Value;
  goto ldv_54414;
  case 41U:
  pDM_Odm->DebugComponents = Value;
  goto ldv_54414;
  case 42U:
  pDM_Odm->DebugLevel = (unsigned int )Value;
  goto ldv_54414;
  case 43U:
  pDM_Odm->RateAdaptive.HighRSSIThresh = (unsigned char )Value;
  goto ldv_54414;
  case 44U:
  pDM_Odm->RateAdaptive.LowRSSIThresh = (unsigned char )Value;
  goto ldv_54414;
  }
  ldv_54414: ;
  return;
}
}
void odm_CommonInfoSelfInit23a(struct dm_odm_t *pDM_Odm )
{
  u32 tmp ;
  u32 tmp___0 ;
  {
  tmp = ODM_GetBBReg(pDM_Odm, 2084U, 512U);
  pDM_Odm->bCckHighPower = tmp != 0U;
  tmp___0 = ODM_GetBBReg(pDM_Odm, 3076U, 15U);
  pDM_Odm->RFPathRxEnable = (unsigned char )tmp___0;
  if ((pDM_Odm->SupportICType & 8U) != 0U) {
    pDM_Odm->AntDivType = 5U;
  } else {
  }
  ODM_InitDebugSetting23a(pDM_Odm);
  return;
}
}
void odm_CommonInfoSelfUpdate23a(struct dm_odm_t *pDM_Odm )
{
  u8 EntryCnt ;
  u8 i ;
  struct sta_info *pEntry ;
  {
  EntryCnt = 0U;
  if ((unsigned int )*(pDM_Odm->pBandWidth) == 1U) {
    if ((unsigned int )*(pDM_Odm->pSecChOffset) == 1U) {
      pDM_Odm->ControlChannel = (unsigned int )*(pDM_Odm->pChannel) + 254U;
    } else
    if ((unsigned int )*(pDM_Odm->pSecChOffset) == 2U) {
      pDM_Odm->ControlChannel = (unsigned int )*(pDM_Odm->pChannel) + 2U;
    } else {
    }
  } else {
    pDM_Odm->ControlChannel = *(pDM_Odm->pChannel);
  }
  i = 0U;
  goto ldv_54434;
  ldv_54433:
  pEntry = pDM_Odm->pODM_StaInfo[(int )i];
  if ((unsigned long )pEntry != (unsigned long )((struct sta_info *)0)) {
    EntryCnt = (u8 )((int )EntryCnt + 1);
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54434: ;
  if ((unsigned int )i <= 31U) {
    goto ldv_54433;
  } else {
  }
  if ((unsigned int )EntryCnt == 1U) {
    pDM_Odm->bOneEntryOnly = 1;
  } else {
    pDM_Odm->bOneEntryOnly = 0;
  }
  return;
}
}
void odm_CmnInfoInit_Debug23a(struct dm_odm_t *pDM_Odm )
{
  {
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_CmnInfoInit_Debug23a ==>\n", "odm_CmnInfoInit_Debug23a");
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): SupportAbility = 0x%x\n", "odm_CmnInfoInit_Debug23a", pDM_Odm->SupportAbility);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): SupportInterface =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->SupportInterface);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): SupportICType = 0x%x\n", "odm_CmnInfoInit_Debug23a", pDM_Odm->SupportICType);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): CutVersion =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->CutVersion);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): FabVersion =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->FabVersion);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): RFType =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->RFType);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): BoardType =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->BoardType);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ExtLNA =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtLNA);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ExtPA =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtPA);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ExtTRSW =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtTRSW);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): PatchID =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->PatchID);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bInHctTest =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bInHctTest);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bWIFITest =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bWIFITest);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bDualMacSmartConcurrent =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bDualMacSmartConcurrent);
  } else {
  }
  return;
}
}
void odm_CmnInfoHook_Debug23a(struct dm_odm_t *pDM_Odm )
{
  {
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_CmnInfoHook_Debug23a ==>\n", "odm_CmnInfoHook_Debug23a");
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): pNumTxBytesUnicast =%llu\n", "odm_CmnInfoHook_Debug23a", *(pDM_Odm->pNumTxBytesUnicast));
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): pNumRxBytesUnicast =%llu\n", "odm_CmnInfoHook_Debug23a", *(pDM_Odm->pNumRxBytesUnicast));
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): pWirelessMode = 0x%x\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pWirelessMode));
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): pSecChOffset =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pSecChOffset));
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): pSecurity =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pSecurity));
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): pBandWidth =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pBandWidth));
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): pChannel =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pChannel));
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): pbScanInProcess =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pbScanInProcess));
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): pbPowerSaving =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pbPowerSaving));
  } else {
  }
  return;
}
}
void odm_CmnInfoUpdate_Debug23a(struct dm_odm_t *pDM_Odm )
{
  {
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_CmnInfoUpdate_Debug23a ==>\n", "odm_CmnInfoUpdate_Debug23a");
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bWIFI_Direct =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bWIFI_Direct);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bWIFI_Display =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bWIFI_Display);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): bLinked =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bLinked);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): RSSI_Min =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->RSSI_Min);
  } else {
  }
  return;
}
}
void ODM_Write_DIG23a(struct dm_odm_t *pDM_Odm , u8 CurrentIGI )
{
  struct dig_t *pDM_DigTable ;
  {
  pDM_DigTable = & pDM_Odm->DM_DigTable;
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ODM_REG(IGI_A, pDM_Odm) = 0x%x, ODM_BIT(IGI, pDM_Odm) = 0x%x \n",
           "ODM_Write_DIG23a", 3152, (pDM_Odm->SupportICType & 31U) != 0U ? 127U : 4294967295U);
  } else {
  }
  if ((int )pDM_DigTable->CurIGValue != (int )CurrentIGI) {
    ODM_SetBBReg(pDM_Odm, 3152U, (pDM_Odm->SupportICType & 31U) != 0U ? 127U : 4294967295U,
                 (u32 )CurrentIGI);
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): CurrentIGI(0x%02x). \n", "ODM_Write_DIG23a", (int )CurrentIGI);
    } else {
    }
    pDM_DigTable->CurIGValue = CurrentIGI;
  } else {
  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): ODM_Write_DIG23a():CurrentIGI = 0x%x \n", "ODM_Write_DIG23a", (int )CurrentIGI);
  } else {
  }
  return;
}
}
void odm_DIG23abyRSSI_LPS(struct dm_odm_t *pDM_Odm )
{
  struct rtw_adapter *pAdapter ;
  struct false_alarm_stats *pFalseAlmCnt ;
  u8 RSSI_Lower ;
  u8 bFwCurrentInPSMode ;
  u8 CurrentIGI ;
  {
  pAdapter = pDM_Odm->Adapter;
  pFalseAlmCnt = & pDM_Odm->FalseAlmCnt;
  RSSI_Lower = 30U;
  bFwCurrentInPSMode = 0U;
  CurrentIGI = pDM_Odm->RSSI_Min;
  if ((pDM_Odm->SupportICType & 8U) == 0U) {
    return;
  } else {
  }
  CurrentIGI = (unsigned int )CurrentIGI + 5U;
  bFwCurrentInPSMode = pAdapter->pwrctrlpriv.bFwCurrentInPSMode;
  if ((unsigned int )bFwCurrentInPSMode != 0U) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): ---Neil---odm_DIG23a is in LPS mode\n", "odm_DIG23abyRSSI_LPS");
    } else {
    }
    if (pFalseAlmCnt->Cnt_all > 30U) {
      CurrentIGI = (unsigned int )CurrentIGI + 2U;
    } else
    if (pFalseAlmCnt->Cnt_all > 15U) {
      CurrentIGI = (unsigned int )CurrentIGI + 1U;
    } else
    if (pFalseAlmCnt->Cnt_all <= 3U) {
      CurrentIGI = (unsigned int )CurrentIGI + 255U;
    } else {
    }
  } else {
    CurrentIGI = RSSI_Lower;
  }
  if ((int )pDM_Odm->RSSI_Min + -10 > 30) {
    RSSI_Lower = (unsigned int )pDM_Odm->RSSI_Min + 246U;
  } else {
    RSSI_Lower = 30U;
  }
  if ((unsigned int )CurrentIGI > 78U) {
    CurrentIGI = 78U;
  } else
  if ((int )CurrentIGI < (int )RSSI_Lower) {
    CurrentIGI = RSSI_Lower;
  } else {
  }
  ODM_Write_DIG23a(pDM_Odm, (int )CurrentIGI);
  return;
}
}
void odm_DIG23aInit(struct dm_odm_t *pDM_Odm )
{
  struct dig_t *pDM_DigTable ;
  u32 tmp ;
  {
  pDM_DigTable = & pDM_Odm->DM_DigTable;
  tmp = ODM_GetBBReg(pDM_Odm, 3152U, (pDM_Odm->SupportICType & 31U) != 0U ? 127U : 4294967295U);
  pDM_DigTable->CurIGValue = (unsigned char )tmp;
  pDM_DigTable->RssiLowThresh = 35;
  pDM_DigTable->RssiHighThresh = 40;
  pDM_DigTable->FALowThresh = 400U;
  pDM_DigTable->FAHighThresh = 1000U;
  if ((unsigned int )pDM_Odm->BoardType == 1U) {
    pDM_DigTable->rx_gain_range_max = 78U;
    pDM_DigTable->rx_gain_range_min = 30U;
  } else {
    pDM_DigTable->rx_gain_range_max = 78U;
    pDM_DigTable->rx_gain_range_min = 30U;
  }
  pDM_DigTable->BackoffVal = 10;
  pDM_DigTable->BackoffVal_range_max = 12;
  pDM_DigTable->BackoffVal_range_min = -4;
  pDM_DigTable->PreCCK_CCAThres = 255U;
  pDM_DigTable->CurCCK_CCAThres = 131U;
  pDM_DigTable->ForbiddenIGI = 30U;
  pDM_DigTable->LargeFAHit = 0U;
  pDM_DigTable->Recover_cnt = 0U;
  pDM_DigTable->DIG_Dynamic_MIN_0 = 30U;
  pDM_DigTable->DIG_Dynamic_MIN_1 = 30U;
  pDM_DigTable->bMediaConnect_0 = 0;
  pDM_DigTable->bMediaConnect_1 = 0;
  pDM_Odm->bDMInitialGainEnable = 1;
  return;
}
}
void odm_DIG23a(struct dm_odm_t *pDM_Odm )
{
  struct dig_t *pDM_DigTable ;
  struct false_alarm_stats *pFalseAlmCnt ;
  u8 DIG_Dynamic_MIN ;
  u8 DIG_MaxOfMin ;
  bool FirstConnect ;
  bool FirstDisConnect ;
  u8 dm_dig_max ;
  u8 dm_dig_min ;
  u8 CurrentIGI ;
  {
  pDM_DigTable = & pDM_Odm->DM_DigTable;
  pFalseAlmCnt = & pDM_Odm->FalseAlmCnt;
  CurrentIGI = pDM_DigTable->CurIGValue;
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a() ==>\n", "odm_DIG23a");
  } else {
  }
  if ((pDM_Odm->SupportAbility & 1U) == 0U || (pDM_Odm->SupportAbility & 8U) == 0U) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a() Return: SupportAbility ODM_BB_DIG or ODM_BB_FA_CNT is disabled\n",
             "odm_DIG23a");
    } else {
    }
    return;
  } else {
  }
  if ((int )*(pDM_Odm->pbScanInProcess)) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a() Return: In Scan Progress \n", "odm_DIG23a");
    } else {
    }
    return;
  } else {
  }
  if (! pDM_Odm->bDMInitialGainEnable) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a() Return: PSD is Processing \n", "odm_DIG23a");
    } else {
    }
    return;
  } else {
  }
  DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
  FirstConnect = (bool )((int )pDM_Odm->bLinked && ! pDM_DigTable->bMediaConnect_0);
  FirstDisConnect = (bool )(! pDM_Odm->bLinked && (int )pDM_DigTable->bMediaConnect_0);
  if ((pDM_Odm->SupportICType & 8U) != 0U && ((unsigned int )pDM_Odm->BoardType == 1U || (unsigned int )pDM_Odm->ExtLNA != 0U)) {
    dm_dig_max = 70U;
    dm_dig_min = 46U;
    DIG_MaxOfMin = 66U;
  } else {
    dm_dig_max = 78U;
    dm_dig_min = 30U;
    DIG_MaxOfMin = 50U;
  }
  if ((int )pDM_Odm->bLinked) {
    if (pDM_Odm->SupportICType == 8U) {
      if ((int )pDM_Odm->RSSI_Min + 10 > 78) {
        pDM_DigTable->rx_gain_range_max = 78U;
      } else
      if ((int )pDM_Odm->RSSI_Min + 10 <= 29) {
        pDM_DigTable->rx_gain_range_max = 30U;
      } else {
        pDM_DigTable->rx_gain_range_max = (unsigned int )pDM_Odm->RSSI_Min + 10U;
      }
      DIG_Dynamic_MIN = 30U;
    } else {
      if ((int )pDM_Odm->RSSI_Min + 20 > (int )dm_dig_max) {
        pDM_DigTable->rx_gain_range_max = dm_dig_max;
      } else
      if ((int )pDM_Odm->RSSI_Min + 20 < (int )dm_dig_min) {
        pDM_DigTable->rx_gain_range_max = dm_dig_min;
      } else {
        pDM_DigTable->rx_gain_range_max = (unsigned int )pDM_Odm->RSSI_Min + 20U;
      }
      if ((int )pDM_Odm->bOneEntryOnly) {
        if ((int )pDM_Odm->RSSI_Min < (int )dm_dig_min) {
          DIG_Dynamic_MIN = dm_dig_min;
        } else
        if ((int )pDM_Odm->RSSI_Min > (int )DIG_MaxOfMin) {
          DIG_Dynamic_MIN = DIG_MaxOfMin;
        } else {
          DIG_Dynamic_MIN = pDM_Odm->RSSI_Min;
        }
        if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): odm_DIG23a() : bOneEntryOnly = true,  DIG_Dynamic_MIN = 0x%x\n",
                 "odm_DIG23a", (int )DIG_Dynamic_MIN);
        } else {
        }
        if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): odm_DIG23a() : pDM_Odm->RSSI_Min =%d\n", "odm_DIG23a", (int )pDM_Odm->RSSI_Min);
        } else {
        }
      } else {
        DIG_Dynamic_MIN = dm_dig_min;
      }
    }
  } else {
    pDM_DigTable->rx_gain_range_max = dm_dig_max;
    DIG_Dynamic_MIN = dm_dig_min;
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a() : No Link\n", "odm_DIG23a");
    } else {
    }
  }
  if (pFalseAlmCnt->Cnt_all > 10000U) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): dm_DIG(): Abnornally false alarm case. \n", "odm_DIG23a");
    } else {
    }
    if ((unsigned int )pDM_DigTable->LargeFAHit != 3U) {
      pDM_DigTable->LargeFAHit = (u8 )((int )pDM_DigTable->LargeFAHit + 1);
    } else {
    }
    if ((int )pDM_DigTable->ForbiddenIGI < (int )CurrentIGI) {
      pDM_DigTable->ForbiddenIGI = CurrentIGI;
      pDM_DigTable->LargeFAHit = 1U;
    } else {
    }
    if ((unsigned int )pDM_DigTable->LargeFAHit > 2U) {
      if ((int )pDM_DigTable->ForbiddenIGI + 1 > (int )pDM_DigTable->rx_gain_range_max) {
        pDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
      } else {
        pDM_DigTable->rx_gain_range_min = (unsigned int )pDM_DigTable->ForbiddenIGI + 1U;
      }
      pDM_DigTable->Recover_cnt = 3600U;
    } else {
    }
  } else
  if (pDM_DigTable->Recover_cnt != 0U) {
    pDM_DigTable->Recover_cnt = pDM_DigTable->Recover_cnt - 1U;
  } else
  if ((unsigned int )pDM_DigTable->LargeFAHit <= 2U) {
    if ((int )pDM_DigTable->ForbiddenIGI + -1 < (int )DIG_Dynamic_MIN) {
      pDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN;
      pDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): odm_DIG23a(): Normal Case: At Lower Bound\n", "odm_DIG23a");
      } else {
      }
    } else {
      pDM_DigTable->ForbiddenIGI = (u8 )((int )pDM_DigTable->ForbiddenIGI - 1);
      pDM_DigTable->rx_gain_range_min = (unsigned int )pDM_DigTable->ForbiddenIGI + 1U;
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): odm_DIG23a(): Normal Case: Approach Lower Bound\n", "odm_DIG23a");
      } else {
      }
    }
  } else {
    pDM_DigTable->LargeFAHit = 0U;
  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): pDM_DigTable->LargeFAHit =%d\n", "odm_DIG23a", (int )pDM_DigTable->LargeFAHit);
  } else {
  }
  if ((int )pDM_Odm->bLinked) {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a(): DIG AfterLink\n", "odm_DIG23a");
    } else {
    }
    if ((int )FirstConnect) {
      CurrentIGI = pDM_Odm->RSSI_Min;
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): DIG: First Connect\n", "odm_DIG23a");
      } else {
      }
    } else
    if (pFalseAlmCnt->Cnt_all > 1024U) {
      CurrentIGI = (unsigned int )CurrentIGI + 4U;
    } else
    if (pFalseAlmCnt->Cnt_all > 768U) {
      CurrentIGI = (unsigned int )CurrentIGI + 2U;
    } else
    if (pFalseAlmCnt->Cnt_all <= 511U) {
      CurrentIGI = (unsigned int )CurrentIGI + 254U;
    } else {
    }
  } else {
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): odm_DIG23a(): DIG BeforeLink\n", "odm_DIG23a");
    } else {
    }
    if ((int )FirstDisConnect) {
      CurrentIGI = pDM_DigTable->rx_gain_range_min;
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): odm_DIG23a(): First DisConnect \n", "odm_DIG23a");
      } else {
      }
    } else {
      if (pFalseAlmCnt->Cnt_all > 10000U) {
        CurrentIGI = (unsigned int )CurrentIGI + 2U;
      } else
      if (pFalseAlmCnt->Cnt_all > 8000U) {
        CurrentIGI = (unsigned int )CurrentIGI + 1U;
      } else
      if (pFalseAlmCnt->Cnt_all <= 499U) {
        CurrentIGI = (unsigned int )CurrentIGI + 255U;
      } else {
      }
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): odm_DIG23a(): England DIG \n", "odm_DIG23a");
      } else {
      }
    }
  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): DIG End Adjust IGI\n", "odm_DIG23a");
  } else {
  }
  if ((int )pDM_DigTable->rx_gain_range_max < (int )CurrentIGI) {
    CurrentIGI = pDM_DigTable->rx_gain_range_max;
  } else {
  }
  if ((int )pDM_DigTable->rx_gain_range_min > (int )CurrentIGI) {
    CurrentIGI = pDM_DigTable->rx_gain_range_min;
  } else {
  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): rx_gain_range_max = 0x%x, rx_gain_range_min = 0x%x\n",
           "odm_DIG23a", (int )pDM_DigTable->rx_gain_range_max, (int )pDM_DigTable->rx_gain_range_min);
  } else {
  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): TotalFA =%d\n", "odm_DIG23a", pFalseAlmCnt->Cnt_all);
  } else {
  }
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_DIG23a(): CurIGValue = 0x%x\n", "odm_DIG23a", (int )CurrentIGI);
  } else {
  }
  ODM_Write_DIG23a(pDM_Odm, (int )CurrentIGI);
  pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
  pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
  return;
}
}
void odm_FalseAlarmCounterStatistics23a(struct dm_odm_t *pDM_Odm )
{
  u32 ret_value ;
  struct false_alarm_stats *FalseAlmCnt ;
  {
  FalseAlmCnt = & pDM_Odm->FalseAlmCnt;
  if ((pDM_Odm->SupportAbility & 8U) == 0U) {
    return;
  } else {
  }
  if ((pDM_Odm->SupportICType & 31U) != 0U) {
    ODM_SetBBReg(pDM_Odm, 3072U, 2147483648U, 1U);
    ODM_SetBBReg(pDM_Odm, 3328U, 2147483648U, 1U);
    ret_value = ODM_GetBBReg(pDM_Odm, 3312U, 4294967295U);
    FalseAlmCnt->Cnt_Fast_Fsync = ret_value & 65535U;
    FalseAlmCnt->Cnt_SB_Search_fail = ret_value >> 16;
    ret_value = ODM_GetBBReg(pDM_Odm, 3488U, 4294967295U);
    FalseAlmCnt->Cnt_OFDM_CCA = ret_value & 65535U;
    FalseAlmCnt->Cnt_Parity_Fail = ret_value >> 16;
    ret_value = ODM_GetBBReg(pDM_Odm, 3492U, 4294967295U);
    FalseAlmCnt->Cnt_Rate_Illegal = ret_value & 65535U;
    FalseAlmCnt->Cnt_Crc8_fail = ret_value >> 16;
    ret_value = ODM_GetBBReg(pDM_Odm, 3496U, 4294967295U);
    FalseAlmCnt->Cnt_Mcs_fail = ret_value & 65535U;
    FalseAlmCnt->Cnt_Ofdm_fail = ((((FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal) + FalseAlmCnt->Cnt_Crc8_fail) + FalseAlmCnt->Cnt_Mcs_fail) + FalseAlmCnt->Cnt_Fast_Fsync) + FalseAlmCnt->Cnt_SB_Search_fail;
    ODM_SetBBReg(pDM_Odm, 2604U, 4096U, 1U);
    ODM_SetBBReg(pDM_Odm, 2604U, 16384U, 1U);
    ret_value = ODM_GetBBReg(pDM_Odm, 2652U, 255U);
    FalseAlmCnt->Cnt_Cck_fail = ret_value;
    ret_value = ODM_GetBBReg(pDM_Odm, 2648U, 4278190080U);
    FalseAlmCnt->Cnt_Cck_fail = FalseAlmCnt->Cnt_Cck_fail + ((ret_value << 8) & 65535U);
    ret_value = ODM_GetBBReg(pDM_Odm, 2656U, 4294967295U);
    FalseAlmCnt->Cnt_CCK_CCA = ((ret_value << 8) & 65535U) | ((ret_value & 65280U) >> 8);
    FalseAlmCnt->Cnt_all = (((((FalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail) + FalseAlmCnt->Cnt_Parity_Fail) + FalseAlmCnt->Cnt_Rate_Illegal) + FalseAlmCnt->Cnt_Crc8_fail) + FalseAlmCnt->Cnt_Mcs_fail) + FalseAlmCnt->Cnt_Cck_fail;
    FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA + FalseAlmCnt->Cnt_CCK_CCA;
    if (pDM_Odm->SupportICType > 7U) {
      ODM_SetBBReg(pDM_Odm, 3084U, 2147483648U, 1U);
      ODM_SetBBReg(pDM_Odm, 3084U, 2147483648U, 0U);
      ODM_SetBBReg(pDM_Odm, 3328U, 134217728U, 1U);
      ODM_SetBBReg(pDM_Odm, 3328U, 134217728U, 0U);
      ODM_SetBBReg(pDM_Odm, 3072U, 2147483648U, 0U);
      ODM_SetBBReg(pDM_Odm, 3328U, 2147483648U, 0U);
      ODM_SetBBReg(pDM_Odm, 2604U, 12288U, 0U);
      ODM_SetBBReg(pDM_Odm, 2604U, 12288U, 2U);
      ODM_SetBBReg(pDM_Odm, 2604U, 49152U, 0U);
      ODM_SetBBReg(pDM_Odm, 2604U, 49152U, 2U);
    } else {
    }
    if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): Enter odm_FalseAlarmCounterStatistics23a\n", "odm_FalseAlarmCounterStatistics23a");
    } else {
    }
    if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): Cnt_Fast_Fsync =%d, Cnt_SB_Search_fail =%d\n", "odm_FalseAlarmCounterStatistics23a",
             FalseAlmCnt->Cnt_Fast_Fsync, FalseAlmCnt->Cnt_SB_Search_fail);
    } else {
    }
    if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): Cnt_Parity_Fail =%d, Cnt_Rate_Illegal =%d\n", "odm_FalseAlarmCounterStatistics23a",
             FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal);
    } else {
    }
    if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): Cnt_Crc8_fail =%d, Cnt_Mcs_fail =%d\n", "odm_FalseAlarmCounterStatistics23a",
             FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail);
    } else {
    }
  } else {
    FalseAlmCnt->Cnt_Ofdm_fail = ODM_GetBBReg(pDM_Odm, 3912U, 65535U);
    FalseAlmCnt->Cnt_Cck_fail = ODM_GetBBReg(pDM_Odm, 2652U, 65535U);
    FalseAlmCnt->Cnt_all = FalseAlmCnt->Cnt_Ofdm_fail + FalseAlmCnt->Cnt_Cck_fail;
    ODM_SetBBReg(pDM_Odm, 2468U, 131072U, 1U);
    ODM_SetBBReg(pDM_Odm, 2468U, 131072U, 0U);
    ODM_SetBBReg(pDM_Odm, 2604U, 32768U, 0U);
    ODM_SetBBReg(pDM_Odm, 2604U, 32768U, 1U);
  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Cnt_Cck_fail =%d\n", "odm_FalseAlarmCounterStatistics23a", FalseAlmCnt->Cnt_Cck_fail);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Cnt_Ofdm_fail =%d\n", "odm_FalseAlarmCounterStatistics23a", FalseAlmCnt->Cnt_Ofdm_fail);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): Total False Alarm =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_all);
  } else {
  }
  return;
}
}
void odm_CCKPacketDetectionThresh23a(struct dm_odm_t *pDM_Odm )
{
  struct false_alarm_stats *FalseAlmCnt ;
  u8 CurCCK_CCAThres ;
  {
  FalseAlmCnt = & pDM_Odm->FalseAlmCnt;
  if ((pDM_Odm->SupportAbility & 40U) == 0U) {
    return;
  } else {
  }
  if ((unsigned int )pDM_Odm->ExtLNA != 0U) {
    return;
  } else {
  }
  if ((int )pDM_Odm->bLinked) {
    if ((unsigned int )pDM_Odm->RSSI_Min > 25U) {
      CurCCK_CCAThres = 205U;
    } else
    if ((unsigned int )pDM_Odm->RSSI_Min <= 25U && (unsigned int )pDM_Odm->RSSI_Min > 10U) {
      CurCCK_CCAThres = 131U;
    } else
    if (FalseAlmCnt->Cnt_Cck_fail > 1000U) {
      CurCCK_CCAThres = 131U;
    } else {
      CurCCK_CCAThres = 64U;
    }
  } else
  if (FalseAlmCnt->Cnt_Cck_fail > 1000U) {
    CurCCK_CCAThres = 131U;
  } else {
    CurCCK_CCAThres = 64U;
  }
  ODM_Write_CCK_CCA_Thres23a(pDM_Odm, (int )CurCCK_CCAThres);
  return;
}
}
void ODM_Write_CCK_CCA_Thres23a(struct dm_odm_t *pDM_Odm , u8 CurCCK_CCAThres )
{
  struct dig_t *pDM_DigTable ;
  {
  pDM_DigTable = & pDM_Odm->DM_DigTable;
  if ((int )pDM_DigTable->CurCCK_CCAThres != (int )CurCCK_CCAThres) {
    ODM_Write1Byte(pDM_Odm, 2570U, (int )CurCCK_CCAThres);
  } else {
  }
  pDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;
  pDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;
  return;
}
}
void odm23a_DynBBPSInit(struct dm_odm_t *pDM_Odm )
{
  struct dynamic_pwr_sav *pDM_PSTable ;
  {
  pDM_PSTable = & pDM_Odm->DM_PSTable;
  pDM_PSTable->PreCCAState = 2U;
  pDM_PSTable->CurCCAState = 2U;
  pDM_PSTable->PreRFState = 2U;
  pDM_PSTable->CurRFState = 2U;
  pDM_PSTable->Rssi_val_min = 0;
  pDM_PSTable->initialize = 0U;
  return;
}
}
void odm_DynamicBBPowerSaving23a(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void odm_1R_CCA23a(struct dm_odm_t *pDM_Odm )
{
  struct dynamic_pwr_sav *pDM_PSTable ;
  {
  pDM_PSTable = & pDM_Odm->DM_PSTable;
  if ((unsigned int )pDM_Odm->RSSI_Min != 255U) {
    if ((unsigned int )pDM_PSTable->PreCCAState == 1U) {
      if ((unsigned int )pDM_Odm->RSSI_Min > 34U) {
        pDM_PSTable->CurCCAState = 0U;
      } else {
        pDM_PSTable->CurCCAState = 1U;
      }
    } else
    if ((unsigned int )pDM_Odm->RSSI_Min <= 30U) {
      pDM_PSTable->CurCCAState = 1U;
    } else {
      pDM_PSTable->CurCCAState = 0U;
    }
  } else {
    pDM_PSTable->CurCCAState = 2U;
  }
  if ((int )pDM_PSTable->PreCCAState != (int )pDM_PSTable->CurCCAState) {
    if ((unsigned int )pDM_PSTable->CurCCAState == 0U) {
      if ((unsigned int )pDM_Odm->RFType == 2U) {
        ODM_SetBBReg(pDM_Odm, 3076U, 255U, 19U);
      } else {
        ODM_SetBBReg(pDM_Odm, 3076U, 255U, 35U);
      }
    } else {
      ODM_SetBBReg(pDM_Odm, 3076U, 255U, 51U);
    }
    pDM_PSTable->PreCCAState = pDM_PSTable->CurCCAState;
  } else {
  }
  return;
}
}
void ODM_RF_Saving23a(struct dm_odm_t *pDM_Odm , u8 bForceInNormal )
{
  struct dynamic_pwr_sav *pDM_PSTable ;
  u8 Rssi_Up_bound ;
  u8 Rssi_Low_bound ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  pDM_PSTable = & pDM_Odm->DM_PSTable;
  Rssi_Up_bound = 30U;
  Rssi_Low_bound = 25U;
  if ((unsigned int )pDM_Odm->PatchID == 40U) {
    Rssi_Up_bound = 50U;
    Rssi_Low_bound = 45U;
  } else {
  }
  if ((unsigned int )pDM_PSTable->initialize == 0U) {
    tmp = ODM_GetBBReg(pDM_Odm, 2164U, 4294967295U);
    pDM_PSTable->Reg874 = (tmp & 1884160U) >> 14;
    tmp___0 = ODM_GetBBReg(pDM_Odm, 3184U, 4294967295U);
    pDM_PSTable->RegC70 = (u32 )(((unsigned long )tmp___0 & 8UL) >> 3);
    tmp___1 = ODM_GetBBReg(pDM_Odm, 2140U, 4294967295U);
    pDM_PSTable->Reg85C = tmp___1 >> 24;
    tmp___2 = ODM_GetBBReg(pDM_Odm, 2676U, 4294967295U);
    pDM_PSTable->RegA74 = (tmp___2 & 61440U) >> 12;
    pDM_PSTable->initialize = 1U;
  } else {
  }
  if ((unsigned int )bForceInNormal == 0U) {
    if ((unsigned int )pDM_Odm->RSSI_Min != 255U) {
      if ((unsigned int )pDM_PSTable->PreRFState == 1U) {
        if ((int )pDM_Odm->RSSI_Min >= (int )Rssi_Up_bound) {
          pDM_PSTable->CurRFState = 0U;
        } else {
          pDM_PSTable->CurRFState = 1U;
        }
      } else
      if ((int )pDM_Odm->RSSI_Min <= (int )Rssi_Low_bound) {
        pDM_PSTable->CurRFState = 1U;
      } else {
        pDM_PSTable->CurRFState = 0U;
      }
    } else {
      pDM_PSTable->CurRFState = 2U;
    }
  } else {
    pDM_PSTable->CurRFState = 1U;
  }
  if ((int )pDM_PSTable->PreRFState != (int )pDM_PSTable->CurRFState) {
    if ((unsigned int )pDM_PSTable->CurRFState == 0U) {
      if (pDM_Odm->SupportICType == 8U) {
        ODM_SetBBReg(pDM_Odm, 2164U, 32U, 1U);
      } else {
      }
      ODM_SetBBReg(pDM_Odm, 2164U, 1835008U, 2U);
      ODM_SetBBReg(pDM_Odm, 3184U, 8U, 0U);
      ODM_SetBBReg(pDM_Odm, 2140U, 4278190080U, 99U);
      ODM_SetBBReg(pDM_Odm, 2164U, 49152U, 2U);
      ODM_SetBBReg(pDM_Odm, 2676U, 61440U, 3U);
      ODM_SetBBReg(pDM_Odm, 2072U, 268435456U, 0U);
      ODM_SetBBReg(pDM_Odm, 2072U, 268435456U, 1U);
    } else {
      ODM_SetBBReg(pDM_Odm, 2164U, 1884160U, pDM_PSTable->Reg874);
      ODM_SetBBReg(pDM_Odm, 3184U, 8U, pDM_PSTable->RegC70);
      ODM_SetBBReg(pDM_Odm, 2140U, 4278190080U, pDM_PSTable->Reg85C);
      ODM_SetBBReg(pDM_Odm, 2676U, 61440U, pDM_PSTable->RegA74);
      ODM_SetBBReg(pDM_Odm, 2072U, 268435456U, 0U);
      if (pDM_Odm->SupportICType == 8U) {
        ODM_SetBBReg(pDM_Odm, 2164U, 32U, 0U);
      } else {
      }
    }
    pDM_PSTable->PreRFState = pDM_PSTable->CurRFState;
  } else {
  }
  return;
}
}
void odm_RateAdaptiveMaskInit23a(struct dm_odm_t *pDM_Odm )
{
  struct odm_rate_adapt *pOdmRA ;
  {
  pOdmRA = & pDM_Odm->RateAdaptive;
  pOdmRA->Type = 1U;
  if ((unsigned int )pOdmRA->Type == 1U) {
    pDM_Odm->bUseRAMask = 1U;
  } else {
    pDM_Odm->bUseRAMask = 0U;
  }
  pOdmRA->RATRState = 0U;
  pOdmRA->HighRSSIThresh = 50U;
  pOdmRA->LowRSSIThresh = 20U;
  return;
}
}
u32 ODM_Get_Rate_Bitmap23a(struct dm_odm_t *pDM_Odm , u32 macid , u32 ra_mask , u8 rssi_level )
{
  struct sta_info *pEntry ;
  u32 rate_bitmap ;
  u8 WirelessMode ;
  {
  rate_bitmap = 268435455U;
  pEntry = pDM_Odm->pODM_StaInfo[macid];
  if ((unsigned long )pEntry == (unsigned long )((struct sta_info *)0)) {
    return (ra_mask);
  } else {
  }
  WirelessMode = pEntry->wireless_mode;
  switch ((int )WirelessMode) {
  case 1: ;
  if ((ra_mask & 12U) != 0U) {
    rate_bitmap = 13U;
  } else {
    rate_bitmap = 15U;
  }
  goto ldv_54528;
  case 6: ;
  if ((unsigned int )rssi_level == 1U) {
    rate_bitmap = 3840U;
  } else {
    rate_bitmap = 4080U;
  }
  goto ldv_54528;
  case 3: ;
  if ((unsigned int )rssi_level == 1U) {
    rate_bitmap = 3840U;
  } else
  if ((unsigned int )rssi_level == 2U) {
    rate_bitmap = 4080U;
  } else {
    rate_bitmap = 4085U;
  }
  goto ldv_54528;
  case 11: ;
  case 15: ;
  if ((unsigned int )pDM_Odm->RFType == 1U || (unsigned int )pDM_Odm->RFType == 0U) {
    if ((unsigned int )rssi_level == 1U) {
      rate_bitmap = 983040U;
    } else
    if ((unsigned int )rssi_level == 2U) {
      rate_bitmap = 1044480U;
    } else
    if ((unsigned int )*(pDM_Odm->pBandWidth) == 1U) {
      rate_bitmap = 1044501U;
    } else {
      rate_bitmap = 1044485U;
    }
  } else
  if ((unsigned int )rssi_level == 1U) {
    rate_bitmap = 261029888U;
  } else
  if ((unsigned int )rssi_level == 2U) {
    rate_bitmap = 261091328U;
  } else
  if ((unsigned int )*(pDM_Odm->pBandWidth) == 1U) {
    rate_bitmap = 261091349U;
  } else {
    rate_bitmap = 261091333U;
  }
  goto ldv_54528;
  default: ;
  if ((unsigned int )pDM_Odm->RFType == 0U) {
    rate_bitmap = 1048575U;
  } else {
    rate_bitmap = 268435455U;
  }
  goto ldv_54528;
  }
  ldv_54528: ;
  if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s():  ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n",
           "ODM_Get_Rate_Bitmap23a", (int )rssi_level, (int )WirelessMode, rate_bitmap);
  } else {
  }
  return (rate_bitmap);
}
}
void odm_RefreshRateAdaptiveMask23a(struct dm_odm_t *pDM_Odm )
{
  {
  if ((pDM_Odm->SupportAbility & 2U) == 0U) {
    return;
  } else {
  }
  odm_RefreshRateAdaptiveMask23aCE23a(pDM_Odm);
  return;
}
}
void odm_RefreshRateAdaptiveMask23aMP23a(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void odm_RefreshRateAdaptiveMask23aCE23a(struct dm_odm_t *pDM_Odm )
{
  u8 i ;
  struct rtw_adapter *pAdapter ;
  struct sta_info *pstat ;
  bool tmp ;
  {
  pAdapter = pDM_Odm->Adapter;
  if (pAdapter->bDriverStopped != 0) {
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 4U) {
      printk("[ODM-8723A] ");
      printk("%s(): <---- odm_RefreshRateAdaptiveMask23a(): driver is going to unload\n",
             "odm_RefreshRateAdaptiveMask23aCE23a");
    } else {
    }
    return;
  } else {
  }
  if ((unsigned int )pDM_Odm->bUseRAMask == 0U) {
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): <---- odm_RefreshRateAdaptiveMask23a(): driver does not control rate adaptive mask\n",
             "odm_RefreshRateAdaptiveMask23aCE23a");
    } else {
    }
    return;
  } else {
  }
  i = 0U;
  goto ldv_54549;
  ldv_54548:
  pstat = pDM_Odm->pODM_StaInfo[(int )i];
  if ((unsigned long )pstat != (unsigned long )((struct sta_info *)0)) {
    tmp = ODM_RAStateCheck23a(pDM_Odm, pstat->rssi_stat.UndecoratedSmoothedPWDB, 0,
                              & pstat->rssi_level);
    if ((int )tmp) {
      if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): RSSI:%d, RSSI_LEVEL:%d\n", "odm_RefreshRateAdaptiveMask23aCE23a",
               pstat->rssi_stat.UndecoratedSmoothedPWDB, (int )pstat->rssi_level);
      } else {
      }
      rtw_hal_update_ra_mask23a(pstat, (int )pstat->rssi_level);
    } else {
    }
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54549: ;
  if ((unsigned int )i <= 31U) {
    goto ldv_54548;
  } else {
  }
  return;
}
}
void odm_RefreshRateAdaptiveMask23aAPADSL23a(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
bool ODM_RAStateCheck23a(struct dm_odm_t *pDM_Odm , s32 RSSI , bool bForceUpdate ,
                         u8 *pRATRState )
{
  struct odm_rate_adapt *pRA ;
  u8 GoUpGap ;
  u8 HighRSSIThreshForRA ;
  u8 LowRSSIThreshForRA ;
  u8 RATRState ;
  {
  pRA = & pDM_Odm->RateAdaptive;
  GoUpGap = 5U;
  HighRSSIThreshForRA = pRA->HighRSSIThresh;
  LowRSSIThreshForRA = pRA->LowRSSIThresh;
  switch ((int )*pRATRState) {
  case 0: ;
  case 1: ;
  goto ldv_54567;
  case 2:
  HighRSSIThreshForRA = (int )HighRSSIThreshForRA + (int )GoUpGap;
  goto ldv_54567;
  case 3:
  HighRSSIThreshForRA = (int )HighRSSIThreshForRA + (int )GoUpGap;
  LowRSSIThreshForRA = (int )LowRSSIThreshForRA + (int )GoUpGap;
  goto ldv_54567;
  default:
  printk("Assertion failed! %s at ......\n", (char *)"false");
  printk("      ......%s,%s,line=%d\n", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared",
         "ODM_RAStateCheck23a", 1605);
  printk("%s(): wrong rssi level setting %d !", "ODM_RAStateCheck23a", (int )*pRATRState);
  goto ldv_54567;
  }
  ldv_54567: ;
  if ((int )HighRSSIThreshForRA < RSSI) {
    RATRState = 1U;
  } else
  if ((int )LowRSSIThreshForRA < RSSI) {
    RATRState = 2U;
  } else {
    RATRState = 3U;
  }
  if ((int )*pRATRState != (int )RATRState || (int )bForceUpdate) {
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): RSSI Level %d -> %d\n", "ODM_RAStateCheck23a", (int )*pRATRState,
             (int )RATRState);
    } else {
    }
    *pRATRState = RATRState;
    return (1);
  } else {
  }
  return (0);
}
}
void odm_DynamicTxPower23aInit(struct dm_odm_t *pDM_Odm )
{
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  {
  Adapter = pDM_Odm->Adapter;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pdmpriv->DynamicTxHighPowerLvl = 0U;
  return;
}
}
void odm_RSSIMonitorInit(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void odm_RSSIMonitorCheck23a(struct dm_odm_t *pDM_Odm )
{
  {
  if ((pDM_Odm->SupportAbility & 16U) == 0U) {
    return;
  } else {
  }
  odm_RSSIMonitorCheck23aCE(pDM_Odm);
  return;
}
}
void odm_RSSIMonitorCheck23aMP(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
static void FindMinimumRSSI(struct rtw_adapter *pAdapter )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;
  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pDM_Odm = & pHalData->odmpriv;
  if (! pDM_Odm->bLinked && pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0) {
    pdmpriv->MinUndecoratedPWDBForDM = 0;
  } else {
    pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
  }
  return;
}
}
void odm_RSSIMonitorCheck23aCE(struct dm_odm_t *pDM_Odm )
{
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  int i ;
  int tmpEntryMaxPWDB ;
  int tmpEntryMinPWDB ;
  u8 sta_cnt ;
  u32 PWDB_rssi[32U] ;
  unsigned int tmp ;
  struct sta_info *psta ;
  u8 tmp___0 ;
  {
  Adapter = pDM_Odm->Adapter;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  tmpEntryMaxPWDB = 0;
  tmpEntryMinPWDB = 255;
  sta_cnt = 0U;
  PWDB_rssi[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 32U) {
      break;
    } else {
    }
    PWDB_rssi[tmp] = 0U;
    tmp = tmp + 1U;
  }
  if (! pDM_Odm->bLinked) {
    return;
  } else {
  }
  i = 0;
  goto ldv_54606;
  ldv_54605:
  psta = pDM_Odm->pODM_StaInfo[i];
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    if (psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB) {
      tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
    } else {
    }
    if (psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB) {
      tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
    } else {
    }
    if (psta->rssi_stat.UndecoratedSmoothedPWDB != -1) {
      tmp___0 = sta_cnt;
      sta_cnt = (u8 )((int )sta_cnt + 1);
      PWDB_rssi[(int )tmp___0] = psta->mac_id | (uint )(psta->rssi_stat.UndecoratedSmoothedPWDB << 16);
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_54606: ;
  if (i <= 31) {
    goto ldv_54605;
  } else {
  }
  i = 0;
  goto ldv_54609;
  ldv_54608: ;
  if (PWDB_rssi[i] != 0U) {
    if ((unsigned int )pHalData->fw_ractrl != 0U) {
      rtl8723a_set_rssi_cmd(Adapter, (u8 *)(& PWDB_rssi) + (unsigned long )i);
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_54609: ;
  if ((int )sta_cnt > i) {
    goto ldv_54608;
  } else {
  }
  if (tmpEntryMaxPWDB != 0) {
    pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
  } else {
    pdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;
  }
  if (tmpEntryMinPWDB != 255) {
    pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
  } else {
    pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
  }
  FindMinimumRSSI(Adapter);
  ODM_CmnInfoUpdate23a(& pHalData->odmpriv, 40U, (u64 )pdmpriv->MinUndecoratedPWDBForDM);
  return;
}
}
void odm_RSSIMonitorCheck23aAP(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void odm_TXPowerTrackingInit23a(struct dm_odm_t *pDM_Odm )
{
  {
  odm_TXPowerTrackingThermalMeterInit23a(pDM_Odm);
  return;
}
}
void odm_TXPowerTrackingThermalMeterInit23a(struct dm_odm_t *pDM_Odm )
{
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  {
  Adapter = pDM_Odm->Adapter;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pdmpriv->bTXPowerTracking = 1U;
  pdmpriv->TXPowercount = 0U;
  pdmpriv->bTXPowerTrackingInit = 0U;
  pdmpriv->TxPowerTrackControl = 1U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: pdmpriv->TxPowerTrackControl = %d\n", (int )pdmpriv->TxPowerTrackControl);
  } else {
  }
  pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = 1U;
  return;
}
}
void ODM_TXPowerTrackingCheck23a(struct dm_odm_t *pDM_Odm )
{
  {
  odm_TXPowerTrackingCheckCE23a(pDM_Odm);
  return;
}
}
void odm_TXPowerTrackingCheckCE23a(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void odm_TXPowerTrackingCheckMP(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void odm_TXPowerTrackingCheckAP(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void odm_SwAntDivInit(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void ODM_SwAntDivChkPerPktRssi(struct dm_odm_t *pDM_Odm , u8 StationID , struct phy_info *pPhyInfo )
{
  {
  return;
}
}
void odm_SwAntDivChkAntSwitch(struct dm_odm_t *pDM_Odm , u8 Step )
{
  {
  return;
}
}
void ODM_SwAntDivRestAfterLink(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void odm_SwAntDivChkAntSwitchCallback23a(unsigned long data )
{
  {
  return;
}
}
void odm_InitHybridAntDiv23a(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void odm_HwAntDiv23a(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void ODM_EdcaTurboInit23a(struct dm_odm_t *pDM_Odm )
{
  struct rtw_adapter *Adapter ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  {
  Adapter = pDM_Odm->Adapter;
  pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 0;
  pDM_Odm->DM_EDCA_Table.bIsCurRDLState = 0;
  Adapter->recvpriv.bIsAnyNonBEPkts = 0U;
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    tmp = ODM_Read4Byte(pDM_Odm, 1280U);
    printk("%s(): Orginial VO PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    tmp___0 = ODM_Read4Byte(pDM_Odm, 1284U);
    printk("%s(): Orginial VI PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___0);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    tmp___1 = ODM_Read4Byte(pDM_Odm, 1288U);
    printk("%s(): Orginial BE PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___1);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    tmp___2 = ODM_Read4Byte(pDM_Odm, 1292U);
    printk("%s(): Orginial BK PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___2);
  } else {
  }
  return;
}
}
void odm_EdcaTurboCheck23a(struct dm_odm_t *pDM_Odm )
{
  {
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): odm_EdcaTurboCheck23a ========================>\n", "odm_EdcaTurboCheck23a");
  } else {
  }
  if ((pDM_Odm->SupportAbility & 65536U) == 0U) {
    return;
  } else {
  }
  odm_EdcaTurboCheck23aCE23a(pDM_Odm);
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): <======================== odm_EdcaTurboCheck23a\n", "odm_EdcaTurboCheck23a");
  } else {
  }
  return;
}
}
void odm_EdcaTurboCheck23aCE23a(struct dm_odm_t *pDM_Odm )
{
  struct rtw_adapter *Adapter ;
  u32 trafficIndex ;
  u32 edca_param ;
  u64 cur_tx_bytes ;
  u64 cur_rx_bytes ;
  u8 bbtchange ;
  struct hal_data_8723a *pHalData ;
  struct xmit_priv *pxmitpriv ;
  struct recv_priv *precvpriv ;
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  {
  Adapter = pDM_Odm->Adapter;
  cur_tx_bytes = 0ULL;
  cur_rx_bytes = 0ULL;
  bbtchange = 0U;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pxmitpriv = & Adapter->xmitpriv;
  precvpriv = & Adapter->recvpriv;
  pregpriv = & Adapter->registrypriv;
  pmlmeext = & Adapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
    goto dm_CheckEdcaTurbo_EXIT;
  } else {
  }
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor > 16U) {
    goto dm_CheckEdcaTurbo_EXIT;
  } else {
  }
  tmp = rtl8723a_BT_disable_EDCA_turbo(Adapter);
  if ((int )tmp) {
    goto dm_CheckEdcaTurbo_EXIT;
  } else {
  }
  if ((unsigned int )bbtchange != 0U || precvpriv->bIsAnyNonBEPkts == 0U) {
    cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
    cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
    if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 4U || (unsigned int )pmlmeinfo->assoc_AP_vendor == 5U) {
      if (cur_rx_bytes << 2 < cur_tx_bytes) {
        trafficIndex = 0U;
      } else {
        trafficIndex = 1U;
      }
    } else
    if (cur_tx_bytes << 2 < cur_rx_bytes) {
      trafficIndex = 1U;
    } else {
      trafficIndex = 0U;
    }
    if (pDM_Odm->DM_EDCA_Table.prv_traffic_idx != trafficIndex || ! pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA) {
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 6U && ((int )pmlmeext->cur_wireless_mode & 8) != 0) {
        edca_param = EDCAParam[(int )pmlmeinfo->assoc_AP_vendor][trafficIndex];
      } else {
        edca_param = EDCAParam[0][trafficIndex];
      }
      rtl8723au_write32(Adapter, 1288U, edca_param);
      pDM_Odm->DM_EDCA_Table.prv_traffic_idx = trafficIndex;
    } else {
    }
    pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 1;
  } else
  if ((int )pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA) {
    rtl8723au_write32(Adapter, 1288U, pHalData->AcParam_BE);
    pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 0;
  } else {
  }
  dm_CheckEdcaTurbo_EXIT:
  precvpriv->bIsAnyNonBEPkts = 0U;
  pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
  precvpriv->last_rx_bytes = precvpriv->rx_bytes;
  return;
}
}
u32 GetPSDData(struct dm_odm_t *pDM_Odm , unsigned int point , u8 initial_gain_psd )
{
  u32 psd_report ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  ODM_SetBBReg(pDM_Odm, 2056U, 1023U, point);
  ODM_SetBBReg(pDM_Odm, 2056U, 4194304U, 1U);
  __const_udelay(128850UL);
  ODM_SetBBReg(pDM_Odm, 2056U, 4194304U, 0U);
  tmp = ODM_GetBBReg(pDM_Odm, 2228U, 4294967295U);
  psd_report = tmp & 65535U;
  tmp___0 = ConvertTo_dB23a(psd_report);
  psd_report = (tmp___0 + (u32 )initial_gain_psd) + 4294967268U;
  return (psd_report);
}
}
u32 ConvertTo_dB23a(u32 Value )
{
  u8 i ;
  u8 j ;
  u32 dB ;
  {
  Value = Value & 65535U;
  i = 0U;
  goto ldv_54698;
  ldv_54697: ;
  if ((u32 )dB_Invert_Table[(int )i][11] >= Value) {
    goto ldv_54696;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54698: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_54697;
  } else {
  }
  ldv_54696: ;
  if ((unsigned int )i > 7U) {
    return (96U);
  } else {
  }
  j = 0U;
  goto ldv_54701;
  ldv_54700: ;
  if ((u32 )dB_Invert_Table[(int )i][(int )j] >= Value) {
    goto ldv_54699;
  } else {
  }
  j = (u8 )((int )j + 1);
  ldv_54701: ;
  if ((unsigned int )j <= 11U) {
    goto ldv_54700;
  } else {
  }
  ldv_54699:
  dB = (u32 )(((int )i * 12 + (int )j) + 1);
  return (dB);
}
}
void ODM_SingleDualAntennaDefaultSetting(struct dm_odm_t *pDM_Odm )
{
  struct sw_ant_sw *pDM_SWAT_Table ;
  {
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
  pDM_SWAT_Table->ANTA_ON = 1;
  pDM_SWAT_Table->ANTB_ON = 1;
  return;
}
}
static void odm_PHY_SaveAFERegisters(struct dm_odm_t *pDM_Odm , u32 *AFEReg , u32 *AFEBackup ,
                                     u32 RegisterNum )
{
  u32 i ;
  {
  i = 0U;
  goto ldv_54714;
  ldv_54713:
  *(AFEBackup + (unsigned long )i) = ODM_GetBBReg(pDM_Odm, *(AFEReg + (unsigned long )i),
                                                  4294967295U);
  i = i + 1U;
  ldv_54714: ;
  if (i < RegisterNum) {
    goto ldv_54713;
  } else {
  }
  return;
}
}
static void odm_PHY_ReloadAFERegisters(struct dm_odm_t *pDM_Odm , u32 *AFEReg , u32 *AFEBackup ,
                                       u32 RegiesterNum )
{
  u32 i ;
  {
  i = 0U;
  goto ldv_54724;
  ldv_54723:
  ODM_SetBBReg(pDM_Odm, *(AFEReg + (unsigned long )i), 4294967295U, *(AFEBackup + (unsigned long )i));
  i = i + 1U;
  ldv_54724: ;
  if (i < RegiesterNum) {
    goto ldv_54723;
  } else {
  }
  return;
}
}
bool ODM_SingleDualAntennaDetection(struct dm_odm_t *pDM_Odm , u8 mode )
{
  struct sw_ant_sw *pDM_SWAT_Table ;
  u32 CurrentChannel ;
  u32 RfLoopReg ;
  u8 n ;
  u32 Reg88c ;
  u32 Regc08 ;
  u32 Reg874 ;
  u32 Regc50 ;
  u8 initial_gain ;
  u32 PSD_report_tmp ;
  u32 AntA_report ;
  u32 AntB_report ;
  u32 AntO_report ;
  bool bResult ;
  u32 AFE_Backup[16U] ;
  u32 AFE_REG_8723A[16U] ;
  {
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
  initial_gain = 90U;
  AntA_report = 0U;
  AntB_report = 0U;
  AntO_report = 0U;
  bResult = 1;
  AFE_REG_8723A[0] = 3696U;
  AFE_REG_8723A[1] = 3700U;
  AFE_REG_8723A[2] = 3704U;
  AFE_REG_8723A[3] = 3708U;
  AFE_REG_8723A[4] = 3712U;
  AFE_REG_8723A[5] = 3716U;
  AFE_REG_8723A[6] = 3720U;
  AFE_REG_8723A[7] = 3724U;
  AFE_REG_8723A[8] = 3792U;
  AFE_REG_8723A[9] = 3796U;
  AFE_REG_8723A[10] = 3800U;
  AFE_REG_8723A[11] = 3804U;
  AFE_REG_8723A[12] = 3808U;
  AFE_REG_8723A[13] = 3820U;
  AFE_REG_8723A[14] = 2140U;
  AFE_REG_8723A[15] = 3692U;
  if ((pDM_Odm->SupportICType & 8U) == 0U) {
    return (bResult);
  } else {
  }
  if ((pDM_Odm->SupportAbility & 64U) == 0U) {
    return (bResult);
  } else {
  }
  CurrentChannel = ODM_GetRFReg(pDM_Odm, 0, 24U, 1048575U);
  RfLoopReg = ODM_GetRFReg(pDM_Odm, 0, 0U, 1048575U);
  ODM_SetBBReg(pDM_Odm, 2144U, 768U, 1U);
  __const_udelay(42950UL);
  Reg88c = ODM_GetBBReg(pDM_Odm, 2188U, 4294967295U);
  Regc08 = ODM_GetBBReg(pDM_Odm, 3080U, 4294967295U);
  Reg874 = ODM_GetBBReg(pDM_Odm, 2164U, 4294967295U);
  Regc50 = ODM_GetBBReg(pDM_Odm, 3152U, 4294967295U);
  odm_PHY_SaveAFERegisters(pDM_Odm, (u32 *)(& AFE_REG_8723A), (u32 *)(& AFE_Backup),
                           16U);
  ODM_SetBBReg(pDM_Odm, 2056U, 49152U, 0U);
  ODM_SetRFReg(pDM_Odm, 0, 24U, 1048575U, 1U);
  ODM_SetBBReg(pDM_Odm, 3696U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3700U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3704U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3708U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3712U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3716U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3720U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3724U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3792U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3796U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3800U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3804U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3808U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3820U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 2140U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 3692U, 4294967295U, 1876632996U);
  ODM_SetBBReg(pDM_Odm, 2188U, 4294967295U, 3438280896U);
  ODM_SetBBReg(pDM_Odm, 3080U, 4294967295U, 524516U);
  ODM_SetBBReg(pDM_Odm, 2164U, 4294967295U, 572555264U);
  ODM_SetBBReg(pDM_Odm, 3632U, 4294967295U, 268471324U);
  ODM_SetBBReg(pDM_Odm, 3648U, 4294967295U, 16808960U);
  ODM_SetBBReg(pDM_Odm, 2920U, 4294967295U, 524288U);
  ODM_SetBBReg(pDM_Odm, 2920U, 4294967295U, 257949696U);
  ODM_SetBBReg(pDM_Odm, 3652U, 4294967295U, 16795648U);
  ODM_SetBBReg(pDM_Odm, 3636U, 4294967295U, 268471327U);
  ODM_SetBBReg(pDM_Odm, 3640U, 4294967295U, 2182414344U);
  ODM_SetBBReg(pDM_Odm, 3644U, 4294967295U, 672464904U);
  ODM_SetBBReg(pDM_Odm, 3660U, 4294967295U, 1059024U);
  ODM_SetRFReg(pDM_Odm, 0, 0U, 1048575U, 327688U);
  ODM_SetBBReg(pDM_Odm, 3624U, 4294967295U, 2155872256U);
  ODM_SetBBReg(pDM_Odm, 3656U, 4294967295U, 4160749568U);
  __const_udelay(4295000UL);
  PSD_report_tmp = 0U;
  n = 0U;
  goto ldv_54747;
  ldv_54746:
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
  if (PSD_report_tmp > AntA_report) {
    AntA_report = PSD_report_tmp;
  } else {
  }
  n = (u8 )((int )n + 1);
  ldv_54747: ;
  if ((unsigned int )n <= 1U) {
    goto ldv_54746;
  } else {
  }
  PSD_report_tmp = 0U;
  ODM_SetBBReg(pDM_Odm, 2144U, 768U, 2U);
  __const_udelay(42950UL);
  n = 0U;
  goto ldv_54750;
  ldv_54749:
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
  if (PSD_report_tmp > AntB_report) {
    AntB_report = PSD_report_tmp;
  } else {
  }
  n = (u8 )((int )n + 1);
  ldv_54750: ;
  if ((unsigned int )n <= 1U) {
    goto ldv_54749;
  } else {
  }
  ODM_SetBBReg(pDM_Odm, 2144U, 768U, 0U);
  __const_udelay(42950UL);
  n = 0U;
  goto ldv_54753;
  ldv_54752:
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
  if (PSD_report_tmp > AntO_report) {
    AntO_report = PSD_report_tmp;
  } else {
  }
  n = (u8 )((int )n + 1);
  ldv_54753: ;
  if ((unsigned int )n <= 1U) {
    goto ldv_54752;
  } else {
  }
  ODM_SetBBReg(pDM_Odm, 3624U, 4294967295U, 0U);
  PSD_report_tmp = 0U;
  ODM_SetBBReg(pDM_Odm, 2144U, 768U, 1U);
  ODM_SetBBReg(pDM_Odm, 2188U, 4294967295U, Reg88c);
  ODM_SetBBReg(pDM_Odm, 3080U, 4294967295U, Regc08);
  ODM_SetBBReg(pDM_Odm, 2164U, 4294967295U, Reg874);
  ODM_SetBBReg(pDM_Odm, 3152U, 127U, 64U);
  ODM_SetBBReg(pDM_Odm, 3152U, 4294967295U, Regc50);
  ODM_SetRFReg(pDM_Odm, 0, 24U, 1048575U, CurrentChannel);
  ODM_SetRFReg(pDM_Odm, 0, 0U, 1048575U, RfLoopReg);
  odm_PHY_ReloadAFERegisters(pDM_Odm, (u32 *)(& AFE_REG_8723A), (u32 *)(& AFE_Backup),
                             16U);
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): psd_report_A[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntA_report);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): psd_report_B[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntB_report);
  } else {
  }
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
    printk("[ODM-8723A] ");
    printk("%s(): psd_report_O[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntO_report);
  } else {
  }
  if ((unsigned int )mode == 2U) {
    if (AntA_report > 99U) {
      if (AntA_report + 1U < AntB_report) {
        pDM_SWAT_Table->ANTB_ON = 0;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): ODM_SingleDualAntennaDetection(): Single Antenna A\n", "ODM_SingleDualAntennaDetection");
        } else {
        }
      } else {
        pDM_SWAT_Table->ANTB_ON = 1;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n",
                 "ODM_SingleDualAntennaDetection");
        } else {
        }
      }
    } else {
      if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
        printk("[ODM-8723A] ");
        printk("%s(): ODM_SingleDualAntennaDetection(): Need to check again\n", "ODM_SingleDualAntennaDetection");
      } else {
      }
      pDM_SWAT_Table->ANTB_ON = 0;
      bResult = 0;
    }
  } else
  if ((unsigned int )mode == 0U) {
    if (AntO_report > 99U && AntO_report <= 117U) {
      if (AntO_report + 1U < AntA_report) {
        pDM_SWAT_Table->ANTA_ON = 0;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): Ant A is OFF", "ODM_SingleDualAntennaDetection");
        } else {
        }
      } else {
        pDM_SWAT_Table->ANTA_ON = 1;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): Ant A is ON", "ODM_SingleDualAntennaDetection");
        } else {
        }
      }
      if (AntO_report + 2U < AntB_report) {
        pDM_SWAT_Table->ANTB_ON = 0;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): Ant B is OFF", "ODM_SingleDualAntennaDetection");
        } else {
        }
      } else {
        pDM_SWAT_Table->ANTB_ON = 1;
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
          printk("[ODM-8723A] ");
          printk("%s(): Ant B is ON", "ODM_SingleDualAntennaDetection");
        } else {
        }
      }
    } else {
    }
  } else {
    if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
      printk("[ODM-8723A] ");
      printk("%s(): ODM_SingleDualAntennaDetection(): Need to check again\n", "ODM_SingleDualAntennaDetection");
    } else {
    }
    pDM_SWAT_Table->ANTA_ON = 1;
    pDM_SWAT_Table->ANTB_ON = 0;
    bResult = 0;
  }
  return (bResult);
}
}
void odm_dtc(struct dm_odm_t *pDM_Odm )
{
  {
  return;
}
}
void *ldv_kmem_cache_alloc_1460(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1466(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1468(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1470(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1471(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1472(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1473(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1474(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1475(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1476(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1502(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1510(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1518(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1512(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1508(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1516(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1517(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1513(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1514(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1515(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
s32 FillH2CCmd(struct rtw_adapter *padapter , u8 ElementID , u32 CmdLen , u8 *pCmdBuffer ) ;
void rtl8723a_fill_fake_txdesc(struct rtw_adapter *padapter , u8 *pDesc , u32 BufferLen ,
                               u8 IsPsPoll , u8 IsBTQosNull ) ;
void rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(struct rtw_adapter *padapter ) ;
int rtl8723a_set_raid_cmd(struct rtw_adapter *padapter , u32 mask , u8 arg ) ;
void rtl8723a_add_rateatid(struct rtw_adapter *pAdapter , u32 bitmap , u8 arg , u8 rssi_level ) ;
void CheckFwRsvdPageContent23a(struct rtw_adapter *Adapter ) ;
static u8 _is_fw_read_cmd_down(struct rtw_adapter *padapter , u8 msgbox_num )
{
  u8 read_down ;
  int retry_cnts ;
  u8 valid ;
  u8 tmp ;
  int tmp___0 ;
  {
  read_down = 0U;
  retry_cnts = 100;
  ldv_54292:
  tmp = rtl8723au_read8(padapter, 460U);
  valid = (int )tmp & (int )((u8 )(1UL << (int )msgbox_num));
  if ((unsigned int )valid == 0U) {
    read_down = 1U;
  } else {
  }
  if ((unsigned int )read_down == 0U) {
    tmp___0 = retry_cnts;
    retry_cnts = retry_cnts - 1;
    if (tmp___0 != 0) {
      goto ldv_54292;
    } else {
      goto ldv_54293;
    }
  } else {
  }
  ldv_54293: ;
  return (read_down);
}
}
s32 FillH2CCmd(struct rtw_adapter *padapter , u8 ElementID , u32 CmdLen , u8 *pCmdBuffer )
{
  u8 bcmd_down ;
  s32 retry_cnts ;
  u8 h2c_box_num ;
  u32 msgbox_addr ;
  u32 msgbox_ex_addr ;
  struct hal_data_8723a *pHalData ;
  u32 h2c_cmd ;
  u16 h2c_cmd_ex ;
  int ret ;
  u8 tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  s32 tmp___0 ;
  {
  bcmd_down = 0U;
  retry_cnts = 100;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  h2c_cmd = 0U;
  h2c_cmd_ex = 0U;
  ret = 0;
  padapter = (padapter->dvobj)->if1;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  mutex_lock_nested(& (padapter->dvobj)->h2c_fwcmd_mutex, 0U);
  if ((unsigned long )pCmdBuffer == (unsigned long )((u8 *)0U)) {
    goto exit;
  } else {
  }
  if (CmdLen > 5U) {
    goto exit;
  } else {
  }
  if (padapter->bSurpriseRemoved == 1) {
    goto exit;
  } else {
  }
  ldv_54319:
  h2c_box_num = pHalData->LastHMEBoxNum;
  tmp = _is_fw_read_cmd_down(padapter, (int )h2c_box_num);
  if ((unsigned int )tmp == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU:  fw read cmd failed...\n");
    } else {
    }
    goto exit;
  } else {
  }
  if (CmdLen <= 3U) {
    __len = (size_t )CmdLen;
    __ret = memcpy((void *)(& h2c_cmd) + 1U, (void const *)pCmdBuffer,
                             __len);
  } else {
    __len___0 = 2UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& h2c_cmd_ex), (void const *)pCmdBuffer, __len___0);
    } else {
      __ret___0 = memcpy((void *)(& h2c_cmd_ex), (void const *)pCmdBuffer,
                                   __len___0);
    }
    __len___1 = (size_t )(CmdLen - 2U);
    __ret___1 = memcpy((void *)(& h2c_cmd) + 1U, (void const *)pCmdBuffer + 2U,
                                 __len___1);
    *((u8 *)(& h2c_cmd)) = (u8 )((unsigned int )*((u8 *)(& h2c_cmd)) | 128U);
  }
  *((u8 *)(& h2c_cmd)) = (u8 )((int )*((u8 *)(& h2c_cmd)) | (int )ElementID);
  if (((unsigned long )h2c_cmd & 128UL) != 0UL) {
    msgbox_ex_addr = (u32 )(((int )h2c_box_num + 68) * 2);
    h2c_cmd_ex = h2c_cmd_ex;
    rtl8723au_write16(padapter, msgbox_ex_addr, (int )h2c_cmd_ex);
  } else {
  }
  msgbox_addr = (u32 )(((int )h2c_box_num + 116) * 4);
  h2c_cmd = h2c_cmd;
  rtl8723au_write32(padapter, msgbox_addr, h2c_cmd);
  bcmd_down = 1U;
  pHalData->LastHMEBoxNum = (u8 )(((int )h2c_box_num + 1) % 4);
  if ((unsigned int )bcmd_down == 0U) {
    tmp___0 = retry_cnts;
    retry_cnts = retry_cnts - 1;
    if (tmp___0 != 0) {
      goto ldv_54319;
    } else {
      goto ldv_54320;
    }
  } else {
  }
  ldv_54320:
  ret = 1;
  exit:
  mutex_unlock(& (padapter->dvobj)->h2c_fwcmd_mutex);
  return (ret);
}
}
int rtl8723a_set_rssi_cmd(struct rtw_adapter *padapter , u8 *param )
{
  int res ;
  {
  res = 1;
  *((u32 *)param) = *((u32 *)param);
  FillH2CCmd(padapter, 5, 3U, param);
  return (res);
}
}
int rtl8723a_set_raid_cmd(struct rtw_adapter *padapter , u32 mask , u8 arg )
{
  u8 buf[5U] ;
  int res ;
  size_t __len ;
  void *__ret ;
  {
  res = 1;
  memset((void *)(& buf), 0, 5UL);
  mask = mask;
  __len = 4UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& buf), (void const *)(& mask), __len);
  } else {
    __ret = memcpy((void *)(& buf), (void const *)(& mask), __len);
  }
  buf[4] = arg;
  FillH2CCmd(padapter, 6, 5U, (u8 *)(& buf));
  return (res);
}
}
void rtl8723a_add_rateatid(struct rtw_adapter *pAdapter , u32 bitmap , u8 arg , u8 rssi_level )
{
  struct hal_data_8723a *pHalData ;
  u8 macid ;
  u8 raid ;
  u8 init_rate ;
  u8 shortGIrate ;
  unsigned char tmp ;
  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  macid = (unsigned int )arg & 31U;
  raid = (u8 )(bitmap >> 28);
  bitmap = bitmap & 268435455U;
  if ((unsigned int )rssi_level != 0U) {
    bitmap = ODM_Get_Rate_Bitmap23a(& pHalData->odmpriv, (u32 )macid, bitmap, (int )rssi_level);
  } else {
  }
  bitmap = (u32 )((int )raid << 28) | bitmap;
  if ((unsigned int )pHalData->fw_ractrl == 1U) {
    rtl8723a_set_raid_cmd(pAdapter, bitmap, (int )arg);
  } else {
    shortGIrate = 0U;
    tmp = get_highest_rate_idx23a(bitmap & 268435455U);
    init_rate = (unsigned int )tmp & 63U;
    shortGIrate = ((unsigned long )arg & 32UL) != 0UL;
    if ((unsigned int )shortGIrate == 1U) {
      init_rate = (u8 )((unsigned int )init_rate | 64U);
    } else {
    }
    rtl8723au_write8(pAdapter, (u32 )((int )macid + 1156), (int )init_rate);
  }
  return;
}
}
void rtl8723a_set_FwPwrMode_cmd(struct rtw_adapter *padapter , u8 Mode )
{
  struct setpwrmode_parm H2CSetPwrMode ;
  struct pwrctrl_priv *pwrpriv ;
  struct hal_data_8723a *pHalData ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: Mode =%d SmartPS =%d UAPSD =%d BcnMode = 0x%02x\n",
           "rtl8723a_set_FwPwrMode_cmd", (int )Mode, (int )pwrpriv->smart_ps, (int )padapter->registrypriv.uapsd_enable,
           (int )pwrpriv->bcn_ant_mode);
  } else {
  }
  if ((unsigned int )Mode != 0U && (((unsigned int )pHalData->VersionID.ICType != 2U && (unsigned int )pHalData->VersionID.ICType != 1U) || (unsigned int )pHalData->VersionID.RFType != 2U)) {
    ODM_RF_Saving23a(& pHalData->odmpriv, 1);
  } else {
  }
  H2CSetPwrMode.Mode = Mode;
  H2CSetPwrMode.SmartPS = pwrpriv->smart_ps;
  H2CSetPwrMode.AwakeInterval = 1U;
  H2CSetPwrMode.bAllQueueUAPSD = padapter->registrypriv.uapsd_enable;
  H2CSetPwrMode.BcnAntMode = pwrpriv->bcn_ant_mode;
  FillH2CCmd(padapter, 1, 5U, (u8 *)(& H2CSetPwrMode));
  return;
}
}
static void ConstructBeacon(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength )
{
  struct ieee80211_hdr *pwlanhdr ;
  u32 rate_len ;
  u32 pktlen ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 bc_addr[6U] ;
  int bcn_fixed_size ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp ;
  u8 *tmp___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  size_t __len___2 ;
  void *__ret___2 ;
  __le16 *tmp___3 ;
  __le16 *tmp___4 ;
  size_t __len___3 ;
  void *__ret___3 ;
  __le16 *tmp___5 ;
  __le16 *tmp___6 ;
  size_t __len___4 ;
  void *__ret___4 ;
  u32 ATIMWindow ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  bc_addr[0] = 255U;
  bc_addr[1] = 255U;
  bc_addr[2] = 255U;
  bc_addr[3] = 255U;
  bc_addr[4] = 255U;
  bc_addr[5] = 255U;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 128U;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pwlanhdr->addr1), (void const *)(& bc_addr), __len);
  } else {
    __ret = memcpy((void *)(& pwlanhdr->addr1), (void const *)(& bc_addr),
                             __len);
  }
  __len___0 = 6UL;
  if (__len___0 > 63UL) {
    tmp = myid(& padapter->eeprompriv);
    __ret___0 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp, __len___0);
  } else {
    tmp___0 = myid(& padapter->eeprompriv);
    __ret___0 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp___0,
                                 __len___0);
  }
  __len___1 = 6UL;
  if (__len___1 > 63UL) {
    tmp___1 = get_my_bssid23a(cur_network);
    __ret___1 = memcpy((void *)(& pwlanhdr->addr3), (void const *)tmp___1, __len___1);
  } else {
    tmp___2 = get_my_bssid23a(cur_network);
    __ret___1 = memcpy((void *)(& pwlanhdr->addr3), (void const *)tmp___2,
                                 __len___1);
  }
  pwlanhdr->seq_ctrl = 0U;
  pframe = pframe + 24UL;
  pktlen = 24U;
  pframe = pframe + 8UL;
  pktlen = pktlen + 8U;
  __len___2 = 2UL;
  if (__len___2 > 63UL) {
    tmp___3 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
    __ret___2 = memcpy((void *)pframe, (void const *)tmp___3, __len___2);
  } else {
    tmp___4 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
    __ret___2 = memcpy((void *)pframe, (void const *)tmp___4, __len___2);
  }
  pframe = pframe + 2UL;
  pktlen = pktlen + 2U;
  __len___3 = 2UL;
  if (__len___3 > 63UL) {
    tmp___5 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
    __ret___3 = memcpy((void *)pframe, (void const *)tmp___5, __len___3);
  } else {
    tmp___6 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
    __ret___3 = memcpy((void *)pframe, (void const *)tmp___6, __len___3);
  }
  pframe = pframe + 2UL;
  pktlen = pktlen + 2U;
  if ((pmlmeinfo->state & 3U) == 3U) {
    bcn_fixed_size = 12;
    pktlen = (cur_network->IELength - (u32 )bcn_fixed_size) + pktlen;
    __len___4 = (size_t )pktlen;
    __ret___4 = memcpy((void *)pframe, (void const *)(& cur_network->IEs) + (unsigned long )bcn_fixed_size,
                                 __len___4);
    goto _ConstructBeacon;
  } else {
  }
  pframe = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const *)(& cur_network->Ssid.ssid),
                         & pktlen);
  rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  pframe = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const *)(& cur_network->SupportedRates),
                         & pktlen);
  pframe = rtw_set_ie23a(pframe, 3, 1U, (u8 const *)(& cur_network->DSConfig), & pktlen);
  if ((pmlmeinfo->state & 3U) == 1U) {
    ATIMWindow = 0U;
    pframe = rtw_set_ie23a(pframe, 6, 2U, (u8 const *)(& ATIMWindow), & pktlen);
  } else {
  }
  if (rate_len > 8U) {
    pframe = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const *)(& cur_network->SupportedRates) + 8U,
                           & pktlen);
  } else {
  }
  _ConstructBeacon: ;
  if (pktlen + 32U > 512U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: beacon frame too large\n");
    } else {
    }
    return;
  } else {
  }
  *pLength = pktlen;
  return;
}
}
static void ConstructPSPoll(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength )
{
  struct ieee80211_hdr *pwlanhdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;
  u8 *tmp ;
  u8 *tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 164U;
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  pwlanhdr->duration_id = (unsigned int )pmlmeinfo->aid | 49152U;
  __len = 6UL;
  if (__len > 63UL) {
    tmp = get_my_bssid23a(& pmlmeinfo->network);
    __ret = memcpy((void *)(& pwlanhdr->addr1), (void const *)tmp, __len);
  } else {
    tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
    __ret = memcpy((void *)(& pwlanhdr->addr1), (void const *)tmp___0,
                             __len);
  }
  __len___0 = 6UL;
  if (__len___0 > 63UL) {
    tmp___1 = myid(& padapter->eeprompriv);
    __ret___0 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp___1, __len___0);
  } else {
    tmp___2 = myid(& padapter->eeprompriv);
    __ret___0 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp___2,
                                 __len___0);
  }
  *pLength = 16U;
  return;
}
}
static void ConstructNullFunctionData(struct rtw_adapter *padapter , u8 *pframe ,
                                      u32 *pLength , u8 *StaAddr , u8 bQoS , u8 AC ,
                                      u8 bEosp , u8 bForcePowerSave )
{
  struct ieee80211_hdr *pwlanhdr ;
  u32 pktlen ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;
  u8 *tmp ;
  u8 *tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  size_t __len___4 ;
  void *__ret___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  size_t __len___5 ;
  void *__ret___5 ;
  size_t __len___6 ;
  void *__ret___6 ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  size_t __len___7 ;
  void *__ret___7 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  struct ieee80211_qos_hdr *qoshdr ;
  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pwlanhdr->frame_control = 0U;
  pwlanhdr->seq_ctrl = 0U;
  if ((unsigned int )bForcePowerSave != 0U) {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  } else {
  }
  switch ((unsigned int )cur_network->network.ifmode) {
  case 8U: ;
  case 2U:
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  __len = 6UL;
  if (__len > 63UL) {
    tmp = get_my_bssid23a(& pmlmeinfo->network);
    __ret = memcpy((void *)(& pwlanhdr->addr1), (void const *)tmp, __len);
  } else {
    tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
    __ret = memcpy((void *)(& pwlanhdr->addr1), (void const *)tmp___0,
                             __len);
  }
  __len___0 = 6UL;
  if (__len___0 > 63UL) {
    tmp___1 = myid(& padapter->eeprompriv);
    __ret___0 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp___1, __len___0);
  } else {
    tmp___2 = myid(& padapter->eeprompriv);
    __ret___0 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp___2,
                                 __len___0);
  }
  __len___1 = 6UL;
  if (__len___1 > 63UL) {
    __ret___1 = memcpy((void *)(& pwlanhdr->addr3), (void const *)StaAddr, __len___1);
  } else {
    __ret___1 = memcpy((void *)(& pwlanhdr->addr3), (void const *)StaAddr,
                                 __len___1);
  }
  goto ldv_54429;
  case 9U: ;
  case 3U:
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  __len___2 = 6UL;
  if (__len___2 > 63UL) {
    __ret___2 = memcpy((void *)(& pwlanhdr->addr1), (void const *)StaAddr, __len___2);
  } else {
    __ret___2 = memcpy((void *)(& pwlanhdr->addr1), (void const *)StaAddr,
                                 __len___2);
  }
  __len___3 = 6UL;
  if (__len___3 > 63UL) {
    tmp___3 = get_my_bssid23a(& pmlmeinfo->network);
    __ret___3 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp___3, __len___3);
  } else {
    tmp___4 = get_my_bssid23a(& pmlmeinfo->network);
    __ret___3 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp___4,
                                 __len___3);
  }
  __len___4 = 6UL;
  if (__len___4 > 63UL) {
    tmp___5 = myid(& padapter->eeprompriv);
    __ret___4 = memcpy((void *)(& pwlanhdr->addr3), (void const *)tmp___5, __len___4);
  } else {
    tmp___6 = myid(& padapter->eeprompriv);
    __ret___4 = memcpy((void *)(& pwlanhdr->addr3), (void const *)tmp___6,
                                 __len___4);
  }
  goto ldv_54429;
  case 1U: ;
  default:
  __len___5 = 6UL;
  if (__len___5 > 63UL) {
    __ret___5 = memcpy((void *)(& pwlanhdr->addr1), (void const *)StaAddr, __len___5);
  } else {
    __ret___5 = memcpy((void *)(& pwlanhdr->addr1), (void const *)StaAddr,
                                 __len___5);
  }
  __len___6 = 6UL;
  if (__len___6 > 63UL) {
    tmp___7 = myid(& padapter->eeprompriv);
    __ret___6 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp___7, __len___6);
  } else {
    tmp___8 = myid(& padapter->eeprompriv);
    __ret___6 = memcpy((void *)(& pwlanhdr->addr2), (void const *)tmp___8,
                                 __len___6);
  }
  __len___7 = 6UL;
  if (__len___7 > 63UL) {
    tmp___9 = get_my_bssid23a(& pmlmeinfo->network);
    __ret___7 = memcpy((void *)(& pwlanhdr->addr3), (void const *)tmp___9, __len___7);
  } else {
    tmp___10 = get_my_bssid23a(& pmlmeinfo->network);
    __ret___7 = memcpy((void *)(& pwlanhdr->addr3), (void const *)tmp___10,
                                 __len___7);
  }
  goto ldv_54429;
  }
  ldv_54429: ;
  if ((unsigned int )bQoS == 1U) {
    qoshdr = (struct ieee80211_qos_hdr *)pframe;
    qoshdr->frame_control = (__le16 )((unsigned int )qoshdr->frame_control | 200U);
    qoshdr->qos_ctrl = (unsigned int )((unsigned short )AC) & 15U;
    if ((unsigned int )bEosp != 0U) {
      qoshdr->qos_ctrl = (__le16 )((unsigned int )qoshdr->qos_ctrl | 16U);
    } else {
    }
    pktlen = 26U;
  } else {
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 72U);
    pktlen = 24U;
  }
  *pLength = pktlen;
  return;
}
}
static void ConstructProbeRsp(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ,
                              u8 *StaAddr , bool bHideSSID )
{
  struct ieee80211_hdr *pwlanhdr ;
  u8 *mac ;
  u8 *bssid ;
  u32 pktlen ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  mac = myid(& padapter->eeprompriv);
  bssid = (u8 *)(& cur_network->MacAddress);
  pwlanhdr->frame_control = 80U;
  pwlanhdr->seq_ctrl = 0U;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pwlanhdr->addr1), (void const *)StaAddr, __len);
  } else {
    __ret = memcpy((void *)(& pwlanhdr->addr1), (void const *)StaAddr,
                             __len);
  }
  __len___0 = 6UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& pwlanhdr->addr2), (void const *)mac, __len___0);
  } else {
    __ret___0 = memcpy((void *)(& pwlanhdr->addr2), (void const *)mac,
                                 __len___0);
  }
  __len___1 = 6UL;
  if (__len___1 > 63UL) {
    __ret___1 = memcpy((void *)(& pwlanhdr->addr3), (void const *)bssid, __len___1);
  } else {
    __ret___1 = memcpy((void *)(& pwlanhdr->addr3), (void const *)bssid,
                                 __len___1);
  }
  pktlen = 24U;
  pframe = pframe + (unsigned long )pktlen;
  if (cur_network->IELength > 768U) {
    return;
  } else {
  }
  __len___2 = (size_t )cur_network->IELength;
  __ret___2 = memcpy((void *)pframe, (void const *)(& cur_network->IEs),
                               __len___2);
  pframe = pframe + (unsigned long )cur_network->IELength;
  pktlen = cur_network->IELength + pktlen;
  *pLength = pktlen;
  return;
}
}
void CheckFwRsvdPageContent23a(struct rtw_adapter *Adapter )
{
  {
  return;
}
}
static void SetFwRsvdPagePkt(struct rtw_adapter *padapter , bool bDLFinished )
{
  struct hal_data_8723a *pHalData ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 BeaconLength ;
  u32 ProbeRspLength ;
  u32 PSPollLength ;
  u32 NullDataLength ;
  u32 QosNullLength ;
  u32 BTQosNullLength ;
  u8 *ReservedPagePacket ;
  u8 PageNum ;
  u8 PageNeed ;
  u8 TxDescLen ;
  u16 BufIndex ;
  u32 TotalPacketLen ;
  struct rsvdpage_loc RsvdPageLoc ;
  void *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u32 tmp___4 ;
  size_t __len ;
  void *__ret ;
  {
  BeaconLength = 0U;
  ProbeRspLength = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "SetFwRsvdPagePkt");
  } else {
  }
  tmp = kzalloc(1000UL, 208U);
  ReservedPagePacket = (u8 *)tmp;
  if ((unsigned long )ReservedPagePacket == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: alloc ReservedPagePacket fail!\n", "SetFwRsvdPagePkt");
    } else {
    }
    return;
  } else {
  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  TxDescLen = 32U;
  PageNum = 0U;
  BufIndex = 40U;
  ConstructBeacon(padapter, ReservedPagePacket + (unsigned long )BufIndex, & BeaconLength);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + BeaconLength) >> 7)) + ((((u32 )TxDescLen + BeaconLength) & 127U) != 0U ? 1U : 0U);
  if ((unsigned int )PageNeed == 1U) {
    PageNeed = (unsigned int )PageNeed + 1U;
  } else {
  }
  PageNum = (int )PageNum + (int )PageNeed;
  pHalData->FwRsvdPageStartOffset = PageNum;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocPsPoll = PageNum;
  ConstructPSPoll(padapter, ReservedPagePacket + (unsigned long )BufIndex, & PSPollLength);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            PSPollLength, 1, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + PSPollLength) >> 7)) + ((((u32 )TxDescLen + PSPollLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocNullData = PageNum;
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & NullDataLength, tmp___0, 0, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            NullDataLength, 0, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + NullDataLength) >> 7)) + ((((u32 )TxDescLen + NullDataLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocProbeRsp = PageNum;
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
  ConstructProbeRsp(padapter, ReservedPagePacket + (unsigned long )BufIndex, & ProbeRspLength,
                    tmp___1, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            ProbeRspLength, 0, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + ProbeRspLength) >> 7)) + ((((u32 )TxDescLen + ProbeRspLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocQosNull = PageNum;
  tmp___2 = get_my_bssid23a(& pmlmeinfo->network);
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & QosNullLength, tmp___2, 1, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            QosNullLength, 0, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + QosNullLength) >> 7)) + ((((u32 )TxDescLen + QosNullLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocBTQosNull = PageNum;
  tmp___3 = get_my_bssid23a(& pmlmeinfo->network);
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & BTQosNullLength, tmp___3, 1, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            BTQosNullLength, 0, 1);
  TotalPacketLen = (u32 )BufIndex + BTQosNullLength;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->qsel = 16U;
  tmp___4 = TotalPacketLen - 40U;
  pattrib->last_txcmdsz = tmp___4;
  pattrib->pktlen = tmp___4;
  __len = (size_t )TotalPacketLen;
  __ret = memcpy((void *)pmgntframe->buf_addr, (void const *)ReservedPagePacket,
                           __len);
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: Set RSVD page location to Fw\n", "SetFwRsvdPagePkt");
  } else {
  }
  FillH2CCmd(padapter, 3, 5U, (u8 *)(& RsvdPageLoc));
  exit:
  kfree((void const *)ReservedPagePacket);
  return;
}
}
void rtl8723a_set_FwJoinBssReport_cmd(struct rtw_adapter *padapter , u8 mstatus )
{
  struct joinbssrpt_parm JoinBssRptParm ;
  struct hal_data_8723a *pHalData ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool bRecover ;
  u8 v8 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s mstatus(%x)\n", "rtl8723a_set_FwJoinBssReport_cmd",
           (int )mstatus);
  } else {
  }
  if ((unsigned int )mstatus == 1U) {
    bRecover = 0;
    rtl8723au_write16(padapter, 1704U, (int )((unsigned int )pmlmeinfo->aid | 49152U));
    v8 = rtl8723au_read8(padapter, 257U);
    v8 = (u8 )((unsigned int )v8 | 1U);
    rtl8723au_write8(padapter, 257U, (int )v8);
    SetBcnCtrlReg23a(padapter, 16, 8);
    if (((unsigned long )pHalData->RegFwHwTxQCtrl & 64UL) != 0UL) {
      bRecover = 1;
    } else {
    }
    rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl & 191);
    pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
    SetFwRsvdPagePkt(padapter, 0);
    SetBcnCtrlReg23a(padapter, 8, 16);
    if ((int )bRecover) {
      rtl8723au_write8(padapter, 1058U, (int )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U));
      pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
    } else {
    }
    v8 = rtl8723au_read8(padapter, 257U);
    v8 = (unsigned int )v8 & 254U;
    rtl8723au_write8(padapter, 257U, (int )v8);
  } else {
  }
  JoinBssRptParm.OpMode = mstatus;
  FillH2CCmd(padapter, 2, 1U, (u8 *)(& JoinBssRptParm));
  return;
}
}
static void SetFwRsvdPagePkt_BTCoex(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 fakemac[6U] ;
  u32 NullDataLength ;
  u32 BTQosNullLength ;
  u8 *ReservedPagePacket ;
  u8 PageNum ;
  u8 PageNeed ;
  u8 TxDescLen ;
  u16 BufIndex ;
  u32 TotalPacketLen ;
  struct rsvdpage_loc RsvdPageLoc ;
  void *tmp ;
  u32 tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  fakemac[0] = 0U;
  fakemac[1] = 224U;
  fakemac[2] = 76U;
  fakemac[3] = 0U;
  fakemac[4] = 0U;
  fakemac[5] = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +%s\n", "SetFwRsvdPagePkt_BTCoex");
  } else {
  }
  tmp = kzalloc(1024UL, 208U);
  ReservedPagePacket = (u8 *)tmp;
  if ((unsigned long )ReservedPagePacket == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: alloc ReservedPagePacket fail!\n", "SetFwRsvdPagePkt_BTCoex");
    } else {
    }
    return;
  } else {
  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  TxDescLen = 32U;
  PageNum = 0U;
  BufIndex = 40U;
  PageNeed = 3U;
  PageNum = (int )PageNum + (int )PageNeed;
  pHalData->FwRsvdPageStartOffset = PageNum;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocNullData = PageNum;
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & NullDataLength, (u8 *)(& fakemac), 0, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            NullDataLength, 0, 0);
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + NullDataLength) >> 7)) + ((((u32 )TxDescLen + NullDataLength) & 127U) != 0U ? 1U : 0U);
  PageNum = (int )PageNum + (int )PageNeed;
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
  RsvdPageLoc.LocBTQosNull = PageNum;
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & BTQosNullLength, (u8 *)(& fakemac), 1, 0, 0, 0);
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            BTQosNullLength, 0, 1);
  TotalPacketLen = (u32 )BufIndex + BTQosNullLength;
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    goto exit;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->qsel = 16U;
  tmp___0 = TotalPacketLen - 40U;
  pattrib->last_txcmdsz = tmp___0;
  pattrib->pktlen = tmp___0;
  __len = (size_t )TotalPacketLen;
  __ret = memcpy((void *)pmgntframe->buf_addr, (void const *)ReservedPagePacket,
                           __len);
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: Set RSVD page location to Fw\n", "SetFwRsvdPagePkt_BTCoex");
  } else {
  }
  FillH2CCmd(padapter, 3, 5U, (u8 *)(& RsvdPageLoc));
  exit:
  kfree((void const *)ReservedPagePacket);
  return;
}
}
void rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u8 bRecover ;
  {
  bRecover = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +%s\n", "rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd");
  } else {
  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (((unsigned long )pHalData->RegFwHwTxQCtrl & 64UL) != 0UL) {
    bRecover = 1U;
  } else {
  }
  pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
  rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl);
  SetFwRsvdPagePkt_BTCoex(padapter);
  if ((unsigned int )bRecover != 0U) {
    pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
    rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl);
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_1502(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1508(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1510(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1512(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1513(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1514(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1515(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1516(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1517(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1518(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1544(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1552(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1560(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1554(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1550(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1558(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1559(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1555(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1556(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1557(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void rtl8723a_init_dm_priv(struct rtw_adapter *Adapter ) ;
void rtl8723a_deinit_dm_priv(struct rtw_adapter *Adapter ) ;
void rtl8723a_InitHalDm(struct rtw_adapter *Adapter ) ;
static void dm_CheckStatistics(struct rtw_adapter *Adapter )
{
  {
  return;
}
}
static void dm_CheckPbcGPIO(struct rtw_adapter *padapter )
{
  u8 tmp1byte ;
  u8 bPbcPressed ;
  struct pid *tmp ;
  {
  bPbcPressed = 0U;
  if ((unsigned int )padapter->registrypriv.hw_wps_pbc == 0U) {
    return;
  } else {
  }
  tmp1byte = rtl8723au_read8(padapter, 70U);
  tmp1byte = (u8 )((unsigned int )tmp1byte | 4U);
  rtl8723au_write8(padapter, 70U, (int )tmp1byte);
  tmp1byte = (unsigned int )tmp1byte & 251U;
  rtl8723au_write8(padapter, 68U, (int )tmp1byte);
  tmp1byte = rtl8723au_read8(padapter, 70U);
  tmp1byte = (unsigned int )tmp1byte & 251U;
  rtl8723au_write8(padapter, 70U, (int )tmp1byte);
  tmp1byte = rtl8723au_read8(padapter, 68U);
  if ((unsigned int )tmp1byte == 255U) {
    return;
  } else {
  }
  if (((unsigned long )tmp1byte & 4UL) != 0UL) {
    bPbcPressed = 1U;
  } else {
  }
  if ((unsigned int )bPbcPressed != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: CheckPbcGPIO - PBC is pressed\n");
    } else {
    }
    if (padapter->pid[0] == 0) {
      return;
    } else {
    }
    tmp = find_vpid(padapter->pid[0]);
    kill_pid(tmp, 10, 1);
  } else {
  }
  return;
}
}
static void Init_ODM_ComInfo_8723a(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  u8 cut_ver ;
  u8 fab_ver ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pDM_Odm = & pHalData->odmpriv;
  memset((void *)pDM_Odm, 0, 3632UL);
  pDM_Odm->Adapter = Adapter;
  ODM_CmnInfoInit23a(pDM_Odm, 0, 4U);
  ODM_CmnInfoInit23a(pDM_Odm, 2, 2U);
  ODM_CmnInfoInit23a(pDM_Odm, 4, 8U);
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 0U) {
    fab_ver = 1U;
    cut_ver = 1U;
  } else
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) {
    fab_ver = 1U;
    cut_ver = 2U;
  } else {
    fab_ver = 0U;
    cut_ver = 1U;
  }
  ODM_CmnInfoInit23a(pDM_Odm, 6, (u32 )fab_ver);
  ODM_CmnInfoInit23a(pDM_Odm, 5, (u32 )cut_ver);
  ODM_CmnInfoInit23a(pDM_Odm, 3, (unsigned int )pHalData->VersionID.ChipType == 1U);
  ODM_CmnInfoInit23a(pDM_Odm, 8, (u32 )pHalData->BoardType);
  if ((unsigned int )pHalData->BoardType == 1U) {
    ODM_CmnInfoInit23a(pDM_Odm, 9, 1U);
    ODM_CmnInfoInit23a(pDM_Odm, 10, 1U);
  } else {
  }
  ODM_CmnInfoInit23a(pDM_Odm, 12, (u32 )pHalData->CustomerID);
  ODM_CmnInfoInit23a(pDM_Odm, 14, (u32 )Adapter->registrypriv.wifi_spec);
  if ((unsigned int )pHalData->rf_type == 3U) {
    ODM_CmnInfoUpdate23a(pDM_Odm, 7U, 0ULL);
  } else
  if ((unsigned int )pHalData->rf_type == 2U) {
    ODM_CmnInfoUpdate23a(pDM_Odm, 7U, 2ULL);
  } else
  if ((unsigned int )pHalData->rf_type == 0U) {
    ODM_CmnInfoUpdate23a(pDM_Odm, 7U, 1ULL);
  } else {
  }
  return;
}
}
static void Update_ODM_ComInfo_8723a(struct rtw_adapter *Adapter )
{
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrctrlpriv ;
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct dm_priv *pdmpriv ;
  int i ;
  {
  pmlmeext = & Adapter->mlmeextpriv;
  pmlmepriv = & Adapter->mlmepriv;
  pwrctrlpriv = & Adapter->pwrctrlpriv;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pDM_Odm = & pHalData->odmpriv;
  pdmpriv = & pHalData->dmpriv;
  pdmpriv->InitODMFlag = 83951807U;
  ODM_CmnInfoUpdate23a(pDM_Odm, 1U, (u64 )pdmpriv->InitODMFlag);
  ODM23a_CmnInfoHook(pDM_Odm, 17, (void *)(& Adapter->xmitpriv.tx_bytes));
  ODM23a_CmnInfoHook(pDM_Odm, 18, (void *)(& Adapter->recvpriv.rx_bytes));
  ODM23a_CmnInfoHook(pDM_Odm, 19, (void *)(& pmlmeext->cur_wireless_mode));
  ODM23a_CmnInfoHook(pDM_Odm, 21, (void *)(& pHalData->nCur40MhzPrimeSC));
  ODM23a_CmnInfoHook(pDM_Odm, 22, (void *)(& Adapter->securitypriv.dot11PrivacyAlgrthm));
  ODM23a_CmnInfoHook(pDM_Odm, 23, (void *)(& pHalData->CurrentChannelBW));
  ODM23a_CmnInfoHook(pDM_Odm, 24, (void *)(& pHalData->CurrentChannel));
  ODM23a_CmnInfoHook(pDM_Odm, 35, (void *)(& Adapter->net_closed));
  ODM23a_CmnInfoHook(pDM_Odm, 28, (void *)(& pmlmepriv->bScanInProcess));
  ODM23a_CmnInfoHook(pDM_Odm, 29, (void *)(& pwrctrlpriv->bpower_saving));
  i = 0;
  goto ldv_54269;
  ldv_54268:
  ODM_CmnInfoPtrArrayHook23a(pDM_Odm, 51, (int )((u16 )i), (void *)0);
  i = i + 1;
  ldv_54269: ;
  if (i <= 31) {
    goto ldv_54268;
  } else {
  }
  return;
}
}
void rtl8723a_InitHalDm(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;
  u8 i ;
  u8 tmp ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pDM_Odm = & pHalData->odmpriv;
  pdmpriv->DM_Type = 1U;
  pdmpriv->DMFlag = 0U;
  pdmpriv->DMFlag = (u8 )((unsigned int )pdmpriv->DMFlag | 1U);
  pdmpriv->InitDMFlag = pdmpriv->DMFlag;
  Update_ODM_ComInfo_8723a(Adapter);
  ODM23a_DMInit(pDM_Odm);
  i = 0U;
  goto ldv_54279;
  ldv_54278:
  tmp = rtl8723au_read8(Adapter, (u32 )((int )i + 1156));
  pdmpriv->INIDATA_RATE[(int )i] = (unsigned int )tmp & 63U;
  i = (u8 )((int )i + 1);
  ldv_54279: ;
  if ((unsigned int )i <= 31U) {
    goto ldv_54278;
  } else {
  }
  return;
}
}
void rtl8723a_HalDmWatchDog(struct rtw_adapter *Adapter )
{
  bool bFwCurrentInPSMode ;
  bool bFwPSAwake ;
  u8 hw_init_completed ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 tmp ;
  u8 i ;
  u8 tmp___0 ;
  bool tmp___1 ;
  u8 bLinked ;
  int tmp___2 ;
  {
  bFwCurrentInPSMode = 0;
  bFwPSAwake = 1;
  hw_init_completed = 0U;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  hw_init_completed = Adapter->hw_init_completed;
  if ((unsigned int )hw_init_completed == 0U) {
    goto skip_dm;
  } else {
  }
  bFwCurrentInPSMode = (unsigned int )Adapter->pwrctrlpriv.bFwCurrentInPSMode != 0U;
  bFwPSAwake = rtl8723a_get_fwlps_rf_on(Adapter);
  if ((unsigned int )hw_init_completed != 0U && (! bFwCurrentInPSMode && (int )bFwPSAwake)) {
    dm_CheckStatistics(Adapter);
    tmp___1 = check_fwstate(& Adapter->mlmepriv, 8);
    if ((int )tmp___1) {
      tmp = rtl8723au_read8(Adapter, 1156U);
      pdmpriv->INIDATA_RATE[0] = (unsigned int )tmp & 63U;
    } else {
      i = 1U;
      goto ldv_54292;
      ldv_54291:
      tmp___0 = rtl8723au_read8(Adapter, (u32 )((int )i + 1156));
      pdmpriv->INIDATA_RATE[(int )i] = (unsigned int )tmp___0 & 63U;
      i = (u8 )((int )i + 1);
      ldv_54292: ;
      if ((int )i < Adapter->stapriv.asoc_sta_count + 1) {
        goto ldv_54291;
      } else {
      }
    }
  } else {
  }
  if ((unsigned int )hw_init_completed == 1U) {
    bLinked = 0U;
    tmp___2 = rtw_linked_check(Adapter);
    if (tmp___2 != 0) {
      bLinked = 1U;
    } else {
    }
    ODM_CmnInfoUpdate23a(& pHalData->odmpriv, 39U, (u64 )bLinked);
    ODM_DMWatchdog23a(& pHalData->odmpriv);
  } else {
  }
  skip_dm:
  dm_CheckPbcGPIO(Adapter);
  return;
}
}
void rtl8723a_init_dm_priv(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  memset((void *)pdmpriv, 0, 356UL);
  Init_ODM_ComInfo_8723a(Adapter);
  return;
}
}
void rtl8723a_deinit_dm_priv(struct rtw_adapter *Adapter )
{
  {
  return;
}
}
void *ldv_kmem_cache_alloc_1544(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1550(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1552(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1554(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1555(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1556(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1557(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1558(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1559(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1560(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
extern void *kmemdup(void const * , size_t , gfp_t ) ;
void *ldv_kmem_cache_alloc_1586(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
extern int request_firmware(struct firmware const ** , char const * , struct device * ) ;
extern void release_firmware(struct firmware const * ) ;
struct sk_buff *ldv_skb_clone_1594(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1602(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1596(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1592(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1600(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1601(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1597(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1598(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1599(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void hw_var_set_macaddr(struct rtw_adapter *padapter , u8 *val ) ;
__inline static struct device *dvobj_to_dev(struct dvobj_priv *dvobj )
{
  {
  return (& (dvobj->pusbintf)->dev);
}
}
void rtl8723a_BT_wifiassociate_notify(struct rtw_adapter *padapter , u8 action ) ;
void rtl8723a_BT_init_hal_vars(struct rtw_adapter *padapter ) ;
void rtl8723a_fw_c2h_BT_info(struct rtw_adapter *padapter , u8 *tmpBuf , u8 length ) ;
void handle_txrpt_ccx_8723a(struct rtw_adapter *adapter , void *buf ) ;
void rtl8723a_update_txdesc(struct xmit_frame *pxmitframe , u8 *pbuf ) ;
s32 rtl8723a_FirmwareDownload(struct rtw_adapter *padapter ) ;
void rtl8723a_FirmwareSelfReset(struct rtw_adapter *padapter ) ;
void rtl8723a_InitializeFirmwareVars(struct rtw_adapter *padapter ) ;
void rtl8723a_InitAntenna_Selection(struct rtw_adapter *padapter ) ;
void rtl8723a_DeinitAntenna_Selection(struct rtw_adapter *padapter ) ;
void rtl8723a_CheckAntenna_Selection(struct rtw_adapter *padapter ) ;
void rtl8723a_init_default_value(struct rtw_adapter *padapter ) ;
s32 InitLLTTable23a(struct rtw_adapter *padapter , u32 boundary ) ;
s32 CardDisableHWSM(struct rtw_adapter *padapter , u8 resetMCU ) ;
s32 CardDisableWithoutHWSM(struct rtw_adapter *padapter ) ;
u8 GetEEPROMSize8723A(struct rtw_adapter *padapter ) ;
void Hal_InitPGData(struct rtw_adapter *padapter , u8 *PROMContent ) ;
void Hal_EfuseParseIDCode(struct rtw_adapter *padapter , u8 *hwinfo ) ;
void Hal_EfuseParsetxpowerinfo_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                     bool AutoLoadFail ) ;
void Hal_EfuseParseBTCoexistInfo_8723A(struct rtw_adapter *padapter , u8 *hwinfo ,
                                       bool AutoLoadFail ) ;
void Hal_EfuseParseEEPROMVer(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
void rtl8723a_EfuseParseChnlPlan(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
void Hal_EfuseParseCustomerID(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
void Hal_EfuseParseAntennaDiversity(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
void Hal_EfuseParseRateIndicationOption(struct rtw_adapter *padapter , u8 *hwinfo ,
                                        bool AutoLoadFail ) ;
void Hal_EfuseParseXtal_8723A(struct rtw_adapter *pAdapter , u8 *hwinfo , u8 AutoLoadFail ) ;
void Hal_EfuseParseThermalMeter_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                      bool AutoloadFail ) ;
void Hal_InitChannelPlan23a(struct rtw_adapter *padapter ) ;
void rtl8723a_InitBeaconParameters(struct rtw_adapter *padapter ) ;
void rtl8723a_read_chip_version(struct rtw_adapter *padapter ) ;
void rtl8723a_notch_filter(struct rtw_adapter *adapter , bool enable ) ;
int rtl8723au_writeN(struct rtw_adapter *padapter , u32 addr , u32 length , u8 *pdata ) ;
static void _FWDownloadEnable(struct rtw_adapter *padapter , bool enable )
{
  u8 tmp ;
  {
  if ((int )enable) {
    tmp = rtl8723au_read8(padapter, 3U);
    rtl8723au_write8(padapter, 3U, (int )((unsigned int )tmp | 4U));
    tmp = rtl8723au_read8(padapter, 128U);
    rtl8723au_write8(padapter, 128U, (int )((unsigned int )tmp | 1U));
    tmp = rtl8723au_read8(padapter, 130U);
    rtl8723au_write8(padapter, 130U, (int )tmp & 247);
  } else {
    tmp = rtl8723au_read8(padapter, 128U);
    rtl8723au_write8(padapter, 128U, (int )tmp & 254);
    rtl8723au_write8(padapter, 129U, 0);
  }
  return;
}
}
static int _BlockWrite(struct rtw_adapter *padapter , void *buffer , u32 buffSize )
{
  int ret ;
  u32 blockSize_p1 ;
  u32 blockSize_p2 ;
  u32 blockSize_p3 ;
  u32 blockCount_p1 ;
  u32 blockCount_p2 ;
  u32 blockCount_p3 ;
  u32 remainSize_p1 ;
  u32 remainSize_p2 ;
  u8 *bufferPtr ;
  u32 i ;
  u32 offset ;
  {
  ret = 1;
  blockSize_p1 = 4U;
  blockSize_p2 = 8U;
  blockSize_p3 = 1U;
  blockCount_p1 = 0U;
  blockCount_p2 = 0U;
  blockCount_p3 = 0U;
  remainSize_p1 = 0U;
  remainSize_p2 = 0U;
  bufferPtr = (u8 *)buffer;
  i = 0U;
  offset = 0U;
  blockSize_p1 = 254U;
  blockCount_p1 = buffSize / blockSize_p1;
  remainSize_p1 = buffSize % blockSize_p1;
  if (blockCount_p1 != 0U) {
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 6);
      printk("\016_BlockWrite: [P1] buffSize(%d) blockSize_p1(%d) blockCount_p1(%d) remainSize_p1(%d)\n",
             buffSize, blockSize_p1, blockCount_p1, remainSize_p1);
    } else {
    }
  } else {
  }
  i = 0U;
  goto ldv_54296;
  ldv_54295:
  ret = rtl8723au_writeN(padapter, i * blockSize_p1 + 4096U, blockSize_p1, bufferPtr + (unsigned long )(i * blockSize_p1));
  if (ret == 0) {
    goto exit;
  } else {
  }
  i = i + 1U;
  ldv_54296: ;
  if (i < blockCount_p1) {
    goto ldv_54295;
  } else {
  }
  if (remainSize_p1 != 0U) {
    offset = blockCount_p1 * blockSize_p1;
    blockCount_p2 = remainSize_p1 / blockSize_p2;
    remainSize_p2 = remainSize_p1 % blockSize_p2;
    if (blockCount_p2 != 0U) {
      if (GlobalDebugLevel23A > 5U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 6);
        printk("\016_BlockWrite: [P2] buffSize_p2(%d) blockSize_p2(%d) blockCount_p2(%d) remainSize_p2(%d)\n",
               buffSize - offset, blockSize_p2, blockCount_p2, remainSize_p2);
      } else {
      }
    } else {
    }
    i = 0U;
    goto ldv_54299;
    ldv_54298:
    ret = rtl8723au_writeN(padapter, (i * blockSize_p2 + offset) + 4096U, blockSize_p2,
                           bufferPtr + ((unsigned long )offset + (unsigned long )(i * blockSize_p2)));
    if (ret == 0) {
      goto exit;
    } else {
    }
    i = i + 1U;
    ldv_54299: ;
    if (i < blockCount_p2) {
      goto ldv_54298;
    } else {
    }
  } else {
  }
  if (remainSize_p2 != 0U) {
    offset = blockCount_p1 * blockSize_p1 + blockCount_p2 * blockSize_p2;
    blockCount_p3 = remainSize_p2 / blockSize_p3;
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 6);
      printk("\016_BlockWrite: [P3] buffSize_p3(%d) blockSize_p3(%d) blockCount_p3(%d)\n",
             buffSize - offset, blockSize_p3, blockCount_p3);
    } else {
    }
    i = 0U;
    goto ldv_54302;
    ldv_54301:
    ret = rtl8723au_write8(padapter, (offset + i) + 4096U, (int )*(bufferPtr + ((unsigned long )offset + (unsigned long )i)));
    if (ret == 0) {
      goto exit;
    } else {
    }
    i = i + 1U;
    ldv_54302: ;
    if (i < blockCount_p3) {
      goto ldv_54301;
    } else {
    }
  } else {
  }
  exit: ;
  return (ret);
}
}
static int _PageWrite(struct rtw_adapter *padapter , u32 page , void *buffer , u32 size )
{
  u8 value8 ;
  u8 u8Page ;
  u8 tmp ;
  int tmp___0 ;
  {
  u8Page = (unsigned int )((unsigned char )page) & 7U;
  tmp = rtl8723au_read8(padapter, 130U);
  value8 = (u8 )(((int )((signed char )tmp) & -8) | (int )((signed char )u8Page));
  rtl8723au_write8(padapter, 130U, (int )value8);
  tmp___0 = _BlockWrite(padapter, buffer, size);
  return (tmp___0);
}
}
static int _WriteFW(struct rtw_adapter *padapter , void *buffer , u32 size )
{
  int ret ;
  u32 pageNums ;
  u32 remainSize ;
  u32 page ;
  u32 offset ;
  u8 *bufferPtr ;
  {
  ret = 1;
  bufferPtr = (u8 *)buffer;
  pageNums = size / 4096U;
  remainSize = size & 4095U;
  page = 0U;
  goto ldv_54325;
  ldv_54324:
  offset = page * 4096U;
  ret = _PageWrite(padapter, page, (void *)bufferPtr + (unsigned long )offset, 4096U);
  if (ret == 0) {
    goto exit;
  } else {
  }
  page = page + 1U;
  ldv_54325: ;
  if (page < pageNums) {
    goto ldv_54324;
  } else {
  }
  if (remainSize != 0U) {
    offset = pageNums * 4096U;
    page = pageNums;
    ret = _PageWrite(padapter, page, (void *)bufferPtr + (unsigned long )offset, remainSize);
    if (ret == 0) {
      goto exit;
    } else {
    }
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016_WriteFW Done- for Normal chip.\n");
  } else {
  }
  exit: ;
  return (ret);
}
}
static int _FWFreeToGo(struct rtw_adapter *padapter )
{
  u32 counter ;
  u32 value32 ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  counter = 0U;
  ldv_54333:
  value32 = rtl8723au_read32(padapter, 128U);
  if (((unsigned long )value32 & 4UL) != 0UL) {
    goto ldv_54332;
  } else {
  }
  tmp = counter;
  counter = counter + 1U;
  if (tmp <= 999U) {
    goto ldv_54333;
  } else {
  }
  ldv_54332: ;
  if (counter > 999U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
      printk("\016%s: chksum report fail! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo", value32);
    } else {
    }
    return (0);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016%s: Checksum report OK! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo", value32);
  } else {
  }
  value32 = rtl8723au_read32(padapter, 128U);
  value32 = value32 | 2U;
  value32 = value32 & 4294967231U;
  rtl8723au_write32(padapter, 128U, value32);
  counter = 0U;
  ldv_54335:
  value32 = rtl8723au_read32(padapter, 128U);
  if (((unsigned long )value32 & 64UL) != 0UL) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
      printk("\016%s: Polling FW ready success!! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
             value32);
    } else {
    }
    return (1);
  } else {
  }
  __const_udelay(21475UL);
  tmp___0 = counter;
  counter = counter + 1U;
  if (tmp___0 <= 999U) {
    goto ldv_54335;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
    printk("\016%s: Polling FW ready fail!! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
           value32);
  } else {
  }
  return (0);
}
}
void rtl8723a_FirmwareSelfReset(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u8 u1bTmp ;
  u8 Delay ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  Delay = 100U;
  if (((int )((struct hal_data_8723a *)padapter->HalData)->FirmwareSignature & 65520) != 35008 || ((unsigned int )pHalData->FirmwareVersion > 32U && ((unsigned int )pHalData->FirmwareVersion != 33U || (unsigned int )pHalData->FirmwareSubVersion != 0U))) {
    rtl8723au_write8(padapter, 463U, 32);
    u1bTmp = rtl8723au_read8(padapter, 3U);
    goto ldv_54345;
    ldv_54344:
    Delay = (u8 )((int )Delay - 1);
    if ((unsigned int )Delay == 0U) {
      goto ldv_54343;
    } else {
    }
    __const_udelay(214750UL);
    u1bTmp = rtl8723au_read8(padapter, 3U);
    ldv_54345: ;
    if (((unsigned long )u1bTmp & 4UL) != 0UL) {
      goto ldv_54344;
    } else {
    }
    ldv_54343: ;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
      printk("\016-%s: 8051 reset success (%d)\n", "rtl8723a_FirmwareSelfReset", (int )Delay);
    } else {
    }
    if ((unsigned int )Delay == 0U) {
      u1bTmp = rtl8723au_read8(padapter, 3U);
      rtl8723au_write8(padapter, 3U, (int )u1bTmp & 251);
    } else {
    }
  } else {
  }
  return;
}
}
s32 rtl8723a_FirmwareDownload(struct rtw_adapter *padapter )
{
  int rtStatus ;
  u8 writeFW_retry ;
  unsigned long fwdl_start_time ;
  struct hal_data_8723a *pHalData ;
  struct dvobj_priv *dvobj ;
  struct device *device ;
  struct device *tmp ;
  struct rt_8723a_firmware_hdr *pFwHdr ;
  struct firmware const *fw ;
  char *fw_name ;
  u8 *firmware_buf ;
  u8 *buf ;
  int fw_size ;
  int log_version ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  unsigned int tmp___6 ;
  u8 tmp___7 ;
  unsigned int tmp___8 ;
  {
  rtStatus = 1;
  writeFW_retry = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  dvobj = padapter->dvobj;
  tmp = dvobj_to_dev(dvobj);
  device = tmp;
  pFwHdr = (struct rt_8723a_firmware_hdr *)0;
  firmware_buf = (u8 *)0U;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016+%s\n", "rtl8723a_FirmwareDownload");
  } else {
  }
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 0U) {
    fw_name = (char *)"rtlwifi/rtl8723aufw.bin";
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
      printk("\016rtl8723a_FirmwareDownload: R8723FwImageArray_UMC for RTL8723A A CUT\n");
    } else {
    }
  } else
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) {
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
      fw_name = (char *)"rtlwifi/rtl8723aufw_B_NoBT.bin";
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithoutBT for RTL8723A B CUT\n");
      } else {
      }
    } else {
      tmp___0 = rtl8723a_BT_coexist(padapter);
      if ((int )tmp___0) {
        fw_name = (char *)"rtlwifi/rtl8723aufw_B.bin";
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithBT for RTL8723A B CUT\n");
        } else {
        }
      } else {
        fw_name = (char *)"rtlwifi/rtl8723aufw_B_NoBT.bin";
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithout BT for RTL8723A B CUT\n");
        } else {
        }
      }
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
      printk("\016%s: unknow version!\n", "rtl8723a_FirmwareDownload");
    } else {
    }
    rtStatus = 0;
    goto Exit;
  }
  printk("\016rtl8723au: Loading firmware %s\n", fw_name);
  tmp___1 = request_firmware(& fw, (char const *)fw_name, device);
  if (tmp___1 != 0) {
    printk("\vrtl8723au: request_firmware load failed\n");
    rtStatus = 0;
    goto Exit;
  } else {
  }
  if ((unsigned long )fw == (unsigned long )((struct firmware const *)0)) {
    printk("\vrtl8723au: Firmware %s not available\n", fw_name);
    rtStatus = 0;
    goto Exit;
  } else {
  }
  tmp___2 = kmemdup((void const *)fw->data, fw->size, 208U);
  firmware_buf = (u8 *)tmp___2;
  if ((unsigned long )firmware_buf == (unsigned long )((u8 *)0U)) {
    rtStatus = 0;
    goto Exit;
  } else {
  }
  buf = firmware_buf;
  fw_size = (int )fw->size;
  release_firmware(fw);
  pFwHdr = (struct rt_8723a_firmware_hdr *)firmware_buf;
  pHalData->FirmwareVersion = pFwHdr->Version;
  pHalData->FirmwareSubVersion = (u16 )pFwHdr->Subversion;
  pHalData->FirmwareSignature = pFwHdr->Signature;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: fw_ver =%d fw_subver =%d sig = 0x%x\n", "rtl8723a_FirmwareDownload",
           (int )pHalData->FirmwareVersion, (int )pHalData->FirmwareSubVersion, (int )pHalData->FirmwareSignature);
  } else {
  }
  tmp___3 = log_version;
  log_version = log_version + 1;
  if (tmp___3 == 0) {
    printk("\016%sFirmware Version %d, SubVersion %d, Signature 0x%x\n", (char *)"RTL8723AU: ",
           (int )pHalData->FirmwareVersion, (int )pHalData->FirmwareSubVersion, (int )pHalData->FirmwareSignature);
  } else {
  }
  if ((((int )pFwHdr->Signature & 65520) == 37568 || ((int )pFwHdr->Signature & 65520) == 35008) || ((int )pFwHdr->Signature & 65520) == 8960) {
    buf = buf + 32UL;
    fw_size = fw_size + -32;
  } else {
  }
  tmp___4 = rtl8723au_read8(padapter, 128U);
  if ((int )((signed char )tmp___4) < 0) {
    rtl8723a_FirmwareSelfReset(padapter);
    rtl8723au_write8(padapter, 128U, 0);
  } else {
  }
  _FWDownloadEnable(padapter, 1);
  fwdl_start_time = jiffies;
  ldv_54366:
  tmp___5 = rtl8723au_read8(padapter, 128U);
  rtl8723au_write8(padapter, 128U, (int )((unsigned int )tmp___5 | 4U));
  rtStatus = _WriteFW(padapter, (void *)buf, (u32 )fw_size);
  if (rtStatus == 1) {
    goto ldv_54365;
  } else {
    tmp___6 = jiffies_to_msecs((unsigned long )jiffies - fwdl_start_time);
    if (tmp___6 > 500U) {
      tmp___7 = writeFW_retry;
      writeFW_retry = (u8 )((int )writeFW_retry + 1);
      if ((unsigned int )tmp___7 > 2U) {
        goto ldv_54365;
      } else {
      }
    } else {
    }
  }
  if (GlobalDebugLevel23A > 3U) {
    tmp___8 = jiffies_to_msecs((unsigned long )jiffies - fwdl_start_time);
    printk("\016RTL8723AU: %s writeFW_retry:%u, time after fwdl_start_time:%ums\n",
           "rtl8723a_FirmwareDownload", (int )writeFW_retry, tmp___8);
  } else {
  }
  goto ldv_54366;
  ldv_54365:
  _FWDownloadEnable(padapter, 0);
  if (rtStatus != 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: DL Firmware failed!\n");
    } else {
    }
    goto Exit;
  } else {
  }
  rtStatus = _FWFreeToGo(padapter);
  if (rtStatus != 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
      printk("\016DL Firmware failed!\n");
    } else {
    }
    goto Exit;
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016Firmware is ready to run!\n");
  } else {
  }
  Exit:
  kfree((void const *)firmware_buf);
  return (rtStatus);
}
}
void rtl8723a_InitializeFirmwareVars(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  padapter->pwrctrlpriv.bFwCurrentInPSMode = 0U;
  pHalData->LastHMEBoxNum = 0U;
  return;
}
}
static u8 hal_EfuseSwitchToBank(struct rtw_adapter *padapter , u8 bank )
{
  u8 bRet ;
  u32 value32 ;
  {
  bRet = 0U;
  value32 = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: Efuse switch bank to %d\n", "hal_EfuseSwitchToBank",
           (int )bank);
  } else {
  }
  value32 = rtl8723au_read32(padapter, 52U);
  bRet = 1U;
  switch ((int )bank) {
  case 0:
  value32 = value32 & 4294966527U;
  goto ldv_54379;
  case 1:
  value32 = (value32 & 4294966527U) | 256U;
  goto ldv_54379;
  case 2:
  value32 = (value32 & 4294966527U) | 512U;
  goto ldv_54379;
  case 3:
  value32 = value32 | 768U;
  goto ldv_54379;
  default:
  value32 = value32 & 4294966527U;
  bRet = 0U;
  goto ldv_54379;
  }
  ldv_54379:
  rtl8723au_write32(padapter, 52U, value32);
  return (bRet);
}
}
static void hal_ReadEFuse_WiFi(struct rtw_adapter *padapter , u16 _offset , u16 _size_byte ,
                               u8 *pbuf )
{
  u8 *efuseTbl ;
  u16 eFuse_Addr ;
  u8 offset ;
  u8 wden ;
  u8 efuseHeader ;
  u8 efuseExtHdr ;
  u8 efuseData ;
  u16 i ;
  u16 total ;
  u16 used ;
  struct hal_data_8723a *pHalData ;
  void *tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 addr ;
  u16 tmp___2 ;
  u16 tmp___3 ;
  u8 tmp___4 ;
  {
  efuseTbl = (u8 *)0U;
  eFuse_Addr = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((int )_offset + (int )_size_byte > 256) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: Invalid offset(%#x) with read bytes(%#x)!!\n", "hal_ReadEFuse_WiFi",
             (int )_offset, (int )_size_byte);
    } else {
    }
    return;
  } else {
  }
  tmp = kmalloc(256UL, 208U);
  efuseTbl = (u8 *)tmp;
  if ((unsigned long )efuseTbl == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: alloc efuseTbl fail!\n", "hal_ReadEFuse_WiFi");
    } else {
    }
    return;
  } else {
  }
  memset((void *)efuseTbl, 255, 256UL);
  hal_EfuseSwitchToBank(padapter, 0);
  goto ldv_54403;
  ldv_54408:
  tmp___0 = eFuse_Addr;
  eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
  ReadEFuseByte23a(padapter, (int )tmp___0, & efuseHeader);
  if ((unsigned int )efuseHeader == 255U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: data end at address =%#x\n", "hal_ReadEFuse_WiFi",
             (int )eFuse_Addr);
    } else {
    }
    goto ldv_54402;
  } else {
  }
  if (((int )efuseHeader & 31) == 15) {
    offset = (int )efuseHeader >> 5;
    tmp___1 = eFuse_Addr;
    eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
    ReadEFuseByte23a(padapter, (int )tmp___1, & efuseExtHdr);
    if (((int )efuseExtHdr & 15) == 15) {
      goto ldv_54403;
    } else {
    }
    offset = (u8 )((int )((signed char )(((int )efuseExtHdr & 240) >> 1)) | (int )((signed char )offset));
    wden = (unsigned int )efuseExtHdr & 15U;
  } else {
    offset = (u8 )((int )efuseHeader >> 4);
    wden = (unsigned int )efuseHeader & 15U;
  }
  if ((unsigned int )offset <= 31U) {
    addr = (unsigned int )((u16 )offset) * 8U;
    i = 0U;
    goto ldv_54406;
    ldv_54405: ;
    if ((((int )wden >> (int )i) & 1) == 0) {
      tmp___2 = eFuse_Addr;
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___2, & efuseData);
      *(efuseTbl + (unsigned long )addr) = efuseData;
      tmp___3 = eFuse_Addr;
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuseData);
      *(efuseTbl + ((unsigned long )addr + 1UL)) = efuseData;
    } else {
    }
    addr = (unsigned int )addr + 2U;
    i = (u16 )((int )i + 1);
    ldv_54406: ;
    if ((unsigned int )i <= 3U) {
      goto ldv_54405;
    } else {
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: offset(%d) is illegal!!\n", "hal_ReadEFuse_WiFi",
             (int )offset);
    } else {
    }
    tmp___4 = Efuse_CalculateWordCnts23a((int )wden);
    eFuse_Addr = (unsigned int )((u16 )tmp___4) * 2U + (unsigned int )eFuse_Addr;
  }
  ldv_54403: ;
  if ((unsigned int )eFuse_Addr <= 511U) {
    goto ldv_54408;
  } else {
  }
  ldv_54402:
  i = 0U;
  goto ldv_54410;
  ldv_54409:
  *(pbuf + (unsigned long )i) = *(efuseTbl + (unsigned long )((int )_offset + (int )i));
  i = (u16 )((int )i + 1);
  ldv_54410: ;
  if ((int )i < (int )_size_byte) {
    goto ldv_54409;
  } else {
  }
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& total));
  used = (unsigned int )eFuse_Addr + 65535U;
  pHalData->EfuseUsedBytes = used;
  kfree((void const *)efuseTbl);
  return;
}
}
static void hal_ReadEFuse_BT(struct rtw_adapter *padapter , u16 _offset , u16 _size_byte ,
                             u8 *pbuf )
{
  u8 *efuseTbl ;
  u8 bank ;
  u16 eFuse_Addr ;
  u8 efuseHeader ;
  u8 efuseExtHdr ;
  u8 efuseData ;
  u8 offset ;
  u8 wden ;
  u16 i ;
  u16 total ;
  u16 used ;
  struct hal_data_8723a *pHalData ;
  void *tmp ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 addr ;
  u16 tmp___3 ;
  u16 tmp___4 ;
  u8 tmp___5 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((int )_offset + (int )_size_byte > 1024) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: Invalid offset(%#x) with read bytes(%#x)!!\n", "hal_ReadEFuse_BT",
             (int )_offset, (int )_size_byte);
    } else {
    }
    return;
  } else {
  }
  tmp = kmalloc(1024UL, 208U);
  efuseTbl = (u8 *)tmp;
  if ((unsigned long )efuseTbl == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: efuseTbl malloc fail!\n", "hal_ReadEFuse_BT");
    } else {
    }
    return;
  } else {
  }
  memset((void *)efuseTbl, 255, 1024UL);
  EFUSE_GetEfuseDefinition23a(padapter, 1, 2, (void *)(& total));
  bank = 1U;
  goto ldv_54441;
  ldv_54440:
  tmp___0 = hal_EfuseSwitchToBank(padapter, (int )bank);
  if ((unsigned int )tmp___0 == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: hal_EfuseSwitchToBank Fail!!\n", "hal_ReadEFuse_BT");
    } else {
    }
    goto exit;
  } else {
  }
  eFuse_Addr = 0U;
  goto ldv_54433;
  ldv_54438:
  tmp___1 = eFuse_Addr;
  eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
  ReadEFuseByte23a(padapter, (int )tmp___1, & efuseHeader);
  if ((unsigned int )efuseHeader == 255U) {
    goto ldv_54432;
  } else {
  }
  if (((int )efuseHeader & 31) == 15) {
    offset = (int )efuseHeader >> 5;
    tmp___2 = eFuse_Addr;
    eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
    ReadEFuseByte23a(padapter, (int )tmp___2, & efuseExtHdr);
    if (((int )efuseExtHdr & 15) == 15) {
      goto ldv_54433;
    } else {
    }
    offset = (u8 )((int )((signed char )(((int )efuseExtHdr & 240) >> 1)) | (int )((signed char )offset));
    wden = (unsigned int )efuseExtHdr & 15U;
  } else {
    offset = (u8 )((int )efuseHeader >> 4);
    wden = (unsigned int )efuseHeader & 15U;
  }
  if ((int )((signed char )offset) >= 0) {
    addr = (unsigned int )((u16 )offset) * 8U;
    i = 0U;
    goto ldv_54436;
    ldv_54435: ;
    if ((((int )wden >> (int )i) & 1) == 0) {
      tmp___3 = eFuse_Addr;
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuseData);
      *(efuseTbl + (unsigned long )addr) = efuseData;
      tmp___4 = eFuse_Addr;
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___4, & efuseData);
      *(efuseTbl + ((unsigned long )addr + 1UL)) = efuseData;
    } else {
    }
    addr = (unsigned int )addr + 2U;
    i = (u16 )((int )i + 1);
    ldv_54436: ;
    if ((unsigned int )i <= 3U) {
      goto ldv_54435;
    } else {
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: offset(%d) is illegal!!\n", "hal_ReadEFuse_BT",
             (int )offset);
    } else {
    }
    tmp___5 = Efuse_CalculateWordCnts23a((int )wden);
    eFuse_Addr = (unsigned int )((u16 )tmp___5) * 2U + (unsigned int )eFuse_Addr;
  }
  ldv_54433: ;
  if ((unsigned int )eFuse_Addr <= 511U) {
    goto ldv_54438;
  } else {
  }
  ldv_54432: ;
  if ((int )eFuse_Addr + -1 < (int )total) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: bank(%d) data end at %#x\n", "hal_ReadEFuse_BT",
             (int )bank, (int )eFuse_Addr + -1);
    } else {
    }
    goto ldv_54439;
  } else {
  }
  bank = (u8 )((int )bank + 1);
  ldv_54441: ;
  if ((unsigned int )bank <= 3U) {
    goto ldv_54440;
  } else {
  }
  ldv_54439:
  hal_EfuseSwitchToBank(padapter, 0);
  i = 0U;
  goto ldv_54443;
  ldv_54442:
  *(pbuf + (unsigned long )i) = *(efuseTbl + (unsigned long )((int )_offset + (int )i));
  i = (u16 )((int )i + 1);
  ldv_54443: ;
  if ((int )i < (int )_size_byte) {
    goto ldv_54442;
  } else {
  }
  EFUSE_GetEfuseDefinition23a(padapter, 1, 3, (void *)(& total));
  used = ((unsigned int )((u16 )((int )bank + -1)) * 512U + (unsigned int )eFuse_Addr) + 65535U;
  pHalData->BTEfuseUsedBytes = used;
  exit:
  kfree((void const *)efuseTbl);
  return;
}
}
void rtl8723a_readefuse(struct rtw_adapter *padapter , u8 efuseType , u16 _offset ,
                        u16 _size_byte , u8 *pbuf )
{
  {
  if ((unsigned int )efuseType == 0U) {
    hal_ReadEFuse_WiFi(padapter, (int )_offset, (int )_size_byte, pbuf);
  } else {
    hal_ReadEFuse_BT(padapter, (int )_offset, (int )_size_byte, pbuf);
  }
  return;
}
}
u16 rtl8723a_EfuseGetCurrentSize_WiFi(struct rtw_adapter *padapter )
{
  u16 efuse_addr ;
  u8 hoffset ;
  u8 hworden ;
  u8 efuse_data ;
  u8 word_cnts ;
  struct hal_data_8723a *pHalData ;
  int tmp ;
  {
  efuse_addr = 0U;
  hoffset = 0U;
  hworden = 0U;
  word_cnts = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  efuse_addr = pHalData->EfuseUsedBytes;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: start_efuse_addr = 0x%X\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
           (int )efuse_addr);
  } else {
  }
  hal_EfuseSwitchToBank(padapter, 0);
  goto ldv_54463;
  ldv_54464:
  tmp = efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: efuse_OneByteRead23a Fail! addr = 0x%X !!\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
             (int )efuse_addr);
    } else {
    }
    goto ldv_54462;
  } else {
  }
  if ((unsigned int )efuse_data == 255U) {
    goto ldv_54462;
  } else {
  }
  if (((int )efuse_data & 31) == 15) {
    hoffset = (int )efuse_data >> 5;
    efuse_addr = (u16 )((int )efuse_addr + 1);
    efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
    if (((int )efuse_data & 15) == 15) {
      goto ldv_54463;
    } else {
    }
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
    hworden = (unsigned int )efuse_data & 15U;
  } else {
    hoffset = (u8 )((int )efuse_data >> 4);
    hworden = (unsigned int )efuse_data & 15U;
  }
  word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
  efuse_addr = ((unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr) + 1U;
  ldv_54463: ;
  if ((unsigned int )efuse_addr <= 511U) {
    goto ldv_54464;
  } else {
  }
  ldv_54462:
  pHalData->EfuseUsedBytes = efuse_addr;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: CurrentSize =%d\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
           (int )efuse_addr);
  } else {
  }
  return (efuse_addr);
}
}
u16 rtl8723a_EfuseGetCurrentSize_BT(struct rtw_adapter *padapter )
{
  u16 btusedbytes ;
  u16 efuse_addr ;
  u8 bank ;
  u8 startBank ;
  u8 hoffset ;
  u8 hworden ;
  u8 efuse_data ;
  u8 word_cnts ;
  u16 retU2 ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  int tmp___0 ;
  {
  hoffset = 0U;
  hworden = 0U;
  word_cnts = 0U;
  retU2 = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btusedbytes = pHalData->BTEfuseUsedBytes;
  efuse_addr = (unsigned int )btusedbytes & 511U;
  startBank = (unsigned int )((unsigned char )((unsigned int )btusedbytes / 512U)) + 1U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: start from bank =%d addr = 0x%X\n", "rtl8723a_EfuseGetCurrentSize_BT",
           (int )startBank, (int )efuse_addr);
  } else {
  }
  EFUSE_GetEfuseDefinition23a(padapter, 1, 2, (void *)(& retU2));
  bank = startBank;
  goto ldv_54484;
  ldv_54483:
  tmp = hal_EfuseSwitchToBank(padapter, (int )bank);
  if ((unsigned int )tmp == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: switch bank(%d) Fail!!\n", "rtl8723a_EfuseGetCurrentSize_BT",
             (int )bank);
    } else {
    }
    bank = 4U;
    goto ldv_54479;
  } else {
  }
  if ((int )bank != (int )startBank) {
    efuse_addr = 0U;
  } else {
  }
  goto ldv_54481;
  ldv_54482:
  tmp___0 = efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
  if (tmp___0 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \v%s: efuse_OneByteRead23a Fail! addr = 0x%X !!\n", "rtl8723a_EfuseGetCurrentSize_BT",
             (int )efuse_addr);
    } else {
    }
    bank = 4U;
    goto ldv_54480;
  } else {
  }
  if ((unsigned int )efuse_data == 255U) {
    goto ldv_54480;
  } else {
  }
  if (((int )efuse_data & 31) == 15) {
    hoffset = (int )efuse_data >> 5;
    efuse_addr = (u16 )((int )efuse_addr + 1);
    efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
    if (((int )efuse_data & 15) == 15) {
      efuse_addr = (u16 )((int )efuse_addr + 1);
      goto ldv_54481;
    } else {
    }
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
    hworden = (unsigned int )efuse_data & 15U;
  } else {
    hoffset = (u8 )((int )efuse_data >> 4);
    hworden = (unsigned int )efuse_data & 15U;
  }
  word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
  efuse_addr = ((unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr) + 1U;
  ldv_54481: ;
  if ((unsigned int )efuse_addr <= 511U) {
    goto ldv_54482;
  } else {
  }
  ldv_54480: ;
  if ((int )efuse_addr < (int )retU2) {
    goto ldv_54479;
  } else {
  }
  bank = (u8 )((int )bank + 1);
  ldv_54484: ;
  if ((unsigned int )bank <= 3U) {
    goto ldv_54483;
  } else {
  }
  ldv_54479:
  retU2 = (unsigned int )((u16 )((int )bank + -1)) * 512U + (unsigned int )efuse_addr;
  pHalData->BTEfuseUsedBytes = retU2;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: CurrentSize =%d\n", "rtl8723a_EfuseGetCurrentSize_BT",
           (int )retU2);
  } else {
  }
  return (retU2);
}
}
bool rtl8723a_EfusePgPacketRead(struct rtw_adapter *padapter , u8 offset , u8 *data )
{
  u8 efuse_data ;
  u8 word_cnts ;
  u16 efuse_addr ;
  u8 hoffset ;
  u8 hworden ;
  u8 i ;
  u8 max_section ;
  s32 ret ;
  u16 tmp ;
  int tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 tmp___3 ;
  {
  word_cnts = 0U;
  efuse_addr = 0U;
  hoffset = 0U;
  hworden = 0U;
  max_section = 0U;
  if ((unsigned long )data == (unsigned long )((u8 *)0U)) {
    return (0);
  } else {
  }
  EFUSE_GetEfuseDefinition23a(padapter, 0, 0, (void *)(& max_section));
  if ((int )offset > (int )max_section) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s: Packet offset(%d) is illegal(>%d)!\n", "rtl8723a_EfusePgPacketRead",
             (int )offset, (int )max_section);
    } else {
    }
    return (0);
  } else {
  }
  memset((void *)data, 255, 8UL);
  ret = 1;
  goto ldv_54500;
  ldv_54504:
  tmp = efuse_addr;
  efuse_addr = (u16 )((int )efuse_addr + 1);
  tmp___0 = efuse_OneByteRead23a(padapter, (int )tmp, & efuse_data);
  if (tmp___0 == 0) {
    ret = 0;
    goto ldv_54499;
  } else {
  }
  if ((unsigned int )efuse_data == 255U) {
    goto ldv_54499;
  } else {
  }
  if (((int )efuse_data & 31) == 15) {
    hoffset = (int )efuse_data >> 5;
    tmp___1 = efuse_addr;
    efuse_addr = (u16 )((int )efuse_addr + 1);
    efuse_OneByteRead23a(padapter, (int )tmp___1, & efuse_data);
    if (((int )efuse_data & 15) == 15) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s: Error!! All words disabled!\n", "rtl8723a_EfusePgPacketRead");
      } else {
      }
      goto ldv_54500;
    } else {
    }
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
    hworden = (unsigned int )efuse_data & 15U;
  } else {
    hoffset = (u8 )((int )efuse_data >> 4);
    hworden = (unsigned int )efuse_data & 15U;
  }
  if ((int )hoffset == (int )offset) {
    i = 0U;
    goto ldv_54502;
    ldv_54501: ;
    if ((((int )hworden >> (int )i) & 1) == 0) {
      tmp___2 = efuse_addr;
      efuse_addr = (u16 )((int )efuse_addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___2, & efuse_data);
      *(data + (unsigned long )((int )i * 2)) = efuse_data;
      tmp___3 = efuse_addr;
      efuse_addr = (u16 )((int )efuse_addr + 1);
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuse_data);
      *(data + ((unsigned long )((int )i * 2) + 1UL)) = efuse_data;
    } else {
    }
    i = (u8 )((int )i + 1);
    ldv_54502: ;
    if ((unsigned int )i <= 3U) {
      goto ldv_54501;
    } else {
    }
  } else {
    word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
    efuse_addr = (unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr;
  }
  ldv_54500: ;
  if ((unsigned int )efuse_addr <= 511U) {
    goto ldv_54504;
  } else {
  }
  ldv_54499: ;
  return (ret != 0);
}
}
void rtl8723a_read_chip_version(struct rtw_adapter *padapter )
{
  u32 value32 ;
  struct hal_version ChipVersion ;
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  value32 = rtl8723au_read32(padapter, 240U);
  ChipVersion.ICType = 4;
  ChipVersion.ChipType = ((unsigned long )value32 & 8388608UL) == 0UL;
  ChipVersion.RFType = 0;
  ChipVersion.VendorType = ((unsigned long )value32 & 524288UL) != 0UL;
  ChipVersion.CUTVersion = (enum hal_cut_version )((value32 & 61440U) >> 12);
  pHalData->RegulatorMode = ((unsigned long )value32 & 16777216UL) != 0UL;
  value32 = rtl8723au_read32(padapter, 244U);
  ChipVersion.ROMVer = (u8 )(((unsigned long )value32 & 4026531840UL) >> 20);
  pHalData->MultiFunc = 0;
  value32 = rtl8723au_read32(padapter, 104U);
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 4UL) != 0UL ? 1U : 0U));
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 262144UL) != 0UL ? 2U : 0U));
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 4194304UL) != 0UL ? 4U : 0U));
  pHalData->PolarityCtl = ((unsigned long )value32 & 2UL) != 0UL;
  dump_chip_info23a(ChipVersion);
  pHalData->VersionID = ChipVersion;
  if ((unsigned int )ChipVersion.RFType == 1U) {
    pHalData->rf_type = 0U;
  } else
  if ((unsigned int )ChipVersion.RFType == 2U) {
    pHalData->rf_type = 2U;
  } else {
    pHalData->rf_type = 3U;
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: RF_Type is %x!!\n", (int )pHalData->rf_type);
  } else {
  }
  return;
}
}
void SetBcnCtrlReg23a(struct rtw_adapter *padapter , u8 SetBits , u8 ClearBits )
{
  struct hal_data_8723a *pHalData ;
  u32 addr ;
  u8 *pRegBcnCtrlVal ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pRegBcnCtrlVal = (u8 *)(& pHalData->RegBcnCtrlVal);
  addr = 1360U;
  *pRegBcnCtrlVal = rtl8723au_read8(padapter, addr);
  *pRegBcnCtrlVal = (u8 )((int )*pRegBcnCtrlVal | (int )SetBits);
  *pRegBcnCtrlVal = (u8 )((int )((signed char )*pRegBcnCtrlVal) & ~ ((int )((signed char )ClearBits)));
  rtl8723au_write8(padapter, addr, (int )*pRegBcnCtrlVal);
  return;
}
}
void rtl8723a_InitBeaconParameters(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  int tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  rtl8723au_write16(padapter, 1360U, 4112);
  pHalData->RegBcnCtrlVal = 4112U;
  rtl8723au_write16(padapter, 1344U, 25604);
  tmp = check_fwstate(& padapter->mlmepriv, 8);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    rtl8723au_write8(padapter, 1368U, 5);
  } else {
  }
  rtl8723au_write8(padapter, 1369U, 2);
  rtl8723au_write16(padapter, 1296U, 26127);
  return;
}
}
static void ResumeTxBeacon(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016+ResumeTxBeacon\n");
  } else {
  }
  pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
  rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl);
  rtl8723au_write8(padapter, 1345U, 255);
  pHalData->RegReg542 = (u8 )((unsigned int )pHalData->RegReg542 | 1U);
  rtl8723au_write8(padapter, 1346U, (int )pHalData->RegReg542);
  return;
}
}
static void StopTxBeacon(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016+StopTxBeacon\n");
  } else {
  }
  pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
  rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl);
  rtl8723au_write8(padapter, 1345U, 100);
  pHalData->RegReg542 = (unsigned int )pHalData->RegReg542 & 254U;
  rtl8723au_write8(padapter, 1346U, (int )pHalData->RegReg542);
  CheckFwRsvdPageContent23a(padapter);
  return;
}
}
static void _BeaconFunctionEnable(struct rtw_adapter *padapter , u8 Enable , u8 Linked )
{
  {
  SetBcnCtrlReg23a(padapter, 26, 0);
  rtl8723au_write8(padapter, 1317U, 111);
  return;
}
}
void rtl8723a_SetBeaconRelatedRegisters(struct rtw_adapter *padapter )
{
  u32 value32 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  rtl8723au_write16(padapter, 1370U, 2);
  rtl8723au_write16(padapter, 1364U, (int )pmlmeinfo->bcn_interval);
  rtl8723a_InitBeaconParameters(padapter);
  rtl8723au_write8(padapter, 1307U, 9);
  value32 = rtl8723au_read32(padapter, 1540U);
  value32 = value32 & 4294967294U;
  rtl8723au_write32(padapter, 1540U, value32);
  value32 = value32 | 1U;
  rtl8723au_write32(padapter, 1540U, value32);
  tmp = check_fwstate(& padapter->mlmepriv, 112);
  if ((int )tmp) {
    rtl8723au_write8(padapter, 1374U, 80);
    rtl8723au_write8(padapter, 1375U, 80);
  } else {
  }
  _BeaconFunctionEnable(padapter, 1, 1);
  ResumeTxBeacon(padapter);
  SetBcnCtrlReg23a(padapter, 2, 0);
  return;
}
}
void rtl8723a_SetHalODMVar(struct rtw_adapter *Adapter , enum hal_odm_variable eVariable ,
                           void *pValue1 , bool bSet )
{
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *podmpriv ;
  struct sta_info *psta ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  podmpriv = & pHalData->odmpriv;
  switch ((unsigned int )eVariable) {
  case 0U:
  psta = (struct sta_info *)pValue1;
  if ((int )bSet) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Set STA_(%d) info\n", psta->mac_id);
    } else {
    }
    ODM_CmnInfoPtrArrayHook23a(podmpriv, 51, (int )((u16 )psta->mac_id), (void *)psta);
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Clean STA_(%d) info\n", psta->mac_id);
    } else {
    }
    ODM_CmnInfoPtrArrayHook23a(podmpriv, 51, (int )((u16 )psta->mac_id), (void *)0);
  }
  goto ldv_54552;
  case 1U:
  ODM_CmnInfoUpdate23a(podmpriv, 37U, (u64 )bSet);
  goto ldv_54552;
  case 2U:
  ODM_CmnInfoUpdate23a(podmpriv, 38U, (u64 )bSet);
  goto ldv_54552;
  default: ;
  goto ldv_54552;
  }
  ldv_54552: ;
  return;
}
}
void rtl8723a_notch_filter(struct rtw_adapter *adapter , bool enable )
{
  u8 tmp ;
  u8 tmp___0 ;
  {
  if ((int )enable) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Enable notch filter\n");
    } else {
    }
    tmp = rtl8723au_read8(adapter, 3137U);
    rtl8723au_write8(adapter, 3137U, (int )((unsigned int )tmp | 2U));
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Disable notch filter\n");
    } else {
    }
    tmp___0 = rtl8723au_read8(adapter, 3137U);
    rtl8723au_write8(adapter, 3137U, (int )tmp___0 & 253);
  }
  return;
}
}
bool c2h_id_filter_ccx_8723a(u8 id )
{
  bool ret ;
  {
  ret = 0;
  if ((unsigned int )id == 3U) {
    ret = 1;
  } else {
  }
  return (ret);
}
}
int c2h_handler_8723a(struct rtw_adapter *padapter , struct c2h_evt_hdr *c2h_evt )
{
  int ret ;
  u8 i ;
  {
  ret = 1;
  i = 0U;
  if ((unsigned long )c2h_evt == (unsigned long )((struct c2h_evt_hdr *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s c2h_evt is NULL\n", "c2h_handler_8723a");
    } else {
    }
    ret = 0;
    goto exit;
  } else {
  }
  switch ((int )c2h_evt->id) {
  case 0: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016C2HCommandHandler: %s\n", (u8 *)(& c2h_evt->payload));
  } else {
  }
  goto ldv_54573;
  case 3:
  handle_txrpt_ccx_8723a(padapter, (void *)(& c2h_evt->payload));
  goto ldv_54573;
  case 6: ;
  goto ldv_54573;
  case 10: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016[BT], C2H_HW_INFO_EXCH\n");
  } else {
  }
  i = 0U;
  goto ldv_54578;
  ldv_54577: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016[BT], tmpBuf[%d]= 0x%x\n", (int )i, (int )c2h_evt->payload[(int )i]);
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54578: ;
  if ((int )i < (int )c2h_evt->plen) {
    goto ldv_54577;
  } else {
  }
  goto ldv_54573;
  case 11: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016[BT], C2H_H2C_TEST\n");
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016[BT], tmpBuf[0]/[1]/[2]/[3]/[4]= 0x%x/ 0x%x/ 0x%x/ 0x%x/ 0x%x\n",
           (int )c2h_evt->payload[0], (int )c2h_evt->payload[1], (int )c2h_evt->payload[2],
           (int )c2h_evt->payload[3], (int )c2h_evt->payload[4]);
  } else {
  }
  goto ldv_54573;
  case 12: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s ,  Got  C2H_BT_INFO \n", "c2h_handler_8723a");
  } else {
  }
  rtl8723a_fw_c2h_BT_info(padapter, (u8 *)(& c2h_evt->payload), (int )c2h_evt->plen);
  goto ldv_54573;
  default:
  ret = 0;
  goto ldv_54573;
  }
  ldv_54573: ;
  exit: ;
  return (ret);
}
}
void rtl8723a_InitAntenna_Selection(struct rtw_adapter *padapter )
{
  u8 val ;
  {
  val = rtl8723au_read8(padapter, 78U);
  val = (u8 )((unsigned int )val | 128U);
  rtl8723au_write8(padapter, 78U, (int )val);
  return;
}
}
void rtl8723a_CheckAntenna_Selection(struct rtw_adapter *padapter )
{
  u8 val ;
  {
  val = rtl8723au_read8(padapter, 78U);
  if ((int )((signed char )val) >= 0) {
    val = (u8 )((unsigned int )val | 128U);
    rtl8723au_write8(padapter, 78U, (int )val);
  } else {
  }
  return;
}
}
void rtl8723a_DeinitAntenna_Selection(struct rtw_adapter *padapter )
{
  u8 val ;
  {
  val = rtl8723au_read8(padapter, 78U);
  val = (unsigned int )val & 127U;
  rtl8723au_write8(padapter, 78U, (int )val);
  return;
}
}
void rtl8723a_init_default_value(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 i ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pHalData->fw_ractrl = 0U;
  pHalData->bIQKInitialized = 0U;
  if ((unsigned int )padapter->pwrctrlpriv.bkeepfwalive == 0U) {
    pHalData->LastHMEBoxNum = 0U;
  } else {
  }
  pHalData->bIQKInitialized = 0U;
  pdmpriv->TM_Trigger = 0U;
  pdmpriv->ThermalValue_HP_index = 0U;
  i = 0U;
  goto ldv_54602;
  ldv_54601:
  pdmpriv->ThermalValue_HP[(int )i] = 0U;
  i = (u8 )((int )i + 1);
  ldv_54602: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_54601;
  } else {
  }
  pHalData->EfuseUsedBytes = 0U;
  pHalData->BTEfuseUsedBytes = 0U;
  return;
}
}
u8 GetEEPROMSize8723A(struct rtw_adapter *padapter )
{
  u8 size ;
  u32 cr ;
  u16 tmp ;
  {
  size = 0U;
  tmp = rtl8723au_read16(padapter, 10U);
  cr = (u32 )tmp;
  size = ((unsigned long )cr & 16UL) != 0UL ? 6U : 4U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: EEPROM type is %s\n", (unsigned int )size == 4U ? (char *)"E-FUSE" : (char *)"93C46");
  } else {
  }
  return (size);
}
}
static int _LLTWrite(struct rtw_adapter *padapter , u32 address , u32 data )
{
  int status ;
  s32 count ;
  u32 value ;
  u16 LLTReg ;
  s32 tmp ;
  {
  status = 1;
  count = 0;
  value = (((address << 8) & 65535U) | (data & 255U)) | 1073741824U;
  LLTReg = 480U;
  rtl8723au_write32(padapter, (u32 )LLTReg, value);
  ldv_54619:
  value = rtl8723au_read32(padapter, (u32 )LLTReg);
  if (value >> 30 == 0U) {
    goto ldv_54618;
  } else {
  }
  if (count > 20) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
      printk("\016Failed to polling write LLT done at address %d!\n", address);
    } else {
    }
    status = 0;
    goto ldv_54618;
  } else {
  }
  tmp = count;
  count = count + 1;
  if (tmp != 0) {
    goto ldv_54619;
  } else {
  }
  ldv_54618: ;
  return (status);
}
}
s32 InitLLTTable23a(struct rtw_adapter *padapter , u32 boundary )
{
  int status ;
  u32 i ;
  u32 txpktbuf_bndy ;
  u32 Last_Entry_Of_TxPktBuf ;
  {
  status = 1;
  txpktbuf_bndy = boundary;
  Last_Entry_Of_TxPktBuf = 255U;
  i = 0U;
  goto ldv_54629;
  ldv_54628:
  status = _LLTWrite(padapter, i, i + 1U);
  if (status != 1) {
    return (status);
  } else {
  }
  i = i + 1U;
  ldv_54629: ;
  if (txpktbuf_bndy - 1U > i) {
    goto ldv_54628;
  } else {
  }
  status = _LLTWrite(padapter, txpktbuf_bndy - 1U, 255U);
  if (status != 1) {
    return (status);
  } else {
  }
  i = txpktbuf_bndy;
  goto ldv_54632;
  ldv_54631:
  status = _LLTWrite(padapter, i, i + 1U);
  if (status != 1) {
    return (status);
  } else {
  }
  i = i + 1U;
  ldv_54632: ;
  if (i < Last_Entry_Of_TxPktBuf) {
    goto ldv_54631;
  } else {
  }
  status = _LLTWrite(padapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
  if (status != 1) {
    return (status);
  } else {
  }
  return (status);
}
}
static void _DisableGPIO(struct rtw_adapter *padapter )
{
  u32 value32 ;
  u32 u4bTmp ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  rtl8723au_write16(padapter, 70U, 0);
  tmp = rtl8723au_read32(padapter, 68U);
  value32 = tmp & 4294902015U;
  u4bTmp = value32 & 255U;
  value32 = ((u4bTmp << 8) | value32) | 16711680U;
  rtl8723au_write32(padapter, 68U, value32);
  rtl8723au_write16(padapter, 98U, 0);
  tmp___0 = rtl8723au_read32(padapter, 96U);
  value32 = tmp___0 & 4294901791U;
  u4bTmp = value32 & 31U;
  value32 = ((u4bTmp << 8) | value32) | 1900544U;
  rtl8723au_write32(padapter, 96U, value32);
  rtl8723au_write16(padapter, 76U, 32896);
  return;
}
}
static void _DisableRFAFEAndResetBB8192C(struct rtw_adapter *padapter )
{
  u8 eRFPath ;
  u8 value8 ;
  {
  eRFPath = 0U;
  value8 = 0U;
  rtl8723au_write8(padapter, 1314U, 255);
  PHY_SetRFReg(padapter, (enum RF_RADIO_PATH )eRFPath, 0U, 255U, 0U);
  value8 = (u8 )((unsigned int )value8 | 64U);
  rtl8723au_write8(padapter, 1536U, (int )value8);
  value8 = 0U;
  value8 = (u8 )((unsigned int )value8 | 22U);
  rtl8723au_write8(padapter, 2U, (int )value8);
  value8 = (unsigned int )value8 & 253U;
  rtl8723au_write8(padapter, 2U, (int )value8);
  return;
}
}
static void _DisableRFAFEAndResetBB(struct rtw_adapter *padapter )
{
  {
  _DisableRFAFEAndResetBB8192C(padapter);
  return;
}
}
static void _ResetDigitalProcedure1_92C(struct rtw_adapter *padapter , bool bWithoutHWSM )
{
  struct hal_data_8723a *pHalData ;
  u16 valu16 ;
  u16 tmp ;
  u8 retry_cnts ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  unsigned long __ms ;
  unsigned long tmp___2 ;
  u8 tmp___3 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (((int )((struct hal_data_8723a *)padapter->HalData)->FirmwareSignature & 65520) == 35008 && (unsigned int )pHalData->FirmwareVersion <= 32U) {
    valu16 = 0U;
    rtl8723au_write8(padapter, 128U, 0);
    valu16 = rtl8723au_read16(padapter, 2U);
    rtl8723au_write16(padapter, 2U, (int )valu16 & 64511);
    tmp = rtl8723au_read16(padapter, 2U);
    valu16 = (unsigned int )tmp & 4095U;
    rtl8723au_write16(padapter, 2U, (int )((unsigned int )valu16 | 20480U));
    valu16 = rtl8723au_read16(padapter, 2U);
    rtl8723au_write16(padapter, 2U, (int )((unsigned int )valu16 | 1024U));
  } else {
    retry_cnts = 0U;
    tmp___3 = rtl8723au_read8(padapter, 128U);
    if (((unsigned long )tmp___3 & 2UL) != 0UL) {
      if ((unsigned int )padapter->bFWReady != 0U) {
        rtl8723au_write8(padapter, 304U, 32);
        rtl8723au_write8(padapter, 312U, 0);
        rtl8723au_write8(padapter, 80U, 0);
        rtl8723au_write8(padapter, 463U, 32);
        goto ldv_54655;
        ldv_54654:
        __const_udelay(214750UL);
        ldv_54655:
        tmp___0 = retry_cnts;
        retry_cnts = (u8 )((int )retry_cnts + 1);
        if ((unsigned int )tmp___0 <= 99U) {
          tmp___1 = rtl8723au_read16(padapter, 2U);
          if (((unsigned int )tmp___1 & 1024U) != 0U) {
            goto ldv_54654;
          } else {
            goto ldv_54656;
          }
        } else {
        }
        ldv_54656: ;
        if ((unsigned int )retry_cnts > 99U) {
          rtl8723au_write8(padapter, 3U, 80);
          __ms = 10UL;
          goto ldv_54659;
          ldv_54658:
          __const_udelay(4295000UL);
          ldv_54659:
          tmp___2 = __ms;
          __ms = __ms - 1UL;
          if (tmp___2 != 0UL) {
            goto ldv_54658;
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
    rtl8723au_write8(padapter, 3U, 84);
    rtl8723au_write8(padapter, 128U, 0);
  }
  if ((int )bWithoutHWSM) {
    rtl8723au_write16(padapter, 8U, 28835);
    rtl8723au_write8(padapter, 40U, 128);
    rtl8723au_write16(padapter, 36U, 34831);
    rtl8723au_write8(padapter, 0U, 249);
  } else {
    rtl8723au_write8(padapter, 31U, 0);
  }
  return;
}
}
static void _ResetDigitalProcedure1(struct rtw_adapter *padapter , bool bWithoutHWSM )
{
  {
  _ResetDigitalProcedure1_92C(padapter, (int )bWithoutHWSM);
  return;
}
}
static void _ResetDigitalProcedure2(struct rtw_adapter *padapter )
{
  {
  rtl8723au_write16(padapter, 8U, 28835);
  rtl8723au_write8(padapter, 1U, 130);
  return;
}
}
static void _DisableAnalog(struct rtw_adapter *padapter , bool bWithoutHWSM )
{
  struct hal_data_8723a *pHalData ;
  u16 value16 ;
  u8 value8 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  value16 = 0U;
  value8 = 0U;
  if ((int )bWithoutHWSM) {
    rtl8723au_write8(padapter, 32U, 4);
    value8 = rtl8723au_read8(padapter, 33U);
    value8 = (unsigned int )value8 & 254U;
    rtl8723au_write8(padapter, 33U, (int )value8);
  } else {
  }
  value8 = 35U;
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U)) {
    value8 = (u8 )((unsigned int )value8 | 8U);
  } else {
  }
  rtl8723au_write8(padapter, 17U, (int )value8);
  if ((int )bWithoutHWSM) {
    value16 = (u16 )((unsigned int )value16 | 18434U);
  } else {
    value16 = (u16 )((unsigned int )value16 | 18434U);
  }
  rtl8723au_write16(padapter, 4U, (int )value16);
  rtl8723au_write8(padapter, 28U, 14);
  return;
}
}
s32 CardDisableHWSM(struct rtw_adapter *padapter , u8 resetMCU )
{
  int rtStatus ;
  {
  rtStatus = 1;
  if (padapter->bSurpriseRemoved != 0) {
    return (rtStatus);
  } else {
  }
  _DisableRFAFEAndResetBB(padapter);
  _ResetDigitalProcedure1(padapter, 0);
  _DisableGPIO(padapter);
  _DisableAnalog(padapter, 0);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016======> Card disable finished.\n");
  } else {
  }
  return (rtStatus);
}
}
s32 CardDisableWithoutHWSM(struct rtw_adapter *padapter )
{
  int rtStatus ;
  {
  rtStatus = 1;
  if (padapter->bSurpriseRemoved != 0) {
    return (rtStatus);
  } else {
  }
  _DisableRFAFEAndResetBB(padapter);
  _ResetDigitalProcedure1(padapter, 1);
  _DisableGPIO(padapter);
  _ResetDigitalProcedure2(padapter);
  _DisableAnalog(padapter, 1);
  return (rtStatus);
}
}
void Hal_InitPGData(struct rtw_adapter *padapter , u8 *PROMContent )
{
  struct eeprom_priv *pEEPROM ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  pEEPROM = & padapter->eeprompriv;
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 0U) {
    if ((unsigned int )pEEPROM->EepromOrEfuse == 0U) {
      EFUSE_ShadowMapUpdate23a(padapter, 0);
      __len = 256UL;
      if (__len > 63UL) {
        __ret = memcpy((void *)PROMContent, (void const *)(& pEEPROM->efuse_eeprom_data),
                         __len);
      } else {
        __ret = memcpy((void *)PROMContent, (void const *)(& pEEPROM->efuse_eeprom_data),
                                 __len);
      }
    } else {
    }
  } else {
    if (GlobalDebugLevel23A > 5U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 6);
      printk("\016AutoLoad Fail reported from CR9346!!\n");
    } else {
    }
    if ((unsigned int )pEEPROM->EepromOrEfuse == 0U) {
      EFUSE_ShadowMapUpdate23a(padapter, 0);
    } else {
    }
    __len___0 = 256UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)PROMContent, (void const *)(& pEEPROM->efuse_eeprom_data),
                           __len___0);
    } else {
      __ret___0 = memcpy((void *)PROMContent, (void const *)(& pEEPROM->efuse_eeprom_data),
                                   __len___0);
    }
  }
  return;
}
}
void Hal_EfuseParseIDCode(struct rtw_adapter *padapter , u8 *hwinfo )
{
  struct eeprom_priv *pEEPROM ;
  u16 EEPROMId ;
  {
  pEEPROM = & padapter->eeprompriv;
  EEPROMId = *((u16 *)hwinfo);
  if ((unsigned int )EEPROMId != 33065U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: EEPROM ID(%#x) is invalid!!\n", (int )EEPROMId);
    } else {
    }
    pEEPROM->bautoload_fail_flag = 1U;
  } else {
    pEEPROM->bautoload_fail_flag = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    printk("\016EEPROM ID = 0x%04x\n", (int )EEPROMId);
  } else {
  }
  return;
}
}
static void Hal_EEValueCheck(u8 EEType , void *pInValue , void *pOutValue )
{
  u8 *pIn ;
  u8 *pOut ;
  {
  switch ((int )EEType) {
  case 0:
  pIn = (u8 *)pInValue;
  pOut = (u8 *)pOutValue;
  if ((unsigned int )*pIn <= 63U) {
    *pOut = *pIn;
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
      printk("\016EETYPE_TX_PWR, value =%d is invalid, set to default = 0x%x\n", (int )*pIn,
             34);
    } else {
    }
    *pOut = 34U;
  }
  goto ldv_54709;
  default: ;
  goto ldv_54709;
  }
  ldv_54709: ;
  return;
}
}
static void Hal_ReadPowerValueFromPROM_8723A(struct txpowerinfo *pwrInfo , u8 *PROMContent ,
                                             bool AutoLoadFail )
{
  u32 rfPath ;
  u32 eeAddr ;
  u32 group ;
  u32 rfPathMax ;
  {
  rfPathMax = 1U;
  memset((void *)pwrInfo, 0, 180UL);
  if ((int )AutoLoadFail) {
    group = 0U;
    goto ldv_54724;
    ldv_54723:
    rfPath = 0U;
    goto ldv_54721;
    ldv_54720:
    pwrInfo->CCKIndex[rfPath][group] = 34U;
    pwrInfo->HT40_1SIndex[rfPath][group] = 34U;
    pwrInfo->HT40_2SIndexDiff[rfPath][group] = 0U;
    pwrInfo->HT20IndexDiff[rfPath][group] = 2U;
    pwrInfo->OFDMIndexDiff[rfPath][group] = 3U;
    pwrInfo->HT40MaxOffset[rfPath][group] = 0U;
    pwrInfo->HT20MaxOffset[rfPath][group] = 0U;
    rfPath = rfPath + 1U;
    ldv_54721: ;
    if (rfPath < rfPathMax) {
      goto ldv_54720;
    } else {
    }
    group = group + 1U;
    ldv_54724: ;
    if (group <= 11U) {
      goto ldv_54723;
    } else {
    }
    pwrInfo->TSSI_A[0] = 0U;
    return;
  } else {
  }
  rfPath = 0U;
  goto ldv_54730;
  ldv_54729:
  group = 0U;
  goto ldv_54727;
  ldv_54726:
  eeAddr = (rfPath * 3U + group) + 16U;
  Hal_EEValueCheck(0, (void *)PROMContent + (unsigned long )eeAddr, (void *)(& pwrInfo->CCKIndex) + ((unsigned long )rfPath + (unsigned long )group));
  eeAddr = (rfPath * 3U + group) + 22U;
  Hal_EEValueCheck(0, (void *)PROMContent + (unsigned long )eeAddr, (void *)(& pwrInfo->HT40_1SIndex) + ((unsigned long )rfPath + (unsigned long )group));
  group = group + 1U;
  ldv_54727: ;
  if (group <= 11U) {
    goto ldv_54726;
  } else {
  }
  rfPath = rfPath + 1U;
  ldv_54730: ;
  if (rfPath < rfPathMax) {
    goto ldv_54729;
  } else {
  }
  group = 0U;
  goto ldv_54736;
  ldv_54735:
  rfPath = 0U;
  goto ldv_54733;
  ldv_54732:
  pwrInfo->HT40_2SIndexDiff[rfPath][group] = 0U;
  pwrInfo->HT20IndexDiff[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 28U)) >> (int )(rfPath * 4U))) & 15U;
  if (((unsigned long )pwrInfo->HT20IndexDiff[rfPath][group] & 8UL) != 0UL) {
    pwrInfo->HT20IndexDiff[rfPath][group] = (u8 )((unsigned int )pwrInfo->HT20IndexDiff[rfPath][group] | 240U);
  } else {
  }
  pwrInfo->OFDMIndexDiff[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 31U)) >> (int )(rfPath * 4U))) & 15U;
  pwrInfo->HT40MaxOffset[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 34U)) >> (int )(rfPath * 4U))) & 15U;
  pwrInfo->HT20MaxOffset[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 37U)) >> (int )(rfPath * 4U))) & 15U;
  rfPath = rfPath + 1U;
  ldv_54733: ;
  if (rfPath < rfPathMax) {
    goto ldv_54732;
  } else {
  }
  group = group + 1U;
  ldv_54736: ;
  if (group <= 11U) {
    goto ldv_54735;
  } else {
  }
  pwrInfo->TSSI_A[0] = *(PROMContent + 41UL);
  return;
}
}
static u8 Hal_GetChnlGroup(u8 chnl )
{
  u8 group ;
  {
  group = 0U;
  if ((unsigned int )chnl <= 2U) {
    group = 0U;
  } else
  if ((unsigned int )chnl <= 8U) {
    group = 1U;
  } else {
    group = 2U;
  }
  return (group);
}
}
void Hal_EfuseParsetxpowerinfo_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                     bool AutoLoadFail )
{
  struct hal_data_8723a *pHalData ;
  struct txpowerinfo pwrInfo ;
  u8 rfPath ;
  u8 ch ;
  u8 group ;
  u8 rfPathMax ;
  u8 pwr ;
  u8 diff ;
  struct registry_priv *registry_par ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  rfPathMax = 1U;
  Hal_ReadPowerValueFromPROM_8723A(& pwrInfo, PROMContent, (int )AutoLoadFail);
  rfPath = 0U;
  goto ldv_54759;
  ldv_54758:
  ch = 0U;
  goto ldv_54756;
  ldv_54755:
  group = Hal_GetChnlGroup((int )ch);
  pHalData->TxPwrLevelCck[(int )rfPath][(int )ch] = pwrInfo.CCKIndex[(int )rfPath][(int )group];
  pHalData->TxPwrLevelHT40_1S[(int )rfPath][(int )ch] = pwrInfo.HT40_1SIndex[(int )rfPath][(int )group];
  pHalData->TxPwrHt20Diff[(int )rfPath][(int )ch] = pwrInfo.HT20IndexDiff[(int )rfPath][(int )group];
  pHalData->TxPwrLegacyHtDiff[(int )rfPath][(int )ch] = pwrInfo.OFDMIndexDiff[(int )rfPath][(int )group];
  pHalData->PwrGroupHT20[(int )rfPath][(int )ch] = pwrInfo.HT20MaxOffset[(int )rfPath][(int )group];
  pHalData->PwrGroupHT40[(int )rfPath][(int )ch] = pwrInfo.HT40MaxOffset[(int )rfPath][(int )group];
  pwr = pwrInfo.HT40_1SIndex[(int )rfPath][(int )group];
  diff = pwrInfo.HT40_2SIndexDiff[(int )rfPath][(int )group];
  pHalData->TxPwrLevelHT40_2S[(int )rfPath][(int )ch] = (int )pwr > (int )diff ? (int )pwr - (int )diff : 0U;
  ch = (u8 )((int )ch + 1);
  ldv_54756: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_54755;
  } else {
  }
  rfPath = (u8 )((int )rfPath + 1);
  ldv_54759: ;
  if ((int )rfPath < (int )rfPathMax) {
    goto ldv_54758;
  } else {
  }
  rfPath = 0U;
  goto ldv_54765;
  ldv_54764:
  ch = 0U;
  goto ldv_54762;
  ldv_54761: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016RF(%u)-Ch(%u) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n",
           (int )rfPath, (int )ch, (int )pHalData->TxPwrLevelCck[(int )rfPath][(int )ch],
           (int )pHalData->TxPwrLevelHT40_1S[(int )rfPath][(int )ch], (int )pHalData->TxPwrLevelHT40_2S[(int )rfPath][(int )ch]);
  } else {
  }
  ch = (u8 )((int )ch + 1);
  ldv_54762: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_54761;
  } else {
  }
  rfPath = (u8 )((int )rfPath + 1);
  ldv_54765: ;
  if ((unsigned int )rfPath <= 1U) {
    goto ldv_54764;
  } else {
  }
  ch = 0U;
  goto ldv_54768;
  ldv_54767: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016RF-A Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", (int )ch, (int )pHalData->TxPwrHt20Diff[0][(int )ch],
           (int )pHalData->TxPwrHt20Diff[0][(int )ch]);
  } else {
  }
  ch = (u8 )((int )ch + 1);
  ldv_54768: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_54767;
  } else {
  }
  ch = 0U;
  goto ldv_54771;
  ldv_54770: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016RF-A Legacy to Ht40 Diff[%u] = 0x%x\n", (int )ch, (int )pHalData->TxPwrLegacyHtDiff[0][(int )ch]);
  } else {
  }
  ch = (u8 )((int )ch + 1);
  ldv_54771: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_54770;
  } else {
  }
  ch = 0U;
  goto ldv_54774;
  ldv_54773: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016RF-B Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", (int )ch, (int )pHalData->TxPwrHt20Diff[1][(int )ch],
           (int )pHalData->TxPwrHt20Diff[1][(int )ch]);
  } else {
  }
  ch = (u8 )((int )ch + 1);
  ldv_54774: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_54773;
  } else {
  }
  ch = 0U;
  goto ldv_54777;
  ldv_54776: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016RF-B Legacy to HT40 Diff[%u] = 0x%x\n", (int )ch, (int )pHalData->TxPwrLegacyHtDiff[1][(int )ch]);
  } else {
  }
  ch = (u8 )((int )ch + 1);
  ldv_54777: ;
  if ((unsigned int )ch <= 13U) {
    goto ldv_54776;
  } else {
  }
  if (! AutoLoadFail) {
    registry_par = & padapter->registrypriv;
    if ((unsigned int )registry_par->regulatory_tid == 255U) {
      if ((unsigned int )*(PROMContent + 43UL) == 255U) {
        pHalData->EEPROMRegulatory = 0U;
      } else {
        pHalData->EEPROMRegulatory = (unsigned int )*(PROMContent + 43UL) & 7U;
      }
    } else {
      pHalData->EEPROMRegulatory = registry_par->regulatory_tid;
    }
  } else {
    pHalData->EEPROMRegulatory = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016EEPROMRegulatory = 0x%x\n", (int )pHalData->EEPROMRegulatory);
  } else {
  }
  if (! AutoLoadFail) {
    pHalData->bTXPowerDataReadFromEEPORM = 1U;
  } else {
  }
  return;
}
}
void Hal_EfuseParseBTCoexistInfo_8723A(struct rtw_adapter *padapter , u8 *hwinfo ,
                                       bool AutoLoadFail )
{
  struct hal_data_8723a *pHalData ;
  u8 tempval ;
  u32 tmpu4 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (! AutoLoadFail) {
    tmpu4 = rtl8723au_read32(padapter, 104U);
    if (((unsigned long )tmpu4 & 262144UL) != 0UL) {
      pHalData->EEPROMBluetoothCoexist = 1U;
    } else {
      pHalData->EEPROMBluetoothCoexist = 0U;
    }
    pHalData->EEPROMBluetoothType = 6U;
    tempval = *(hwinfo + 46UL);
    pHalData->EEPROMBluetoothAntNum = (unsigned int )tempval & 1U;
    pHalData->EEPROMBluetoothAntIsolation = (u8 )(((int )tempval & 16) >> 4);
    pHalData->EEPROMBluetoothRadioShared = (u8 )(((int )tempval & 32) >> 5);
  } else {
    pHalData->EEPROMBluetoothCoexist = 0U;
    pHalData->EEPROMBluetoothType = 6U;
    pHalData->EEPROMBluetoothAntNum = 0U;
    pHalData->EEPROMBluetoothAntIsolation = 0U;
    pHalData->EEPROMBluetoothRadioShared = 0U;
  }
  rtl8723a_BT_init_hal_vars(padapter);
  return;
}
}
void Hal_EfuseParseEEPROMVer(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (! AutoLoadFail) {
    pHalData->EEPROMVersion = *(hwinfo + 48UL);
  } else {
    pHalData->EEPROMVersion = 1U;
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016Hal_EfuseParseEEPROMVer(), EEVer = %d\n", (int )pHalData->EEPROMVersion);
  } else {
  }
  return;
}
}
void rtl8723a_EfuseParseChnlPlan(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail )
{
  {
  padapter->mlmepriv.ChannelPlan = hal_com_get_channel_plan23a(padapter, (unsigned long )hwinfo != (unsigned long )((u8 *)0U) ? (int )*(hwinfo + 40UL) : 255,
                                                               (int )padapter->registrypriv.channel_plan,
                                                               10, (int )AutoLoadFail);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: mlmepriv.ChannelPlan = 0x%02x\n", (int )padapter->mlmepriv.ChannelPlan);
  } else {
  }
  return;
}
}
void Hal_EfuseParseCustomerID(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (! AutoLoadFail) {
    pHalData->EEPROMCustomerID = *(hwinfo + 49UL);
    pHalData->EEPROMSubCustomerID = *(hwinfo + 50UL);
  } else {
    pHalData->EEPROMCustomerID = 0U;
    pHalData->EEPROMSubCustomerID = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016EEPROM Customer ID: 0x%2x\n", (int )pHalData->EEPROMCustomerID);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016EEPROM SubCustomer ID: 0x%02x\n", (int )pHalData->EEPROMSubCustomerID);
  } else {
  }
  return;
}
}
void Hal_EfuseParseAntennaDiversity(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail )
{
  {
  return;
}
}
void Hal_EfuseParseRateIndicationOption(struct rtw_adapter *padapter , u8 *hwinfo ,
                                        bool AutoLoadFail )
{
  {
  return;
}
}
void Hal_EfuseParseXtal_8723A(struct rtw_adapter *pAdapter , u8 *hwinfo , u8 AutoLoadFail )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  if ((unsigned int )AutoLoadFail == 0U) {
    pHalData->CrystalCap = *(hwinfo + 51UL);
    if ((unsigned int )pHalData->CrystalCap == 255U) {
      pHalData->CrystalCap = 32U;
    } else {
    }
  } else {
    pHalData->CrystalCap = 32U;
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016%s: CrystalCap = 0x%2x\n", "Hal_EfuseParseXtal_8723A", (int )pHalData->CrystalCap);
  } else {
  }
  return;
}
}
void Hal_EfuseParseThermalMeter_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                      bool AutoloadFail )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (! AutoloadFail) {
    pHalData->EEPROMThermalMeter = *(PROMContent + 42UL);
  } else {
    pHalData->EEPROMThermalMeter = 18U;
  }
  if ((unsigned int )pHalData->EEPROMThermalMeter == 255U || (int )AutoloadFail) {
    pHalData->bAPKThermalMeterIgnore = 1U;
    pHalData->EEPROMThermalMeter = 18U;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s: ThermalMeter = 0x%x\n", "Hal_EfuseParseThermalMeter_8723A",
           (int )pHalData->EEPROMThermalMeter);
  } else {
  }
  return;
}
}
void Hal_InitChannelPlan23a(struct rtw_adapter *padapter )
{
  {
  return;
}
}
static void rtl8723a_cal_txdesc_chksum(struct tx_desc *ptxdesc )
{
  u16 *usPtr ;
  u32 count ;
  u32 index ;
  u16 checksum ;
  {
  usPtr = (u16 *)ptxdesc;
  count = 16U;
  checksum = 0U;
  ptxdesc->txdw7 = ptxdesc->txdw7 & 4294901760U;
  index = 0U;
  goto ldv_54840;
  ldv_54839:
  checksum = (u16 )((int )*(usPtr + (unsigned long )index) ^ (int )checksum);
  index = index + 1U;
  ldv_54840: ;
  if (index < count) {
    goto ldv_54839;
  } else {
  }
  ptxdesc->txdw7 = ptxdesc->txdw7 | (__le32 )checksum;
  return;
}
}
static void fill_txdesc_sectype(struct pkt_attrib *pattrib , struct txdesc_8723a *ptxdesc )
{
  {
  if (pattrib->encrypt != 0U && (unsigned int )pattrib->bswenc == 0U) {
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: ;
    case 1027074U:
    ptxdesc->sectype = 1U;
    goto ldv_54849;
    case 1027076U:
    ptxdesc->sectype = 3U;
    goto ldv_54849;
    case 0U: ;
    default: ;
    goto ldv_54849;
    }
    ldv_54849: ;
  } else {
  }
  return;
}
}
static void fill_txdesc_vcs(struct pkt_attrib *pattrib , struct txdesc_8723a *ptxdesc )
{
  {
  switch ((int )pattrib->vcs_mode) {
  case 1:
  ptxdesc->rtsen = 1U;
  goto ldv_54858;
  case 2:
  ptxdesc->cts2self = 1U;
  goto ldv_54858;
  case 0: ;
  default: ;
  goto ldv_54858;
  }
  ldv_54858: ;
  if ((unsigned int )pattrib->vcs_mode != 0U) {
    ptxdesc->hw_rts_en = 1U;
    if ((unsigned int )pattrib->ht_en != 0U) {
      if ((int )pattrib->bwmode & 1) {
        ptxdesc->rts_bw = 1U;
      } else {
      }
      switch ((int )pattrib->ch_offset) {
      case 0:
      ptxdesc->rts_sc = 0U;
      goto ldv_54863;
      case 1:
      ptxdesc->rts_sc = 1U;
      goto ldv_54863;
      case 2:
      ptxdesc->rts_sc = 2U;
      goto ldv_54863;
      default:
      ptxdesc->rts_sc = 3U;
      goto ldv_54863;
      }
      ldv_54863: ;
    } else {
    }
  } else {
  }
  return;
}
}
static void fill_txdesc_phy(struct pkt_attrib *pattrib , struct txdesc_8723a *ptxdesc )
{
  {
  if ((unsigned int )pattrib->ht_en != 0U) {
    if ((int )pattrib->bwmode & 1) {
      ptxdesc->data_bw = 1U;
    } else {
    }
    switch ((int )pattrib->ch_offset) {
    case 0:
    ptxdesc->data_sc = 0U;
    goto ldv_54872;
    case 1:
    ptxdesc->data_sc = 1U;
    goto ldv_54872;
    case 2:
    ptxdesc->data_sc = 2U;
    goto ldv_54872;
    default:
    ptxdesc->data_sc = 3U;
    goto ldv_54872;
    }
    ldv_54872: ;
  } else {
  }
  return;
}
}
static void rtl8723a_fill_default_txdesc(struct xmit_frame *pxmitframe , u8 *pbuf )
{
  struct rtw_adapter *padapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct pkt_attrib *pattrib ;
  struct txdesc_8723a *ptxdesc ;
  s32 bmcst ;
  bool tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  {
  padapter = pxmitframe->padapter;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pattrib = & pxmitframe->attrib;
  tmp = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
  bmcst = (s32 )tmp;
  ptxdesc = (struct txdesc_8723a *)pbuf;
  if (pxmitframe->frame_tag == 1) {
    ptxdesc->macid = pattrib->mac_id;
    if ((unsigned int )pattrib->ampdu_en == 1U) {
      ptxdesc->agg_en = 1U;
    } else {
      ptxdesc->bk = 1U;
    }
    ptxdesc->qsel = pattrib->qsel;
    ptxdesc->rate_id = pattrib->raid;
    fill_txdesc_sectype(pattrib, ptxdesc);
    ptxdesc->seq = pattrib->seqnum;
    if (((unsigned int )pattrib->ether_type != 34958U && (unsigned int )pattrib->ether_type != 2054U) && (unsigned int )pattrib->dhcp_pkt != 1U) {
      fill_txdesc_vcs(pattrib, ptxdesc);
      fill_txdesc_phy(pattrib, ptxdesc);
      ptxdesc->rtsrate = 8U;
      ptxdesc->data_ratefb_lmt = 31U;
      ptxdesc->rts_ratefb_lmt = 15U;
      ptxdesc->datarate = pdmpriv->INIDATA_RATE[(int )pattrib->mac_id];
    } else {
      ptxdesc->bk = 1U;
      ptxdesc->userate = 1U;
      if ((unsigned int )pmlmeinfo->preamble_mode == 3U) {
        ptxdesc->data_short = 1U;
      } else {
      }
      tmp___0 = MRateToHwRate23a((int )pmlmeext->tx_rate);
      ptxdesc->datarate = tmp___0;
    }
  } else
  if (pxmitframe->frame_tag == 3) {
    ptxdesc->macid = pattrib->mac_id;
    ptxdesc->qsel = pattrib->qsel;
    ptxdesc->rate_id = pattrib->raid;
    ptxdesc->seq = pattrib->seqnum;
    ptxdesc->userate = 1U;
    ptxdesc->rty_lmt_en = 1U;
    ptxdesc->data_rt_lmt = 6U;
    if ((unsigned int )pxmitframe->ack_report != 0U) {
      ptxdesc->ccx = 1U;
    } else {
    }
    tmp___1 = MRateToHwRate23a((int )pmlmeext->tx_rate);
    ptxdesc->datarate = tmp___1;
  } else
  if (pxmitframe->frame_tag == 8) {
    if (GlobalDebugLevel23A > 4U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 268435456U, 5);
      printk("\016%s: TXAGG_FRAMETAG\n", "rtl8723a_fill_default_txdesc");
    } else {
    }
  } else {
    if (GlobalDebugLevel23A > 4U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 268435456U, 5);
      printk("\016%s: frame_tag = 0x%x\n", "rtl8723a_fill_default_txdesc", pxmitframe->frame_tag);
    } else {
    }
    ptxdesc->macid = 4U;
    ptxdesc->rate_id = 6U;
    ptxdesc->seq = pattrib->seqnum;
    ptxdesc->userate = 1U;
    tmp___2 = MRateToHwRate23a((int )pmlmeext->tx_rate);
    ptxdesc->datarate = tmp___2;
  }
  ptxdesc->pktlen = (unsigned short )pattrib->last_txcmdsz;
  ptxdesc->offset = 32U;
  if (bmcst != 0) {
    ptxdesc->bmc = 1U;
  } else {
  }
  ptxdesc->ls = 1U;
  ptxdesc->fs = 1U;
  ptxdesc->own = 1U;
  if ((unsigned int )pattrib->qos_en == 0U) {
    ptxdesc->hwseq_en = 1U;
    ptxdesc->hwseq_sel = 0U;
  } else {
  }
  return;
}
}
void rtl8723a_update_txdesc(struct xmit_frame *pxmitframe , u8 *pbuf )
{
  struct tx_desc *pdesc ;
  {
  pdesc = (struct tx_desc *)pbuf;
  memset((void *)pdesc, 0, 32UL);
  rtl8723a_fill_default_txdesc(pxmitframe, pbuf);
  pdesc->txdw0 = pdesc->txdw0;
  pdesc->txdw1 = pdesc->txdw1;
  pdesc->txdw2 = pdesc->txdw2;
  pdesc->txdw3 = pdesc->txdw3;
  pdesc->txdw4 = pdesc->txdw4;
  pdesc->txdw5 = pdesc->txdw5;
  pdesc->txdw6 = pdesc->txdw6;
  pdesc->txdw7 = pdesc->txdw7;
  rtl8723a_cal_txdesc_chksum(pdesc);
  return;
}
}
void rtl8723a_fill_fake_txdesc(struct rtw_adapter *padapter , u8 *pDesc , u32 BufferLen ,
                               u8 IsPsPoll , u8 IsBTQosNull )
{
  struct tx_desc *ptxdesc ;
  {
  ptxdesc = (struct tx_desc *)pDesc;
  memset((void *)pDesc, 0, 32UL);
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2348810240U;
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2097152U;
  ptxdesc->txdw0 = ptxdesc->txdw0 | (BufferLen & 65535U);
  ptxdesc->txdw1 = ptxdesc->txdw1 | 4608U;
  if ((unsigned int )IsPsPoll != 0U) {
    ptxdesc->txdw1 = ptxdesc->txdw1 | 1048576U;
  } else {
    ptxdesc->txdw4 = ptxdesc->txdw4 | 128U;
    ptxdesc->txdw3 = ptxdesc->txdw3 | 2147483648U;
  }
  if ((unsigned int )IsBTQosNull == 1U) {
    ptxdesc->txdw2 = ptxdesc->txdw2 | 8388608U;
  } else {
  }
  ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
  rtl8723a_cal_txdesc_chksum(ptxdesc);
  return;
}
}
void hw_var_set_opmode(struct rtw_adapter *padapter , u8 mode )
{
  u8 val8 ;
  {
  if ((unsigned int )mode == 2U || (unsigned int )mode == 0U) {
    StopTxBeacon(padapter);
    val8 = 25U;
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else
  if ((unsigned int )mode == 1U) {
    ResumeTxBeacon(padapter);
    val8 = 26U;
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else
  if ((unsigned int )mode == 3U) {
    rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(padapter);
    ResumeTxBeacon(padapter);
    val8 = 18U;
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
    rtl8723au_write32(padapter, 1544U, 1879057038U);
    rtl8723au_write16(padapter, 1700U, 65535);
    rtl8723au_write16(padapter, 1698U, 1024);
    rtl8723au_write8(padapter, 1369U, 2);
    rtl8723au_write8(padapter, 1368U, 5);
    rtl8723au_write8(padapter, 1370U, 10);
    rtl8723au_write16(padapter, 1296U, 0);
    rtl8723au_write16(padapter, 1344U, 65284);
    rtl8723au_write16(padapter, 1304U, 32767);
    rtl8723au_write8(padapter, 1363U, 1);
    val8 = 30U;
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else {
  }
  val8 = rtl8723au_read8(padapter, 258U);
  val8 = (u8 )(((int )((signed char )val8) & 12) | (int )((signed char )mode));
  rtl8723au_write8(padapter, 258U, (int )val8);
  return;
}
}
void hw_var_set_macaddr(struct rtw_adapter *padapter , u8 *val )
{
  u8 idx ;
  u32 reg_macid ;
  {
  idx = 0U;
  reg_macid = 1552U;
  idx = 0U;
  goto ldv_54914;
  ldv_54913:
  rtl8723au_write8(padapter, (u32 )idx + reg_macid, (int )*(val + (unsigned long )idx));
  idx = (u8 )((int )idx + 1);
  ldv_54914: ;
  if ((unsigned int )idx <= 5U) {
    goto ldv_54913;
  } else {
  }
  return;
}
}
void hw_var_set_bssid(struct rtw_adapter *padapter , u8 *val )
{
  u8 idx ;
  u32 reg_bssid ;
  {
  idx = 0U;
  reg_bssid = 1560U;
  idx = 0U;
  goto ldv_54923;
  ldv_54922:
  rtl8723au_write8(padapter, (u32 )idx + reg_bssid, (int )*(val + (unsigned long )idx));
  idx = (u8 )((int )idx + 1);
  ldv_54923: ;
  if ((unsigned int )idx <= 5U) {
    goto ldv_54922;
  } else {
  }
  return;
}
}
void hw_var_set_correct_tsf(struct rtw_adapter *padapter )
{
  u64 tsf ;
  u32 reg_tsftr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  uint32_t __base ;
  uint32_t __rem ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  __base = (uint32_t )((int )pmlmeinfo->bcn_interval * 1024);
  __rem = (uint32_t )(pmlmeext->TSFValue % (u64 )__base);
  pmlmeext->TSFValue = pmlmeext->TSFValue / (u64 )__base;
  tsf = (pmlmeext->TSFValue - (u64 )__rem) - 1024ULL;
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
    StopTxBeacon(padapter);
  } else {
  }
  reg_tsftr = 1376U;
  SetBcnCtrlReg23a(padapter, 0, 8);
  rtl8723au_write32(padapter, reg_tsftr, (u32 )tsf);
  rtl8723au_write32(padapter, reg_tsftr + 4U, (u32 )(tsf >> 32));
  SetBcnCtrlReg23a(padapter, 8, 0);
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
    ResumeTxBeacon(padapter);
  } else {
  }
  return;
}
}
void hw_var_set_mlme_disconnect(struct rtw_adapter *padapter )
{
  {
  rtl8723au_write16(padapter, 1700U, 0);
  rtl8723au_write8(padapter, 1363U, 1);
  SetBcnCtrlReg23a(padapter, 16, 0);
  return;
}
}
void hw_var_set_mlme_join(struct rtw_adapter *padapter , u8 type )
{
  u8 RetryLimit ;
  struct hal_data_8723a *pHalData ;
  struct mlme_priv *pmlmepriv ;
  u32 v32 ;
  bool tmp ;
  bool tmp___0 ;
  {
  RetryLimit = 48U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pmlmepriv = & padapter->mlmepriv;
  if ((unsigned int )type == 0U) {
    rtl8723au_write16(padapter, 1700U, 65535);
    v32 = rtl8723au_read32(padapter, 1544U);
    v32 = v32 | 192U;
    rtl8723au_write32(padapter, 1544U, v32);
    tmp = check_fwstate(pmlmepriv, 8);
    if ((int )tmp) {
      RetryLimit = (unsigned int )pHalData->CustomerID == 18U ? 7U : 48U;
    } else {
      RetryLimit = 7U;
    }
  } else
  if ((unsigned int )type == 1U) {
    rtl8723au_write16(padapter, 1700U, 0);
  } else
  if ((unsigned int )type == 2U) {
    SetBcnCtrlReg23a(padapter, 0, 16);
    tmp___0 = check_fwstate(pmlmepriv, 96);
    if ((int )tmp___0) {
      rtl8723au_write8(padapter, 1346U, 2);
      RetryLimit = 7U;
    } else {
    }
  } else {
  }
  rtl8723au_write16(padapter, 1066U, (int )((u16 )((int )((short )((int )RetryLimit << 8)) | (int )((short )RetryLimit))));
  switch ((int )type) {
  case 0:
  rtl8723a_BT_wifiassociate_notify(padapter, 1);
  goto ldv_54947;
  case 1:
  rtl8723a_BT_wifiassociate_notify(padapter, 0);
  goto ldv_54947;
  case 2: ;
  goto ldv_54947;
  }
  ldv_54947: ;
  return;
}
}
void *ldv_kmem_cache_alloc_1586(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1592(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1594(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1596(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1597(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1598(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1599(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1600(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1601(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1602(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1628(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1636(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1644(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1638(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1634(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1642(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1643(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1639(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1640(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1641(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void PHY_SetTxPowerLevel8723A(struct rtw_adapter *Adapter , u8 channel ) ;
int PHY_BBConfig8723A(struct rtw_adapter *Adapter ) ;
int PHY_RFConfig8723A(struct rtw_adapter *Adapter ) ;
s32 PHY_MACConfig8723A(struct rtw_adapter *Adapter ) ;
void rtl8723a_phy_rf6052set_bw(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ) ;
void rtl823a_phy_rf6052setccktxpower(struct rtw_adapter *Adapter , u8 *pPowerlevel ) ;
void rtl8723a_PHY_RF6052SetOFDMTxPower(struct rtw_adapter *Adapter , u8 *pPowerLevel ,
                                       u8 Channel ) ;
int PHY_RF6052_Config8723A(struct rtw_adapter *Adapter ) ;
static u32 phy_CalculateBitShift(u32 BitMask )
{
  u32 i ;
  {
  i = 0U;
  goto ldv_54249;
  ldv_54248: ;
  if ((int )(BitMask >> (int )i) & 1) {
    goto ldv_54247;
  } else {
  }
  i = i + 1U;
  ldv_54249: ;
  if (i <= 31U) {
    goto ldv_54248;
  } else {
  }
  ldv_54247: ;
  return (i);
}
}
u32 PHY_QueryBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask )
{
  u32 ReturnValue ;
  u32 OriginalValue ;
  u32 BitShift ;
  {
  ReturnValue = 0U;
  OriginalValue = rtl8723au_read32(Adapter, RegAddr);
  BitShift = phy_CalculateBitShift(BitMask);
  ReturnValue = (OriginalValue & BitMask) >> (int )BitShift;
  return (ReturnValue);
}
}
void PHY_SetBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask , u32 Data )
{
  u32 OriginalValue ;
  u32 BitShift ;
  {
  if (BitMask != 4294967295U) {
    OriginalValue = rtl8723au_read32(Adapter, RegAddr);
    BitShift = phy_CalculateBitShift(BitMask);
    Data = (~ BitMask & OriginalValue) | (Data << (int )BitShift);
  } else {
  }
  rtl8723au_write32(Adapter, RegAddr, Data);
  return;
}
}
static u32 phy_RFSerialRead(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath ,
                            u32 Offset )
{
  u32 retValue ;
  struct hal_data_8723a *pHalData ;
  struct bb_reg_define *pPhyReg ;
  u32 NewOffset ;
  u32 tmplong ;
  u32 tmplong2 ;
  u8 RfPiEnable ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  retValue = 0U;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
  RfPiEnable = 0U;
  Offset = Offset & 63U;
  NewOffset = Offset;
  tmplong = PHY_QueryBBReg(Adapter, 2084U, 4294967295U);
  if ((unsigned int )eRFPath == 0U) {
    tmplong2 = tmplong;
  } else {
    tmplong2 = PHY_QueryBBReg(Adapter, pPhyReg->rfHSSIPara2, 4294967295U);
  }
  tmplong2 = ((tmplong2 & 2155872255U) | (NewOffset << 23)) | 2147483648U;
  PHY_SetBBReg(Adapter, 2084U, 4294967295U, tmplong & 2147483647U);
  __const_udelay(42950UL);
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 4294967295U, tmplong2);
  __const_udelay(429500UL);
  PHY_SetBBReg(Adapter, 2084U, 4294967295U, tmplong | 2147483648U);
  __const_udelay(42950UL);
  if ((unsigned int )eRFPath == 0U) {
    tmp = PHY_QueryBBReg(Adapter, 2080U, 256U);
    RfPiEnable = (unsigned char )tmp;
  } else
  if ((unsigned int )eRFPath == 1U) {
    tmp___0 = PHY_QueryBBReg(Adapter, 2088U, 256U);
    RfPiEnable = (unsigned char )tmp___0;
  } else {
  }
  if ((unsigned int )RfPiEnable != 0U) {
    retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBackPi, 1048575U);
  } else {
    retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBack, 1048575U);
  }
  return (retValue);
}
}
static void phy_RFSerialWrite(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath ,
                              u32 Offset , u32 Data )
{
  u32 DataAndAddr ;
  struct hal_data_8723a *pHalData ;
  struct bb_reg_define *pPhyReg ;
  u32 NewOffset ;
  {
  DataAndAddr = 0U;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
  Offset = Offset & 63U;
  NewOffset = Offset;
  DataAndAddr = ((NewOffset << 20) | (Data & 1048575U)) & 268435455U;
  PHY_SetBBReg(Adapter, pPhyReg->rf3wireOffset, 4294967295U, DataAndAddr);
  return;
}
}
u32 PHY_QueryRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                   u32 BitMask )
{
  u32 Original_Value ;
  u32 Readback_Value ;
  u32 BitShift ;
  {
  Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
  BitShift = phy_CalculateBitShift(BitMask);
  Readback_Value = (Original_Value & BitMask) >> (int )BitShift;
  return (Readback_Value);
}
}
void PHY_SetRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data )
{
  u32 Original_Value ;
  u32 BitShift ;
  {
  if (BitMask != 1048575U) {
    Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
    BitShift = phy_CalculateBitShift(BitMask);
    Data = (~ BitMask & Original_Value) | (Data << (int )BitShift);
  } else {
  }
  phy_RFSerialWrite(Adapter, eRFPath, RegAddr, Data);
  return;
}
}
s32 PHY_MACConfig8723A(struct rtw_adapter *Adapter )
{
  int rtStatus ;
  struct hal_data_8723a *pHalData ;
  bool is92C ;
  int tmp ;
  {
  rtStatus = 1;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  is92C = (bool )(((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U);
  tmp = ODM_ConfigMACWithHeaderFile23a(& pHalData->odmpriv);
  if (tmp == 0) {
    rtStatus = 0;
  } else {
  }
  rtl8723au_write8(Adapter, 1226U, 10);
  if ((int )is92C && (unsigned int )pHalData->BoardType == 0U) {
    rtl8723au_write8(Adapter, 64U, 4);
  } else {
  }
  return (rtStatus);
}
}
static void phy_InitBBRFRegisterDefinition(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pHalData->PHYRegDef[0].rfintfs = 2160U;
  pHalData->PHYRegDef[1].rfintfs = 2160U;
  pHalData->PHYRegDef[0].rfintfi = 2272U;
  pHalData->PHYRegDef[1].rfintfi = 2272U;
  pHalData->PHYRegDef[0].rfintfo = 2144U;
  pHalData->PHYRegDef[1].rfintfo = 2148U;
  pHalData->PHYRegDef[0].rfintfe = 2144U;
  pHalData->PHYRegDef[1].rfintfe = 2148U;
  pHalData->PHYRegDef[0].rf3wireOffset = 2112U;
  pHalData->PHYRegDef[1].rf3wireOffset = 2116U;
  pHalData->PHYRegDef[0].rfLSSI_Select = 2168U;
  pHalData->PHYRegDef[1].rfLSSI_Select = 2168U;
  pHalData->PHYRegDef[0].rfTxGainStage = 2060U;
  pHalData->PHYRegDef[1].rfTxGainStage = 2060U;
  pHalData->PHYRegDef[0].rfHSSIPara1 = 2080U;
  pHalData->PHYRegDef[1].rfHSSIPara1 = 2088U;
  pHalData->PHYRegDef[0].rfHSSIPara2 = 2084U;
  pHalData->PHYRegDef[1].rfHSSIPara2 = 2092U;
  pHalData->PHYRegDef[0].rfSwitchControl = 2136U;
  pHalData->PHYRegDef[1].rfSwitchControl = 2136U;
  pHalData->PHYRegDef[0].rfAGCControl1 = 3152U;
  pHalData->PHYRegDef[1].rfAGCControl1 = 3160U;
  pHalData->PHYRegDef[0].rfAGCControl2 = 3156U;
  pHalData->PHYRegDef[1].rfAGCControl2 = 3164U;
  pHalData->PHYRegDef[0].rfRxIQImbalance = 3092U;
  pHalData->PHYRegDef[1].rfRxIQImbalance = 3100U;
  pHalData->PHYRegDef[0].rfRxAFE = 3088U;
  pHalData->PHYRegDef[1].rfRxAFE = 3096U;
  pHalData->PHYRegDef[0].rfTxIQImbalance = 3200U;
  pHalData->PHYRegDef[1].rfTxIQImbalance = 3208U;
  pHalData->PHYRegDef[0].rfTxAFE = 3204U;
  pHalData->PHYRegDef[1].rfTxAFE = 3212U;
  pHalData->PHYRegDef[0].rfLSSIReadBack = 2208U;
  pHalData->PHYRegDef[1].rfLSSIReadBack = 2212U;
  pHalData->PHYRegDef[0].rfLSSIReadBackPi = 2232U;
  pHalData->PHYRegDef[1].rfLSSIReadBackPi = 2236U;
  return;
}
}
static void storePwrIndexDiffRateOffset(struct rtw_adapter *Adapter , u32 RegAddr ,
                                        u32 BitMask , u32 Data )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if (RegAddr == 3584U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][0] = Data;
  } else {
  }
  if (RegAddr == 3588U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][1] = Data;
  } else {
  }
  if (RegAddr == 3592U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][6] = Data;
  } else {
  }
  if (RegAddr == 2156U && BitMask == 4294967040U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][7] = Data;
  } else {
  }
  if (RegAddr == 3600U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][2] = Data;
  } else {
  }
  if (RegAddr == 3604U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][3] = Data;
  } else {
  }
  if (RegAddr == 3608U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][4] = Data;
  } else {
  }
  if (RegAddr == 3612U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][5] = Data;
  } else {
  }
  if (RegAddr == 2096U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][8] = Data;
  } else {
  }
  if (RegAddr == 2100U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][9] = Data;
  } else {
  }
  if (RegAddr == 2104U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][14] = Data;
  } else {
  }
  if (RegAddr == 2156U && BitMask == 255U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][15] = Data;
  } else {
  }
  if (RegAddr == 2108U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][10] = Data;
  } else {
  }
  if (RegAddr == 2120U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][11] = Data;
  } else {
  }
  if (RegAddr == 2124U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][12] = Data;
  } else {
  }
  if (RegAddr == 2152U) {
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][13] = Data;
    pHalData->pwrGroupCnt = (u8 )((int )pHalData->pwrGroupCnt + 1);
  } else {
  }
  return;
}
}
static int phy_ConfigBBWithPgHeaderFile(struct rtw_adapter *Adapter , u8 ConfigType )
{
  int i ;
  u32 *Rtl819XPHY_REGArray_Table_PG ;
  u16 PHY_REGArrayPGLen ;
  {
  PHY_REGArrayPGLen = 336U;
  Rtl819XPHY_REGArray_Table_PG = (u32 *)(& Rtl8723UPHY_REG_Array_PG);
  if ((unsigned int )ConfigType == 0U) {
    i = 0;
    goto ldv_54331;
    ldv_54330:
    storePwrIndexDiffRateOffset(Adapter, *(Rtl819XPHY_REGArray_Table_PG + (unsigned long )i),
                                *(Rtl819XPHY_REGArray_Table_PG + ((unsigned long )i + 1UL)),
                                *(Rtl819XPHY_REGArray_Table_PG + ((unsigned long )i + 2UL)));
    i = i + 3;
    ldv_54331: ;
    if ((int )PHY_REGArrayPGLen > i) {
      goto ldv_54330;
    } else {
    }
  } else {
  }
  return (1);
}
}
static void phy_BB8192C_Config_1T(struct rtw_adapter *Adapter )
{
  {
  PHY_SetBBReg(Adapter, 2052U, 3U, 2U);
  PHY_SetBBReg(Adapter, 2316U, 3145779U, 2097186U);
  PHY_SetBBReg(Adapter, 2564U, 4278190080U, 69U);
  PHY_SetBBReg(Adapter, 3076U, 255U, 35U);
  PHY_SetBBReg(Adapter, 3184U, 48U, 1U);
  PHY_SetBBReg(Adapter, 3700U, 201326592U, 2U);
  PHY_SetBBReg(Adapter, 3704U, 201326592U, 2U);
  PHY_SetBBReg(Adapter, 3708U, 201326592U, 2U);
  PHY_SetBBReg(Adapter, 3712U, 201326592U, 2U);
  PHY_SetBBReg(Adapter, 3720U, 201326592U, 2U);
  return;
}
}
static int phy_BB8723a_Config_ParaFile(struct rtw_adapter *Adapter )
{
  struct eeprom_priv *pEEPROM ;
  struct hal_data_8723a *pHalData ;
  int rtStatus ;
  int tmp ;
  int tmp___0 ;
  {
  pEEPROM = & Adapter->eeprompriv;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  rtStatus = 1;
  tmp = ODM_ConfigBBWithHeaderFile23a(& pHalData->odmpriv, 0);
  if (tmp == 0) {
    rtStatus = 0;
  } else {
  }
  if (rtStatus != 1) {
    goto phy_BB8190_Config_ParaFile_Fail;
  } else {
  }
  if ((unsigned int )pHalData->rf_type == 0U) {
    phy_BB8192C_Config_1T(Adapter);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: phy_BB8723a_Config_ParaFile():Config to 1T!!\n");
    } else {
    }
  } else {
  }
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 0U) {
    pHalData->pwrGroupCnt = 0U;
    rtStatus = phy_ConfigBBWithPgHeaderFile(Adapter, 0);
  } else {
  }
  if (rtStatus != 1) {
    goto phy_BB8190_Config_ParaFile_Fail;
  } else {
  }
  tmp___0 = ODM_ConfigBBWithHeaderFile23a(& pHalData->odmpriv, 1);
  if (tmp___0 == 0) {
    rtStatus = 0;
  } else {
  }
  phy_BB8190_Config_ParaFile_Fail: ;
  return (rtStatus);
}
}
int PHY_BBConfig8723A(struct rtw_adapter *Adapter )
{
  int rtStatus ;
  struct hal_data_8723a *pHalData ;
  u8 TmpU1B ;
  u8 CrystalCap ;
  {
  rtStatus = 1;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  TmpU1B = 0U;
  phy_InitBBRFRegisterDefinition(Adapter);
  TmpU1B = rtl8723au_read8(Adapter, 40U);
  __const_udelay(8590UL);
  rtl8723au_write8(Adapter, 40U, (int )((unsigned int )TmpU1B | 2U));
  __const_udelay(8590UL);
  rtl8723au_write8(Adapter, 41U, 255);
  __const_udelay(8590UL);
  TmpU1B = rtl8723au_read8(Adapter, 2U);
  rtl8723au_write8(Adapter, 2U, (int )((unsigned int )TmpU1B | 3U));
  TmpU1B = rtl8723au_read8(Adapter, 37U);
  rtl8723au_write8(Adapter, 37U, (int )TmpU1B & 191);
  TmpU1B = rtl8723au_read8(Adapter, 38U);
  rtl8723au_write8(Adapter, 38U, (int )TmpU1B & 239);
  rtl8723au_write8(Adapter, 31U, 7);
  rtStatus = phy_BB8723a_Config_ParaFile(Adapter);
  if ((unsigned int )pHalData->EEPROMVersion != 0U) {
    CrystalCap = (unsigned int )pHalData->CrystalCap & 63U;
    PHY_SetBBReg(Adapter, 44U, 16773120U, (u32 )((int )CrystalCap | ((int )CrystalCap << 6)));
  } else {
  }
  PHY_SetBBReg(Adapter, 32U, 4294967295U, 22488325U);
  return (rtStatus);
}
}
int PHY_RFConfig8723A(struct rtw_adapter *Adapter )
{
  int rtStatus ;
  {
  rtStatus = 1;
  rtStatus = PHY_RF6052_Config8723A(Adapter);
  return (rtStatus);
}
}
static void getTxPowerIndex(struct rtw_adapter *Adapter , u8 channel , u8 *cckPowerLevel ,
                            u8 *ofdmPowerLevel )
{
  struct hal_data_8723a *pHalData ;
  u8 index ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  index = (unsigned int )channel + 255U;
  *cckPowerLevel = pHalData->TxPwrLevelCck[0][(int )index];
  *(cckPowerLevel + 1UL) = pHalData->TxPwrLevelCck[1][(int )index];
  if ((unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 0U || (unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 3U) {
    *ofdmPowerLevel = pHalData->TxPwrLevelHT40_1S[0][(int )index];
    *(ofdmPowerLevel + 1UL) = pHalData->TxPwrLevelHT40_1S[1][(int )index];
  } else
  if ((unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 2U) {
    *ofdmPowerLevel = pHalData->TxPwrLevelHT40_2S[0][(int )index];
    *(ofdmPowerLevel + 1UL) = pHalData->TxPwrLevelHT40_2S[1][(int )index];
  } else {
  }
  return;
}
}
static void ccxPowerIndexCheck(struct rtw_adapter *Adapter , u8 channel , u8 *cckPowerLevel ,
                               u8 *ofdmPowerLevel )
{
  {
  return;
}
}
void PHY_SetTxPowerLevel8723A(struct rtw_adapter *Adapter , u8 channel )
{
  struct hal_data_8723a *pHalData ;
  u8 cckPowerLevel[2U] ;
  u8 ofdmPowerLevel[2U] ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if ((unsigned int )pHalData->bTXPowerDataReadFromEEPORM == 0U) {
    return;
  } else {
  }
  getTxPowerIndex(Adapter, (int )channel, (u8 *)(& cckPowerLevel), (u8 *)(& ofdmPowerLevel));
  ccxPowerIndexCheck(Adapter, (int )channel, (u8 *)(& cckPowerLevel), (u8 *)(& ofdmPowerLevel));
  rtl823a_phy_rf6052setccktxpower(Adapter, (u8 *)(& cckPowerLevel));
  rtl8723a_PHY_RF6052SetOFDMTxPower(Adapter, (u8 *)(& ofdmPowerLevel), (int )channel);
  return;
}
}
static void _PHY_SetBWMode23a92C(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  u8 regBwOpMode ;
  u8 regRRSR_RSC ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if ((unsigned int )pHalData->rf_chip == 5U) {
    return;
  } else {
  }
  if ((unsigned int )pHalData->rf_chip == 1U) {
    return;
  } else {
  }
  if (Adapter->bDriverStopped != 0) {
    return;
  } else {
  }
  regBwOpMode = rtl8723au_read8(Adapter, 1539U);
  regRRSR_RSC = rtl8723au_read8(Adapter, 1090U);
  switch ((unsigned int )pHalData->CurrentChannelBW) {
  case 0U:
  regBwOpMode = (u8 )((unsigned int )regBwOpMode | 4U);
  rtl8723au_write8(Adapter, 1539U, (int )regBwOpMode);
  goto ldv_54382;
  case 1U:
  regBwOpMode = (unsigned int )regBwOpMode & 251U;
  rtl8723au_write8(Adapter, 1539U, (int )regBwOpMode);
  regRRSR_RSC = (u8 )(((int )((signed char )regRRSR_RSC) & -112) | (int )((signed char )((int )pHalData->nCur40MhzPrimeSC << 5)));
  rtl8723au_write8(Adapter, 1090U, (int )regRRSR_RSC);
  goto ldv_54382;
  default: ;
  goto ldv_54382;
  }
  ldv_54382: ;
  switch ((unsigned int )pHalData->CurrentChannelBW) {
  case 0U:
  PHY_SetBBReg(Adapter, 2048U, 1U, 0U);
  PHY_SetBBReg(Adapter, 2304U, 1U, 0U);
  PHY_SetBBReg(Adapter, 2180U, 1024U, 1U);
  goto ldv_54386;
  case 1U:
  PHY_SetBBReg(Adapter, 2048U, 1U, 1U);
  PHY_SetBBReg(Adapter, 2304U, 1U, 1U);
  PHY_SetBBReg(Adapter, 2560U, 16U, (u32 )((int )pHalData->nCur40MhzPrimeSC >> 1));
  PHY_SetBBReg(Adapter, 3328U, 3072U, (u32 )pHalData->nCur40MhzPrimeSC);
  PHY_SetBBReg(Adapter, 2180U, 1024U, 0U);
  PHY_SetBBReg(Adapter, 2072U, 201326592U, (unsigned int )pHalData->nCur40MhzPrimeSC == 1U ? 2U : 1U);
  goto ldv_54386;
  default: ;
  goto ldv_54386;
  }
  ldv_54386: ;
  switch ((int )pHalData->rf_chip) {
  case 1: ;
  goto ldv_54390;
  case 2: ;
  goto ldv_54390;
  case 3: ;
  goto ldv_54390;
  case 5: ;
  goto ldv_54390;
  case 4:
  rtl8723a_phy_rf6052set_bw(Adapter, pHalData->CurrentChannelBW);
  goto ldv_54390;
  default: ;
  goto ldv_54390;
  }
  ldv_54390: ;
  return;
}
}
void PHY_SetBWMode23a8723A(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ,
                           unsigned char Offset )
{
  struct hal_data_8723a *pHalData ;
  enum ht_channel_width tmpBW ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  tmpBW = pHalData->CurrentChannelBW;
  pHalData->CurrentChannelBW = Bandwidth;
  pHalData->nCur40MhzPrimeSC = Offset;
  if (Adapter->bDriverStopped == 0 && Adapter->bSurpriseRemoved == 0) {
    _PHY_SetBWMode23a92C(Adapter);
  } else {
    pHalData->CurrentChannelBW = tmpBW;
  }
  return;
}
}
static void _PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel )
{
  u8 eRFPath ;
  u32 param1 ;
  u32 param2 ;
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if ((unsigned int )Adapter->bNotifyChannelChange != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: [%s] ch = %d\n", "_PHY_SwChnl8723A", (int )channel);
    } else {
    }
  } else {
  }
  PHY_SetTxPowerLevel8723A(Adapter, (int )channel);
  param1 = 24U;
  param2 = (u32 )channel;
  eRFPath = 0U;
  goto ldv_54413;
  ldv_54412:
  pHalData->RfRegChnlVal[(int )eRFPath] = (pHalData->RfRegChnlVal[(int )eRFPath] & 4294966272U) | param2;
  PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH )eRFPath, param1, 1048575U, pHalData->RfRegChnlVal[(int )eRFPath]);
  eRFPath = (u8 )((int )eRFPath + 1);
  ldv_54413: ;
  if ((int )pHalData->NumTotalRFPath > (int )eRFPath) {
    goto ldv_54412;
  } else {
  }
  return;
}
}
void PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel )
{
  struct hal_data_8723a *pHalData ;
  u8 tmpchannel ;
  bool result ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  tmpchannel = pHalData->CurrentChannel;
  result = 1;
  if ((unsigned int )pHalData->rf_chip == 5U) {
    return;
  } else {
  }
  if ((unsigned int )channel == 0U) {
    channel = 1U;
  } else {
  }
  pHalData->CurrentChannel = channel;
  if (Adapter->bDriverStopped == 0 && Adapter->bSurpriseRemoved == 0) {
    _PHY_SwChnl8723A(Adapter, (int )channel);
    if (! result) {
      pHalData->CurrentChannel = tmpchannel;
    } else {
    }
  } else {
    pHalData->CurrentChannel = tmpchannel;
  }
  return;
}
}
void *ldv_kmem_cache_alloc_1628(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1634(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1636(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1638(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1639(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1640(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1641(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1642(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1643(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1644(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1670(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1678(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1686(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1680(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1676(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1684(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1685(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1681(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1682(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1683(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void rtl8723a_phy_rf6052set_bw(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  switch ((unsigned int )Bandwidth) {
  case 0U:
  pHalData->RfRegChnlVal[0] = (pHalData->RfRegChnlVal[0] & 4294964223U) | 1024U;
  PHY_SetRFReg(Adapter, 0, 24U, 1048575U, pHalData->RfRegChnlVal[0]);
  goto ldv_54255;
  case 1U:
  pHalData->RfRegChnlVal[0] = pHalData->RfRegChnlVal[0] & 4294964223U;
  PHY_SetRFReg(Adapter, 0, 24U, 1048575U, pHalData->RfRegChnlVal[0]);
  goto ldv_54255;
  default: ;
  goto ldv_54255;
  }
  ldv_54255: ;
  return;
}
}
void rtl823a_phy_rf6052setccktxpower(struct rtw_adapter *Adapter , u8 *pPowerlevel )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u32 TxAGC[2U] ;
  u32 tmpval ;
  bool TurboScanOff ;
  u8 idx1 ;
  u8 idx2 ;
  u8 *ptr ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pmlmeext = & Adapter->mlmeextpriv;
  TxAGC[0] = 0U;
  TxAGC[1] = 0U;
  tmpval = 0U;
  TurboScanOff = 0;
  if ((unsigned int )pHalData->EEPROMRegulatory != 0U || (unsigned int )pHalData->ExternalPA != 0U) {
    TurboScanOff = 1;
  } else {
  }
  if (pmlmeext->sitesurvey_res.state == 3) {
    TxAGC[0] = 1061109567U;
    TxAGC[1] = 1061109567U;
    TurboScanOff = 1;
    if ((int )TurboScanOff) {
      idx1 = 0U;
      goto ldv_54272;
      ldv_54271:
      TxAGC[(int )idx1] = (u32 )((((int )*(pPowerlevel + (unsigned long )idx1) | ((int )*(pPowerlevel + (unsigned long )idx1) << 8)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 16)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 24));
      if (TxAGC[(int )idx1] > 32U && (unsigned int )pHalData->ExternalPA != 0U) {
        TxAGC[(int )idx1] = 32U;
      } else {
      }
      idx1 = (u8 )((int )idx1 + 1);
      ldv_54272: ;
      if ((unsigned int )idx1 <= 1U) {
        goto ldv_54271;
      } else {
      }
    } else {
    }
  } else
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 1U) {
    TxAGC[0] = 269488144U;
    TxAGC[1] = 269488144U;
  } else
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 2U) {
    TxAGC[0] = 0U;
    TxAGC[1] = 0U;
  } else {
    idx1 = 0U;
    goto ldv_54275;
    ldv_54274:
    TxAGC[(int )idx1] = (u32 )((((int )*(pPowerlevel + (unsigned long )idx1) | ((int )*(pPowerlevel + (unsigned long )idx1) << 8)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 16)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 24));
    idx1 = (u8 )((int )idx1 + 1);
    ldv_54275: ;
    if ((unsigned int )idx1 <= 1U) {
      goto ldv_54274;
    } else {
    }
    if ((unsigned int )pHalData->EEPROMRegulatory == 0U) {
      tmpval = pHalData->MCSTxPowerLevelOriginalOffset[0][6] + (pHalData->MCSTxPowerLevelOriginalOffset[0][7] << 8);
      TxAGC[0] = TxAGC[0] + tmpval;
      tmpval = pHalData->MCSTxPowerLevelOriginalOffset[0][14] + (pHalData->MCSTxPowerLevelOriginalOffset[0][15] << 24);
      TxAGC[1] = TxAGC[1] + tmpval;
    } else {
    }
  }
  idx1 = 0U;
  goto ldv_54281;
  ldv_54280:
  ptr = (u8 *)(& TxAGC) + (unsigned long )idx1;
  idx2 = 0U;
  goto ldv_54278;
  ldv_54277: ;
  if ((unsigned int )*ptr > 63U) {
    *ptr = 63U;
  } else {
  }
  ptr = ptr + 1;
  idx2 = (u8 )((int )idx2 + 1);
  ldv_54278: ;
  if ((unsigned int )idx2 <= 3U) {
    goto ldv_54277;
  } else {
  }
  idx1 = (u8 )((int )idx1 + 1);
  ldv_54281: ;
  if ((unsigned int )idx1 <= 1U) {
    goto ldv_54280;
  } else {
  }
  tmpval = TxAGC[0] & 255U;
  PHY_SetBBReg(Adapter, 3592U, 65280U, tmpval);
  tmpval = TxAGC[0] >> 8;
  PHY_SetBBReg(Adapter, 2156U, 4294967040U, tmpval);
  tmpval = TxAGC[1] >> 24;
  PHY_SetBBReg(Adapter, 2156U, 255U, tmpval);
  tmpval = TxAGC[1] & 16777215U;
  PHY_SetBBReg(Adapter, 2104U, 4294967040U, tmpval);
  return;
}
}
static void getPowerBase(struct rtw_adapter *Adapter , u8 *pPowerLevel , u8 Channel ,
                         u32 *OfdmBase , u32 *MCSBase )
{
  struct hal_data_8723a *pHalData ;
  u32 powerBase0 ;
  u32 powerBase1 ;
  u8 Legacy_pwrdiff ;
  s8 HT20_pwrdiff ;
  u8 i ;
  u8 powerlevel[2U] ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  Legacy_pwrdiff = 0U;
  HT20_pwrdiff = 0;
  i = 0U;
  goto ldv_54298;
  ldv_54297:
  powerlevel[(int )i] = *(pPowerLevel + (unsigned long )i);
  Legacy_pwrdiff = pHalData->TxPwrLegacyHtDiff[(int )i][(int )Channel + -1];
  powerBase0 = (u32 )((int )powerlevel[(int )i] + (int )Legacy_pwrdiff);
  powerBase0 = (((powerBase0 << 24) | (powerBase0 << 16)) | (powerBase0 << 8)) | powerBase0;
  *(OfdmBase + (unsigned long )i) = powerBase0;
  i = (u8 )((int )i + 1);
  ldv_54298: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_54297;
  } else {
  }
  i = 0U;
  goto ldv_54301;
  ldv_54300: ;
  if ((unsigned int )pHalData->CurrentChannelBW == 0U) {
    HT20_pwrdiff = (s8 )pHalData->TxPwrHt20Diff[(int )i][(int )Channel + -1];
    powerlevel[(int )i] = (int )powerlevel[(int )i] + (int )((u8 )HT20_pwrdiff);
  } else {
  }
  powerBase1 = (u32 )powerlevel[(int )i];
  powerBase1 = (((powerBase1 << 24) | (powerBase1 << 16)) | (powerBase1 << 8)) | powerBase1;
  *(MCSBase + (unsigned long )i) = powerBase1;
  i = (u8 )((int )i + 1);
  ldv_54301: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_54300;
  } else {
  }
  return;
}
}
static void getTxPowerWriteValByRegulatory(struct rtw_adapter *Adapter , u8 Channel ,
                                           u8 index , u32 *powerBase0 , u32 *powerBase1 ,
                                           u32 *pOutWriteVal )
{
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 i ;
  u8 chnlGroup ;
  u8 pwr_diff_limit[4U] ;
  u32 writeVal ;
  u32 customer_limit ;
  u32 rf ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  chnlGroup = 0U;
  rf = 0U;
  goto ldv_54329;
  ldv_54328: ;
  switch ((int )pHalData->EEPROMRegulatory) {
  case 0:
  chnlGroup = 0U;
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
  goto ldv_54320;
  case 1: ;
  if ((unsigned int )pHalData->pwrGroupCnt == 1U) {
    chnlGroup = 0U;
  } else {
  }
  if ((unsigned int )pHalData->pwrGroupCnt > 2U) {
    if ((unsigned int )Channel <= 3U) {
      chnlGroup = 0U;
    } else
    if ((unsigned int )Channel > 3U && (unsigned int )Channel <= 9U) {
      chnlGroup = 1U;
    } else
    if ((unsigned int )Channel > 9U) {
      chnlGroup = 2U;
    } else {
    }
    if ((unsigned int )pHalData->CurrentChannelBW == 0U) {
      chnlGroup = (u8 )((int )chnlGroup + 1);
    } else {
      chnlGroup = (unsigned int )chnlGroup + 4U;
    }
  } else {
  }
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
  goto ldv_54320;
  case 2:
  writeVal = (unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf);
  goto ldv_54320;
  case 3:
  chnlGroup = 0U;
  i = 0U;
  goto ldv_54325;
  ldv_54324:
  pwr_diff_limit[(int )i] = (unsigned char )((pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] & (u32 )(127 << (int )i * 8)) >> (int )i * 8);
  if ((unsigned int )pHalData->CurrentChannelBW == 1U) {
    if ((int )pwr_diff_limit[(int )i] > (int )pHalData->PwrGroupHT40[rf][(int )Channel + -1]) {
      pwr_diff_limit[(int )i] = pHalData->PwrGroupHT40[rf][(int )Channel + -1];
    } else {
    }
  } else
  if ((int )pwr_diff_limit[(int )i] > (int )pHalData->PwrGroupHT20[rf][(int )Channel + -1]) {
    pwr_diff_limit[(int )i] = pHalData->PwrGroupHT20[rf][(int )Channel + -1];
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54325: ;
  if ((unsigned int )i <= 3U) {
    goto ldv_54324;
  } else {
  }
  customer_limit = (u32 )(((((int )pwr_diff_limit[3] << 24) | ((int )pwr_diff_limit[2] << 16)) | ((int )pwr_diff_limit[1] << 8)) | (int )pwr_diff_limit[0]);
  writeVal = ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf)) + customer_limit;
  goto ldv_54320;
  default:
  chnlGroup = 0U;
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
  goto ldv_54320;
  }
  ldv_54320: ;
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 1U) {
    writeVal = 336860180U;
  } else
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 2U) {
    writeVal = 0U;
  } else {
  }
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 3U) {
    writeVal = writeVal - 101058054U;
  } else
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 4U) {
    writeVal = writeVal;
  } else {
  }
  *(pOutWriteVal + (unsigned long )rf) = writeVal;
  rf = rf + 1U;
  ldv_54329: ;
  if (rf <= 1U) {
    goto ldv_54328;
  } else {
  }
  return;
}
}
static void writeOFDMPowerReg(struct rtw_adapter *Adapter , u8 index , u32 *pValue )
{
  struct hal_data_8723a *pHalData ;
  u16 RegOffset_A[6U] ;
  u16 RegOffset_B[6U] ;
  u8 i ;
  u8 rf ;
  u8 pwr_val[4U] ;
  u32 writeVal ;
  u16 RegOffset ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  RegOffset_A[0] = 3584U;
  RegOffset_A[1] = 3588U;
  RegOffset_A[2] = 3600U;
  RegOffset_A[3] = 3604U;
  RegOffset_A[4] = 3608U;
  RegOffset_A[5] = 3612U;
  RegOffset_B[0] = 2096U;
  RegOffset_B[1] = 2100U;
  RegOffset_B[2] = 2108U;
  RegOffset_B[3] = 2120U;
  RegOffset_B[4] = 2124U;
  RegOffset_B[5] = 2152U;
  rf = 0U;
  goto ldv_54351;
  ldv_54350:
  writeVal = *(pValue + (unsigned long )rf);
  i = 0U;
  goto ldv_54345;
  ldv_54344:
  pwr_val[(int )i] = (unsigned char )(((u32 )(127 << (int )i * 8) & writeVal) >> (int )i * 8);
  if ((unsigned int )pwr_val[(int )i] > 63U) {
    pwr_val[(int )i] = 63U;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54345: ;
  if ((unsigned int )i <= 3U) {
    goto ldv_54344;
  } else {
  }
  writeVal = (u32 )(((((int )pwr_val[3] << 24) | ((int )pwr_val[2] << 16)) | ((int )pwr_val[1] << 8)) | (int )pwr_val[0]);
  if ((unsigned int )rf == 0U) {
    RegOffset = RegOffset_A[(int )index];
  } else {
    RegOffset = RegOffset_B[(int )index];
  }
  PHY_SetBBReg(Adapter, (u32 )RegOffset, 4294967295U, writeVal);
  if (((unsigned int )pHalData->rf_type == 2U && ((unsigned int )RegOffset == 3612U || (unsigned int )RegOffset == 2152U)) || ((unsigned int )pHalData->rf_type != 2U && ((unsigned int )RegOffset == 3604U || (unsigned int )RegOffset == 2120U))) {
    writeVal = (u32 )pwr_val[3];
    if ((unsigned int )RegOffset == 3612U || (unsigned int )RegOffset == 3604U) {
      RegOffset = 3216U;
    } else {
    }
    if ((unsigned int )RegOffset == 2152U || (unsigned int )RegOffset == 2120U) {
      RegOffset = 3224U;
    } else {
    }
    i = 0U;
    goto ldv_54348;
    ldv_54347: ;
    if ((unsigned int )i != 2U) {
      writeVal = writeVal > 8U ? writeVal - 8U : 0U;
    } else {
      writeVal = writeVal > 6U ? writeVal - 6U : 0U;
    }
    rtl8723au_write8(Adapter, (u32 )((int )RegOffset + (int )i), (int )((unsigned char )writeVal));
    i = (u8 )((int )i + 1);
    ldv_54348: ;
    if ((unsigned int )i <= 2U) {
      goto ldv_54347;
    } else {
    }
  } else {
  }
  rf = (u8 )((int )rf + 1);
  ldv_54351: ;
  if ((unsigned int )rf <= 1U) {
    goto ldv_54350;
  } else {
  }
  return;
}
}
void rtl8723a_PHY_RF6052SetOFDMTxPower(struct rtw_adapter *Adapter , u8 *pPowerLevel ,
                                       u8 Channel )
{
  u32 writeVal[2U] ;
  u32 powerBase0[2U] ;
  u32 powerBase1[2U] ;
  u8 index ;
  {
  index = 0U;
  getPowerBase(Adapter, pPowerLevel, (int )Channel, (u32 *)(& powerBase0), (u32 *)(& powerBase1));
  index = 0U;
  goto ldv_54363;
  ldv_54362:
  getTxPowerWriteValByRegulatory(Adapter, (int )Channel, (int )index, (u32 *)(& powerBase0),
                                 (u32 *)(& powerBase1), (u32 *)(& writeVal));
  writeOFDMPowerReg(Adapter, (int )index, (u32 *)(& writeVal));
  index = (u8 )((int )index + 1);
  ldv_54363: ;
  if ((unsigned int )index <= 5U) {
    goto ldv_54362;
  } else {
  }
  return;
}
}
static int phy_RF6052_Config_ParaFile(struct rtw_adapter *Adapter )
{
  u32 u4RegValue ;
  u8 eRFPath ;
  struct bb_reg_define *pPhyReg ;
  int rtStatus ;
  struct hal_data_8723a *pHalData ;
  int tmp ;
  int tmp___0 ;
  {
  u4RegValue = 0U;
  rtStatus = 1;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  eRFPath = 0U;
  goto ldv_54384;
  ldv_54383:
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
  switch ((int )eRFPath) {
  case 0:
  u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, 16U);
  goto ldv_54374;
  case 1:
  u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, 1048576U);
  goto ldv_54374;
  }
  ldv_54374:
  PHY_SetBBReg(Adapter, pPhyReg->rfintfe, 1048576U, 1U);
  __const_udelay(4295UL);
  PHY_SetBBReg(Adapter, pPhyReg->rfintfo, 16U, 1U);
  __const_udelay(4295UL);
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 1024U, 0U);
  __const_udelay(4295UL);
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 2048U, 0U);
  __const_udelay(4295UL);
  switch ((int )eRFPath) {
  case 0:
  tmp = ODM_ConfigRFWithHeaderFile23a(& pHalData->odmpriv, (enum RF_RADIO_PATH )eRFPath,
                                      (enum RF_RADIO_PATH )eRFPath);
  if (tmp == 0) {
    rtStatus = 0;
  } else {
  }
  goto ldv_54377;
  case 1:
  tmp___0 = ODM_ConfigRFWithHeaderFile23a(& pHalData->odmpriv, (enum RF_RADIO_PATH )eRFPath,
                                          (enum RF_RADIO_PATH )eRFPath);
  if (tmp___0 == 0) {
    rtStatus = 0;
  } else {
  }
  goto ldv_54377;
  }
  ldv_54377: ;
  switch ((int )eRFPath) {
  case 0:
  PHY_SetBBReg(Adapter, pPhyReg->rfintfs, 16U, u4RegValue);
  goto ldv_54380;
  case 1:
  PHY_SetBBReg(Adapter, pPhyReg->rfintfs, 1048576U, u4RegValue);
  goto ldv_54380;
  }
  ldv_54380: ;
  if (rtStatus != 1) {
    goto phy_RF6052_Config_ParaFile_Fail;
  } else {
  }
  eRFPath = (u8 )((int )eRFPath + 1);
  ldv_54384: ;
  if ((int )pHalData->NumTotalRFPath > (int )eRFPath) {
    goto ldv_54383;
  } else {
  }
  phy_RF6052_Config_ParaFile_Fail: ;
  return (rtStatus);
}
}
int PHY_RF6052_Config8723A(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  int rtStatus ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  rtStatus = 1;
  if ((unsigned int )pHalData->rf_type == 3U) {
    pHalData->NumTotalRFPath = 1U;
  } else {
    pHalData->NumTotalRFPath = 2U;
  }
  rtStatus = phy_RF6052_Config_ParaFile(Adapter);
  return (rtStatus);
}
}
void *ldv_kmem_cache_alloc_1670(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1676(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1678(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1680(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1681(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1682(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1683(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1684(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1685(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1686(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1712(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1720(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1728(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1722(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1718(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1726(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1727(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1723(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1724(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1725(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void rtl8723a_process_phy_info(struct rtw_adapter *padapter , void *prframe ) ;
static void process_rssi(struct rtw_adapter *padapter , struct recv_frame *prframe )
{
  struct rx_pkt_attrib *pattrib ;
  struct signal_stat *signal_stat ;
  {
  pattrib = & prframe->attrib;
  signal_stat = & padapter->recvpriv.signal_strength_data;
  if ((unsigned int )signal_stat->update_req != 0U) {
    signal_stat->total_num = 0U;
    signal_stat->total_val = 0U;
    signal_stat->update_req = 0U;
  } else {
  }
  signal_stat->total_num = signal_stat->total_num + 1U;
  signal_stat->total_val = signal_stat->total_val + (u32 )pattrib->phy_info.SignalStrength;
  signal_stat->avg_val = (u8 )(signal_stat->total_val / signal_stat->total_num);
  return;
}
}
static void process_link_qual(struct rtw_adapter *padapter , struct recv_frame *prframe )
{
  struct rx_pkt_attrib *pattrib ;
  struct signal_stat *signal_stat ;
  {
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0) || (unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {
  }
  pattrib = & prframe->attrib;
  signal_stat = & padapter->recvpriv.signal_qual_data;
  if ((unsigned int )signal_stat->update_req != 0U) {
    signal_stat->total_num = 0U;
    signal_stat->total_val = 0U;
    signal_stat->update_req = 0U;
  } else {
  }
  signal_stat->total_num = signal_stat->total_num + 1U;
  signal_stat->total_val = signal_stat->total_val + (u32 )pattrib->phy_info.SignalQuality;
  signal_stat->avg_val = (u8 )(signal_stat->total_val / signal_stat->total_num);
  return;
}
}
void rtl8723a_process_phy_info(struct rtw_adapter *padapter , void *prframe )
{
  struct recv_frame *precvframe ;
  {
  precvframe = (struct recv_frame *)prframe;
  process_rssi(padapter, precvframe);
  process_link_qual(padapter, precvframe);
  return;
}
}
void *ldv_kmem_cache_alloc_1712(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1718(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1720(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1722(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1723(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1724(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1725(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1726(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1727(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1728(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1754(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1762(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1770(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1764(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1760(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1768(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1769(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1765(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1766(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1767(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void rtl8723a_sreset_xmit_status_check(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  unsigned long current_time ;
  struct xmit_priv *pxmitpriv ;
  unsigned int diff_time ;
  u32 txdma_status ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  pxmitpriv = & padapter->xmitpriv;
  txdma_status = rtl8723au_read32(padapter, 528U);
  if (txdma_status != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s REG_TXDMA_STATUS:0x%08x\n", "rtl8723a_sreset_xmit_status_check",
             txdma_status);
    } else {
    }
    rtw_sreset_reset(padapter);
  } else {
  }
  current_time = jiffies;
  if (pxmitpriv->free_xmitbuf_cnt == 0U || pxmitpriv->free_xmit_extbuf_cnt == 0U) {
    diff_time = jiffies_to_msecs((unsigned long )jiffies - psrtpriv->last_tx_time);
    if (diff_time > 2000U) {
      if (psrtpriv->last_tx_complete_time == 0UL) {
        psrtpriv->last_tx_complete_time = current_time;
      } else {
        diff_time = jiffies_to_msecs((unsigned long )jiffies - psrtpriv->last_tx_complete_time);
        if (diff_time > 4000U) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: %s tx hang\n", "rtl8723a_sreset_xmit_status_check");
          } else {
          }
          rtw_sreset_reset(padapter);
        } else {
        }
      }
    } else {
    }
  } else {
  }
  if (psrtpriv->dbg_trigger_point == 1) {
    psrtpriv->dbg_trigger_point = 0;
    rtw_sreset_reset(padapter);
    return;
  } else {
  }
  return;
}
}
void rtl8723a_sreset_linked_status_check(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  psrtpriv = & pHalData->srestpriv;
  if (psrtpriv->dbg_trigger_point == 2) {
    psrtpriv->dbg_trigger_point = 0;
    rtw_sreset_reset(padapter);
    return;
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_1754(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1760(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1762(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1764(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1765(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1766(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1767(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1768(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1769(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1770(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1796(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1804(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1812(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1806(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1802(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1810(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1811(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1807(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1808(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1809(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void dump_txrpt_ccx_8723a(void *buf ) ;
void dump_txrpt_ccx_8723a(void *buf )
{
  struct txrpt_ccx_8723a *txrpt_ccx ;
  {
  txrpt_ccx = (struct txrpt_ccx_8723a *)buf;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s:\ntag1:%u, rsvd:%u, int_bt:%u, int_tri:%u, int_ccx:%u\nmac_id:%u, pkt_drop:%u, pkt_ok:%u, bmc:%u\nretry_cnt:%u, lifetime_over:%u, retry_over:%u\nccx_qtime:%u\nfinal_data_rate:0x%02x\nqsel:%u, sw:0x%03x\n",
           "dump_txrpt_ccx_8723a", (int )txrpt_ccx->tag1, (int )txrpt_ccx->rsvd, (int )txrpt_ccx->int_bt,
           (int )txrpt_ccx->int_tri, (int )txrpt_ccx->int_ccx, (int )txrpt_ccx->mac_id,
           (int )txrpt_ccx->pkt_drop, (int )txrpt_ccx->pkt_ok, (int )txrpt_ccx->bmc,
           (int )txrpt_ccx->retry_cnt, (int )txrpt_ccx->lifetime_over, (int )txrpt_ccx->retry_over,
           (int )txrpt_ccx->ccx_qtime0 + ((int )txrpt_ccx->ccx_qtime1 << 8), (int )txrpt_ccx->final_data_rate,
           (int )txrpt_ccx->qsel, (int )txrpt_ccx->sw0 + ((int )txrpt_ccx->sw1 << 8));
  } else {
  }
  return;
}
}
void handle_txrpt_ccx_8723a(struct rtw_adapter *adapter , void *buf )
{
  struct txrpt_ccx_8723a *txrpt_ccx ;
  {
  txrpt_ccx = (struct txrpt_ccx_8723a *)buf;
  if ((unsigned int )*((unsigned char *)txrpt_ccx + 0UL) != 0U) {
    if ((unsigned int )*((unsigned char *)txrpt_ccx + 1UL) != 0U) {
      rtw_ack_tx_done23a(& adapter->xmitpriv, 0);
    } else {
      rtw_ack_tx_done23a(& adapter->xmitpriv, 8);
    }
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_1796(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1802(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1804(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1806(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1807(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1808(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1809(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1810(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1811(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1812(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1838(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1846(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1854(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1848(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1844(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1852(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1853(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1849(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1850(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1851(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void rtl8723au_InitSwLeds(struct rtw_adapter *padapter ) ;
void rtl8723au_DeInitSwLeds(struct rtw_adapter *padapter ) ;
void SwLedOn23a(struct rtw_adapter *padapter , struct led_8723a *pLed )
{
  u8 LedCfg ;
  {
  LedCfg = 0U;
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
    return;
  } else {
  }
  switch ((unsigned int )pLed->LedPin) {
  case 4U: ;
  goto ldv_54259;
  case 1U:
  rtl8723au_write8(padapter, 76U, (int )(((unsigned int )LedCfg & 144U) | 96U));
  goto ldv_54259;
  case 2U:
  rtl8723au_write8(padapter, 77U, 64);
  goto ldv_54259;
  case 3U:
  LedCfg = rtl8723au_read8(padapter, 78U);
  rtl8723au_write8(padapter, 78U, (int )(((unsigned int )LedCfg & 128U) | 32U));
  goto ldv_54259;
  default: ;
  goto ldv_54259;
  }
  ldv_54259:
  pLed->bLedOn = 1U;
  return;
}
}
void SwLedOff23a(struct rtw_adapter *padapter , struct led_8723a *pLed )
{
  u8 LedCfg ;
  {
  LedCfg = 0U;
  if (padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) {
    goto exit;
  } else {
  }
  switch ((unsigned int )pLed->LedPin) {
  case 4U: ;
  goto ldv_54271;
  case 1U:
  rtl8723au_write8(padapter, 76U, (int )(((unsigned int )LedCfg & 144U) | 96U));
  goto ldv_54271;
  case 2U:
  rtl8723au_write8(padapter, 77U, 96);
  goto ldv_54271;
  case 3U:
  LedCfg = rtl8723au_read8(padapter, 78U);
  rtl8723au_write8(padapter, 78U, (int )(((unsigned int )LedCfg & 128U) | 40U));
  goto ldv_54271;
  default: ;
  goto ldv_54271;
  }
  ldv_54271: ;
  exit:
  pLed->bLedOn = 0U;
  return;
}
}
void rtl8723au_InitSwLeds(struct rtw_adapter *padapter )
{
  struct led_priv *pledpriv ;
  {
  pledpriv = & padapter->ledpriv;
  pledpriv->LedControlHandler = & LedControl871x23a;
  InitLed871x23a(padapter, & pledpriv->SwLed0, 3);
  return;
}
}
void rtl8723au_DeInitSwLeds(struct rtw_adapter *padapter )
{
  struct led_priv *ledpriv ;
  {
  ledpriv = & padapter->ledpriv;
  DeInitLed871x23a(& ledpriv->SwLed0);
  return;
}
}
void *ldv_kmem_cache_alloc_1838(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1844(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1846(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1848(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1849(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1850(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1851(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1852(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1853(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1854(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1880(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1888(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1896(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1890(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1886(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1894(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1895(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
__inline static __u32 skb_queue_len(struct sk_buff_head const *list_ )
{
  {
  return ((__u32 )list_->qlen);
}
}
__inline static void skb_queue_head_init(struct sk_buff_head *list )
{
  struct lock_class_key __key ;
  {
  spinlock_check(& list->lock);
  __raw_spin_lock_init(& list->lock.ldv_6347.rlock, "&(&list->lock)->rlock", & __key);
  __skb_queue_head_init(list);
  return;
}
}
extern void skb_queue_tail(struct sk_buff_head * , struct sk_buff * ) ;
__inline static void skb_reserve(struct sk_buff *skb , int len )
{
  {
  skb->data = skb->data + (unsigned long )len;
  skb->tail = skb->tail + (sk_buff_data_t )len;
  return;
}
}
extern void skb_queue_purge(struct sk_buff_head * ) ;
struct sk_buff *ldv___netdev_alloc_skb_1891(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1892(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1893(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1899(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
extern struct urb *usb_alloc_urb(int , gfp_t ) ;
struct urb *ldv_usb_alloc_urb_1897(int ldv_func_arg1 , gfp_t flags ) ;
struct urb *ldv_usb_alloc_urb_1898(int ldv_func_arg1 , gfp_t flags ) ;
extern void usb_free_urb(struct urb * ) ;
void rtl8723au_recv_tasklet(void *priv ) ;
void update_recvframe_attrib(struct recv_frame *precvframe , struct recv_stat *prxstat ) ;
void update_recvframe_phyinfo(struct recv_frame *precvframe , struct phy_stat *pphy_status ) ;
int rtl8723au_init_recv_priv(struct rtw_adapter *padapter )
{
  struct recv_priv *precvpriv ;
  int i ;
  int size ;
  int res ;
  struct recv_buf *precvbuf ;
  unsigned long tmpaddr ;
  unsigned long alignment ;
  struct sk_buff *pskb ;
  void *tmp ;
  void *tmp___0 ;
  {
  precvpriv = & padapter->recvpriv;
  res = 1;
  tasklet_init(& precvpriv->recv_tasklet, (void (*)(unsigned long ))(& rtl8723au_recv_tasklet),
               (unsigned long )padapter);
  precvpriv->int_in_urb = ldv_usb_alloc_urb_1897(0, 208U);
  if ((unsigned long )precvpriv->int_in_urb == (unsigned long )((struct urb *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: alloc_urb for interrupt in endpoint fail !!!!\n");
    } else {
    }
  } else {
  }
  tmp = kzalloc(56UL, 208U);
  precvpriv->int_in_buf = (u8 *)tmp;
  if ((unsigned long )precvpriv->int_in_buf == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: alloc_mem for interrupt in endpoint fail !!!!\n");
    } else {
    }
  } else {
  }
  size = 160;
  tmp___0 = kzalloc((size_t )size, 208U);
  precvpriv->precv_buf = (u8 *)tmp___0;
  if ((unsigned long )precvpriv->precv_buf == (unsigned long )((u8 *)0U)) {
    res = 0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016alloc recv_buf fail!\n");
    } else {
    }
    goto exit;
  } else {
  }
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
  i = 0;
  goto ldv_54320;
  ldv_54319:
  INIT_LIST_HEAD(& precvbuf->list);
  precvbuf->purb = ldv_usb_alloc_urb_1898(0, 208U);
  if ((unsigned long )precvbuf->purb == (unsigned long )((struct urb *)0)) {
    goto ldv_54318;
  } else {
  }
  precvbuf->adapter = padapter;
  precvbuf = precvbuf + 1;
  i = i + 1;
  ldv_54320: ;
  if (i <= 3) {
    goto ldv_54319;
  } else {
  }
  ldv_54318:
  skb_queue_head_init(& precvpriv->rx_skb_queue);
  skb_queue_head_init(& precvpriv->free_recv_skb_queue);
  i = 0;
  goto ldv_54322;
  ldv_54321:
  size = 15368;
  pskb = ldv___netdev_alloc_skb_1899(padapter->pnetdev, (unsigned int )size, 208U);
  if ((unsigned long )pskb != (unsigned long )((struct sk_buff *)0)) {
    pskb->dev = padapter->pnetdev;
    tmpaddr = (unsigned long )pskb->data;
    alignment = tmpaddr & 7UL;
    skb_reserve(pskb, (int )(8U - (unsigned int )alignment));
    skb_queue_tail(& precvpriv->free_recv_skb_queue, pskb);
  } else {
  }
  pskb = (struct sk_buff *)0;
  i = i + 1;
  ldv_54322: ;
  if (i <= 7) {
    goto ldv_54321;
  } else {
  }
  exit: ;
  return (res);
}
}
void rtl8723au_free_recv_priv(struct rtw_adapter *padapter )
{
  int i ;
  struct recv_buf *precvbuf ;
  struct recv_priv *precvpriv ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  {
  precvpriv = & padapter->recvpriv;
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
  i = 0;
  goto ldv_54331;
  ldv_54330:
  usb_free_urb(precvbuf->purb);
  if ((unsigned long )precvbuf->pskb != (unsigned long )((struct sk_buff *)0)) {
    dev_kfree_skb_any(precvbuf->pskb);
  } else {
  }
  precvbuf = precvbuf + 1;
  i = i + 1;
  ldv_54331: ;
  if (i <= 3) {
    goto ldv_54330;
  } else {
  }
  kfree((void const *)precvpriv->precv_buf);
  usb_free_urb(precvpriv->int_in_urb);
  kfree((void const *)precvpriv->int_in_buf);
  tmp = skb_queue_len((struct sk_buff_head const *)(& precvpriv->rx_skb_queue));
  if (tmp != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \frx_skb_queue not empty\n");
    } else {
    }
  } else {
  }
  skb_queue_purge(& precvpriv->rx_skb_queue);
  tmp___1 = skb_queue_len((struct sk_buff_head const *)(& precvpriv->free_recv_skb_queue));
  if (tmp___1 != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      tmp___0 = skb_queue_len((struct sk_buff_head const *)(& precvpriv->free_recv_skb_queue));
      printk("\016RTL8723AU: \ffree_recv_skb_queue not empty, %d\n", tmp___0);
    } else {
    }
  } else {
  }
  skb_queue_purge(& precvpriv->free_recv_skb_queue);
  return;
}
}
void update_recvframe_attrib(struct recv_frame *precvframe , struct recv_stat *prxstat )
{
  struct rx_pkt_attrib *pattrib ;
  struct recv_stat_cpu report ;
  struct rxreport_8723a *prxreport ;
  {
  report.rxdw0 = prxstat->rxdw0;
  report.rxdw1 = prxstat->rxdw1;
  report.rxdw2 = prxstat->rxdw2;
  report.rxdw3 = prxstat->rxdw3;
  report.rxdw4 = prxstat->rxdw4;
  report.rxdw5 = prxstat->rxdw5;
  prxreport = (struct rxreport_8723a *)(& report);
  pattrib = & precvframe->attrib;
  memset((void *)pattrib, 0, 96UL);
  pattrib->pkt_len = prxreport->pktlen;
  pattrib->drvinfo_sz = (int )prxreport->drvinfosize << 3U;
  pattrib->physt = prxreport->physt;
  pattrib->crc_err = prxreport->crc32;
  pattrib->icv_err = prxreport->icverr;
  pattrib->bdecrypted = (unsigned int )*((unsigned char *)prxreport + 3UL) == 0U;
  pattrib->encrypt = (u32 )prxreport->security;
  pattrib->qos = prxreport->qos;
  pattrib->priority = prxreport->tid;
  pattrib->amsdu = prxreport->amsdu;
  pattrib->seq_num = prxreport->seq;
  pattrib->frag_num = prxreport->frag;
  pattrib->mfrag = prxreport->mf;
  pattrib->mdata = prxreport->md;
  pattrib->mcs_rate = prxreport->rxmcs;
  pattrib->rxht = prxreport->rxht;
  return;
}
}
void update_recvframe_phyinfo(struct recv_frame *precvframe , struct phy_stat *pphy_status )
{
  struct rtw_adapter *padapter ;
  struct rx_pkt_attrib *pattrib ;
  struct hal_data_8723a *pHalData ;
  struct phy_info *pPHYInfo ;
  struct odm_packet_info pkt_info ;
  u8 *sa ;
  u8 *da ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  bool matchbssid ;
  u8 *bssid ;
  int tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  {
  padapter = precvframe->adapter;
  pattrib = & precvframe->attrib;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pPHYInfo = & pattrib->phy_info;
  sa = (u8 *)0U;
  skb = precvframe->pkt;
  hdr = (struct ieee80211_hdr *)skb->data;
  matchbssid = 0;
  tmp = ieee80211_is_ctl((int )hdr->frame_control);
  matchbssid = (bool )((tmp == 0 && (unsigned int )pattrib->icv_err == 0U) && (unsigned int )pattrib->crc_err == 0U);
  if ((int )matchbssid) {
    switch ((int )hdr->frame_control & 768) {
    case 256:
    bssid = (u8 *)(& hdr->addr1);
    goto ldv_54365;
    case 512:
    bssid = (u8 *)(& hdr->addr2);
    goto ldv_54365;
    case 0:
    bssid = (u8 *)(& hdr->addr3);
    goto ldv_54365;
    default:
    bssid = (u8 *)0U;
    matchbssid = 0;
    }
    ldv_54365: ;
    if ((unsigned long )bssid != (unsigned long )((u8 *)0U)) {
      tmp___0 = get_bssid(& padapter->mlmepriv);
      matchbssid = ether_addr_equal((u8 const *)tmp___0, (u8 const *)bssid);
    } else {
    }
  } else {
  }
  pkt_info.bPacketMatchBSSID = matchbssid;
  da = ieee80211_get_DA(hdr);
  if ((int )pkt_info.bPacketMatchBSSID) {
    tmp___1 = myid(& padapter->eeprompriv);
    tmp___2 = memcmp((void const *)da, (void const *)tmp___1, 6UL);
    if (tmp___2 == 0) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  pkt_info.bPacketToSelf = (bool )tmp___3;
  if ((int )pkt_info.bPacketMatchBSSID) {
    tmp___4 = ieee80211_is_beacon((int )hdr->frame_control);
    if (tmp___4 != 0) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
  } else {
    tmp___5 = 0;
  }
  pkt_info.bPacketBeacon = (bool )tmp___5;
  pkt_info.StationID = 255U;
  if ((int )pkt_info.bPacketBeacon) {
    tmp___6 = check_fwstate(& padapter->mlmepriv, 8);
    if ((int )tmp___6) {
      sa = (u8 *)(& padapter->mlmepriv.cur_network.network.MacAddress);
    } else {
    }
  } else {
    sa = ieee80211_get_SA(hdr);
  }
  pstapriv = & padapter->stapriv;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)sa);
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    pkt_info.StationID = (u8 )psta->mac_id;
  } else {
  }
  pkt_info.Rate = pattrib->mcs_rate;
  ODM_PhyStatusQuery23a(& pHalData->odmpriv, pPHYInfo, (u8 *)pphy_status, & pkt_info);
  precvframe->psta = (struct sta_info *)0;
  if ((int )pkt_info.bPacketMatchBSSID) {
    tmp___8 = check_fwstate(& padapter->mlmepriv, 16);
    if ((int )tmp___8) {
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
        precvframe->psta = psta;
        rtl8723a_process_phy_info(padapter, (void *)precvframe);
      } else {
      }
    } else {
      goto _L;
    }
  } else
  _L:
  if ((int )pkt_info.bPacketToSelf || (int )pkt_info.bPacketBeacon) {
    tmp___7 = check_fwstate(& padapter->mlmepriv, 96);
    if ((int )tmp___7) {
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
        precvframe->psta = psta;
      } else {
      }
    } else {
    }
    rtl8723a_process_phy_info(padapter, (void *)precvframe);
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_1880(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1886(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1888(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1890(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1891(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1892(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1893(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1894(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1895(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1896(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct urb *ldv_usb_alloc_urb_1897(int ldv_func_arg1 , gfp_t flags )
{
  struct urb *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = usb_alloc_urb(ldv_func_arg1, flags);
  return (tmp);
}
}
struct urb *ldv_usb_alloc_urb_1898(int ldv_func_arg1 , gfp_t flags )
{
  struct urb *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = usb_alloc_urb(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1899(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
void *ldv_kmem_cache_alloc_1928(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1936(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1944(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1938(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1934(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1942(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1943(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1939(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1940(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1941(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
int rtl8723au_write_port(struct rtw_adapter *padapter , u32 addr , u32 cnt , struct xmit_buf *pxmitbuf ) ;
bool rtl8723au_xmitframe_complete(struct rtw_adapter *padapter , struct xmit_priv *pxmitpriv ,
                                  struct xmit_buf *pxmitbuf ) ;
static void do_queue_select___0(struct rtw_adapter *padapter , struct pkt_attrib *pattrib )
{
  u8 qsel ;
  {
  qsel = pattrib->priority;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016### do_queue_select priority =%d , qsel = %d\n", (int )pattrib->priority,
           (int )qsel);
  } else {
  }
  pattrib->qsel = qsel;
  return;
}
}
static int urb_zero_packet_chk(struct rtw_adapter *padapter , int sz )
{
  int blnSetTxDescOffset ;
  struct dvobj_priv *pdvobj ;
  {
  pdvobj = padapter->dvobj;
  if ((unsigned int )pdvobj->ishighspeed != 0U) {
    if (((unsigned int )(sz + 32) & 511U) == 0U) {
      blnSetTxDescOffset = 1;
    } else {
      blnSetTxDescOffset = 0;
    }
  } else
  if (((unsigned int )(sz + 32) & 63U) == 0U) {
    blnSetTxDescOffset = 1;
  } else {
    blnSetTxDescOffset = 0;
  }
  return (blnSetTxDescOffset);
}
}
static void rtl8192cu_cal_txdesc_chksum(struct tx_desc *ptxdesc )
{
  u16 *usPtr ;
  u32 count ;
  u32 index ;
  u16 checksum ;
  {
  usPtr = (u16 *)ptxdesc;
  count = 16U;
  checksum = 0U;
  ptxdesc->txdw7 = ptxdesc->txdw7 & 4294901760U;
  index = 0U;
  goto ldv_54281;
  ldv_54280:
  checksum = (u16 )((int )*(usPtr + (unsigned long )index) ^ (int )checksum);
  index = index + 1U;
  ldv_54281: ;
  if (index < count) {
    goto ldv_54280;
  } else {
  }
  ptxdesc->txdw7 = ptxdesc->txdw7 | (__le32 )checksum;
  return;
}
}
static void fill_txdesc_sectype___0(struct pkt_attrib *pattrib , struct tx_desc *ptxdesc )
{
  {
  if (pattrib->encrypt != 0U && (unsigned int )pattrib->bswenc == 0U) {
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U:
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4194304U;
    goto ldv_54289;
    case 1027074U:
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4194304U;
    goto ldv_54289;
    case 1027076U:
    ptxdesc->txdw1 = ptxdesc->txdw1 | 12582912U;
    goto ldv_54289;
    case 0U: ;
    default: ;
    goto ldv_54289;
    }
    ldv_54289: ;
  } else {
  }
  return;
}
}
static void fill_txdesc_vcs___0(struct pkt_attrib *pattrib , u32 *pdw )
{
  {
  switch ((int )pattrib->vcs_mode) {
  case 1:
  *pdw = *pdw | 4096U;
  goto ldv_54299;
  case 2:
  *pdw = *pdw | 2048U;
  goto ldv_54299;
  case 0: ;
  default: ;
  goto ldv_54299;
  }
  ldv_54299: ;
  if ((unsigned int )pattrib->vcs_mode != 0U) {
    *pdw = *pdw | 8192U;
    if ((unsigned int )pattrib->ht_en != 0U) {
      *pdw = *pdw | ((int )pattrib->bwmode & 1 ? 134217728U : 0U);
      if ((unsigned int )pattrib->ch_offset == 1U) {
        *pdw = *pdw | 268435456U;
      } else
      if ((unsigned int )pattrib->ch_offset == 2U) {
        *pdw = *pdw | 536870912U;
      } else
      if ((unsigned int )pattrib->ch_offset == 0U) {
        *pdw = *pdw;
      } else {
        *pdw = *pdw | 805306368U;
      }
    } else {
    }
  } else {
  }
  return;
}
}
static void fill_txdesc_phy___0(struct pkt_attrib *pattrib , u32 *pdw )
{
  {
  if ((unsigned int )pattrib->ht_en != 0U) {
    *pdw = *pdw | ((int )pattrib->bwmode & 1 ? 33554432U : 0U);
    if ((unsigned int )pattrib->ch_offset == 1U) {
      *pdw = *pdw | 1048576U;
    } else
    if ((unsigned int )pattrib->ch_offset == 2U) {
      *pdw = *pdw | 2097152U;
    } else
    if ((unsigned int )pattrib->ch_offset == 0U) {
      *pdw = *pdw;
    } else {
      *pdw = *pdw | 3145728U;
    }
  } else {
  }
  return;
}
}
static s32 update_txdesc(struct xmit_frame *pxmitframe , u8 *pmem , s32 sz , u8 bagg_pkt )
{
  int pull ;
  uint qsel ;
  struct rtw_adapter *padapter ;
  struct pkt_attrib *pattrib ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct tx_desc *ptxdesc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bmcst ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  {
  pull = 0;
  padapter = pxmitframe->padapter;
  pattrib = & pxmitframe->attrib;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  ptxdesc = (struct tx_desc *)pmem;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  tmp = is_multicast_ether_addr((u8 const *)(& pattrib->ra));
  bmcst = (int )tmp;
  if ((unsigned int )bagg_pkt == 0U) {
    tmp___0 = urb_zero_packet_chk(padapter, sz);
    if (tmp___0 == 0) {
      ptxdesc = (struct tx_desc *)pmem + 8U;
      pull = 1;
      pxmitframe->pkt_offset = (s8 )((int )pxmitframe->pkt_offset - 1);
    } else {
    }
  } else {
  }
  memset((void *)ptxdesc, 0, 32UL);
  if ((pxmitframe->frame_tag & 15) == 1) {
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )pattrib->mac_id & 31U);
    qsel = (unsigned int )pattrib->qsel & 31U;
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((qsel << 8) & 7936U);
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pattrib->raid << 16) & 983040U);
    fill_txdesc_sectype___0(pattrib, ptxdesc);
    if ((unsigned int )pattrib->ampdu_en != 0U) {
      ptxdesc->txdw1 = ptxdesc->txdw1 | 32U;
    } else {
      ptxdesc->txdw1 = ptxdesc->txdw1 | 64U;
    }
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
    if ((unsigned int )pattrib->qos_en != 0U) {
      ptxdesc->txdw4 = ptxdesc->txdw4 | 64U;
    } else {
    }
    if (((unsigned int )pattrib->ether_type != 34958U && (unsigned int )pattrib->ether_type != 2054U) && (unsigned int )pattrib->dhcp_pkt != 1U) {
      fill_txdesc_vcs___0(pattrib, & ptxdesc->txdw4);
      fill_txdesc_phy___0(pattrib, & ptxdesc->txdw4);
      ptxdesc->txdw4 = ptxdesc->txdw4 | 8U;
      ptxdesc->txdw5 = ptxdesc->txdw5 | 130816U;
      ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )pdmpriv->INIDATA_RATE[(int )pattrib->mac_id];
    } else {
      ptxdesc->txdw1 = ptxdesc->txdw1 | 64U;
      ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
      if ((unsigned int )pmlmeinfo->preamble_mode == 3U) {
        ptxdesc->txdw4 = ptxdesc->txdw4 | 16777216U;
      } else {
      }
      tmp___1 = MRateToHwRate23a((int )pmlmeext->tx_rate);
      ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___1;
    }
  } else
  if ((pxmitframe->frame_tag & 15) == 3) {
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )pattrib->mac_id & 31U);
    qsel = (unsigned int )pattrib->qsel & 31U;
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((qsel << 8) & 7936U);
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pattrib->raid << 16) & 983040U);
    if ((unsigned int )pxmitframe->ack_report != 0U) {
      ptxdesc->txdw2 = ptxdesc->txdw2 | 524288U;
    } else {
    }
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
    ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
    ptxdesc->txdw5 = ptxdesc->txdw5 | 131072U;
    ptxdesc->txdw5 = ptxdesc->txdw5 | 1572864U;
    tmp___2 = MRateToHwRate23a((int )pmlmeext->tx_rate);
    ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___2;
  } else
  if ((pxmitframe->frame_tag & 15) == 8) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
    } else {
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
    } else {
    }
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4U;
    ptxdesc->txdw1 = ptxdesc->txdw1 | 393216U;
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
    ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
    tmp___3 = MRateToHwRate23a((int )pmlmeext->tx_rate);
    ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___3;
  }
  if ((unsigned int )pattrib->qos_en == 0U) {
    ptxdesc->txdw4 = ptxdesc->txdw4 | 128U;
    ptxdesc->txdw3 = ptxdesc->txdw3 | 2147483648U;
  } else {
  }
  ptxdesc->txdw0 = ptxdesc->txdw0 | ((__le32 )sz & 65535U);
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2348810240U;
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2097152U;
  if (bmcst != 0) {
    ptxdesc->txdw0 = ptxdesc->txdw0 | 16777216U;
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016offset0-txdesc = 0x%x\n", ptxdesc->txdw0);
  } else {
  }
  if ((int )pxmitframe->pkt_offset > 0) {
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pxmitframe->pkt_offset << 26) & 2080374784U);
  } else {
  }
  rtl8192cu_cal_txdesc_chksum(ptxdesc);
  return (pull);
}
}
static int rtw_dump_xframe(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  int ret ;
  int inner_ret ;
  int t ;
  int sz ;
  int w_sz ;
  int pull ;
  u8 *mem_addr ;
  u32 ff_hwaddr ;
  struct xmit_buf *pxmitbuf ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;
  {
  ret = 1;
  inner_ret = 1;
  pull = 0;
  pxmitbuf = pxmitframe->pxmitbuf;
  pattrib = & pxmitframe->attrib;
  pxmitpriv = & padapter->xmitpriv;
  if (((pxmitframe->frame_tag == 1 && (unsigned int )pxmitframe->attrib.ether_type != 2054U) && (unsigned int )pxmitframe->attrib.ether_type != 34958U) && (unsigned int )pxmitframe->attrib.dhcp_pkt != 1U) {
    rtw_issue_addbareq_cmd23a(padapter, pxmitframe);
  } else {
  }
  mem_addr = pxmitframe->buf_addr;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016rtw_dump_xframe()\n");
  } else {
  }
  t = 0;
  goto ldv_54339;
  ldv_54338: ;
  if (inner_ret != 1 && ret == 1) {
    ret = 0;
  } else {
  }
  if ((int )pattrib->nr_frags + -1 != t) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
      printk("\016pattrib->nr_frags =%d\n", (int )pattrib->nr_frags);
    } else {
    }
    sz = (int )pxmitpriv->frag_len;
    sz = (sz + -4) - (int )pattrib->icv_len;
  } else {
    sz = (int )pattrib->last_txcmdsz;
  }
  pull = update_txdesc(pxmitframe, mem_addr, sz, 0);
  if (pull != 0) {
    mem_addr = mem_addr + 8UL;
    pxmitframe->buf_addr = mem_addr;
    w_sz = sz + 32;
  } else {
    w_sz = sz + 40;
  }
  ff_hwaddr = rtw_get_ff_hwaddr23a(pxmitframe);
  inner_ret = rtl8723au_write_port(padapter, ff_hwaddr, (u32 )w_sz, pxmitbuf);
  rtw_count_tx_stats23a(padapter, pxmitframe, sz);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016rtw_write_port, w_sz =%d\n", w_sz);
  } else {
  }
  mem_addr = mem_addr + (unsigned long )w_sz;
  mem_addr = (u8 *)(((unsigned long )mem_addr + 3UL) & 0xfffffffffffffffcUL);
  t = t + 1;
  ldv_54339: ;
  if ((int )pattrib->nr_frags > t) {
    goto ldv_54338;
  } else {
  }
  rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
  if (ret != 1) {
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 1);
  } else {
  }
  return (ret);
}
}
bool rtl8723au_xmitframe_complete(struct rtw_adapter *padapter , struct xmit_priv *pxmitpriv ,
                                  struct xmit_buf *pxmitbuf )
{
  struct hw_xmit *phwxmits ;
  struct xmit_frame *pxmitframe ;
  int hwentry ;
  int res ;
  int xcnt ;
  {
  res = 1;
  xcnt = 0;
  phwxmits = pxmitpriv->hwxmits;
  hwentry = (int )pxmitpriv->hwxmit_entry;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
    printk("\016xmitframe_complete()\n");
  } else {
  }
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    pxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);
    if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
      return (0);
    } else {
    }
  } else {
  }
  pxmitframe = rtw_dequeue_xframe23a(pxmitpriv, phwxmits, hwentry);
  if ((unsigned long )pxmitframe != (unsigned long )((struct xmit_frame *)0)) {
    pxmitframe->pxmitbuf = pxmitbuf;
    pxmitframe->buf_addr = pxmitbuf->pbuf;
    pxmitbuf->priv_data = (void *)pxmitframe;
    if ((pxmitframe->frame_tag & 15) == 1) {
      if ((unsigned int )pxmitframe->attrib.priority <= 15U) {
        res = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);
      } else {
      }
      rtw_os_xmit_complete23a(padapter, pxmitframe);
    } else {
    }
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
      printk("\016xmitframe_complete(): rtw_dump_xframe\n");
    } else {
    }
    if (res == 1) {
      rtw_dump_xframe(padapter, pxmitframe);
    } else {
      rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
      rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    }
    xcnt = xcnt + 1;
  } else {
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
    return (0);
  }
  return (1);
}
}
static int xmitframe_direct(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  int res ;
  {
  res = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);
  if (res == 1) {
    rtw_dump_xframe(padapter, pxmitframe);
  } else {
  }
  return (res);
}
}
bool rtl8723au_hal_xmit(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  int res ;
  struct xmit_buf *pxmitbuf ;
  struct xmit_priv *pxmitpriv ;
  struct pkt_attrib *pattrib ;
  struct mlme_priv *pmlmepriv ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  int tmp ;
  s32 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  pxmitbuf = (struct xmit_buf *)0;
  pxmitpriv = & padapter->xmitpriv;
  pattrib = & pxmitframe->attrib;
  pmlmepriv = & padapter->mlmepriv;
  do_queue_select___0(padapter, pattrib);
  spin_lock_bh(& pxmitpriv->lock);
  tmp = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
  if (tmp != 0) {
    pstapriv = & padapter->stapriv;
    spin_unlock_bh(& pxmitpriv->lock);
    if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
      psta = pattrib->psta;
    } else {
      psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->ra));
    }
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
      if (psta->sleepq_len > 32U) {
        wakeup_sta_to_xmit23a(padapter, psta);
      } else {
      }
    } else {
    }
    return (0);
  } else {
  }
  tmp___0 = rtw_txframes_sta_ac_pending23a(padapter, pattrib);
  if (tmp___0 > 0) {
    goto enqueue;
  } else {
  }
  tmp___1 = check_fwstate(pmlmepriv, 2176);
  if ((int )tmp___1) {
    goto enqueue;
  } else {
  }
  pxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
    goto enqueue;
  } else {
  }
  spin_unlock_bh(& pxmitpriv->lock);
  pxmitframe->pxmitbuf = pxmitbuf;
  pxmitframe->buf_addr = pxmitbuf->pbuf;
  pxmitbuf->priv_data = (void *)pxmitframe;
  tmp___2 = xmitframe_direct(padapter, pxmitframe);
  if (tmp___2 != 1) {
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
  } else {
  }
  return (1);
  enqueue:
  res = rtw_xmitframe_enqueue23a(padapter, pxmitframe);
  spin_unlock_bh(& pxmitpriv->lock);
  if (res != 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 4);
      printk("\016pre_xmitframe: enqueue xmitframe fail\n");
    } else {
    }
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    pxmitpriv->tx_pkts = pxmitpriv->tx_pkts - 1ULL;
    pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
    return (1);
  } else {
  }
  return (0);
}
}
int rtl8723au_mgnt_xmit(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe )
{
  int tmp ;
  {
  tmp = rtw_dump_xframe(padapter, pmgntframe);
  return (tmp);
}
}
int rtl8723au_hal_xmitframe_enqueue(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe )
{
  struct xmit_priv *pxmitpriv ;
  int err ;
  {
  pxmitpriv = & padapter->xmitpriv;
  err = rtw_xmitframe_enqueue23a(padapter, pxmitframe);
  if (err != 1) {
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    pxmitpriv->tx_pkts = pxmitpriv->tx_pkts - 1ULL;
    pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
  } else {
    tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  }
  return (err);
}
}
void *ldv_kmem_cache_alloc_1928(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1934(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1936(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1938(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1939(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1940(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1941(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1942(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1943(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1944(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_1970(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1978(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_1986(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_1980(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_1976(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1984(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_1985(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1981(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1982(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_1983(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
int rtw_hal_init23a(struct rtw_adapter *padapter ) ;
int rtw_hal_deinit23a(struct rtw_adapter *padapter ) ;
int rtl8723au_inirp_init(struct rtw_adapter *Adapter ) ;
int rtl8723au_inirp_deinit(struct rtw_adapter *Adapter ) ;
void rtl8723a_dual_antenna_detection(struct rtw_adapter *padapter ) ;
void rtl8723a_BT_init_hwconfig(struct rtw_adapter *padapter ) ;
void BT_HaltProcess(struct rtw_adapter *padapter ) ;
void rtl8723a_read_adapter_info(struct rtw_adapter *Adapter ) ;
int rtl8723au_read_port(struct rtw_adapter *adapter , u32 addr , u32 cnt , struct recv_buf *precvbuf ) ;
void rtl8723au_read_port_cancel(struct rtw_adapter *padapter ) ;
int rtl8723au_read_interrupt(struct rtw_adapter *adapter , u32 addr ) ;
void rtl8723au_chip_configure(struct rtw_adapter *padapter ) ;
static void _ConfigChipOutEP(struct rtw_adapter *pAdapter , u8 NumOutPipe )
{
  u8 value8 ;
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  pHalData->OutEpQueueSel = 0U;
  pHalData->OutEpNumber = 0U;
  value8 = rtl8723au_read8(pAdapter, 65126U);
  if (((int )value8 & 15) != 0) {
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 1U);
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {
  }
  if ((((int )value8 >> 4) & 15) != 0) {
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 4U);
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {
  }
  value8 = rtl8723au_read8(pAdapter, 65127U);
  if (((int )value8 & 15) != 0) {
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 2U);
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {
  }
  return;
}
}
static bool rtl8723au_set_queue_pipe_mapping(struct rtw_adapter *pAdapter , u8 NumInPipe ,
                                             u8 NumOutPipe )
{
  struct hal_data_8723a *pHalData ;
  bool result ;
  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  result = 0;
  _ConfigChipOutEP(pAdapter, (int )NumOutPipe);
  if ((unsigned int )pHalData->OutEpNumber == 1U) {
    if ((unsigned int )NumInPipe != 1U) {
      return (result);
    } else {
    }
  } else {
  }
  result = Hal_MappingOutPipe23a(pAdapter, (int )NumOutPipe);
  return (result);
}
}
void rtl8723au_chip_configure(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct dvobj_priv *pdvobjpriv ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdvobjpriv = padapter->dvobj;
  pHalData->interfaceIndex = (u32 )pdvobjpriv->InterfaceNumber;
  rtl8723au_set_queue_pipe_mapping(padapter, (int )pdvobjpriv->RtNumInPipes, (int )pdvobjpriv->RtNumOutPipes);
  return;
}
}
static int _InitPowerOn(struct rtw_adapter *padapter )
{
  int status ;
  u16 value16 ;
  u8 value8 ;
  u8 tmp ;
  {
  status = 1;
  value16 = 0U;
  value8 = 0U;
  rtl8723au_write8(padapter, 28U, 0);
  tmp = HalPwrSeqCmdParsing23a(padapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_card_enable_flow));
  if ((unsigned int )tmp == 0U) {
    return (0);
  } else {
  }
  value8 = rtl8723au_read8(padapter, 6U);
  rtl8723au_write8(padapter, 6U, (int )((unsigned int )value8 | 8U));
  value16 = rtl8723au_read16(padapter, 256U);
  value16 = (u16 )((unsigned int )value16 | 1791U);
  rtl8723au_write16(padapter, 256U, (int )value16);
  PHY_SetBBReg(padapter, 48U, 1879048192U, 6U);
  return (status);
}
}
static void _InitInterrupt(struct rtw_adapter *Adapter )
{
  u32 value32 ;
  {
  value32 = 4294967295U;
  rtl8723au_write32(Adapter, 292U, value32);
  rtl8723au_write32(Adapter, 288U, value32);
  return;
}
}
static void _InitQueueReservedPage(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  struct registry_priv *pregistrypriv ;
  u32 numHQ ;
  u32 numLQ ;
  u32 numNQ ;
  u32 numPubQ ;
  u32 value32 ;
  u8 value8 ;
  bool bWiFiConfig ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pregistrypriv = & Adapter->registrypriv;
  numHQ = 0U;
  numLQ = 0U;
  numNQ = 0U;
  bWiFiConfig = (unsigned int )pregistrypriv->wifi_spec != 0U;
  numPubQ = (int )bWiFiConfig ? 176U : 231U;
  if ((int )pHalData->OutEpQueueSel & 1) {
    numHQ = (int )bWiFiConfig ? 41U : 12U;
  } else {
  }
  if (((unsigned long )pHalData->OutEpQueueSel & 2UL) != 0UL) {
    numLQ = (int )bWiFiConfig ? 28U : 2U;
  } else {
  }
  if (((unsigned long )pHalData->OutEpQueueSel & 4UL) != 0UL) {
    numNQ = (int )bWiFiConfig ? 28U : 2U;
  } else {
  }
  value8 = (unsigned char )numNQ;
  rtl8723au_write8(Adapter, 532U, (int )value8);
  value32 = (((numHQ & 255U) | ((numLQ << 8) & 65535U)) | ((numPubQ & 255U) << 16)) | 2147483648U;
  rtl8723au_write32(Adapter, 512U, value32);
  return;
}
}
static void _InitTxBufferBoundary(struct rtw_adapter *Adapter )
{
  struct registry_priv *pregistrypriv ;
  u8 txpktbuf_bndy ;
  {
  pregistrypriv = & Adapter->registrypriv;
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
    txpktbuf_bndy = 249U;
  } else {
    txpktbuf_bndy = 246U;
  }
  rtl8723au_write8(Adapter, 1060U, (int )txpktbuf_bndy);
  rtl8723au_write8(Adapter, 1061U, (int )txpktbuf_bndy);
  rtl8723au_write8(Adapter, 1117U, (int )txpktbuf_bndy);
  rtl8723au_write8(Adapter, 276U, (int )txpktbuf_bndy);
  rtl8723au_write8(Adapter, 521U, (int )txpktbuf_bndy);
  return;
}
}
static void _InitPageBoundary(struct rtw_adapter *Adapter )
{
  u16 rxff_bndy ;
  {
  rxff_bndy = 10239U;
  rtl8723au_write16(Adapter, 278U, (int )rxff_bndy);
  return;
}
}
static void _InitNormalChipRegPriority(struct rtw_adapter *Adapter , u16 beQ , u16 bkQ ,
                                       u16 viQ , u16 voQ , u16 mgtQ , u16 hiQ )
{
  u16 value16 ;
  u16 tmp ;
  {
  tmp = rtl8723au_read16(Adapter, 268U);
  value16 = (unsigned int )tmp & 7U;
  value16 = (u16 )(((((((int )((short )(((int )beQ & 3) << 8)) | (int )((short )(((int )bkQ & 3) << 10))) | ((int )((short )((int )viQ << 6)) & 255)) | (int )((short )(((int )voQ & 3) << 4))) | (int )((short )(((int )mgtQ & 3) << 12))) | (int )((short )((int )hiQ << 14))) | (int )((short )value16));
  rtl8723au_write16(Adapter, 268U, (int )value16);
  return;
}
}
static void _InitNormalChipOneOutEpPriority(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  u16 value ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  value = 0U;
  switch ((int )pHalData->OutEpQueueSel) {
  case 1:
  value = 3U;
  goto ldv_54364;
  case 2:
  value = 1U;
  goto ldv_54364;
  case 4:
  value = 2U;
  goto ldv_54364;
  default: ;
  goto ldv_54364;
  }
  ldv_54364:
  _InitNormalChipRegPriority(Adapter, (int )value, (int )value, (int )value, (int )value,
                             (int )value, (int )value);
  return;
}
}
static void _InitNormalChipTwoOutEpPriority(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  struct registry_priv *pregistrypriv ;
  u16 beQ ;
  u16 bkQ ;
  u16 viQ ;
  u16 voQ ;
  u16 mgtQ ;
  u16 hiQ ;
  u16 valueHi ;
  u16 valueLow ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pregistrypriv = & Adapter->registrypriv;
  valueHi = 0U;
  valueLow = 0U;
  switch ((int )pHalData->OutEpQueueSel) {
  case 3:
  valueHi = 3U;
  valueLow = 1U;
  goto ldv_54382;
  case 6:
  valueHi = 2U;
  valueLow = 1U;
  goto ldv_54382;
  case 5:
  valueHi = 3U;
  valueLow = 2U;
  goto ldv_54382;
  default: ;
  goto ldv_54382;
  }
  ldv_54382: ;
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
    beQ = valueLow;
    bkQ = valueLow;
    viQ = valueHi;
    voQ = valueHi;
    mgtQ = valueHi;
    hiQ = valueHi;
  } else {
    beQ = valueLow;
    bkQ = valueHi;
    viQ = valueHi;
    voQ = valueLow;
    mgtQ = valueHi;
    hiQ = valueHi;
  }
  _InitNormalChipRegPriority(Adapter, (int )beQ, (int )bkQ, (int )viQ, (int )voQ,
                             (int )mgtQ, (int )hiQ);
  return;
}
}
static void _InitNormalChipThreeOutEpPriority(struct rtw_adapter *Adapter )
{
  struct registry_priv *pregistrypriv ;
  u16 beQ ;
  u16 bkQ ;
  u16 viQ ;
  u16 voQ ;
  u16 mgtQ ;
  u16 hiQ ;
  {
  pregistrypriv = & Adapter->registrypriv;
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
    beQ = 1U;
    bkQ = 1U;
    viQ = 2U;
    voQ = 3U;
    mgtQ = 3U;
    hiQ = 3U;
  } else {
    beQ = 1U;
    bkQ = 2U;
    viQ = 2U;
    voQ = 3U;
    mgtQ = 3U;
    hiQ = 3U;
  }
  _InitNormalChipRegPriority(Adapter, (int )beQ, (int )bkQ, (int )viQ, (int )voQ,
                             (int )mgtQ, (int )hiQ);
  return;
}
}
static void _InitNormalChipQueuePriority(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  switch ((int )pHalData->OutEpNumber) {
  case 1:
  _InitNormalChipOneOutEpPriority(Adapter);
  goto ldv_54401;
  case 2:
  _InitNormalChipTwoOutEpPriority(Adapter);
  goto ldv_54401;
  case 3:
  _InitNormalChipThreeOutEpPriority(Adapter);
  goto ldv_54401;
  default: ;
  goto ldv_54401;
  }
  ldv_54401: ;
  return;
}
}
static void _InitQueuePriority(struct rtw_adapter *Adapter )
{
  {
  _InitNormalChipQueuePriority(Adapter);
  return;
}
}
static void _InitNetworkType(struct rtw_adapter *Adapter )
{
  u32 value32 ;
  {
  value32 = rtl8723au_read32(Adapter, 256U);
  value32 = (value32 & 4294770687U) | 131072U;
  rtl8723au_write32(Adapter, 256U, value32);
  return;
}
}
static void _InitTransferPageSize(struct rtw_adapter *Adapter )
{
  u8 value8 ;
  {
  value8 = 17U;
  rtl8723au_write8(Adapter, 260U, (int )value8);
  return;
}
}
static void _InitDriverInfoSize(struct rtw_adapter *Adapter , u8 drvInfoSize )
{
  {
  rtl8723au_write8(Adapter, 1551U, (int )drvInfoSize);
  return;
}
}
static void _InitWMACSetting(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pHalData->ReceiveConfig = 1879072974U;
  rtl8723au_write32(Adapter, 1544U, pHalData->ReceiveConfig);
  rtl8723au_write32(Adapter, 1568U, 4294967295U);
  rtl8723au_write32(Adapter, 1572U, 4294967295U);
  return;
}
}
static void _InitAdaptiveCtrl(struct rtw_adapter *Adapter )
{
  u16 value16 ;
  u32 value32 ;
  {
  value32 = rtl8723au_read32(Adapter, 1088U);
  value32 = value32 & 4293918720U;
  value32 = value32 | 1048561U;
  rtl8723au_write32(Adapter, 1088U, value32);
  value16 = 4112U;
  rtl8723au_write16(Adapter, 1064U, (int )value16);
  value16 = 12336U;
  rtl8723au_write16(Adapter, 1066U, (int )value16);
  return;
}
}
static void _InitRateFallback(struct rtw_adapter *Adapter )
{
  {
  rtl8723au_write32(Adapter, 1072U, 0U);
  rtl8723au_write32(Adapter, 1076U, 268960772U);
  rtl8723au_write32(Adapter, 1080U, 67305985U);
  rtl8723au_write32(Adapter, 1084U, 134678021U);
  return;
}
}
static void _InitEDCA(struct rtw_adapter *Adapter )
{
  {
  rtl8723au_write16(Adapter, 1064U, 4106);
  rtl8723au_write16(Adapter, 1594U, 4106);
  rtl8723au_write16(Adapter, 1300U, 4106);
  rtl8723au_write16(Adapter, 1302U, 4106);
  rtl8723au_write32(Adapter, 1288U, 6202411U);
  rtl8723au_write32(Adapter, 1292U, 42063U);
  rtl8723au_write32(Adapter, 1284U, 6202148U);
  rtl8723au_write32(Adapter, 1280U, 3121702U);
  return;
}
}
static void _InitHWLed(struct rtw_adapter *Adapter )
{
  struct led_priv *pledpriv ;
  {
  pledpriv = & Adapter->ledpriv;
  if ((unsigned int )pledpriv->LedStrategy != 50U) {
    return;
  } else {
  }
  return;
}
}
static void _InitRDGSetting(struct rtw_adapter *Adapter )
{
  {
  rtl8723au_write8(Adapter, 1316U, 255);
  rtl8723au_write16(Adapter, 1348U, 512);
  rtl8723au_write8(Adapter, 1123U, 5);
  return;
}
}
static void _InitRetryFunction(struct rtw_adapter *Adapter )
{
  u8 value8 ;
  {
  value8 = rtl8723au_read8(Adapter, 1056U);
  value8 = (u8 )((unsigned int )value8 | 128U);
  rtl8723au_write8(Adapter, 1056U, (int )value8);
  rtl8723au_write8(Adapter, 1600U, 64);
  return;
}
}
static void usb_AggSettingTxUpdate(struct rtw_adapter *Adapter )
{
  {
  return;
}
}
static void usb_AggSettingRxUpdate(struct rtw_adapter *Adapter )
{
  {
  return;
}
}
static void InitUsbAggregationSetting(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  usb_AggSettingTxUpdate(Adapter);
  usb_AggSettingRxUpdate(Adapter);
  pHalData->UsbRxHighSpeedMode = 0;
  return;
}
}
static void _InitOperationMode(struct rtw_adapter *Adapter )
{
  {
  return;
}
}
static void _InitRFType(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  bool is92CU ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  is92CU = (bool )(((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U);
  pHalData->rf_chip = 4U;
  if (! is92CU) {
    pHalData->rf_type = 3U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Set RF Chip ID to RF_6052 and RF type to 1T1R.\n");
    } else {
    }
    return;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Set RF Chip ID to RF_6052 and RF type to %d.\n", (int )pHalData->rf_type);
  } else {
  }
  return;
}
}
static void _BBTurnOnBlock(struct rtw_adapter *Adapter )
{
  {
  PHY_SetBBReg(Adapter, 2048U, 16777216U, 1U);
  PHY_SetBBReg(Adapter, 2048U, 33554432U, 1U);
  return;
}
}
static void _RfPowerSave(struct rtw_adapter *padapter )
{
  {
  return;
}
}
enum rt_rf_power_state RfOnOffDetect23a(struct rtw_adapter *pAdapter )
{
  u8 val8 ;
  enum rt_rf_power_state rfpowerstate ;
  u8 tmp ;
  {
  rfpowerstate = 2;
  if ((unsigned int )pAdapter->pwrctrlpriv.bHWPowerdown != 0U) {
    val8 = rtl8723au_read8(pAdapter, 92U);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: pwrdown, 0x5c(BIT7) =%02x\n", (int )val8);
    } else {
    }
    rfpowerstate = (int )((signed char )val8) < 0 ? 2 : 0;
  } else {
    tmp = rtl8723au_read8(pAdapter, 67U);
    rtl8723au_write8(pAdapter, 67U, (int )tmp & 247);
    val8 = rtl8723au_read8(pAdapter, 66U);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: GPIO_IN =%02x\n", (int )val8);
    } else {
    }
    rfpowerstate = ((unsigned long )val8 & 8UL) != 0UL ? 0 : 2;
  }
  return (rfpowerstate);
}
}
void _ps_open_RF23a(struct rtw_adapter *padapter ) ;
static int rtl8723au_hal_init(struct rtw_adapter *Adapter )
{
  u8 val8 ;
  u32 boundary ;
  int status ;
  struct hal_data_8723a *pHalData ;
  struct pwrctrl_priv *pwrctrlpriv ;
  struct registry_priv *pregistrypriv ;
  unsigned long init_start_time ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  unsigned int tmp___2 ;
  {
  val8 = 0U;
  status = 1;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pwrctrlpriv = & Adapter->pwrctrlpriv;
  pregistrypriv = & Adapter->registrypriv;
  init_start_time = jiffies;
  if ((unsigned int )Adapter->pwrctrlpriv.bkeepfwalive != 0U) {
    _ps_open_RF23a(Adapter);
    if ((unsigned int )pHalData->bIQKInitialized != 0U) {
      rtl8723a_phy_iq_calibrate(Adapter, 1);
    } else {
      rtl8723a_phy_iq_calibrate(Adapter, 0);
      pHalData->bIQKInitialized = 1U;
    }
    rtl8723a_odm_check_tx_power_tracking(Adapter);
    rtl8723a_phy_lc_calibrate(Adapter);
    goto exit;
  } else {
  }
  val8 = rtl8723au_read8(Adapter, 256U);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016%s: REG_CR 0x100 = 0x%02x\n", "rtl8723au_hal_init", (int )val8);
  } else {
  }
  if ((unsigned int )val8 == 234U) {
    pHalData->bMACFuncEnable = 0;
  } else {
    pHalData->bMACFuncEnable = 1;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
      printk("\016%s: MAC has already power on\n", "rtl8723au_hal_init");
    } else {
    }
  }
  status = _InitPowerOn(Adapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
      printk("\016Failed to init power on!\n");
    } else {
    }
    goto exit;
  } else {
  }
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
    boundary = 249U;
  } else {
    boundary = 246U;
  }
  if (! pHalData->bMACFuncEnable) {
    status = InitLLTTable23a(Adapter, boundary);
    if (status == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
        printk("\016Failed to init LLT table\n");
      } else {
      }
      goto exit;
    } else {
    }
  } else {
  }
  if ((int )pHalData->bRDGEnable) {
    _InitRDGSetting(Adapter);
  } else {
  }
  status = rtl8723a_FirmwareDownload(Adapter);
  if (status != 1) {
    Adapter->bFWReady = 0U;
    pHalData->fw_ractrl = 0U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: fw download fail!\n");
    } else {
    }
    goto exit;
  } else {
    Adapter->bFWReady = 1U;
    pHalData->fw_ractrl = 1U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: fw download ok!\n");
    } else {
    }
  }
  rtl8723a_InitializeFirmwareVars(Adapter);
  if ((unsigned int )pwrctrlpriv->reg_rfoff == 1U) {
    pwrctrlpriv->rf_pwrstate = 2;
  } else {
  }
  _InitRFType(Adapter);
  pHalData->CurrentChannel = 6U;
  status = PHY_MACConfig8723A(Adapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: PHY_MACConfig8723A fault !!\n");
    } else {
    }
    goto exit;
  } else {
  }
  status = PHY_BBConfig8723A(Adapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: PHY_BBConfig8723A fault !!\n");
    } else {
    }
    goto exit;
  } else {
  }
  status = PHY_RFConfig8723A(Adapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: PHY_RFConfig8723A fault !!\n");
    } else {
    }
    goto exit;
  } else {
  }
  PHY_SetBBReg(Adapter, 36U, 4294967295U, 58818701U);
  PHY_SetBBReg(Adapter, 40U, 4294967295U, 4076863363U);
  PHY_SetBBReg(Adapter, 40U, 4294967295U, 4076863362U);
  PHY_SetBBReg(Adapter, 40U, 4294967295U, 4076863363U);
  PHY_SetBBReg(Adapter, 2052U, 4294967295U, 3U);
  PHY_SetBBReg(Adapter, 2160U, 4294967295U, 117442400U);
  PHY_SetBBReg(Adapter, 2144U, 4294967295U, 1727398416U);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    tmp = PHY_QueryBBReg(Adapter, 2160U, 4294967295U);
    printk("\016%s: 0x870 = value 0x%x\n", "rtl8723au_hal_init", tmp);
  } else {
  }
  pHalData->RfRegChnlVal[0] = PHY_QueryRFReg(Adapter, 0, 24U, 1048575U);
  pHalData->RfRegChnlVal[1] = PHY_QueryRFReg(Adapter, 1, 24U, 1048575U);
  if (! pHalData->bMACFuncEnable) {
    _InitQueueReservedPage(Adapter);
    _InitTxBufferBoundary(Adapter);
  } else {
  }
  _InitQueuePriority(Adapter);
  _InitPageBoundary(Adapter);
  _InitTransferPageSize(Adapter);
  _InitDriverInfoSize(Adapter, 4);
  _InitInterrupt(Adapter);
  hw_var_set_macaddr(Adapter, (u8 *)(& Adapter->eeprompriv.mac_addr));
  _InitNetworkType(Adapter);
  _InitWMACSetting(Adapter);
  _InitAdaptiveCtrl(Adapter);
  _InitEDCA(Adapter);
  _InitRateFallback(Adapter);
  _InitRetryFunction(Adapter);
  InitUsbAggregationSetting(Adapter);
  _InitOperationMode(Adapter);
  rtl8723a_InitBeaconParameters(Adapter);
  _InitHWLed(Adapter);
  _BBTurnOnBlock(Adapter);
  invalidate_cam_all23a(Adapter);
  PHY_SetTxPowerLevel8723A(Adapter, (int )pHalData->CurrentChannel);
  rtl8723a_InitAntenna_Selection(Adapter);
  rtl8723au_write8(Adapter, 1059U, 255);
  rtl8723au_write32(Adapter, 1228U, 33685503U);
  if ((unsigned int )pregistrypriv->wifi_spec != 0U) {
    rtl8723au_write16(Adapter, 1120U, 0);
  } else {
  }
  _RfPowerSave(Adapter);
  if ((unsigned int )pwrctrlpriv->rf_pwrstate == 0U) {
    if ((unsigned int )pHalData->bIQKInitialized != 0U) {
      rtl8723a_phy_iq_calibrate(Adapter, 1);
    } else {
      rtl8723a_phy_iq_calibrate(Adapter, 0);
      pHalData->bIQKInitialized = 1U;
    }
    rtl8723a_odm_check_tx_power_tracking(Adapter);
    rtl8723a_phy_lc_calibrate(Adapter);
    rtl8723a_dual_antenna_detection(Adapter);
  } else {
  }
  rtl8723au_write8(Adapter, 65088U, 224);
  rtl8723au_write8(Adapter, 65089U, 141);
  rtl8723au_write8(Adapter, 65090U, 128);
  rtl8723au_write32(Adapter, 524U, 16581408U);
  if (((unsigned int )pHalData->VersionID.ICType != 2U && (unsigned int )pHalData->VersionID.ICType != 1U) || ((unsigned int )pHalData->VersionID.VendorType != 1U || (unsigned int )pHalData->VersionID.CUTVersion != 0U)) {
    rtl8723au_write8(Adapter, 65088U, 230);
    rtl8723au_write8(Adapter, 65089U, 148);
    rtl8723au_write8(Adapter, 65090U, 128);
    rtl8723au_write8(Adapter, 65088U, 224);
    rtl8723au_write8(Adapter, 65089U, 25);
    rtl8723au_write8(Adapter, 65090U, 128);
    rtl8723au_write8(Adapter, 65088U, 229);
    rtl8723au_write8(Adapter, 65089U, 145);
    rtl8723au_write8(Adapter, 65090U, 128);
    rtl8723au_write8(Adapter, 65088U, 226);
    rtl8723au_write8(Adapter, 65089U, 129);
    rtl8723au_write8(Adapter, 65090U, 128);
  } else {
  }
  rtl8723a_BT_init_hwconfig(Adapter);
  rtl8723a_InitHalDm(Adapter);
  rtl8723a_set_nav_upper(Adapter, 30000U);
  tmp___0 = rtl8723au_read32(Adapter, 2048U);
  if ((tmp___0 & 4278190080U) != 2197815296U) {
    PHY_SetBBReg(Adapter, 2048U, 16777216U, 1U);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
      printk("\016%s: IQK fail recorver\n", "rtl8723au_hal_init");
    } else {
    }
  } else {
  }
  tmp___1 = rtl8723au_read32(Adapter, 1056U);
  rtl8723au_write32(Adapter, 1056U, tmp___1 | 4096U);
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    tmp___2 = jiffies_to_msecs((unsigned long )jiffies - init_start_time);
    printk("\016RTL8723AU: %s in %dms\n", "rtl8723au_hal_init", tmp___2);
  } else {
  }
  return (status);
}
}
static void phy_SsPwrSwitch92CU(struct rtw_adapter *Adapter , enum rt_rf_power_state eRFPowerState ,
                                int bRegSSPwrLvl )
{
  struct hal_data_8723a *pHalData ;
  u8 value8 ;
  u8 bytetmp ;
  u8 tmp ;
  unsigned long __ms ;
  unsigned long tmp___0 ;
  u8 tmp___1 ;
  unsigned long __ms___0 ;
  unsigned long tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u8 eRFPath ;
  u8 value8___0 ;
  unsigned long __ms___1 ;
  unsigned long tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  unsigned long __ms___2 ;
  unsigned long tmp___12 ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  switch ((unsigned int )eRFPowerState) {
  case 0U: ;
  if (bRegSSPwrLvl == 1) {
    tmp = rtl8723au_read8(Adapter, 17U);
    rtl8723au_write8(Adapter, 17U, (int )((unsigned int )tmp | 9U));
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetBBReg(Adapter, 2168U, 3670072U, 1U);
    } else {
      PHY_SetBBReg(Adapter, 2168U, 56U, 1U);
    }
    PHY_SetBBReg(Adapter, 3076U, 240U, 1U);
    PHY_SetBBReg(Adapter, 2048U, 2U, 0U);
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1675306400U);
    } else
    if ((unsigned int )pHalData->rf_type == 3U) {
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1662723488U);
    } else {
    }
    PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 208277U);
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 208277U);
    } else {
    }
  } else {
    rtl8723au_write8(Adapter, 40U, 129);
    rtl8723au_write16(Adapter, 36U, 32783);
    if (1) {
      __const_udelay(4295000UL);
    } else {
      __ms = 1UL;
      goto ldv_54503;
      ldv_54502:
      __const_udelay(4295000UL);
      ldv_54503:
      tmp___0 = __ms;
      __ms = __ms - 1UL;
      if (tmp___0 != 0UL) {
        goto ldv_54502;
      } else {
      }
    }
    tmp___1 = rtl8723au_read8(Adapter, 17U);
    rtl8723au_write8(Adapter, 17U, (int )((unsigned int )tmp___1 | 9U));
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetBBReg(Adapter, 2168U, 3670072U, 1U);
    } else {
      PHY_SetBBReg(Adapter, 2168U, 56U, 1U);
    }
    PHY_SetBBReg(Adapter, 3076U, 240U, 1U);
    PHY_SetBBReg(Adapter, 2048U, 2U, 0U);
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1675306400U);
    } else
    if ((unsigned int )pHalData->rf_type == 3U) {
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1662723488U);
    } else {
    }
    PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 208277U);
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 208277U);
    } else {
    }
    bytetmp = rtl8723au_read8(Adapter, 1536U);
    rtl8723au_write8(Adapter, 1536U, (int )bytetmp & 191);
    __ms___0 = 10UL;
    goto ldv_54507;
    ldv_54506:
    __const_udelay(4295000UL);
    ldv_54507:
    tmp___2 = __ms___0;
    __ms___0 = __ms___0 - 1UL;
    if (tmp___2 != 0UL) {
      goto ldv_54506;
    } else {
    }
    rtl8723au_write8(Adapter, 2U, 23);
    rtl8723au_write8(Adapter, 1314U, 0);
  }
  goto ldv_54509;
  case 1U: ;
  case 2U:
  value8 = rtl8723au_read8(Adapter, 17U);
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U)) {
    value8 = (unsigned int )value8 & 254U;
  } else {
    value8 = (unsigned int )value8 & 246U;
  }
  if (bRegSSPwrLvl == 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
      printk("\016SS LVL1\n");
    } else {
    }
    tmp___3 = PHY_QueryBBReg(Adapter, 2168U, 4294967295U);
    Adapter->pwrctrlpriv.PS_BBRegBackup[0] = (unsigned long )tmp___3;
    tmp___4 = PHY_QueryBBReg(Adapter, 3076U, 4294967295U);
    Adapter->pwrctrlpriv.PS_BBRegBackup[1] = (unsigned long )tmp___4;
    tmp___5 = PHY_QueryBBReg(Adapter, 2048U, 4294967295U);
    Adapter->pwrctrlpriv.PS_BBRegBackup[2] = (unsigned long )tmp___5;
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetBBReg(Adapter, 2168U, 3670072U, 0U);
    } else
    if ((unsigned int )pHalData->rf_type == 3U) {
      PHY_SetBBReg(Adapter, 2168U, 56U, 0U);
    } else {
    }
    PHY_SetBBReg(Adapter, 3076U, 240U, 0U);
    PHY_SetBBReg(Adapter, 2048U, 2U, 1U);
    tmp___6 = PHY_QueryBBReg(Adapter, 3696U, 4294967295U);
    Adapter->pwrctrlpriv.PS_BBRegBackup[3] = (unsigned long )tmp___6;
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 14362016U);
    } else
    if ((unsigned int )pHalData->rf_type == 3U) {
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1779104U);
    } else {
    }
    PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 0U);
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 0U);
    } else {
    }
    rtl8723au_write8(Adapter, 17U, (int )value8);
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
      printk("\016SS LVL2\n");
    } else {
    }
    eRFPath = 0U;
    value8___0 = 0U;
    rtl8723au_write8(Adapter, 1314U, 255);
    PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH )eRFPath, 0U, 255U, 0U);
    value8___0 = (u8 )((unsigned int )value8___0 | 64U);
    rtl8723au_write8(Adapter, 1536U, (int )value8___0);
    __ms___1 = 10UL;
    goto ldv_54516;
    ldv_54515:
    __const_udelay(4295000UL);
    ldv_54516:
    tmp___7 = __ms___1;
    __ms___1 = __ms___1 - 1UL;
    if (tmp___7 != 0UL) {
      goto ldv_54515;
    } else {
    }
    value8___0 = 0U;
    value8___0 = (u8 )((unsigned int )value8___0 | 22U);
    rtl8723au_write8(Adapter, 2U, (int )value8___0);
    tmp___8 = PHY_QueryBBReg(Adapter, 2168U, 4294967295U);
    Adapter->pwrctrlpriv.PS_BBRegBackup[0] = (unsigned long )tmp___8;
    tmp___9 = PHY_QueryBBReg(Adapter, 3076U, 4294967295U);
    Adapter->pwrctrlpriv.PS_BBRegBackup[1] = (unsigned long )tmp___9;
    tmp___10 = PHY_QueryBBReg(Adapter, 2048U, 4294967295U);
    Adapter->pwrctrlpriv.PS_BBRegBackup[2] = (unsigned long )tmp___10;
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetBBReg(Adapter, 2168U, 3670072U, 0U);
    } else
    if ((unsigned int )pHalData->rf_type == 3U) {
      PHY_SetBBReg(Adapter, 2168U, 56U, 0U);
    } else {
    }
    PHY_SetBBReg(Adapter, 3076U, 240U, 0U);
    PHY_SetBBReg(Adapter, 2048U, 2U, 1U);
    tmp___11 = PHY_QueryBBReg(Adapter, 3696U, 4294967295U);
    Adapter->pwrctrlpriv.PS_BBRegBackup[3] = (unsigned long )tmp___11;
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 14362016U);
    } else
    if ((unsigned int )pHalData->rf_type == 3U) {
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1779104U);
    } else {
    }
    PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 0U);
    if ((unsigned int )pHalData->rf_type == 2U) {
      PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 0U);
    } else {
    }
    rtl8723au_write8(Adapter, 17U, (int )value8);
    rtl8723au_write8(Adapter, 40U, 128);
    if (1) {
      __const_udelay(4295000UL);
    } else {
      __ms___2 = 1UL;
      goto ldv_54520;
      ldv_54519:
      __const_udelay(4295000UL);
      ldv_54520:
      tmp___12 = __ms___2;
      __ms___2 = __ms___2 - 1UL;
      if (tmp___12 != 0UL) {
        goto ldv_54519;
      } else {
      }
    }
    rtl8723au_write16(Adapter, 36U, 43023);
  }
  goto ldv_54509;
  default: ;
  goto ldv_54509;
  }
  ldv_54509: ;
  return;
}
}
void _ps_open_RF23a(struct rtw_adapter *padapter )
{
  {
  phy_SsPwrSwitch92CU(padapter, 0, 1);
  return;
}
}
static void CardDisableRTL8723U(struct rtw_adapter *Adapter )
{
  u8 u1bTmp ;
  u8 tmp ;
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: CardDisableRTL8723U\n");
  } else {
  }
  HalPwrSeqCmdParsing23a(Adapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_enter_lps_flow));
  rtl8723au_write8(Adapter, 31U, 0);
  tmp = rtl8723au_read8(Adapter, 128U);
  if ((int )((signed char )tmp) < 0 && (unsigned int )Adapter->bFWReady != 0U) {
    rtl8723a_FirmwareSelfReset(Adapter);
  } else {
  }
  u1bTmp = rtl8723au_read8(Adapter, 3U);
  rtl8723au_write8(Adapter, 3U, (int )u1bTmp & 251);
  rtl8723au_write8(Adapter, 128U, 0);
  HalPwrSeqCmdParsing23a(Adapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_card_disable_flow));
  u1bTmp = rtl8723au_read8(Adapter, 29U);
  rtl8723au_write8(Adapter, 29U, (int )u1bTmp & 254);
  u1bTmp = rtl8723au_read8(Adapter, 29U);
  rtl8723au_write8(Adapter, 29U, (int )((unsigned int )u1bTmp | 1U));
  rtl8723au_write8(Adapter, 28U, 14);
  return;
}
}
static int rtl8723au_hal_deinit(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ==> %s\n", "rtl8723au_hal_deinit");
  } else {
  }
  BT_HaltProcess(padapter);
  CardDisableRTL8723U(padapter);
  return (1);
}
}
int rtl8723au_inirp_init(struct rtw_adapter *Adapter )
{
  u8 i ;
  struct recv_buf *precvbuf ;
  int status ;
  struct recv_priv *precvpriv ;
  struct hal_data_8723a *pHalData ;
  int tmp ;
  int tmp___0 ;
  {
  precvpriv = & Adapter->recvpriv;
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  status = 1;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016===> usb_inirp_init\n");
  } else {
  }
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
  i = 0U;
  goto ldv_54544;
  ldv_54543:
  tmp = rtl8723au_read_port(Adapter, 128U, 0U, precvbuf);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
      printk("\016usb_rx_init: usb_read_port error\n");
    } else {
    }
    status = 0;
    goto exit;
  } else {
  }
  precvbuf = precvbuf + 1;
  i = (u8 )((int )i + 1);
  ldv_54544: ;
  if ((unsigned int )i <= 3U) {
    goto ldv_54543;
  } else {
  }
  tmp___0 = rtl8723au_read_interrupt(Adapter, 129U);
  if (tmp___0 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
      printk("\016usb_rx_init: usb_read_interrupt error\n");
    } else {
    }
    status = 0;
  } else {
  }
  pHalData->IntrMask[0] = rtl8723au_read32(Adapter, 65080U);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: pHalData->IntrMask = 0x%04x\n", pHalData->IntrMask[0]);
  } else {
  }
  pHalData->IntrMask[0] = pHalData->IntrMask[0] | 1280U;
  rtl8723au_write32(Adapter, 65080U, pHalData->IntrMask[0]);
  exit: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016<=== usb_inirp_init\n");
  } else {
  }
  return (status);
}
}
int rtl8723au_inirp_deinit(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016\n ===> usb_rx_deinit\n");
  } else {
  }
  rtl8723au_read_port_cancel(Adapter);
  pHalData->IntrMask[0] = rtl8723au_read32(Adapter, 65080U);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s pHalData->IntrMask = 0x%04x\n", "rtl8723au_inirp_deinit",
           pHalData->IntrMask[0]);
  } else {
  }
  pHalData->IntrMask[0] = 0U;
  rtl8723au_write32(Adapter, 65080U, pHalData->IntrMask[0]);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
    printk("\016\n <=== usb_rx_deinit\n");
  } else {
  }
  return (1);
}
}
static void _ReadBoardType(struct rtw_adapter *Adapter , u8 *PROMContent , bool AutoloadFail )
{
  struct hal_data_8723a *pHalData ;
  u8 boardType ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  boardType = 0U;
  if ((int )AutoloadFail) {
    if ((unsigned int )pHalData->VersionID.ICType == 4U) {
      pHalData->rf_type = 3U;
    } else {
      pHalData->rf_type = 2U;
    }
    pHalData->BoardType = boardType;
    return;
  } else {
  }
  boardType = *(PROMContent + 121UL);
  boardType = (unsigned int )boardType & 224U;
  boardType = (u8 )((int )boardType >> 5);
  pHalData->BoardType = boardType;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: _ReadBoardType(%x)\n", (int )pHalData->BoardType);
  } else {
  }
  if ((unsigned int )boardType == 1U) {
    pHalData->ExternalPA = 1U;
  } else {
  }
  return;
}
}
static void _ReadLEDSetting(struct rtw_adapter *Adapter , u8 *PROMContent , bool AutoloadFail )
{
  struct led_priv *pledpriv ;
  {
  pledpriv = & Adapter->ledpriv;
  pledpriv->LedStrategy = 50;
  return;
}
}
static void Hal_EfuseParsePIDVID_8723AU(struct rtw_adapter *pAdapter , u8 *hwinfo ,
                                        bool AutoLoadFail )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
  if ((int )AutoLoadFail) {
    pHalData->EEPROMVID = 0U;
    pHalData->EEPROMPID = 0U;
  } else {
    pHalData->EEPROMVID = *((u16 *)hwinfo + 183U);
    pHalData->EEPROMPID = *((u16 *)hwinfo + 185U);
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: EEPROM VID = 0x%4x\n", (int )pHalData->EEPROMVID);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: EEPROM PID = 0x%4x\n", (int )pHalData->EEPROMPID);
  } else {
  }
  return;
}
}
static void Hal_EfuseParseMACAddr_8723AU(struct rtw_adapter *padapter , u8 *hwinfo ,
                                         bool AutoLoadFail )
{
  u16 i ;
  u8 sMacAddr[6U] ;
  struct eeprom_priv *pEEPROM ;
  size_t __len ;
  void *__ret ;
  {
  sMacAddr[0] = 0U;
  sMacAddr[1] = 224U;
  sMacAddr[2] = 76U;
  sMacAddr[3] = 135U;
  sMacAddr[4] = 35U;
  sMacAddr[5] = 0U;
  pEEPROM = & padapter->eeprompriv;
  if ((int )AutoLoadFail) {
    i = 0U;
    goto ldv_54579;
    ldv_54578:
    pEEPROM->mac_addr[(int )i] = sMacAddr[(int )i];
    i = (u16 )((int )i + 1);
    ldv_54579: ;
    if ((unsigned int )i <= 5U) {
      goto ldv_54578;
    } else {
    }
  } else {
    __len = 6UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& pEEPROM->mac_addr), (void const *)hwinfo + 198U,
                       __len);
    } else {
      __ret = memcpy((void *)(& pEEPROM->mac_addr), (void const *)hwinfo + 198U,
                               __len);
    }
  }
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 6);
    printk("\016Hal_EfuseParseMACAddr_8723AU: Permanent Address =%02x:%02x:%02x:%02x:%02x:%02x\n",
           (int )pEEPROM->mac_addr[0], (int )pEEPROM->mac_addr[1], (int )pEEPROM->mac_addr[2],
           (int )pEEPROM->mac_addr[3], (int )pEEPROM->mac_addr[4], (int )pEEPROM->mac_addr[5]);
  } else {
  }
  return;
}
}
static void readAdapterInfo(struct rtw_adapter *padapter )
{
  struct eeprom_priv *pEEPROM ;
  u8 hwinfo[256U] ;
  {
  pEEPROM = & padapter->eeprompriv;
  Hal_InitPGData(padapter, (u8 *)(& hwinfo));
  Hal_EfuseParseIDCode(padapter, (u8 *)(& hwinfo));
  Hal_EfuseParsePIDVID_8723AU(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseEEPROMVer(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseMACAddr_8723AU(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParsetxpowerinfo_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  _ReadBoardType(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseBTCoexistInfo_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  rtl8723a_EfuseParseChnlPlan(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseThermalMeter_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  _ReadLEDSetting(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseAntennaDiversity(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseEEPROMVer(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseCustomerID(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseRateIndicationOption(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
  Hal_EfuseParseXtal_8723A(padapter, (u8 *)(& hwinfo), (int )pEEPROM->bautoload_fail_flag);
  Hal_InitChannelPlan23a(padapter);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(): REPLACEMENT = %x\n", "readAdapterInfo", padapter->bDongle);
  } else {
  }
  return;
}
}
static void _ReadPROMContent(struct rtw_adapter *Adapter )
{
  struct eeprom_priv *pEEPROM ;
  u8 eeValue ;
  {
  pEEPROM = & Adapter->eeprompriv;
  eeValue = rtl8723au_read8(Adapter, 10U);
  pEEPROM->EepromOrEfuse = ((unsigned long )eeValue & 16UL) != 0UL;
  pEEPROM->bautoload_fail_flag = ((unsigned long )eeValue & 32UL) == 0UL;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Boot from %s, Autoload %s !\n", (unsigned int )pEEPROM->EepromOrEfuse != 0U ? (char *)"EEPROM" : (char *)"EFUSE",
           (unsigned int )pEEPROM->bautoload_fail_flag != 0U ? (char *)"Fail" : (char *)"OK");
  } else {
  }
  readAdapterInfo(Adapter);
  return;
}
}
static void _ReadRFType(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pHalData->rf_chip = 4U;
  return;
}
}
static void _ReadSilmComboMode(struct rtw_adapter *Adapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  pHalData->SlimComboDbg = 0;
  return;
}
}
static void hal_EfuseCellSel(struct rtw_adapter *Adapter )
{
  u32 value32 ;
  {
  value32 = rtl8723au_read32(Adapter, 52U);
  value32 = value32 & 4294966527U;
  rtl8723au_write32(Adapter, 52U, value32);
  return;
}
}
void rtl8723a_read_adapter_info(struct rtw_adapter *Adapter )
{
  unsigned long start ;
  unsigned int tmp ;
  {
  start = jiffies;
  Adapter->EepromAddressSize = GetEEPROMSize8723A(Adapter);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ====> _ReadAdapterInfo8723AU\n");
  } else {
  }
  hal_EfuseCellSel(Adapter);
  _ReadRFType(Adapter);
  _ReadPROMContent(Adapter);
  _ReadSilmComboMode(Adapter);
  if (GlobalDebugLevel23A > 3U) {
    tmp = jiffies_to_msecs((unsigned long )jiffies - start);
    printk("\016RTL8723AU: <==== _ReadAdapterInfo8723AU in %d ms\n", tmp);
  } else {
  }
  return;
}
}
int GetHalDefVar8192CUsb(struct rtw_adapter *Adapter , enum hal_def_variable eVariable ,
                         void *pValue )
{
  struct hal_data_8723a *pHalData ;
  int bResult ;
  struct dm_odm_t *pDM_Odm ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  bResult = 1;
  switch ((unsigned int )eVariable) {
  case 0U:
  *((int *)pValue) = pHalData->dmpriv.UndecoratedSmoothedPWDB;
  goto ldv_54619;
  case 1U: ;
  goto ldv_54619;
  case 2U: ;
  goto ldv_54619;
  case 3U:
  *((u32 *)pValue) = 4U;
  goto ldv_54619;
  case 4U:
  *((u32 *)pValue) = 15360U;
  goto ldv_54619;
  case 5U:
  *((u32 *)pValue) = 28U;
  goto ldv_54619;
  case 6U:
  *((u8 *)pValue) = pHalData->bDumpRxPkt;
  goto ldv_54619;
  case 7U:
  *((u32 *)pValue) = pHalData->odmpriv.SupportAbility;
  goto ldv_54619;
  case 11U:
  *((u32 *)pValue) = 3U;
  goto ldv_54619;
  case 15U:
  pDM_Odm = & pHalData->odmpriv;
  printk("pDM_Odm->DebugComponents = 0x%llx\n", pDM_Odm->DebugComponents);
  goto ldv_54619;
  default:
  bResult = 0;
  goto ldv_54619;
  }
  ldv_54619: ;
  return (bResult);
}
}
void rtl8723a_update_ramask(struct rtw_adapter *padapter , u32 mac_id , u8 rssi_level )
{
  u8 init_rate ;
  u8 networkType ;
  u8 raid ;
  u32 mask ;
  u32 rate_bitmap ;
  u8 shortGIrate ;
  int supportRateNum ;
  struct sta_info *psta ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  uint tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  uint tmp___4 ;
  uint tmp___5 ;
  u8 tmp___6 ;
  unsigned char tmp___7 ;
  u8 arg ;
  {
  init_rate = 0U;
  shortGIrate = 0U;
  supportRateNum = 0;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  if (mac_id > 31U) {
    return;
  } else {
  }
  psta = pmlmeinfo->FW_sta_info[mac_id].psta;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return;
  } else {
  }
  switch (mac_id) {
  case 0U:
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  supportRateNum = (int )tmp;
  tmp___0 = judge_network_type23a(padapter, (unsigned char *)(& cur_network->SupportedRates),
                                  supportRateNum);
  networkType = (unsigned int )tmp___0 & 15U;
  raid = networktype_to_raid23a((int )networkType);
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
  if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
    tmp___1 = update_MSC_rate23a(& pmlmeinfo->HT_caps);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = 0U;
  }
  mask = tmp___2 | mask;
  tmp___3 = support_short_GI23a(padapter, & pmlmeinfo->HT_caps);
  if (tmp___3 != 0) {
    shortGIrate = 1U;
  } else {
  }
  goto ldv_54650;
  case 1U:
  tmp___4 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
  supportRateNum = (int )tmp___4;
  if ((int )pmlmeext->cur_wireless_mode & 1) {
    networkType = 1U;
  } else {
    networkType = 2U;
  }
  raid = networktype_to_raid23a((int )networkType);
  mask = update_basic_rate23a((unsigned char *)(& cur_network->SupportedRates), (unsigned int )supportRateNum);
  goto ldv_54650;
  default:
  tmp___5 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
  supportRateNum = (int )tmp___5;
  tmp___6 = judge_network_type23a(padapter, (unsigned char *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                                  supportRateNum);
  networkType = (unsigned int )tmp___6 & 15U;
  raid = networktype_to_raid23a((int )networkType);
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
  goto ldv_54650;
  }
  ldv_54650:
  rate_bitmap = 268435455U;
  rate_bitmap = ODM_Get_Rate_Bitmap23a(& pHalData->odmpriv, mac_id, mask, (int )rssi_level);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s => mac_id:%d, networkType:0x%02x, mask:0x%08x\n\t ==> rssi_level:%d, rate_bitmap:0x%08x\n",
           "rtl8723a_update_ramask", mac_id, (int )networkType, mask, (int )rssi_level,
           rate_bitmap);
  } else {
  }
  mask = mask & rate_bitmap;
  mask = (u32 )((int )raid << 28) | mask;
  tmp___7 = get_highest_rate_idx23a(mask);
  init_rate = (unsigned int )tmp___7 & 63U;
  if ((unsigned int )pHalData->fw_ractrl == 1U) {
    arg = 0U;
    arg = (unsigned int )((u8 )mac_id) & 31U;
    arg = (u8 )((unsigned int )arg | 128U);
    if ((unsigned int )shortGIrate == 1U) {
      arg = (u8 )((unsigned int )arg | 32U);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: update raid entry, mask = 0x%x, arg = 0x%x\n", mask,
             (int )arg);
    } else {
    }
    rtl8723a_set_raid_cmd(padapter, mask, (int )arg);
  } else {
    if ((unsigned int )shortGIrate == 1U) {
      init_rate = (u8 )((unsigned int )init_rate | 64U);
    } else {
    }
    rtl8723au_write8(padapter, mac_id + 1156U, (int )init_rate);
  }
  psta->raid = raid;
  psta->init_rate = init_rate;
  pdmpriv->INIDATA_RATE[mac_id] = init_rate;
  return;
}
}
int rtw_hal_init23a(struct rtw_adapter *padapter )
{
  int status ;
  {
  padapter->hw_init_completed = 0U;
  status = rtl8723au_hal_init(padapter);
  if (status == 1) {
    padapter->hw_init_completed = 1U;
    if ((unsigned int )padapter->registrypriv.notch_filter == 1U) {
      rtl8723a_notch_filter(padapter, 1);
    } else {
    }
  } else {
    padapter->hw_init_completed = 0U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: rtw_hal_init23a: hal__init fail\n");
    } else {
    }
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
    printk("\016-rtl871x_hal_init:status = 0x%x\n", status);
  } else {
  }
  return (status);
}
}
int rtw_hal_deinit23a(struct rtw_adapter *padapter )
{
  int status ;
  {
  status = rtl8723au_hal_deinit(padapter);
  if (status == 1) {
    padapter->hw_init_completed = 0U;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: \n rtw_hal_deinit23a: hal_init fail\n");
  } else {
  }
  return (status);
}
}
void *ldv_kmem_cache_alloc_1970(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_1976(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1978(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_1980(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1981(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1982(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_1983(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1984(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_1985(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_1986(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void *ldv_kmem_cache_alloc_2012(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2020(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2028(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2031(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2022(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2018(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2026(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2027(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
extern struct sk_buff *skb_dequeue(struct sk_buff_head * ) ;
__inline static void skb_reset_tail_pointer(struct sk_buff *skb )
{
  {
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
  return;
}
}
struct sk_buff *ldv___netdev_alloc_skb_2023(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2024(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2025(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev , unsigned int length )
{
  struct sk_buff *tmp ;
  {
  tmp = ldv___netdev_alloc_skb_2023(dev, length, 32U);
  return (tmp);
}
}
extern void __tasklet_schedule(struct tasklet_struct * ) ;
__inline static void tasklet_schedule(struct tasklet_struct *t )
{
  int tmp ;
  {
  tmp = test_and_set_bit(0L, (unsigned long volatile *)(& t->state));
  if (tmp == 0) {
    __tasklet_schedule(t);
  } else {
  }
  return;
}
}
__inline static void usb_fill_bulk_urb(struct urb *urb , struct usb_device *dev ,
                                       unsigned int pipe , void *transfer_buffer ,
                                       int buffer_length , void (*complete_fn)(struct urb * ) ,
                                       void *context )
{
  {
  urb->dev = dev;
  urb->pipe = pipe;
  urb->transfer_buffer = transfer_buffer;
  urb->transfer_buffer_length = (u32 )buffer_length;
  urb->complete = complete_fn;
  urb->context = context;
  return;
}
}
__inline static void usb_fill_int_urb(struct urb *urb , struct usb_device *dev , unsigned int pipe ,
                                      void *transfer_buffer , int buffer_length ,
                                      void (*complete_fn)(struct urb * ) , void *context ,
                                      int interval )
{
  int __val ;
  int __min ;
  int __max ;
  {
  urb->dev = dev;
  urb->pipe = pipe;
  urb->transfer_buffer = transfer_buffer;
  urb->transfer_buffer_length = (u32 )buffer_length;
  urb->complete = complete_fn;
  urb->context = context;
  if ((unsigned int )dev->speed == 3U || (unsigned int )dev->speed == 5U) {
    __val = interval;
    __min = 1;
    __max = 16;
    __val = __min > __val ? __min : __val;
    interval = __max < __val ? __max : __val;
    urb->interval = 1 << (interval + -1);
  } else {
    urb->interval = interval;
  }
  urb->start_frame = -1;
  return;
}
}
extern int usb_submit_urb(struct urb * , gfp_t ) ;
int ldv_usb_submit_urb_2029(struct urb *ldv_func_arg1 , gfp_t flags ) ;
int ldv_usb_submit_urb_2030(struct urb *ldv_func_arg1 , gfp_t flags ) ;
int ldv_usb_submit_urb_2032(struct urb *ldv_func_arg1 , gfp_t flags ) ;
extern int usb_control_msg(struct usb_device * , unsigned int , __u8 , __u8 , __u16 ,
                           __u16 , void * , __u16 , int ) ;
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint )
{
  {
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
void rtl8723au_set_hw_type(struct rtw_adapter *padapter ) ;
__inline static int rtw_inc_and_chk_continual_urb_error(struct dvobj_priv *dvobj )
{
  int ret ;
  int value ;
  {
  ret = 0;
  value = atomic_add_return(1, & dvobj->continual_urb_error);
  if (value > 4) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: [dvobj:%p][OLD_ERROR] continual_urb_error:%d > %d\n", dvobj,
             value, 4);
    } else {
    }
    ret = 1;
  } else {
  }
  return (ret);
}
}
__inline static void rtw_reset_continual_urb_error(struct dvobj_priv *dvobj )
{
  {
  atomic_set(& dvobj->continual_urb_error, 0);
  return;
}
}
static int usbctrl_vendorreq(struct rtw_adapter *padapter , u8 request , u16 value ,
                             u16 index , void *pdata , u16 len , u8 requesttype )
{
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  unsigned int pipe ;
  int status ;
  u8 reqtype ;
  u8 *pIo_buf ;
  int vendorreq_times ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct hal_data_8723a *pHalData ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___1 ;
  {
  pdvobjpriv = padapter->dvobj;
  udev = pdvobjpriv->pusbdev;
  status = 0;
  vendorreq_times = 0;
  if (padapter->bSurpriseRemoved != 0 || (unsigned int )padapter->pwrctrlpriv.pnp_bstop_trx != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usbctrl_vendorreq:(padapter->bSurpriseRemoved||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n");
    } else {
    }
    status = -1;
    goto exit;
  } else {
  }
  if ((unsigned int )len > 254U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: [%s] Buffer len error , vendor request failed\n", "usbctrl_vendorreq");
    } else {
    }
    status = -22;
    goto exit;
  } else {
  }
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
  pIo_buf = pdvobjpriv->usb_vendor_req_buf;
  if ((unsigned long )pIo_buf == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: [%s] pIo_buf == NULL \n", "usbctrl_vendorreq");
    } else {
    }
    status = -12;
    goto release_mutex;
  } else {
  }
  goto ldv_54340;
  ldv_54339:
  memset((void *)pIo_buf, 0, (size_t )len);
  if ((unsigned int )requesttype == 1U) {
    tmp = __create_pipe(udev, 0U);
    pipe = tmp | 2147483776U;
    reqtype = 192U;
  } else {
    tmp___0 = __create_pipe(udev, 0U);
    pipe = tmp___0 | 2147483648U;
    reqtype = 64U;
    __len = (size_t )len;
    __ret = memcpy((void *)pIo_buf, (void const *)pdata, __len);
  }
  status = usb_control_msg(udev, pipe, (int )request, (int )reqtype, (int )value,
                           (int )index, (void *)pIo_buf, (int )len, 500);
  if ((int )len == status) {
    rtw_reset_continual_urb_error(pdvobjpriv);
    if ((unsigned int )requesttype == 1U) {
      __len___0 = (size_t )len;
      __ret___0 = memcpy(pdata, (void const *)pIo_buf, __len___0);
    } else {
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: reg 0x%x, usb %s %u fail, status:%d value = 0x%x, vendorreq_times:%d\n",
             (int )value, (unsigned int )requesttype == 1U ? (char *)"read" : (char *)"write",
             (int )len, status, *((u32 *)pdata), vendorreq_times);
    } else {
    }
    if (status < 0) {
      if (status == -108 || status == -19) {
        padapter->bSurpriseRemoved = 1;
      } else {
        pHalData = (struct hal_data_8723a *)padapter->HalData;
        pHalData->srestpriv.Wifi_Error_Status = 1U;
      }
    } else
    if (status > 0) {
      if ((unsigned int )requesttype == 1U) {
        __len___1 = (size_t )len;
        __ret___1 = memcpy(pdata, (void const *)pIo_buf, __len___1);
      } else {
      }
    } else {
    }
    tmp___1 = rtw_inc_and_chk_continual_urb_error(pdvobjpriv);
    if (tmp___1 != 0) {
      padapter->bSurpriseRemoved = 1;
      goto ldv_54338;
    } else {
    }
  }
  if (((unsigned int )value > 4095U && (unsigned int )value <= 8191U) || (int )len == status) {
    goto ldv_54338;
  } else {
  }
  ldv_54340:
  vendorreq_times = vendorreq_times + 1;
  if (vendorreq_times <= 10) {
    goto ldv_54339;
  } else {
  }
  ldv_54338: ;
  release_mutex:
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
  exit: ;
  return (status);
}
}
u8 rtl8723au_read8(struct rtw_adapter *padapter , u32 addr )
{
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  u8 data ;
  {
  data = 0U;
  request = 5U;
  requesttype = 1U;
  index = 0U;
  wvalue = (unsigned short )addr;
  len = 1U;
  usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                    (int )len, (int )requesttype);
  return (data);
}
}
u16 rtl8723au_read16(struct rtw_adapter *padapter , u32 addr )
{
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  __le16 data ;
  {
  request = 5U;
  requesttype = 1U;
  index = 0U;
  wvalue = (unsigned short )addr;
  len = 2U;
  usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                    (int )len, (int )requesttype);
  return (data);
}
}
u32 rtl8723au_read32(struct rtw_adapter *padapter , u32 addr )
{
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  __le32 data ;
  {
  request = 5U;
  requesttype = 1U;
  index = 0U;
  wvalue = (unsigned short )addr;
  len = 4U;
  usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                    (int )len, (int )requesttype);
  return (data);
}
}
int rtl8723au_write8(struct rtw_adapter *padapter , u32 addr , u8 val )
{
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  u8 data ;
  int ret ;
  {
  request = 5U;
  requesttype = 0U;
  index = 0U;
  wvalue = (unsigned short )addr;
  len = 1U;
  data = val;
  ret = usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                          (int )len, (int )requesttype);
  return (ret);
}
}
int rtl8723au_write16(struct rtw_adapter *padapter , u32 addr , u16 val )
{
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  __le16 data ;
  int ret ;
  {
  request = 5U;
  requesttype = 0U;
  index = 0U;
  wvalue = (unsigned short )addr;
  len = 2U;
  data = val;
  ret = usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                          (int )len, (int )requesttype);
  return (ret);
}
}
int rtl8723au_write32(struct rtw_adapter *padapter , u32 addr , u32 val )
{
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  __le32 data ;
  int ret ;
  {
  request = 5U;
  requesttype = 0U;
  index = 0U;
  wvalue = (unsigned short )addr;
  len = 4U;
  data = val;
  ret = usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                          (int )len, (int )requesttype);
  return (ret);
}
}
int rtl8723au_writeN(struct rtw_adapter *padapter , u32 addr , u32 length , u8 *pdata )
{
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  u8 buf[254U] ;
  unsigned int tmp ;
  int ret ;
  size_t __len ;
  void *__ret ;
  {
  buf[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 254U) {
      break;
    } else {
    }
    buf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  request = 5U;
  requesttype = 0U;
  index = 0U;
  wvalue = (unsigned short )addr;
  len = (u16 )length;
  __len = (size_t )len;
  __ret = memcpy((void *)(& buf), (void const *)pdata, __len);
  ret = usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& buf),
                          (int )len, (int )requesttype);
  return (ret);
}
}
static bool InterruptRecognized8723AU(struct rtw_adapter *Adapter , void *pContent ,
                                      u32 ContentLen )
{
  struct hal_data_8723a *pHalData ;
  u8 *buffer ;
  struct reportpwrstate_parm report ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  {
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
  buffer = (u8 *)pContent;
  __len = 4UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pHalData->IntArray), (void const *)buffer + 48U,
                     __len);
  } else {
    __ret = memcpy((void *)(& pHalData->IntArray), (void const *)buffer + 48U,
                             __len);
  }
  pHalData->IntArray[0] = pHalData->IntArray[0] & pHalData->IntrMask[0];
  __len___0 = 4UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& pHalData->IntArray) + 1U, (void const *)buffer + 52U,
                         __len___0);
  } else {
    __ret___0 = memcpy((void *)(& pHalData->IntArray) + 1U, (void const *)buffer + 52U,
                                 __len___0);
  }
  pHalData->IntArray[1] = pHalData->IntArray[1] & pHalData->IntrMask[1];
  __len___1 = 1UL;
  if (__len___1 > 63UL) {
    __ret___1 = memcpy((void *)(& report.state), (void const *)buffer + 16U, __len___1);
  } else {
    __ret___1 = memcpy((void *)(& report.state), (void const *)buffer + 16U,
                                 __len___1);
  }
  return ((bool )((pHalData->IntArray[0] & pHalData->IntrMask[0]) != 0U || (pHalData->IntArray[1] & pHalData->IntrMask[1]) != 0U));
}
}
static void usb_read_interrupt_complete(struct urb *purb )
{
  int err ;
  struct rtw_adapter *padapter ;
  struct c2h_evt_hdr *c2h_evt ;
  struct evt_work *c2w ;
  int res ;
  void *tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  size_t __len ;
  void *__ret ;
  bool tmp___0 ;
  bool tmp___1 ;
  {
  padapter = (struct rtw_adapter *)purb->context;
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bReadPortCancel != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s() RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
             "usb_read_interrupt_complete", padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel);
    } else {
    }
    return;
  } else {
  }
  if (purb->status == 0) {
    c2h_evt = (struct c2h_evt_hdr *)purb->transfer_buffer;
    if (purb->actual_length > 56U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: usb_read_interrupt_complete: purb->actual_length > USB_INTR_CONTENT_LENGTH\n");
      } else {
      }
      goto urb_submit;
    } else {
    }
    InterruptRecognized8723AU(padapter, purb->transfer_buffer, purb->actual_length);
    if ((unsigned int )*((unsigned char *)c2h_evt + 0UL) != 0U || (unsigned int )*((unsigned char *)c2h_evt + 0UL) != 0U) {
      tmp___1 = c2h_id_filter_ccx_8723a((int )c2h_evt->id);
      if ((int )tmp___1) {
        handle_txrpt_ccx_8723a(padapter, (void *)(& c2h_evt->payload));
        schedule_work(& padapter->evtpriv.irq_wk);
      } else {
        tmp = kmalloc(104UL, 32U);
        c2w = (struct evt_work *)tmp;
        if ((unsigned long )c2w == (unsigned long )((struct evt_work *)0)) {
          printk("\f%s: unable to allocate work buffer\n", "usb_read_interrupt_complete");
          goto urb_submit;
        } else {
        }
        c2w->adapter = padapter;
        __init_work(& c2w->work, 0);
        __constr_expr_0.counter = 137438953408L;
        c2w->work.data = __constr_expr_0;
        lockdep_init_map(& c2w->work.lockdep_map, "(&c2w->work)", & __key, 0);
        INIT_LIST_HEAD(& c2w->work.entry);
        c2w->work.func = & rtw_evt_work;
        __len = 16UL;
        if (__len > 63UL) {
          __ret = memcpy((void *)(& c2w->u.buf), (void const *)purb->transfer_buffer,
                           __len);
        } else {
          __ret = memcpy((void *)(& c2w->u.buf), (void const *)purb->transfer_buffer,
                                   __len);
        }
        tmp___0 = queue_work(padapter->evtpriv.wq, & c2w->work);
        res = (int )tmp___0;
        if (res == 0) {
          printk("\v%s: Call to queue_work() failed\n", "usb_read_interrupt_complete");
          kfree((void const *)c2w);
          goto urb_submit;
        } else {
        }
      }
    } else {
    }
    urb_submit:
    err = ldv_usb_submit_urb_2029(purb, 32U);
    if (err != 0 && err != -1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: cannot submit interrupt in-token(err = 0x%08x), urb_status = %d\n",
               err, purb->status);
      } else {
      }
    } else {
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ###=> usb_read_interrupt_complete => urb status(%d)\n",
             purb->status);
    } else {
    }
    switch (purb->status) {
    case -22: ;
    case -32: ;
    case -19: ;
    case -108: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_read_port_complete:bSurpriseRemoved =true\n");
    } else {
    }
    case -2:
    padapter->bDriverStopped = 1;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_read_port_complete:bDriverStopped =true\n");
    } else {
    }
    goto ldv_54460;
    case -71: ;
    goto ldv_54460;
    case -115: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: OLD_ERROR: URB IS IN PROGRESS!\n");
    } else {
    }
    goto ldv_54460;
    default: ;
    goto ldv_54460;
    }
    ldv_54460: ;
  }
  return;
}
}
int rtl8723au_read_interrupt(struct rtw_adapter *adapter , u32 addr )
{
  int err ;
  unsigned int pipe ;
  int ret ;
  struct dvobj_priv *pdvobj ;
  struct recv_priv *precvpriv ;
  struct usb_device *pusbd ;
  unsigned int tmp ;
  {
  ret = 1;
  pdvobj = adapter->dvobj;
  precvpriv = & adapter->recvpriv;
  pusbd = pdvobj->pusbdev;
  tmp = __create_pipe(pusbd, (unsigned int )pdvobj->RtInPipe[1]);
  pipe = tmp | 1073741952U;
  usb_fill_int_urb(precvpriv->int_in_urb, pusbd, pipe, (void *)precvpriv->int_in_buf,
                   56, & usb_read_interrupt_complete, (void *)adapter, 1);
  err = ldv_usb_submit_urb_2030(precvpriv->int_in_urb, 32U);
  if (err != 0 && err != -1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",
             err, (precvpriv->int_in_urb)->status);
    } else {
    }
    ret = 0;
  } else {
  }
  return (ret);
}
}
static int recvbuf2recvframe(struct rtw_adapter *padapter , struct sk_buff *pskb )
{
  u8 *pbuf ;
  u8 shift_sz ;
  u16 pkt_cnt ;
  u32 pkt_offset ;
  u32 skb_len ;
  u32 alloc_sz ;
  int transfer_len ;
  struct recv_stat *prxstat ;
  struct phy_stat *pphy_info ;
  struct sk_buff *pkt_copy ;
  struct recv_frame *precvframe ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *pfree_recv_queue ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  {
  shift_sz = 0U;
  precvpriv = & padapter->recvpriv;
  pfree_recv_queue = & precvpriv->free_recv_queue;
  transfer_len = (int )pskb->len;
  pbuf = pskb->data;
  prxstat = (struct recv_stat *)pbuf;
  pkt_cnt = (unsigned int )((u16 )(prxstat->rxdw2 >> 16)) & 255U;
  ldv_54497: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
    printk("\016recvbuf2recvframe: rxdesc = offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
           prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4);
  } else {
  }
  prxstat = (struct recv_stat *)pbuf;
  precvframe = rtw_alloc_recvframe23a(pfree_recv_queue);
  if ((unsigned long )precvframe == (unsigned long )((struct recv_frame *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016recvbuf2recvframe: precvframe == NULL\n");
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: rtw_alloc_recvframe23a() failed! RX Drop!\n",
             "recvbuf2recvframe", 728);
    } else {
    }
    goto _exit_recvbuf2recvframe;
  } else {
  }
  INIT_LIST_HEAD(& precvframe->list);
  update_recvframe_attrib(precvframe, prxstat);
  pattrib = & precvframe->attrib;
  if ((unsigned int )pattrib->crc_err != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: RX Warning! rx CRC OLD_ERROR !!\n", "recvbuf2recvframe",
             740);
    } else {
    }
    rtw_free_recvframe23a(precvframe);
    goto _exit_recvbuf2recvframe;
  } else {
  }
  pkt_offset = (u32 )((((int )pattrib->drvinfo_sz + 24) + (int )pattrib->shift_sz) + (int )pattrib->pkt_len);
  if ((unsigned int )pattrib->pkt_len == 0U || (u32 )transfer_len < pkt_offset) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
      printk("\016recvbuf2recvframe: pkt_len<= 0\n");
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: RX Warning!\n", "recvbuf2recvframe", 752);
    } else {
    }
    rtw_free_recvframe23a(precvframe);
    goto _exit_recvbuf2recvframe;
  } else {
  }
  if ((unsigned int )pattrib->qos != 0U) {
    shift_sz = 6U;
  } else {
    shift_sz = 0U;
  }
  skb_len = (u32 )pattrib->pkt_len;
  if ((unsigned int )pattrib->mfrag == 1U && (unsigned int )pattrib->frag_num == 0U) {
    if (skb_len <= 1650U) {
      alloc_sz = 1664U;
    } else {
      alloc_sz = skb_len + 14U;
    }
  } else {
    alloc_sz = skb_len;
    alloc_sz = alloc_sz + 14U;
  }
  pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
  if ((unsigned long )pkt_copy != (unsigned long )((struct sk_buff *)0)) {
    pkt_copy->dev = padapter->pnetdev;
    precvframe->pkt = pkt_copy;
    skb_reserve(pkt_copy, (int )(8U - ((unsigned int )((long )pkt_copy->data) & 7U)));
    skb_reserve(pkt_copy, (int )shift_sz);
    __len = (size_t )skb_len;
    __ret = memcpy((void *)pkt_copy->data, (void const *)(pbuf + (((unsigned long )pattrib->shift_sz + (unsigned long )pattrib->drvinfo_sz) + 24UL)),
                             __len);
    skb_put(pkt_copy, skb_len);
  } else {
    if ((unsigned int )pattrib->mfrag == 1U && (unsigned int )pattrib->frag_num == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: recvbuf2recvframe: alloc_skb fail, drop frag frame \n");
      } else {
      }
      rtw_free_recvframe23a(precvframe);
      goto _exit_recvbuf2recvframe;
    } else {
    }
    precvframe->pkt = ldv_skb_clone_2031(pskb, 32U);
    if ((unsigned long )precvframe->pkt == (unsigned long )((struct sk_buff *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: recvbuf2recvframe: skb_clone fail\n");
      } else {
      }
      rtw_free_recvframe23a(precvframe);
      goto _exit_recvbuf2recvframe;
    } else {
    }
  }
  if ((unsigned int )pattrib->physt != 0U) {
    pphy_info = (struct phy_stat *)pbuf + 24U;
    update_recvframe_phyinfo(precvframe, pphy_info);
  } else {
  }
  tmp = rtw_recv_entry23a(precvframe);
  if (tmp != 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
      printk("\016recvbuf2recvframe: rtw_recv_entry23a(precvframe) != _SUCCESS\n");
    } else {
    }
  } else {
  }
  pkt_cnt = (u16 )((int )pkt_cnt - 1);
  transfer_len = (int )((u32 )transfer_len - pkt_offset);
  pbuf = pbuf + (unsigned long )pkt_offset;
  precvframe = (struct recv_frame *)0;
  pkt_copy = (struct sk_buff *)0;
  if (transfer_len > 0 && (unsigned int )pkt_cnt == 0U) {
    pkt_cnt = (unsigned int )((u16 )(prxstat->rxdw2 >> 16)) & 255U;
  } else {
  }
  if (transfer_len > 0 && (unsigned int )pkt_cnt != 0U) {
    goto ldv_54497;
  } else {
  }
  _exit_recvbuf2recvframe: ;
  return (1);
}
}
void rtl8723au_recv_tasklet(void *priv )
{
  struct sk_buff *pskb ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  {
  padapter = (struct rtw_adapter *)priv;
  precvpriv = & padapter->recvpriv;
  goto ldv_54507;
  ldv_54506: ;
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
    } else {
    }
    dev_kfree_skb_any(pskb);
    goto ldv_54505;
  } else {
  }
  recvbuf2recvframe(padapter, pskb);
  skb_reset_tail_pointer(pskb);
  pskb->len = 0U;
  skb_queue_tail(& precvpriv->free_recv_skb_queue, pskb);
  ldv_54507:
  pskb = skb_dequeue(& precvpriv->rx_skb_queue);
  if ((unsigned long )pskb != (unsigned long )((struct sk_buff *)0)) {
    goto ldv_54506;
  } else {
  }
  ldv_54505: ;
  return;
}
}
static void usb_read_port_complete(struct urb *purb )
{
  struct recv_buf *precvbuf ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct hal_data_8723a *pHalData ;
  __u32 tmp ;
  int tmp___0 ;
  {
  precvbuf = (struct recv_buf *)purb->context;
  padapter = precvbuf->adapter;
  precvpriv = & padapter->recvpriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
    printk("\016usb_read_port_complete!!!\n");
  } else {
  }
  precvpriv->rx_pending_cnt = (u8 )((int )precvpriv->rx_pending_cnt - 1);
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bReadPortCancel != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n",
             padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s()-%d: RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
             "usb_read_port_complete", 885, padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel);
    } else {
    }
    return;
  } else {
  }
  if (purb->status == 0) {
    if (purb->actual_length > 15360U || purb->actual_length <= 23U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
        printk("\016usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n");
      } else {
      }
      rtl8723au_read_port(padapter, 128U, 0U, precvbuf);
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s()-%d: RX Warning!\n", "usb_read_port_complete",
               899);
      } else {
      }
    } else {
      rtw_reset_continual_urb_error(padapter->dvobj);
      skb_put(precvbuf->pskb, purb->actual_length);
      skb_queue_tail(& precvpriv->rx_skb_queue, precvbuf->pskb);
      tmp = skb_queue_len((struct sk_buff_head const *)(& precvpriv->rx_skb_queue));
      if (tmp <= 1U) {
        tasklet_schedule(& precvpriv->recv_tasklet);
      } else {
      }
      precvbuf->pskb = (struct sk_buff *)0;
      rtl8723au_read_port(padapter, 128U, 0U, precvbuf);
    }
  } else {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_read_port_complete : purb->status(%d) != 0 \n", purb->status);
    } else {
    }
    skb_put(precvbuf->pskb, purb->actual_length);
    precvbuf->pskb = (struct sk_buff *)0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ###=> usb_read_port_complete => urb status(%d)\n", purb->status);
    } else {
    }
    tmp___0 = rtw_inc_and_chk_continual_urb_error(padapter->dvobj);
    if (tmp___0 != 0) {
      padapter->bSurpriseRemoved = 1;
    } else {
    }
    switch (purb->status) {
    case -22: ;
    case -32: ;
    case -19: ;
    case -108: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_read_port_complete:bSurpriseRemoved = true\n");
    } else {
    }
    case -2:
    padapter->bDriverStopped = 1;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_read_port_complete:bDriverStopped = true\n");
    } else {
    }
    goto ldv_54521;
    case -71: ;
    case -75:
    pHalData = (struct hal_data_8723a *)padapter->HalData;
    pHalData->srestpriv.Wifi_Error_Status = 2U;
    rtl8723au_read_port(padapter, 128U, 0U, precvbuf);
    goto ldv_54521;
    case -115: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: OLD_ERROR: URB IS IN PROGRESS!\n");
    } else {
    }
    goto ldv_54521;
    default: ;
    goto ldv_54521;
    }
    ldv_54521: ;
  }
  return;
}
}
int rtl8723au_read_port(struct rtw_adapter *adapter , u32 addr , u32 cnt , struct recv_buf *precvbuf )
{
  int err ;
  unsigned int pipe ;
  unsigned long tmpaddr ;
  unsigned long alignment ;
  int ret ;
  struct urb *purb ;
  struct dvobj_priv *pdvobj ;
  struct recv_priv *precvpriv ;
  struct usb_device *pusbd ;
  unsigned int tmp ;
  {
  ret = 1;
  pdvobj = adapter->dvobj;
  precvpriv = & adapter->recvpriv;
  pusbd = pdvobj->pusbdev;
  if ((adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) || (unsigned int )adapter->pwrctrlpriv.pnp_bstop_trx != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n");
    } else {
    }
    return (0);
  } else {
  }
  if ((unsigned long )precvbuf == (unsigned long )((struct recv_buf *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_read_port:precvbuf == NULL\n");
    } else {
    }
    return (0);
  } else {
  }
  if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
    precvbuf->pskb = skb_dequeue(& precvpriv->free_recv_skb_queue);
  } else {
  }
  if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
    precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, 15368U);
    if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
        printk("\016init_recvbuf(): alloc_skb fail!\n");
      } else {
      }
      return (0);
    } else {
    }
    tmpaddr = (unsigned long )(precvbuf->pskb)->data;
    alignment = tmpaddr & 7UL;
    skb_reserve(precvbuf->pskb, (int )(8U - (unsigned int )alignment));
  } else {
  }
  precvpriv->rx_pending_cnt = (u8 )((int )precvpriv->rx_pending_cnt + 1);
  purb = precvbuf->purb;
  tmp = __create_pipe(pusbd, (unsigned int )pdvobj->RtInPipe[0]);
  pipe = tmp | 3221225600U;
  usb_fill_bulk_urb(purb, pusbd, pipe, (void *)(precvbuf->pskb)->data, 15360, & usb_read_port_complete,
                    (void *)precvbuf);
  err = ldv_usb_submit_urb_2032(purb, 32U);
  if (err != 0 && err != -1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016cannot submit rx in-token(err = 0x%.8x), URB_STATUS = 0x%.8x", err,
             purb->status);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: cannot submit rx in-token(err = 0x%08x), urb_status = %d\n",
             err, purb->status);
    } else {
    }
    ret = 0;
  } else {
  }
  return (ret);
}
}
void rtl8723au_xmit_tasklet(void *priv )
{
  int ret ;
  struct rtw_adapter *padapter ;
  struct xmit_priv *pxmitpriv ;
  bool tmp ;
  bool tmp___0 ;
  {
  padapter = (struct rtw_adapter *)priv;
  pxmitpriv = & padapter->xmitpriv;
  tmp = check_fwstate(& padapter->mlmepriv, 2048);
  if ((int )tmp) {
    return;
  } else {
  }
  ldv_54548: ;
  if ((padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) || (unsigned int )padapter->bWritePortCancel != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: xmit_tasklet => bDriverStopped or bSurpriseRemoved or bWritePortCancel\n");
    } else {
    }
    goto ldv_54547;
  } else {
  }
  tmp___0 = rtl8723au_xmitframe_complete(padapter, pxmitpriv, (struct xmit_buf *)0);
  ret = (int )tmp___0;
  if (ret == 0) {
    goto ldv_54547;
  } else {
  }
  goto ldv_54548;
  ldv_54547: ;
  return;
}
}
void rtl8723au_set_hw_type(struct rtw_adapter *padapter )
{
  {
  padapter->chip_type = 4U;
  padapter->HardwareType = 14U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: CHIP TYPE: RTL8723A\n");
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_2012(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2018(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2020(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2022(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2023(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2024(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2025(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2026(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2027(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2028(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_usb_submit_urb_2029(struct urb *ldv_func_arg1 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = usb_submit_urb(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_usb_submit_urb_2030(struct urb *ldv_func_arg1 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = usb_submit_urb(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2031(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_usb_submit_urb_2032(struct urb *ldv_func_arg1 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = usb_submit_urb(ldv_func_arg1, flags);
  return (tmp);
}
}
extern int strcmp(char const * , char const * ) ;
extern char *strncpy(char * , char const * , __kernel_size_t ) ;
__inline static void *ERR_PTR(long error )
{
  {
  return ((void *)error);
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
__inline static char const *kobject_name(struct kobject const *kobj )
{
  {
  return ((char const *)kobj->name);
}
}
void *ldv_kmem_cache_alloc_2062(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
extern u32 __VERIFIER_nondet_u32(void) ;
extern u16 __VERIFIER_nondet_u16(void) ;
extern u8 __VERIFIER_nondet_u8(void) ;
struct wiphy *rtw_cfg80211_ops_group1 ;
int ldv_state_variable_14 ;
int ref_cnt ;
struct station_parameters *rtw_cfg80211_ops_group2 ;
struct station_info *rtw_cfg80211_ops_group3 ;
int usb_counter ;
struct vif_params *rtw_cfg80211_ops_group5 ;
int ldv_state_variable_15 ;
struct net_device *rtw_cfg80211_ops_group6 ;
struct wireless_dev *rtw_cfg80211_ops_group0 ;
struct net_device *rtw_cfg80211_monitor_if_ops_group1 ;
struct cfg80211_pmksa *rtw_cfg80211_ops_group4 ;
void ldv_net_device_ops_15(void) ;
void ldv_initialize_cfg80211_ops_14(void) ;
__inline static char const *dev_name(struct device const *dev )
{
  char const *tmp ;
  {
  if ((unsigned long )dev->init_name != (unsigned long )((char const * )0)) {
    return ((char const *)dev->init_name);
  } else {
  }
  tmp = kobject_name(& dev->kobj);
  return (tmp);
}
}
extern void consume_skb(struct sk_buff * ) ;
struct sk_buff *ldv_skb_clone_2070(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2078(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2072(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2068(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2076(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2077(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2073(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2074(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2075(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
__inline static void *netdev_priv(struct net_device const *dev )
{
  {
  return ((void *)dev + 3264U);
}
}
extern int register_netdevice(struct net_device * ) ;
extern void unregister_netdevice_queue(struct net_device * , struct list_head * ) ;
__inline static void unregister_netdevice(struct net_device *dev )
{
  {
  unregister_netdevice_queue(dev, (struct list_head *)0);
  return;
}
}
extern void free_netdev(struct net_device * ) ;
void ldv_free_netdev_2079(struct net_device *dev ) ;
extern void unregister_netdev(struct net_device * ) ;
void ldv_unregister_netdev_2080(struct net_device *dev ) ;
extern struct net_device *alloc_etherdev_mqs(int , unsigned int , unsigned int ) ;
__inline static void eth_broadcast_addr(u8 *addr )
{
  {
  memset((void *)addr, 255, 6UL);
  return;
}
}
__inline static void eth_zero_addr(u8 *addr )
{
  {
  memset((void *)addr, 0, 6UL);
  return;
}
}
__inline static int ieee80211_get_radiotap_len(unsigned char *data )
{
  struct ieee80211_radiotap_header *hdr ;
  u16 tmp ;
  {
  hdr = (struct ieee80211_radiotap_header *)data;
  tmp = get_unaligned_le16((void const *)(& hdr->it_len));
  return ((int )tmp);
}
}
__inline static int ieee80211_is_action(__le16 fc )
{
  {
  return (((int )fc & 252) == 208);
}
}
__inline static void *wiphy_priv___1(struct wiphy *wiphy )
{
  long tmp ;
  {
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3111), "i" (12UL));
    ldv_45899: ;
    goto ldv_45899;
  } else {
  }
  return ((void *)(& wiphy->priv));
}
}
__inline static void set_wiphy_dev(struct wiphy *wiphy , struct device *dev )
{
  {
  wiphy->dev.parent = dev;
  return;
}
}
__inline static char const *wiphy_name(struct wiphy const *wiphy )
{
  char const *tmp ;
  {
  tmp = dev_name(& wiphy->dev);
  return (tmp);
}
}
extern struct wiphy *wiphy_new(struct cfg80211_ops const * , int ) ;
extern int wiphy_register(struct wiphy * ) ;
extern void wiphy_unregister(struct wiphy * ) ;
extern void wiphy_free(struct wiphy * ) ;
__inline static void *wdev_priv___1(struct wireless_dev *wdev )
{
  long tmp ;
  void *tmp___0 ;
  {
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3343), "i" (12UL));
    ldv_45979: ;
    goto ldv_45979;
  } else {
  }
  tmp___0 = wiphy_priv___1(wdev->wiphy);
  return (tmp___0);
}
}
extern int ieee80211_channel_to_frequency(int , enum ieee80211_band ) ;
extern int ieee80211_frequency_to_channel(int ) ;
extern struct ieee80211_channel *__ieee80211_get_channel(struct wiphy * , int ) ;
__inline static struct ieee80211_channel *ieee80211_get_channel(struct wiphy *wiphy ,
                                                                int freq )
{
  struct ieee80211_channel *tmp ;
  {
  tmp = __ieee80211_get_channel(wiphy, freq);
  return (tmp);
}
}
extern void cfg80211_scan_done(struct cfg80211_scan_request * , bool ) ;
extern struct cfg80211_bss *cfg80211_inform_bss_width_frame(struct wiphy * , struct ieee80211_channel * ,
                                                            enum nl80211_bss_scan_width ,
                                                            struct ieee80211_mgmt * ,
                                                            size_t , s32 , gfp_t ) ;
__inline static struct cfg80211_bss *cfg80211_inform_bss_frame(struct wiphy *wiphy ,
                                                               struct ieee80211_channel *rx_channel ,
                                                               struct ieee80211_mgmt *mgmt ,
                                                               size_t len , s32 signal ,
                                                               gfp_t gfp )
{
  struct cfg80211_bss *tmp ;
  {
  tmp = cfg80211_inform_bss_width_frame(wiphy, rx_channel, 0, mgmt, len, signal, gfp);
  return (tmp);
}
}
extern void cfg80211_put_bss(struct wiphy * , struct cfg80211_bss * ) ;
extern void cfg80211_connect_result(struct net_device * , u8 const * , u8 const * ,
                                    size_t , u8 const * , size_t , u16 , gfp_t ) ;
extern void cfg80211_roamed(struct net_device * , struct ieee80211_channel * , u8 const * ,
                            u8 const * , size_t , u8 const * , size_t , gfp_t ) ;
extern void cfg80211_disconnected(struct net_device * , u16 , u8 const * , size_t ,
                                  gfp_t ) ;
extern bool cfg80211_rx_mgmt(struct wireless_dev * , int , int , u8 const * ,
                             size_t , u32 , gfp_t ) ;
extern void cfg80211_mgmt_tx_status(struct wireless_dev * , u64 , u8 const * ,
                                    size_t , bool , gfp_t ) ;
int rtw_xmit23a_entry23a(struct sk_buff *skb , struct net_device *pnetdev ) ;
void rtw_ndev_destructor(struct net_device *ndev ) ;
int rtw_check_beacon_data23a(struct rtw_adapter *padapter , u8 *pbuf , unsigned int len ) ;
int rtw_sta_flush23a(struct rtw_adapter *padapter ) ;
void start_ap_mode23a(struct rtw_adapter *padapter ) ;
void stop_ap_mode23a(struct rtw_adapter *padapter ) ;
int rtw_wdev_alloc(struct rtw_adapter *padapter , struct device *dev ) ;
void rtw_wdev_free(struct wireless_dev *wdev ) ;
void rtw_wdev_unregister(struct wireless_dev *wdev ) ;
void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter ) ;
void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter , unsigned char *da ,
                                        unsigned short reason ) ;
static u32 const rtw_cipher_suites[4U] = { 1027073U, 1027077U, 1027074U, 1027076U};
static struct ieee80211_rate rtw_rates[12U] =
  { {0U, 10U, 1U, (unsigned short)0},
        {0U, 20U, 2U, (unsigned short)0},
        {0U, 55U, 4U, (unsigned short)0},
        {0U, 110U, 8U, (unsigned short)0},
        {0U, 60U, 16U, (unsigned short)0},
        {0U, 90U, 32U, (unsigned short)0},
        {0U, 120U, 64U, (unsigned short)0},
        {0U, 180U, 128U, (unsigned short)0},
        {0U, 240U, 256U, (unsigned short)0},
        {0U, 360U, 512U, (unsigned short)0},
        {0U, 480U, 1024U, (unsigned short)0},
        {0U, 540U, 2048U, (unsigned short)0}};
static struct ieee80211_channel rtw_2ghz_channels[14U] =
  { {0, 2412U, 1U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2417U, 2U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2422U, 3U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2427U, 4U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2432U, 5U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2437U, 6U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2442U, 7U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2447U, 8U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2452U, 9U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2457U, 10U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2462U, 11U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2467U, 12U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2472U, 13U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {0, 2484U, 14U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}};
static struct ieee80211_channel rtw_5ghz_a_channels[37U] =
  { {1, 5170U, 34U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5180U, 36U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5190U, 38U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5200U, 40U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5210U, 42U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5220U, 44U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5230U, 46U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5240U, 48U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5260U, 52U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5280U, 56U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5300U, 60U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5320U, 64U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5500U, 100U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5520U, 104U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5540U, 108U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5560U, 112U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5580U, 116U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5600U, 120U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5620U, 124U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5640U, 128U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5660U, 132U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5680U, 136U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5700U, 140U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5745U, 149U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5765U, 153U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5785U, 157U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5805U, 161U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5825U, 165U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5920U, 184U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5940U, 188U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5960U, 192U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 5980U, 196U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 6000U, 200U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 6020U, 204U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 6040U, 208U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 6060U, 212U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U},
        {1, 6080U, 216U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}};
static void rtw_2g_channels_init(struct ieee80211_channel *channels )
{
  size_t __len ;
  void *__ret ;
  {
  __len = 896UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)channels, (void const *)(& rtw_2ghz_channels), __len);
  } else {
    __ret = memcpy((void *)channels, (void const *)(& rtw_2ghz_channels),
                             __len);
  }
  return;
}
}
static void rtw_5g_channels_init(struct ieee80211_channel *channels )
{
  size_t __len ;
  void *__ret ;
  {
  __len = 2368UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)channels, (void const *)(& rtw_5ghz_a_channels), __len);
  } else {
    __ret = memcpy((void *)channels, (void const *)(& rtw_5ghz_a_channels),
                             __len);
  }
  return;
}
}
static void rtw_2g_rates_init(struct ieee80211_rate *rates )
{
  size_t __len ;
  void *__ret ;
  {
  __len = 144UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)rates, (void const *)(& rtw_rates), __len);
  } else {
    __ret = memcpy((void *)rates, (void const *)(& rtw_rates), __len);
  }
  return;
}
}
static void rtw_5g_rates_init(struct ieee80211_rate *rates )
{
  size_t __len ;
  void *__ret ;
  {
  __len = 96UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)rates, (void const *)(& rtw_rates) + 4U, __len);
  } else {
    __ret = memcpy((void *)rates, (void const *)(& rtw_rates) + 4U, __len);
  }
  return;
}
}
static struct ieee80211_supported_band *rtw_spt_band_alloc(enum ieee80211_band band )
{
  struct ieee80211_supported_band *spt_band ;
  int n_channels ;
  int n_bitrates ;
  void *tmp ;
  {
  spt_band = (struct ieee80211_supported_band *)0;
  if ((unsigned int )band == 0U) {
    n_channels = 14;
    n_bitrates = 12;
  } else
  if ((unsigned int )band == 1U) {
    n_channels = 37;
    n_bitrates = 8;
  } else {
    goto exit;
  }
  tmp = kzalloc(((unsigned long )n_channels * 64UL + (unsigned long )n_bitrates * 12UL) + 72UL,
                208U);
  spt_band = (struct ieee80211_supported_band *)tmp;
  if ((unsigned long )spt_band == (unsigned long )((struct ieee80211_supported_band *)0)) {
    goto exit;
  } else {
  }
  spt_band->channels = (struct ieee80211_channel *)spt_band + 72U;
  spt_band->bitrates = (struct ieee80211_rate *)spt_band->channels + (unsigned long )n_channels * 64UL;
  spt_band->band = band;
  spt_band->n_channels = n_channels;
  spt_band->n_bitrates = n_bitrates;
  if ((unsigned int )band == 0U) {
    rtw_2g_channels_init(spt_band->channels);
    rtw_2g_rates_init(spt_band->bitrates);
  } else
  if ((unsigned int )band == 1U) {
    rtw_5g_channels_init(spt_band->channels);
    rtw_5g_rates_init(spt_band->bitrates);
  } else {
  }
  exit: ;
  return (spt_band);
}
}
static struct ieee80211_txrx_stypes const rtw_cfg80211_default_mgmt_stypes[11U] =
  { {(unsigned short)0, (unsigned short)0},
        {65535U, 8192U},
        {65535U, 8208U},
        {65535U, 15381U},
        {65535U, 15381U},
        {(unsigned short)0, (unsigned short)0},
        {(unsigned short)0, (unsigned short)0},
        {(unsigned short)0, (unsigned short)0},
        {65535U, 8208U},
        {65535U, 15381U}};
static int rtw_cfg80211_inform_bss(struct rtw_adapter *padapter , struct wlan_network *pnetwork )
{
  int ret ;
  struct ieee80211_channel *notify_channel ;
  struct cfg80211_bss *bss ;
  u16 channel ;
  u32 freq ;
  u64 notify_timestamp ;
  u16 notify_capability ;
  u16 notify_interval ;
  u8 *notify_ie ;
  size_t notify_ielen ;
  s32 notify_signal ;
  u8 buf[1000U] ;
  u8 *pbuf ;
  size_t len ;
  struct ieee80211_hdr *pwlanhdr ;
  struct wireless_dev *wdev ;
  struct wiphy *wiphy ;
  struct mlme_priv *pmlmepriv ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  __le16 *tmp___2 ;
  __le16 *tmp___3 ;
  s32 tmp___4 ;
  s32 tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  u8 *tmp___8 ;
  size_t __len ;
  void *__ret ;
  long tmp___9 ;
  {
  ret = 0;
  wdev = padapter->rtw_wdev;
  wiphy = wdev->wiphy;
  pmlmepriv = & padapter->mlmepriv;
  if (pnetwork->network.IELength > 768U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s IE Length too long > %d byte\n", "rtw_cfg80211_inform_bss",
             768);
    } else {
    }
    goto exit;
  } else {
  }
  channel = (u16 )pnetwork->network.DSConfig;
  if ((unsigned int )channel <= 14U) {
    tmp = ieee80211_channel_to_frequency((int )channel, 0);
    freq = (u32 )tmp;
  } else {
    tmp___0 = ieee80211_channel_to_frequency((int )channel, 1);
    freq = (u32 )tmp___0;
  }
  notify_channel = ieee80211_get_channel(wiphy, (int )freq);
  tmp___1 = jiffies_to_msecs(jiffies);
  notify_timestamp = (u64 )(tmp___1 * 1000U);
  tmp___2 = rtw_get_beacon_interval23a_from_ie((u8 *)(& pnetwork->network.IEs));
  notify_interval = get_unaligned_le16((void const *)tmp___2);
  tmp___3 = rtw_get_capability23a_from_ie((u8 *)(& pnetwork->network.IEs));
  notify_capability = get_unaligned_le16((void const *)tmp___3);
  notify_ie = (u8 *)(& pnetwork->network.IEs) + 12UL;
  notify_ielen = (size_t )(pnetwork->network.IELength - 12U);
  tmp___6 = check_fwstate(pmlmepriv, 1);
  if ((int )tmp___6) {
    tmp___7 = is_same_network23a(& pmlmepriv->cur_network.network, & pnetwork->network);
    if (tmp___7 != 0) {
      tmp___4 = translate_percentage_to_dbm((u32 )padapter->recvpriv.signal_strength);
      notify_signal = tmp___4 * 100;
    } else {
      tmp___5 = translate_percentage_to_dbm((u32 )pnetwork->network.PhyInfo.SignalStrength);
      notify_signal = tmp___5 * 100;
    }
  } else {
    tmp___5 = translate_percentage_to_dbm((u32 )pnetwork->network.PhyInfo.SignalStrength);
    notify_signal = tmp___5 * 100;
  }
  pbuf = (u8 *)(& buf);
  pwlanhdr = (struct ieee80211_hdr *)pbuf;
  pwlanhdr->seq_ctrl = 0U;
  if ((unsigned int )pnetwork->network.reserved == 1U) {
    eth_broadcast_addr((u8 *)(& pwlanhdr->addr1));
    pwlanhdr->frame_control = 128U;
  } else {
    tmp___8 = myid(& padapter->eeprompriv);
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)tmp___8);
    pwlanhdr->frame_control = 80U;
  }
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)(& pnetwork->network.MacAddress));
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)(& pnetwork->network.MacAddress));
  pbuf = pbuf + 24UL;
  len = 24UL;
  __len = (size_t )pnetwork->network.IELength;
  __ret = memcpy((void *)pbuf, (void const *)(& pnetwork->network.IEs),
                           __len);
  len = (size_t )pnetwork->network.IELength + len;
  bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)(& buf),
                                  len, notify_signal, 32U);
  tmp___9 = ldv__builtin_expect((unsigned long )bss == (unsigned long )((struct cfg80211_bss *)0),
                             0L);
  if (tmp___9 != 0L) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: rtw_cfg80211_inform_bss error\n");
    } else {
    }
    return (-22);
  } else {
  }
  cfg80211_put_bss(wiphy, bss);
  exit: ;
  return (ret);
}
}
void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  struct wireless_dev *pwdev ;
  bool tmp ;
  struct wiphy *wiphy ;
  struct ieee80211_channel *notify_channel ;
  u32 freq ;
  u16 channel ;
  int tmp___0 ;
  int tmp___1 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network;
  pwdev = padapter->rtw_wdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_cfg80211_indicate_connect", padapter);
  } else {
  }
  if ((unsigned int )pwdev->iftype != 2U && (unsigned int )pwdev->iftype != 8U) {
    return;
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    return;
  } else {
  }
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
    wiphy = pwdev->wiphy;
    channel = (u16 )cur_network->network.DSConfig;
    if ((unsigned int )channel <= 14U) {
      tmp___0 = ieee80211_channel_to_frequency((int )channel, 0);
      freq = (u32 )tmp___0;
    } else {
      tmp___1 = ieee80211_channel_to_frequency((int )channel, 1);
      freq = (u32 )tmp___1;
    }
    notify_channel = ieee80211_get_channel(wiphy, (int )freq);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s call cfg80211_roamed\n", "rtw_cfg80211_indicate_connect");
    } else {
    }
    cfg80211_roamed(padapter->pnetdev, notify_channel, (u8 const *)(& cur_network->network.MacAddress),
                    (u8 const *)pmlmepriv->assoc_req + 26U, (unsigned long )pmlmepriv->assoc_req_len - 26UL,
                    (u8 const *)pmlmepriv->assoc_rsp + 30U, (unsigned long )pmlmepriv->assoc_rsp_len - 30UL,
                    32U);
  } else {
    cfg80211_connect_result(padapter->pnetdev, (u8 const *)(& cur_network->network.MacAddress),
                            (u8 const *)pmlmepriv->assoc_req + 26U, (unsigned long )pmlmepriv->assoc_req_len - 26UL,
                            (u8 const *)pmlmepriv->assoc_rsp + 30U, (unsigned long )pmlmepriv->assoc_rsp_len - 30UL,
                            0, 32U);
  }
  return;
}
}
void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct wireless_dev *pwdev ;
  bool tmp ;
  bool tmp___0 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pwdev = padapter->rtw_wdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_cfg80211_indicate_disconnect",
           padapter);
  } else {
  }
  if ((unsigned int )pwdev->iftype != 2U && (unsigned int )pwdev->iftype != 8U) {
    return;
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 16);
  if ((int )tmp) {
    return;
  } else {
  }
  if ((unsigned int )padapter->mlmepriv.not_indic_disco == 0U) {
    tmp___0 = check_fwstate(& padapter->mlmepriv, 128);
    if ((int )tmp___0) {
      cfg80211_connect_result(padapter->pnetdev, (u8 const *)0U, (u8 const *)0U,
                              0UL, (u8 const *)0U, 0UL, 1, 32U);
    } else {
      cfg80211_disconnected(padapter->pnetdev, 0, (u8 const *)0U, 0UL, 32U);
    }
  } else {
  }
  return;
}
}
static int set_pairwise_key(struct rtw_adapter *padapter , struct sta_info *psta )
{
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  tmp = kzalloc(128UL, 208U);
  ph2c = (struct cmd_obj *)tmp;
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(28UL, 208U);
  psetstakey_para = (struct set_stakey_parm *)tmp___0;
  if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
    kfree((void const *)ph2c);
    res = 0;
    goto exit;
  } else {
  }
  ph2c->cmdcode = 21U;
  ph2c->parmbuf = (u8 *)psetstakey_para;
  ph2c->cmdsz = 28U;
  ph2c->rsp = (u8 *)0U;
  ph2c->rspsz = 0U;
  psetstakey_para->algorithm = psta->dot118021XPrivacy;
  ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const *)(& psta->hwaddr));
  __len = 16UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& psetstakey_para->key), (void const *)(& psta->dot118021x_UncstKey),
                     __len);
  } else {
    __ret = memcpy((void *)(& psetstakey_para->key), (void const *)(& psta->dot118021x_UncstKey),
                             __len);
  }
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
  return (res);
}
}
static int set_group_key(struct rtw_adapter *padapter , u8 *key , u32 alg , u8 keyid )
{
  u8 keylen ;
  struct cmd_obj *pcmd ;
  struct setkey_parm *psetkeyparm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  {
  pcmdpriv = & padapter->cmdpriv;
  res = 1;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "set_group_key");
  } else {
  }
  if ((unsigned int )keyid > 3U) {
    res = 0;
    goto exit;
  } else {
  }
  tmp = kzalloc(128UL, 208U);
  pcmd = (struct cmd_obj *)tmp;
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
    res = 0;
    goto exit;
  } else {
  }
  tmp___0 = kzalloc(24UL, 208U);
  psetkeyparm = (struct setkey_parm *)tmp___0;
  if ((unsigned long )psetkeyparm == (unsigned long )((struct setkey_parm *)0)) {
    kfree((void const *)pcmd);
    res = 0;
    goto exit;
  } else {
  }
  psetkeyparm->keyid = keyid;
  if (alg == 1027073U || alg == 1027077U) {
    padapter->mlmepriv.key_mask = (int )padapter->mlmepriv.key_mask | (int )((u8 )(1UL << (int )psetkeyparm->keyid));
  } else {
  }
  psetkeyparm->algorithm = alg;
  psetkeyparm->set_tx = 1U;
  switch (alg) {
  case 1027073U:
  keylen = 5U;
  goto ldv_51540;
  case 1027077U:
  keylen = 13U;
  goto ldv_51540;
  case 1027074U: ;
  case 1027076U: ;
  default:
  keylen = 16U;
  }
  ldv_51540:
  __len = (size_t )keylen;
  __ret = memcpy((void *)(& psetkeyparm->key), (void const *)key, __len);
  pcmd->cmdcode = 20U;
  pcmd->parmbuf = (u8 *)psetkeyparm;
  pcmd->cmdsz = 24U;
  pcmd->rsp = (u8 *)0U;
  pcmd->rspsz = 0U;
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
  return (res);
}
}
static int set_wep_key(struct rtw_adapter *padapter , u8 *key , u16 keylen , u8 keyid )
{
  u32 alg ;
  int tmp ;
  {
  switch ((int )keylen) {
  case 5:
  alg = 1027073U;
  goto ldv_51556;
  case 13:
  alg = 1027077U;
  goto ldv_51556;
  default:
  alg = 0U;
  }
  ldv_51556:
  tmp = set_group_key(padapter, key, alg, (int )keyid);
  return (tmp);
}
}
static int rtw_cfg80211_ap_set_encryption(struct net_device *dev , struct ieee_param *param ,
                                          u32 param_len )
{
  int ret ;
  u16 wep_key_len ;
  u8 wep_key_idx ;
  struct sta_info *psta ;
  struct sta_info *pbcmc_sta ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct sta_priv *pstapriv ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  int tmp___2 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  size_t __len___5 ;
  void *__ret___5 ;
  size_t __len___6 ;
  void *__ret___6 ;
  size_t __len___7 ;
  void *__ret___7 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __len___8 ;
  void *__ret___8 ;
  size_t __len___9 ;
  void *__ret___9 ;
  size_t __len___10 ;
  void *__ret___10 ;
  size_t __len___11 ;
  void *__ret___11 ;
  size_t __len___12 ;
  void *__ret___12 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  {
  ret = 0;
  psta = (struct sta_info *)0;
  pbcmc_sta = (struct sta_info *)0;
  tmp = netdev_priv((struct net_device const *)dev);
  padapter = (struct rtw_adapter *)tmp;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pstapriv = & padapter->stapriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_ap_set_encryption");
  } else {
  }
  param->u.crypt.err = 0U;
  param->u.crypt.alg[15] = 0U;
  if ((unsigned long )param_len != (unsigned long )param->u.crypt.key_len + 64UL) {
    ret = -22;
    goto exit;
  } else {
  }
  tmp___0 = is_broadcast_ether_addr((u8 const *)(& param->sta_addr));
  if ((int )tmp___0) {
    if ((unsigned int )param->u.crypt.idx > 3U) {
      ret = -22;
      goto exit;
    } else {
    }
  } else {
    psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& param->sta_addr));
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: rtw_set_encryption(), sta has already been removed or never been added\n");
      } else {
      }
      goto exit;
    } else {
    }
  }
  tmp___1 = strcmp((char const *)(& param->u.crypt.alg), "none");
  if (tmp___1 == 0 && (unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: clear default encryption keys, keyid =%d\n", (int )param->u.crypt.idx);
    } else {
    }
    goto exit;
  } else {
  }
  tmp___2 = strcmp((char const *)(& param->u.crypt.alg), "WEP");
  if (tmp___2 == 0 && (unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: r871x_set_encryption, crypt.alg = WEP\n");
    } else {
    }
    wep_key_idx = param->u.crypt.idx;
    wep_key_len = param->u.crypt.key_len;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: r871x_set_encryption, wep_key_idx =%d, len =%d\n", (int )wep_key_idx,
             (int )wep_key_len);
    } else {
    }
    if ((unsigned int )wep_key_idx > 3U || (unsigned int )wep_key_len == 0U) {
      ret = -22;
      goto exit;
    } else {
    }
    if ((unsigned int )wep_key_len != 0U) {
      wep_key_len = (unsigned int )wep_key_len <= 5U ? 5U : 13U;
    } else {
    }
    if ((unsigned int )psecuritypriv->bWepDefaultKeyIdxSet == 0U) {
      psecuritypriv->ndisencryptstatus = 0U;
      psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
      psecuritypriv->dot118021XGrpPrivacy = 1027073U;
      if ((unsigned int )wep_key_len == 13U) {
        psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
        psecuritypriv->dot118021XGrpPrivacy = 1027077U;
      } else {
      }
      psecuritypriv->dot11PrivacyKeyIndex = (u32 )wep_key_idx;
    } else {
    }
    __len = (size_t )wep_key_len;
    __ret = memcpy((void *)(& psecuritypriv->wep_key[(int )wep_key_idx].key),
                             (void const *)(& param->u.crypt.key), __len);
    psecuritypriv->wep_key[(int )wep_key_idx].keylen = wep_key_len;
    set_wep_key(padapter, (u8 *)(& param->u.crypt.key), (int )wep_key_len, (int )wep_key_idx);
    goto exit;
  } else {
  }
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    tmp___6 = check_fwstate(pmlmepriv, 16);
    if ((int )tmp___6) {
      if ((unsigned int )param->u.crypt.set_tx == 0U) {
        tmp___5 = strcmp((char const *)(& param->u.crypt.alg), "WEP");
        if (tmp___5 == 0) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: %s, set group_key, WEP\n", "rtw_cfg80211_ap_set_encryption");
          } else {
          }
          __len___0 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
          __ret___0 = memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                       (void const *)(& param->u.crypt.key), __len___0);
          psecuritypriv->dot118021XGrpPrivacy = 1027073U;
          if ((unsigned int )param->u.crypt.key_len == 13U) {
            psecuritypriv->dot118021XGrpPrivacy = 1027077U;
          } else {
          }
        } else {
          tmp___4 = strcmp((char const *)(& param->u.crypt.alg), "TKIP");
          if (tmp___4 == 0) {
            if (GlobalDebugLevel23A > 3U) {
              printk("\016RTL8723AU: %s, set group_key, TKIP\n", "rtw_cfg80211_ap_set_encryption");
            } else {
            }
            psecuritypriv->dot118021XGrpPrivacy = 1027074U;
            __len___1 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
            __ret___1 = memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                         (void const *)(& param->u.crypt.key), __len___1);
            __len___2 = 8UL;
            if (__len___2 > 63UL) {
              __ret___2 = memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                   (void const *)(& param->u.crypt.key) + 16U, __len___2);
            } else {
              __ret___2 = memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                           (void const *)(& param->u.crypt.key) + 16U,
                                           __len___2);
            }
            __len___3 = 8UL;
            if (__len___3 > 63UL) {
              __ret___3 = memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                   (void const *)(& param->u.crypt.key) + 24U, __len___3);
            } else {
              __ret___3 = memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                           (void const *)(& param->u.crypt.key) + 24U,
                                           __len___3);
            }
            psecuritypriv->busetkipkey = 1U;
          } else {
            tmp___3 = strcmp((char const *)(& param->u.crypt.alg), "CCMP");
            if (tmp___3 == 0) {
              if (GlobalDebugLevel23A > 3U) {
                printk("\016RTL8723AU: %s, set group_key, CCMP\n", "rtw_cfg80211_ap_set_encryption");
              } else {
              }
              psecuritypriv->dot118021XGrpPrivacy = 1027076U;
              __len___4 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
              __ret___4 = memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                           (void const *)(& param->u.crypt.key),
                                           __len___4);
            } else {
              if (GlobalDebugLevel23A > 3U) {
                printk("\016RTL8723AU: %s, set group_key, none\n", "rtw_cfg80211_ap_set_encryption");
              } else {
              }
              psecuritypriv->dot118021XGrpPrivacy = 0U;
            }
          }
        }
        psecuritypriv->dot118021XGrpKeyid = (u32 )param->u.crypt.idx;
        psecuritypriv->binstallGrpkey = 1U;
        psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;
        set_group_key(padapter, (u8 *)(& param->u.crypt.key), psecuritypriv->dot118021XGrpPrivacy,
                      (int )param->u.crypt.idx);
        pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
        if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
          pbcmc_sta->ieee8021x_blocked = 0U;
          pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;
        } else {
        }
      } else {
      }
      goto exit;
    } else {
    }
  } else {
  }
  if (psecuritypriv->dot11AuthAlgrthm == 2U && (unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    tmp___13 = check_fwstate(pmlmepriv, 16);
    if ((int )tmp___13) {
      if ((unsigned int )param->u.crypt.set_tx == 1U) {
        __len___5 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
        __ret___5 = memcpy((void *)(& psta->dot118021x_UncstKey.skey), (void const *)(& param->u.crypt.key),
                                     __len___5);
        tmp___9 = strcmp((char const *)(& param->u.crypt.alg), "WEP");
        if (tmp___9 == 0) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: %s, set pairwise key, WEP\n", "rtw_cfg80211_ap_set_encryption");
          } else {
          }
          psta->dot118021XPrivacy = 1027073U;
          if ((unsigned int )param->u.crypt.key_len == 13U) {
            psta->dot118021XPrivacy = 1027077U;
          } else {
          }
        } else {
          tmp___8 = strcmp((char const *)(& param->u.crypt.alg), "TKIP");
          if (tmp___8 == 0) {
            if (GlobalDebugLevel23A > 3U) {
              printk("\016RTL8723AU: %s, set pairwise key, TKIP\n", "rtw_cfg80211_ap_set_encryption");
            } else {
            }
            psta->dot118021XPrivacy = 1027074U;
            __len___6 = 8UL;
            if (__len___6 > 63UL) {
              __ret___6 = memcpy((void *)(& psta->dot11tkiptxmickey.skey), (void const *)(& param->u.crypt.key) + 16U,
                                   __len___6);
            } else {
              __ret___6 = memcpy((void *)(& psta->dot11tkiptxmickey.skey),
                                           (void const *)(& param->u.crypt.key) + 16U,
                                           __len___6);
            }
            __len___7 = 8UL;
            if (__len___7 > 63UL) {
              __ret___7 = memcpy((void *)(& psta->dot11tkiprxmickey.skey), (void const *)(& param->u.crypt.key) + 24U,
                                   __len___7);
            } else {
              __ret___7 = memcpy((void *)(& psta->dot11tkiprxmickey.skey),
                                           (void const *)(& param->u.crypt.key) + 24U,
                                           __len___7);
            }
            psecuritypriv->busetkipkey = 1U;
          } else {
            tmp___7 = strcmp((char const *)(& param->u.crypt.alg), "CCMP");
            if (tmp___7 == 0) {
              if (GlobalDebugLevel23A > 3U) {
                printk("\016RTL8723AU: %s, set pairwise key, CCMP\n", "rtw_cfg80211_ap_set_encryption");
              } else {
              }
              psta->dot118021XPrivacy = 1027076U;
            } else {
              if (GlobalDebugLevel23A > 3U) {
                printk("\016RTL8723AU: %s, set pairwise key, none\n", "rtw_cfg80211_ap_set_encryption");
              } else {
              }
              psta->dot118021XPrivacy = 0U;
            }
          }
        }
        set_pairwise_key(padapter, psta);
        psta->ieee8021x_blocked = 0U;
        psta->bpairwise_key_installed = 1U;
      } else {
        tmp___12 = strcmp((char const *)(& param->u.crypt.alg), "WEP");
        if (tmp___12 == 0) {
          __len___8 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
          __ret___8 = memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                       (void const *)(& param->u.crypt.key), __len___8);
          psecuritypriv->dot118021XGrpPrivacy = 1027073U;
          if ((unsigned int )param->u.crypt.key_len == 13U) {
            psecuritypriv->dot118021XGrpPrivacy = 1027077U;
          } else {
          }
        } else {
          tmp___11 = strcmp((char const *)(& param->u.crypt.alg), "TKIP");
          if (tmp___11 == 0) {
            psecuritypriv->dot118021XGrpPrivacy = 1027074U;
            __len___9 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
            __ret___9 = memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                         (void const *)(& param->u.crypt.key), __len___9);
            __len___10 = 8UL;
            if (__len___10 > 63UL) {
              __ret___10 = memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                    (void const *)(& param->u.crypt.key) + 16U,
                                    __len___10);
            } else {
              __ret___10 = memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                            (void const *)(& param->u.crypt.key) + 16U,
                                            __len___10);
            }
            __len___11 = 8UL;
            if (__len___11 > 63UL) {
              __ret___11 = memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                    (void const *)(& param->u.crypt.key) + 24U,
                                    __len___11);
            } else {
              __ret___11 = memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                            (void const *)(& param->u.crypt.key) + 24U,
                                            __len___11);
            }
            psecuritypriv->busetkipkey = 1U;
          } else {
            tmp___10 = strcmp((char const *)(& param->u.crypt.alg), "CCMP");
            if (tmp___10 == 0) {
              psecuritypriv->dot118021XGrpPrivacy = 1027076U;
              __len___12 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
              __ret___12 = memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                            (void const *)(& param->u.crypt.key),
                                            __len___12);
            } else {
              psecuritypriv->dot118021XGrpPrivacy = 0U;
            }
          }
        }
        psecuritypriv->dot118021XGrpKeyid = (u32 )param->u.crypt.idx;
        psecuritypriv->binstallGrpkey = 1U;
        psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;
        set_group_key(padapter, (u8 *)(& param->u.crypt.key), psecuritypriv->dot118021XGrpPrivacy,
                      (int )param->u.crypt.idx);
        pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
        if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
          pbcmc_sta->ieee8021x_blocked = 0U;
          pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;
        } else {
        }
      }
    } else {
    }
  } else {
  }
  exit: ;
  return (ret);
}
}
static int rtw_cfg80211_set_encryption(struct net_device *dev , struct ieee_param *param ,
                                       u32 param_len )
{
  int ret ;
  u32 wep_key_idx ;
  u16 wep_key_len ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_info *pbcmc_sta ;
  struct sta_priv *pstapriv ;
  u8 *tmp___2 ;
  int tmp___3 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  int tmp___4 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  size_t __len___5 ;
  void *__ret___5 ;
  int tmp___5 ;
  bool tmp___6 ;
  {
  ret = 0;
  tmp = netdev_priv((struct net_device const *)dev);
  padapter = (struct rtw_adapter *)tmp;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_set_encryption");
  } else {
  }
  param->u.crypt.err = 0U;
  param->u.crypt.alg[15] = 0U;
  if (((unsigned int )((long )(& param->u.crypt.key)) - (unsigned int )((long )param)) + (unsigned int )param->u.crypt.key_len > param_len) {
    ret = -22;
    goto exit;
  } else {
  }
  tmp___0 = is_broadcast_ether_addr((u8 const *)(& param->sta_addr));
  if ((int )tmp___0) {
    if ((unsigned int )param->u.crypt.idx > 3U) {
      ret = -22;
      goto exit;
    } else {
    }
  } else {
    ret = -22;
    goto exit;
  }
  tmp___1 = strcmp((char const *)(& param->u.crypt.alg), "WEP");
  if (tmp___1 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 33554432U, 4);
      printk("\016wpa_set_encryption, crypt.alg = WEP\n");
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: wpa_set_encryption, crypt.alg = WEP\n");
    } else {
    }
    wep_key_idx = (u32 )param->u.crypt.idx;
    wep_key_len = param->u.crypt.key_len;
    if (wep_key_idx > 4U || (unsigned int )wep_key_len == 0U) {
      ret = -22;
      goto exit;
    } else {
    }
    if ((unsigned int )psecuritypriv->bWepDefaultKeyIdxSet == 0U) {
      wep_key_len = (unsigned int )wep_key_len <= 5U ? 5U : 13U;
      psecuritypriv->ndisencryptstatus = 0U;
      psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
      psecuritypriv->dot118021XGrpPrivacy = 1027073U;
      if ((unsigned int )wep_key_len == 13U) {
        psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
        psecuritypriv->dot118021XGrpPrivacy = 1027077U;
      } else {
      }
      psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
    } else {
    }
    __len = (size_t )wep_key_len;
    __ret = memcpy((void *)(& psecuritypriv->wep_key[wep_key_idx].key),
                             (void const *)(& param->u.crypt.key), __len);
    psecuritypriv->wep_key[wep_key_idx].keylen = wep_key_len;
    rtw_set_key23a(padapter, psecuritypriv, (int )wep_key_idx, 0);
    goto exit;
  } else {
  }
  if (padapter->securitypriv.dot11AuthAlgrthm == 2U) {
    pstapriv = & padapter->stapriv;
    tmp___6 = check_fwstate(pmlmepriv, 65544);
    if ((int )tmp___6) {
      tmp___2 = get_bssid(pmlmepriv);
      psta = rtw_get_stainfo23a(pstapriv, (u8 const *)tmp___2);
      if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, : Obtain Sta_info fail\n", "rtw_cfg80211_set_encryption");
        } else {
        }
      } else {
        tmp___3 = strcmp((char const *)(& param->u.crypt.alg), "none");
        if (tmp___3 != 0) {
          psta->ieee8021x_blocked = 0U;
        } else {
        }
        if (padapter->securitypriv.ndisencryptstatus == 4U || padapter->securitypriv.ndisencryptstatus == 6U) {
          psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
        } else {
        }
        if ((unsigned int )param->u.crypt.set_tx == 1U) {
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU: %s, : param->u.crypt.set_tx == 1\n", "rtw_cfg80211_set_encryption");
          } else {
          }
          __len___0 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
          __ret___0 = memcpy((void *)(& psta->dot118021x_UncstKey.skey),
                                       (void const *)(& param->u.crypt.key), __len___0);
          tmp___4 = strcmp((char const *)(& param->u.crypt.alg), "TKIP");
          if (tmp___4 == 0) {
            __len___1 = 8UL;
            if (__len___1 > 63UL) {
              __ret___1 = memcpy((void *)(& psta->dot11tkiptxmickey.skey), (void const *)(& param->u.crypt.key) + 16U,
                                   __len___1);
            } else {
              __ret___1 = memcpy((void *)(& psta->dot11tkiptxmickey.skey),
                                           (void const *)(& param->u.crypt.key) + 16U,
                                           __len___1);
            }
            __len___2 = 8UL;
            if (__len___2 > 63UL) {
              __ret___2 = memcpy((void *)(& psta->dot11tkiprxmickey.skey), (void const *)(& param->u.crypt.key) + 24U,
                                   __len___2);
            } else {
              __ret___2 = memcpy((void *)(& psta->dot11tkiprxmickey.skey),
                                           (void const *)(& param->u.crypt.key) + 24U,
                                           __len___2);
            }
            padapter->securitypriv.busetkipkey = 0U;
          } else {
          }
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU:  ~~~~set sta key:unicastkey\n");
          } else {
          }
          rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
        } else {
          __len___3 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
          __ret___3 = memcpy((void *)(& padapter->securitypriv.dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                       (void const *)(& param->u.crypt.key), __len___3);
          __len___4 = 8UL;
          if (__len___4 > 63UL) {
            __ret___4 = memcpy((void *)(& padapter->securitypriv.dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                 (void const *)(& param->u.crypt.key) + 16U, __len___4);
          } else {
            __ret___4 = memcpy((void *)(& padapter->securitypriv.dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                         (void const *)(& param->u.crypt.key) + 16U,
                                         __len___4);
          }
          __len___5 = 8UL;
          if (__len___5 > 63UL) {
            __ret___5 = memcpy((void *)(& padapter->securitypriv.dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                 (void const *)(& param->u.crypt.key) + 24U, __len___5);
          } else {
            __ret___5 = memcpy((void *)(& padapter->securitypriv.dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                         (void const *)(& param->u.crypt.key) + 24U,
                                         __len___5);
          }
          padapter->securitypriv.binstallGrpkey = 1U;
          if (GlobalDebugLevel23A > 3U) {
            printk("\016RTL8723AU:  ~~~~set sta key:groupkey\n");
          } else {
          }
          padapter->securitypriv.dot118021XGrpKeyid = (u32 )param->u.crypt.idx;
          rtw_set_key23a(padapter, & padapter->securitypriv, (int )param->u.crypt.idx,
                         1);
        }
      }
      pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
      if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
        tmp___5 = strcmp((char const *)(& param->u.crypt.alg), "none");
        if (tmp___5 != 0) {
          pbcmc_sta->ieee8021x_blocked = 0U;
        } else {
        }
        if (padapter->securitypriv.ndisencryptstatus == 4U || padapter->securitypriv.ndisencryptstatus == 6U) {
          pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
        } else {
        }
      } else {
      }
    } else {
      check_fwstate(pmlmepriv, 32);
    }
  } else {
  }
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ret =%d\n", "rtw_cfg80211_set_encryption", ret);
  } else {
  }
  return (ret);
}
}
static int cfg80211_rtw_add_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const *mac_addr , struct key_params *params )
{
  char *alg_name ;
  u32 param_len ;
  struct ieee_param *param ;
  int ret ;
  struct wireless_dev *rtw_wdev ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  void *tmp___0 ;
  struct mlme_priv *pmlmepriv ;
  void *tmp___1 ;
  bool tmp___2 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp___3 ;
  bool tmp___4 ;
  {
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  rtw_wdev = ((struct rtw_wdev_priv *)tmp)->rtw_wdev;
  tmp___0 = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp___0)->padapter;
  pmlmepriv = & padapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): adding key for %pM\n", "cfg80211_rtw_add_key",
           (char *)(& ndev->name), mac_addr);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: cipher = 0x%x\n", params->cipher);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: key_len = 0x%x\n", params->key_len);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: seq_len = 0x%x\n", params->seq_len);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: key_index =%d\n", (int )key_index);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: pairwise =%d\n", (int )pairwise);
  } else {
  }
  param_len = (u32 )params->key_len + 64U;
  tmp___1 = kzalloc((size_t )param_len, 208U);
  param = (struct ieee_param *)tmp___1;
  if ((unsigned long )param == (unsigned long )((struct ieee_param *)0)) {
    return (-12);
  } else {
  }
  param->cmd = 3U;
  eth_broadcast_addr((u8 *)(& param->sta_addr));
  switch (params->cipher) {
  case 1U:
  alg_name = (char *)"none";
  goto ldv_51671;
  case 1027073U: ;
  case 1027077U:
  alg_name = (char *)"WEP";
  goto ldv_51671;
  case 1027074U:
  alg_name = (char *)"TKIP";
  goto ldv_51671;
  case 1027076U:
  alg_name = (char *)"CCMP";
  goto ldv_51671;
  default:
  ret = -524;
  goto addkey_end;
  }
  ldv_51671:
  strncpy((char *)(& param->u.crypt.alg), (char const *)alg_name, 16UL);
  if ((unsigned long )mac_addr == (unsigned long )((u8 const *)0U)) {
    param->u.crypt.set_tx = 0U;
  } else {
    tmp___2 = is_broadcast_ether_addr(mac_addr);
    if ((int )tmp___2) {
      param->u.crypt.set_tx = 0U;
    } else {
      param->u.crypt.set_tx = 1U;
    }
  }
  param->u.crypt.idx = key_index;
  if (params->seq_len != 0 && (unsigned long )params->seq != (unsigned long )((u8 const *)0U)) {
    __len = (size_t )params->seq_len;
    __ret = memcpy((void *)(& param->u.crypt.seq), (void const *)params->seq,
                             __len);
  } else {
  }
  if (params->key_len != 0 && (unsigned long )params->key != (unsigned long )((u8 const *)0U)) {
    param->u.crypt.key_len = (u16 )params->key_len;
    __len___0 = (size_t )params->key_len;
    __ret___0 = memcpy((void *)(& param->u.crypt.key), (void const *)params->key,
                                 __len___0);
  } else {
  }
  tmp___4 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___4) {
    ret = rtw_cfg80211_set_encryption(ndev, param, param_len);
  } else {
    tmp___3 = check_fwstate(pmlmepriv, 16);
    if ((int )tmp___3) {
      if ((unsigned long )mac_addr != (unsigned long )((u8 const *)0U)) {
        ether_addr_copy((u8 *)(& param->sta_addr), mac_addr);
      } else {
      }
      ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
    } else
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: error! fw_state = 0x%x, iftype =%d\n", pmlmepriv->fw_state,
             (unsigned int )rtw_wdev->iftype);
    } else {
    }
  }
  addkey_end:
  kfree((void const *)param);
  return (ret);
}
}
static int cfg80211_rtw_get_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const *mac_addr , void *cookie ,
                                void (*callback)(void * , struct key_params * ) )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_get_key", (char *)(& ndev->name));
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_del_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const *mac_addr )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  {
  tmp = netdev_priv((struct net_device const *)ndev);
  padapter = (struct rtw_adapter *)tmp;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): key_index =%d\n", "cfg80211_rtw_del_key", (char *)(& ndev->name),
           (int )key_index);
  } else {
  }
  if ((u32 )key_index == psecuritypriv->dot11PrivacyKeyIndex) {
    psecuritypriv->bWepDefaultKeyIdxSet = 0U;
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_set_default_key(struct wiphy *wiphy , struct net_device *ndev ,
                                        u8 key_index , bool unicast , bool multicast )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  {
  tmp = netdev_priv((struct net_device const *)ndev);
  padapter = (struct rtw_adapter *)tmp;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): key_index =%d, unicast =%d, multicast =%d.\n",
           "cfg80211_rtw_set_default_key", (char *)(& ndev->name), (int )key_index,
           (int )unicast, (int )multicast);
  } else {
  }
  if ((unsigned int )key_index <= 3U && (psecuritypriv->dot11PrivacyAlgrthm == 1027073U || psecuritypriv->dot11PrivacyAlgrthm == 1027077U)) {
    psecuritypriv->ndisencryptstatus = 0U;
    psecuritypriv->dot11PrivacyKeyIndex = (u32 )key_index;
    psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
    psecuritypriv->dot118021XGrpPrivacy = 1027073U;
    if ((unsigned int )psecuritypriv->wep_key[(int )key_index].keylen == 13U) {
      psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
      psecuritypriv->dot118021XGrpPrivacy = 1027077U;
    } else {
    }
    psecuritypriv->bWepDefaultKeyIdxSet = 1U;
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_get_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const *mac , struct station_info *sinfo )
{
  int ret ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct wlan_network *cur_network ;
  bool tmp___0 ;
  int tmp___1 ;
  s32 tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  {
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  pmlmepriv = & padapter->mlmepriv;
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  sinfo->filled = 0U;
  if ((unsigned long )mac == (unsigned long )((u8 const *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): mac ==%p\n", "cfg80211_rtw_get_station", (char *)(& ndev->name),
             mac);
    } else {
    }
    ret = -2;
    goto exit;
  } else {
  }
  psta = rtw_get_stainfo23a(pstapriv, mac);
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, sta_info is null\n", "cfg80211_rtw_get_station");
    } else {
    }
    ret = -2;
    goto exit;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): mac =%02x:%02x:%02x:%02x:%02x:%02x\n", "cfg80211_rtw_get_station",
           (char *)(& ndev->name), (int )*((u8 *)mac), (int )*((u8 *)mac + 1UL), (int )*((u8 *)mac + 2UL),
           (int )*((u8 *)mac + 3UL), (int )*((u8 *)mac + 4UL), (int )*((u8 *)mac + 5UL));
  } else {
  }
  tmp___3 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___3) {
    tmp___4 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___4) {
      cur_network = & pmlmepriv->cur_network;
      tmp___0 = ether_addr_equal(mac, (u8 const *)(& cur_network->network.MacAddress));
      if (tmp___0) {
        tmp___1 = 0;
      } else {
        tmp___1 = 1;
      }
      if (tmp___1) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s, mismatch bssid =%02x:%02x:%02x:%02x:%02x:%02x\n",
                 "cfg80211_rtw_get_station", (int )*((u8 *)(& cur_network->network.MacAddress)),
                 (int )*((u8 *)(& cur_network->network.MacAddress) + 1UL), (int )*((u8 *)(& cur_network->network.MacAddress) + 2UL),
                 (int )*((u8 *)(& cur_network->network.MacAddress) + 3UL), (int )*((u8 *)(& cur_network->network.MacAddress) + 4UL),
                 (int )*((u8 *)(& cur_network->network.MacAddress) + 5UL));
        } else {
        }
        ret = -2;
        goto exit;
      } else {
      }
      sinfo->filled = sinfo->filled | 64U;
      tmp___2 = translate_percentage_to_dbm((u32 )padapter->recvpriv.signal_strength);
      sinfo->signal = (s8 )tmp___2;
      sinfo->filled = sinfo->filled | 128U;
      sinfo->txrate.legacy = rtw_get_cur_max_rate23a(padapter);
      sinfo->filled = sinfo->filled | 256U;
      sinfo->rx_packets = (u32 )psta->sta_stats.rx_data_pkts;
      sinfo->filled = sinfo->filled | 512U;
      sinfo->tx_packets = (u32 )psta->sta_stats.tx_pkts;
    } else {
    }
  } else {
  }
  tmp___5 = check_fwstate(pmlmepriv, 32);
  if ((int )tmp___5) {
    goto _L;
  } else {
    tmp___6 = check_fwstate(pmlmepriv, 64);
    if ((int )tmp___6) {
      goto _L;
    } else {
      tmp___7 = check_fwstate(pmlmepriv, 16);
      if ((int )tmp___7) {
        _L:
        tmp___8 = check_fwstate(pmlmepriv, 1);
        if ((int )tmp___8) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
    }
  }
  exit: ;
  return (ret);
}
}
int cfg80211_infrastructure_mode(struct rtw_adapter *padapter , enum nl80211_iftype ifmode )
{
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  enum nl80211_iftype old_mode ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  cur_network = & pmlmepriv->cur_network;
  old_mode = cur_network->network.ifmode;
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 6);
    tmp = get_fwstate(pmlmepriv);
    printk("\016+%s: old =%d new =%d fw_state = 0x%08x\n", "cfg80211_infrastructure_mode",
           (unsigned int )old_mode, (unsigned int )ifmode, tmp);
  } else {
  }
  if ((unsigned int )old_mode != (unsigned int )ifmode) {
    spin_lock_bh(& pmlmepriv->lock);
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
      printk("\016 change mode!");
    } else {
    }
    if ((unsigned int )old_mode == 3U || (unsigned int )old_mode == 9U) {
      cur_network->join_res = -1;
      stop_ap_mode23a(padapter);
    } else {
    }
    tmp___0 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___0 || (unsigned int )old_mode == 1U) {
      rtw_disassoc_cmd23a(padapter, 0U, 1);
    } else {
    }
    tmp___1 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___1) {
      rtw_free_assoc_resources23a(padapter, 1);
    } else {
      tmp___2 = check_fwstate(pmlmepriv, 64);
      if ((int )tmp___2) {
        rtw_free_assoc_resources23a(padapter, 1);
      } else {
      }
    }
    if (((unsigned int )old_mode == 2U || (unsigned int )old_mode == 8U) || (unsigned int )old_mode == 1U) {
      tmp___3 = check_fwstate(pmlmepriv, 1);
      if ((int )tmp___3) {
        rtw_indicate_disconnect23a(padapter);
      } else {
      }
    } else {
    }
    cur_network->network.ifmode = ifmode;
    _clr_fwstate_(pmlmepriv, -1);
    switch ((unsigned int )ifmode) {
    case 1U:
    set_fwstate(pmlmepriv, 32);
    goto ldv_51739;
    case 8U: ;
    case 2U:
    set_fwstate(pmlmepriv, 8);
    goto ldv_51739;
    case 9U: ;
    case 3U:
    set_fwstate(pmlmepriv, 16);
    start_ap_mode23a(padapter);
    goto ldv_51739;
    default: ;
    goto ldv_51739;
    }
    ldv_51739:
    spin_unlock_bh(& pmlmepriv->lock);
  } else {
  }
  return (1);
}
}
static int cfg80211_rtw_change_iface(struct wiphy *wiphy , struct net_device *ndev ,
                                     enum nl80211_iftype type , u32 *flags , struct vif_params *params )
{
  enum nl80211_iftype old_type ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_ext_priv *pmlmeext ;
  struct wireless_dev *rtw_wdev ;
  void *tmp___0 ;
  int ret ;
  int tmp___1 ;
  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  pmlmeext = & padapter->mlmeextpriv;
  tmp___0 = wiphy_priv___1(wiphy);
  rtw_wdev = ((struct rtw_wdev_priv *)tmp___0)->rtw_wdev;
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): call netdev_open23a\n", "cfg80211_rtw_change_iface",
           (char *)(& ndev->name));
  } else {
  }
  old_type = rtw_wdev->iftype;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): old_iftype =%d, new_iftype =%d\n", "cfg80211_rtw_change_iface",
           (char *)(& ndev->name), (unsigned int )old_type, (unsigned int )type);
  } else {
  }
  if ((unsigned int )old_type != (unsigned int )type) {
    pmlmeext->action_public_rxseq = 65535U;
    pmlmeext->action_public_dialog_token = 255U;
  } else {
  }
  switch ((unsigned int )type) {
  case 1U: ;
  case 8U: ;
  case 2U: ;
  case 9U: ;
  case 3U: ;
  case 0U: ;
  goto ldv_51764;
  default: ;
  return (-95);
  }
  ldv_51764:
  rtw_wdev->iftype = type;
  tmp___1 = cfg80211_infrastructure_mode(padapter, type);
  if (tmp___1 != 1) {
    rtw_wdev->iftype = old_type;
    ret = -1;
    goto exit;
  } else {
  }
  rtw_setopmode_cmd23a(padapter, type);
  exit: ;
  return (ret);
}
}
void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv , bool aborted )
{
  {
  spin_lock_bh(& pwdev_priv->scan_req_lock);
  if ((unsigned long )pwdev_priv->scan_request != (unsigned long )((struct cfg80211_scan_request *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s with scan req\n", "rtw_cfg80211_indicate_scan_done");
    } else {
    }
    if ((unsigned long )(pwdev_priv->scan_request)->wiphy != (unsigned long )(pwdev_priv->rtw_wdev)->wiphy) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: error wiphy compare\n");
      } else {
      }
    } else {
      cfg80211_scan_done(pwdev_priv->scan_request, (int )aborted);
    }
    pwdev_priv->scan_request = (struct cfg80211_scan_request *)0;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s without scan req\n", "rtw_cfg80211_indicate_scan_done");
  } else {
  }
  spin_unlock_bh(& pwdev_priv->scan_req_lock);
  return;
}
}
void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter )
{
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *queue ;
  struct wlan_network *pnetwork ;
  struct list_head const *__mptr ;
  int tmp ;
  void *tmp___0 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  queue = & pmlmepriv->scanned_queue;
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  phead = get_list_head(queue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_51784;
  ldv_51783:
  __mptr = (struct list_head const *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  tmp = rtw_ch_set_search_ch23a((struct rt_channel_info *)(& padapter->mlmeextpriv.channel_set),
                                pnetwork->network.DSConfig);
  if (tmp >= 0) {
    rtw_cfg80211_inform_bss(padapter, pnetwork);
  } else {
  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_51784: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_51783;
  } else {
  }
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
  rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___0, 0);
  return;
}
}
static int rtw_cfg80211_set_probe_req_wpsp2pie(struct rtw_adapter *padapter , char *buf ,
                                               int len )
{
  int ret ;
  uint wps_ielen ;
  u8 *wps_ie ;
  struct mlme_priv *pmlmepriv ;
  void *tmp ;
  {
  ret = 0;
  wps_ielen = 0U;
  pmlmepriv = & padapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ielen =%d\n", "rtw_cfg80211_set_probe_req_wpsp2pie",
           len);
  } else {
  }
  if (len > 0) {
    wps_ie = rtw_get_wps_ie23a((u8 *)buf, (uint )len, (u8 *)0U, & wps_ielen);
    if ((unsigned long )wps_ie != (unsigned long )((u8 *)0U)) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: probe_req_wps_ielen =%d\n", wps_ielen);
      } else {
      }
      if ((unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
        pmlmepriv->wps_probe_req_ie_len = 0U;
        kfree((void const *)pmlmepriv->wps_probe_req_ie);
        pmlmepriv->wps_probe_req_ie = (u8 *)0U;
      } else {
      }
      tmp = kmemdup((void const *)wps_ie, (size_t )wps_ielen, 208U);
      pmlmepriv->wps_probe_req_ie = (u8 *)tmp;
      if ((unsigned long )pmlmepriv->wps_probe_req_ie == (unsigned long )((u8 *)0U)) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: %s()-%d: kmalloc() OLD_ERROR!\n", "rtw_cfg80211_set_probe_req_wpsp2pie",
                 1722);
        } else {
        }
        return (-22);
      } else {
      }
      pmlmepriv->wps_probe_req_ie_len = wps_ielen;
    } else {
    }
  } else {
  }
  return (ret);
}
}
static int cfg80211_rtw_scan(struct wiphy *wiphy , struct cfg80211_scan_request *request )
{
  int i ;
  u8 _status ;
  int ret ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct cfg80211_ssid ssid[9U] ;
  struct rtw_ieee80211_channel ch[51U] ;
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp___0 ;
  struct cfg80211_ssid *ssids ;
  bool need_indicate_scan_done ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___5 ;
  int tmp___6 ;
  {
  _status = 0U;
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  pmlmepriv = & padapter->mlmepriv;
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
  pwdev_priv = (struct rtw_wdev_priv *)tmp___0;
  ssids = request->ssids;
  need_indicate_scan_done = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_scan", (char *)(& (padapter->pnetdev)->name));
  } else {
  }
  spin_lock_bh(& pwdev_priv->scan_req_lock);
  pwdev_priv->scan_request = request;
  spin_unlock_bh(& pwdev_priv->scan_req_lock);
  tmp___1 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s under WIFI_AP_STATE\n", "cfg80211_rtw_scan");
    } else {
    }
  } else {
  }
  tmp___2 = _rtw_pwr_wakeup23a(padapter, 2000U, "cfg80211_rtw_scan");
  if (tmp___2 == 0) {
    need_indicate_scan_done = 1;
    goto check_need_indicate_scan_done;
  } else {
  }
  if ((unsigned long )request->ie != (unsigned long )((u8 const *)0U) && request->ie_len != 0UL) {
    rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (char *)request->ie, (int )request->ie_len);
  } else {
  }
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, bBusyTraffic == true\n", "cfg80211_rtw_scan");
    } else {
    }
    need_indicate_scan_done = 1;
    goto check_need_indicate_scan_done;
  } else {
  }
  tmp___3 = rtw_is_scan_deny(padapter);
  if ((int )tmp___3) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): scan deny\n", "cfg80211_rtw_scan", (char *)(& (padapter->pnetdev)->name));
    } else {
    }
    need_indicate_scan_done = 1;
    goto check_need_indicate_scan_done;
  } else {
  }
  tmp___4 = check_fwstate(pmlmepriv, 2176);
  if ((int )tmp___4) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, fwstate = 0x%x\n", "cfg80211_rtw_scan", pmlmepriv->fw_state);
    } else {
    }
    need_indicate_scan_done = 1;
    goto check_need_indicate_scan_done;
  } else {
  }
  memset((void *)(& ssid), 0, 297UL);
  i = 0;
  goto ldv_51816;
  ldv_51815: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ssid =%s, len =%d\n", (u8 *)(& (ssids + (unsigned long )i)->ssid),
           (int )(ssids + (unsigned long )i)->ssid_len);
  } else {
  }
  __len = (size_t )(ssids + (unsigned long )i)->ssid_len;
  __ret = memcpy((void *)(& ssid[i].ssid), (void const *)(& (ssids + (unsigned long )i)->ssid),
                           __len);
  ssid[i].ssid_len = (ssids + (unsigned long )i)->ssid_len;
  i = i + 1;
  ldv_51816: ;
  if (request->n_ssids > i && i <= 8) {
    goto ldv_51815;
  } else {
  }
  memset((void *)(& ch), 0, 408UL);
  if (request->n_channels == 1U) {
    i = 0;
    goto ldv_51819;
    ldv_51818: ;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s:(%s):hw_value:%u, flags:0x%08x\n", "cfg80211_rtw_scan",
             (char *)(& (padapter->pnetdev)->name), (int )(request->channels[i])->hw_value,
             (request->channels[i])->flags);
    } else {
    }
    ch[i].hw_value = (request->channels[i])->hw_value;
    ch[i].flags = (request->channels[i])->flags;
    i = i + 1;
    ldv_51819: ;
    if ((u32 )i < request->n_channels && i <= 50) {
      goto ldv_51818;
    } else {
    }
  } else {
  }
  spin_lock_bh(& pmlmepriv->lock);
  if (request->n_channels == 1U) {
    __len___0 = 8UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& ch) + 1U, (void const *)(& ch), __len___0);
    } else {
      __ret___0 = memcpy((void *)(& ch) + 1U, (void const *)(& ch), __len___0);
    }
    __len___1 = 8UL;
    if (__len___1 > 63UL) {
      __ret___1 = memcpy((void *)(& ch) + 2U, (void const *)(& ch), __len___1);
    } else {
      __ret___1 = memcpy((void *)(& ch) + 2U, (void const *)(& ch), __len___1);
    }
    tmp___5 = rtw_sitesurvey_cmd23a(padapter, (struct cfg80211_ssid *)(& ssid), 9,
                                    (struct rtw_ieee80211_channel *)(& ch), 3);
    _status = (u8 )tmp___5;
  } else {
    tmp___6 = rtw_sitesurvey_cmd23a(padapter, (struct cfg80211_ssid *)(& ssid), 9,
                                    (struct rtw_ieee80211_channel *)0, 0);
    _status = (u8 )tmp___6;
  }
  spin_unlock_bh(& pmlmepriv->lock);
  if ((unsigned int )_status == 0U) {
    ret = -1;
  } else {
  }
  check_need_indicate_scan_done: ;
  if ((int )need_indicate_scan_done) {
    rtw_cfg80211_surveydone_event_callback(padapter);
  } else {
  }
  return (ret);
}
}
static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy , u32 changed )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_set_wiphy_params");
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_join_ibss(struct wiphy *wiphy , struct net_device *ndev ,
                                  struct cfg80211_ibss_params *params )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_join_ibss", (char *)(& ndev->name));
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_leave_ibss(struct wiphy *wiphy , struct net_device *ndev )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_leave_ibss", (char *)(& ndev->name));
  } else {
  }
  return (0);
}
}
static int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv , u32 wpa_version )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, wpa_version =%d\n", "rtw_cfg80211_set_wpa_version",
           wpa_version);
  } else {
  }
  if (wpa_version == 0U) {
    psecuritypriv->ndisauthtype = 0U;
    return (0);
  } else {
  }
  if ((wpa_version & 3U) != 0U) {
    psecuritypriv->ndisauthtype = 4U;
  } else {
  }
  return (0);
}
}
static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv , enum nl80211_auth_type sme_auth_type )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, nl80211_auth_type =%d\n", "rtw_cfg80211_set_auth_type",
           (unsigned int )sme_auth_type);
  } else {
  }
  switch ((unsigned int )sme_auth_type) {
  case 5U:
  psecuritypriv->dot11AuthAlgrthm = 3U;
  goto ldv_51854;
  case 0U:
  psecuritypriv->dot11AuthAlgrthm = 0U;
  if (psecuritypriv->ndisauthtype > 3U) {
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else {
  }
  goto ldv_51854;
  case 1U:
  psecuritypriv->dot11AuthAlgrthm = 1U;
  psecuritypriv->ndisencryptstatus = 0U;
  goto ldv_51854;
  default:
  psecuritypriv->dot11AuthAlgrthm = 0U;
  }
  ldv_51854: ;
  return (0);
}
}
static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv , u32 cipher ,
                                   bool ucast )
{
  u32 ndisencryptstatus ;
  u32 *profile_cipher ;
  {
  ndisencryptstatus = 1U;
  profile_cipher = (int )ucast ? & psecuritypriv->dot11PrivacyAlgrthm : & psecuritypriv->dot118021XGrpPrivacy;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ucast =%d, cipher = 0x%x\n", "rtw_cfg80211_set_cipher",
           (int )ucast, cipher);
  } else {
  }
  if (cipher == 0U) {
    *profile_cipher = 0U;
    psecuritypriv->ndisencryptstatus = ndisencryptstatus;
    return (0);
  } else {
  }
  switch (cipher) {
  case 1U:
  *profile_cipher = 0U;
  ndisencryptstatus = 1U;
  goto ldv_51867;
  case 1027073U:
  *profile_cipher = 1027073U;
  ndisencryptstatus = 0U;
  goto ldv_51867;
  case 1027077U:
  *profile_cipher = 1027077U;
  ndisencryptstatus = 0U;
  goto ldv_51867;
  case 1027074U:
  *profile_cipher = 1027074U;
  ndisencryptstatus = 4U;
  goto ldv_51867;
  case 1027076U:
  *profile_cipher = 1027076U;
  ndisencryptstatus = 6U;
  goto ldv_51867;
  default: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Unsupported cipher: 0x%x\n", cipher);
  } else {
  }
  return (-524);
  }
  ldv_51867: ;
  if ((int )ucast) {
    psecuritypriv->ndisencryptstatus = ndisencryptstatus;
  } else {
  }
  return (0);
}
}
static int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv , u32 key_mgt )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, key_mgt = 0x%x\n", "rtw_cfg80211_set_key_mgt", key_mgt);
  } else {
  }
  if (key_mgt == 1027073U) {
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else
  if (key_mgt == 1027074U) {
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Invalid key mgt: 0x%x\n", key_mgt);
  } else {
  }
  return (0);
}
}
static int rtw_cfg80211_set_wpa_ie(struct rtw_adapter *padapter , u8 const *pie ,
                                   size_t ielen )
{
  u8 *buf ;
  int group_cipher ;
  int pairwise_cipher ;
  int ret ;
  u8 const *pwpa ;
  u8 const *pwpa2 ;
  int i ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___1 ;
  uint wps_ielen ;
  u8 *wps_ie ;
  size_t __len___1 ;
  void *__ret___1 ;
  {
  buf = (u8 *)0U;
  group_cipher = 0;
  pairwise_cipher = 0;
  ret = 0;
  if ((unsigned long )pie == (unsigned long )((u8 const *)0U) || ielen == 0UL) {
    _clr_fwstate_(& padapter->mlmepriv, 256);
    goto exit;
  } else {
  }
  if (ielen > 1024UL) {
    ret = -22;
    goto exit;
  } else {
  }
  tmp = kmemdup((void const *)pie, ielen, 208U);
  buf = (u8 *)tmp;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    ret = -12;
    goto exit;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: set wpa_ie(length:%zu):\n", ielen);
  } else {
  }
  i = 0;
  goto ldv_51892;
  ldv_51891: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",
           (int )*(buf + (unsigned long )i), (int )*(buf + ((unsigned long )i + 1UL)),
           (int )*(buf + ((unsigned long )i + 2UL)), (int )*(buf + ((unsigned long )i + 3UL)),
           (int )*(buf + ((unsigned long )i + 4UL)), (int )*(buf + ((unsigned long )i + 5UL)),
           (int )*(buf + ((unsigned long )i + 6UL)), (int )*(buf + ((unsigned long )i + 7UL)));
  } else {
  }
  i = i + 8;
  ldv_51892: ;
  if ((size_t )i < ielen) {
    goto ldv_51891;
  } else {
  }
  if (ielen <= 3UL) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 33554432U, 4);
      printk("\016Ie len too short %d\n", (int )ielen);
    } else {
    }
    ret = -1;
    goto exit;
  } else {
  }
  pwpa = cfg80211_find_vendor_ie(20722U, 1, (u8 const *)buf, (int )ielen);
  if ((unsigned long )pwpa != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(pwpa + 1UL)) != 0U) {
    tmp___0 = rtw_parse_wpa_ie23a(pwpa, (int )*(pwpa + 1UL) + 2, & group_cipher, & pairwise_cipher,
                                  (int *)0);
    if (tmp___0 == 1) {
      padapter->securitypriv.dot11AuthAlgrthm = 2U;
      padapter->securitypriv.ndisauthtype = 4U;
      __len = (size_t )((int )*(pwpa + 1UL) + 2);
      __ret = memcpy((void *)(& padapter->securitypriv.supplicant_ie), (void const *)pwpa,
                               __len);
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: got wpa_ie, wpa_ielen:%u\n", (int )*(pwpa + 1UL));
      } else {
      }
    } else {
    }
  } else {
  }
  pwpa2 = cfg80211_find_ie(48, (u8 const *)buf, (int )ielen);
  if ((unsigned long )pwpa2 != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(pwpa2 + 1UL)) != 0U) {
    tmp___1 = rtw_parse_wpa2_ie23a(pwpa2, (int )*(pwpa2 + 1UL) + 2, & group_cipher,
                                   & pairwise_cipher, (int *)0);
    if (tmp___1 == 1) {
      padapter->securitypriv.dot11AuthAlgrthm = 2U;
      padapter->securitypriv.ndisauthtype = 7U;
      __len___0 = (size_t )((int )*(pwpa2 + 1UL) + 2);
      __ret___0 = memcpy((void *)(& padapter->securitypriv.supplicant_ie),
                                   (void const *)pwpa2, __len___0);
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: got wpa2_ie, wpa2_ielen:%u\n", (int )*(pwpa2 + 1UL));
      } else {
      }
    } else {
    }
  } else {
  }
  if (group_cipher == 0) {
    group_cipher = 1;
  } else {
  }
  if (pairwise_cipher == 0) {
    pairwise_cipher = 1;
  } else {
  }
  switch (group_cipher) {
  case 1:
  padapter->securitypriv.dot118021XGrpPrivacy = 0U;
  padapter->securitypriv.ndisencryptstatus = 1U;
  goto ldv_51901;
  case 2:
  padapter->securitypriv.dot118021XGrpPrivacy = 1027073U;
  padapter->securitypriv.ndisencryptstatus = 0U;
  goto ldv_51901;
  case 8:
  padapter->securitypriv.dot118021XGrpPrivacy = 1027074U;
  padapter->securitypriv.ndisencryptstatus = 4U;
  goto ldv_51901;
  case 16:
  padapter->securitypriv.dot118021XGrpPrivacy = 1027076U;
  padapter->securitypriv.ndisencryptstatus = 6U;
  goto ldv_51901;
  case 4:
  padapter->securitypriv.dot118021XGrpPrivacy = 1027077U;
  padapter->securitypriv.ndisencryptstatus = 0U;
  goto ldv_51901;
  }
  ldv_51901: ;
  switch (pairwise_cipher) {
  case 1:
  padapter->securitypriv.dot11PrivacyAlgrthm = 0U;
  padapter->securitypriv.ndisencryptstatus = 1U;
  goto ldv_51907;
  case 2:
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027073U;
  padapter->securitypriv.ndisencryptstatus = 0U;
  goto ldv_51907;
  case 8:
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027074U;
  padapter->securitypriv.ndisencryptstatus = 4U;
  goto ldv_51907;
  case 16:
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027076U;
  padapter->securitypriv.ndisencryptstatus = 6U;
  goto ldv_51907;
  case 4:
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027077U;
  padapter->securitypriv.ndisencryptstatus = 0U;
  goto ldv_51907;
  }
  ldv_51907:
  wps_ie = rtw_get_wps_ie23a(buf, (uint )ielen, (u8 *)0U, & wps_ielen);
  if ((unsigned long )wps_ie != (unsigned long )((u8 *)0U) && wps_ielen != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: got wps_ie, wps_ielen:%u\n", wps_ielen);
    } else {
    }
    padapter->securitypriv.wps_ie_len = (int )(512U < wps_ielen ? 512U : wps_ielen);
    __len___1 = (size_t )padapter->securitypriv.wps_ie_len;
    __ret___1 = memcpy((void *)(& padapter->securitypriv.wps_ie), (void const *)wps_ie,
                                 __len___1);
    set_fwstate(& padapter->mlmepriv, 256);
  } else {
    _clr_fwstate_(& padapter->mlmepriv, 256);
  }
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
    rtl8723a_off_rcr_am(padapter);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 33554432U, 7);
    printk("\016rtw_set_wpa_ie: pairwise_cipher = 0x%08x padapter->securitypriv.ndisencryptstatus =%d padapter->securitypriv.ndisauthtype =%d\n",
           pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype);
  } else {
  }
  exit:
  kfree((void const *)buf);
  if (ret != 0) {
    _clr_fwstate_(& padapter->mlmepriv, 256);
  } else {
  }
  return (ret);
}
}
static int rtw_cfg80211_add_wep(struct rtw_adapter *padapter , struct rtw_wep_key *wep ,
                                u8 keyid )
{
  int res ;
  struct security_priv *psecuritypriv ;
  size_t __len ;
  void *__ret ;
  {
  psecuritypriv = & padapter->securitypriv;
  if ((unsigned int )keyid > 3U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
      printk("\016%s:keyid>4 =>fail\n", "rtw_cfg80211_add_wep");
    } else {
    }
    res = 0;
    goto exit;
  } else {
  }
  switch ((int )wep->keylen) {
  case 5:
  psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
    printk("\016%s:wep->KeyLength = 5\n", "rtw_cfg80211_add_wep");
  } else {
  }
  goto ldv_51927;
  case 13:
  psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
    printk("\016%s:wep->KeyLength = 13\n", "rtw_cfg80211_add_wep");
  } else {
  }
  goto ldv_51927;
  default:
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
    printk("\016%s:wep->KeyLength!= 5 or 13\n", "rtw_cfg80211_add_wep");
  } else {
  }
  res = 0;
  goto exit;
  }
  ldv_51927: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
    printk("\016%s:before memcpy, wep->KeyLength = 0x%x keyid =%x\n", "rtw_cfg80211_add_wep",
           (int )wep->keylen, (int )keyid);
  } else {
  }
  __len = 16UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& psecuritypriv->wep_key) + (unsigned long )keyid, (void const *)wep,
                     __len);
  } else {
    __ret = memcpy((void *)(& psecuritypriv->wep_key) + (unsigned long )keyid,
                             (void const *)wep, __len);
  }
  psecuritypriv->dot11PrivacyKeyIndex = (u32 )keyid;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
    printk("\016%s:security key material : %x %x %x %x %x %x %x %x %x %x %x %x %x\n",
           "rtw_cfg80211_add_wep", (int )psecuritypriv->wep_key[(int )keyid].key[0],
           (int )psecuritypriv->wep_key[(int )keyid].key[1], (int )psecuritypriv->wep_key[(int )keyid].key[2],
           (int )psecuritypriv->wep_key[(int )keyid].key[3], (int )psecuritypriv->wep_key[(int )keyid].key[4],
           (int )psecuritypriv->wep_key[(int )keyid].key[5], (int )psecuritypriv->wep_key[(int )keyid].key[6],
           (int )psecuritypriv->wep_key[(int )keyid].key[7], (int )psecuritypriv->wep_key[(int )keyid].key[8],
           (int )psecuritypriv->wep_key[(int )keyid].key[9], (int )psecuritypriv->wep_key[(int )keyid].key[10],
           (int )psecuritypriv->wep_key[(int )keyid].key[11], (int )psecuritypriv->wep_key[(int )keyid].key[12]);
  } else {
  }
  res = rtw_set_key23a(padapter, psecuritypriv, (int )keyid, 1);
  exit: ;
  return (res);
}
}
static int cfg80211_rtw_connect(struct wiphy *wiphy , struct net_device *ndev , struct cfg80211_connect_params *sme )
{
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct wlan_network *pnetwork ;
  enum ndis_802_11_auth_mode authmode ;
  struct cfg80211_ssid ndis_ssid ;
  u8 *dst_ssid ;
  u8 *src_ssid ;
  u8 *dst_bssid ;
  u8 const *src_bssid ;
  u8 matched ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct rtw_queue *queue ;
  int tmp___0 ;
  bool tmp___1 ;
  size_t __len ;
  void *__ret ;
  bool tmp___2 ;
  bool tmp___3 ;
  struct list_head const *__mptr ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct rtw_wep_key wep_key ;
  u8 wep_key_idx ;
  u8 wep_key_len ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___10 ;
  int tmp___11 ;
  {
  ret = 0;
  pnetwork = (struct wlan_network *)0;
  matched = 0U;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  queue = & pmlmepriv->scanned_queue;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: =>%s(%s)\n", "cfg80211_rtw_connect", (char *)(& ndev->name));
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: privacy =%d, key =%p, key_len =%d, key_idx =%d\n", (int )sme->privacy,
           sme->key, (int )sme->key_len, (int )sme->key_idx);
  } else {
  }
  tmp___0 = _rtw_pwr_wakeup23a(padapter, 2000U, "cfg80211_rtw_connect");
  if (tmp___0 == 0) {
    ret = -1;
    goto exit;
  } else {
  }
  tmp___1 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___1) {
    ret = -1;
    goto exit;
  } else {
  }
  if ((unsigned long )sme->ssid == (unsigned long )((u8 const *)0U) || sme->ssid_len == 0UL) {
    ret = -22;
    goto exit;
  } else {
  }
  if (sme->ssid_len > 32UL) {
    ret = -7;
    goto exit;
  } else {
  }
  memset((void *)(& ndis_ssid), 0, 33UL);
  ndis_ssid.ssid_len = (u8 )sme->ssid_len;
  __len = sme->ssid_len;
  __ret = memcpy((void *)(& ndis_ssid.ssid), (void const *)sme->ssid,
                           __len);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ssid =%s, len =%zu\n", (u8 *)(& ndis_ssid.ssid), sme->ssid_len);
  } else {
  }
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: bssid =%02x:%02x:%02x:%02x:%02x:%02x\n", (int )*((u8 *)sme->bssid),
             (int )*((u8 *)sme->bssid + 1UL), (int )*((u8 *)sme->bssid + 2UL), (int )*((u8 *)sme->bssid + 3UL),
             (int )*((u8 *)sme->bssid + 4UL), (int )*((u8 *)sme->bssid + 5UL));
    } else {
    }
  } else {
  }
  tmp___2 = check_fwstate(pmlmepriv, 128);
  if ((int )tmp___2) {
    ret = -16;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, fw_state = 0x%x, goto exit\n", "cfg80211_rtw_connect",
             pmlmepriv->fw_state);
    } else {
    }
    goto exit;
  } else {
  }
  tmp___3 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___3) {
    rtw_scan_abort23a(padapter);
  } else {
  }
  spin_lock_bh(& queue->lock);
  phead = get_list_head(queue);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_51967;
  ldv_51966:
  __mptr = (struct list_head const *)plist;
  pnetwork = (struct wlan_network *)__mptr;
  dst_ssid = (u8 *)(& pnetwork->network.Ssid.ssid);
  dst_bssid = (u8 *)(& pnetwork->network.MacAddress);
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const *)0U)) {
    tmp___4 = ether_addr_equal((u8 const *)(& pnetwork->network.MacAddress), sme->bssid);
    if (tmp___4) {
      tmp___5 = 0;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      goto ldv_51961;
    } else {
    }
  } else {
  }
  if ((unsigned long )sme->ssid != (unsigned long )((u8 const *)0U) && sme->ssid_len != 0UL) {
    if ((size_t )pnetwork->network.Ssid.ssid_len != sme->ssid_len) {
      goto ldv_51961;
    } else {
      tmp___6 = memcmp((void const *)(& pnetwork->network.Ssid.ssid), (void const *)sme->ssid,
                       sme->ssid_len);
      if (tmp___6 != 0) {
        goto ldv_51961;
      } else {
      }
    }
  } else {
  }
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const *)0U)) {
    src_bssid = sme->bssid;
    tmp___7 = ether_addr_equal((u8 const *)dst_bssid, src_bssid);
    if ((int )tmp___7) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: matched by bssid\n");
      } else {
      }
      ndis_ssid.ssid_len = pnetwork->network.Ssid.ssid_len;
      __len___0 = (size_t )pnetwork->network.Ssid.ssid_len;
      __ret___0 = memcpy((void *)(& ndis_ssid.ssid), (void const *)(& pnetwork->network.Ssid.ssid),
                                   __len___0);
      matched = 1U;
      goto ldv_51965;
    } else {
    }
  } else
  if ((unsigned long )sme->ssid != (unsigned long )((u8 const *)0U) && sme->ssid_len != 0UL) {
    src_ssid = (u8 *)(& ndis_ssid.ssid);
    tmp___8 = memcmp((void const *)dst_ssid, (void const *)src_ssid, (size_t )ndis_ssid.ssid_len);
    if (tmp___8 == 0 && (int )pnetwork->network.Ssid.ssid_len == (int )ndis_ssid.ssid_len) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: matched by ssid\n");
      } else {
      }
      matched = 1U;
      goto ldv_51965;
    } else {
    }
  } else {
  }
  ldv_51961:
  plist = ptmp;
  ptmp = plist->next;
  ldv_51967: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_51966;
  } else {
  }
  ldv_51965:
  spin_unlock_bh(& queue->lock);
  if ((unsigned int )matched == 0U || (unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
    ret = -2;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: connect, matched == false, goto exit\n");
    } else {
    }
    goto exit;
  } else {
  }
  tmp___9 = cfg80211_infrastructure_mode(padapter, pnetwork->network.ifmode);
  if (tmp___9 != 1) {
    ret = -1;
    goto exit;
  } else {
  }
  psecuritypriv->ndisencryptstatus = 1U;
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
  psecuritypriv->dot118021XGrpPrivacy = 0U;
  psecuritypriv->dot11AuthAlgrthm = 0U;
  psecuritypriv->ndisauthtype = 0U;
  ret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);
  if (ret < 0) {
    goto exit;
  } else {
  }
  ret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);
  if (ret < 0) {
    goto exit;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ie_len =%zu\n", "cfg80211_rtw_connect", sme->ie_len);
  } else {
  }
  ret = rtw_cfg80211_set_wpa_ie(padapter, sme->ie, sme->ie_len);
  if (ret < 0) {
    goto exit;
  } else {
  }
  if (sme->crypto.n_ciphers_pairwise != 0) {
    ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0],
                                  1);
    if (ret < 0) {
      goto exit;
    } else {
    }
  } else {
  }
  if ((psecuritypriv->dot11AuthAlgrthm == 1U || psecuritypriv->dot11AuthAlgrthm == 3U) && (unsigned long )sme->key != (unsigned long )((u8 const *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): Shared/Auto WEP\n", "cfg80211_rtw_connect");
    } else {
    }
    wep_key_idx = sme->key_idx;
    wep_key_len = sme->key_len;
    if (((unsigned int )wep_key_idx > 4U || (unsigned int )wep_key_len == 0U) || (unsigned int )wep_key_len > 13U) {
      ret = -22;
      goto exit;
    } else {
    }
    wep_key_len = (unsigned int )wep_key_len <= 5U ? 5U : 13U;
    memset((void *)(& wep_key), 0, 16UL);
    wep_key.keylen = (u16 )wep_key_len;
    if ((unsigned int )wep_key_len == 13U) {
      padapter->securitypriv.dot11PrivacyAlgrthm = 1027077U;
      padapter->securitypriv.dot118021XGrpPrivacy = 1027077U;
    } else {
      padapter->securitypriv.dot11PrivacyAlgrthm = 1027073U;
      padapter->securitypriv.dot118021XGrpPrivacy = 1027073U;
    }
    __len___1 = (size_t )wep_key.keylen;
    __ret___1 = memcpy((void *)(& wep_key.key), (void const *)sme->key,
                                 __len___1);
    tmp___10 = rtw_cfg80211_add_wep(padapter, & wep_key, (int )wep_key_idx);
    if (tmp___10 != 1) {
      ret = -95;
    } else {
    }
    if (ret < 0) {
      goto exit;
    } else {
    }
  } else {
  }
  ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, 0);
  if (ret < 0) {
    return (ret);
  } else {
  }
  if (sme->crypto.n_akm_suites != 0) {
    ret = rtw_cfg80211_set_key_mgt(psecuritypriv, sme->crypto.akm_suites[0]);
    if (ret < 0) {
      goto exit;
    } else {
    }
  } else {
  }
  authmode = (enum ndis_802_11_auth_mode )psecuritypriv->ndisauthtype;
  rtw_set_802_11_authentication_mode23a(padapter, authmode);
  tmp___11 = rtw_set_802_11_ssid23a(padapter, & ndis_ssid);
  if (tmp___11 == 0) {
    ret = -1;
    goto exit;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: set ssid:dot11AuthAlgrthm =%d, dot11PrivacyAlgrthm =%d, dot118021XGrpPrivacy =%d\n",
           psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy);
  } else {
  }
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: <=%s, ret %d\n", "cfg80211_rtw_connect", ret);
  } else {
  }
  return (ret);
}
}
static int cfg80211_rtw_disconnect(struct wiphy *wiphy , struct net_device *ndev ,
                                   u16 reason_code )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  bool tmp___0 ;
  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_disconnect", (char *)(& ndev->name));
  } else {
  }
  rtw_set_roaming(padapter, 0);
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp___0) {
    rtw_scan_abort23a(padapter);
    LeaveAllPowerSaveMode23a(padapter);
    rtw_disassoc_cmd23a(padapter, 500U, 0);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s...call rtw_indicate_disconnect23a\n", "cfg80211_rtw_disconnect");
    } else {
    }
    padapter->mlmepriv.not_indic_disco = 1U;
    rtw_indicate_disconnect23a(padapter);
    padapter->mlmepriv.not_indic_disco = 0U;
    rtw_free_assoc_resources23a(padapter, 1);
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_set_txpower(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                    enum nl80211_tx_power_setting type , int mbm )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_set_txpower");
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_get_txpower(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                    int *dbm )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_get_txpower");
  } else {
  }
  *dbm = 12;
  return (0);
}
}
static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy , struct net_device *ndev ,
                                       bool enabled , int timeout )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct rtw_wdev_priv *rtw_wdev_priv ;
  void *tmp___0 ;
  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
  rtw_wdev_priv = (struct rtw_wdev_priv *)tmp___0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): enabled:%u, timeout:%d\n", "cfg80211_rtw_set_power_mgmt",
           (char *)(& ndev->name), (int )enabled, timeout);
  } else {
  }
  rtw_wdev_priv->power_mgmt = enabled;
  if (! enabled) {
    LPS_Leave23a(padapter);
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy , struct net_device *netdev ,
                                  struct cfg80211_pmksa *pmksa )
{
  u8 index ;
  u8 blInserted ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;
  size_t __len ;
  void *__ret ;
  bool tmp___1 ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  blInserted = 0U;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_set_pmksa", (char *)(& netdev->name));
  } else {
  }
  tmp___0 = is_zero_ether_addr(pmksa->bssid);
  if ((int )tmp___0) {
    return (-22);
  } else {
  }
  blInserted = 0U;
  index = 0U;
  goto ldv_52022;
  ldv_52021:
  tmp___1 = ether_addr_equal((u8 const *)(& psecuritypriv->PMKIDList[(int )index].Bssid),
                             pmksa->bssid);
  if ((int )tmp___1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s):  BSSID exists in the PMKList.\n", "cfg80211_rtw_set_pmksa",
             (char *)(& netdev->name));
    } else {
    }
    __len = 16UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID), (void const *)pmksa->pmkid,
                       __len);
    } else {
      __ret = memcpy((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID),
                               (void const *)pmksa->pmkid, __len);
    }
    psecuritypriv->PMKIDList[(int )index].bUsed = 1U;
    psecuritypriv->PMKIDIndex = (unsigned int )index + 1U;
    blInserted = 1U;
    goto ldv_52020;
  } else {
  }
  index = (u8 )((int )index + 1);
  ldv_52022: ;
  if ((unsigned int )index <= 15U) {
    goto ldv_52021;
  } else {
  }
  ldv_52020: ;
  if ((unsigned int )blInserted == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): Use new entry index = %d for this PMKID\n", "cfg80211_rtw_set_pmksa",
             (char *)(& netdev->name), (int )psecuritypriv->PMKIDIndex);
    } else {
    }
    ether_addr_copy((u8 *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].Bssid),
                    pmksa->bssid);
    __len___0 = 16UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].PMKID),
                           (void const *)pmksa->pmkid, __len___0);
    } else {
      __ret___0 = memcpy((void *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].PMKID),
                                   (void const *)pmksa->pmkid, __len___0);
    }
    psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].bUsed = 1U;
    psecuritypriv->PMKIDIndex = (u8 )((int )psecuritypriv->PMKIDIndex + 1);
    if ((unsigned int )psecuritypriv->PMKIDIndex == 16U) {
      psecuritypriv->PMKIDIndex = 0U;
    } else {
    }
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy , struct net_device *netdev ,
                                  struct cfg80211_pmksa *pmksa )
{
  u8 index ;
  u8 bMatched ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;
  {
  bMatched = 0U;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_del_pmksa", (char *)(& netdev->name));
  } else {
  }
  index = 0U;
  goto ldv_52038;
  ldv_52037:
  tmp___0 = ether_addr_equal((u8 const *)(& psecuritypriv->PMKIDList[(int )index].Bssid),
                             pmksa->bssid);
  if ((int )tmp___0) {
    eth_zero_addr((u8 *)(& psecuritypriv->PMKIDList[(int )index].Bssid));
    memset((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID), 0, 16UL);
    psecuritypriv->PMKIDList[(int )index].bUsed = 0U;
    bMatched = 1U;
    goto ldv_52036;
  } else {
  }
  index = (u8 )((int )index + 1);
  ldv_52038: ;
  if ((unsigned int )index <= 15U) {
    goto ldv_52037;
  } else {
  }
  ldv_52036: ;
  if ((unsigned int )bMatched == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): do not have matched BSSID\n", "cfg80211_rtw_del_pmksa",
             (char *)(& netdev->name));
    } else {
    }
    return (-22);
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy , struct net_device *netdev )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  psecuritypriv = & padapter->securitypriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_flush_pmksa", (char *)(& netdev->name));
  } else {
  }
  memset((void *)(& psecuritypriv->PMKIDList), 0, 1152UL);
  psecuritypriv->PMKIDIndex = 0U;
  return (0);
}
}
void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter , u8 *pmgmt_frame ,
                                     uint frame_len )
{
  s32 freq ;
  int channel ;
  struct mlme_ext_priv *pmlmeext ;
  struct net_device *ndev ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  ndev = padapter->pnetdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p,%s)\n", "rtw_cfg80211_indicate_sta_assoc",
           padapter, (char *)(& ndev->name));
  } else {
  }
  channel = (int )pmlmeext->cur_channel;
  if (channel <= 14) {
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
  cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const *)pmgmt_frame, (size_t )frame_len,
                   0U, 32U);
  return;
}
}
void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter , unsigned char *da ,
                                        unsigned short reason )
{
  s32 freq ;
  int channel ;
  u8 *pmgmt_frame ;
  uint frame_len ;
  struct ieee80211_hdr *pwlanhdr ;
  u8 mgmt_buf[128U] ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct net_device *ndev ;
  u8 *tmp ;
  u8 *tmp___0 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  ndev = padapter->pnetdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p,%s)\n", "rtw_cfg80211_indicate_sta_disassoc",
           padapter, (char *)(& ndev->name));
  } else {
  }
  memset((void *)(& mgmt_buf), 0, 128UL);
  channel = (int )pmlmeext->cur_channel;
  if (channel <= 14) {
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
  pmgmt_frame = (u8 *)(& mgmt_buf);
  pwlanhdr = (struct ieee80211_hdr *)pmgmt_frame;
  pwlanhdr->frame_control = 192U;
  tmp = myid(& padapter->eeprompriv);
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const *)tmp);
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const *)da);
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const *)tmp___0);
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pmgmt_frame = pmgmt_frame + 24UL;
  frame_len = 24U;
  reason = reason;
  pmgmt_frame = rtw_set_fixed_ie23a(pmgmt_frame, 2U, (unsigned char *)(& reason),
                                    & frame_len);
  cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const *)(& mgmt_buf), (size_t )frame_len,
                   0U, 32U);
  return;
}
}
static int rtw_cfg80211_monitor_if_open(struct net_device *ndev )
{
  int ret ;
  {
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_open");
  } else {
  }
  return (ret);
}
}
static int rtw_cfg80211_monitor_if_close(struct net_device *ndev )
{
  int ret ;
  {
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_close");
  } else {
  }
  return (ret);
}
}
static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb , struct net_device *ndev )
{
  int ret ;
  int rtap_len ;
  int qos_len ;
  int dot11_hdr_len ;
  int snap_len ;
  unsigned char *pdata ;
  unsigned char src_mac_addr[6U] ;
  unsigned char dst_mac_addr[6U] ;
  struct ieee80211_hdr *dot11_hdr ;
  struct ieee80211_radiotap_header *rtap_hdr ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u32 len ;
  u8 category ;
  u8 action ;
  char const *tmp___5 ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___6 ;
  int tmp___7 ;
  {
  ret = 0;
  qos_len = 0;
  dot11_hdr_len = 24;
  snap_len = 6;
  tmp = netdev_priv((struct net_device const *)ndev);
  padapter = (struct rtw_adapter *)tmp;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "rtw_cfg80211_monitor_if_xmit_entry", (char *)(& ndev->name));
  } else {
  }
  tmp___0 = ldv__builtin_expect(skb->len <= 7U, 0L);
  if (tmp___0 != 0L) {
    goto fail;
  } else {
  }
  rtap_hdr = (struct ieee80211_radiotap_header *)skb->data;
  tmp___1 = ldv__builtin_expect((unsigned int )rtap_hdr->it_version != 0U, 0L);
  if (tmp___1 != 0L) {
    goto fail;
  } else {
  }
  rtap_len = ieee80211_get_radiotap_len(skb->data);
  tmp___2 = ldv__builtin_expect(skb->len < (unsigned int )rtap_len, 0L);
  if (tmp___2 != 0L) {
    goto fail;
  } else {
  }
  if (rtap_len != 14) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: radiotap len (should be 14): %d\n", rtap_len);
    } else {
    }
    goto fail;
  } else {
  }
  skb_pull(skb, (unsigned int )rtap_len);
  dot11_hdr = (struct ieee80211_hdr *)skb->data;
  tmp___7 = ieee80211_is_data((int )dot11_hdr->frame_control);
  if (tmp___7 != 0) {
    tmp___3 = ieee80211_is_data_qos((int )dot11_hdr->frame_control);
    if (tmp___3 != 0) {
      qos_len = 2;
    } else {
    }
    tmp___4 = ieee80211_has_a4((int )dot11_hdr->frame_control);
    if (tmp___4 != 0) {
      dot11_hdr_len = dot11_hdr_len + 6;
    } else {
    }
    __len = 6UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& dst_mac_addr), (void const *)(& dot11_hdr->addr1),
                       __len);
    } else {
      __ret = memcpy((void *)(& dst_mac_addr), (void const *)(& dot11_hdr->addr1),
                               __len);
    }
    __len___0 = 6UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& src_mac_addr), (void const *)(& dot11_hdr->addr2),
                           __len___0);
    } else {
      __ret___0 = memcpy((void *)(& src_mac_addr), (void const *)(& dot11_hdr->addr2),
                                   __len___0);
    }
    skb_pull(skb, (unsigned int )(((dot11_hdr_len + qos_len) + snap_len) + -12));
    pdata = skb->data;
    ether_addr_copy(pdata, (u8 const *)(& dst_mac_addr));
    ether_addr_copy(pdata + 6U, (u8 const *)(& src_mac_addr));
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: should be eapol packet\n");
    } else {
    }
    ret = rtw_xmit23a_entry23a(skb, padapter->pnetdev);
    return (ret);
  } else {
    tmp___6 = ieee80211_is_action((int )dot11_hdr->frame_control);
    if (tmp___6 != 0) {
      pxmitpriv = & padapter->xmitpriv;
      pmlmeext = & padapter->mlmeextpriv;
      len = skb->len;
      mgmt = (struct ieee80211_mgmt *)dot11_hdr;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: RTW_Tx:da =%02x:%02x:%02x:%02x:%02x:%02x via %s(%s)\n",
               (int )*((u8 *)(& mgmt->da)), (int )*((u8 *)(& mgmt->da) + 1UL), (int )*((u8 *)(& mgmt->da) + 2UL),
               (int )*((u8 *)(& mgmt->da) + 3UL), (int )*((u8 *)(& mgmt->da) + 4UL),
               (int )*((u8 *)(& mgmt->da) + 5UL), "rtw_cfg80211_monitor_if_xmit_entry",
               (char *)(& ndev->name));
      } else {
      }
      category = mgmt->u.action.category;
      action = mgmt->u.action.u.wme_action.action_code;
      if ((unsigned int )mgmt->u.action.category == 4U) {
        if (GlobalDebugLevel23A > 3U) {
          tmp___5 = action_public_str23a((int )action);
          printk("\016RTL8723AU: RTW_Tx:%s\n", tmp___5);
        } else {
        }
      } else
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: RTW_Tx:category(%u), action(%u)\n", (int )category,
               (int )action);
      } else {
      }
      pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
      if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
        goto fail;
      } else {
      }
      pattrib = & pmgntframe->attrib;
      update_mgntframe_attrib23a(padapter, pattrib);
      pattrib->retry_ctrl = 0U;
      memset((void *)pmgntframe->buf_addr, 0, 104UL);
      pframe = pmgntframe->buf_addr + 40U;
      __len___1 = (size_t )len;
      __ret___1 = memcpy((void *)pframe, (void const *)skb->data, __len___1);
      pattrib->pktlen = len;
      pmlmeext->mgnt_seq = (u16 )((int )dot11_hdr->seq_ctrl >> 4);
      pattrib->seqnum = pmlmeext->mgnt_seq;
      pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
      pattrib->last_txcmdsz = pattrib->pktlen;
      dump_mgntframe23a(padapter, pmgntframe);
    } else {
    }
  }
  fail:
  consume_skb(skb);
  return (0);
}
}
static int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev , void *addr )
{
  int ret ;
  {
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_set_mac_address");
  } else {
  }
  return (ret);
}
}
static struct net_device_ops const rtw_cfg80211_monitor_if_ops =
     {0, 0, & rtw_cfg80211_monitor_if_open, & rtw_cfg80211_monitor_if_close, (netdev_tx_t (*)(struct sk_buff * ,
                                                                                            struct net_device * ))(& rtw_cfg80211_monitor_if_xmit_entry),
    0, 0, 0, & rtw_cfg80211_monitor_if_set_mac_address, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static int rtw_cfg80211_add_monitor_if(struct rtw_adapter *padapter , char *name ,
                                       struct net_device **ndev )
{
  int ret ;
  struct net_device *mon_ndev ;
  struct wireless_dev *mon_wdev ;
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;
  void *tmp___0 ;
  struct net_device *tmp___1 ;
  size_t __len ;
  void *__ret ;
  {
  ret = 0;
  mon_ndev = (struct net_device *)0;
  mon_wdev = (struct wireless_dev *)0;
  tmp = wdev_priv___1(padapter->rtw_wdev);
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
  if ((unsigned long )name == (unsigned long )((char *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): without specific name\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {
    }
    ret = -22;
    goto out;
  } else {
  }
  if ((unsigned long )pwdev_priv->pmon_ndev != (unsigned long )((struct net_device *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): monitor interface exist: %s\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name), (char *)(& (pwdev_priv->pmon_ndev)->name));
    } else {
    }
    ret = -16;
    goto out;
  } else {
  }
  mon_ndev = alloc_etherdev_mqs(18136, 1U, 1U);
  if ((unsigned long )mon_ndev == (unsigned long )((struct net_device *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): allocate ndev fail\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {
    }
    ret = -12;
    goto out;
  } else {
  }
  mon_ndev->type = 803U;
  strncpy((char *)(& mon_ndev->name), (char const *)name, 16UL);
  mon_ndev->name[15] = 0;
  mon_ndev->destructor = & rtw_ndev_destructor;
  mon_ndev->netdev_ops = & rtw_cfg80211_monitor_if_ops;
  tmp___0 = kzalloc(984UL, 208U);
  mon_wdev = (struct wireless_dev *)tmp___0;
  if ((unsigned long )mon_wdev == (unsigned long )((struct wireless_dev *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): allocate mon_wdev fail\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {
    }
    ret = -12;
    goto out;
  } else {
  }
  mon_wdev->wiphy = (padapter->rtw_wdev)->wiphy;
  mon_wdev->netdev = mon_ndev;
  mon_wdev->iftype = 6;
  mon_ndev->ieee80211_ptr = mon_wdev;
  ret = register_netdevice(mon_ndev);
  if (ret != 0) {
    goto out;
  } else {
  }
  tmp___1 = mon_ndev;
  pwdev_priv->pmon_ndev = tmp___1;
  *ndev = tmp___1;
  __len = 17UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pwdev_priv->ifname_mon), (void const *)name, __len);
  } else {
    __ret = memcpy((void *)(& pwdev_priv->ifname_mon), (void const *)name,
                             __len);
  }
  out: ;
  if (ret != 0) {
    kfree((void const *)mon_wdev);
    mon_wdev = (struct wireless_dev *)0;
  } else {
  }
  if (ret != 0 && (unsigned long )mon_ndev != (unsigned long )((struct net_device *)0)) {
    ldv_free_netdev_2079(mon_ndev);
    mon_ndev = (struct net_device *)0;
    *ndev = mon_ndev;
  } else {
  }
  return (ret);
}
}
static struct wireless_dev *cfg80211_rtw_add_virtual_intf(struct wiphy *wiphy , char const *name ,
                                                          enum nl80211_iftype type ,
                                                          u32 *flags , struct vif_params *params )
{
  int ret ;
  struct net_device *ndev ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  char const *tmp___0 ;
  void *tmp___1 ;
  struct wireless_dev *tmp___2 ;
  {
  ret = 0;
  ndev = (struct net_device *)0;
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = wiphy_name((struct wiphy const *)wiphy);
    printk("\016RTL8723AU: %s(%s): wiphy:%s, name:%s, type:%d\n", "cfg80211_rtw_add_virtual_intf",
           (char *)(& (padapter->pnetdev)->name), tmp___0, name, (unsigned int )type);
  } else {
  }
  switch ((unsigned int )type) {
  case 1U: ;
  case 4U: ;
  case 5U: ;
  case 7U:
  ret = -19;
  goto ldv_52152;
  case 6U:
  ret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, & ndev);
  goto ldv_52152;
  case 8U: ;
  case 2U:
  ret = -19;
  goto ldv_52152;
  case 9U: ;
  case 3U:
  ret = -19;
  goto ldv_52152;
  default:
  ret = -19;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: Unsupported interface type\n");
  } else {
  }
  goto ldv_52152;
  }
  ldv_52152: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): ndev:%p, ret:%d\n", "cfg80211_rtw_add_virtual_intf",
           (char *)(& (padapter->pnetdev)->name), ndev, ret);
  } else {
  }
  if ((unsigned long )ndev != (unsigned long )((struct net_device *)0)) {
    tmp___2 = ndev->ieee80211_ptr;
  } else {
    tmp___1 = ERR_PTR((long )ret);
    tmp___2 = (struct wireless_dev *)tmp___1;
  }
  return (tmp___2);
}
}
static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy , struct wireless_dev *wdev )
{
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;
  struct net_device *ndev ;
  {
  tmp = wiphy_priv___1(wiphy);
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
  ndev = (unsigned long )wdev != (unsigned long )((struct wireless_dev *)0) ? wdev->netdev : (struct net_device *)0;
  if ((unsigned long )ndev == (unsigned long )((struct net_device *)0)) {
    goto exit;
  } else {
  }
  unregister_netdevice(ndev);
  if ((unsigned long )pwdev_priv->pmon_ndev == (unsigned long )ndev) {
    pwdev_priv->pmon_ndev = (struct net_device *)0;
    pwdev_priv->ifname_mon[0] = 0;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): remove monitor interface\n", "cfg80211_rtw_del_virtual_intf",
             (char *)(& ndev->name));
    } else {
    }
  } else {
  }
  exit: ;
  return (0);
}
}
static int rtw_add_beacon(struct rtw_adapter *adapter , u8 const *head , size_t head_len ,
                          u8 const *tail , size_t tail_len )
{
  int ret ;
  u8 *pbuf ;
  uint len ;
  uint wps_ielen ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp___2 ;
  int tmp___3 ;
  {
  ret = 0;
  pbuf = (u8 *)0U;
  wps_ielen = 0U;
  pmlmepriv = & adapter->mlmepriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s beacon_head_len =%zu, beacon_tail_len =%zu\n", "rtw_add_beacon",
           head_len, tail_len);
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 16);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (-22);
  } else {
  }
  if (head_len <= 23UL) {
    return (-22);
  } else {
  }
  tmp___1 = kzalloc(head_len + tail_len, 208U);
  pbuf = (u8 *)tmp___1;
  if ((unsigned long )pbuf == (unsigned long )((u8 *)0U)) {
    return (-12);
  } else {
  }
  __len = head_len - 24UL;
  __ret = memcpy((void *)pbuf, (void const *)head + 24U, __len);
  __len___0 = tail_len;
  __ret___0 = memcpy((void *)(pbuf + (head_len + 0xffffffffffffffe8UL)),
                               (void const *)tail, __len___0);
  len = ((uint )head_len + (uint )tail_len) - 24U;
  tmp___2 = rtw_get_wps_ie23a(pbuf + 12UL, len - 12U, (u8 *)0U, & wps_ielen);
  if ((unsigned long )tmp___2 != (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: add bcn, wps_ielen =%d\n", wps_ielen);
    } else {
    }
  } else {
  }
  rtw_ies_remove_ie23a(pbuf, & len, 12U, 221, (u8 *)(& P2P_OUI23A), 4);
  rtw_ies_remove_ie23a(pbuf, & len, 12U, 221, (u8 *)(& WFD_OUI23A), 4);
  tmp___3 = rtw_check_beacon_data23a(adapter, pbuf, len);
  if (tmp___3 == 1) {
    ret = 0;
  } else {
    ret = -22;
  }
  kfree((void const *)pbuf);
  return (ret);
}
}
static int cfg80211_rtw_start_ap(struct wiphy *wiphy , struct net_device *ndev , struct cfg80211_ap_settings *settings )
{
  int ret ;
  struct rtw_adapter *adapter ;
  void *tmp ;
  struct wlan_bssid_ex *pbss_network ;
  struct wlan_bssid_ex *pbss_network_ext ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  adapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): hidden_ssid:%d, auth_type:%d\n", "cfg80211_rtw_start_ap",
           (char *)(& ndev->name), (unsigned int )settings->hidden_ssid, (unsigned int )settings->auth_type);
  } else {
  }
  ret = rtw_add_beacon(adapter, settings->beacon.head, settings->beacon.head_len,
                       settings->beacon.tail, settings->beacon.tail_len);
  adapter->mlmeextpriv.mlmext_info.hidden_ssid_mode = (u8 )settings->hidden_ssid;
  if ((unsigned long )settings->ssid != (unsigned long )((u8 const *)0U) && settings->ssid_len != 0UL) {
    pbss_network = & adapter->mlmepriv.cur_network.network;
    pbss_network_ext = & adapter->mlmeextpriv.mlmext_info.network;
    __len = settings->ssid_len;
    __ret = memcpy((void *)(& pbss_network->Ssid.ssid), (void const *)settings->ssid,
                             __len);
    pbss_network->Ssid.ssid_len = (u8 )settings->ssid_len;
    __len___0 = settings->ssid_len;
    __ret___0 = memcpy((void *)(& pbss_network_ext->Ssid.ssid), (void const *)settings->ssid,
                                 __len___0);
    pbss_network_ext->Ssid.ssid_len = (u8 )settings->ssid_len;
  } else {
  }
  return (ret);
}
}
static int cfg80211_rtw_change_beacon(struct wiphy *wiphy , struct net_device *ndev ,
                                      struct cfg80211_beacon_data *info )
{
  int ret ;
  struct rtw_adapter *adapter ;
  void *tmp ;
  {
  ret = 0;
  tmp = wiphy_priv___1(wiphy);
  adapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_beacon", (char *)(& ndev->name));
  } else {
  }
  ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
  return (ret);
}
}
static int cfg80211_rtw_stop_ap(struct wiphy *wiphy , struct net_device *ndev )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_stop_ap", (char *)(& ndev->name));
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_add_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const *mac , struct station_parameters *params )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_add_station", (char *)(& ndev->name));
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_del_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const *mac )
{
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 updated ;
  struct sta_info *psta ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  struct list_head const *__mptr ;
  bool tmp___3 ;
  {
  ret = 0;
  updated = 0U;
  tmp = netdev_priv((struct net_device const *)ndev);
  padapter = (struct rtw_adapter *)tmp;
  pmlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +%s(%s)\n", "cfg80211_rtw_del_station", (char *)(& ndev->name));
  } else {
  }
  tmp___0 = check_fwstate(pmlmepriv, 17);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, fw_state != FW_LINKED|WIFI_AP_STATE\n", "cfg80211_rtw_del_station");
    } else {
    }
    return (-22);
  } else {
  }
  if ((unsigned long )mac == (unsigned long )((u8 const *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: flush all sta, and cam_entry\n");
    } else {
    }
    flush_all_cam_entry23a(padapter);
    ret = rtw_sta_flush23a(padapter);
    return (ret);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: free sta macaddr =%02x:%02x:%02x:%02x:%02x:%02x\n", (int )*((u8 *)mac),
           (int )*((u8 *)mac + 1UL), (int )*((u8 *)mac + 2UL), (int )*((u8 *)mac + 3UL),
           (int )*((u8 *)mac + 4UL), (int )*((u8 *)mac + 5UL));
  } else {
  }
  tmp___2 = is_broadcast_ether_addr(mac);
  if ((int )tmp___2) {
    return (-22);
  } else {
  }
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_52241;
  ldv_52240:
  __mptr = (struct list_head const *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
  tmp___3 = ether_addr_equal(mac, (u8 const *)(& psta->hwaddr));
  if ((int )tmp___3) {
    if (psta->dot8021xalg == 1 && (unsigned int )psta->bpairwise_key_installed == 0U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s, sta\'s dot8021xalg = 1 and key_installed = false\n",
               "cfg80211_rtw_del_station");
      } else {
      }
    } else {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: free psta =%p, aid =%d\n", psta, psta->aid);
      } else {
      }
      list_del_init(& psta->asoc_list);
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
      updated = ap_free_sta23a(padapter, psta, 1, 3);
      psta = (struct sta_info *)0;
      goto ldv_52239;
    }
  } else {
  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_52241: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_52240;
  } else {
  }
  ldv_52239:
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  associated_clients_update23a(padapter, (int )updated);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -%s(%s)\n", "cfg80211_rtw_del_station", (char *)(& ndev->name));
  } else {
  }
  return (ret);
}
}
static int cfg80211_rtw_change_station(struct wiphy *wiphy , struct net_device *ndev ,
                                       u8 const *mac , struct station_parameters *params )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_station", (char *)(& ndev->name));
  } else {
  }
  return (0);
}
}
static int cfg80211_rtw_dump_station(struct wiphy *wiphy , struct net_device *ndev ,
                                     int idx , u8 *mac , struct station_info *sinfo )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_dump_station", (char *)(& ndev->name));
  } else {
  }
  return (-2);
}
}
static int cfg80211_rtw_change_bss(struct wiphy *wiphy , struct net_device *ndev ,
                                   struct bss_parameters *params )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_bss", (char *)(& ndev->name));
  } else {
  }
  return (0);
}
}
void rtw_cfg80211_rx_action(struct rtw_adapter *adapter , u8 *frame , uint frame_len ,
                            char const *msg )
{
  struct ieee80211_mgmt *hdr ;
  s32 freq ;
  int channel ;
  u8 tmp ;
  {
  hdr = (struct ieee80211_mgmt *)frame;
  tmp = rtw_get_oper_ch23a(adapter);
  channel = (int )tmp;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: RTW_Rx:cur_ch =%d\n", channel);
  } else {
  }
  if ((unsigned long )msg != (unsigned long )((char const *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: RTW_Rx:%s\n", msg);
    } else {
    }
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: RTW_Rx:category(%u), action(%u)\n", (int )hdr->u.action.category,
           (int )hdr->u.action.u.wme_action.action_code);
  } else {
  }
  if (channel <= 14) {
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
  cfg80211_rx_mgmt(adapter->rtw_wdev, freq, 0, (u8 const *)frame, (size_t )frame_len,
                   0U, 32U);
  return;
}
}
static int _cfg80211_rtw_mgmt_tx(struct rtw_adapter *padapter , u8 tx_ch , u8 const *buf ,
                                 size_t len )
{
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  int ret ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u8 tmp___2 ;
  size_t __len ;
  void *__ret ;
  {
  ret = 0;
  pxmitpriv = & padapter->xmitpriv;
  pmlmeext = & padapter->mlmeextpriv;
  tmp = _rtw_pwr_wakeup23a(padapter, 2000U, "_cfg80211_rtw_mgmt_tx");
  if (tmp == 0) {
    ret = -14;
    goto exit;
  } else {
  }
  rtw_set_scan_deny(padapter, 1000U);
  rtw_scan_abort23a(padapter);
  tmp___2 = rtw_get_oper_ch23a(padapter);
  if ((int )tmp___2 != (int )tx_ch) {
    tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      pmlmeext->cur_channel = tx_ch;
    } else {
    }
    set_channel_bwmode23a(padapter, (int )tx_ch, 0, 0);
  } else {
  }
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
    ret = 0;
    goto exit;
  } else {
  }
  pattrib = & pmgntframe->attrib;
  update_mgntframe_attrib23a(padapter, pattrib);
  pattrib->retry_ctrl = 0U;
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
  pframe = pmgntframe->buf_addr + 40U;
  __len = len;
  __ret = memcpy((void *)pframe, (void const *)buf, __len);
  pattrib->pktlen = (u32 )len;
  pwlanhdr = (struct ieee80211_hdr *)pframe;
  pmlmeext->mgnt_seq = (u16 )((int )pwlanhdr->seq_ctrl >> 4);
  pattrib->seqnum = pmlmeext->mgnt_seq;
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
  pattrib->last_txcmdsz = pattrib->pktlen;
  ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  if (ret != 1) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, ack == false\n", "_cfg80211_rtw_mgmt_tx");
    } else {
    }
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ack == true\n", "_cfg80211_rtw_mgmt_tx");
  } else {
  }
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ret =%d\n", "_cfg80211_rtw_mgmt_tx", ret);
  } else {
  }
  return (ret);
}
}
static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                struct cfg80211_mgmt_tx_params *params , u64 *cookie )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  int ret ;
  int tx_ret ;
  u32 dump_limit ;
  u32 dump_cnt ;
  bool ack ;
  u8 category ;
  u8 action ;
  unsigned long start ;
  size_t len ;
  struct ieee80211_channel *chan ;
  u8 const *buf ;
  struct ieee80211_mgmt *hdr ;
  u8 tx_ch ;
  int tmp___0 ;
  int tmp___1 ;
  char const *tmp___2 ;
  unsigned int tmp___3 ;
  {
  tmp = wiphy_priv___1(wiphy);
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
  ret = 0;
  dump_limit = 8U;
  dump_cnt = 0U;
  ack = 1;
  start = jiffies;
  len = params->len;
  chan = params->chan;
  buf = params->buf;
  hdr = (struct ieee80211_mgmt *)buf;
  tmp___0 = ieee80211_frequency_to_channel((int )chan->center_freq);
  tx_ch = (unsigned char )tmp___0;
  tmp___1 = ieee80211_is_action((int )hdr->frame_control);
  if (tmp___1 == 0) {
    return (-22);
  } else {
  }
  *cookie = (u64 )buf;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): len =%zu, ch =%d\n", "cfg80211_rtw_mgmt_tx", (char *)(& (padapter->pnetdev)->name),
           len, (int )tx_ch);
  } else {
  }
  cfg80211_mgmt_tx_status(padapter->rtw_wdev, *cookie, buf, len, (int )ack, 208U);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: RTW_Tx:tx_ch =%d, da =%02x:%02x:%02x:%02x:%02x:%02x\n",
           (int )tx_ch, (int )*((u8 *)(& hdr->da)), (int )*((u8 *)(& hdr->da) + 1UL),
           (int )*((u8 *)(& hdr->da) + 2UL), (int )*((u8 *)(& hdr->da) + 3UL), (int )*((u8 *)(& hdr->da) + 4UL),
           (int )*((u8 *)(& hdr->da) + 5UL));
  } else {
  }
  category = hdr->u.action.category;
  action = hdr->u.action.u.wme_action.action_code;
  if ((unsigned int )category == 4U) {
    if (GlobalDebugLevel23A > 3U) {
      tmp___2 = action_public_str23a((int )action);
      printk("\016RTL8723AU: RTW_Tx:%s\n", tmp___2);
    } else {
    }
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: RTW_Tx:category(%u), action(%u)\n", (int )category, (int )action);
  } else {
  }
  ldv_52311:
  dump_cnt = dump_cnt + 1U;
  tx_ret = _cfg80211_rtw_mgmt_tx(padapter, (int )tx_ch, buf, len);
  if (dump_cnt < dump_limit && tx_ret != 1) {
    goto ldv_52311;
  } else {
  }
  if (tx_ret != 1 || dump_cnt > 1U) {
    if (GlobalDebugLevel23A > 3U) {
      tmp___3 = jiffies_to_msecs((unsigned long )jiffies - start);
      printk("\016RTL8723AU: %s(%s): %s (%d/%d) in %d ms\n", "cfg80211_rtw_mgmt_tx",
             (char *)(& (padapter->pnetdev)->name), tx_ret == 1 ? (char *)"OK" : (char *)"FAIL",
             dump_cnt, dump_limit, tmp___3);
    } else {
    }
  } else {
  }
  return (ret);
}
}
static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                             u16 frame_type , bool reg )
{
  {
  if ((unsigned int )frame_type != 64U) {
    return;
  } else {
  }
  return;
}
}
static struct cfg80211_ops rtw_cfg80211_ops =
     {0, 0, 0, & cfg80211_rtw_add_virtual_intf, & cfg80211_rtw_del_virtual_intf, & cfg80211_rtw_change_iface,
    & cfg80211_rtw_add_key, & cfg80211_rtw_get_key, & cfg80211_rtw_del_key, & cfg80211_rtw_set_default_key,
    0, & cfg80211_rtw_start_ap, & cfg80211_rtw_change_beacon, & cfg80211_rtw_stop_ap,
    & cfg80211_rtw_add_station, & cfg80211_rtw_del_station, & cfg80211_rtw_change_station,
    & cfg80211_rtw_get_station, & cfg80211_rtw_dump_station, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & cfg80211_rtw_change_bss, 0, 0, 0, & cfg80211_rtw_scan, 0, 0, 0, 0, & cfg80211_rtw_connect,
    & cfg80211_rtw_disconnect, & cfg80211_rtw_join_ibss, & cfg80211_rtw_leave_ibss,
    0, & cfg80211_rtw_set_wiphy_params, & cfg80211_rtw_set_txpower, & cfg80211_rtw_get_txpower,
    0, 0, 0, 0, 0, 0, & cfg80211_rtw_set_pmksa, & cfg80211_rtw_del_pmksa, & cfg80211_rtw_flush_pmksa,
    0, 0, & cfg80211_rtw_mgmt_tx, 0, & cfg80211_rtw_set_power_mgmt, 0, 0, & cfg80211_rtw_mgmt_frame_register,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap , enum ieee80211_band band ,
                                       u8 rf_type )
{
  {
  ht_cap->ht_supported = 1;
  ht_cap->cap = 6242U;
  ht_cap->ampdu_factor = 3U;
  ht_cap->ampdu_density = 7U;
  ht_cap->mcs.tx_params = 1U;
  if ((unsigned int )rf_type == 3U) {
    ht_cap->mcs.rx_mask[0] = 255U;
    ht_cap->mcs.rx_mask[1] = 0U;
    ht_cap->mcs.rx_mask[4] = 1U;
    ht_cap->mcs.rx_highest = 150U;
  } else
  if ((unsigned int )rf_type == 0U || (unsigned int )rf_type == 2U) {
    ht_cap->mcs.rx_mask[0] = 255U;
    ht_cap->mcs.rx_mask[1] = 255U;
    ht_cap->mcs.rx_mask[4] = 1U;
    ht_cap->mcs.rx_highest = 300U;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, error rf_type =%d\n", "rtw_cfg80211_init_ht_capab",
           (int )rf_type);
  } else {
  }
  return;
}
}
void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter )
{
  u8 rf_type ;
  struct ieee80211_supported_band *bands ;
  struct wireless_dev *pwdev ;
  struct wiphy *wiphy ;
  {
  pwdev = padapter->rtw_wdev;
  wiphy = pwdev->wiphy;
  rf_type = rtl8723a_get_rf_type(padapter);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s:rf_type =%d\n", "rtw_cfg80211_init_wiphy", (int )rf_type);
  } else {
  }
  bands = wiphy->bands[0];
  if ((unsigned long )bands != (unsigned long )((struct ieee80211_supported_band *)0)) {
    rtw_cfg80211_init_ht_capab(& bands->ht_cap, 0, (int )rf_type);
  } else {
  }
  bands = wiphy->bands[1];
  if ((unsigned long )bands != (unsigned long )((struct ieee80211_supported_band *)0)) {
    rtw_cfg80211_init_ht_capab(& bands->ht_cap, 1, (int )rf_type);
  } else {
  }
  return;
}
}
static void rtw_cfg80211_preinit_wiphy(struct rtw_adapter *padapter , struct wiphy *wiphy )
{
  {
  wiphy->signal_type = 1;
  wiphy->max_scan_ssids = 9U;
  wiphy->max_scan_ie_len = 2304U;
  wiphy->max_num_pmkids = 4U;
  wiphy->max_remain_on_channel_duration = 65535U;
  wiphy->interface_modes = 78U;
  wiphy->mgmt_stypes = (struct ieee80211_txrx_stypes const *)(& rtw_cfg80211_default_mgmt_stypes);
  wiphy->software_iftypes = (u16 )((unsigned int )wiphy->software_iftypes | 64U);
  wiphy->cipher_suites = (u32 const *)(& rtw_cipher_suites);
  wiphy->n_cipher_suites = 4;
  wiphy->bands[0] = rtw_spt_band_alloc(0);
  wiphy->bands[1] = rtw_spt_band_alloc(1);
  wiphy->flags = wiphy->flags | 2097152U;
  wiphy->flags = wiphy->flags | 1179648U;
  if ((unsigned int )padapter->registrypriv.power_mgnt != 0U) {
    wiphy->flags = wiphy->flags | 16U;
  } else {
    wiphy->flags = wiphy->flags & 4294967279U;
  }
  return;
}
}
int rtw_wdev_alloc(struct rtw_adapter *padapter , struct device *dev )
{
  int ret ;
  struct wiphy *wiphy ;
  struct wireless_dev *wdev ;
  struct rtw_wdev_priv *pwdev_priv ;
  struct net_device *pnetdev ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  {
  ret = 0;
  pnetdev = padapter->pnetdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_wdev_alloc", padapter);
  } else {
  }
  wiphy = wiphy_new((struct cfg80211_ops const *)(& rtw_cfg80211_ops), 128);
  if ((unsigned long )wiphy == (unsigned long )((struct wiphy *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Couldn\'t allocate wiphy device\n");
    } else {
    }
    ret = -12;
    goto exit;
  } else {
  }
  tmp = kzalloc(984UL, 208U);
  wdev = (struct wireless_dev *)tmp;
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Couldn\'t allocate wireless device\n");
    } else {
    }
    ret = -12;
    goto free_wiphy;
  } else {
  }
  set_wiphy_dev(wiphy, dev);
  rtw_cfg80211_preinit_wiphy(padapter, wiphy);
  ret = wiphy_register(wiphy);
  if (ret < 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Couldn\'t register wiphy device\n");
    } else {
    }
    goto free_wdev;
  } else {
  }
  wdev->wiphy = wiphy;
  wdev->netdev = pnetdev;
  wdev->iftype = 6;
  padapter->rtw_wdev = wdev;
  pnetdev->ieee80211_ptr = wdev;
  tmp___0 = wdev_priv___1(wdev);
  pwdev_priv = (struct rtw_wdev_priv *)tmp___0;
  pwdev_priv->rtw_wdev = wdev;
  pwdev_priv->pmon_ndev = (struct net_device *)0;
  pwdev_priv->ifname_mon[0] = 0;
  pwdev_priv->padapter = padapter;
  pwdev_priv->scan_request = (struct cfg80211_scan_request *)0;
  spinlock_check(& pwdev_priv->scan_req_lock);
  __raw_spin_lock_init(& pwdev_priv->scan_req_lock.ldv_6347.rlock, "&(&pwdev_priv->scan_req_lock)->rlock",
                       & __key);
  pwdev_priv->p2p_enabled = 0U;
  if ((unsigned int )padapter->registrypriv.power_mgnt != 0U) {
    pwdev_priv->power_mgmt = 1;
  } else {
    pwdev_priv->power_mgmt = 0;
  }
  return (ret);
  free_wdev:
  kfree((void const *)wdev);
  free_wiphy:
  wiphy_free(wiphy);
  exit: ;
  return (ret);
}
}
void rtw_wdev_free(struct wireless_dev *wdev )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(wdev =%p)\n", "rtw_wdev_free", wdev);
  } else {
  }
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
    return;
  } else {
  }
  kfree((void const *)(wdev->wiphy)->bands[0]);
  kfree((void const *)(wdev->wiphy)->bands[1]);
  wiphy_free(wdev->wiphy);
  kfree((void const *)wdev);
  return;
}
}
void rtw_wdev_unregister(struct wireless_dev *wdev )
{
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(wdev =%p)\n", "rtw_wdev_unregister", wdev);
  } else {
  }
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
    return;
  } else {
  }
  tmp = wdev_priv___1(wdev);
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
  rtw_cfg80211_indicate_scan_done(pwdev_priv, 1);
  if ((unsigned long )pwdev_priv->pmon_ndev != (unsigned long )((struct net_device *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s, unregister monitor interface\n", "rtw_wdev_unregister");
    } else {
    }
    ldv_unregister_netdev_2080(pwdev_priv->pmon_ndev);
  } else {
  }
  wiphy_unregister(wdev->wiphy);
  return;
}
}
extern int ldv_release_14(void) ;
void (*ldvarg32)(void * , struct key_params * ) ;
extern int ldv_ndo_init_15(void) ;
extern int ldv_bind_14(void) ;
int ldv_retval_5 ;
int ldv_retval_4 ;
int ldv_retval_6 ;
extern int ldv_ndo_uninit_15(void) ;
void ldv_net_device_ops_15(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(3264UL);
  rtw_cfg80211_monitor_if_ops_group1 = (struct net_device *)tmp;
  return;
}
}
void ldv_initialize_cfg80211_ops_14(void)
{
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  {
  tmp = ldv_zalloc(1760UL);
  rtw_cfg80211_ops_group1 = (struct wiphy *)tmp;
  tmp___0 = ldv_zalloc(12UL);
  rtw_cfg80211_ops_group5 = (struct vif_params *)tmp___0;
  tmp___1 = ldv_zalloc(120UL);
  rtw_cfg80211_ops_group2 = (struct station_parameters *)tmp___1;
  tmp___2 = ldv_zalloc(16UL);
  rtw_cfg80211_ops_group4 = (struct cfg80211_pmksa *)tmp___2;
  tmp___3 = ldv_zalloc(984UL);
  rtw_cfg80211_ops_group0 = (struct wireless_dev *)tmp___3;
  tmp___4 = ldv_zalloc(3264UL);
  rtw_cfg80211_ops_group6 = (struct net_device *)tmp___4;
  tmp___5 = ldv_zalloc(144UL);
  rtw_cfg80211_ops_group3 = (struct station_info *)tmp___5;
  return;
}
}
void ldv_main_exported_15(void)
{
  void *ldvarg2 ;
  void *tmp ;
  struct sk_buff *ldvarg3 ;
  void *tmp___0 ;
  int tmp___1 ;
  {
  tmp = ldv_zalloc(1UL);
  ldvarg2 = tmp;
  tmp___0 = ldv_zalloc(232UL);
  ldvarg3 = (struct sk_buff *)tmp___0;
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_15 == 3) {
    rtw_cfg80211_monitor_if_close(rtw_cfg80211_monitor_if_ops_group1);
    ldv_state_variable_15 = 2;
  } else {
  }
  goto ldv_52389;
  case 1: ;
  if (ldv_state_variable_15 == 2) {
    ldv_retval_5 = rtw_cfg80211_monitor_if_open(rtw_cfg80211_monitor_if_ops_group1);
    if (ldv_retval_5 == 0) {
      ldv_state_variable_15 = 3;
    } else {
    }
  } else {
  }
  goto ldv_52389;
  case 2: ;
  if (ldv_state_variable_15 == 3) {
    rtw_cfg80211_monitor_if_xmit_entry(ldvarg3, rtw_cfg80211_monitor_if_ops_group1);
    ldv_state_variable_15 = 3;
  } else {
  }
  goto ldv_52389;
  case 3: ;
  if (ldv_state_variable_15 == 1) {
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg2);
    ldv_state_variable_15 = 1;
  } else {
  }
  if (ldv_state_variable_15 == 3) {
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg2);
    ldv_state_variable_15 = 3;
  } else {
  }
  if (ldv_state_variable_15 == 2) {
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg2);
    ldv_state_variable_15 = 2;
  } else {
  }
  goto ldv_52389;
  case 4: ;
  if (ldv_state_variable_15 == 1) {
    ldv_retval_4 = ldv_ndo_init_15();
    if (ldv_retval_4 == 0) {
      ldv_state_variable_15 = 2;
      usb_counter = usb_counter + 1;
      ref_cnt = ref_cnt + 1;
    } else {
    }
  } else {
  }
  goto ldv_52389;
  case 5: ;
  if (ldv_state_variable_15 == 2) {
    ldv_ndo_uninit_15();
    ldv_state_variable_15 = 1;
    usb_counter = usb_counter - 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_52389;
  default:
  ldv_stop();
  }
  ldv_52389: ;
  return;
}
}
void ldv_main_exported_14(void)
{
  u16 ldvarg19 ;
  u16 tmp ;
  bool ldvarg22 ;
  u32 *ldvarg25 ;
  void *tmp___0 ;
  struct cfg80211_ap_settings *ldvarg17 ;
  void *tmp___1 ;
  int ldvarg21 ;
  int tmp___2 ;
  bool ldvarg30 ;
  int ldvarg15 ;
  int tmp___3 ;
  char *ldvarg27 ;
  void *tmp___4 ;
  enum nl80211_iftype ldvarg26 ;
  int ldvarg45 ;
  int tmp___5 ;
  u32 ldvarg9 ;
  u32 tmp___6 ;
  enum nl80211_iftype ldvarg40 ;
  bool ldvarg36 ;
  u8 *ldvarg10 ;
  void *tmp___7 ;
  u8 *ldvarg13 ;
  void *tmp___8 ;
  struct cfg80211_mgmt_tx_params *ldvarg8 ;
  void *tmp___9 ;
  struct key_params *ldvarg41 ;
  void *tmp___10 ;
  u8 ldvarg31 ;
  u8 tmp___11 ;
  u8 *ldvarg20 ;
  void *tmp___12 ;
  u32 *ldvarg39 ;
  void *tmp___13 ;
  u8 *ldvarg28 ;
  void *tmp___14 ;
  bool ldvarg34 ;
  struct cfg80211_connect_params *ldvarg14 ;
  void *tmp___15 ;
  struct bss_parameters *ldvarg4 ;
  void *tmp___16 ;
  enum nl80211_tx_power_setting ldvarg16 ;
  u16 ldvarg6 ;
  u16 tmp___17 ;
  u8 *ldvarg33 ;
  void *tmp___18 ;
  struct cfg80211_ibss_params *ldvarg5 ;
  void *tmp___19 ;
  struct cfg80211_beacon_data *ldvarg38 ;
  void *tmp___20 ;
  u8 ldvarg35 ;
  u8 tmp___21 ;
  u8 *ldvarg24 ;
  void *tmp___22 ;
  u8 *ldvarg44 ;
  void *tmp___23 ;
  void *ldvarg29 ;
  void *tmp___24 ;
  struct cfg80211_scan_request *ldvarg37 ;
  void *tmp___25 ;
  bool ldvarg46 ;
  int *ldvarg12 ;
  void *tmp___26 ;
  bool ldvarg42 ;
  u8 ldvarg43 ;
  u8 tmp___27 ;
  u8 ldvarg23 ;
  u8 tmp___28 ;
  u64 *ldvarg7 ;
  void *tmp___29 ;
  u8 *ldvarg11 ;
  void *tmp___30 ;
  bool ldvarg18 ;
  int tmp___31 ;
  {
  tmp = __VERIFIER_nondet_u16();
  ldvarg19 = tmp;
  tmp___0 = ldv_zalloc(4UL);
  ldvarg25 = (u32 *)tmp___0;
  tmp___1 = ldv_zalloc(224UL);
  ldvarg17 = (struct cfg80211_ap_settings *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  ldvarg21 = tmp___2;
  tmp___3 = __VERIFIER_nondet_int();
  ldvarg15 = tmp___3;
  tmp___4 = ldv_zalloc(1UL);
  ldvarg27 = (char *)tmp___4;
  tmp___5 = __VERIFIER_nondet_int();
  ldvarg45 = tmp___5;
  tmp___6 = __VERIFIER_nondet_u32();
  ldvarg9 = tmp___6;
  tmp___7 = ldv_zalloc(1UL);
  ldvarg10 = (u8 *)tmp___7;
  tmp___8 = ldv_zalloc(1UL);
  ldvarg13 = (u8 *)tmp___8;
  tmp___9 = ldv_zalloc(48UL);
  ldvarg8 = (struct cfg80211_mgmt_tx_params *)tmp___9;
  tmp___10 = ldv_zalloc(32UL);
  ldvarg41 = (struct key_params *)tmp___10;
  tmp___11 = __VERIFIER_nondet_u8();
  ldvarg31 = tmp___11;
  tmp___12 = ldv_zalloc(1UL);
  ldvarg20 = (u8 *)tmp___12;
  tmp___13 = ldv_zalloc(4UL);
  ldvarg39 = (u32 *)tmp___13;
  tmp___14 = ldv_zalloc(1UL);
  ldvarg28 = (u8 *)tmp___14;
  tmp___15 = ldv_zalloc(232UL);
  ldvarg14 = (struct cfg80211_connect_params *)tmp___15;
  tmp___16 = ldv_zalloc(40UL);
  ldvarg4 = (struct bss_parameters *)tmp___16;
  tmp___17 = __VERIFIER_nondet_u16();
  ldvarg6 = tmp___17;
  tmp___18 = ldv_zalloc(1UL);
  ldvarg33 = (u8 *)tmp___18;
  tmp___19 = ldv_zalloc(128UL);
  ldvarg5 = (struct cfg80211_ibss_params *)tmp___19;
  tmp___20 = ldv_zalloc(96UL);
  ldvarg38 = (struct cfg80211_beacon_data *)tmp___20;
  tmp___21 = __VERIFIER_nondet_u8();
  ldvarg35 = tmp___21;
  tmp___22 = ldv_zalloc(1UL);
  ldvarg24 = (u8 *)tmp___22;
  tmp___23 = ldv_zalloc(1UL);
  ldvarg44 = (u8 *)tmp___23;
  tmp___24 = ldv_zalloc(1UL);
  ldvarg29 = tmp___24;
  tmp___25 = ldv_zalloc(88UL);
  ldvarg37 = (struct cfg80211_scan_request *)tmp___25;
  tmp___26 = ldv_zalloc(4UL);
  ldvarg12 = (int *)tmp___26;
  tmp___27 = __VERIFIER_nondet_u8();
  ldvarg43 = tmp___27;
  tmp___28 = __VERIFIER_nondet_u8();
  ldvarg23 = tmp___28;
  tmp___29 = ldv_zalloc(8UL);
  ldvarg7 = (u64 *)tmp___29;
  tmp___30 = ldv_zalloc(1UL);
  ldvarg11 = (u8 *)tmp___30;
  memset((void *)(& ldvarg22), 0, 1UL);
  memset((void *)(& ldvarg30), 0, 1UL);
  memset((void *)(& ldvarg26), 0, 4UL);
  memset((void *)(& ldvarg40), 0, 4UL);
  memset((void *)(& ldvarg36), 0, 1UL);
  memset((void *)(& ldvarg34), 0, 1UL);
  memset((void *)(& ldvarg16), 0, 4UL);
  memset((void *)(& ldvarg46), 0, 1UL);
  memset((void *)(& ldvarg42), 0, 1UL);
  memset((void *)(& ldvarg18), 0, 1UL);
  tmp___31 = __VERIFIER_nondet_int();
  switch (tmp___31) {
  case 0: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (int )ldvarg46, ldvarg45);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (int )ldvarg46, ldvarg45);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (int )ldvarg46, ldvarg45);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 1: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg43,
                         (int )ldvarg42, (u8 const *)ldvarg44, ldvarg41);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg43,
                         (int )ldvarg42, (u8 const *)ldvarg44, ldvarg41);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg43,
                         (int )ldvarg42, (u8 const *)ldvarg44, ldvarg41);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 2: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg40,
                              ldvarg39, rtw_cfg80211_ops_group5);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg40,
                              ldvarg39, rtw_cfg80211_ops_group5);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg40,
                              ldvarg39, rtw_cfg80211_ops_group5);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 3: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg38);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg38);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg38);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 4: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_scan(rtw_cfg80211_ops_group1, ldvarg37);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_scan(rtw_cfg80211_ops_group1, ldvarg37);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_scan(rtw_cfg80211_ops_group1, ldvarg37);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 5: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                 (int )ldvarg35, (int )ldvarg34, (int )ldvarg36);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                 (int )ldvarg35, (int )ldvarg34, (int )ldvarg36);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                 (int )ldvarg35, (int )ldvarg34, (int )ldvarg36);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 6: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg31,
                         (int )ldvarg30, (u8 const *)ldvarg33, ldvarg29, ldvarg32);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg31,
                         (int )ldvarg30, (u8 const *)ldvarg33, ldvarg29, ldvarg32);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg31,
                         (int )ldvarg30, (u8 const *)ldvarg33, ldvarg29, ldvarg32);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 7: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 8: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 9: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const *)ldvarg28,
                             rtw_cfg80211_ops_group2);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const *)ldvarg28,
                             rtw_cfg80211_ops_group2);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const *)ldvarg28,
                             rtw_cfg80211_ops_group2);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 10: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group1, (char const *)ldvarg27,
                                  ldvarg26, ldvarg25, rtw_cfg80211_ops_group5);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group1, (char const *)ldvarg27,
                                  ldvarg26, ldvarg25, rtw_cfg80211_ops_group5);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group1, (char const *)ldvarg27,
                                  ldvarg26, ldvarg25, rtw_cfg80211_ops_group5);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 11: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg23,
                         (int )ldvarg22, (u8 const *)ldvarg24);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg23,
                         (int )ldvarg22, (u8 const *)ldvarg24);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg23,
                         (int )ldvarg22, (u8 const *)ldvarg24);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 12: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg21,
                              ldvarg20, rtw_cfg80211_ops_group3);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg21,
                              ldvarg20, rtw_cfg80211_ops_group3);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg21,
                              ldvarg20, rtw_cfg80211_ops_group3);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 13: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0,
                                     (int )ldvarg19, (int )ldvarg18);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0,
                                     (int )ldvarg19, (int )ldvarg18);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0,
                                     (int )ldvarg19, (int )ldvarg18);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 14: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg17);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg17);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg17);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 15: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg16,
                             ldvarg15);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg16,
                             ldvarg15);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg16,
                             ldvarg15);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 16: ;
  if (ldv_state_variable_14 == 2) {
    ldv_retval_6 = cfg80211_rtw_connect(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                        ldvarg14);
    if (ldv_retval_6 == 0) {
      ldv_state_variable_14 = 3;
    } else {
    }
  } else {
  }
  goto ldv_52442;
  case 17: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 18: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const *)ldvarg13);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const *)ldvarg13);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const *)ldvarg13);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 19: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg12);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg12);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg12);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 20: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 21: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const *)ldvarg11,
                             rtw_cfg80211_ops_group3);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const *)ldvarg11,
                             rtw_cfg80211_ops_group3);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const *)ldvarg11,
                             rtw_cfg80211_ops_group3);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 22: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (u8 const *)ldvarg10, rtw_cfg80211_ops_group2);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (u8 const *)ldvarg10, rtw_cfg80211_ops_group2);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (u8 const *)ldvarg10, rtw_cfg80211_ops_group2);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 23: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group1, ldvarg9);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group1, ldvarg9);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group1, ldvarg9);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 24: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg8,
                         ldvarg7);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg8,
                         ldvarg7);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg8,
                         ldvarg7);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 25: ;
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_disconnect(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg6);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 26: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 27: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg5);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg5);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg5);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 28: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg4);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg4);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg4);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 29: ;
  if (ldv_state_variable_14 == 1) {
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
    ldv_state_variable_14 = 1;
  } else {
  }
  if (ldv_state_variable_14 == 3) {
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
    ldv_state_variable_14 = 3;
  } else {
  }
  if (ldv_state_variable_14 == 2) {
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
    ldv_state_variable_14 = 2;
  } else {
  }
  goto ldv_52442;
  case 30: ;
  if (ldv_state_variable_14 == 2) {
    ldv_release_14();
    ldv_state_variable_14 = 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_52442;
  case 31: ;
  if (ldv_state_variable_14 == 1) {
    ldv_bind_14();
    ldv_state_variable_14 = 2;
    ref_cnt = ref_cnt + 1;
  } else {
  }
  goto ldv_52442;
  default:
  ldv_stop();
  }
  ldv_52442: ;
  return;
}
}
void *ldv_kmem_cache_alloc_2062(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2068(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2070(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2072(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2073(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2074(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2075(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2076(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2077(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2078(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void ldv_free_netdev_2079(struct net_device *dev )
{
  {
  free_netdev(dev);
  ldv_state_variable_15 = 0;
  return;
}
}
void ldv_unregister_netdev_2080(struct net_device *dev )
{
  {
  unregister_netdev(dev);
  ldv_state_variable_15 = 0;
  return;
}
}
void *ldv_kmem_cache_alloc_2108(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2116(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2124(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2118(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2114(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2122(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2123(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2119(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2120(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2121(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
extern void netif_carrier_off(struct net_device * ) ;
static struct rt_pmkid_list backupPMKIDList[16U] ;
void rtw_reset_securitypriv23a(struct rtw_adapter *adapter )
{
  u8 backupPMKIDIndex ;
  u8 backupTKIPCountermeasure ;
  unsigned long backupTKIPcountermeasure_time ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct security_priv *psec_priv ;
  {
  backupPMKIDIndex = 0U;
  backupTKIPCountermeasure = 0U;
  backupTKIPcountermeasure_time = 0UL;
  if (adapter->securitypriv.dot11AuthAlgrthm == 2U) {
    __len = 1152UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& backupPMKIDList), (void const *)(& adapter->securitypriv.PMKIDList),
                       __len);
    } else {
      __ret = memcpy((void *)(& backupPMKIDList), (void const *)(& adapter->securitypriv.PMKIDList),
                               __len);
    }
    backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
    backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
    backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;
    memset((void *)(& adapter->securitypriv), 0, 4776UL);
    __len___0 = 1152UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& adapter->securitypriv.PMKIDList), (void const *)(& backupPMKIDList),
                           __len___0);
    } else {
      __ret___0 = memcpy((void *)(& adapter->securitypriv.PMKIDList), (void const *)(& backupPMKIDList),
                                   __len___0);
    }
    adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
    adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
    adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;
    adapter->securitypriv.ndisauthtype = 0U;
    adapter->securitypriv.ndisencryptstatus = 1U;
  } else {
    psec_priv = & adapter->securitypriv;
    psec_priv->dot11AuthAlgrthm = 0U;
    psec_priv->dot11PrivacyAlgrthm = 0U;
    psec_priv->dot11PrivacyKeyIndex = 0U;
    psec_priv->dot118021XGrpPrivacy = 0U;
    psec_priv->dot118021XGrpKeyid = 1U;
    psec_priv->ndisauthtype = 0U;
    psec_priv->ndisencryptstatus = 1U;
  }
  return;
}
}
void rtw_os_indicate_disconnect23a(struct rtw_adapter *adapter )
{
  {
  netif_carrier_off(adapter->pnetdev);
  rtw_cfg80211_indicate_disconnect(adapter);
  rtw_reset_securitypriv23a(adapter);
  return;
}
}
void *ldv_kmem_cache_alloc_2108(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2114(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2116(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2118(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2119(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2120(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2121(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2122(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2123(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2124(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
__inline static void clear_bit(long nr , unsigned long volatile *addr )
{
  {
  __asm__ volatile (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile *)addr)): "Ir" (nr));
  return;
}
}
extern int snprintf(char * , size_t , char const * , ...) ;
int ldv_mod_timer_2167(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_2176(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_2177(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_2178(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_2179(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_2168(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2169(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2170(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2171(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2172(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2173(struct timer_list *ldv_func_arg1 ) ;
void *ldv_kmem_cache_alloc_2150(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct net_device *rtw_netdev_ops_group1 ;
int ldv_state_variable_13 ;
void ldv_net_device_ops_13(void) ;
struct sk_buff *ldv_skb_clone_2158(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2166(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2160(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2156(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2164(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2165(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
__inline static unsigned char *skb_network_header(struct sk_buff const *skb )
{
  {
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2161(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2162(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2163(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
extern int dev_alloc_name(struct net_device * , char const * ) ;
void ldv_free_netdev_2175(struct net_device *dev ) ;
void ldv_free_netdev_2180(struct net_device *dev ) ;
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue )
{
  {
  clear_bit(0L, (unsigned long volatile *)(& dev_queue->state));
  return;
}
}
__inline static void netif_tx_start_all_queues(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_40936;
  ldv_40935:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_start_queue(txq);
  i = i + 1U;
  ldv_40936: ;
  if (dev->num_tx_queues > i) {
    goto ldv_40935;
  } else {
  }
  return;
}
}
__inline static void netif_tx_wake_all_queues___0(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_40950;
  ldv_40949:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_wake_queue(txq);
  i = i + 1U;
  ldv_40950: ;
  if (dev->num_tx_queues > i) {
    goto ldv_40949;
  } else {
  }
  return;
}
}
__inline static void netif_tx_stop_all_queues___0(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_40966;
  ldv_40965:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_stop_queue(txq);
  i = i + 1U;
  ldv_40966: ;
  if (dev->num_tx_queues > i) {
    goto ldv_40965;
  } else {
  }
  return;
}
}
extern int register_netdev(struct net_device * ) ;
int ldv_register_netdev_2174(struct net_device *dev ) ;
__inline static struct iphdr *ip_hdr(struct sk_buff const *skb )
{
  unsigned char *tmp ;
  {
  tmp = skb_network_header(skb);
  return ((struct iphdr *)tmp);
}
}
int netdev_open23a(struct net_device *pnetdev ) ;
int pm_netdev_open23a(struct net_device *pnetdev , u8 bnormal ) ;
int rtw_init_drv_sw23a(struct rtw_adapter *padapter ) ;
int rtw_free_drv_sw23a(struct rtw_adapter *padapter ) ;
int rtw_reset_drv_sw23a(struct rtw_adapter *padapter ) ;
int rtw_init_netdev23a_name23a(struct net_device *pnetdev , char const *ifname___0 ) ;
struct net_device *rtw_init_netdev23a(struct rtw_adapter *old_padapter ) ;
u16 rtw_recv_select_queue23a(struct sk_buff *skb ) ;
void rtw_ips_dev_unload23a(struct rtw_adapter *padapter ) ;
int rtw_drv_register_netdev(struct rtw_adapter *if1 ) ;
void rtl8723a_usb_intf_stop(struct rtw_adapter *padapter ) ;
static int rtw_chip_version = 0;
static int rtw_rfintfs = 2;
static int rtw_debug = 1;
static int rtw_channel = 1;
static int rtw_wireless_mode = 11;
static int rtw_vrtl_carrier_sense = 2;
static int rtw_vcs_type = 1;
static int rtw_rts_thresh = 2347;
static int rtw_frag_thresh = 2346;
static int rtw_preamble = 1;
static int rtw_scan_mode = 1;
static int rtw_adhoc_tx_pwr = 1;
static int rtw_soft_ap ;
static int rtw_power_mgnt = 1;
static int rtw_ips_mode = 1;
static int rtw_smart_ps = 2;
static int rtw_long_retry_lmt = 7;
static int rtw_short_retry_lmt = 7;
static int rtw_busy_thresh = 40;
static int rtw_ack_policy = 0;
static int rtw_acm_method ;
static int rtw_wmm_enable = 1;
static int rtw_uapsd_enable ;
static int rtw_ht_enable = 1;
static int rtw_cbw40_enable = 3;
static int rtw_ampdu_enable = 1;
static int rtw_rx_stbc = 1;
static int rtw_ampdu_amsdu ;
static int rtw_lowrate_two_xmit = 1;
static int rtw_rf_config = 5;
static int rtw_low_power ;
static int rtw_wifi_spec ;
static int rtw_channel_plan = 66;
static int rtw_btcoex_enable = 1;
static int rtw_bt_iso = 2;
static int rtw_bt_sco = 3;
static int rtw_bt_ampdu = 1;
static int rtw_AcceptAddbaReq = 1;
static int rtw_antdiv_cfg = 2;
static int rtw_antdiv_type ;
static int rtw_hwpdn_mode = 2;
static int rtw_hwpwrp_detect ;
static int rtw_hw_wps_pbc = 1;
static int rtw_80211d ;
static int rtw_regulatory_id = 255;
static char *ifname = (char *)"wlan%d";
static char *if2name = (char *)"wlan%d";
static uint rtw_max_roaming_times = 2U;
static uint rtw_notch_filter ;
static int netdev_close(struct net_device *pnetdev ) ;
static int loadparam(struct rtw_adapter *padapter , struct net_device *pnetdev )
{
  struct registry_priv *registry_par ;
  int status ;
  size_t __len ;
  void *__ret ;
  {
  registry_par = & padapter->registrypriv;
  status = 1;
  GlobalDebugLevel23A = (u32 )rtw_debug;
  registry_par->chip_version = (unsigned char )rtw_chip_version;
  registry_par->rfintfs = (unsigned char )rtw_rfintfs;
  __len = 3UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& registry_par->ssid.ssid), (void const *)"ANY", __len);
  } else {
    __ret = memcpy((void *)(& registry_par->ssid.ssid), (void const *)"ANY",
                             __len);
  }
  registry_par->ssid.ssid_len = 3U;
  registry_par->channel = (unsigned char )rtw_channel;
  registry_par->wireless_mode = (unsigned char )rtw_wireless_mode;
  registry_par->vrtl_carrier_sense = (unsigned char )rtw_vrtl_carrier_sense;
  registry_par->vcs_type = (unsigned char )rtw_vcs_type;
  registry_par->rts_thresh = (unsigned short )rtw_rts_thresh;
  registry_par->frag_thresh = (unsigned short )rtw_frag_thresh;
  registry_par->preamble = (unsigned char )rtw_preamble;
  registry_par->scan_mode = (unsigned char )rtw_scan_mode;
  registry_par->adhoc_tx_pwr = (unsigned char )rtw_adhoc_tx_pwr;
  registry_par->soft_ap = (unsigned char )rtw_soft_ap;
  registry_par->smart_ps = (unsigned char )rtw_smart_ps;
  registry_par->power_mgnt = (unsigned char )rtw_power_mgnt;
  registry_par->ips_mode = (unsigned char )rtw_ips_mode;
  registry_par->long_retry_lmt = (unsigned char )rtw_long_retry_lmt;
  registry_par->short_retry_lmt = (unsigned char )rtw_short_retry_lmt;
  registry_par->busy_thresh = (unsigned short )rtw_busy_thresh;
  registry_par->ack_policy = (unsigned char )rtw_ack_policy;
  registry_par->acm_method = (unsigned char )rtw_acm_method;
  registry_par->wmm_enable = (unsigned char )rtw_wmm_enable;
  registry_par->uapsd_enable = (unsigned char )rtw_uapsd_enable;
  registry_par->ht_enable = (unsigned char )rtw_ht_enable;
  registry_par->cbw40_enable = (unsigned char )rtw_cbw40_enable;
  registry_par->ampdu_enable = (unsigned char )rtw_ampdu_enable;
  registry_par->rx_stbc = (unsigned char )rtw_rx_stbc;
  registry_par->ampdu_amsdu = (unsigned char )rtw_ampdu_amsdu;
  registry_par->lowrate_two_xmit = (unsigned char )rtw_lowrate_two_xmit;
  registry_par->rf_config = (unsigned char )rtw_rf_config;
  registry_par->low_power = (unsigned char )rtw_low_power;
  registry_par->wifi_spec = (unsigned char )rtw_wifi_spec;
  registry_par->channel_plan = (unsigned char )rtw_channel_plan;
  registry_par->btcoex = (unsigned char )rtw_btcoex_enable;
  registry_par->bt_iso = (unsigned char )rtw_bt_iso;
  registry_par->bt_sco = (unsigned char )rtw_bt_sco;
  registry_par->bt_ampdu = (unsigned char )rtw_bt_ampdu;
  registry_par->bAcceptAddbaReq = (unsigned int )((unsigned char )rtw_AcceptAddbaReq) != 0U;
  registry_par->antdiv_cfg = (unsigned char )rtw_antdiv_cfg;
  registry_par->antdiv_type = (unsigned char )rtw_antdiv_type;
  registry_par->hwpdn_mode = (unsigned char )rtw_hwpdn_mode;
  registry_par->hwpwrp_detect = (unsigned char )rtw_hwpwrp_detect;
  registry_par->hw_wps_pbc = (unsigned char )rtw_hw_wps_pbc;
  registry_par->max_roaming_times = (unsigned char )rtw_max_roaming_times;
  registry_par->enable80211d = (unsigned char )rtw_80211d;
  snprintf((char *)(& registry_par->ifname), 16UL, "%s", ifname);
  snprintf((char *)(& registry_par->if2name), 16UL, "%s", if2name);
  registry_par->notch_filter = (unsigned char )rtw_notch_filter;
  registry_par->regulatory_tid = (unsigned char )rtw_regulatory_id;
  return (status);
}
}
static int rtw_net_set_mac_address(struct net_device *pnetdev , void *p )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct sockaddr *addr ;
  {
  tmp = netdev_priv((struct net_device const *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  addr = (struct sockaddr *)p;
  if (padapter->bup == 0) {
    ether_addr_copy((u8 *)(& padapter->eeprompriv.mac_addr), (u8 const *)(& addr->sa_data));
  } else {
  }
  return (0);
}
}
static struct net_device_stats *rtw_net_get_stats(struct net_device *pnetdev )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct xmit_priv *pxmitpriv ;
  struct recv_priv *precvpriv ;
  {
  tmp = netdev_priv((struct net_device const *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  pxmitpriv = & padapter->xmitpriv;
  precvpriv = & padapter->recvpriv;
  padapter->stats.tx_packets = (unsigned long )pxmitpriv->tx_pkts;
  padapter->stats.rx_packets = (unsigned long )precvpriv->rx_pkts;
  padapter->stats.tx_dropped = (unsigned long )pxmitpriv->tx_drop;
  padapter->stats.rx_dropped = (unsigned long )precvpriv->rx_drop;
  padapter->stats.tx_bytes = (unsigned long )pxmitpriv->tx_bytes;
  padapter->stats.rx_bytes = (unsigned long )precvpriv->rx_bytes;
  return (& padapter->stats);
}
}
static u16 const rtw_1d_to_queue[8U] =
  { 2U, 3U, 3U, 2U,
        1U, 1U, 0U, 0U};
static u32 rtw_classify8021d(struct sk_buff *skb )
{
  u32 dscp ;
  struct iphdr *tmp ;
  {
  if (skb->priority > 255U && skb->priority <= 263U) {
    return (skb->priority - 256U);
  } else {
  }
  switch ((int )skb->protocol) {
  case 8:
  tmp = ip_hdr((struct sk_buff const *)skb);
  dscp = (u32 )tmp->tos & 252U;
  goto ldv_54845;
  default: ;
  return (0U);
  }
  ldv_54845: ;
  return (dscp >> 5);
}
}
static u16 rtw_select_queue(struct net_device *dev , struct sk_buff *skb , void *accel_priv ,
                            u16 (*fallback)(struct net_device * , struct sk_buff * ) )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  u8 tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)dev);
  padapter = (struct rtw_adapter *)tmp;
  pmlmepriv = & padapter->mlmepriv;
  skb->priority = rtw_classify8021d(skb);
  if ((unsigned int )pmlmepriv->acm_mask != 0U) {
    tmp___0 = qos_acm23a((int )pmlmepriv->acm_mask, (int )((u8 )skb->priority));
    skb->priority = (__u32 )tmp___0;
  } else {
  }
  return ((u16 )rtw_1d_to_queue[skb->priority]);
}
}
u16 rtw_recv_select_queue23a(struct sk_buff *skb )
{
  struct iphdr *piphdr ;
  struct ethhdr *eth ;
  unsigned int dscp ;
  u16 eth_type ;
  u16 tmp ;
  u32 priority ;
  u8 *pdata ;
  {
  eth = (struct ethhdr *)skb->data;
  tmp = get_unaligned_be16((void const *)(& eth->h_proto));
  eth_type = tmp;
  pdata = skb->data;
  switch ((int )eth_type) {
  case 2048:
  piphdr = (struct iphdr *)pdata + 14U;
  dscp = (unsigned int )piphdr->tos & 252U;
  priority = dscp >> 5;
  goto ldv_54865;
  default:
  priority = 0U;
  }
  ldv_54865: ;
  return ((u16 )rtw_1d_to_queue[priority]);
}
}
static struct net_device_ops const rtw_netdev_ops =
     {0, 0, & netdev_open23a, & netdev_close, (netdev_tx_t (*)(struct sk_buff * , struct net_device * ))(& rtw_xmit23a_entry23a),
    & rtw_select_queue, 0, 0, & rtw_net_set_mac_address, 0, 0, 0, 0, 0, 0, 0, & rtw_net_get_stats,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int rtw_init_netdev23a_name23a(struct net_device *pnetdev , char const *ifname___0 )
{
  int tmp ;
  {
  tmp = dev_alloc_name(pnetdev, ifname___0);
  if (tmp < 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
      printk("\016dev_alloc_name, fail!\n");
    } else {
    }
  } else {
  }
  netif_carrier_off(pnetdev);
  return (0);
}
}
static struct device_type const wlan_type = {"wlan", 0, 0, 0, 0, 0};
struct net_device *rtw_init_netdev23a(struct rtw_adapter *old_padapter )
{
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  void *tmp ;
  {
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016+init_net_dev\n");
  } else {
  }
  pnetdev = alloc_etherdev_mqs(18136, 4U, 4U);
  if ((unsigned long )pnetdev == (unsigned long )((struct net_device *)0)) {
    return ((struct net_device *)0);
  } else {
  }
  pnetdev->dev.type = & wlan_type;
  tmp = netdev_priv((struct net_device const *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  padapter->pnetdev = pnetdev;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: register rtw_netdev_ops to netdev_ops\n");
  } else {
  }
  pnetdev->netdev_ops = & rtw_netdev_ops;
  pnetdev->watchdog_timeo = 750;
  loadparam(padapter, pnetdev);
  return (pnetdev);
}
}
static int rtw_init_default_value(struct rtw_adapter *padapter )
{
  struct registry_priv *pregistrypriv ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  int ret ;
  {
  pregistrypriv = & padapter->registrypriv;
  pxmitpriv = & padapter->xmitpriv;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  ret = 1;
  pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
  pxmitpriv->vcs = pregistrypriv->vcs_type;
  pxmitpriv->vcs_type = pregistrypriv->vcs_type;
  pxmitpriv->frag_len = (uint )pregistrypriv->frag_thresh;
  pmlmepriv->scan_interval = 30U;
  pmlmepriv->scan_mode = 1;
  pmlmepriv->htpriv.ampdu_enable = 0U;
  psecuritypriv->binstallGrpkey = 0U;
  psecuritypriv->dot11AuthAlgrthm = 0U;
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
  psecuritypriv->dot11PrivacyKeyIndex = 0U;
  psecuritypriv->dot118021XGrpPrivacy = 0U;
  psecuritypriv->dot118021XGrpKeyid = 1U;
  psecuritypriv->ndisauthtype = 0U;
  psecuritypriv->ndisencryptstatus = 1U;
  rtw_init_registrypriv_dev_network23a(padapter);
  rtw_update_registrypriv_dev_network23a(padapter);
  rtl8723a_init_default_value(padapter);
  padapter->bReadPortCancel = 0U;
  padapter->bWritePortCancel = 0U;
  padapter->bNotifyChannelChange = 0U;
  return (ret);
}
}
int rtw_reset_drv_sw23a(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrctrlpriv ;
  unsigned long tmp ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pwrctrlpriv = & padapter->pwrctrlpriv;
  rtl8723a_init_default_value(padapter);
  padapter->bReadPortCancel = 0U;
  padapter->bWritePortCancel = 0U;
  pmlmepriv->scan_interval = 30U;
  padapter->xmitpriv.tx_pkts = 0ULL;
  padapter->recvpriv.rx_pkts = 0ULL;
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
  _clr_fwstate_(pmlmepriv, 2176);
  rtw_sreset_reset_value(padapter);
  pwrctrlpriv->pwr_state_check_cnts = 0U;
  padapter->mlmeextpriv.sitesurvey_res.state = 0;
  tmp = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
  ldv_mod_timer_2167(& padapter->recvpriv.signal_stat_timer, tmp + (unsigned long )jiffies);
  return (1);
}
}
int rtw_init_drv_sw23a(struct rtw_adapter *padapter )
{
  int ret8 ;
  int tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  {
  ret8 = 1;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016+rtw_init_drv_sw23a\n");
  } else {
  }
  tmp = rtw_init_cmd_priv23a(& padapter->cmdpriv);
  if (tmp == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
      printk("\016\n Can\'t init cmd_priv\n");
    } else {
    }
    ret8 = 0;
    goto exit;
  } else {
  }
  padapter->cmdpriv.padapter = padapter;
  tmp___0 = rtw_init_evt_priv23a(& padapter->evtpriv);
  if (tmp___0 == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
      printk("\016\n Can\'t init evt_priv\n");
    } else {
    }
    ret8 = 0;
    goto exit;
  } else {
  }
  tmp___1 = rtw_init_mlme_priv23a(padapter);
  if (tmp___1 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
      printk("\016\n Can\'t init mlme_priv\n");
    } else {
    }
    ret8 = 0;
    goto exit;
  } else {
  }
  tmp___2 = init_mlme_ext_priv23a(padapter);
  if (tmp___2 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
      printk("\016\n Can\'t init mlme_ext_priv\n");
    } else {
    }
    ret8 = 0;
    goto exit;
  } else {
  }
  tmp___3 = _rtw_init_xmit_priv23a(& padapter->xmitpriv, padapter);
  if (tmp___3 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Can\'t _rtw_init_xmit_priv23a\n");
    } else {
    }
    ret8 = 0;
    goto exit;
  } else {
  }
  tmp___4 = _rtw_init_recv_priv23a(& padapter->recvpriv, padapter);
  if (tmp___4 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Can\'t _rtw_init_recv_priv23a\n");
    } else {
    }
    ret8 = 0;
    goto exit;
  } else {
  }
  tmp___5 = _rtw_init_sta_priv23a(& padapter->stapriv);
  if (tmp___5 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: Can\'t _rtw_init_sta_priv23a\n");
    } else {
    }
    ret8 = 0;
    goto exit;
  } else {
  }
  padapter->stapriv.padapter = padapter;
  padapter->setband = 0U;
  rtw_init_bcmc_stainfo23a(padapter);
  rtw_init_pwrctrl_priv23a(padapter);
  ret8 = rtw_init_default_value(padapter);
  rtl8723a_init_dm_priv(padapter);
  rtw_sreset_init(padapter);
  exit: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016-rtw_init_drv_sw23a\n");
  } else {
  }
  return (ret8);
}
}
void rtw_cancel_all_timer23a(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016+rtw_cancel_all_timer23a\n");
  } else {
  }
  ldv_del_timer_sync_2168(& padapter->mlmepriv.assoc_timer);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016%s:cancel association timer complete!\n", "rtw_cancel_all_timer23a");
  } else {
  }
  ldv_del_timer_sync_2169(& padapter->mlmepriv.scan_to_timer);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016%s:cancel scan_to_timer!\n", "rtw_cancel_all_timer23a");
  } else {
  }
  ldv_del_timer_sync_2170(& padapter->mlmepriv.dynamic_chk_timer);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016%s:cancel dynamic_chk_timer!\n", "rtw_cancel_all_timer23a");
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016%s:cancel DeInitSwLeds!\n", "rtw_cancel_all_timer23a");
  } else {
  }
  ldv_del_timer_sync_2171(& padapter->pwrctrlpriv.pwr_state_check_timer);
  ldv_del_timer_sync_2172(& padapter->mlmepriv.set_scan_deny_timer);
  rtw_clear_scan_deny(padapter);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016%s:cancel set_scan_deny_timer!\n", "rtw_cancel_all_timer23a");
  } else {
  }
  ldv_del_timer_sync_2173(& padapter->recvpriv.signal_stat_timer);
  rtl8723a_deinit_dm_priv(padapter);
  return;
}
}
int rtw_free_drv_sw23a(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016==>rtw_free_drv_sw23a");
  } else {
  }
  free_mlme_ext_priv23a(& padapter->mlmeextpriv);
  rtw_free_evt_priv23a(& padapter->evtpriv);
  rtw_free_mlme_priv23a(& padapter->mlmepriv);
  _rtw_free_xmit_priv23a(& padapter->xmitpriv);
  _rtw_free_sta_priv23a(& padapter->stapriv);
  _rtw_free_recv_priv23a(& padapter->recvpriv);
  rtw_free_pwrctrl_priv(padapter);
  kfree((void const *)padapter->HalData);
  padapter->HalData = (void *)0;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016<== rtw_free_drv_sw23a\n");
  } else {
  }
  if ((unsigned long )padapter->pbuddy_adapter != (unsigned long )((struct rtw_adapter *)0)) {
    (padapter->pbuddy_adapter)->pbuddy_adapter = (struct rtw_adapter *)0;
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016-rtw_free_drv_sw23a\n");
  } else {
  }
  return (1);
}
}
static int _rtw_drv_register_netdev(struct rtw_adapter *padapter , char *name )
{
  struct net_device *pnetdev ;
  int ret ;
  int tmp ;
  {
  pnetdev = padapter->pnetdev;
  ret = 1;
  rtw_init_netdev23a_name23a(pnetdev, (char const *)name);
  ether_addr_copy(pnetdev->dev_addr, (u8 const *)(& padapter->eeprompriv.mac_addr));
  tmp = ldv_register_netdev_2174(pnetdev);
  if (tmp != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(%s): Failed!\n", "_rtw_drv_register_netdev", (char *)(& pnetdev->name));
    } else {
    }
    ret = 0;
    goto error_register_netdev;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, MAC Address (if%d) = %02x:%02x:%02x:%02x:%02x:%02x\n",
           "_rtw_drv_register_netdev", (int )padapter->iface_id + 1, (int )*(pnetdev->dev_addr),
           (int )*(pnetdev->dev_addr + 1UL), (int )*(pnetdev->dev_addr + 2UL), (int )*(pnetdev->dev_addr + 3UL),
           (int )*(pnetdev->dev_addr + 4UL), (int )*(pnetdev->dev_addr + 5UL));
  } else {
  }
  return (ret);
  error_register_netdev: ;
  if ((unsigned int )padapter->iface_id != 0U) {
    rtw_free_drv_sw23a(padapter);
    ldv_free_netdev_2175(pnetdev);
  } else {
  }
  return (ret);
}
}
int rtw_drv_register_netdev(struct rtw_adapter *if1 )
{
  struct dvobj_priv *dvobj ;
  int i ;
  int status ;
  struct rtw_adapter *padapter ;
  char *name ;
  {
  dvobj = if1->dvobj;
  status = 1;
  if ((unsigned int )dvobj->iface_nums > 3U) {
    status = 0;
    goto exit;
  } else {
  }
  i = 0;
  goto ldv_54922;
  ldv_54921:
  padapter = dvobj->padapters[i];
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
    if ((unsigned int )padapter->iface_id == 0U) {
      name = (char *)(& if1->registrypriv.ifname);
    } else
    if ((unsigned int )padapter->iface_id == 1U) {
      name = (char *)(& if1->registrypriv.if2name);
    } else {
      name = (char *)"wlan%d";
    }
    status = _rtw_drv_register_netdev(padapter, name);
    if (status != 1) {
      goto ldv_54920;
    } else {
    }
  } else {
  }
  i = i + 1;
  ldv_54922: ;
  if ((int )dvobj->iface_nums > i) {
    goto ldv_54921;
  } else {
  }
  ldv_54920: ;
  exit: ;
  return (status);
}
}
int netdev_open23a(struct net_device *pnetdev )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct pwrctrl_priv *pwrctrlpriv ;
  int ret ;
  int status ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  {
  tmp = netdev_priv((struct net_device const *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  ret = 0;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016+871x_drv - dev_open\n");
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +871x_drv - drv_open, bup =%d\n", padapter->bup);
  } else {
  }
  mutex_lock_nested(& (padapter->dvobj)->hw_init_mutex, 0U);
  pwrctrlpriv = & padapter->pwrctrlpriv;
  if (pwrctrlpriv->ps_flag != 0) {
    padapter->net_closed = 0;
    goto netdev_open23a_normal_process;
  } else {
  }
  if (padapter->bup == 0) {
    padapter->bDriverStopped = 0;
    padapter->bSurpriseRemoved = 0;
    padapter->bCardDisableWOHSM = 0;
    status = rtw_hal_init23a(padapter);
    if (status == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
        printk("\016rtl871x_hal_init(): Can\'t init h/w!\n");
      } else {
      }
      goto netdev_open23a_error;
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: MAC Address = %02x:%02x:%02x:%02x:%02x:%02x\n", (int )*(pnetdev->dev_addr),
             (int )*(pnetdev->dev_addr + 1UL), (int )*(pnetdev->dev_addr + 2UL), (int )*(pnetdev->dev_addr + 3UL),
             (int )*(pnetdev->dev_addr + 4UL), (int )*(pnetdev->dev_addr + 5UL));
    } else {
    }
    tmp___0 = init_hw_mlme_ext23a(padapter);
    if (tmp___0 == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: can\'t init mlme_ext_priv\n");
      } else {
      }
      goto netdev_open23a_error;
    } else {
    }
    rtl8723au_inirp_init(padapter);
    rtw_cfg80211_init_wiphy(padapter);
    padapter->bup = 1;
  } else {
  }
  padapter->net_closed = 0;
  tmp___1 = msecs_to_jiffies(2000U);
  ldv_mod_timer_2176(& padapter->mlmepriv.dynamic_chk_timer, tmp___1 + (unsigned long )jiffies);
  padapter->pwrctrlpriv.bips_processing = 0U;
  tmp___2 = msecs_to_jiffies((unsigned int const )padapter->pwrctrlpriv.pwr_state_check_interval);
  ldv_mod_timer_2177(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp___2 + (unsigned long )jiffies);
  tmp___3 = rtw_netif_queue_stopped(pnetdev);
  if (tmp___3 == 0) {
    netif_tx_start_all_queues(pnetdev);
  } else {
    netif_tx_wake_all_queues___0(pnetdev);
  }
  netdev_open23a_normal_process: ;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016-871x_drv - dev_open\n");
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -871x_drv - drv_open, bup =%d\n", padapter->bup);
  } else {
  }
  exit:
  mutex_unlock(& (padapter->dvobj)->hw_init_mutex);
  return (ret);
  netdev_open23a_error:
  padapter->bup = 0;
  netif_carrier_off(pnetdev);
  netif_tx_stop_all_queues___0(pnetdev);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
    printk("\016-871x_drv - dev_open, fail!\n");
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -871x_drv - drv_open fail, bup =%d\n", padapter->bup);
  } else {
  }
  ret = -1;
  goto exit;
}
}
static int ips_netdrv_open(struct rtw_adapter *padapter )
{
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  {
  status = 1;
  padapter->net_closed = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ===> %s.........\n", "ips_netdrv_open");
  } else {
  }
  padapter->bDriverStopped = 0;
  padapter->bSurpriseRemoved = 0;
  padapter->bCardDisableWOHSM = 0;
  status = rtw_hal_init23a(padapter);
  if (status == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
      printk("\016ips_netdrv_open(): Can\'t init h/w!\n");
    } else {
    }
    goto netdev_open23a_error;
  } else {
  }
  rtl8723au_inirp_init(padapter);
  tmp = msecs_to_jiffies((unsigned int const )padapter->pwrctrlpriv.pwr_state_check_interval);
  ldv_mod_timer_2178(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp + (unsigned long )jiffies);
  tmp___0 = msecs_to_jiffies(5000U);
  ldv_mod_timer_2179(& padapter->mlmepriv.dynamic_chk_timer, tmp___0 + (unsigned long )jiffies);
  return (1);
  netdev_open23a_error: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -ips_netdrv_open - drv_open failure, bup =%d\n", padapter->bup);
  } else {
  }
  return (0);
}
}
int rtw_ips_pwr_up23a(struct rtw_adapter *padapter )
{
  int result ;
  unsigned long start_time ;
  unsigned int tmp ;
  {
  start_time = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ===>  rtw_ips_pwr_up23a..............\n");
  } else {
  }
  rtw_reset_drv_sw23a(padapter);
  result = ips_netdrv_open(padapter);
  if (GlobalDebugLevel23A > 3U) {
    tmp = jiffies_to_msecs((unsigned long )jiffies - start_time);
    printk("\016RTL8723AU: <===  rtw_ips_pwr_up23a.............. in %dms\n", tmp);
  } else {
  }
  return (result);
}
}
void rtw_ips_pwr_down23a(struct rtw_adapter *padapter )
{
  unsigned long start_time ;
  unsigned int tmp ;
  {
  start_time = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: ===> rtw_ips_pwr_down23a...................\n");
  } else {
  }
  padapter->bCardDisableWOHSM = 1;
  padapter->net_closed = 1;
  rtw_ips_dev_unload23a(padapter);
  padapter->bCardDisableWOHSM = 0;
  if (GlobalDebugLevel23A > 3U) {
    tmp = jiffies_to_msecs((unsigned long )jiffies - start_time);
    printk("\016RTL8723AU: <=== rtw_ips_pwr_down23a..................... in %dms\n",
           tmp);
  } else {
  }
  return;
}
}
void rtw_ips_dev_unload23a(struct rtw_adapter *padapter )
{
  {
  rtl8723a_fifo_cleanup(padapter);
  rtl8723a_usb_intf_stop(padapter);
  if (padapter->bSurpriseRemoved == 0) {
    rtw_hal_deinit23a(padapter);
  } else {
  }
  return;
}
}
int pm_netdev_open23a(struct net_device *pnetdev , u8 bnormal )
{
  int status ;
  void *tmp ;
  int tmp___0 ;
  {
  if ((unsigned int )bnormal != 0U) {
    status = netdev_open23a(pnetdev);
  } else {
    tmp = netdev_priv((struct net_device const *)pnetdev);
    tmp___0 = ips_netdrv_open((struct rtw_adapter *)tmp);
    status = tmp___0 == 1 ? 0 : -1;
  }
  return (status);
}
}
static int netdev_close(struct net_device *pnetdev )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016+871x_drv - drv_close\n");
  } else {
  }
  padapter->net_closed = 1;
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: (2)871x_drv - drv_close, bup =%d, hw_init_completed =%d\n",
             padapter->bup, (int )padapter->hw_init_completed);
    } else {
    }
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
      tmp___0 = rtw_netif_queue_stopped(pnetdev);
      if (tmp___0 == 0) {
        netif_tx_stop_all_queues___0(pnetdev);
      } else {
      }
    } else {
    }
    LeaveAllPowerSaveMode23a(padapter);
    rtw_disassoc_cmd23a(padapter, 500U, 0);
    rtw_indicate_disconnect23a(padapter);
    rtw_free_assoc_resources23a(padapter, 1);
    rtw_free_network_queue23a(padapter);
  } else {
  }
  rtw_scan_abort23a(padapter);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
    printk("\016-871x_drv - drv_close\n");
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -871x_drv - drv_close, bup =%d\n", padapter->bup);
  } else {
  }
  return (0);
}
}
void rtw_ndev_destructor(struct net_device *ndev )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "rtw_ndev_destructor", (char *)(& ndev->name));
  } else {
  }
  kfree((void const *)ndev->ieee80211_ptr);
  ldv_free_netdev_2180(ndev);
  return;
}
}
void _rtw_init_queue23a(struct rtw_queue *pqueue )
{
  struct lock_class_key __key ;
  {
  INIT_LIST_HEAD(& pqueue->queue);
  spinlock_check(& pqueue->lock);
  __raw_spin_lock_init(& pqueue->lock.ldv_6347.rlock, "&(&pqueue->lock)->rlock", & __key);
  return;
}
}
u16 (*ldvarg48)(struct net_device * , struct sk_buff * ) ;
extern int ldv_ndo_init_13(void) ;
int ldv_retval_8 ;
int ldv_retval_9 ;
extern int ldv_ndo_uninit_13(void) ;
void ldv_net_device_ops_13(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(3264UL);
  rtw_netdev_ops_group1 = (struct net_device *)tmp;
  return;
}
}
void ldv_main_exported_13(void)
{
  void *ldvarg47 ;
  void *tmp ;
  struct sk_buff *ldvarg50 ;
  void *tmp___0 ;
  void *ldvarg49 ;
  void *tmp___1 ;
  struct sk_buff *ldvarg51 ;
  void *tmp___2 ;
  int tmp___3 ;
  {
  tmp = ldv_zalloc(1UL);
  ldvarg47 = tmp;
  tmp___0 = ldv_zalloc(232UL);
  ldvarg50 = (struct sk_buff *)tmp___0;
  tmp___1 = ldv_zalloc(1UL);
  ldvarg49 = tmp___1;
  tmp___2 = ldv_zalloc(232UL);
  ldvarg51 = (struct sk_buff *)tmp___2;
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_13 == 1) {
    rtw_net_get_stats(rtw_netdev_ops_group1);
    ldv_state_variable_13 = 1;
  } else {
  }
  if (ldv_state_variable_13 == 3) {
    rtw_net_get_stats(rtw_netdev_ops_group1);
    ldv_state_variable_13 = 3;
  } else {
  }
  if (ldv_state_variable_13 == 2) {
    rtw_net_get_stats(rtw_netdev_ops_group1);
    ldv_state_variable_13 = 2;
  } else {
  }
  goto ldv_54988;
  case 1: ;
  if (ldv_state_variable_13 == 2) {
    ldv_retval_9 = netdev_open23a(rtw_netdev_ops_group1);
    if (ldv_retval_9 == 0) {
      ldv_state_variable_13 = 3;
    } else {
    }
  } else {
  }
  goto ldv_54988;
  case 2: ;
  if (ldv_state_variable_13 == 3) {
    rtw_xmit23a_entry23a(ldvarg51, rtw_netdev_ops_group1);
    ldv_state_variable_13 = 3;
  } else {
  }
  goto ldv_54988;
  case 3: ;
  if (ldv_state_variable_13 == 3) {
    netdev_close(rtw_netdev_ops_group1);
    ldv_state_variable_13 = 2;
  } else {
  }
  goto ldv_54988;
  case 4: ;
  if (ldv_state_variable_13 == 1) {
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg50, ldvarg49, ldvarg48);
    ldv_state_variable_13 = 1;
  } else {
  }
  if (ldv_state_variable_13 == 3) {
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg50, ldvarg49, ldvarg48);
    ldv_state_variable_13 = 3;
  } else {
  }
  if (ldv_state_variable_13 == 2) {
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg50, ldvarg49, ldvarg48);
    ldv_state_variable_13 = 2;
  } else {
  }
  goto ldv_54988;
  case 5: ;
  if (ldv_state_variable_13 == 1) {
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg47);
    ldv_state_variable_13 = 1;
  } else {
  }
  if (ldv_state_variable_13 == 3) {
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg47);
    ldv_state_variable_13 = 3;
  } else {
  }
  if (ldv_state_variable_13 == 2) {
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg47);
    ldv_state_variable_13 = 2;
  } else {
  }
  goto ldv_54988;
  case 6: ;
  if (ldv_state_variable_13 == 1) {
    ldv_retval_8 = ldv_ndo_init_13();
    if (ldv_retval_8 == 0) {
      ldv_state_variable_13 = 2;
      usb_counter = usb_counter + 1;
      ref_cnt = ref_cnt + 1;
    } else {
    }
  } else {
  }
  goto ldv_54988;
  case 7: ;
  if (ldv_state_variable_13 == 2) {
    ldv_ndo_uninit_13();
    ldv_state_variable_13 = 1;
    usb_counter = usb_counter - 1;
    ref_cnt = ref_cnt - 1;
  } else {
  }
  goto ldv_54988;
  default:
  ldv_stop();
  }
  ldv_54988: ;
  return;
}
}
void *ldv_kmem_cache_alloc_2150(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2156(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2158(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2160(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2161(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2162(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2163(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2164(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2165(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2166(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_mod_timer_2167(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2168(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2169(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2170(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2171(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2172(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2173(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_register_netdev_2174(struct net_device *dev )
{
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;
  {
  tmp = register_netdev(dev);
  ldv_func_res = tmp;
  ldv_state_variable_15 = 1;
  ldv_net_device_ops_15();
  return (ldv_func_res);
}
}
void ldv_free_netdev_2175(struct net_device *dev )
{
  {
  free_netdev(dev);
  ldv_state_variable_15 = 0;
  return;
}
}
int ldv_mod_timer_2176(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_2177(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_2178(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_2179(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
void ldv_free_netdev_2180(struct net_device *dev )
{
  {
  free_netdev(dev);
  ldv_state_variable_15 = 0;
  return;
}
}
void *ldv_kmem_cache_alloc_2220(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
int ldv_timer_11_0 ;
struct timer_list *ldv_timer_list_11_1 ;
int ldv_timer_11_2 ;
int ldv_timer_11_1 ;
struct timer_list *ldv_timer_list_11_2 ;
struct timer_list *ldv_timer_list_11_0 ;
int ldv_timer_11_3 ;
struct timer_list *ldv_timer_list_11_3 ;
void disable_suitable_timer_11(struct timer_list *timer ) ;
void ldv_timer_11(int state , struct timer_list *timer ) ;
void choose_timer_11(void) ;
void timer_init_11(void) ;
int reg_timer_11(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data ) ;
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void activate_suitable_timer_11(struct timer_list *timer , unsigned long data ) ;
struct sk_buff *ldv_skb_clone_2228(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2236(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2237(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2230(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2226(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2235(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
__inline static unsigned char *skb_end_pointer(struct sk_buff const *skb )
{
  {
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2231(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2232(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2233(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
__inline static void skb_set_queue_mapping(struct sk_buff *skb , u16 queue_mapping )
{
  {
  skb->queue_mapping = queue_mapping;
  return;
}
}
extern void cfg80211_michael_mic_failure(struct net_device * , u8 const * , enum nl80211_key_type ,
                                         int , u8 const * , gfp_t ) ;
void rtw_handle_tkip_mic_err23a(struct rtw_adapter *padapter , u8 bgroup )
{
  enum nl80211_key_type key_type ;
  union iwreq_data wrqu ;
  struct iw_michaelmicfailure ev ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  unsigned long cur_time ;
  {
  key_type = 0;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  if (psecuritypriv->last_mic_err_time == 0UL) {
    psecuritypriv->last_mic_err_time = jiffies;
  } else {
    cur_time = jiffies;
    if (cur_time - psecuritypriv->last_mic_err_time <= 14999UL) {
      psecuritypriv->btkip_countermeasure = 1U;
      psecuritypriv->last_mic_err_time = 0UL;
      psecuritypriv->btkip_countermeasure_time = cur_time;
    } else {
      psecuritypriv->last_mic_err_time = jiffies;
    }
  }
  if ((unsigned int )bgroup != 0U) {
    key_type = key_type;
  } else {
    key_type = (enum nl80211_key_type )((unsigned int )key_type | 1U);
  }
  cfg80211_michael_mic_failure(padapter->pnetdev, (u8 const *)(& pmlmepriv->assoc_bssid),
                               key_type, -1, (u8 const *)0U, 32U);
  memset((void *)(& ev), 0, 28UL);
  if ((unsigned int )bgroup != 0U) {
    ev.flags = ev.flags | 4U;
  } else {
    ev.flags = ev.flags | 8U;
  }
  ev.src_addr.sa_family = 1U;
  ether_addr_copy((u8 *)(& ev.src_addr.sa_data), (u8 const *)(& pmlmepriv->assoc_bssid));
  memset((void *)(& wrqu), 0, 16UL);
  wrqu.data.length = 28U;
  return;
}
}
int rtw_recv_indicatepkt23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame )
{
  struct recv_priv *precvpriv ;
  struct sk_buff *skb ;
  struct mlme_priv *pmlmepriv ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  struct sk_buff *pskb2 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct rx_pkt_attrib *pattrib ;
  int bmcast ;
  bool tmp___1 ;
  struct net_device *pnetdev ;
  u16 tmp___2 ;
  u8 *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  precvpriv = & padapter->recvpriv;
  skb = precv_frame->pkt;
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 4);
      printk("\016rtw_recv_indicatepkt23a():skb == NULL!!!!\n");
    } else {
    }
    goto _recv_indicatepkt_drop;
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 7);
    printk("\016rtw_recv_indicatepkt23a():skb != NULL !!!\n");
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 7);
    printk("\016rtw_recv_indicatepkt23a():precv_frame->hdr.rx_data =%p\n", (precv_frame->pkt)->data);
  } else {
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 7);
    tmp = skb_end_pointer((struct sk_buff const *)skb);
    tmp___0 = skb_tail_pointer((struct sk_buff const *)skb);
    printk("\016\n skb->head =%p skb->data =%p skb->tail =%p skb->end =%p skb->len =%d\n",
           skb->head, skb->data, tmp___0, tmp, skb->len);
  } else {
  }
  tmp___6 = check_fwstate(pmlmepriv, 16);
  if ((int )tmp___6) {
    pskb2 = (struct sk_buff *)0;
    psta = (struct sta_info *)0;
    pstapriv = & padapter->stapriv;
    pattrib = & precv_frame->attrib;
    tmp___1 = is_multicast_ether_addr((u8 const *)(& pattrib->dst));
    bmcast = (int )tmp___1;
    tmp___3 = myid(& padapter->eeprompriv);
    tmp___4 = ether_addr_equal((u8 const *)(& pattrib->dst), (u8 const *)tmp___3);
    if (tmp___4) {
      tmp___5 = 0;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (bmcast != 0) {
        psta = rtw_get_bcmc_stainfo23a(padapter);
        pskb2 = ldv_skb_clone_2237(skb, 32U);
      } else {
        psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& pattrib->dst));
      }
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
        pnetdev = padapter->pnetdev;
        skb->dev = pnetdev;
        tmp___2 = rtw_recv_select_queue23a(skb);
        skb_set_queue_mapping(skb, (int )tmp___2);
        rtw_xmit23a_entry23a(skb, pnetdev);
        if (bmcast != 0) {
          skb = pskb2;
        } else {
          goto _recv_indicatepkt_end;
        }
      } else {
      }
    } else {
    }
  } else {
  }
  skb->ip_summed = 0U;
  skb->dev = padapter->pnetdev;
  skb->protocol = eth_type_trans(skb, padapter->pnetdev);
  netif_rx(skb);
  _recv_indicatepkt_end:
  precv_frame->pkt = (struct sk_buff *)0;
  rtw_free_recvframe23a(precv_frame);
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 7);
    printk("\016\n rtw_recv_indicatepkt23a :after netif_rx!!!!\n");
  } else {
  }
  return (1);
  _recv_indicatepkt_drop:
  rtw_free_recvframe23a(precv_frame);
  return (0);
}
}
void rtw_init_recv_timer23a(struct recv_reorder_ctrl *preorder_ctrl )
{
  {
  reg_timer_6(& preorder_ctrl->reordering_ctrl_timer, & rtw_reordering_ctrl_timeout_handler23a,
              (unsigned long )preorder_ctrl);
  return;
}
}
void disable_suitable_timer_11(struct timer_list *timer )
{
  {
  if (ldv_timer_11_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_0) {
    ldv_timer_11_0 = 0;
    return;
  } else {
  }
  if (ldv_timer_11_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_1) {
    ldv_timer_11_1 = 0;
    return;
  } else {
  }
  if (ldv_timer_11_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_2) {
    ldv_timer_11_2 = 0;
    return;
  } else {
  }
  if (ldv_timer_11_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_3) {
    ldv_timer_11_3 = 0;
    return;
  } else {
  }
  return;
}
}
void ldv_timer_11(int state , struct timer_list *timer )
{
  {
  LDV_IN_INTERRUPT = 2;
  rtw_reordering_ctrl_timeout_handler23a(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void choose_timer_11(void)
{
  int tmp ;
  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_11_0 == 1) {
    ldv_timer_11_0 = 2;
    ldv_timer_11(ldv_timer_11_0, ldv_timer_list_11_0);
  } else {
  }
  goto ldv_51537;
  case 1: ;
  if (ldv_timer_11_1 == 1) {
    ldv_timer_11_1 = 2;
    ldv_timer_11(ldv_timer_11_1, ldv_timer_list_11_1);
  } else {
  }
  goto ldv_51537;
  case 2: ;
  if (ldv_timer_11_2 == 1) {
    ldv_timer_11_2 = 2;
    ldv_timer_11(ldv_timer_11_2, ldv_timer_list_11_2);
  } else {
  }
  goto ldv_51537;
  case 3: ;
  if (ldv_timer_11_3 == 1) {
    ldv_timer_11_3 = 2;
    ldv_timer_11(ldv_timer_11_3, ldv_timer_list_11_3);
  } else {
  }
  goto ldv_51537;
  default:
  ldv_stop();
  }
  ldv_51537: ;
  return;
}
}
void timer_init_11(void)
{
  {
  ldv_timer_11_0 = 0;
  ldv_timer_11_1 = 0;
  ldv_timer_11_2 = 0;
  ldv_timer_11_3 = 0;
  return;
}
}
int reg_timer_11(struct timer_list *timer , void (*function)(unsigned long ) , unsigned long data )
{
  {
  if ((unsigned long )function == (unsigned long )(& rtw_reordering_ctrl_timeout_handler23a)) {
    activate_suitable_timer_11(timer, data);
  } else {
  }
  return (0);
}
}
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag )
{
  {
  if ((unsigned long )ldv_timer_list_11_0 == (unsigned long )timer) {
    if (ldv_timer_11_0 == 2 || pending_flag != 0) {
      ldv_timer_list_11_0 = timer;
      ldv_timer_list_11_0->data = data;
      ldv_timer_11_0 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_11_1 == (unsigned long )timer) {
    if (ldv_timer_11_1 == 2 || pending_flag != 0) {
      ldv_timer_list_11_1 = timer;
      ldv_timer_list_11_1->data = data;
      ldv_timer_11_1 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_11_2 == (unsigned long )timer) {
    if (ldv_timer_11_2 == 2 || pending_flag != 0) {
      ldv_timer_list_11_2 = timer;
      ldv_timer_list_11_2->data = data;
      ldv_timer_11_2 = 1;
    } else {
    }
    return;
  } else {
  }
  if ((unsigned long )ldv_timer_list_11_3 == (unsigned long )timer) {
    if (ldv_timer_11_3 == 2 || pending_flag != 0) {
      ldv_timer_list_11_3 = timer;
      ldv_timer_list_11_3->data = data;
      ldv_timer_11_3 = 1;
    } else {
    }
    return;
  } else {
  }
  activate_suitable_timer_11(timer, data);
  return;
}
}
void activate_suitable_timer_11(struct timer_list *timer , unsigned long data )
{
  {
  if (ldv_timer_11_0 == 0 || ldv_timer_11_0 == 2) {
    ldv_timer_list_11_0 = timer;
    ldv_timer_list_11_0->data = data;
    ldv_timer_11_0 = 1;
    return;
  } else {
  }
  if (ldv_timer_11_1 == 0 || ldv_timer_11_1 == 2) {
    ldv_timer_list_11_1 = timer;
    ldv_timer_list_11_1->data = data;
    ldv_timer_11_1 = 1;
    return;
  } else {
  }
  if (ldv_timer_11_2 == 0 || ldv_timer_11_2 == 2) {
    ldv_timer_list_11_2 = timer;
    ldv_timer_list_11_2->data = data;
    ldv_timer_11_2 = 1;
    return;
  } else {
  }
  if (ldv_timer_11_3 == 0 || ldv_timer_11_3 == 2) {
    ldv_timer_list_11_3 = timer;
    ldv_timer_list_11_3->data = data;
    ldv_timer_11_3 = 1;
    return;
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_2220(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2226(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2228(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2230(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2231(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2232(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2233(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2235(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2236(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2237(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
extern struct module __this_module ;
extern void __bad_percpu_size(void) ;
extern struct task_struct *current_task ;
__inline static struct task_struct *get_current(void)
{
  struct task_struct *pfo_ret__ ;
  {
  switch (8UL) {
  case 1UL:
  __asm__ ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
  goto ldv_3067;
  case 2UL:
  __asm__ ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_3067;
  case 4UL:
  __asm__ ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_3067;
  case 8UL:
  __asm__ ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_3067;
  default:
  __bad_percpu_size();
  }
  ldv_3067: ;
  return (pfo_ret__);
}
}
extern void flush_workqueue(struct workqueue_struct * ) ;
void *ldv_kmem_cache_alloc_2264(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct timer_list *ldv_timer_list_7_1 ;
int ldv_timer_11_0 ;
int ldv_timer_1_3 ;
struct timer_list *ldv_timer_list_2_0 ;
int ldv_state_variable_0 ;
struct timer_list *ldv_timer_list_9_3 ;
struct timer_list *ldv_timer_list_10_2 ;
struct timer_list *ldv_timer_list_8_1 ;
int ldv_timer_5_2 ;
int ldv_state_variable_12 ;
struct timer_list *ldv_timer_list_5_0 ;
struct wiphy *rtw_cfg80211_ops_group1 ;
int ldv_state_variable_14 ;
int ldv_timer_9_1 ;
struct timer_list *ldv_timer_list_3_2 ;
int ldv_timer_6_2 ;
int ldv_timer_2_2 ;
int ldv_timer_3_3 ;
int ldv_timer_9_0 ;
struct timer_list *ldv_timer_list_5_3 ;
int ldv_timer_9_3 ;
int ldv_timer_4_3 ;
int ldv_state_variable_9 ;
int ldv_timer_6_0 ;
struct timer_list *ldv_timer_list_5_1 ;
struct timer_list *ldv_timer_list_11_1 ;
int ref_cnt ;
int ldv_state_variable_7 ;
struct timer_list *ldv_timer_list_10_0 ;
struct timer_list *ldv_timer_list_6_3 ;
struct station_parameters *rtw_cfg80211_ops_group2 ;
int ldv_timer_8_2 ;
struct timer_list *ldv_timer_list_6_2 ;
struct timer_list *ldv_timer_list_9_2 ;
int ldv_timer_9_2 ;
struct timer_list *ldv_timer_list_4_0 ;
struct timer_list *ldv_timer_list_1_1 ;
struct timer_list *ldv_timer_list_7_3 ;
struct timer_list *ldv_timer_list_2_1 ;
int ldv_timer_11_2 ;
int ldv_state_variable_6 ;
int ldv_timer_2_0 ;
int ldv_timer_1_1 ;
struct station_info *rtw_cfg80211_ops_group3 ;
struct timer_list *ldv_timer_list_6_0 ;
int usb_counter ;
struct timer_list *ldv_timer_list_8_3 ;
int ldv_timer_7_1 ;
int ldv_timer_10_2 ;
struct timer_list *ldv_timer_list_4_3 ;
struct vif_params *rtw_cfg80211_ops_group5 ;
int ldv_timer_5_3 ;
struct timer_list *ldv_timer_list_7_0 ;
int ldv_timer_3_2 ;
struct timer_list *ldv_timer_list_10_1 ;
int ldv_state_variable_3 ;
int ldv_timer_3_0 ;
int ldv_timer_4_1 ;
struct timer_list *ldv_timer_list_4_1 ;
struct timer_list *ldv_timer_list_2_2 ;
struct net_device *rtw_netdev_ops_group1 ;
struct timer_list *ldv_timer_list_9_0 ;
int ldv_timer_8_3 ;
int ldv_state_variable_4 ;
int ldv_timer_7_3 ;
int ldv_state_variable_8 ;
int ldv_state_variable_15 ;
int ldv_timer_4_0 ;
int ldv_timer_2_1 ;
struct timer_list *ldv_timer_list_5_2 ;
int ldv_state_variable_5 ;
int ldv_timer_11_1 ;
int ldv_state_variable_13 ;
struct timer_list *ldv_timer_list_11_2 ;
struct timer_list *ldv_timer_list_3_1 ;
int ldv_timer_5_1 ;
struct timer_list *ldv_timer_list_7_2 ;
int ldv_timer_2_3 ;
int ldv_timer_1_0 ;
struct timer_list *ldv_timer_list_3_3 ;
struct timer_list *ldv_timer_list_6_1 ;
int ldv_timer_7_0 ;
struct timer_list *ldv_timer_list_11_0 ;
int ldv_timer_3_1 ;
struct net_device *rtw_cfg80211_ops_group6 ;
int ldv_state_variable_1 ;
int ldv_timer_6_3 ;
int ldv_timer_8_0 ;
int ldv_timer_10_0 ;
int ldv_timer_4_2 ;
struct wireless_dev *rtw_cfg80211_ops_group0 ;
struct timer_list *ldv_timer_list_1_3 ;
int ldv_state_variable_10 ;
struct timer_list *ldv_timer_list_1_0 ;
int ldv_timer_11_3 ;
int ldv_timer_1_2 ;
int ldv_timer_8_1 ;
struct net_device *rtw_cfg80211_monitor_if_ops_group1 ;
int ldv_state_variable_2 ;
struct timer_list *ldv_timer_list_1_2 ;
int ldv_timer_10_1 ;
int ldv_timer_5_0 ;
struct usb_interface *rtl8723a_usb_drv_group1 ;
int ldv_state_variable_11 ;
int ldv_timer_7_2 ;
struct timer_list *ldv_timer_list_4_2 ;
struct timer_list *ldv_timer_list_8_0 ;
struct timer_list *ldv_timer_list_10_3 ;
struct cfg80211_pmksa *rtw_cfg80211_ops_group4 ;
int ldv_timer_6_1 ;
struct timer_list *ldv_timer_list_11_3 ;
struct timer_list *ldv_timer_list_2_3 ;
struct timer_list *ldv_timer_list_3_0 ;
int ldv_timer_10_3 ;
struct timer_list *ldv_timer_list_8_2 ;
struct timer_list *ldv_timer_list_9_1 ;
void ldv_usb_driver_12(void) ;
__inline static bool device_may_wakeup(struct device *dev )
{
  {
  return ((bool )((unsigned int )*((unsigned char *)dev + 532UL) != 0U && (unsigned long )dev->power.wakeup != (unsigned long )((struct wakeup_source *)0)));
}
}
extern int device_init_wakeup(struct device * , bool ) ;
__inline static void *dev_get_drvdata(struct device const *dev )
{
  {
  return ((void *)dev->driver_data);
}
}
__inline static void dev_set_drvdata(struct device *dev , void *data )
{
  {
  dev->driver_data = data;
  return;
}
}
extern void get_random_bytes(void * , int ) ;
struct sk_buff *ldv_skb_clone_2272(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2280(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2274(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2270(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2278(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2279(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2275(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2276(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2277(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void ldv_free_netdev_2281(struct net_device *dev ) ;
void ldv_free_netdev_2283(struct net_device *dev ) ;
__inline static void netif_tx_start_all_queues___0(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_40884;
  ldv_40883:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_start_queue(txq);
  i = i + 1U;
  ldv_40884: ;
  if (dev->num_tx_queues > i) {
    goto ldv_40883;
  } else {
  }
  return;
}
}
__inline static void netif_tx_wake_all_queues___1(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_40898;
  ldv_40897:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_wake_queue(txq);
  i = i + 1U;
  ldv_40898: ;
  if (dev->num_tx_queues > i) {
    goto ldv_40897;
  } else {
  }
  return;
}
}
__inline static void netif_tx_stop_all_queues___1(struct net_device *dev )
{
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  i = 0U;
  goto ldv_40914;
  ldv_40913:
  tmp = netdev_get_tx_queue((struct net_device const *)dev, i);
  txq = tmp;
  netif_tx_stop_queue(txq);
  i = i + 1U;
  ldv_40914: ;
  if (dev->num_tx_queues > i) {
    goto ldv_40913;
  } else {
  }
  return;
}
}
extern void netif_device_attach(struct net_device * ) ;
void ldv_unregister_netdev_2282(struct net_device *dev ) ;
__inline static void eth_random_addr(u8 *addr )
{
  {
  get_random_bytes((void *)addr, 6);
  *addr = (unsigned int )*addr & 254U;
  *addr = (u8 )((unsigned int )*addr | 2U);
  return;
}
}
__inline static void *wiphy_priv___2(struct wiphy *wiphy )
{
  long tmp ;
  {
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3111), "i" (12UL));
    ldv_45905: ;
    goto ldv_45905;
  } else {
  }
  return ((void *)(& wiphy->priv));
}
}
__inline static void *wdev_priv___2(struct wireless_dev *wdev )
{
  long tmp ;
  void *tmp___0 ;
  {
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
  if (tmp != 0L) {
    __asm__ volatile ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3343), "i" (12UL));
    ldv_45985: ;
    goto ldv_45985;
  } else {
  }
  tmp___0 = wiphy_priv___2(wdev->wiphy);
  return (tmp___0);
}
}
int rtw_resume_process23a(struct rtw_adapter *padapter ) ;
__inline static void *usb_get_intfdata(struct usb_interface *intf )
{
  void *tmp ;
  {
  tmp = dev_get_drvdata((struct device const *)(& intf->dev));
  return (tmp);
}
}
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data )
{
  {
  dev_set_drvdata(& intf->dev, data);
  return;
}
}
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf )
{
  struct device const *__mptr ;
  {
  __mptr = (struct device const *)intf->dev.parent;
  return ((struct usb_device *)__mptr + 0xffffffffffffff70UL);
}
}
extern struct usb_device *usb_get_dev(struct usb_device * ) ;
extern void usb_put_dev(struct usb_device * ) ;
extern int usb_reset_device(struct usb_device * ) ;
extern int usb_autopm_get_interface(struct usb_interface * ) ;
extern void usb_autopm_put_interface(struct usb_interface * ) ;
extern int usb_register_driver(struct usb_driver * , struct module * , char const * ) ;
int ldv_usb_register_driver_2284(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const *ldv_func_arg3 ) ;
extern void usb_deregister(struct usb_driver * ) ;
void ldv_usb_deregister_2285(struct usb_driver *arg ) ;
void free_mlme_ap_info23a(struct rtw_adapter *padapter ) ;
void rtl8723au_write_port_cancel(struct rtw_adapter *padapter ) ;
static int rtw_suspend(struct usb_interface *pusb_intf , pm_message_t message ) ;
static int rtw_resume(struct usb_interface *pusb_intf ) ;
static int rtw_drv_init(struct usb_interface *pusb_intf , struct usb_device_id const *pdid ) ;
static void rtw_disconnect(struct usb_interface *pusb_intf ) ;
static struct usb_device_id rtl8723a_usb_id_tbl[4U] = { {899U, 3034U, 34596U, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL},
        {899U,
      3034U, 5924U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL},
        {899U, 3034U, 1828U, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}};
struct usb_device_id const __mod_usb__rtl8723a_usb_id_tbl_device_table ;
static struct usb_driver rtl8723a_usb_drv =
     {"rtl8723au", & rtw_drv_init, & rtw_disconnect, 0, & rtw_suspend, & rtw_resume,
    & rtw_resume, 0, 0, (struct usb_device_id const *)(& rtl8723a_usb_id_tbl), {{{{{{0U}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0}},
    {{0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0};
static struct usb_driver *usb_drv = & rtl8723a_usb_drv;
__inline static int RT_usb_endpoint_dir_in(struct usb_endpoint_descriptor const *epd )
{
  {
  return ((int )((signed char )epd->bEndpointAddress) < 0);
}
}
__inline static int RT_usb_endpoint_dir_out(struct usb_endpoint_descriptor const *epd )
{
  {
  return ((int )((signed char )epd->bEndpointAddress) >= 0);
}
}
__inline static int RT_usb_endpoint_xfer_int(struct usb_endpoint_descriptor const *epd )
{
  {
  return (((int )epd->bmAttributes & 3) == 3);
}
}
__inline static int RT_usb_endpoint_xfer_bulk(struct usb_endpoint_descriptor const *epd )
{
  {
  return (((int )epd->bmAttributes & 3) == 2);
}
}
__inline static int RT_usb_endpoint_is_bulk_in(struct usb_endpoint_descriptor const *epd )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = RT_usb_endpoint_xfer_bulk(epd);
  if (tmp != 0) {
    tmp___0 = RT_usb_endpoint_dir_in(epd);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
__inline static int RT_usb_endpoint_is_bulk_out(struct usb_endpoint_descriptor const *epd )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = RT_usb_endpoint_xfer_bulk(epd);
  if (tmp != 0) {
    tmp___0 = RT_usb_endpoint_dir_out(epd);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
__inline static int RT_usb_endpoint_is_int_in(struct usb_endpoint_descriptor const *epd )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  {
  tmp = RT_usb_endpoint_xfer_int(epd);
  if (tmp != 0) {
    tmp___0 = RT_usb_endpoint_dir_in(epd);
    if (tmp___0 != 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
__inline static int RT_usb_endpoint_num(struct usb_endpoint_descriptor const *epd )
{
  {
  return ((int )epd->bEndpointAddress & 15);
}
}
static int rtw_init_intf_priv(struct dvobj_priv *dvobj )
{
  int rst ;
  struct lock_class_key __key ;
  void *tmp ;
  {
  rst = 1;
  __mutex_init(& dvobj->usb_vendor_req_mutex, "&dvobj->usb_vendor_req_mutex", & __key);
  tmp = kzalloc(270UL, 208U);
  dvobj->usb_alloc_vendor_req_buf = (u8 *)tmp;
  if ((unsigned long )dvobj->usb_alloc_vendor_req_buf == (unsigned long )((u8 *)0U)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: alloc usb_vendor_req_buf failed...\n");
    } else {
    }
    rst = 0;
    goto exit;
  } else {
  }
  dvobj->usb_vendor_req_buf = (u8 *)(((unsigned long )dvobj->usb_alloc_vendor_req_buf + 15UL) & 0xfffffffffffffff0UL);
  exit: ;
  return (rst);
}
}
static int rtw_deinit_intf_priv(struct dvobj_priv *dvobj )
{
  int rst ;
  {
  rst = 1;
  kfree((void const *)dvobj->usb_alloc_vendor_req_buf);
  mutex_destroy(& dvobj->usb_vendor_req_mutex);
  return (rst);
}
}
static struct dvobj_priv *usb_dvobj_init(struct usb_interface *usb_intf )
{
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device_descriptor *pdev_desc ;
  struct usb_host_config *phost_conf ;
  struct usb_config_descriptor *pconf_desc ;
  struct usb_host_interface *phost_iface ;
  struct usb_interface_descriptor *piface_desc ;
  struct usb_host_endpoint *phost_endp ;
  struct usb_endpoint_descriptor *pendp_desc ;
  struct usb_device *pusbd ;
  int i ;
  int status ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  {
  status = 0;
  tmp = kzalloc(992UL, 208U);
  pdvobjpriv = (struct dvobj_priv *)tmp;
  if ((unsigned long )pdvobjpriv == (unsigned long )((struct dvobj_priv *)0)) {
    goto exit;
  } else {
  }
  __mutex_init(& pdvobjpriv->hw_init_mutex, "&pdvobjpriv->hw_init_mutex", & __key);
  __mutex_init(& pdvobjpriv->h2c_fwcmd_mutex, "&pdvobjpriv->h2c_fwcmd_mutex", & __key___0);
  __mutex_init(& pdvobjpriv->setch_mutex, "&pdvobjpriv->setch_mutex", & __key___1);
  __mutex_init(& pdvobjpriv->setbw_mutex, "&pdvobjpriv->setbw_mutex", & __key___2);
  pdvobjpriv->pusbintf = usb_intf;
  pusbd = interface_to_usbdev(usb_intf);
  pdvobjpriv->pusbdev = pusbd;
  usb_set_intfdata(usb_intf, (void *)pdvobjpriv);
  pdvobjpriv->RtNumInPipes = 0U;
  pdvobjpriv->RtNumOutPipes = 0U;
  pdev_desc = & pusbd->descriptor;
  phost_conf = pusbd->actconfig;
  pconf_desc = & phost_conf->desc;
  phost_iface = usb_intf->altsetting;
  piface_desc = & phost_iface->desc;
  pdvobjpriv->NumInterfaces = pconf_desc->bNumInterfaces;
  pdvobjpriv->InterfaceNumber = piface_desc->bInterfaceNumber;
  pdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;
  i = 0;
  goto ldv_54379;
  ldv_54378:
  phost_endp = phost_iface->endpoint + (unsigned long )i;
  if ((unsigned long )phost_endp != (unsigned long )((struct usb_host_endpoint *)0)) {
    pendp_desc = & phost_endp->desc;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \nusb_endpoint_descriptor(%d):\n", i);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: bLength =%x\n", (int )pendp_desc->bLength);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: bDescriptorType =%x\n", (int )pendp_desc->bDescriptorType);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: bEndpointAddress =%x\n", (int )pendp_desc->bEndpointAddress);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: wMaxPacketSize =%d\n", (int )pendp_desc->wMaxPacketSize);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: bInterval =%x\n", (int )pendp_desc->bInterval);
    } else {
    }
    tmp___5 = RT_usb_endpoint_is_bulk_in((struct usb_endpoint_descriptor const *)pendp_desc);
    if (tmp___5 != 0) {
      if (GlobalDebugLevel23A > 3U) {
        tmp___0 = RT_usb_endpoint_num((struct usb_endpoint_descriptor const *)pendp_desc);
        printk("\016RTL8723AU: RT_usb_endpoint_is_bulk_in = %x\n", tmp___0);
      } else {
      }
      pdvobjpriv->RtInPipe[(int )pdvobjpriv->RtNumInPipes] = RT_usb_endpoint_num((struct usb_endpoint_descriptor const *)pendp_desc);
      pdvobjpriv->RtNumInPipes = (u8 )((int )pdvobjpriv->RtNumInPipes + 1);
    } else {
      tmp___4 = RT_usb_endpoint_is_int_in((struct usb_endpoint_descriptor const *)pendp_desc);
      if (tmp___4 != 0) {
        if (GlobalDebugLevel23A > 3U) {
          tmp___1 = RT_usb_endpoint_num((struct usb_endpoint_descriptor const *)pendp_desc);
          printk("\016RTL8723AU: RT_usb_endpoint_is_int_in = %x, Interval = %x\n",
                 tmp___1, (int )pendp_desc->bInterval);
        } else {
        }
        pdvobjpriv->RtInPipe[(int )pdvobjpriv->RtNumInPipes] = RT_usb_endpoint_num((struct usb_endpoint_descriptor const *)pendp_desc);
        pdvobjpriv->RtNumInPipes = (u8 )((int )pdvobjpriv->RtNumInPipes + 1);
      } else {
        tmp___3 = RT_usb_endpoint_is_bulk_out((struct usb_endpoint_descriptor const *)pendp_desc);
        if (tmp___3 != 0) {
          if (GlobalDebugLevel23A > 3U) {
            tmp___2 = RT_usb_endpoint_num((struct usb_endpoint_descriptor const *)pendp_desc);
            printk("\016RTL8723AU: RT_usb_endpoint_is_bulk_out = %x\n", tmp___2);
          } else {
          }
          pdvobjpriv->RtOutPipe[(int )pdvobjpriv->RtNumOutPipes] = RT_usb_endpoint_num((struct usb_endpoint_descriptor const *)pendp_desc);
          pdvobjpriv->RtNumOutPipes = (u8 )((int )pdvobjpriv->RtNumOutPipes + 1);
        } else {
        }
      }
    }
    pdvobjpriv->ep_num[i] = RT_usb_endpoint_num((struct usb_endpoint_descriptor const *)pendp_desc);
  } else {
  }
  i = i + 1;
  ldv_54379: ;
  if ((int )pdvobjpriv->nr_endpoint > i) {
    goto ldv_54378;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: nr_endpoint =%d, in_num =%d, out_num =%d\n\n", (int )pdvobjpriv->nr_endpoint,
           (int )pdvobjpriv->RtNumInPipes, (int )pdvobjpriv->RtNumOutPipes);
  } else {
  }
  if ((unsigned int )pusbd->speed == 3U) {
    pdvobjpriv->ishighspeed = 1U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: USB_SPEED_HIGH\n");
    } else {
    }
  } else {
    pdvobjpriv->ishighspeed = 0U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: NON USB_SPEED_HIGH\n");
    } else {
    }
  }
  tmp___6 = rtw_init_intf_priv(pdvobjpriv);
  if (tmp___6 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
      printk("\016\n Can\'t INIT rtw_init_intf_priv\n");
    } else {
    }
    goto free_dvobj;
  } else {
  }
  rtw_reset_continual_urb_error(pdvobjpriv);
  usb_get_dev(pusbd);
  status = 1;
  free_dvobj: ;
  if (status != 1 && (unsigned long )pdvobjpriv != (unsigned long )((struct dvobj_priv *)0)) {
    usb_set_intfdata(usb_intf, (void *)0);
    mutex_destroy(& pdvobjpriv->hw_init_mutex);
    mutex_destroy(& pdvobjpriv->h2c_fwcmd_mutex);
    mutex_destroy(& pdvobjpriv->setch_mutex);
    mutex_destroy(& pdvobjpriv->setbw_mutex);
    kfree((void const *)pdvobjpriv);
    pdvobjpriv = (struct dvobj_priv *)0;
  } else {
  }
  exit: ;
  return (pdvobjpriv);
}
}
static void usb_dvobj_deinit(struct usb_interface *usb_intf )
{
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct usb_device *tmp___0 ;
  struct usb_device *tmp___1 ;
  struct usb_device *tmp___2 ;
  {
  tmp = usb_get_intfdata(usb_intf);
  dvobj = (struct dvobj_priv *)tmp;
  usb_set_intfdata(usb_intf, (void *)0);
  if ((unsigned long )dvobj != (unsigned long )((struct dvobj_priv *)0)) {
    if (((unsigned int )dvobj->NumInterfaces != 2U && (unsigned int )dvobj->NumInterfaces != 3U) || (unsigned int )dvobj->InterfaceNumber == 1U) {
      tmp___1 = interface_to_usbdev(usb_intf);
      if ((unsigned int )tmp___1->state != 0U) {
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: usb attached..., try to reset usb device\n");
        } else {
        }
        tmp___0 = interface_to_usbdev(usb_intf);
        usb_reset_device(tmp___0);
      } else {
      }
    } else {
    }
    rtw_deinit_intf_priv(dvobj);
    mutex_destroy(& dvobj->hw_init_mutex);
    mutex_destroy(& dvobj->h2c_fwcmd_mutex);
    mutex_destroy(& dvobj->setch_mutex);
    mutex_destroy(& dvobj->setbw_mutex);
    kfree((void const *)dvobj);
  } else {
  }
  tmp___2 = interface_to_usbdev(usb_intf);
  usb_put_dev(tmp___2);
  return;
}
}
void rtl8723a_usb_intf_stop(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016+usb_intf_stop\n");
  } else {
  }
  if (padapter->bSurpriseRemoved == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
      printk("\016SurpriseRemoved == false\n");
    } else {
    }
  } else {
  }
  rtl8723au_inirp_deinit(padapter);
  rtl8723au_write_port_cancel(padapter);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016-usb_intf_stop\n");
  } else {
  }
  return;
}
}
static void rtw_dev_unload(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016+rtw_dev_unload\n");
  } else {
  }
  if (padapter->bup != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ===> rtw_dev_unload\n");
    } else {
    }
    padapter->bDriverStopped = 1;
    if (padapter->xmitpriv.ack_tx != 0) {
      rtw_ack_tx_done23a(& padapter->xmitpriv, 9);
    } else {
    }
    rtl8723a_usb_intf_stop(padapter);
    flush_workqueue(padapter->cmdpriv.wq);
    if (padapter->bSurpriseRemoved == 0) {
      rtw_hal_deinit23a(padapter);
      padapter->bSurpriseRemoved = 1;
    } else {
    }
    padapter->bup = 0;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016r871x_dev_unload():padapter->bup == false\n");
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: <=== rtw_dev_unload\n");
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016-rtw_dev_unload\n");
  } else {
  }
  return;
}
}
int rtw_hw_suspend23a(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *pwrpriv ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  pnetdev = padapter->pnetdev;
  pmlmepriv = & padapter->mlmepriv;
  if ((padapter->bup == 0 || padapter->bDriverStopped != 0) || padapter->bSurpriseRemoved != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: padapter->bup =%d bDriverStopped =%d bSurpriseRemoved = %d\n",
             padapter->bup, padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {
    }
    goto error_exit;
  } else {
  }
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
    LeaveAllPowerSaveMode23a(padapter);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ==> rtw_hw_suspend23a\n");
    } else {
    }
    down(& pwrpriv->lock);
    pwrpriv->bips_processing = 1U;
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
      netif_carrier_off(pnetdev);
      netif_tx_stop_all_queues___1(pnetdev);
    } else {
    }
    rtw_disassoc_cmd23a(padapter, 500U, 0);
    tmp = check_fwstate(pmlmepriv, 1);
    if ((int )tmp) {
      _clr_fwstate_(pmlmepriv, 1);
      rtw_os_indicate_disconnect23a(padapter);
      rtw_lps_ctrl_wk_cmd23a(padapter, 3, 0);
    } else {
    }
    rtw_free_assoc_resources23a(padapter, 1);
    rtw_free_network_queue23a(padapter);
    rtw_ips_dev_unload23a(padapter);
    pwrpriv->rf_pwrstate = 2;
    pwrpriv->bips_processing = 0U;
    up(& pwrpriv->lock);
  } else {
    goto error_exit;
  }
  return (0);
  error_exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, failed\n", "rtw_hw_suspend23a");
  } else {
  }
  return (-1);
}
}
int rtw_hw_resume23a(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *pwrpriv ;
  struct net_device *pnetdev ;
  int tmp ;
  int tmp___0 ;
  {
  pwrpriv = & padapter->pwrctrlpriv;
  pnetdev = padapter->pnetdev;
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ==> rtw_hw_resume23a\n");
    } else {
    }
    down(& pwrpriv->lock);
    pwrpriv->bips_processing = 1U;
    rtw_reset_drv_sw23a(padapter);
    tmp = pm_netdev_open23a(pnetdev, 0);
    if (tmp != 0) {
      up(& pwrpriv->lock);
      goto error_exit;
    } else {
    }
    netif_device_attach(pnetdev);
    netif_carrier_on(pnetdev);
    tmp___0 = rtw_netif_queue_stopped(pnetdev);
    if (tmp___0 == 0) {
      netif_tx_start_all_queues___0(pnetdev);
    } else {
      netif_tx_wake_all_queues___1(pnetdev);
    }
    pwrpriv->bkeepfwalive = 0U;
    pwrpriv->brfoffbyhw = 0U;
    pwrpriv->rf_pwrstate = 0;
    pwrpriv->bips_processing = 0U;
    up(& pwrpriv->lock);
  } else {
    goto error_exit;
  }
  return (0);
  error_exit: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, Open net dev failed\n", "rtw_hw_resume23a");
  } else {
  }
  return (-1);
}
}
static int rtw_suspend(struct usb_interface *pusb_intf , pm_message_t message )
{
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrpriv ;
  int ret ;
  unsigned long start_time ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  unsigned int tmp___7 ;
  {
  tmp = usb_get_intfdata(pusb_intf);
  dvobj = (struct dvobj_priv *)tmp;
  padapter = dvobj->if1;
  pnetdev = padapter->pnetdev;
  pmlmepriv = & padapter->mlmepriv;
  pwrpriv = & padapter->pwrctrlpriv;
  ret = 0;
  start_time = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    tmp___0 = get_current();
    tmp___1 = get_current();
    printk("\016RTL8723AU: ==> %s (%s:%d)\n", "rtw_suspend", (char *)(& tmp___1->comm),
           tmp___0->pid);
  } else {
  }
  if ((padapter->bup == 0 || padapter->bDriverStopped != 0) || padapter->bSurpriseRemoved != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: padapter->bup =%d bDriverStopped =%d bSurpriseRemoved = %d\n",
             padapter->bup, padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {
    }
    goto exit;
  } else {
  }
  pwrpriv->bInSuspend = 1U;
  rtw_cancel_all_timer23a(padapter);
  LeaveAllPowerSaveMode23a(padapter);
  down(& pwrpriv->lock);
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
    netif_carrier_off(pnetdev);
    netif_tx_stop_all_queues___1(pnetdev);
  } else {
  }
  rtw_disassoc_cmd23a(padapter, 0U, 0);
  tmp___2 = check_fwstate(pmlmepriv, 8);
  if ((int )tmp___2) {
    tmp___3 = check_fwstate(pmlmepriv, 1);
    if ((int )tmp___3) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s:%d %s(%pM), length:%d assoc_ssid.length:%d\n", "rtw_suspend",
               694, (u8 *)(& pmlmepriv->cur_network.network.Ssid.ssid), (u8 *)(& pmlmepriv->cur_network.network.MacAddress),
               (int )pmlmepriv->cur_network.network.Ssid.ssid_len, (int )pmlmepriv->assoc_ssid.ssid_len);
      } else {
      }
      rtw_set_roaming(padapter, 1);
    } else {
    }
  } else {
  }
  rtw_indicate_disconnect23a(padapter);
  rtw_free_assoc_resources23a(padapter, 1);
  rtw_free_network_queue23a(padapter);
  rtw_dev_unload(padapter);
  up(& pwrpriv->lock);
  tmp___5 = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp___5) {
    tmp___4 = wdev_priv___2(padapter->rtw_wdev);
    rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___4, 1);
  } else {
  }
  tmp___6 = check_fwstate(pmlmepriv, 128);
  if ((int )tmp___6) {
    rtw_indicate_disconnect23a(padapter);
  } else {
  }
  exit: ;
  if (GlobalDebugLevel23A > 3U) {
    tmp___7 = jiffies_to_msecs((unsigned long )jiffies - start_time);
    printk("\016RTL8723AU: <===  %s return %d.............. in %dms\n", "rtw_suspend",
           ret, tmp___7);
  } else {
  }
  return (ret);
}
}
static int rtw_resume(struct usb_interface *pusb_intf )
{
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  int ret ;
  {
  tmp = usb_get_intfdata(pusb_intf);
  dvobj = (struct dvobj_priv *)tmp;
  padapter = dvobj->if1;
  ret = rtw_resume_process23a(padapter);
  return (ret);
}
}
int rtw_resume_process23a(struct rtw_adapter *padapter )
{
  struct net_device *pnetdev ;
  struct pwrctrl_priv *pwrpriv ;
  int ret ;
  unsigned long start_time ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  struct pid *tmp___2 ;
  unsigned int tmp___3 ;
  {
  pwrpriv = (struct pwrctrl_priv *)0;
  ret = -1;
  start_time = jiffies;
  if (GlobalDebugLevel23A > 3U) {
    tmp = get_current();
    tmp___0 = get_current();
    printk("\016RTL8723AU: ==> %s (%s:%d)\n", "rtw_resume_process23a", (char *)(& tmp___0->comm),
           tmp->pid);
  } else {
  }
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    goto exit;
  } else {
  }
  pnetdev = padapter->pnetdev;
  pwrpriv = & padapter->pwrctrlpriv;
  down(& pwrpriv->lock);
  rtw_reset_drv_sw23a(padapter);
  pwrpriv->bkeepfwalive = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bkeepfwalive(%x)\n", (int )pwrpriv->bkeepfwalive);
  } else {
  }
  tmp___1 = pm_netdev_open23a(pnetdev, 1);
  if (tmp___1 != 0) {
    goto exit;
  } else {
  }
  netif_device_attach(pnetdev);
  netif_carrier_on(pnetdev);
  up(& pwrpriv->lock);
  if (padapter->pid[1] != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: pid[1]:%d\n", padapter->pid[1]);
    } else {
    }
    tmp___2 = find_vpid(padapter->pid[1]);
    kill_pid(tmp___2, 12, 1);
  } else {
  }
  rtw23a_roaming(padapter, (struct wlan_network *)0);
  ret = 0;
  exit: ;
  if ((unsigned long )pwrpriv != (unsigned long )((struct pwrctrl_priv *)0)) {
    pwrpriv->bInSuspend = 0U;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    tmp___3 = jiffies_to_msecs((unsigned long )jiffies - start_time);
    printk("\016RTL8723AU: <===  %s return %d.............. in %dms\n", "rtw_resume_process23a",
           ret, tmp___3);
  } else {
  }
  return (ret);
}
}
static struct rtw_adapter *rtw_usb_if1_init(struct dvobj_priv *dvobj , struct usb_interface *pusb_intf ,
                                            struct usb_device_id const *pdid )
{
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  int status ;
  void *tmp ;
  u8 tmp___0 ;
  int tmp___1 ;
  struct device *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  {
  padapter = (struct rtw_adapter *)0;
  pnetdev = (struct net_device *)0;
  status = 0;
  pnetdev = rtw_init_netdev23a(padapter);
  if ((unsigned long )pnetdev == (unsigned long )((struct net_device *)0)) {
    goto handle_dualmac;
  } else {
  }
  tmp = netdev_priv((struct net_device const *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  padapter->dvobj = dvobj;
  padapter->bDriverStopped = 1;
  dvobj->if1 = padapter;
  tmp___0 = dvobj->iface_nums;
  dvobj->iface_nums = (u8 )((int )dvobj->iface_nums + 1);
  dvobj->padapters[(int )tmp___0] = padapter;
  padapter->iface_id = 0U;
  rtl8723au_set_hw_type(padapter);
  tmp___1 = rtw_handle_dualmac23a(padapter, 1);
  if (tmp___1 != 1) {
    goto free_adapter;
  } else {
  }
  pnetdev->dev.parent = dvobj_to_dev(dvobj);
  tmp___2 = dvobj_to_dev(dvobj);
  tmp___3 = rtw_wdev_alloc(padapter, tmp___2);
  if (tmp___3 != 0) {
    goto handle_dualmac;
  } else {
  }
  padapter->HalData = kzalloc(9096UL, 208U);
  if ((unsigned long )padapter->HalData == (unsigned long )((void *)0)) {
    goto free_wdev;
  } else {
  }
  rtl8723a_read_chip_version(padapter);
  rtl8723au_chip_configure(padapter);
  rtl8723a_read_adapter_info(padapter);
  tmp___4 = rtw_init_drv_sw23a(padapter);
  if (tmp___4 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
      printk("\016Initialize driver software resource Failed!\n");
    } else {
    }
    goto free_hal_data;
  } else {
  }
  if ((unsigned int )padapter->pwrctrlpriv.bSupportRemoteWakeup != 0U) {
    (dvobj->pusbdev)->do_remote_wakeup = 1U;
    pusb_intf->needs_remote_wakeup = 1U;
    device_init_wakeup(& pusb_intf->dev, 1);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: \n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~~~~\n");
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      tmp___5 = device_may_wakeup(& pusb_intf->dev);
      printk("\016RTL8723AU: \n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~[%d]~~~\n",
             (int )tmp___5);
    } else {
    }
  } else {
  }
  tmp___6 = usb_autopm_get_interface(pusb_intf);
  if (tmp___6 < 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: can\'t get autopm:\n");
    } else {
    }
  } else {
  }
  padapter->pwrctrlpriv.autopm_cnt = 1U;
  tmp___7 = is_broadcast_ether_addr((u8 const *)(& padapter->eeprompriv.mac_addr));
  if ((int )tmp___7) {
    eth_random_addr((u8 *)(& padapter->eeprompriv.mac_addr));
  } else {
    tmp___8 = is_zero_ether_addr((u8 const *)(& padapter->eeprompriv.mac_addr));
    if ((int )tmp___8) {
      eth_random_addr((u8 *)(& padapter->eeprompriv.mac_addr));
    } else {
    }
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: bDriverStopped:%d, bSurpriseRemoved:%d, bup:%d, hw_init_completed:%d\n",
           padapter->bDriverStopped, padapter->bSurpriseRemoved, padapter->bup, (int )padapter->hw_init_completed);
  } else {
  }
  status = 1;
  free_hal_data: ;
  if (status != 1) {
    kfree((void const *)padapter->HalData);
  } else {
  }
  free_wdev: ;
  if (status != 1) {
    rtw_wdev_unregister(padapter->rtw_wdev);
    rtw_wdev_free(padapter->rtw_wdev);
  } else {
  }
  handle_dualmac: ;
  if (status != 1) {
    rtw_handle_dualmac23a(padapter, 0);
  } else {
  }
  free_adapter: ;
  if (status != 1) {
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
      ldv_free_netdev_2281(pnetdev);
    } else {
    }
    padapter = (struct rtw_adapter *)0;
  } else {
  }
  return (padapter);
}
}
static void rtw_usb_if1_deinit(struct rtw_adapter *if1 )
{
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  {
  pnetdev = if1->pnetdev;
  pmlmepriv = & if1->mlmepriv;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    rtw_disassoc_cmd23a(if1, 0U, 0);
  } else {
  }
  free_mlme_ap_info23a(if1);
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
    ldv_unregister_netdev_2282(pnetdev);
  } else {
  }
  rtw_cancel_all_timer23a(if1);
  rtw_dev_unload(if1);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +r871xu_dev_remove, hw_init_completed =%d\n", (int )if1->hw_init_completed);
  } else {
  }
  rtw_handle_dualmac23a(if1, 0);
  if ((unsigned long )if1->rtw_wdev != (unsigned long )((struct wireless_dev *)0)) {
    rtw_wdev_unregister(if1->rtw_wdev);
    rtw_wdev_free(if1->rtw_wdev);
  } else {
  }
  if ((unsigned int )if1->pwrctrlpriv.autopm_cnt == 1U) {
    usb_autopm_put_interface((if1->dvobj)->pusbintf);
    if1->pwrctrlpriv.autopm_cnt = (u8 )((int )if1->pwrctrlpriv.autopm_cnt - 1);
  } else {
  }
  rtw_free_drv_sw23a(if1);
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
    ldv_free_netdev_2283(pnetdev);
  } else {
  }
  return;
}
}
static int rtw_drv_init(struct usb_interface *pusb_intf , struct usb_device_id const *pdid )
{
  struct rtw_adapter *if1 ;
  struct dvobj_priv *dvobj ;
  int status ;
  {
  if1 = (struct rtw_adapter *)0;
  status = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016+rtw_drv_init\n");
  } else {
  }
  dvobj = usb_dvobj_init(pusb_intf);
  if ((unsigned long )dvobj == (unsigned long )((struct dvobj_priv *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
      printk("\016initialize device object priv Failed!\n");
    } else {
    }
    goto exit;
  } else {
  }
  if1 = rtw_usb_if1_init(dvobj, pusb_intf, pdid);
  if ((unsigned long )if1 == (unsigned long )((struct rtw_adapter *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: rtw_init_primary_adapter Failed!\n");
    } else {
    }
    goto free_dvobj;
  } else {
  }
  status = rtw_drv_register_netdev(if1);
  if (status != 1) {
    goto free_if1;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016-871x_drv - drv_init, success!\n");
  } else {
  }
  status = 1;
  free_if1: ;
  if (status != 1 && (unsigned long )if1 != (unsigned long )((struct rtw_adapter *)0)) {
    rtw_usb_if1_deinit(if1);
  } else {
  }
  free_dvobj: ;
  if (status != 1) {
    usb_dvobj_deinit(pusb_intf);
  } else {
  }
  exit: ;
  return (status == 1 ? 0 : -19);
}
}
static void rtw_disconnect(struct usb_interface *pusb_intf )
{
  struct dvobj_priv *dvobj ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  void *tmp ;
  {
  tmp = usb_get_intfdata(pusb_intf);
  dvobj = (struct dvobj_priv *)tmp;
  if ((unsigned long )dvobj == (unsigned long )((struct dvobj_priv *)0)) {
    return;
  } else {
  }
  padapter = dvobj->if1;
  pnetdev = padapter->pnetdev;
  pmlmepriv = & padapter->mlmepriv;
  usb_set_intfdata(pusb_intf, (void *)0);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016+dev_remove()\n");
  } else {
  }
  rtw_pm_set_ips23a(padapter, 0);
  rtw_pm_set_lps23a(padapter, 0);
  LeaveAllPowerSaveMode23a(padapter);
  rtw_usb_if1_deinit(padapter);
  usb_dvobj_deinit(pusb_intf);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016-dev_remove()\n");
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -r871xu_dev_remove, done\n");
  } else {
  }
  return;
}
}
static int rtw_drv_entry(void)
{
  int tmp ;
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016+rtw_drv_entry\n");
  } else {
  }
  tmp = ldv_usb_register_driver_2284(usb_drv, & __this_module, "r8723au");
  return (tmp);
}
}
static void rtw_drv_halt(void)
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
    printk("\016+rtw_drv_halt\n");
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: +rtw_drv_halt\n");
  } else {
  }
  ldv_usb_deregister_2285(usb_drv);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: -rtw_drv_halt\n");
  } else {
  }
  return;
}
}
int ldv_retval_0 ;
int ldv_retval_1 ;
extern void ldv_initialize(void) ;
extern void ldv_check_final_state(void) ;
int ldv_retval_3 ;
int ldv_retval_2 ;
int ldv_retval_7 ;
void ldv_usb_driver_12(void)
{
  void *tmp ;
  {
  tmp = ldv_zalloc(1560UL);
  rtl8723a_usb_drv_group1 = (struct usb_interface *)tmp;
  return;
}
}
int main(void)
{
  struct usb_device_id *ldvarg1 ;
  void *tmp ;
  pm_message_t ldvarg0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  tmp = ldv_zalloc(32UL);
  ldvarg1 = (struct usb_device_id *)tmp;
  ldv_initialize();
  memset((void *)(& ldvarg0), 0, 4UL);
  timer_init_6();
  ldv_state_variable_6 = 1;
  timer_init_11();
  ldv_state_variable_11 = 1;
  timer_init_3();
  ldv_state_variable_3 = 1;
  timer_init_7();
  ldv_state_variable_7 = 1;
  timer_init_9();
  ldv_state_variable_9 = 1;
  ldv_state_variable_12 = 0;
  timer_init_2();
  ldv_state_variable_2 = 1;
  ldv_state_variable_15 = 0;
  ldv_state_variable_14 = 0;
  timer_init_8();
  ldv_state_variable_8 = 1;
  timer_init_1();
  ldv_state_variable_1 = 1;
  timer_init_4();
  ldv_state_variable_4 = 1;
  ref_cnt = 0;
  ldv_state_variable_0 = 1;
  ldv_state_variable_13 = 0;
  timer_init_10();
  ldv_state_variable_10 = 1;
  timer_init_5();
  ldv_state_variable_5 = 1;
  ldv_54544:
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  goto ldv_54515;
  case 1: ;
  goto ldv_54515;
  case 2: ;
  goto ldv_54515;
  case 3: ;
  goto ldv_54515;
  case 4: ;
  goto ldv_54515;
  case 5: ;
  if (ldv_state_variable_12 != 0) {
    tmp___1 = __VERIFIER_nondet_int();
    switch (tmp___1) {
    case 0: ;
    if (ldv_state_variable_12 == 1) {
      ldv_retval_3 = rtw_drv_init(rtl8723a_usb_drv_group1, (struct usb_device_id const *)ldvarg1);
      if (ldv_retval_3 == 0) {
        ldv_state_variable_12 = 2;
        ref_cnt = ref_cnt + 1;
      } else {
      }
    } else {
    }
    goto ldv_54522;
    case 1: ;
    if (ldv_state_variable_12 == 2) {
      ldv_retval_2 = rtw_suspend(rtl8723a_usb_drv_group1, ldvarg0);
      if (ldv_retval_2 == 0) {
        ldv_state_variable_12 = 3;
      } else {
      }
    } else {
    }
    goto ldv_54522;
    case 2: ;
    if (ldv_state_variable_12 == 3) {
      ldv_retval_1 = rtw_resume(rtl8723a_usb_drv_group1);
      if (ldv_retval_1 == 0) {
        ldv_state_variable_12 = 2;
      } else {
      }
    } else {
    }
    goto ldv_54522;
    case 3: ;
    if (ldv_state_variable_12 == 3) {
      ldv_retval_0 = rtw_resume(rtl8723a_usb_drv_group1);
      if (ldv_retval_0 == 0) {
        ldv_state_variable_12 = 2;
      } else {
      }
    } else {
    }
    goto ldv_54522;
    case 4: ;
    if (ldv_state_variable_12 == 3 && usb_counter == 0) {
      rtw_disconnect(rtl8723a_usb_drv_group1);
      ldv_state_variable_12 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    if (ldv_state_variable_12 == 2 && usb_counter == 0) {
      rtw_disconnect(rtl8723a_usb_drv_group1);
      ldv_state_variable_12 = 1;
      ref_cnt = ref_cnt - 1;
    } else {
    }
    goto ldv_54522;
    default:
    ldv_stop();
    }
    ldv_54522: ;
  } else {
  }
  goto ldv_54515;
  case 6: ;
  goto ldv_54515;
  case 7: ;
  if (ldv_state_variable_15 != 0) {
    ldv_main_exported_15();
  } else {
  }
  goto ldv_54515;
  case 8: ;
  if (ldv_state_variable_14 != 0) {
    ldv_main_exported_14();
  } else {
  }
  goto ldv_54515;
  case 9: ;
  goto ldv_54515;
  case 10: ;
  goto ldv_54515;
  case 11: ;
  goto ldv_54515;
  case 12: ;
  if (ldv_state_variable_0 != 0) {
    tmp___2 = __VERIFIER_nondet_int();
    switch (tmp___2) {
    case 0: ;
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
      rtw_drv_halt();
      ldv_state_variable_0 = 3;
      goto ldv_final;
    } else {
    }
    goto ldv_54537;
    case 1: ;
    if (ldv_state_variable_0 == 1) {
      ldv_retval_7 = rtw_drv_entry();
      if (ldv_retval_7 != 0) {
        ldv_state_variable_0 = 3;
        goto ldv_final;
      } else {
      }
      if (ldv_retval_7 == 0) {
        ldv_state_variable_0 = 2;
        ldv_state_variable_14 = 1;
        ldv_initialize_cfg80211_ops_14();
      } else {
      }
    } else {
    }
    goto ldv_54537;
    default:
    ldv_stop();
    }
    ldv_54537: ;
  } else {
  }
  goto ldv_54515;
  case 13: ;
  if (ldv_state_variable_13 != 0) {
    ldv_main_exported_13();
  } else {
  }
  goto ldv_54515;
  case 14: ;
  goto ldv_54515;
  case 15: ;
  goto ldv_54515;
  default:
  ldv_stop();
  }
  ldv_54515: ;
  goto ldv_54544;
  ldv_final:
  ldv_check_final_state();
  return 0;
}
}
void *ldv_kmem_cache_alloc_2264(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2270(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2272(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2274(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2275(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2276(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2277(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2278(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2279(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2280(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
void ldv_free_netdev_2281(struct net_device *dev )
{
  {
  free_netdev(dev);
  ldv_state_variable_15 = 0;
  return;
}
}
void ldv_unregister_netdev_2282(struct net_device *dev )
{
  {
  unregister_netdev(dev);
  ldv_state_variable_15 = 0;
  return;
}
}
void ldv_free_netdev_2283(struct net_device *dev )
{
  {
  free_netdev(dev);
  ldv_state_variable_15 = 0;
  return;
}
}
int ldv_usb_register_driver_2284(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const *ldv_func_arg3 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = usb_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  ldv_state_variable_12 = 1;
  usb_counter = 0;
  ldv_usb_driver_12();
  return (ldv_func_res);
}
}
void ldv_usb_deregister_2285(struct usb_driver *arg )
{
  {
  usb_deregister(arg);
  ldv_state_variable_12 = 0;
  return;
}
}
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
void *ldv_kmem_cache_alloc_2316(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2324(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2332(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2326(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2322(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2330(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2331(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2327(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2328(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2329(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
int ldv_usb_submit_urb_2333(struct urb *ldv_func_arg1 , gfp_t flags ) ;
extern void usb_kill_urb(struct urb * ) ;
void rtl8723au_read_port_cancel(struct rtw_adapter *padapter )
{
  struct recv_buf *precvbuf ;
  int i ;
  {
  precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtl8723au_read_port_cancel");
  } else {
  }
  padapter->bReadPortCancel = 1U;
  i = 0;
  goto ldv_54261;
  ldv_54260: ;
  if ((unsigned long )precvbuf->purb != (unsigned long )((struct urb *)0)) {
    usb_kill_urb(precvbuf->purb);
  } else {
  }
  precvbuf = precvbuf + 1;
  i = i + 1;
  ldv_54261: ;
  if (i <= 3) {
    goto ldv_54260;
  } else {
  }
  usb_kill_urb(padapter->recvpriv.int_in_urb);
  return;
}
}
static void usb_write_port23a_complete(struct urb *purb )
{
  struct xmit_buf *pxmitbuf ;
  struct rtw_adapter *padapter ;
  struct xmit_priv *pxmitpriv ;
  struct hal_data_8723a *phaldata ;
  unsigned long irqL ;
  {
  pxmitbuf = (struct xmit_buf *)purb->context;
  padapter = pxmitbuf->padapter;
  pxmitpriv = & padapter->xmitpriv;
  switch ((int )pxmitbuf->flags) {
  case 0:
  pxmitpriv->voq_cnt = pxmitpriv->voq_cnt - 1;
  goto ldv_54272;
  case 1:
  pxmitpriv->viq_cnt = pxmitpriv->viq_cnt - 1;
  goto ldv_54272;
  case 2:
  pxmitpriv->beq_cnt = pxmitpriv->beq_cnt - 1;
  goto ldv_54272;
  case 3:
  pxmitpriv->bkq_cnt = pxmitpriv->bkq_cnt - 1;
  goto ldv_54272;
  case 6:
  rtw_chk_hi_queue_cmd23a(padapter);
  goto ldv_54272;
  default: ;
  goto ldv_54272;
  }
  ldv_54272: ;
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bWritePortCancel != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_write_port23a_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
             padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): TX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bWritePortCancel(%d) pxmitbuf->ext_tag(%x)\n",
             "usb_write_port23a_complete", padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel, (int )pxmitbuf->ext_tag);
    } else {
    }
    goto check_completion;
  } else {
  }
  if (purb->status != 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_write_port23a_complete : purb->status(%d) != 0\n", purb->status);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: ###=> urb_write_port_complete status(%d)\n", purb->status);
    } else {
    }
    if (purb->status == -32 || purb->status == -71) {
      sreset_set_wifi_error_status23a(padapter, 4U);
    } else
    if (purb->status == -115) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
        printk("\016usb_write_port23a_complete: EINPROGESS\n");
      } else {
      }
      goto check_completion;
    } else
    if (purb->status == -2) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s: -ENOENT\n", "usb_write_port23a_complete");
      } else {
      }
      goto check_completion;
    } else
    if (purb->status == -104) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s: -ECONNRESET\n", "usb_write_port23a_complete");
      } else {
      }
      goto check_completion;
    } else
    if (purb->status == -108) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
        printk("\016usb_write_port23a_complete: ESHUTDOWN\n");
      } else {
      }
      padapter->bDriverStopped = 1;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
        printk("\016usb_write_port23a_complete:bDriverStopped = true\n");
      } else {
      }
      goto check_completion;
    } else {
      padapter->bSurpriseRemoved = 1;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: bSurpriseRemoved = true\n");
      } else {
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
        printk("\016usb_write_port23a_complete:bSurpriseRemoved = true\n");
      } else {
      }
      goto check_completion;
    }
  } else {
  }
  phaldata = (struct hal_data_8723a *)padapter->HalData;
  phaldata->srestpriv.last_tx_complete_time = jiffies;
  check_completion:
  ldv_spin_lock();
  rtw23a_sctx_done_err(& pxmitbuf->sctx, purb->status != 0 ? 5 : 0);
  spin_unlock_irqrestore(& pxmitpriv->lock_sctx, irqL);
  rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
  tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  return;
}
}
int rtl8723au_write_port(struct rtw_adapter *padapter , u32 addr , u32 cnt , struct xmit_buf *pxmitbuf )
{
  struct urb *purb ;
  struct dvobj_priv *pdvobj ;
  struct xmit_priv *pxmitpriv ;
  struct xmit_frame *pxmitframe ;
  struct usb_device *pusbd ;
  unsigned long irqL ;
  unsigned int pipe ;
  unsigned int ep_num ;
  int status ;
  int ret ;
  unsigned int tmp ;
  struct hal_data_8723a *phaldata ;
  {
  purb = (struct urb *)0;
  pdvobj = padapter->dvobj;
  pxmitpriv = & padapter->xmitpriv;
  pusbd = pdvobj->pusbdev;
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
    printk("\016+usb_write_port23a\n");
  } else {
  }
  if ((padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) || (unsigned int )padapter->pwrctrlpriv.pnp_bstop_trx != 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_write_port23a:( padapter->bDriverStopped || padapter->bSurpriseRemoved || adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n");
    } else {
    }
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 7);
    goto exit;
  } else {
  }
  pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
  ldv_spin_lock();
  switch (addr) {
  case 0U:
  pxmitpriv->voq_cnt = pxmitpriv->voq_cnt + 1;
  pxmitbuf->flags = 0U;
  goto ldv_54298;
  case 1U:
  pxmitpriv->viq_cnt = pxmitpriv->viq_cnt + 1;
  pxmitbuf->flags = 1U;
  goto ldv_54298;
  case 2U:
  pxmitpriv->beq_cnt = pxmitpriv->beq_cnt + 1;
  pxmitbuf->flags = 2U;
  goto ldv_54298;
  case 3U:
  pxmitpriv->bkq_cnt = pxmitpriv->bkq_cnt + 1;
  pxmitbuf->flags = 3U;
  goto ldv_54298;
  case 6U:
  pxmitbuf->flags = 6U;
  goto ldv_54298;
  default:
  pxmitbuf->flags = 5U;
  goto ldv_54298;
  }
  ldv_54298:
  spin_unlock_irqrestore(& pxmitpriv->lock, irqL);
  purb = pxmitbuf->pxmit_urb[0];
  ep_num = (unsigned int )pdvobj->Queue2Pipe[addr];
  tmp = __create_pipe(pusbd, ep_num);
  pipe = tmp | 3221225472U;
  usb_fill_bulk_urb(purb, pusbd, pipe, (void *)pxmitframe->buf_addr, (int )cnt, & usb_write_port23a_complete,
                    (void *)pxmitbuf);
  status = ldv_usb_submit_urb_2333(purb, 32U);
  if (status == 0) {
    phaldata = (struct hal_data_8723a *)padapter->HalData;
    phaldata->srestpriv.last_tx_time = jiffies;
  } else {
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 5);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: usb_write_port23a, status =%d\n", status);
    } else {
    }
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
      printk("\016usb_write_port23a(): usb_submit_urb, status =%x\n", status);
    } else {
    }
    switch (status) {
    case -19:
    padapter->bDriverStopped = 1;
    goto ldv_54306;
    default: ;
    goto ldv_54306;
    }
    ldv_54306: ;
    goto exit;
  }
  ret = 1;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
    printk("\016-usb_write_port23a\n");
  } else {
  }
  exit: ;
  if (ret != 1) {
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
  } else {
  }
  return (ret);
}
}
void rtl8723au_write_port_cancel(struct rtw_adapter *padapter )
{
  struct xmit_buf *pxmitbuf ;
  struct list_head *plist ;
  int j ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "rtl8723au_write_port_cancel");
  } else {
  }
  padapter->bWritePortCancel = 1U;
  plist = padapter->xmitpriv.xmitbuf_list.next;
  goto ldv_54321;
  ldv_54320:
  __mptr = (struct list_head const *)plist;
  pxmitbuf = (struct xmit_buf *)__mptr + 0xfffffffffffffff0UL;
  j = 0;
  goto ldv_54318;
  ldv_54317: ;
  if ((unsigned long )pxmitbuf->pxmit_urb[j] != (unsigned long )((struct urb *)0)) {
    usb_kill_urb(pxmitbuf->pxmit_urb[j]);
  } else {
  }
  j = j + 1;
  ldv_54318: ;
  if (j <= 7) {
    goto ldv_54317;
  } else {
  }
  plist = plist->next;
  ldv_54321: ;
  if ((unsigned long )(& padapter->xmitpriv.xmitbuf_list) != (unsigned long )plist) {
    goto ldv_54320;
  } else {
  }
  plist = padapter->xmitpriv.xmitextbuf_list.next;
  goto ldv_54329;
  ldv_54328:
  __mptr___0 = (struct list_head const *)plist;
  pxmitbuf = (struct xmit_buf *)__mptr___0 + 0xfffffffffffffff0UL;
  j = 0;
  goto ldv_54326;
  ldv_54325: ;
  if ((unsigned long )pxmitbuf->pxmit_urb[j] != (unsigned long )((struct urb *)0)) {
    usb_kill_urb(pxmitbuf->pxmit_urb[j]);
  } else {
  }
  j = j + 1;
  ldv_54326: ;
  if (j <= 7) {
    goto ldv_54325;
  } else {
  }
  plist = plist->next;
  ldv_54329: ;
  if ((unsigned long )(& padapter->xmitpriv.xmitextbuf_list) != (unsigned long )plist) {
    goto ldv_54328;
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_2316(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2322(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2324(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2326(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2327(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2328(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2329(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2330(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2331(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2332(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_usb_submit_urb_2333(struct urb *ldv_func_arg1 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = usb_submit_urb(ldv_func_arg1, flags);
  return (tmp);
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
void *ldv_kmem_cache_alloc_2360(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2368(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2376(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2370(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2366(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2374(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2375(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2371(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2372(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2373(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
__inline static u16 skb_get_queue_mapping(struct sk_buff const *skb )
{
  {
  return ((u16 )skb->queue_mapping);
}
}
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index )
{
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  {
  tmp = netdev_get_tx_queue((struct net_device const *)dev, (unsigned int )queue_index);
  txq = tmp;
  netif_tx_stop_queue(txq);
  return;
}
}
__inline static bool __netif_subqueue_stopped(struct net_device const *dev , u16 queue_index )
{
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;
  {
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
  txq = tmp;
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue const *)txq);
  return (tmp___0);
}
}
__inline static void netif_wake_subqueue(struct net_device *dev , u16 queue_index )
{
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  int tmp___0 ;
  {
  tmp = netdev_get_tx_queue((struct net_device const *)dev, (unsigned int )queue_index);
  txq = tmp;
  tmp___0 = test_and_clear_bit(0L, (unsigned long volatile *)(& txq->state));
  if (tmp___0 != 0) {
    __netif_schedule(txq->qdisc);
  } else {
  }
  return;
}
}
struct urb *ldv_usb_alloc_urb_2377(int ldv_func_arg1 , gfp_t flags ) ;
int rtw_os_xmit_resource_alloc23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ,
                                  u32 alloc_sz )
{
  int i ;
  void *tmp ;
  {
  tmp = kzalloc((size_t )alloc_sz, 208U);
  pxmitbuf->pallocated_buf = (u8 *)tmp;
  if ((unsigned long )pxmitbuf->pallocated_buf == (unsigned long )((u8 *)0U)) {
    return (0);
  } else {
  }
  pxmitbuf->pbuf = (u8 *)(((unsigned long )pxmitbuf->pallocated_buf + 511UL) & 0xfffffffffffffe00UL);
  i = 0;
  goto ldv_51420;
  ldv_51419:
  pxmitbuf->pxmit_urb[i] = ldv_usb_alloc_urb_2377(0, 208U);
  if ((unsigned long )pxmitbuf->pxmit_urb[i] == (unsigned long )((struct urb *)0)) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: pxmitbuf->pxmit_urb[i]==NULL");
    } else {
    }
    return (0);
  } else {
  }
  i = i + 1;
  ldv_51420: ;
  if (i <= 7) {
    goto ldv_51419;
  } else {
  }
  return (1);
}
}
void rtw_os_xmit_resource_free23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf )
{
  int i ;
  {
  i = 0;
  goto ldv_51428;
  ldv_51427:
  usb_free_urb(pxmitbuf->pxmit_urb[i]);
  i = i + 1;
  ldv_51428: ;
  if (i <= 7) {
    goto ldv_51427;
  } else {
  }
  kfree((void const *)pxmitbuf->pallocated_buf);
  return;
}
}
void rtw_os_pkt_complete23a(struct rtw_adapter *padapter , struct sk_buff *pkt )
{
  struct xmit_priv *pxmitpriv ;
  u16 queue ;
  bool tmp ;
  bool tmp___0 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  queue = skb_get_queue_mapping((struct sk_buff const *)pkt);
  if ((unsigned int )padapter->registrypriv.wifi_spec != 0U) {
    tmp = __netif_subqueue_stopped((struct net_device const *)padapter->pnetdev,
                                   (int )queue);
    if ((int )tmp && (pxmitpriv->hwxmits + (unsigned long )queue)->accnt <= 101) {
      netif_wake_subqueue(padapter->pnetdev, (int )queue);
    } else {
    }
  } else {
    tmp___0 = __netif_subqueue_stopped((struct net_device const *)padapter->pnetdev,
                                       (int )queue);
    if ((int )tmp___0) {
      netif_wake_subqueue(padapter->pnetdev, (int )queue);
    } else {
    }
  }
  dev_kfree_skb_any(pkt);
  return;
}
}
void rtw_os_xmit_complete23a(struct rtw_adapter *padapter , struct xmit_frame *pxframe )
{
  {
  if ((unsigned long )pxframe->pkt != (unsigned long )((struct sk_buff *)0)) {
    rtw_os_pkt_complete23a(padapter, pxframe->pkt);
  } else {
  }
  pxframe->pkt = (struct sk_buff *)0;
  return;
}
}
void rtw_os_xmit_schedule23a(struct rtw_adapter *padapter )
{
  struct xmit_priv *pxmitpriv ;
  s32 tmp ;
  {
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {
  }
  pxmitpriv = & padapter->xmitpriv;
  spin_lock_bh(& pxmitpriv->lock);
  tmp = rtw_txframes_pending23a(padapter);
  if (tmp != 0) {
    tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  } else {
  }
  spin_unlock_bh(& pxmitpriv->lock);
  return;
}
}
static void rtw_check_xmit_resource(struct rtw_adapter *padapter , struct sk_buff *pkt )
{
  struct xmit_priv *pxmitpriv ;
  u16 queue ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  {
  pxmitpriv = & padapter->xmitpriv;
  queue = skb_get_queue_mapping((struct sk_buff const *)pkt);
  if ((unsigned int )padapter->registrypriv.wifi_spec != 0U) {
    if ((pxmitpriv->hwxmits + (unsigned long )queue)->accnt > 102) {
      netif_stop_subqueue(padapter->pnetdev, (int )queue);
    } else {
    }
  } else
  if (pxmitpriv->free_xmitframe_cnt <= 4) {
    tmp = netdev_get_tx_queue((struct net_device const *)padapter->pnetdev, (unsigned int )queue);
    tmp___0 = netif_tx_queue_stopped((struct netdev_queue const *)tmp);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      netif_stop_subqueue(padapter->pnetdev, (int )queue);
    } else {
    }
  } else {
  }
  return;
}
}
int rtw_xmit23a_entry23a(struct sk_buff *skb , struct net_device *pnetdev )
{
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  int tmp___0 ;
  {
  tmp = netdev_priv((struct net_device const *)pnetdev);
  padapter = (struct rtw_adapter *)tmp;
  pxmitpriv = & padapter->xmitpriv;
  res = 0;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
    printk("\016+xmit_enry\n");
  } else {
  }
  tmp___0 = rtw_if_up23a(padapter);
  if (tmp___0 == 0) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 4);
      printk("\016rtw_xmit23a_entry23a: rtw_if_up23a fail\n");
    } else {
    }
    goto drop_packet;
  } else {
  }
  rtw_check_xmit_resource(padapter, skb);
  res = rtw_xmit23a(padapter, skb);
  if (res < 0) {
    goto drop_packet;
  } else {
  }
  pxmitpriv->tx_pkts = pxmitpriv->tx_pkts + 1ULL;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 7);
    printk("\016rtw_xmit23a_entry23a: tx_pkts=%d\n", (unsigned int )pxmitpriv->tx_pkts);
  } else {
  }
  goto exit;
  drop_packet:
  pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
  dev_kfree_skb_any(skb);
  if (GlobalDebugLevel23A > 5U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 6);
    printk("\016rtw_xmit23a_entry23a: drop, tx_drop=%d\n", (unsigned int )pxmitpriv->tx_drop);
  } else {
  }
  exit: ;
  return (0);
}
}
void *ldv_kmem_cache_alloc_2360(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2366(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2368(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2370(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2371(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2372(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2373(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2374(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2375(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2376(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct urb *ldv_usb_alloc_urb_2377(int ldv_func_arg1 , gfp_t flags )
{
  struct urb *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = usb_alloc_urb(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_mod_timer_2421(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_2426(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_2428(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_2436(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_2422(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2423(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2424(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2425(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2427(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2429(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2430(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2431(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2432(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2433(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2434(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2435(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_2437(struct timer_list *ldv_func_arg1 ) ;
void *ldv_kmem_cache_alloc_2404(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2412(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2420(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2414(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2410(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2418(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2419(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2415(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2416(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2417(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void BT_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
void BTHCI_EventParse(struct rtw_adapter *padapter , void *pEvntData , u32 dataLen ) ;
u8 BTHCI_HsConnectionEstablished(struct rtw_adapter *padapter ) ;
void BTHCI_UpdateBTProfileRTKToMoto(struct rtw_adapter *padapter ) ;
void BTHCI_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) ;
void BTHCI_StateMachine(struct rtw_adapter *padapter , u8 StateToEnter , enum hci_state_with_cmd StateCmd ,
                        u8 EntryNum ) ;
void BTHCI_DisconnectPeer(struct rtw_adapter *padapter , u8 EntryNum ) ;
void BTHCI_EventNumOfCompletedDataBlocks(struct rtw_adapter *padapter ) ;
void BTHCI_EventAMPStatusChange(struct rtw_adapter *padapter , u8 AMP_Status ) ;
void BTHCI_DisconnectAll(struct rtw_adapter *padapter ) ;
enum hci_status BTHCI_HandleHCICMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) ;
void BTDM_1AntSignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
void BTDM_1AntForDhcp(struct rtw_adapter *padapter ) ;
void BTDM_1AntBtCoexist8723A(struct rtw_adapter *padapter ) ;
void BTDM_2AntBtCoexist8723A(struct rtw_adapter *padapter ) ;
void BTDM_SetFwChnlInfo(struct rtw_adapter *padapter , enum rt_media_status mstatus ) ;
u8 BTDM_IsWifiConnectionExist(struct rtw_adapter *padapter ) ;
void BTDM_SetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 , u8 byte3 ,
                  u8 byte4 , u8 byte5 ) ;
void BTDM_QueryBtInformation(struct rtw_adapter *padapter ) ;
void BTDM_SetSwRfRxLpfCorner(struct rtw_adapter *padapter , u8 type ) ;
void BTDM_SetSwPenaltyTxRateAdaptive(struct rtw_adapter *padapter , u8 raType ) ;
void BTDM_SetFwDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) ;
u8 BTDM_BtProfileSupport(struct rtw_adapter *padapter ) ;
void BTDM_SingleAnt(struct rtw_adapter *padapter , u8 bSingleAntOn , u8 bInterruptOn ,
                    u8 bMultiNAVOn ) ;
void BTDM_CheckBTIdleChange1Ant(struct rtw_adapter *padapter ) ;
void BTDM_DiminishWiFi(struct rtw_adapter *padapter , u8 bDACOn , u8 bInterruptOn ,
                       u8 DACSwingLevel , u8 bNAVOn ) ;
void BTDM_CheckAntSelMode(struct rtw_adapter *padapter ) ;
void BTDM_FwC2hBtRssi(struct rtw_adapter *padapter , u8 *tmpBuf ) ;
void BTDM_DisplayBtCoexInfo(struct rtw_adapter *padapter ) ;
void BTDM_RejectAPAggregatedPacket(struct rtw_adapter *padapter , u8 bReject ) ;
u8 BTDM_IsHT40(struct rtw_adapter *padapter ) ;
u8 BTDM_Legacy(struct rtw_adapter *padapter ) ;
void BTDM_CheckWiFiState(struct rtw_adapter *padapter ) ;
s32 BTDM_GetRxSS(struct rtw_adapter *padapter ) ;
u8 BTDM_CheckCoexBcnRssiState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                              u8 RssiThresh1 ) ;
u8 BTDM_CheckCoexRSSIState1(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                            u8 RssiThresh1 ) ;
u8 BTDM_CheckCoexRSSIState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                           u8 RssiThresh1 ) ;
void BTDM_Balance(struct rtw_adapter *padapter , u8 bBalanceOn , u8 ms0 , u8 ms1 ) ;
void BTDM_AGCTable(struct rtw_adapter *padapter , u8 type ) ;
void BTDM_BBBackOffLevel(struct rtw_adapter *padapter , u8 type ) ;
void BTDM_FWCoexAllOff(struct rtw_adapter *padapter ) ;
void BTDM_SWCoexAllOff(struct rtw_adapter *padapter ) ;
void BTDM_HWCoexAllOff(struct rtw_adapter *padapter ) ;
void BTDM_CoexAllOff(struct rtw_adapter *padapter ) ;
void BTDM_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
void BTDM_UpdateCoexState(struct rtw_adapter *padapter ) ;
u8 BTDM_IsSameCoexistState(struct rtw_adapter *padapter ) ;
void BTDM_PWDBMonitor(struct rtw_adapter *padapter ) ;
u8 BTDM_IsBTBusy(struct rtw_adapter *padapter ) ;
u8 BTDM_IsWifiBusy(struct rtw_adapter *padapter ) ;
u8 BTDM_IsCoexistStateChanged(struct rtw_adapter *padapter ) ;
u8 BTDM_IsWifiUplink(struct rtw_adapter *padapter ) ;
u8 BTDM_IsWifiDownlink(struct rtw_adapter *padapter ) ;
u8 BTDM_IsBTHSMode(struct rtw_adapter *padapter ) ;
u8 BTDM_IsBTUplink(struct rtw_adapter *padapter ) ;
u8 BTDM_IsBTDownlink(struct rtw_adapter *padapter ) ;
void BTDM_AdjustForBtOperation(struct rtw_adapter *padapter ) ;
void BTDM_ForHalt(struct rtw_adapter *padapter ) ;
void BTDM_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) ;
void BTDM_WifiAssociateNotify(struct rtw_adapter *padapter , u8 action ) ;
void BTDM_ResetActionProfileState(struct rtw_adapter *padapter ) ;
void BTDM_SetBtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) ;
u8 BTDM_IsActionSCO(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionHID(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionA2DP(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionPAN(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionHIDA2DP(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionHIDPAN(struct rtw_adapter *padapter ) ;
u8 BTDM_IsActionPANA2DP(struct rtw_adapter *padapter ) ;
u32 BTDM_BtTxRxCounterH(struct rtw_adapter *padapter ) ;
u32 BTDM_BtTxRxCounterL(struct rtw_adapter *padapter ) ;
u8 HALBT_GetPGAntNum(struct rtw_adapter *padapter ) ;
void HALBT_SetKey(struct rtw_adapter *padapter , u8 EntryNum ) ;
void HALBT_RemoveKey(struct rtw_adapter *padapter , u8 EntryNum ) ;
u8 HALBT_BTChipType(struct rtw_adapter *padapter ) ;
void HALBT_SetRtsCtsNoLenLimit(struct rtw_adapter *padapter ) ;
u32 BTCoexDbgLevel ;
u32 BTCoexDbgLevel = 0U;
static u8 BT_Operation(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
static u8 BT_IsLegalChannel(struct rtw_adapter *padapter , u8 channel )
{
  struct rt_channel_info *pChanneList ;
  u8 channelLen ;
  u8 i ;
  {
  pChanneList = (struct rt_channel_info *)0;
  pChanneList = (struct rt_channel_info *)(& padapter->mlmeextpriv.channel_set);
  channelLen = padapter->mlmeextpriv.max_chan_nums;
  i = 0U;
  goto ldv_54357;
  ldv_54356: ;
  if (BTCoexDbgLevel == 1U) {
    printk("Check if chnl(%d) in channel plan contains bt target chnl(%d) for BT connection\n",
           (int )(pChanneList + (unsigned long )i)->ChannelNum, (int )channel);
  } else {
  }
  if ((int )(pChanneList + (unsigned long )i)->ChannelNum == (int )channel || (int )channel == (int )(pChanneList + (unsigned long )i)->ChannelNum + 2) {
    return (channel);
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54357: ;
  if ((int )i < (int )channelLen) {
    goto ldv_54356;
  } else {
  }
  return (0U);
}
}
void BT_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt )
{
  {
  BTDM_SignalCompensation(padapter, rssi_wifi, rssi_bt);
  return;
}
}
void rtl8723a_BT_wifiscan_notify(struct rtw_adapter *padapter , u8 scanType )
{
  {
  BTHCI_WifiScanNotify(padapter, (int )scanType);
  BTDM_CheckAntSelMode(padapter);
  BTDM_WifiScanNotify(padapter, (int )scanType);
  return;
}
}
void rtl8723a_BT_wifiassociate_notify(struct rtw_adapter *padapter , u8 action )
{
  {
  if ((unsigned int )action != 0U) {
    BTDM_CheckAntSelMode(padapter);
  } else {
  }
  BTDM_WifiAssociateNotify(padapter, (int )action);
  return;
}
}
void BT_HaltProcess(struct rtw_adapter *padapter )
{
  {
  BTDM_ForHalt(padapter);
  return;
}
}
static enum rt_status PlatformIndicateBTEvent(struct rtw_adapter *padapter , void *pEvntData ,
                                              u32 dataLen )
{
  enum rt_status rt_status ;
  u32 __i ;
  u8 *ptr ;
  {
  rt_status = 1;
  if (BTCoexDbgLevel == 1U) {
    printk("BT event start, %d bytes data to Transferred!!\n", dataLen);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pEvntData;
    printk("To transfer Hex Data :\n");
    __i = 0U;
    goto ldv_54384;
    ldv_54383:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_54384: ;
    if (__i < dataLen) {
      goto ldv_54383;
    } else {
    }
    printk("\n");
  } else {
  }
  BTHCI_EventParse(padapter, pEvntData, dataLen);
  printk("\f%s: Linux has no way to report BT event!!\n", "PlatformIndicateBTEvent");
  if (BTCoexDbgLevel == 1U) {
    printk("BT event end, %s\n", (unsigned int )rt_status == 0U ? (char *)"SUCCESS" : (char *)"FAIL");
  } else {
  }
  return (rt_status);
}
}
static u8 bthci_GetLocalChannel(struct rtw_adapter *padapter )
{
  {
  return (padapter->mlmeextpriv.cur_channel);
}
}
static u8 bthci_GetCurrentEntryNum(struct rtw_adapter *padapter , u8 PhyHandle )
{
  struct bt_30info *pBTInfo ;
  u8 i ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  i = 0U;
  goto ldv_54397;
  ldv_54396: ;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U && (int )pBTInfo->BtAsocEntry[(int )i].PhyLinkCmdData.BtPhyLinkhandle == (int )PhyHandle) {
    return (i);
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54397: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_54396;
  } else {
  }
  return (255U);
}
}
static void bthci_DecideBTChannel(struct rtw_adapter *padapter , u8 EntryNum )
{
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct chnl_txpower_triple *pTriple_subband ;
  struct common_triple *pTriple ;
  u8 i ;
  u8 j ;
  u8 localchnl ;
  u8 firstRemoteLegalChnlInTriplet ;
  u8 regulatory_skipLen ;
  u8 subbandTripletCnt ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  {
  pTriple_subband = (struct chnl_txpower_triple *)0;
  firstRemoteLegalChnlInTriplet = 0U;
  regulatory_skipLen = 0U;
  subbandTripletCnt = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtMgnt->CheckChnlIsSuit = 1U;
  localchnl = bthci_GetLocalChannel(padapter);
  pTriple = (struct common_triple *)(& pBtHciInfo->BTPreChnllist) + 3U;
  i = 0U;
  goto ldv_54420;
  ldv_54419: ;
  if ((unsigned int )pTriple->byte_1st == 201U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Find Regulatory ID, regulatory class = %d\n", (int )pTriple->byte_2nd);
    } else {
    }
    regulatory_skipLen = (unsigned int )regulatory_skipLen + 3U;
    pTriple_subband = (struct chnl_txpower_triple *)0;
    goto ldv_54415;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("Find Sub-band triplet \n");
    } else {
    }
    subbandTripletCnt = (u8 )((int )subbandTripletCnt + 1);
    pTriple_subband = (struct chnl_txpower_triple *)pTriple;
    j = pTriple_subband->FirstChnl;
    goto ldv_54418;
    ldv_54417: ;
    if (BTCoexDbgLevel == 1U) {
      printk(" Check if chnl(%d) is legal\n", (int )j);
    } else {
    }
    tmp___2 = BT_IsLegalChannel(padapter, (int )j);
    if ((unsigned int )tmp___2 != 0U) {
      firstRemoteLegalChnlInTriplet = j;
      if (BTCoexDbgLevel == 1U) {
        printk("Find first remote legal channel : %d\n", (int )firstRemoteLegalChnlInTriplet);
      } else {
      }
      tmp = check_fwstate(pmlmepriv, 49);
      if (tmp) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      if (tmp___0) {
        tmp___1 = BTHCI_HsConnectionEstablished(padapter);
        if ((unsigned int )tmp___1 == 0U) {
          pBtMgnt->BTChannel = firstRemoteLegalChnlInTriplet;
          if (BTCoexDbgLevel == 1U) {
            printk("Remote legal channel (%d) is selected, Local not connect to any!!\n",
                   (int )pBtMgnt->BTChannel);
          } else {
          }
          return;
        } else {
          goto _L;
        }
      } else
      _L:
      if ((int )localchnl >= (int )firstRemoteLegalChnlInTriplet && (int )localchnl < (int )pTriple_subband->FirstChnl + (int )pTriple_subband->NumChnls) {
        pBtMgnt->BTChannel = localchnl;
        if (BTCoexDbgLevel == 1U) {
          printk("Local channel (%d) is selected, wifi or BT connection exists\n",
                 (int )pBtMgnt->BTChannel);
        } else {
        }
        return;
      } else {
      }
      goto ldv_54416;
    } else {
    }
    j = (u8 )((int )j + 1);
    ldv_54418: ;
    if ((int )j < (int )pTriple_subband->FirstChnl + (int )pTriple_subband->NumChnls) {
      goto ldv_54417;
    } else {
    }
    ldv_54416: ;
  }
  ldv_54415:
  i = (unsigned int )i + 3U;
  pTriple = pTriple + 1;
  ldv_54420: ;
  if ((int )i < (int )pBtHciInfo->BtPreChnlListLen + -3) {
    goto ldv_54419;
  } else {
  }
  if ((unsigned int )subbandTripletCnt != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("There are %d sub band triplet exists, ", (int )subbandTripletCnt);
    } else {
    }
    if ((unsigned int )firstRemoteLegalChnlInTriplet == 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("no legal channel is found!!\n");
      } else {
      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("Remote Legal channel is found but not match to local(wifi connection exists)!!\n");
    } else {
    }
    pBtMgnt->CheckChnlIsSuit = 0U;
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("No sub band triplet exists!!\n");
  } else {
  }
  pBtMgnt->BTChannel = localchnl;
  if (BTCoexDbgLevel == 1U) {
    printk("Local channel (%d) is selected!!\n", (int )pBtMgnt->BTChannel);
  } else {
  }
  return;
}
}
static u8 bthci_GetAssocInfo(struct rtw_adapter *padapter , u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 tempBuf[256U] ;
  u8 i ;
  u8 BaseMemoryShift ;
  u16 TotalLen ;
  struct amp_assoc_structure *pAmpAsoc ;
  size_t __len ;
  void *__ret ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  u32 __i___1 ;
  u8 *ptr___1 ;
  size_t __len___1 ;
  void *__ret___1 ;
  u32 __i___2 ;
  u8 *ptr___2 ;
  size_t __len___2 ;
  void *__ret___2 ;
  {
  i = 0U;
  BaseMemoryShift = 0U;
  TotalLen = 0U;
  if (BTCoexDbgLevel == 1U) {
    printk("GetAssocInfo start\n");
  } else {
  }
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar == 0U) {
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen <= 247U) {
      TotalLen = pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen;
    } else
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen == 248U) {
      TotalLen = 248U;
    } else {
    }
  } else
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar != 0U) {
    TotalLen = pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar;
  } else {
  }
  goto ldv_54473;
  ldv_54472: ;
  if (BTCoexDbgLevel == 1U) {
    printk("GetAssocInfo, TotalLen =%d, BaseMemoryShift =%d\n", (int )TotalLen, (int )BaseMemoryShift);
  } else {
  }
  __len = (size_t )((int )TotalLen - (int )BaseMemoryShift);
  __ret = memcpy((void *)(& tempBuf), (void const *)pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )BaseMemoryShift,
                           __len);
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& tempBuf);
    printk("GetAssocInfo :\n");
    __i = 0U;
    goto ldv_54439;
    ldv_54438:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_54439: ;
    if ((unsigned int )TotalLen - (unsigned int )BaseMemoryShift > __i) {
      goto ldv_54438;
    } else {
    }
    printk("\n");
  } else {
  }
  pAmpAsoc = (struct amp_assoc_structure *)(& tempBuf);
  pAmpAsoc->Length = pAmpAsoc->Length;
  BaseMemoryShift = (unsigned int )((int )((u8 )pAmpAsoc->Length) + (int )BaseMemoryShift) + 3U;
  if (BTCoexDbgLevel == 1U) {
    printk("TypeID = 0x%x, ", (int )pAmpAsoc->TypeID);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    ptr___0 = (u8 *)(& pAmpAsoc->Data);
    printk("Hex Data: \n");
    __i___0 = 0U;
    goto ldv_54444;
    ldv_54443:
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i___0 + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i___0 = __i___0 + 1U;
    ldv_54444: ;
    if ((u32 )pAmpAsoc->Length > __i___0) {
      goto ldv_54443;
    } else {
    }
    printk("\n");
  } else {
  }
  switch ((int )pAmpAsoc->TypeID) {
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_MAC_ADDR\n");
  } else {
  }
  if ((unsigned int )pAmpAsoc->Length > 6U) {
    return (0U);
  } else {
  }
  __len___0 = 6UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr),
                         (void const *)(& pAmpAsoc->Data), __len___0);
  } else {
    __ret___0 = memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr),
                                 (void const *)(& pAmpAsoc->Data), __len___0);
  }
  if (BTCoexDbgLevel == 1U) {
    ptr___1 = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr);
    printk("Remote Mac address \n");
    printk(" ");
    __i___1 = 0U;
    goto ldv_54453;
    ldv_54452:
    printk("%02X%s", (int )*(ptr___1 + (unsigned long )__i___1), __i___1 == 5U ? (char *)"" : (char *)"-");
    __i___1 = __i___1 + 1U;
    ldv_54453: ;
    if (__i___1 <= 5U) {
      goto ldv_54452;
    } else {
    }
    printk("\n");
  } else {
  }
  goto ldv_54455;
  case 2: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_PREFERRED_CHANNEL_LIST\n");
  } else {
  }
  pBtHciInfo->BtPreChnlListLen = pAmpAsoc->Length;
  __len___1 = (size_t )pBtHciInfo->BtPreChnlListLen;
  __ret___1 = memcpy((void *)(& pBtHciInfo->BTPreChnllist), (void const *)(& pAmpAsoc->Data),
                               __len___1);
  if (BTCoexDbgLevel == 1U) {
    ptr___2 = (u8 *)(& pBtHciInfo->BTPreChnllist);
    printk("Preferred channel list : \n");
    __i___2 = 0U;
    goto ldv_54463;
    ldv_54462:
    printk("%02X%s", (int )*(ptr___2 + (unsigned long )__i___2), ((__i___2 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i___2 + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i___2 = __i___2 + 1U;
    ldv_54463: ;
    if ((u32 )pBtHciInfo->BtPreChnlListLen > __i___2) {
      goto ldv_54462;
    } else {
    }
    printk("\n");
  } else {
  }
  bthci_DecideBTChannel(padapter, (int )EntryNum);
  goto ldv_54455;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_CONNECTED_CHANNEL\n");
  } else {
  }
  pBtHciInfo->BTConnectChnlListLen = pAmpAsoc->Length;
  __len___2 = (size_t )pBtHciInfo->BTConnectChnlListLen;
  __ret___2 = memcpy((void *)(& pBtHciInfo->BTConnectChnllist), (void const *)(& pAmpAsoc->Data),
                               __len___2);
  goto ldv_54455;
  case 4: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_80211_PAL_CAP_LIST\n");
  } else {
  }
  pBTInfo->BtAsocEntry[(int )EntryNum].BTCapability = *((u32 *)(& pAmpAsoc->Data));
  goto ldv_54455;
  case 5:
  pBtHciInfo->BTPalVersion = *((u8 *)(& pAmpAsoc->Data));
  pBtHciInfo->BTPalCompanyID = *((u16 *)(& pAmpAsoc->Data) + 1U);
  pBtHciInfo->BTPalsubversion = *((u16 *)(& pAmpAsoc->Data) + 3U);
  if (BTCoexDbgLevel == 1U) {
    printk("==> AMP_80211_PAL_VISION PalVersion  0x%x, PalCompanyID  0x%x, Palsubversion 0x%x\n",
           (int )pBtHciInfo->BTPalVersion, (int )pBtHciInfo->BTPalCompanyID, (int )pBtHciInfo->BTPalsubversion);
  } else {
  }
  goto ldv_54455;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("==> Unsupport TypeID !!\n");
  } else {
  }
  goto ldv_54455;
  }
  ldv_54455:
  i = (u8 )((int )i + 1);
  ldv_54473: ;
  if ((int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar >= (int )((unsigned short )BaseMemoryShift) || (int )((unsigned short )BaseMemoryShift) < (int )TotalLen) {
    goto ldv_54472;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("GetAssocInfo end\n");
  } else {
  }
  return (1U);
}
}
static u8 bthci_AddEntry(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  i = 0U;
  goto ldv_54483;
  ldv_54482: ;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed == 0U) {
    pBTInfo->BtAsocEntry[(int )i].bUsed = 1U;
    pBtMgnt->CurrentConnectEntryNum = i;
    goto ldv_54481;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_54483: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_54482;
  } else {
  }
  ldv_54481: ;
  if ((unsigned int )i == 2U) {
    if (BTCoexDbgLevel == 1U) {
      printk("bthci_AddEntry(), Add entry fail!!\n");
    } else {
    }
    return (0U);
  } else {
  }
  return (1U);
}
}
static u8 bthci_DiscardTxPackets(struct rtw_adapter *padapter , u16 LLH )
{
  {
  return (0U);
}
}
static u8 bthci_CheckLogLinkBehavior(struct rtw_adapter *padapter , struct hci_flow_spec TxFlowSpec )
{
  u8 ID ;
  u8 ServiceType ;
  u16 MaxSDUSize ;
  u32 SDUInterArrivatime ;
  u8 match ;
  {
  ID = TxFlowSpec.Identifier;
  ServiceType = TxFlowSpec.ServiceType;
  MaxSDUSize = TxFlowSpec.MaximumSDUSize;
  SDUInterArrivatime = TxFlowSpec.SDUInterArrivalTime;
  match = 0U;
  switch ((int )ID) {
  case 1: ;
  if ((unsigned int )ServiceType == 1U) {
    match = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  TX best effort flowspec\n");
    } else {
    }
  } else
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 65535U) {
    match = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  RX guaranteed latency flowspec\n");
    } else {
    }
  } else
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 2500U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  RX guaranteed Large latency flowspec\n");
    } else {
    }
  } else {
  }
  goto ldv_54498;
  case 2: ;
  if ((unsigned int )ServiceType == 1U) {
    match = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  RX best effort flowspec\n");
    } else {
    }
  } else {
  }
  goto ldv_54498;
  case 3: ;
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 1492U) {
    match = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  TX guaranteed latency flowspec\n");
    } else {
    }
  } else
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 2500U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Logical Link Type =  TX guaranteed Large latency flowspec\n");
    } else {
    }
  } else {
  }
  goto ldv_54498;
  case 4: ;
  if ((unsigned int )ServiceType == 1U) {
    if ((SDUInterArrivatime == 4294967295U && (unsigned int )ServiceType == 1U) && (unsigned int )MaxSDUSize == 1492U) {
      match = 1U;
      if (BTCoexDbgLevel == 1U) {
        printk("Logical Link Type =  TX/RX aggregated best effort flowspec\n");
      } else {
      }
    } else {
    }
  } else
  if ((unsigned int )ServiceType == 2U) {
    if (SDUInterArrivatime == 100U) {
      match = 1U;
      if (BTCoexDbgLevel == 1U) {
        printk("Logical Link Type =  TX/RX guaranteed bandwidth flowspec\n");
      } else {
      }
    } else {
    }
  } else {
  }
  goto ldv_54498;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("Logical Link Type =  Unknow Type !!!!!!!!\n");
  } else {
  }
  goto ldv_54498;
  }
  ldv_54498: ;
  if (BTCoexDbgLevel == 1U) {
    printk("ID = 0x%x, ServiceType = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, AccessLatency = 0x%x, FlushTimeout = 0x%x\n",
           (int )TxFlowSpec.Identifier, (int )TxFlowSpec.ServiceType, (int )MaxSDUSize,
           SDUInterArrivatime, TxFlowSpec.AccessLatency, TxFlowSpec.FlushTimeout);
  } else {
  }
  return (match);
}
}
static u16 bthci_AssocMACAddr(struct rtw_adapter *padapter , void *pbuf )
{
  struct amp_assoc_structure *pAssoStrc ;
  size_t __len ;
  void *__ret ;
  u32 __i ;
  u8 *ptr ;
  {
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
  pAssoStrc->TypeID = 1U;
  pAssoStrc->Length = 6U;
  __len = 6UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pAssoStrc->Data), (void const *)(& padapter->eeprompriv.mac_addr),
                     __len);
  } else {
    __ret = memcpy((void *)(& pAssoStrc->Data), (void const *)(& padapter->eeprompriv.mac_addr),
                             __len);
  }
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pAssoStrc;
    printk("AssocMACAddr : \n");
    __i = 0U;
    goto ldv_54514;
    ldv_54513:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_54514: ;
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
      goto ldv_54513;
    } else {
    }
    printk("\n");
  } else {
  }
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
static u16 bthci_PALCapabilities(struct rtw_adapter *padapter , void *pbuf )
{
  struct amp_assoc_structure *pAssoStrc ;
  u32 __i ;
  u8 *ptr ;
  {
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
  pAssoStrc->TypeID = 4U;
  pAssoStrc->Length = 4U;
  pAssoStrc->Data[0] = 0U;
  pAssoStrc->Data[1] = 0U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pAssoStrc;
    printk("PALCapabilities:\n");
    __i = 0U;
    goto ldv_54524;
    ldv_54523:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_54524: ;
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
      goto ldv_54523;
    } else {
    }
    printk("\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("PALCapabilities \n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk(" TypeID = 0x%x,\n Length = 0x%x,\n Content = 0x0000\n", (int )pAssoStrc->TypeID,
           (int )pAssoStrc->Length);
  } else {
  }
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
static u16 bthci_AssocPreferredChannelList(struct rtw_adapter *padapter , void *pbuf ,
                                           u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct amp_assoc_structure *pAssoStrc ;
  struct amp_pref_chnl_regulatory *pReg ;
  struct chnl_txpower_triple *pTriple ;
  char ctrString[3U] ;
  u32 len ;
  u8 preferredChnl ;
  size_t __len ;
  void *__ret ;
  bool tmp ;
  u8 tmp___0 ;
  u32 __i ;
  u8 *ptr ;
  {
  ctrString[0] = 88;
  ctrString[1] = 88;
  ctrString[2] = 88;
  len = 0U;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
  pReg = (struct amp_pref_chnl_regulatory *)(& pAssoStrc->Data) + 3U;
  preferredChnl = bthci_GetLocalChannel(padapter);
  pAssoStrc->TypeID = 2U;
  __len = 3UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& pAssoStrc->Data), (void const *)(& ctrString), __len);
  } else {
    __ret = memcpy((void *)(& pAssoStrc->Data), (void const *)(& ctrString),
                             __len);
  }
  pReg->reXId = 201U;
  pReg->regulatoryClass = 254U;
  pReg->coverageClass = 0U;
  len = len + 6U;
  if (BTCoexDbgLevel == 1U) {
    printk("PREFERRED_CHNL_LIST\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("XXX, 201, 254, 0\n");
  } else {
  }
  pTriple = (struct chnl_txpower_triple *)(& pAssoStrc->Data) + (unsigned long )len;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 1U) {
    goto _L;
  } else {
    tmp = check_fwstate(& padapter->mlmepriv, 113);
    if ((int )tmp) {
      goto _L;
    } else {
      tmp___0 = BTHCI_HsConnectionEstablished(padapter);
      if ((unsigned int )tmp___0 != 0U) {
        _L:
        pTriple->FirstChnl = preferredChnl;
        pTriple->NumChnls = 1U;
        pTriple->MaxTxPowerInDbm = 20;
        len = len + 3U;
        if (BTCoexDbgLevel == 1U) {
          printk("First Channel = %d, Channel Num = %d, MaxDbm = %d\n", (int )pTriple->FirstChnl,
                 (int )pTriple->NumChnls, (int )pTriple->MaxTxPowerInDbm);
        } else {
        }
      } else {
      }
    }
  }
  pAssoStrc->Length = (unsigned short )len;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pAssoStrc;
    printk("AssocPreferredChannelList : \n");
    __i = 0U;
    goto ldv_54544;
    ldv_54543:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_54544: ;
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
      goto ldv_54543;
    } else {
    }
    printk("\n");
  } else {
  }
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
static u16 bthci_AssocPALVer(struct rtw_adapter *padapter , void *pbuf )
{
  struct amp_assoc_structure *pAssoStrc ;
  u8 *pu1Tmp ;
  u16 *pu2Tmp ;
  u32 __i ;
  u8 *ptr ;
  {
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
  pAssoStrc->TypeID = 5U;
  pAssoStrc->Length = 5U;
  pu1Tmp = (u8 *)(& pAssoStrc->Data);
  *pu1Tmp = 1U;
  pu2Tmp = (u16 *)(& pAssoStrc->Data) + 1U;
  *pu2Tmp = 93U;
  pu2Tmp = (u16 *)(& pAssoStrc->Data) + 3U;
  *pu2Tmp = 1U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)pAssoStrc;
    printk("AssocPALVer : \n");
    __i = 0U;
    goto ldv_54556;
    ldv_54555:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_54556: ;
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
      goto ldv_54555;
    } else {
    }
    printk("\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("AssocPALVer \n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk(" TypeID = 0x%x,\n Length = 0x%x,\n PAL Version = 0x01,\n PAL vendor = 0x01,\n PAL Sub-version specifier = 0x01\n",
           (int )pAssoStrc->TypeID, (int )pAssoStrc->Length);
  } else {
  }
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
static u8 bthci_CheckRfStateBeforeConnect(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  enum rt_rf_power_state RfState ;
  unsigned long tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  RfState = padapter->pwrctrlpriv.rf_pwrstate;
  if ((unsigned int )RfState != 0U) {
    tmp = msecs_to_jiffies(50U);
    ldv_mod_timer_2421(& pBTInfo->BTPsDisableTimer, tmp + (unsigned long )jiffies);
    return (0U);
  } else {
  }
  return (1U);
}
}
static void bthci_ResponderStartToScan(struct rtw_adapter *padapter )
{
  {
  return;
}
}
static u8 bthci_PhyLinkConnectionInProgress(struct rtw_adapter *padapter , u8 PhyLinkHandle )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->bPhyLinkInProgress != 0U && (int )pBtMgnt->BtCurrentPhyLinkhandle == (int )PhyLinkHandle) {
    return (1U);
  } else {
  }
  return (0U);
}
}
static void bthci_ResetFlowSpec(struct rtw_adapter *padapter , u8 EntryNum , u8 index )
{
  struct bt_30info *pBTinfo ;
  {
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtLogLinkhandle = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtPhyLinkhandle = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].bLLCompleteEventIsSet = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].bLLCancelCMDIsSetandComplete = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtTxFlowSpecID = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].TxPacketCount = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.Identifier = 1U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.ServiceType = 1U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.MaximumSDUSize = 65535U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.SDUInterArrivalTime = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.AccessLatency = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.FlushTimeout = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.Identifier = 1U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.ServiceType = 1U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.MaximumSDUSize = 65535U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.SDUInterArrivalTime = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.AccessLatency = 4294967295U;
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.FlushTimeout = 4294967295U;
  return;
}
}
static void bthci_ResetEntry(struct rtw_adapter *padapter , u8 EntryNum )
{
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 j ;
  {
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTinfo->BtMgnt;
  pBTinfo->BtAsocEntry[(int )EntryNum].bUsed = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].BtCurrentState = 32U;
  pBTinfo->BtAsocEntry[(int )EntryNum].BtNextState = 32U;
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.BtPhyLinkhandle = 0U;
  if ((unsigned long )pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment != (unsigned long )((void *)0)) {
    memset(pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment, 0,
           1000UL);
  } else {
  }
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle = 0U;
  memset((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
         0, (size_t )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen);
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = 16000U;
  pBTinfo->BtAsocEntry[(int )EntryNum].AMPRole = 0;
  pBTinfo->BtAsocEntry[(int )EntryNum].mAssoc = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].b4waySuccess = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].KeyReplayCounter = 0ULL;
  pBTinfo->BtAsocEntry[(int )EntryNum].BTWPAAuthState = 0;
  pBTinfo->BtAsocEntry[(int )EntryNum].bSendSupervisionPacket = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].NoRxPktCnt = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].ShortRangeMode = 0U;
  pBTinfo->BtAsocEntry[(int )EntryNum].rxSuvpPktCnt = 0U;
  j = 0U;
  goto ldv_54586;
  ldv_54585:
  bthci_ResetFlowSpec(padapter, (int )EntryNum, (int )j);
  j = (u8 )((int )j + 1);
  ldv_54586: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_54585;
  } else {
  }
  pBtMgnt->BTAuthCount = 0U;
  pBtMgnt->BTAsocCount = 0U;
  pBtMgnt->BTCurrentConnectType = 4;
  pBtMgnt->BTReceiveConnectPkt = 4;
  HALBT_RemoveKey(padapter, (int )EntryNum);
  return;
}
}
static void bthci_RemoveEntryByEntryNum(struct rtw_adapter *padapter , u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  bthci_ResetEntry(padapter, (int )EntryNum);
  if ((unsigned int )pBtMgnt->CurrentBTConnectionCnt != 0U) {
    pBtMgnt->CurrentBTConnectionCnt = (u8 )((int )pBtMgnt->CurrentBTConnectionCnt - 1);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT Flag], CurrentBTConnectionCnt = %d!!\n", (int )pBtMgnt->CurrentBTConnectionCnt);
  } else {
  }
  if ((unsigned int )pBtMgnt->CurrentBTConnectionCnt != 0U) {
    pBtMgnt->BtOperationOn = 1U;
  } else {
    pBtMgnt->BtOperationOn = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], Bt Operation OFF!!\n");
    } else {
    }
  }
  if ((unsigned int )pBtMgnt->BtOperationOn == 0U) {
    ldv_del_timer_sync_2422(& pBTInfo->BTHCIDiscardAclDataTimer);
    ldv_del_timer_sync_2423(& pBTInfo->BTBeaconTimer);
    pBtMgnt->bStartSendSupervisionPkt = 0U;
  } else {
  }
  return;
}
}
static u8 bthci_CommandCompleteHeader(u8 *pbuf , u16 OGF , u16 OCF , enum hci_status status )
{
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 NumHCI_Comm ;
  {
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;
  NumHCI_Comm = 1U;
  PPacketIrpEvent->EventCode = 14U;
  PPacketIrpEvent->Data[0] = NumHCI_Comm;
  PPacketIrpEvent->Data[1] = (unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF));
  PPacketIrpEvent->Data[2] = (unsigned char )((((int )OGF << 10) | (int )OCF) >> 8);
  if ((unsigned int )OGF == 63U) {
    if ((unsigned int )OCF == 64U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
               (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
               (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
               (unsigned int )status, (int )OGF, (int )OCF);
      } else {
      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
             (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
             (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
             (unsigned int )status, (int )OGF, (int )OCF);
    } else {
    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
           (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
           (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
           (unsigned int )status, (int )OGF, (int )OCF);
  } else {
  }
  return (3U);
}
}
static u8 bthci_ExtensionEventHeaderRtk(u8 *pbuf , u8 extensionEvent )
{
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;
  PPacketIrpEvent->EventCode = 254U;
  PPacketIrpEvent->Data[0] = extensionEvent;
  return (1U);
}
}
static enum rt_status bthci_IndicateEvent(struct rtw_adapter *padapter , void *pEvntData ,
                                          u32 dataLen )
{
  enum rt_status rt_status ;
  {
  rt_status = PlatformIndicateBTEvent(padapter, pEvntData, dataLen);
  return (rt_status);
}
}
static void bthci_EventWriteRemoteAmpAssoc(struct rtw_adapter *padapter , enum hci_status status ,
                                           u8 PLHandle )
{
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 11, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk("PhyLinkHandle = 0x%x, status = %d\n", (int )PLHandle, (unsigned int )status);
  } else {
  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = PLHandle;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return;
}
}
static void bthci_EventEnhancedFlushComplete(struct rtw_adapter *padapter , u16 LLH )
{
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 4U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("EventEnhancedFlushComplete, LLH = 0x%x\n", (int )LLH);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 57U;
  PPacketIrpEvent->Length = 2U;
  PPacketIrpEvent->Data[0] = (unsigned char )LLH;
  PPacketIrpEvent->Data[1] = (unsigned char )((int )LLH >> 8);
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
  return;
}
}
static void bthci_EventShortRangeModeChangeComplete(struct rtw_adapter *padapter ,
                                                    enum hci_status HciStatus , u8 ShortRangeState ,
                                                    u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((pBtHciInfo->BTEventMaskPage2 & 4096ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Short Range Mode Change Complete, Ignore to send this event due to event mask page 2\n");
    } else {
    }
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Short Range Mode Change Complete, Status = %d\n , PLH = 0x%x\n, Short_Range_Mode_State = 0x%x\n",
           (unsigned int )HciStatus, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (int )ShortRangeState);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 76U;
  PPacketIrpEvent->Length = 3U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  PPacketIrpEvent->Data[2] = ShortRangeState;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
  return;
}
}
static void bthci_EventSendFlowSpecModifyComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                                  u16 logicHandle )
{
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((pBtHciInfo->BTEventMaskPage2 & 128ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Flow Spec Modify Complete, Ignore to send this event due to event mask page 2\n");
    } else {
    }
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Flow Spec Modify Complete, status = 0x%x, LLH = 0x%x\n", (unsigned int )HciStatus,
           (int )logicHandle);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 71U;
  PPacketIrpEvent->Length = 3U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = (unsigned char )logicHandle;
  PPacketIrpEvent->Data[2] = (unsigned char )((int )logicHandle >> 8);
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
  return;
}
}
static void bthci_EventExtWifiScanNotify(struct rtw_adapter *padapter , u8 scanType )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 len ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pu1Temp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  enum rt_status tmp___1 ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  len = 0U;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 7U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )pBtMgnt->BtOperationOn == 0U) {
    return;
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_ExtensionEventHeaderRtk((u8 *)(& localBuf), 1);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  pu1Temp = pRetPar;
  *pu1Temp = scanType;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  tmp___1 = bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  if ((unsigned int )tmp___1 == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Wifi scan notify, scan type = %d\n", (int )scanType);
    } else {
    }
  } else {
  }
  return;
}
}
static void bthci_EventAMPReceiverReport(struct rtw_adapter *padapter , u8 Reason )
{
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[20U] ;
  unsigned int tmp ;
  u32 *pu4Temp ;
  u16 *pu2Temp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBtHciInfo->bTestNeedReport != 0U) {
    localBuf[0] = '\000';
    tmp = 1U;
    while (1) {
      if (tmp >= 20U) {
        break;
      } else {
      }
      localBuf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    if (BTCoexDbgLevel == 1U) {
      printk(" HCI_EVENT_AMP_RECEIVER_REPORT\n");
    } else {
    }
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
    PPacketIrpEvent->EventCode = 75U;
    PPacketIrpEvent->Length = 2U;
    PPacketIrpEvent->Data[0] = pBtHciInfo->TestCtrType;
    PPacketIrpEvent->Data[1] = Reason;
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 2U;
    *pu4Temp = pBtHciInfo->TestEventType;
    pu2Temp = (u16 *)(& PPacketIrpEvent->Data) + 6U;
    *pu2Temp = pBtHciInfo->TestNumOfFrame;
    pu2Temp = (u16 *)(& PPacketIrpEvent->Data) + 8U;
    *pu2Temp = pBtHciInfo->TestNumOfErrFrame;
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 10U;
    *pu4Temp = (u32 )pBtHciInfo->TestNumOfBits;
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 14U;
    *pu4Temp = (u32 )pBtHciInfo->TestNumOfErrBits;
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 20U);
  } else {
  }
  pBtHciInfo->TestNumOfFrame = 0U;
  return;
}
}
static void bthci_EventChannelSelected(struct rtw_adapter *padapter , u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[3U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((pBtHciInfo->BTEventMaskPage2 & 2ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Channel Selected, Ignore to send this event due to event mask page 2\n");
    } else {
    }
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Channel Selected, PhyLinkHandle %d\n", (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 65U;
  PPacketIrpEvent->Length = 1U;
  PPacketIrpEvent->Data[0] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 3U);
  return;
}
}
static void bthci_EventDisconnectPhyLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                                 enum hci_status Reason , u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((pBtHciInfo->BTEventMaskPage2 & 4ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Disconnect Physical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {
    }
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Disconnect Physical Link Complete, Status = 0x%x, PLH = 0x%x Reason = 0x%x\n",
           (unsigned int )HciStatus, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (unsigned int )Reason);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 66U;
  PPacketIrpEvent->Length = 3U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  PPacketIrpEvent->Data[2] = (u8 )Reason;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
  return;
}
}
static void bthci_EventPhysicalLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                            u8 EntryNum , u8 PLHandle )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_dgb *pBtDbg ;
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 PL_handle ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtDbg = & pBTInfo->BtDbg;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 4U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  pBtMgnt->bPhyLinkInProgress = 0U;
  pBtDbg->dbgHciInfo.hciCmdPhyLinkStatus = (u32 )HciStatus;
  if ((pBtHciInfo->BTEventMaskPage2 & 1ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Physical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {
    }
    return;
  } else {
  }
  if ((unsigned int )EntryNum == 255U) {
    PL_handle = PLHandle;
  } else {
    PL_handle = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
    pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent = 0U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Physical Link Complete, Status = 0x%x PhyLinkHandle = 0x%x\n",
           (unsigned int )HciStatus, (int )PL_handle);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 64U;
  PPacketIrpEvent->Length = 2U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = PL_handle;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
  return;
}
}
static void bthci_EventCommandStatus(struct rtw_adapter *padapter , u8 OGF , u16 OCF ,
                                     enum hci_status HciStatus )
{
  u8 localBuf[6U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 Num_Hci_Comm ;
  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  Num_Hci_Comm = 1U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], CommandStatus, Opcode = 0x%02x%02x, OGF = 0x%x,  OCF = 0x%x, Status = 0x%x, Num_HCI_COMM = 0x%x\n",
           (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)), (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
           (int )OGF, (int )OCF, (unsigned int )HciStatus, (int )Num_Hci_Comm);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 15U;
  PPacketIrpEvent->Length = 4U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = Num_Hci_Comm;
  PPacketIrpEvent->Data[2] = (unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF));
  PPacketIrpEvent->Data[3] = (unsigned char )((((int )OGF << 10) | (int )OCF) >> 8);
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 6U);
  return;
}
}
static void bthci_EventLogicalLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                           u8 PhyLinkHandle , u16 LogLinkHandle ,
                                           u8 LogLinkIndex , u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 7U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((pBtHciInfo->BTEventMaskPage2 & 32ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Logical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {
    }
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Logical Link Complete, PhyLinkHandle = 0x%x,  LogLinkHandle = 0x%x, Status = 0x%x\n",
           (int )PhyLinkHandle, (int )LogLinkHandle, (unsigned int )HciStatus);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 69U;
  PPacketIrpEvent->Length = 5U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = (unsigned char )LogLinkHandle;
  PPacketIrpEvent->Data[2] = (unsigned char )((int )LogLinkHandle >> 8);
  PPacketIrpEvent->Data[3] = PhyLinkHandle;
  if ((unsigned int )HciStatus == 0U) {
    PPacketIrpEvent->Data[4] = pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )LogLinkIndex].Tx_Flow_Spec.Identifier;
  } else {
    PPacketIrpEvent->Data[4] = 0U;
  }
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 7U);
  return;
}
}
static void bthci_EventDisconnectLogicalLinkComplete(struct rtw_adapter *padapter ,
                                                     enum hci_status HciStatus , u16 LogLinkHandle ,
                                                     enum hci_status Reason )
{
  u8 localBuf[6U] ;
  unsigned int tmp ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((pBtHciInfo->BTEventMaskPage2 & 64ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Disconnect Logical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {
    }
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT event], Disconnect Logical Link Complete, Status = 0x%x, LLH = 0x%x Reason = 0x%x\n",
           (unsigned int )HciStatus, (int )LogLinkHandle, (unsigned int )Reason);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 70U;
  PPacketIrpEvent->Length = 4U;
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
  PPacketIrpEvent->Data[1] = (unsigned char )LogLinkHandle;
  PPacketIrpEvent->Data[2] = (unsigned char )((int )LogLinkHandle >> 8);
  PPacketIrpEvent->Data[3] = (u8 )Reason;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 6U);
  return;
}
}
static void bthci_EventFlushOccurred(struct rtw_adapter *padapter , u16 LogLinkHandle )
{
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 4U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_EventFlushOccurred(), LLH = 0x%x\n", (int )LogLinkHandle);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 17U;
  PPacketIrpEvent->Length = 2U;
  PPacketIrpEvent->Data[0] = (unsigned char )LogLinkHandle;
  PPacketIrpEvent->Data[1] = (unsigned char )((int )LogLinkHandle >> 8);
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
  return;
}
}
static enum hci_status bthci_BuildPhysicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                               u16 OCF )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 EntryNum ;
  u8 PLH ;
  u8 tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  bthci_EventCommandStatus(padapter, 1, (int )OCF, 0);
  PLH = *((u8 *)(& pHciCmd->Data));
  tmp = bthci_AddEntry(padapter);
  if ((unsigned int )tmp == 0U) {
    status = 13;
    bthci_EventPhysicalLinkComplete(padapter, status, 255, (int )PLH);
    return (status);
  } else {
  }
  EntryNum = pBtMgnt->CurrentConnectEntryNum;
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle = PLH;
  pBtMgnt->BtCurrentPhyLinkhandle = PLH;
  if ((unsigned long )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment == (unsigned long )((void *)0)) {
    if (BTCoexDbgLevel == 1U) {
      printk("Create/Accept PhysicalLink, AMP controller is busy\n");
    } else {
    }
    status = 58;
    bthci_EventPhysicalLinkComplete(padapter, status, 255, (int )PLH);
    return (status);
  } else {
  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen = *((u8 *)(& pHciCmd->Data) + 1UL);
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType = *((u8 *)(& pHciCmd->Data) + 2UL);
  __len = (size_t )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen;
  __ret = memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
                           (void const *)(& pHciCmd->Data) + 3U, __len);
  __len___0 = 32UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK), (void const *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
                         __len___0);
  } else {
    __ret___0 = memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK),
                                 (void const *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
                                 __len___0);
  }
  if (BTCoexDbgLevel == 1U) {
    printk("BuildPhysicalLink, EntryNum = %d, PLH = 0x%x  KeyLen = 0x%x, KeyType = 0x%x\n",
           (int )EntryNum, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey);
    printk("BtAMPKey\n");
    __i = 0U;
    goto ldv_54755;
    ldv_54754:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_54755: ;
    if ((u32 )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen > __i) {
      goto ldv_54754;
    } else {
    }
    printk("\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    ptr___0 = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK);
    printk("PMK\n");
    __i___0 = 0U;
    goto ldv_54760;
    ldv_54759:
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i___0 + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i___0 = __i___0 + 1U;
    ldv_54760: ;
    if (__i___0 <= 31U) {
      goto ldv_54759;
    } else {
    }
    printk("\n");
  } else {
  }
  if ((unsigned int )OCF == 53U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_BuildPhysicalLink",
             1505);
    } else {
    }
    BTHCI_StateMachine(padapter, 32, 0, (int )EntryNum);
  } else
  if ((unsigned int )OCF == 54U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_BuildPhysicalLink",
             1507);
    } else {
    }
    BTHCI_StateMachine(padapter, 32, 1, (int )EntryNum);
  } else {
  }
  return (status);
}
}
static void bthci_BuildLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                   u16 OCF )
{
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  u16 AssignLogHandle ;
  struct hci_flow_spec TxFlowSpec ;
  struct hci_flow_spec RxFlowSpec ;
  u32 MaxSDUSize ;
  u32 ArriveTime ;
  u32 Bandwidth ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 i ;
  u8 find ;
  enum hci_status LogCompEventstatus ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTinfo->BtMgnt;
  AssignLogHandle = 1U;
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
  __len = 16UL;
  if (__len > 63UL) {
    __ret = memcpy((void *)(& TxFlowSpec), (void const *)(& pHciCmd->Data) + 1U,
                     __len);
  } else {
    __ret = memcpy((void *)(& TxFlowSpec), (void const *)(& pHciCmd->Data) + 1U,
                             __len);
  }
  __len___0 = 16UL;
  if (__len___0 > 63UL) {
    __ret___0 = memcpy((void *)(& RxFlowSpec), (void const *)(& pHciCmd->Data) + 17U,
                         __len___0);
  } else {
    __ret___0 = memcpy((void *)(& RxFlowSpec), (void const *)(& pHciCmd->Data) + 17U,
                                 __len___0);
  }
  MaxSDUSize = (u32 )TxFlowSpec.MaximumSDUSize;
  ArriveTime = TxFlowSpec.SDUInterArrivalTime;
  tmp = bthci_CheckLogLinkBehavior(padapter, TxFlowSpec);
  if ((unsigned int )tmp != 0U) {
    tmp___0 = bthci_CheckLogLinkBehavior(padapter, RxFlowSpec);
    if ((unsigned int )tmp___0 != 0U) {
      Bandwidth = 30000U;
    } else {
      goto _L;
    }
  } else
  _L:
  if (MaxSDUSize == 65535U && ArriveTime == 4294967295U) {
    Bandwidth = 30000U;
  } else {
    Bandwidth = (MaxSDUSize * 8000U) / (ArriveTime + 244U);
  }
  if (BTCoexDbgLevel == 1U) {
    printk("BuildLogicalLink, PhyLinkHandle = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, Bandwidth = 0x%x\n",
           (int )PhyLinkHandle, MaxSDUSize, ArriveTime, Bandwidth);
  } else {
  }
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Invalid Physical Link handle = 0x%x, status = HCI_STATUS_UNKNOW_CONNECT_ID, return\n",
             (int )PhyLinkHandle);
    } else {
    }
    status = 2;
    bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    return;
  } else {
  }
  if ((unsigned int )pBtMgnt->bLogLinkInProgress == 0U) {
    tmp___1 = bthci_PhyLinkConnectionInProgress(padapter, (int )PhyLinkHandle);
    if ((unsigned int )tmp___1 != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Physical link connection in progress, status = HCI_STATUS_CMD_DISALLOW, return\n");
      } else {
      }
      status = 12;
      pBtMgnt->bPhyLinkInProgressStartLL = 1U;
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
      return;
    } else {
    }
    if (Bandwidth > 30000U) {
      if (BTCoexDbgLevel == 1U) {
        printk("status = HCI_STATUS_QOS_REJECT, Bandwidth = 0x%x, return\n", Bandwidth);
      } else {
      }
      status = 45;
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("status = HCI_STATUS_SUCCESS\n");
      } else {
      }
      status = 0;
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    }
    if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].BtCurrentState != 8U) {
      bthci_EventLogicalLinkComplete(padapter, 12, 0, 0, 0, (int )EntryNum);
    } else {
      find = 0U;
      pBtMgnt->bLogLinkInProgress = 1U;
      i = 0U;
      goto ldv_54796;
      ldv_54795: ;
      if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle == 0U) {
        LogCompEventstatus = 0;
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle = *((u8 *)(& pHciCmd->Data));
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle = AssignLogHandle;
        if (BTCoexDbgLevel == 1U) {
          printk("BuildLogicalLink, EntryNum = %d, physical link handle = 0x%x, logical link handle = 0x%x\n",
                 (int )EntryNum, (int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
                 (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle);
        } else {
        }
        __len___1 = 16UL;
        if (__len___1 > 63UL) {
          __ret___1 = memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                               (void const *)(& TxFlowSpec), __len___1);
        } else {
          __ret___1 = memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                                       (void const *)(& TxFlowSpec), __len___1);
        }
        __len___2 = 16UL;
        if (__len___2 > 63UL) {
          __ret___2 = memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                               (void const *)(& RxFlowSpec), __len___2);
        } else {
          __ret___2 = memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                                       (void const *)(& RxFlowSpec), __len___2);
        }
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCompleteEventIsSet = 0U;
        if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCancelCMDIsSetandComplete != 0U) {
          LogCompEventstatus = 2;
        } else {
        }
        bthci_EventLogicalLinkComplete(padapter, LogCompEventstatus, (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle,
                                       (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle,
                                       (int )i, (int )EntryNum);
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCompleteEventIsSet = 1U;
        find = 1U;
        pBtMgnt->BtCurrentLogLinkhandle = AssignLogHandle;
        AssignLogHandle = (u16 )((int )AssignLogHandle + 1);
        goto ldv_54794;
      } else {
      }
      i = (u8 )((int )i + 1);
      ldv_54796: ;
      if ((unsigned int )i <= 1U) {
        goto ldv_54795;
      } else {
      }
      ldv_54794: ;
      if ((unsigned int )find == 0U) {
        bthci_EventLogicalLinkComplete(padapter, 13, 0, 0, 0, (int )EntryNum);
      } else {
      }
      pBtMgnt->bLogLinkInProgress = 0U;
    }
  } else {
    bthci_EventLogicalLinkComplete(padapter, 58, 0, 0, 0, (int )EntryNum);
  }
  return;
}
}
static void bthci_StartBeaconAndConnect(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                        u8 CurrentAssocNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  u32 __i ;
  u8 buffer[64U] ;
  u32 length ;
  size_t __len ;
  void *__ret ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("StartBeaconAndConnect, CurrentAssocNum =%d, AMPRole =%d\n", (int )CurrentAssocNum,
           (unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole);
  } else {
  }
  if ((unsigned int )pBtMgnt->CheckChnlIsSuit == 0U) {
    bthci_EventPhysicalLinkComplete(padapter, 57, (int )CurrentAssocNum, 255);
    bthci_RemoveEntryByEntryNum(padapter, (int )CurrentAssocNum);
    return;
  } else {
  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 1U) {
    snprintf((char *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf), 32UL,
             "AMP-%02x-%02x-%02x-%02x-%02x-%02x", (int )padapter->eeprompriv.mac_addr[0],
             (int )padapter->eeprompriv.mac_addr[1], (int )padapter->eeprompriv.mac_addr[2],
             (int )padapter->eeprompriv.mac_addr[3], (int )padapter->eeprompriv.mac_addr[4],
             (int )padapter->eeprompriv.mac_addr[5]);
  } else
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 2U) {
    snprintf((char *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf), 32UL,
             "AMP-%02x-%02x-%02x-%02x-%02x-%02x", (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[0],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[1],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[2],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[3],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[4],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[5]);
  } else {
  }
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Octet = (u8 *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf);
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Length = 21U;
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Length = 21U;
  if ((unsigned int )pBtMgnt->bBTConnectInProgress == 0U) {
    pBtMgnt->bBTConnectInProgress = 1U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress ON!!\n");
    } else {
    }
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_StartBeaconAndConnect",
             1701);
    } else {
    }
    BTHCI_StateMachine(padapter, 1, 4, (int )CurrentAssocNum);
    tmp = bthci_CheckRfStateBeforeConnect(padapter);
    if ((unsigned int )tmp == 0U) {
      return;
    } else {
    }
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 1U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT state change] caused by %s, line =%d\n", "bthci_StartBeaconAndConnect",
               1710);
      } else {
      }
      BTHCI_StateMachine(padapter, 2, 6, (int )CurrentAssocNum);
    } else
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 2U) {
      bthci_ResponderStartToScan(padapter);
    } else {
    }
  } else {
  }
  length = (unsigned int )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length <= 63U ? (u32 )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length : 63U;
  memset((void *)(& buffer), 0, 64UL);
  __len = (size_t )length;
  __ret = memcpy((void *)(& buffer), (void const *)pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Octet,
                           __len);
  __i = 0U;
  goto ldv_54812;
  ldv_54811: ;
  if ((unsigned int )buffer[__i] <= 31U || (unsigned int )buffer[__i] > 126U) {
    buffer[__i] = 63U;
  } else {
  }
  __i = __i + 1U;
  ldv_54812: ;
  if (__i < length) {
    goto ldv_54811;
  } else {
  }
  buffer[length] = 0U;
  printk("StartBeaconAndConnect, SSID:\n");
  printk(": %d, <%s>\n", (int )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length,
         (u8 *)(& buffer));
  return;
}
}
static void bthci_ResetBtMgnt(struct bt_mgnt *pBtMgnt )
{
  {
  pBtMgnt->BtOperationOn = 0U;
  pBtMgnt->bBTConnectInProgress = 0U;
  pBtMgnt->bLogLinkInProgress = 0U;
  pBtMgnt->bPhyLinkInProgress = 0U;
  pBtMgnt->bPhyLinkInProgressStartLL = 0U;
  pBtMgnt->DisconnectEntryNum = 255U;
  pBtMgnt->bStartSendSupervisionPkt = 0U;
  pBtMgnt->JoinerNeedSendAuth = 0U;
  pBtMgnt->CurrentBTConnectionCnt = 0U;
  pBtMgnt->BTCurrentConnectType = 4;
  pBtMgnt->BTReceiveConnectPkt = 4;
  pBtMgnt->BTAuthCount = 0U;
  pBtMgnt->btLogoTest = 0U;
  return;
}
}
static void bthci_ResetBtHciInfo(struct bt_hci_info *pBtHciInfo )
{
  {
  pBtHciInfo->BTEventMask = 0ULL;
  pBtHciInfo->BTEventMaskPage2 = 0ULL;
  pBtHciInfo->ConnAcceptTimeout = 10000U;
  pBtHciInfo->PageTimeout = 48U;
  pBtHciInfo->LocationDomainAware = 0U;
  pBtHciInfo->LocationDomain = 22616U;
  pBtHciInfo->LocationDomainOptions = 88U;
  pBtHciInfo->LocationOptions = 0U;
  pBtHciInfo->FlowControlMode = 1U;
  pBtHciInfo->enFlush_LLH = 0U;
  pBtHciInfo->FLTO_LLH = 0U;
  pBtHciInfo->bTestIsEnd = 1U;
  pBtHciInfo->bInTestMode = 0U;
  pBtHciInfo->bTestNeedReport = 0U;
  pBtHciInfo->TestScenario = 255U;
  pBtHciInfo->TestReportInterval = 1U;
  pBtHciInfo->TestCtrType = 93U;
  pBtHciInfo->TestEventType = 0U;
  pBtHciInfo->TestNumOfFrame = 0U;
  pBtHciInfo->TestNumOfErrFrame = 0U;
  pBtHciInfo->TestNumOfBits = 0U;
  pBtHciInfo->TestNumOfErrBits = 0U;
  return;
}
}
static void bthci_ResetBtSec(struct rtw_adapter *padapter , struct bt_security *pBtSec )
{
  {
  if ((unsigned int )((struct hal_data_8723a *)padapter->HalData)->bBTMode != 0U) {
    pBtSec->bUsedHwEncrypt = 1U;
  } else {
    pBtSec->bUsedHwEncrypt = 0U;
  }
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 7);
    printk("\016%s: bUsedHwEncrypt =%d\n", "bthci_ResetBtSec", (int )pBtSec->bUsedHwEncrypt);
  } else {
  }
  pBtSec->RSNIE.Octet = (u8 *)(& pBtSec->RSNIEBuf);
  return;
}
}
static void bthci_ResetBtExtInfo(struct bt_mgnt *pBtMgnt )
{
  u8 i ;
  {
  i = 0U;
  goto ldv_54830;
  ldv_54829:
  pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = 4U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI = 0;
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole = 0U;
  i = (u8 )((int )i + 1);
  ldv_54830: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_54829;
  } else {
  }
  pBtMgnt->ExtConfig.CurrentConnectHandle = 0U;
  pBtMgnt->ExtConfig.CurrentIncomingTrafficMode = 0U;
  pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = 0U;
  pBtMgnt->ExtConfig.MIN_BT_RSSI = 0;
  pBtMgnt->ExtConfig.NumberOfHandle = 0U;
  pBtMgnt->ExtConfig.NumberOfSCO = 0U;
  pBtMgnt->ExtConfig.CurrentBTStatus = 0U;
  pBtMgnt->ExtConfig.HCIExtensionVer = 0U;
  pBtMgnt->ExtConfig.bManualControl = 0U;
  pBtMgnt->ExtConfig.bBTBusy = 0U;
  pBtMgnt->ExtConfig.bBTA2DPBusy = 0U;
  return;
}
}
static enum hci_status bthci_CmdReset(struct rtw_adapter *_padapter , u8 bNeedSendEvent )
{
  enum hci_status status ;
  struct rtw_adapter *padapter ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_security *pBtSec ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_CmdReset()\n");
  } else {
  }
  padapter = _padapter;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtSec = & pBTInfo->BtSec;
  pBtDbg = & pBTInfo->BtDbg;
  pBTInfo->padapter = padapter;
  i = 0U;
  goto ldv_54845;
  ldv_54844:
  bthci_ResetEntry(padapter, (int )i);
  i = (u8 )((int )i + 1);
  ldv_54845: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_54844;
  } else {
  }
  bthci_ResetBtMgnt(pBtMgnt);
  bthci_ResetBtHciInfo(pBtHciInfo);
  bthci_ResetBtSec(padapter, pBtSec);
  pBtMgnt->BTChannel = 10U;
  pBtMgnt->CheckChnlIsSuit = 1U;
  pBTInfo->BTBeaconTmrOn = 0U;
  pBtMgnt->bCreateSpportQos = 1U;
  ldv_del_timer_sync_2424(& pBTInfo->BTHCIDiscardAclDataTimer);
  ldv_del_timer_sync_2425(& pBTInfo->BTBeaconTimer);
  HALBT_SetRtsCtsNoLenLimit(padapter);
  bthci_ResetBtExtInfo(pBtMgnt);
  if ((unsigned int )bNeedSendEvent != 0U) {
    localBuf[0] = '\000';
    tmp = 1U;
    while (1) {
      if (tmp >= 6U) {
        break;
      } else {
      }
      localBuf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    len = 0U;
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
    tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 3, status);
    len = (int )tmp___0 + (int )len;
    pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
    *pRetPar = (u8 )status;
    len = (unsigned int )len + 1U;
    PPacketIrpEvent->Length = len;
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  } else {
  }
  return (status);
}
}
static enum hci_status bthci_CmdWriteRemoteAMPAssoc(struct rtw_adapter *padapter ,
                                                    struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 CurrentAssocNum ;
  u8 PhyLinkHandle ;
  u32 __i ;
  u8 *ptr ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u32 __i___0 ;
  u8 *ptr___0 ;
  u8 tmp ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntWriteRemoteAmpAssoc = pBtDbg->dbgHciInfo.hciCmdCntWriteRemoteAmpAssoc + 1U;
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
  CurrentAssocNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
  if ((unsigned int )CurrentAssocNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("WriteRemoteAMPAssoc, No such Handle in the Entry\n");
    } else {
    }
    status = 2;
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
    return (status);
  } else {
  }
  if ((unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment == (unsigned long )((void *)0)) {
    if (BTCoexDbgLevel == 1U) {
      printk("WriteRemoteAMPAssoc, AMP controller is busy\n");
    } else {
    }
    status = 58;
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
    return (status);
  } else {
  }
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.BtPhyLinkhandle = PhyLinkHandle;
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar = *((u16 *)(& pHciCmd->Data) + 1U);
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen = *((u16 *)(& pHciCmd->Data) + 3U);
  if (BTCoexDbgLevel == 1U) {
    printk("WriteRemoteAMPAssoc, LenSoFar = 0x%x, AssocRemLen = 0x%x\n", (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
           (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("WriteRemoteAMPAssoc fragment \n");
    __i = 0U;
    goto ldv_54863;
    ldv_54862:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_54863: ;
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen + 5U > __i) {
      goto ldv_54862;
    } else {
    }
    printk("\n");
  } else {
  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen > 248U) {
    __len = 248UL;
    if (__len > 63UL) {
      __ret = memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
                       (void const *)(& pHciCmd->Data) + 5U, __len);
    } else {
      __ret = memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
                               (void const *)(& pHciCmd->Data) + 5U, __len);
    }
  } else {
    __len___0 = (size_t )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen;
    __ret___0 = memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
                                 (void const *)(& pHciCmd->Data) + 5U, __len___0);
    if (BTCoexDbgLevel == 1U) {
      ptr___0 = (u8 *)(& pHciCmd->Data) + 5UL;
      printk("WriteRemoteAMPAssoc :\n");
      __i___0 = 0U;
      goto ldv_54874;
      ldv_54873:
      printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
      if (((__i___0 + 1U) & 15U) == 0U) {
        printk("\n");
      } else {
      }
      __i___0 = __i___0 + 1U;
      ldv_54874: ;
      if ((u32 )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen > __i___0) {
        goto ldv_54873;
      } else {
      }
      printk("\n");
    } else {
    }
    tmp = bthci_GetAssocInfo(padapter, (int )CurrentAssocNum);
    if ((unsigned int )tmp == 0U) {
      status = 18;
    } else {
    }
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
    bthci_StartBeaconAndConnect(padapter, pHciCmd, (int )CurrentAssocNum);
  }
  return (status);
}
}
static enum hci_status bthci_CmdReadConnectionAcceptTimeout(struct rtw_adapter *padapter )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 21, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = pBtHciInfo->ConnAcceptTimeout;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetEventFilter(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  {
  status = 0;
  return (status);
}
}
static enum hci_status bthci_CmdWriteConnectionAcceptTimeout(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pu2Temp = (u16 *)(& pHciCmd->Data);
  pBtHciInfo->ConnAcceptTimeout = *pu2Temp;
  if (BTCoexDbgLevel == 1U) {
    printk("ConnAcceptTimeout = 0x%x", (int )pBtHciInfo->ConnAcceptTimeout);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 22, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadPageTimeout(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 23, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk("Read PageTimeout = 0x%x\n", (int )pBtHciInfo->PageTimeout);
  } else {
  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = pBtHciInfo->PageTimeout;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWritePageTimeout(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pu2Temp = (u16 *)(& pHciCmd->Data);
  pBtHciInfo->PageTimeout = *pu2Temp;
  if (BTCoexDbgLevel == 1U) {
    printk("Write PageTimeout = 0x%x\n", (int )pBtHciInfo->PageTimeout);
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 24, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLinkSupervisionTimeout(struct rtw_adapter *padapter ,
                                                           struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 physicalLinkHandle ;
  u8 EntryNum ;
  u8 localBuf[10U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )physicalLinkHandle);
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("ReadLinkSupervisionTimeout, No such Handle in the Entry\n");
    } else {
    }
    status = 2;
    return (status);
  } else {
  }
  if ((int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle != (int )physicalLinkHandle) {
    status = 2;
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 10U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 54, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  *(pRetPar + 2UL) = 0U;
  pu2Temp = (u16 *)pRetPar + 3U;
  *pu2Temp = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout;
  len = (unsigned int )len + 5U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteLinkSupervisionTimeout(struct rtw_adapter *padapter ,
                                                            struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 physicalLinkHandle ;
  u8 EntryNum ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )physicalLinkHandle);
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("WriteLinkSupervisionTimeout, No such Handle in the Entry\n");
    } else {
    }
    status = 2;
  } else
  if ((int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle != (int )physicalLinkHandle) {
    status = 2;
  } else {
    pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = *((u16 *)(& pHciCmd->Data) + 2U);
    if (BTCoexDbgLevel == 1U) {
      printk("BT Write LinkSuperversionTimeout[%d] = 0x%x\n", (int )EntryNum, (int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout);
    } else {
    }
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 55, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  *(pRetPar + 2UL) = 0U;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdEnhancedFlush(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 logicHandle ;
  u8 Packet_Type ;
  u8 tmp ;
  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTinfo->BtHciInfo;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  Packet_Type = pHciCmd->Data[2];
  if ((unsigned int )Packet_Type != 0U) {
    status = 18;
  } else {
    pBtHciInfo->enFlush_LLH = logicHandle;
  }
  tmp = bthci_DiscardTxPackets(padapter, (int )pBtHciInfo->enFlush_LLH);
  if ((unsigned int )tmp != 0U) {
    bthci_EventFlushOccurred(padapter, (int )pBtHciInfo->enFlush_LLH);
  } else {
  }
  bthci_EventCommandStatus(padapter, 3, 95, status);
  if ((unsigned int )pBtHciInfo->enFlush_LLH != 0U) {
    bthci_EventEnhancedFlushComplete(padapter, (int )pBtHciInfo->enFlush_LLH);
    pBtHciInfo->enFlush_LLH = 0U;
  } else {
  }
  return (status);
}
}
static enum hci_status bthci_CmdReadLogicalLinkAcceptTimeout(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 97, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = pBtHciInfo->LogicalAcceptTimeout;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteLogicalLinkAcceptTimeout(struct rtw_adapter *padapter ,
                                                              struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBtHciInfo->LogicalAcceptTimeout = *((u16 *)(& pHciCmd->Data));
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 98, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetEventMask(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 *pu8Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pu8Temp = (u8 *)(& pHciCmd->Data);
  pBtHciInfo->BTEventMask = (u64 )*pu8Temp;
  if (BTCoexDbgLevel == 1U) {
    printk("BTEventMask = 0x%llx\n", pBtHciInfo->BTEventMask);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 1, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetEventMaskPage2(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 *pu8Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pu8Temp = (u8 *)(& pHciCmd->Data);
  pBtHciInfo->BTEventMaskPage2 = (u64 )*pu8Temp;
  if (BTCoexDbgLevel == 1U) {
    printk("BTEventMaskPage2 = 0x%llx\n", pBtHciInfo->BTEventMaskPage2);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 99, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocationData(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[12U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 12U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 100, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk("DomainAware = 0x%x\n", (int )pBtHciInfo->LocationDomainAware);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Domain = 0x%x\n", (int )pBtHciInfo->LocationDomain);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("DomainOptions = 0x%x\n", (int )pBtHciInfo->LocationDomainOptions);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Options = 0x%x\n", (int )pBtHciInfo->LocationOptions);
  } else {
  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBtHciInfo->LocationDomainAware;
  pu2Temp = (u16 *)pRetPar + 2U;
  *pu2Temp = pBtHciInfo->LocationDomain;
  *(pRetPar + 4UL) = pBtHciInfo->LocationDomainOptions;
  *(pRetPar + 5UL) = pBtHciInfo->LocationOptions;
  len = (unsigned int )len + 6U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteLocationData(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBtHciInfo->LocationDomainAware = pHciCmd->Data[0];
  pu2Temp = (u16 *)(& pHciCmd->Data) + 1U;
  pBtHciInfo->LocationDomain = *pu2Temp;
  pBtHciInfo->LocationDomainOptions = pHciCmd->Data[3];
  pBtHciInfo->LocationOptions = pHciCmd->Data[4];
  if (BTCoexDbgLevel == 1U) {
    printk("DomainAware = 0x%x\n", (int )pBtHciInfo->LocationDomainAware);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Domain = 0x%x\n", (int )pBtHciInfo->LocationDomain);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("DomainOptions = 0x%x\n", (int )pBtHciInfo->LocationDomainOptions);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Options = 0x%x\n", (int )pBtHciInfo->LocationOptions);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 101, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadFlowControlMode(struct rtw_adapter *padapter ,
                                                    struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 7U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 102, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBtHciInfo->FlowControlMode;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteFlowControlMode(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBtHciInfo->FlowControlMode = pHciCmd->Data[0];
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 103, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadBestEffortFlushTimeout(struct rtw_adapter *padapter ,
                                                           struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u16 i ;
  u16 j ;
  u16 logicHandle ;
  u32 BestEffortFlushTimeout ;
  u8 find ;
  u8 localBuf[10U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u32 *pu4Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  BestEffortFlushTimeout = 4294967295U;
  find = 0U;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  j = 0U;
  goto ldv_55070;
  ldv_55069:
  i = 0U;
  goto ldv_55068;
  ldv_55067: ;
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
    BestEffortFlushTimeout = pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BestEffortFlushTimeout;
    find = 1U;
    goto ldv_55066;
  } else {
  }
  i = (u16 )((int )i + 1);
  ldv_55068: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55067;
  } else {
  }
  ldv_55066:
  j = (u16 )((int )j + 1);
  ldv_55070: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_55069;
  } else {
  }
  if ((unsigned int )find == 0U) {
    status = 2;
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 10U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 105, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu4Temp = (u32 *)pRetPar + 1U;
  *pu4Temp = BestEffortFlushTimeout;
  len = (unsigned int )len + 5U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWriteBestEffortFlushTimeout(struct rtw_adapter *padapter ,
                                                            struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u16 i ;
  u16 j ;
  u16 logicHandle ;
  u32 BestEffortFlushTimeout ;
  u8 find ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  BestEffortFlushTimeout = 4294967295U;
  find = 0U;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  BestEffortFlushTimeout = *((u32 *)(& pHciCmd->Data) + 1U);
  j = 0U;
  goto ldv_55092;
  ldv_55091:
  i = 0U;
  goto ldv_55090;
  ldv_55089: ;
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
    pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BestEffortFlushTimeout = BestEffortFlushTimeout;
    find = 1U;
    goto ldv_55088;
  } else {
  }
  i = (u16 )((int )i + 1);
  ldv_55090: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55089;
  } else {
  }
  ldv_55088:
  j = (u16 )((int )j + 1);
  ldv_55092: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_55091;
  } else {
  }
  if ((unsigned int )find == 0U) {
    status = 2;
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 106, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdShortRangeMode(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  u8 ShortRangeMode ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  PhyLinkHandle = pHciCmd->Data[0];
  ShortRangeMode = pHciCmd->Data[1];
  if (BTCoexDbgLevel == 1U) {
    printk("PLH = 0x%x, Short_Range_Mode = 0x%x\n", (int )PhyLinkHandle, (int )ShortRangeMode);
  } else {
  }
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
  if ((unsigned int )EntryNum != 255U) {
    pBTInfo->BtAsocEntry[(int )EntryNum].ShortRangeMode = ShortRangeMode;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("No such PLH(0x%x)\n", (int )PhyLinkHandle);
    } else {
    }
    status = 2;
  }
  bthci_EventCommandStatus(padapter, 3, 107, status);
  bthci_EventShortRangeModeChangeComplete(padapter, status, (int )ShortRangeMode,
                                          (int )EntryNum);
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalSupportedCommands(struct rtw_adapter *padapter )
{
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pSupportedCmds ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 2, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  pSupportedCmds = pRetPar + 1UL;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[5]= 0xc0\nBit [6]= Set Event Mask, [7]= Reset\n");
  } else {
  }
  *(pSupportedCmds + 5UL) = 192U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[6]= 0x01\nBit [0]= Set Event Filter\n");
  } else {
  }
  *(pSupportedCmds + 6UL) = 1U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[7]= 0x0c\nBit [2]= Read Connection Accept Timeout, [3]= Write Connection Accept Timeout\n");
  } else {
  }
  *(pSupportedCmds + 7UL) = 12U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[10]= 0x80\nBit [7]= Host Number Of Completed Packets\n");
  } else {
  }
  *(pSupportedCmds + 10UL) = 128U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[11]= 0x03\nBit [0]= Read Link Supervision Timeout, [1]= Write Link Supervision Timeout\n");
  } else {
  }
  *(pSupportedCmds + 11UL) = 3U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[14]= 0xa8\nBit [3]= Read Local Version Information, [5]= Read Local Supported Features, [7]= Read Buffer Size\n");
  } else {
  }
  *(pSupportedCmds + 14UL) = 168U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[15]= 0x1c\nBit [2]= Read Failed Contact Count, [3]= Reset Failed Contact Count, [4]= Get Link Quality\n");
  } else {
  }
  *(pSupportedCmds + 15UL) = 28U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[19]= 0x40\nBit [6]= Enhanced Flush\n");
  } else {
  }
  *(pSupportedCmds + 19UL) = 64U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[21]= 0xff\nBit [0]= Create Physical Link, [1]= Accept Physical Link, [2]= Disconnect Physical Link, [3]= Create Logical Link\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("\t[4]= Accept Logical Link, [5]= Disconnect Logical Link, [6]= Logical Link Cancel, [7]= Flow Spec Modify\n");
  } else {
  }
  *(pSupportedCmds + 21UL) = 255U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[22]= 0xff\nBit [0]= Read Logical Link Accept Timeout, [1]= Write Logical Link Accept Timeout, [2]= Set Event Mask Page 2, [3]= Read Location Data\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("\t[4]= Write Location Data, [5]= Read Local AMP Info, [6]= Read Local AMP_ASSOC, [7]= Write Remote AMP_ASSOC\n");
  } else {
  }
  *(pSupportedCmds + 22UL) = 255U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[23]= 0x07\nBit [0]= Read Flow Control Mode, [1]= Write Flow Control Mode, [2]= Read Data Block Size\n");
  } else {
  }
  *(pSupportedCmds + 23UL) = 7U;
  if (BTCoexDbgLevel == 1U) {
    printk("Octet[24]= 0x1c\nBit [2]= Read Best Effort Flush Timeout, [3]= Write Best Effort Flush Timeout, [4]= Short Range Mode\n");
  } else {
  }
  *(pSupportedCmds + 24UL) = 28U;
  len = (unsigned int )len + 64U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalSupportedFeatures(struct rtw_adapter *padapter )
{
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 3, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 9U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalAMPAssoc(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u16 *pRemainLen ;
  u32 totalLen ;
  u16 typeLen ;
  u16 remainLen ;
  u16 ret_index ;
  u8 *pRetPar ;
  u8 tmp___0 ;
  u32 __i ;
  u8 *ptr ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntReadLocalAmpAssoc = pBtDbg->dbgHciInfo.hciCmdCntReadLocalAmpAssoc + 1U;
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
  if ((unsigned int )EntryNum == 255U && (unsigned int )PhyLinkHandle != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("ReadLocalAMPAssoc, EntryNum = %d  !!!!!, physical link handle = 0x%x\n",
             (int )EntryNum, (int )PhyLinkHandle);
    } else {
    }
    status = 2;
  } else
  if ((unsigned int )pBtMgnt->bPhyLinkInProgressStartLL != 0U) {
    status = 2;
    pBtMgnt->bPhyLinkInProgressStartLL = 0U;
  } else {
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.BtPhyLinkhandle = *((u8 *)(& pHciCmd->Data));
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar = *((u16 *)(& pHciCmd->Data) + 1U);
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen = *((u16 *)(& pHciCmd->Data) + 3U);
    if (BTCoexDbgLevel == 1U) {
      printk("ReadLocalAMPAssoc, LenSoFar =%d, MaxRemoteASSOCLen =%d\n", (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar,
             (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen);
    } else {
    }
  }
  if (BTCoexDbgLevel == 1U) {
    printk("ReadLocalAMPAssoc, EntryNum = %d  !!!!!, physical link handle = 0x%x, LengthSoFar = %x  \n",
           (int )EntryNum, (int )PhyLinkHandle, (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar);
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  totalLen = 0U;
  typeLen = 0U;
  remainLen = 0U;
  ret_index = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 10, status);
  totalLen = (u32 )tmp___0 + totalLen;
  if (BTCoexDbgLevel == 1U) {
    printk("ReadLocalAMPAssoc, Remaining_Len =%d  \n", (int )remainLen);
  } else {
  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )totalLen;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = *((u8 *)(& pHciCmd->Data));
  pRemainLen = (u16 *)pRetPar + 2U;
  totalLen = totalLen + 4U;
  ret_index = 4U;
  typeLen = bthci_AssocMACAddr(padapter, (void *)pRetPar + (unsigned long )ret_index);
  totalLen = (u32 )typeLen + totalLen;
  remainLen = (int )remainLen + (int )typeLen;
  ret_index = (int )ret_index + (int )typeLen;
  typeLen = bthci_AssocPreferredChannelList(padapter, (void *)pRetPar + (unsigned long )ret_index,
                                            (int )EntryNum);
  totalLen = (u32 )typeLen + totalLen;
  remainLen = (int )remainLen + (int )typeLen;
  ret_index = (int )ret_index + (int )typeLen;
  typeLen = bthci_PALCapabilities(padapter, (void *)pRetPar + (unsigned long )ret_index);
  totalLen = (u32 )typeLen + totalLen;
  remainLen = (int )remainLen + (int )typeLen;
  ret_index = (int )ret_index + (int )typeLen;
  typeLen = bthci_AssocPALVer(padapter, (void *)pRetPar + (unsigned long )ret_index);
  totalLen = (u32 )typeLen + totalLen;
  remainLen = (int )remainLen + (int )typeLen;
  PPacketIrpEvent->Length = (unsigned char )totalLen;
  *pRemainLen = remainLen;
  if (BTCoexDbgLevel == 1U) {
    printk("ReadLocalAMPAssoc, Remaining_Len =%d  \n", (int )remainLen);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& PPacketIrpEvent->Data);
    printk("AMP_ASSOC_fragment : \n");
    __i = 0U;
    goto ldv_55145;
    ldv_55144:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_55145: ;
    if (__i < totalLen) {
      goto ldv_55144;
    } else {
    }
    printk("\n");
  } else {
  }
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, totalLen + 2U);
  return (status);
}
}
static enum hci_status bthci_CmdReadFailedContactCounter(struct rtw_adapter *padapter ,
                                                         struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 handle ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  handle = *((u16 *)(& pHciCmd->Data));
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 1, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = (unsigned char )handle;
  *(pRetPar + 2UL) = (unsigned char )((int )handle >> 8);
  *(pRetPar + 3UL) = (unsigned char )pBtHciInfo->FailContactCount;
  *(pRetPar + 4UL) = (unsigned char )((int )pBtHciInfo->FailContactCount >> 8);
  len = (unsigned int )len + 5U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdResetFailedContactCounter(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 handle ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  handle = *((u16 *)(& pHciCmd->Data));
  pBtHciInfo->FailContactCount = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 2, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = (unsigned char )handle;
  *(pRetPar + 2UL) = (unsigned char )((int )handle >> 8);
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalVersionInformation(struct rtw_adapter *padapter )
{
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 1, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = 5U;
  pu2Temp = (u16 *)pRetPar + 2U;
  *pu2Temp = 1U;
  *(pRetPar + 4UL) = 5U;
  pu2Temp = (u16 *)pRetPar + 5U;
  *pu2Temp = 93U;
  pu2Temp = (u16 *)pRetPar + 7U;
  *pu2Temp = 1U;
  len = (unsigned int )len + 9U;
  PPacketIrpEvent->Length = len;
  if (BTCoexDbgLevel == 1U) {
    printk("LOCAL_VERSION_INFORMATION\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Status  %x\n", (unsigned int )status);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_Version = 0x05\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_Revision = 0x0001\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("LMP/PAL_Version = 0x05\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Manufacturer_Name = 0x0001\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("LMP/PAL_Subversion = 0x0001\n");
  } else {
  }
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadDataBlockSize(struct rtw_adapter *padapter )
{
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 10, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = 0U;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = 1492U;
  pu2Temp = (u16 *)pRetPar + 3U;
  *pu2Temp = 1492U;
  pu2Temp = (u16 *)pRetPar + 5U;
  *pu2Temp = 256U;
  len = (unsigned int )len + 7U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadBufferSize(struct rtw_adapter *padapter )
{
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 5, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk("Synchronous_Data_Packet_Length = 0x%x\n", 255);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Total_Num_ACL_Data_Packets = 0x%x\n", 256);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Total_Num_Synchronous_Data_Packets = 0x%x\n", 256);
  } else {
  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = 1492U;
  *(pRetPar + 3UL) = 255U;
  pu2Temp = (u16 *)pRetPar + 4U;
  *pu2Temp = 256U;
  pu2Temp = (u16 *)pRetPar + 6U;
  *pu2Temp = 256U;
  len = (unsigned int )len + 8U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadLocalAMPInfo(struct rtw_adapter *padapter )
{
  enum hci_status status ;
  struct pwrctrl_priv *ppwrctrl ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u32 *pu4Temp ;
  u32 TotalBandwidth ;
  u32 MaxBandGUBandwidth ;
  u8 ControlType ;
  u8 AmpStatus ;
  u32 MaxFlushTimeout ;
  u32 BestEffortFlushTimeout ;
  u16 MaxPDUSize ;
  u16 PalCap ;
  u16 AmpAssocLen ;
  u16 MinLatency ;
  u8 tmp___0 ;
  {
  status = 0;
  ppwrctrl = & padapter->pwrctrlpriv;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  TotalBandwidth = 30000U;
  MaxBandGUBandwidth = 20000U;
  ControlType = 1U;
  AmpStatus = 1U;
  MaxFlushTimeout = 10000U;
  BestEffortFlushTimeout = 5000U;
  MaxPDUSize = 1492U;
  PalCap = 1U;
  AmpAssocLen = 672U;
  MinLatency = 20U;
  if (((unsigned long )ppwrctrl->rfoff_reason & 1073741824UL) != 0UL || (int )ppwrctrl->rfoff_reason < 0) {
    AmpStatus = 2U;
  } else {
  }
  memset((void *)(& localBuf), 0, 256UL);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 9, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = AmpStatus;
  pu4Temp = (u32 *)pRetPar + 2U;
  *pu4Temp = TotalBandwidth;
  pu4Temp = (u32 *)pRetPar + 6U;
  *pu4Temp = MaxBandGUBandwidth;
  pu4Temp = (u32 *)pRetPar + 10U;
  *pu4Temp = (u32 )MinLatency;
  pu4Temp = (u32 *)pRetPar + 14U;
  *pu4Temp = (u32 )MaxPDUSize;
  *(pRetPar + 18UL) = ControlType;
  pu2Temp = (u16 *)pRetPar + 19U;
  *pu2Temp = PalCap;
  pu2Temp = (u16 *)pRetPar + 21U;
  *pu2Temp = AmpAssocLen;
  pu4Temp = (u32 *)pRetPar + 23U;
  *pu4Temp = MaxFlushTimeout;
  pu4Temp = (u32 *)pRetPar + 27U;
  *pu4Temp = BestEffortFlushTimeout;
  len = (unsigned int )len + 31U;
  PPacketIrpEvent->Length = len;
  if (BTCoexDbgLevel == 1U) {
    printk("AmpStatus = 0x%x\n", (int )AmpStatus);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("TotalBandwidth = 0x%x, MaxBandGUBandwidth = 0x%x, MinLatency = 0x%x, \n MaxPDUSize = 0x%x, ControlType = 0x%x\n",
           TotalBandwidth, MaxBandGUBandwidth, (int )MinLatency, (int )MaxPDUSize,
           (int )ControlType);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("PalCap = 0x%x, AmpAssocLen = 0x%x, MaxFlushTimeout = 0x%x, BestEffortFlushTimeout = 0x%x\n",
           (int )PalCap, (int )AmpAssocLen, MaxFlushTimeout, BestEffortFlushTimeout);
  } else {
  }
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdCreatePhysicalLink(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntCreatePhyLink = pBtDbg->dbgHciInfo.hciCmdCntCreatePhyLink + 1U;
  status = bthci_BuildPhysicalLink(padapter, pHciCmd, 53);
  return (status);
}
}
static enum hci_status bthci_CmdReadLinkQuality(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  u16 PLH ;
  u8 EntryNum ;
  u8 LinkQuality ;
  u8 localBuf[11U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  LinkQuality = 85U;
  PLH = *((u16 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("PLH = 0x%x\n", (int )PLH);
  } else {
  }
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )((unsigned char )PLH));
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("No such PLH(0x%x)\n", (int )PLH);
    } else {
    }
    status = 2;
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 11U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 3, status);
  len = (int )tmp___0 + (int )len;
  if (BTCoexDbgLevel == 1U) {
    printk(" PLH = 0x%x\n Link Quality = 0x%x\n", (int )PLH, (int )LinkQuality);
  } else {
  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *((u16 *)pRetPar + 1U) = (u16 )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
  *(pRetPar + 3UL) = 85U;
  len = (unsigned int )len + 4U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdReadRSSI(struct rtw_adapter *padapter )
{
  enum hci_status status ;
  {
  status = 0;
  return (status);
}
}
static enum hci_status bthci_CmdCreateLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntCreateLogLink = pBtDbg->dbgHciInfo.hciCmdCntCreateLogLink + 1U;
  bthci_BuildLogicalLink(padapter, pHciCmd, 56);
  return (status);
}
}
static enum hci_status bthci_CmdAcceptLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntAcceptLogLink = pBtDbg->dbgHciInfo.hciCmdCntAcceptLogLink + 1U;
  bthci_BuildLogicalLink(padapter, pHciCmd, 57);
  return (status);
}
}
static enum hci_status bthci_CmdDisconnectLogicalLink(struct rtw_adapter *padapter ,
                                                      struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u16 logicHandle ;
  u8 i ;
  u8 j ;
  u8 find ;
  u8 LogLinkCount ;
  unsigned long tmp ;
  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTinfo->BtMgnt;
  pBtDbg = & pBTinfo->BtDbg;
  find = 0U;
  LogLinkCount = 0U;
  pBtDbg->dbgHciInfo.hciCmdCntDisconnectLogLink = pBtDbg->dbgHciInfo.hciCmdCntDisconnectLogLink + 1U;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("DisconnectLogicalLink, logicHandle = 0x%x\n", (int )logicHandle);
  } else {
  }
  j = 0U;
  goto ldv_55274;
  ldv_55273:
  i = 0U;
  goto ldv_55272;
  ldv_55271: ;
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
    if (BTCoexDbgLevel == 1U) {
      printk("DisconnectLogicalLink, logicHandle is matched  0x%x\n", (int )logicHandle);
    } else {
    }
    bthci_ResetFlowSpec(padapter, (int )j, (int )i);
    find = 1U;
    pBtMgnt->DisconnectEntryNum = j;
    goto ldv_55270;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55272: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55271;
  } else {
  }
  ldv_55270:
  j = (u8 )((int )j + 1);
  ldv_55274: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_55273;
  } else {
  }
  if ((unsigned int )find == 0U) {
    status = 2;
  } else {
  }
  i = 0U;
  goto ldv_55277;
  ldv_55276: ;
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )pBtMgnt->DisconnectEntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle != 0U) {
    LogLinkCount = (u8 )((int )LogLinkCount + 1);
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55277: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55276;
  } else {
  }
  bthci_EventCommandStatus(padapter, 1, 58, status);
  if ((unsigned int )status == 0U) {
    bthci_EventDisconnectLogicalLinkComplete(padapter, status, (int )logicHandle,
                                             22);
  } else {
  }
  if ((unsigned int )LogLinkCount == 0U) {
    tmp = msecs_to_jiffies(100U);
    ldv_mod_timer_2426(& pBTinfo->BTDisconnectPhyLinkTimer, tmp + (unsigned long )jiffies);
  } else {
  }
  return (status);
}
}
static enum hci_status bthci_CmdLogicalLinkCancel(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 CurrentEntryNum ;
  u8 CurrentLogEntryNum ;
  u8 physicalLinkHandle ;
  u8 TxFlowSpecID ;
  u8 i ;
  u16 CurrentLogicalHandle ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTinfo->BtMgnt;
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
  TxFlowSpecID = *((u8 *)(& pHciCmd->Data) + 1UL);
  if (BTCoexDbgLevel == 1U) {
    printk("LogicalLinkCancel, physicalLinkHandle = 0x%x, TxFlowSpecID = 0x%x\n",
           (int )physicalLinkHandle, (int )TxFlowSpecID);
  } else {
  }
  CurrentEntryNum = pBtMgnt->CurrentConnectEntryNum;
  CurrentLogicalHandle = pBtMgnt->BtCurrentLogLinkhandle;
  if (BTCoexDbgLevel == 1U) {
    printk("CurrentEntryNum = 0x%x, CurrentLogicalHandle = 0x%x\n", (int )CurrentEntryNum,
           (int )CurrentLogicalHandle);
  } else {
  }
  CurrentLogEntryNum = 255U;
  i = 0U;
  goto ldv_55294;
  ldv_55293: ;
  if ((int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )CurrentLogicalHandle && (int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle == (int )physicalLinkHandle) {
    CurrentLogEntryNum = i;
    goto ldv_55292;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55294: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55293;
  } else {
  }
  ldv_55292: ;
  if ((unsigned int )CurrentLogEntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("LogicalLinkCancel, CurrentLogEntryNum == 0xff !!!!\n");
    } else {
    }
    status = 2;
    return (status);
  } else
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].bLLCompleteEventIsSet != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("LogicalLinkCancel, LLCompleteEventIsSet!!!!\n");
    } else {
    }
    status = 11;
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 1, 59, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].BtPhyLinkhandle;
  *(pRetPar + 2UL) = pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].BtTxFlowSpecID;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].bLLCancelCMDIsSetandComplete = 1U;
  return (status);
}
}
static enum hci_status bthci_CmdFlowSpecModify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 i ;
  u8 j ;
  u8 find ;
  u16 logicHandle ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  {
  status = 0;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  find = 0U;
  logicHandle = *((u16 *)(& pHciCmd->Data));
  j = 0U;
  goto ldv_55319;
  ldv_55318:
  i = 0U;
  goto ldv_55317;
  ldv_55316: ;
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
    __len = 16UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                       (void const *)(& pHciCmd->Data) + 2U, __len);
    } else {
      __ret = memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                               (void const *)(& pHciCmd->Data) + 2U, __len);
    }
    __len___0 = 16UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                           (void const *)(& pHciCmd->Data) + 18U, __len___0);
    } else {
      __ret___0 = memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                                   (void const *)(& pHciCmd->Data) + 18U, __len___0);
    }
    bthci_CheckLogLinkBehavior(padapter, pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec);
    find = 1U;
    goto ldv_55315;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55317: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55316;
  } else {
  }
  ldv_55315:
  j = (u8 )((int )j + 1);
  ldv_55319: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_55318;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("FlowSpecModify, LLH = 0x%x, \n", (int )logicHandle);
  } else {
  }
  bthci_EventCommandStatus(padapter, 1, 60, 0);
  if ((unsigned int )find == 0U) {
    status = 2;
  } else {
  }
  bthci_EventSendFlowSpecModifyComplete(padapter, status, (int )logicHandle);
  return (status);
}
}
static enum hci_status bthci_CmdAcceptPhysicalLink(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntAcceptPhyLink = pBtDbg->dbgHciInfo.hciCmdCntAcceptPhyLink + 1U;
  status = bthci_BuildPhysicalLink(padapter, pHciCmd, 54);
  return (status);
}
}
static enum hci_status bthci_CmdDisconnectPhysicalLink(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 PLH ;
  u8 CurrentEntryNum ;
  u8 PhysLinkDisconnectReason ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntDisconnectPhyLink = pBtDbg->dbgHciInfo.hciCmdCntDisconnectPhyLink + 1U;
  PLH = *((u8 *)(& pHciCmd->Data));
  PhysLinkDisconnectReason = *((u8 *)(& pHciCmd->Data) + 1UL);
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_DISCONNECT_PHYSICAL_LINK  PhyHandle = 0x%x, Reason = 0x%x\n", (int )PLH,
           (int )PhysLinkDisconnectReason);
  } else {
  }
  CurrentEntryNum = bthci_GetCurrentEntryNum(padapter, (int )PLH);
  if ((unsigned int )CurrentEntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk("DisconnectPhysicalLink, No such Handle in the Entry\n");
    } else {
    }
    status = 2;
  } else {
    pBTInfo->BtAsocEntry[(int )CurrentEntryNum].PhyLinkDisconnectReason = (enum hci_status )PhysLinkDisconnectReason;
  }
  bthci_EventCommandStatus(padapter, 1, 55, status);
  if ((unsigned int )status != 0U) {
    return (status);
  } else {
  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentEntryNum].BtCurrentState == 32U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_CmdDisconnectPhysicalLink",
             3473);
    } else {
    }
    BTHCI_StateMachine(padapter, 32, 2, (int )CurrentEntryNum);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "bthci_CmdDisconnectPhysicalLink",
             3475);
    } else {
    }
    BTHCI_StateMachine(padapter, 16, 2, (int )CurrentEntryNum);
  }
  return (status);
}
}
static enum hci_status bthci_CmdSetACLLinkDataFlowMode(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBtMgnt->ExtConfig.CurrentConnectHandle = *((u16 *)(& pHciCmd->Data));
  pBtMgnt->ExtConfig.CurrentIncomingTrafficMode = (unsigned int )*((u8 *)(& pHciCmd->Data)) + 2U;
  pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = (unsigned int )*((u8 *)(& pHciCmd->Data)) + 3U;
  if (BTCoexDbgLevel == 1U) {
    printk("Connection Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic mode = 0x%x",
           (int )pBtMgnt->ExtConfig.CurrentConnectHandle, (int )pBtMgnt->ExtConfig.CurrentIncomingTrafficMode,
           (int )pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode);
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 16, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  pu2Temp = (u16 *)pRetPar + 1U;
  *pu2Temp = pBtMgnt->ExtConfig.CurrentConnectHandle;
  len = (unsigned int )len + 3U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetACLLinkStatus(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 *pTriple ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntSetAclLinkStatus = pBtDbg->dbgHciInfo.hciCmdCntSetAclLinkStatus + 1U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("SetACLLinkStatus, Hex Data :\n");
    __i = 0U;
    goto ldv_55364;
    ldv_55363:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_55364: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_55363;
    } else {
    }
    printk("\n");
  } else {
  }
  pBtMgnt->bSupportProfile = 1U;
  pBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("NumberOfHandle = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
  } else {
  }
  pTriple = (u8 *)(& pHciCmd->Data) + 1UL;
  i = 0U;
  goto ldv_55367;
  ldv_55366:
  pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = *(pTriple + 2UL);
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = *(pTriple + 3UL);
  if (BTCoexDbgLevel == 1U) {
    printk("Connection_Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic Mode = 0x%x\n",
           (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode,
           (int )pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode);
  } else {
  }
  pTriple = pTriple + 4UL;
  i = (u8 )((int )i + 1);
  ldv_55367: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_55366;
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 32, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetSCOLinkStatus(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntSetScoLinkStatus = pBtDbg->dbgHciInfo.hciCmdCntSetScoLinkStatus + 1U;
  pBtMgnt->ExtConfig.NumberOfSCO = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("NumberOfSCO = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfSCO);
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 48, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetRSSIValue(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  s8 min_bt_rssi ;
  u8 i ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  min_bt_rssi = 0;
  i = 0U;
  goto ldv_55395;
  ldv_55394: ;
  if ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle == (int )*((u16 *)(& pHciCmd->Data))) {
    pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI = (signed char )pHciCmd->Data[2];
    if (BTCoexDbgLevel == 1U) {
      printk("Connection_Handle = 0x%x, RSSI = %d \n", (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI);
    } else {
    }
  } else {
  }
  if ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI <= (int )min_bt_rssi) {
    min_bt_rssi = pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55395: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_55394;
  } else {
  }
  pBtMgnt->ExtConfig.MIN_BT_RSSI = min_bt_rssi;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt rssi], the min rssi is %d\n", (int )min_bt_rssi);
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 64, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdSetCurrentBluetoothStatus(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtMgnt->ExtConfig.CurrentBTStatus = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("SetCurrentBluetoothStatus, CurrentBTStatus = 0x%x\n", (int )pBtMgnt->ExtConfig.CurrentBTStatus);
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 65, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdExtensionVersionNotify(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntExtensionVersionNotify = pBtDbg->dbgHciInfo.hciCmdCntExtensionVersionNotify + 1U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("ExtensionVersionNotify, Hex Data :\n");
    __i = 0U;
    goto ldv_55423;
    ldv_55422:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_55423: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_55422;
    } else {
    }
    printk("\n");
  } else {
  }
  pBtMgnt->ExtConfig.HCIExtensionVer = *((u16 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("HCIExtensionVer = 0x%x\n", (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 256, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdLinkStatusNotify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 *pTriple ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntLinkStatusNotify = pBtDbg->dbgHciInfo.hciCmdCntLinkStatusNotify + 1U;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("LinkStatusNotify, Hex Data :\n");
    __i = 0U;
    goto ldv_55442;
    ldv_55441:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_55442: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_55441;
    } else {
    }
    printk("\n");
  } else {
  }
  pBtMgnt->bSupportProfile = 1U;
  pBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("NumberOfHandle = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCIExtensionVer = %d\n", (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  } else {
  }
  pTriple = (u8 *)(& pHciCmd->Data) + 1UL;
  i = 0U;
  goto ldv_55445;
  ldv_55444: ;
  if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer == 0U) {
    pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = *(pTriple + 2UL);
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = *(pTriple + 3UL);
    if (BTCoexDbgLevel == 1U) {
      printk("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d\n", (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec);
    } else {
    }
    pTriple = pTriple + 4UL;
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer != 0U) {
    pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = *(pTriple + 2UL);
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = *(pTriple + 3UL);
    pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole = *(pTriple + 4UL);
    if (BTCoexDbgLevel == 1U) {
      printk("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d, LinkRole =%d\n",
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole);
    } else {
    }
    pTriple = pTriple + 5UL;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55445: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_55444;
  } else {
  }
  BTHCI_UpdateBTProfileRTKToMoto(padapter);
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 257, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdBtOperationNotify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("Bt Operation notify, Hex Data :\n");
    __i = 0U;
    goto ldv_55461;
    ldv_55460:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_55461: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_55460;
    } else {
    }
    printk("\n");
  } else {
  }
  pBtMgnt->ExtConfig.btOperationCode = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("btOperationCode = 0x%x\n", (int )pBtMgnt->ExtConfig.btOperationCode);
  } else {
  }
  switch ((int )pBtMgnt->ExtConfig.btOperationCode) {
  case 0: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Operation None!!\n");
  } else {
  }
  goto ldv_55464;
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Inquire start!!\n");
  } else {
  }
  goto ldv_55464;
  case 2: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Inquire finished!!\n");
  } else {
  }
  goto ldv_55464;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Paging is started!!\n");
  } else {
  }
  goto ldv_55464;
  case 4: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Paging complete successfully!!\n");
  } else {
  }
  goto ldv_55464;
  case 5: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Paging complete unsuccessfully!!\n");
  } else {
  }
  goto ldv_55464;
  case 6: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Pairing start!!\n");
  } else {
  }
  goto ldv_55464;
  case 7: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Pairing finished!!\n");
  } else {
  }
  goto ldv_55464;
  case 8: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : BT Device is enabled!!\n");
  } else {
  }
  goto ldv_55464;
  case 9: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : BT Device is disabled!!\n");
  } else {
  }
  goto ldv_55464;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("[bt operation] : Unknown, error!!\n");
  } else {
  }
  goto ldv_55464;
  }
  ldv_55464:
  BTDM_AdjustForBtOperation(padapter);
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 258, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdEnableWifiScanNotify(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    ptr = (u8 *)(& pHciCmd->Data);
    printk("Enable Wifi scan notify, Hex Data :\n");
    __i = 0U;
    goto ldv_55489;
    ldv_55488:
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
    if (((__i + 1U) & 15U) == 0U) {
      printk("\n");
    } else {
    }
    __i = __i + 1U;
    ldv_55489: ;
    if ((u32 )pHciCmd->Length > __i) {
      goto ldv_55488;
    } else {
    }
    printk("\n");
  } else {
  }
  pBtMgnt->ExtConfig.bEnableWifiScanNotify = *((u8 *)(& pHciCmd->Data));
  if (BTCoexDbgLevel == 1U) {
    printk("bEnableWifiScanNotify = %d\n", (int )pBtMgnt->ExtConfig.bEnableWifiScanNotify);
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 259, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWIFICurrentChannel(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct mlme_ext_priv *pmlmeext ;
  u8 chnl ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pmlmeext = & padapter->mlmeextpriv;
  chnl = pmlmeext->cur_channel;
  if ((unsigned int )pmlmeext->cur_bwmode == 1U) {
    if ((unsigned int )pmlmeext->cur_ch_offset == 2U) {
      chnl = (unsigned int )chnl + 2U;
    } else
    if ((unsigned int )pmlmeext->cur_ch_offset == 1U) {
      chnl = (unsigned int )chnl + 254U;
    } else {
    }
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Current Channel  = 0x%x\n", (int )chnl);
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 768, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = chnl;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWIFICurrentBandwidth(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  enum ht_channel_width bw ;
  u8 CurrentBW ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  CurrentBW = 0U;
  bw = (enum ht_channel_width )padapter->mlmeextpriv.cur_bwmode;
  if ((unsigned int )bw == 0U) {
    CurrentBW = 0U;
  } else
  if ((unsigned int )bw == 1U) {
    CurrentBW = 1U;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Current BW = 0x%x\n", (int )CurrentBW);
  } else {
  }
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 769, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = CurrentBW;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdWIFIConnectionStatus(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  u8 connectStatus ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  u8 localBuf[8U] ;
  unsigned int tmp___2 ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___3 ;
  {
  status = 0;
  connectStatus = 0U;
  tmp___1 = check_fwstate(& padapter->mlmepriv, 16);
  if ((int )tmp___1) {
    if (padapter->stapriv.asoc_sta_count > 2) {
      connectStatus = 1U;
    } else {
      connectStatus = 0U;
    }
  } else {
    tmp___0 = check_fwstate(& padapter->mlmepriv, 97);
    if ((int )tmp___0) {
      connectStatus = 1U;
    } else {
      tmp = check_fwstate(& padapter->mlmepriv, 128);
      if ((int )tmp) {
        connectStatus = 2U;
      } else {
        connectStatus = 0U;
      }
    }
  }
  localBuf[0] = '\000';
  tmp___2 = 1U;
  while (1) {
    if (tmp___2 >= 8U) {
      break;
    } else {
    }
    localBuf[tmp___2] = (unsigned char)0;
    tmp___2 = tmp___2 + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___3 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 770, status);
  len = (int )tmp___3 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  *(pRetPar + 1UL) = connectStatus;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdEnableDeviceUnderTestMode(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtHciInfo->bInTestMode = 1U;
  pBtHciInfo->bTestIsEnd = 0U;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 6, 3, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdAMPTestEnd(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n");
    } else {
    }
    status = 12;
    return (status);
  } else {
  }
  pBtHciInfo->bTestIsEnd = 1U;
  ldv_del_timer_sync_2427(& pBTInfo->BTTestSendPacketTimer);
  rtl8723a_check_bssid(padapter, 1);
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 4U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("AMP Test End Event \n");
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  PPacketIrpEvent->EventCode = 74U;
  PPacketIrpEvent->Length = 2U;
  PPacketIrpEvent->Data[0] = (u8 )status;
  PPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
  bthci_EventAMPReceiverReport(padapter, 1);
  return (status);
}
}
static enum hci_status bthci_CmdAMPTestCommand(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 localBuf___0[5U] ;
  unsigned int tmp___0 ;
  struct packet_irp_hcievent_data *PPacketIrpEvent___0 ;
  unsigned long tmp___1 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n");
    } else {
    }
    status = 12;
    return (status);
  } else {
  }
  pBtHciInfo->TestScenario = *((u8 *)(& pHciCmd->Data));
  if ((unsigned int )pBtHciInfo->TestScenario == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("TX Single Test \n");
    } else {
    }
  } else
  if ((unsigned int )pBtHciInfo->TestScenario == 2U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Receive Frame Test \n");
    } else {
    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("No Such Test !!!!!!!!!!!!!!!!!! \n");
  } else {
  }
  if ((unsigned int )pBtHciInfo->bTestIsEnd != 0U) {
    localBuf[0] = '\000';
    tmp = 1U;
    while (1) {
      if (tmp >= 5U) {
        break;
      } else {
      }
      localBuf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    if (BTCoexDbgLevel == 1U) {
      printk("AMP Test End Event \n");
    } else {
    }
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
    PPacketIrpEvent->EventCode = 74U;
    PPacketIrpEvent->Length = 2U;
    PPacketIrpEvent->Data[0] = (u8 )status;
    PPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario;
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
    return (status);
  } else {
  }
  bthci_EventCommandStatus(padapter, 6, 9, status);
  localBuf___0[0] = '\000';
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 5U) {
      break;
    } else {
    }
    localBuf___0[tmp___0] = (unsigned char)0;
    tmp___0 = tmp___0 + 1U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk(" HCI_AMP_Start Test Event \n");
  } else {
  }
  PPacketIrpEvent___0 = (struct packet_irp_hcievent_data *)(& localBuf___0);
  PPacketIrpEvent___0->EventCode = 73U;
  PPacketIrpEvent___0->Length = 2U;
  PPacketIrpEvent___0->Data[0] = (u8 )status;
  PPacketIrpEvent___0->Data[1] = pBtHciInfo->TestScenario;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent___0, 4U);
  if ((unsigned int )pBtHciInfo->TestScenario == 1U) {
    tmp___1 = msecs_to_jiffies(50U);
    ldv_mod_timer_2428(& pBTInfo->BTTestSendPacketTimer, tmp___1 + (unsigned long )jiffies);
    if (BTCoexDbgLevel == 1U) {
      printk("TX Single Test \n");
    } else {
    }
  } else
  if ((unsigned int )pBtHciInfo->TestScenario == 2U) {
    rtl8723a_check_bssid(padapter, 0);
    if (BTCoexDbgLevel == 1U) {
      printk("Receive Frame Test \n");
    } else {
    }
  } else {
  }
  return (status);
}
}
static enum hci_status bthci_CmdEnableAMPReceiverReports(struct rtw_adapter *padapter ,
                                                         struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  u8 localBuf___0[6U] ;
  unsigned int tmp___1 ;
  u8 *pRetPar___0 ;
  u8 len___0 ;
  struct packet_irp_hcievent_data *PPacketIrpEvent___0 ;
  u8 tmp___2 ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
    status = 12;
    localBuf[0] = '\000';
    tmp = 1U;
    while (1) {
      if (tmp >= 6U) {
        break;
      } else {
      }
      localBuf[tmp] = (unsigned char)0;
      tmp = tmp + 1U;
    }
    len = 0U;
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
    tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 6, 7, status);
    len = (int )tmp___0 + (int )len;
    pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
    *pRetPar = (u8 )status;
    len = (unsigned int )len + 1U;
    PPacketIrpEvent->Length = len;
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
    return (status);
  } else {
  }
  pBtHciInfo->bTestNeedReport = *((u8 *)(& pHciCmd->Data));
  pBtHciInfo->TestReportInterval = *((u8 *)(& pHciCmd->Data) + 2UL);
  bthci_EventAMPReceiverReport(padapter, 0);
  localBuf___0[0] = '\000';
  tmp___1 = 1U;
  while (1) {
    if (tmp___1 >= 6U) {
      break;
    } else {
    }
    localBuf___0[tmp___1] = (unsigned char)0;
    tmp___1 = tmp___1 + 1U;
  }
  len___0 = 0U;
  PPacketIrpEvent___0 = (struct packet_irp_hcievent_data *)(& localBuf___0);
  tmp___2 = bthci_CommandCompleteHeader((u8 *)(& localBuf___0), 6, 7, status);
  len___0 = (int )tmp___2 + (int )len___0;
  pRetPar___0 = (u8 *)(& PPacketIrpEvent___0->Data) + (unsigned long )len___0;
  *pRetPar___0 = (u8 )status;
  len___0 = (unsigned int )len___0 + 1U;
  PPacketIrpEvent___0->Length = len___0;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent___0, (u32 )((int )len___0 + 2));
  return (status);
}
}
static enum hci_status bthci_CmdHostBufferSize(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  enum hci_status status ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  u8 tmp___0 ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  status = 0;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 6U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].ACLPacketsData.ACLDataPacketLen = *((u16 *)(& pHciCmd->Data));
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].SyncDataPacketLen = *((u8 *)(& pHciCmd->Data) + 2UL);
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].TotalNumACLDataPackets = *((u16 *)(& pHciCmd->Data) + 3U);
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].TotalSyncNumDataPackets = *((u16 *)(& pHciCmd->Data) + 5U);
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 51, status);
  len = (int )tmp___0 + (int )len;
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
  *pRetPar = (u8 )status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->Length = len;
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  return (status);
}
}
static enum hci_status bthci_CmdHostNumberOfCompletedPackets(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  {
  status = 0;
  return (status);
}
}
static enum hci_status bthci_UnknownCMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  {
  status = 1;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  pBtDbg->dbgHciInfo.hciCmdCntUnknown = pBtDbg->dbgHciInfo.hciCmdCntUnknown + 1U;
  bthci_EventCommandStatus(padapter, (int )pHciCmd->OGF, (int )pHciCmd->OCF, status);
  return (status);
}
}
static enum hci_status bthci_HandleOGFInformationalParameters(struct rtw_adapter *padapter ,
                                                              struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_VERSION_INFORMATION\n");
  } else {
  }
  status = bthci_CmdReadLocalVersionInformation(padapter);
  goto ldv_55602;
  case 2: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_SUPPORTED_COMMANDS\n");
  } else {
  }
  status = bthci_CmdReadLocalSupportedCommands(padapter);
  goto ldv_55602;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_SUPPORTED_FEATURES\n");
  } else {
  }
  status = bthci_CmdReadLocalSupportedFeatures(padapter);
  goto ldv_55602;
  case 5: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_BUFFER_SIZE\n");
  } else {
  }
  status = bthci_CmdReadBufferSize(padapter);
  goto ldv_55602;
  case 10: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_DATA_BLOCK_SIZE\n");
  } else {
  }
  status = bthci_CmdReadDataBlockSize(padapter);
  goto ldv_55602;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_HandleOGFInformationalParameters(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {
  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_55602;
  }
  ldv_55602: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFSetEventMaskCMD(struct rtw_adapter *padapter ,
                                                      struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_EVENT_MASK\n");
  } else {
  }
  status = bthci_CmdSetEventMask(padapter, pHciCmd);
  goto ldv_55614;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_RESET\n");
  } else {
  }
  status = bthci_CmdReset(padapter, 1);
  goto ldv_55614;
  case 21: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_CONNECTION_ACCEPT_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdReadConnectionAcceptTimeout(padapter);
  goto ldv_55614;
  case 5: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_EVENT_FILTER\n");
  } else {
  }
  status = bthci_CmdSetEventFilter(padapter, pHciCmd);
  goto ldv_55614;
  case 22: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdWriteConnectionAcceptTimeout(padapter, pHciCmd);
  goto ldv_55614;
  case 23: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_PAGE_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdReadPageTimeout(padapter, pHciCmd);
  goto ldv_55614;
  case 24: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_PAGE_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdWritePageTimeout(padapter, pHciCmd);
  goto ldv_55614;
  case 53: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_HOST_NUMBER_OF_COMPLETED_PACKETS\n");
  } else {
  }
  status = bthci_CmdHostNumberOfCompletedPackets(padapter, pHciCmd);
  goto ldv_55614;
  case 54: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LINK_SUPERVISION_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdReadLinkSupervisionTimeout(padapter, pHciCmd);
  goto ldv_55614;
  case 55: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_LINK_SUPERVISION_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdWriteLinkSupervisionTimeout(padapter, pHciCmd);
  goto ldv_55614;
  case 95: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ENHANCED_FLUSH\n");
  } else {
  }
  status = bthci_CmdEnhancedFlush(padapter, pHciCmd);
  goto ldv_55614;
  case 97: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOGICAL_LINK_ACCEPT_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdReadLogicalLinkAcceptTimeout(padapter, pHciCmd);
  goto ldv_55614;
  case 98: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdWriteLogicalLinkAcceptTimeout(padapter, pHciCmd);
  goto ldv_55614;
  case 99: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_EVENT_MASK_PAGE_2\n");
  } else {
  }
  status = bthci_CmdSetEventMaskPage2(padapter, pHciCmd);
  goto ldv_55614;
  case 100: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCATION_DATA\n");
  } else {
  }
  status = bthci_CmdReadLocationData(padapter, pHciCmd);
  goto ldv_55614;
  case 101: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_LOCATION_DATA\n");
  } else {
  }
  status = bthci_CmdWriteLocationData(padapter, pHciCmd);
  goto ldv_55614;
  case 102: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_FLOW_CONTROL_MODE\n");
  } else {
  }
  status = bthci_CmdReadFlowControlMode(padapter, pHciCmd);
  goto ldv_55614;
  case 103: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_FLOW_CONTROL_MODE\n");
  } else {
  }
  status = bthci_CmdWriteFlowControlMode(padapter, pHciCmd);
  goto ldv_55614;
  case 105: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_BEST_EFFORT_FLUSH_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdReadBestEffortFlushTimeout(padapter, pHciCmd);
  goto ldv_55614;
  case 106: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_BEST_EFFORT_FLUSH_TIMEOUT\n");
  } else {
  }
  status = bthci_CmdWriteBestEffortFlushTimeout(padapter, pHciCmd);
  goto ldv_55614;
  case 107: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SHORT_RANGE_MODE\n");
  } else {
  }
  status = bthci_CmdShortRangeMode(padapter, pHciCmd);
  goto ldv_55614;
  case 51: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_HOST_BUFFER_SIZE\n");
  } else {
  }
  status = bthci_CmdHostBufferSize(padapter, pHciCmd);
  goto ldv_55614;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_HandleOGFSetEventMaskCMD(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {
  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_55614;
  }
  ldv_55614: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFStatusParameters(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 1: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_FAILED_CONTACT_COUNTER\n");
  } else {
  }
  status = bthci_CmdReadFailedContactCounter(padapter, pHciCmd);
  goto ldv_55643;
  case 2: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_RESET_FAILED_CONTACT_COUNTER\n");
  } else {
  }
  status = bthci_CmdResetFailedContactCounter(padapter, pHciCmd);
  goto ldv_55643;
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LINK_QUALITY\n");
  } else {
  }
  status = bthci_CmdReadLinkQuality(padapter, pHciCmd);
  goto ldv_55643;
  case 5: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_RSSI\n");
  } else {
  }
  status = bthci_CmdReadRSSI(padapter);
  goto ldv_55643;
  case 9: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_AMP_INFO\n");
  } else {
  }
  status = bthci_CmdReadLocalAMPInfo(padapter);
  goto ldv_55643;
  case 10: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_READ_LOCAL_AMP_ASSOC\n");
  } else {
  }
  status = bthci_CmdReadLocalAMPAssoc(padapter, pHciCmd);
  goto ldv_55643;
  case 11: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WRITE_REMOTE_AMP_ASSOC\n");
  } else {
  }
  status = bthci_CmdWriteRemoteAMPAssoc(padapter, pHciCmd);
  goto ldv_55643;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_HandleOGFStatusParameters(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {
  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_55643;
  }
  ldv_55643: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFLinkControlCMD(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 53: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_CREATE_PHYSICAL_LINK\n");
  } else {
  }
  status = bthci_CmdCreatePhysicalLink(padapter, pHciCmd);
  goto ldv_55657;
  case 54: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ACCEPT_PHYSICAL_LINK\n");
  } else {
  }
  status = bthci_CmdAcceptPhysicalLink(padapter, pHciCmd);
  goto ldv_55657;
  case 55: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_DISCONNECT_PHYSICAL_LINK\n");
  } else {
  }
  status = bthci_CmdDisconnectPhysicalLink(padapter, pHciCmd);
  goto ldv_55657;
  case 56: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_CREATE_LOGICAL_LINK\n");
  } else {
  }
  status = bthci_CmdCreateLogicalLink(padapter, pHciCmd);
  goto ldv_55657;
  case 57: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ACCEPT_LOGICAL_LINK\n");
  } else {
  }
  status = bthci_CmdAcceptLogicalLink(padapter, pHciCmd);
  goto ldv_55657;
  case 58: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_DISCONNECT_LOGICAL_LINK\n");
  } else {
  }
  status = bthci_CmdDisconnectLogicalLink(padapter, pHciCmd);
  goto ldv_55657;
  case 59: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_LOGICAL_LINK_CANCEL\n");
  } else {
  }
  status = bthci_CmdLogicalLinkCancel(padapter, pHciCmd);
  goto ldv_55657;
  case 60: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_FLOW_SPEC_MODIFY\n");
  } else {
  }
  status = bthci_CmdFlowSpecModify(padapter, pHciCmd);
  goto ldv_55657;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("bthci_HandleOGFLinkControlCMD(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {
  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_55657;
  }
  ldv_55657: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFTestingCMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 3: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ENABLE_DEVICE_UNDER_TEST_MODE\n");
  } else {
  }
  bthci_CmdEnableDeviceUnderTestMode(padapter, pHciCmd);
  goto ldv_55672;
  case 8: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_AMP_TEST_END\n");
  } else {
  }
  bthci_CmdAMPTestEnd(padapter, pHciCmd);
  goto ldv_55672;
  case 9: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_AMP_TEST_COMMAND\n");
  } else {
  }
  bthci_CmdAMPTestCommand(padapter, pHciCmd);
  goto ldv_55672;
  case 7: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ENABLE_AMP_RECEIVER_REPORTS\n");
  } else {
  }
  bthci_CmdEnableAMPReceiverReports(padapter, pHciCmd);
  goto ldv_55672;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {
  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_55672;
  }
  ldv_55672: ;
  return (status);
}
}
static enum hci_status bthci_HandleOGFExtension(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  {
  status = 0;
  switch ((int )pHciCmd->OCF) {
  case 16: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_ACL_LINK_DATA_FLOW_MODE\n");
  } else {
  }
  status = bthci_CmdSetACLLinkDataFlowMode(padapter, pHciCmd);
  goto ldv_55683;
  case 32: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_ACL_LINK_STATUS\n");
  } else {
  }
  status = bthci_CmdSetACLLinkStatus(padapter, pHciCmd);
  goto ldv_55683;
  case 48: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_SCO_LINK_STATUS\n");
  } else {
  }
  status = bthci_CmdSetSCOLinkStatus(padapter, pHciCmd);
  goto ldv_55683;
  case 64: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_RSSI_VALUE\n");
  } else {
  }
  status = bthci_CmdSetRSSIValue(padapter, pHciCmd);
  goto ldv_55683;
  case 65: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_SET_CURRENT_BLUETOOTH_STATUS\n");
  } else {
  }
  status = bthci_CmdSetCurrentBluetoothStatus(padapter, pHciCmd);
  goto ldv_55683;
  case 256: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_EXTENSION_VERSION_NOTIFY\n");
  } else {
  }
  status = bthci_CmdExtensionVersionNotify(padapter, pHciCmd);
  goto ldv_55683;
  case 257: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_LINK_STATUS_NOTIFY\n");
  } else {
  }
  status = bthci_CmdLinkStatusNotify(padapter, pHciCmd);
  goto ldv_55683;
  case 258: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_BT_OPERATION_NOTIFY\n");
  } else {
  }
  status = bthci_CmdBtOperationNotify(padapter, pHciCmd);
  goto ldv_55683;
  case 259: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_ENABLE_WIFI_SCAN_NOTIFY\n");
  } else {
  }
  status = bthci_CmdEnableWifiScanNotify(padapter, pHciCmd);
  goto ldv_55683;
  case 768: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WIFI_CURRENT_CHANNEL\n");
  } else {
  }
  status = bthci_CmdWIFICurrentChannel(padapter, pHciCmd);
  goto ldv_55683;
  case 769: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WIFI_CURRENT_BANDWIDTH\n");
  } else {
  }
  status = bthci_CmdWIFICurrentBandwidth(padapter, pHciCmd);
  goto ldv_55683;
  case 770: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_WIFI_CONNECTION_STATUS\n");
  } else {
  }
  status = bthci_CmdWIFIConnectionStatus(padapter, pHciCmd);
  goto ldv_55683;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {
  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_55683;
  }
  ldv_55683: ;
  return (status);
}
}
static void bthci_StateStarting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Starting], ");
  } else {
  }
  switch ((unsigned int )StateCmd) {
  case 3U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {
  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55704;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {
  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  ldv_del_timer_sync_2429(& pBTInfo->BTHCIJoinTimeoutTimer);
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55704;
  case 4U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_START_COMPLETE\n");
  } else {
  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 1U) {
    bthci_EventChannelSelected(padapter, (int )EntryNum);
  } else {
  }
  goto ldv_55704;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {
  }
  goto ldv_55704;
  }
  ldv_55704: ;
  return;
}
}
static void bthci_StateConnecting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                  u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Connecting], ");
  } else {
  }
  switch ((unsigned int )StateCmd) {
  case 3U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {
  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55716;
  case 6U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_CONNECT_COMPLETE\n");
  } else {
  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 2U) {
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 7);
      printk("\016StateConnecting \n");
    } else {
    }
  } else {
  }
  goto ldv_55716;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {
  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
  ldv_del_timer_sync_2430(& pBTInfo->BTHCIJoinTimeoutTimer);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55716;
  case 9U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n");
  } else {
  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 58;
  pBtMgnt->bNeedNotifyAMPNoCap = 0U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55716;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {
  }
  goto ldv_55716;
  }
  ldv_55716: ;
  return;
}
}
static void bthci_StateConnected(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                 u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;
  u16 logicHandle ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  logicHandle = 0U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Connected], ");
  } else {
  }
  switch ((unsigned int )StateCmd) {
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {
  }
  i = 0U;
  goto ldv_55732;
  ldv_55731: ;
  if ((unsigned int )((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle != 0U) {
    logicHandle = ((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle;
    bthci_EventDisconnectLogicalLinkComplete(padapter, 0, (int )logicHandle, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason);
    ((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle = 0U;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55732: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55731;
  } else {
  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  ldv_del_timer_sync_2431(& pBTInfo->BTHCIJoinTimeoutTimer);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55734;
  case 8U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_DISCONNECT_INDICATE\n");
  } else {
  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, 22, (int )EntryNum);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55734;
  case 12U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_ENTER_STATE\n");
  } else {
  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    pBtMgnt->bBTConnectInProgress = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {
    }
  } else {
  }
  pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState = 8U;
  pBTInfo->BtAsocEntry[(int )EntryNum].b4waySuccess = 1U;
  pBtMgnt->bStartSendSupervisionPkt = 1U;
  rtl8723a_update_ramask(padapter, (u32 )(63 - (int )EntryNum), 0);
  HalSetBrateCfg23a(padapter, (u8 *)(& padapter->mlmepriv.cur_network.network.SupportedRates));
  BTDM_SetFwChnlInfo(padapter, 1);
  goto ldv_55734;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {
  }
  goto ldv_55734;
  }
  ldv_55734: ;
  return;
}
}
static void bthci_StateAuth(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                            u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Authenticating], ");
  } else {
  }
  switch ((unsigned int )StateCmd) {
  case 3U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {
  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55746;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {
  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
  ldv_del_timer_sync_2432(& pBTInfo->BTHCIJoinTimeoutTimer);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55746;
  case 10U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_4WAY_FAILED\n");
  } else {
  }
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 5;
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  ldv_del_timer_sync_2433(& pBTInfo->BTHCIJoinTimeoutTimer);
  goto ldv_55746;
  case 11U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_4WAY_SUCCESSED\n");
  } else {
  }
  bthci_EventPhysicalLinkComplete(padapter, 0, (int )EntryNum, 255);
  ldv_del_timer_sync_2434(& pBTInfo->BTHCIJoinTimeoutTimer);
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateAuth", 4923);
  } else {
  }
  BTHCI_StateMachine(padapter, 8, 12, (int )EntryNum);
  goto ldv_55746;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {
  }
  goto ldv_55746;
  }
  ldv_55746: ;
  return;
}
}
static void bthci_StateDisconnecting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                     u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Disconnecting], ");
  } else {
  }
  switch ((unsigned int )StateCmd) {
  case 9U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n");
  } else {
  }
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent != 0U) {
    bthci_EventPhysicalLinkComplete(padapter, pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus,
                                    (int )EntryNum, 255);
  } else {
  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    pBtMgnt->bBTConnectInProgress = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {
    }
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateDisconnecting",
           4953);
  } else {
  }
  BTHCI_StateMachine(padapter, 32, 12, (int )EntryNum);
  goto ldv_55761;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {
  }
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  ldv_del_timer_sync_2435(& pBTInfo->BTHCIJoinTimeoutTimer);
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
  goto ldv_55761;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {
  }
  goto ldv_55761;
  }
  ldv_55761: ;
  return;
}
}
static void bthci_StateDisconnected(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                    u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_mgnt *pBtMgnt ;
  unsigned long __ms ;
  unsigned long tmp ;
  bool tmp___0 ;
  unsigned long tmp___1 ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state], [Disconnected], ");
  } else {
  }
  switch ((unsigned int )StateCmd) {
  case 0U: ;
  case 1U: ;
  if ((unsigned int )StateCmd == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("STATE_CMD_CREATE_PHY_LINK\n");
    } else {
    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_ACCEPT_PHY_LINK\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT PS], Disable IPS and LPS\n");
  } else {
  }
  ips_leave23a(padapter);
  LPS_Leave23a(padapter);
  pBtMgnt->bPhyLinkInProgress = 1U;
  pBtMgnt->BTCurrentConnectType = 4;
  pBtMgnt->CurrentBTConnectionCnt = (u8 )((int )pBtMgnt->CurrentBTConnectionCnt + 1);
  if (BTCoexDbgLevel == 1U) {
    printk("[BT Flag], CurrentBTConnectionCnt = %d\n", (int )pBtMgnt->CurrentBTConnectionCnt);
  } else {
  }
  pBtMgnt->BtOperationOn = 1U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BT Flag], Bt Operation ON!! CurrentConnectEntryNum = %d\n", (int )pBtMgnt->CurrentConnectEntryNum);
  } else {
  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    bthci_EventPhysicalLinkComplete(padapter, 58, 255, (int )pBtMgnt->BtCurrentPhyLinkhandle);
    bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
    return;
  } else {
  }
  if ((unsigned int )StateCmd == 0U) {
    pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole = 1;
  } else {
    pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole = 2;
  }
  goto ldv_55779;
  ldv_55778: ;
  if (BTCoexDbgLevel == 1U) {
    printk("Scan/Roaming/Wifi Link is in Progress, wait 200 ms\n");
  } else {
  }
  __ms = 200UL;
  goto ldv_55776;
  ldv_55775:
  __const_udelay(4295000UL);
  ldv_55776:
  tmp = __ms;
  __ms = __ms - 1UL;
  if (tmp != 0UL) {
    goto ldv_55775;
  } else {
  }
  ldv_55779:
  tmp___0 = check_fwstate(& padapter->mlmepriv, 2049);
  if ((int )tmp___0) {
    goto ldv_55778;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Channel is Ready\n");
  } else {
  }
  tmp___1 = msecs_to_jiffies((unsigned int const )pBtHciInfo->ConnAcceptTimeout);
  ldv_mod_timer_2436(& pBTInfo->BTHCIJoinTimeoutTimer, tmp___1 + (unsigned long )jiffies);
  pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent = 1U;
  goto ldv_55781;
  case 2U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {
  }
  ldv_del_timer_sync_2437(& pBTInfo->BTHCIJoinTimeoutTimer);
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent != 0U) {
    bthci_EventPhysicalLinkComplete(padapter, 2, (int )EntryNum, 255);
  } else {
  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    pBtMgnt->bBTConnectInProgress = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {
    }
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateDisconnected",
           5047);
  } else {
  }
  BTHCI_StateMachine(padapter, 32, 12, (int )EntryNum);
  bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
  goto ldv_55781;
  case 12U: ;
  if (BTCoexDbgLevel == 1U) {
    printk("STATE_CMD_ENTER_STATE\n");
  } else {
  }
  goto ldv_55781;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {
  }
  goto ldv_55781;
  }
  ldv_55781: ;
  return;
}
}
void BTHCI_EventParse(struct rtw_adapter *padapter , void *pEvntData , u32 dataLen )
{
  {
  return;
}
}
u8 BTHCI_HsConnectionEstablished(struct rtw_adapter *padapter )
{
  u8 bBtConnectionExist ;
  struct bt_30info *pBtinfo ;
  u8 i ;
  {
  bBtConnectionExist = 0U;
  pBtinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  i = 0U;
  goto ldv_55799;
  ldv_55798: ;
  if ((unsigned int )pBtinfo->BtAsocEntry[(int )i].b4waySuccess != 0U) {
    bBtConnectionExist = 1U;
    goto ldv_55797;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55799: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55798;
  } else {
  }
  ldv_55797: ;
  return (bBtConnectionExist);
}
}
static u8 BTHCI_CheckProfileExist(struct rtw_adapter *padapter , enum bt_traffic_mode_profile Profile )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 IsPRofile ;
  u8 i ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  IsPRofile = 0U;
  i = 0U;
  i = 0U;
  goto ldv_55810;
  ldv_55809: ;
  if ((unsigned int )pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile == (unsigned int )Profile) {
    IsPRofile = 1U;
    goto ldv_55808;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55810: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_55809;
  } else {
  }
  ldv_55808: ;
  return (IsPRofile);
}
}
void BTHCI_UpdateBTProfileRTKToMoto(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  i = 0U;
  pBtMgnt->ExtConfig.NumberOfSCO = 0U;
  i = 0U;
  goto ldv_55824;
  ldv_55823:
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = 0U;
  if ((unsigned int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile == 4U) {
    pBtMgnt->ExtConfig.NumberOfSCO = (u8 )((int )pBtMgnt->ExtConfig.NumberOfSCO + 1);
  } else {
  }
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile;
  switch ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile) {
  case 4: ;
  goto ldv_55818;
  case 2:
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 0U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
  goto ldv_55818;
  case 1:
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 3U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 3U;
  goto ldv_55818;
  case 3:
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 1U;
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
  goto ldv_55818;
  default: ;
  goto ldv_55818;
  }
  ldv_55818:
  i = (u8 )((int )i + 1);
  ldv_55824: ;
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
    goto ldv_55823;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], RTK, NumberOfHandle = %d, NumberOfSCO = %d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle,
           (int )pBtMgnt->ExtConfig.NumberOfSCO);
  } else {
  }
  return;
}
}
void BTHCI_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bEnableWifiScanNotify != 0U) {
    bthci_EventExtWifiScanNotify(padapter, (int )scanType);
  } else {
  }
  return;
}
}
void BTHCI_StateMachine(struct rtw_adapter *padapter , u8 StateToEnter , enum hci_state_with_cmd StateCmd ,
                        u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )EntryNum == 255U) {
    if (BTCoexDbgLevel == 1U) {
      printk(" StateMachine, error EntryNum = 0x%x \n", (int )EntryNum);
    } else {
    }
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk(" StateMachine, EntryNum = 0x%x, CurrentState = 0x%x, BtNextState = 0x%x,  StateCmd = 0x%x , StateToEnter = 0x%x\n",
           (int )EntryNum, (int )pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState, (unsigned int )StateCmd,
           (int )StateToEnter);
  } else {
  }
  if ((unsigned int )((int )pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState & (int )StateToEnter) != 0U) {
    pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState = StateToEnter;
    switch ((int )StateToEnter) {
    case 1:
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 18U;
    bthci_StateStarting(padapter, StateCmd, (int )EntryNum);
    goto ldv_55841;
    case 2:
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 22U;
    bthci_StateConnecting(padapter, StateCmd, (int )EntryNum);
    goto ldv_55841;
    case 4:
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 24U;
    bthci_StateAuth(padapter, StateCmd, (int )EntryNum);
    goto ldv_55841;
    case 8:
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 24U;
    bthci_StateConnected(padapter, StateCmd, (int )EntryNum);
    goto ldv_55841;
    case 16:
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 48U;
    bthci_StateDisconnecting(padapter, StateCmd, (int )EntryNum);
    goto ldv_55841;
    case 32:
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 35U;
    bthci_StateDisconnected(padapter, StateCmd, (int )EntryNum);
    goto ldv_55841;
    default: ;
    if (BTCoexDbgLevel == 1U) {
      printk(" StateMachine, Unknown state to enter!!!\n");
    } else {
    }
    goto ldv_55841;
    }
    ldv_55841: ;
  } else
  if (BTCoexDbgLevel == 1U) {
    printk(" StateMachine, Wrong state to enter\n");
  } else {
  }
  if ((unsigned int )pBtMgnt->bBTConnectInProgress == 0U && (unsigned int )pBtMgnt->BtOperationOn == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT PS], ips_enter23a()\n");
    } else {
    }
    ips_enter23a(padapter);
  } else {
  }
  return;
}
}
void BTHCI_DisconnectPeer(struct rtw_adapter *padapter , u8 EntryNum )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk(" BTHCI_DisconnectPeer()\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectPeer", 5216);
  } else {
  }
  BTHCI_StateMachine(padapter, 16, 9, (int )EntryNum);
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
    pBtMgnt->bBTConnectInProgress = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {
    }
  } else {
  }
  bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
  if ((unsigned int )pBtMgnt->bNeedNotifyAMPNoCap != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT AMPStatus], set to invalid in BTHCI_DisconnectPeer()\n");
    } else {
    }
    BTHCI_EventAMPStatusChange(padapter, 2);
  } else {
  }
  return;
}
}
void BTHCI_EventNumOfCompletedDataBlocks(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pTriple ;
  u8 len ;
  u8 i ;
  u8 j ;
  u8 handleNum ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u16 *pPackets ;
  u16 *pHandle ;
  u16 *pDblocks ;
  u8 sent ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtHciInfo = & pBTInfo->BtHciInfo;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 256U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  len = 0U;
  handleNum = 0U;
  sent = 0U;
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  if ((pBtHciInfo->BTEventMaskPage2 & 256ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], Num Of Completed DataBlocks, Ignore to send NumOfCompletedDataBlocksEvent due to event mask page 2\n");
    } else {
    }
    return;
  } else {
  }
  pRetPar = (u8 *)(& PPacketIrpEvent->Data);
  pTriple = pRetPar + 3UL;
  j = 0U;
  goto ldv_55877;
  ldv_55876:
  i = 0U;
  goto ldv_55874;
  ldv_55873: ;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle != 0U) {
    handleNum = (u8 )((int )handleNum + 1);
    pHandle = (u16 *)pTriple;
    pPackets = (u16 *)pTriple + 2U;
    pDblocks = (u16 *)pTriple + 4U;
    *pHandle = pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle;
    *pPackets = (unsigned short )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount;
    *pDblocks = (unsigned short )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount;
    if (pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount != 0U) {
      sent = 1U;
      if (BTCoexDbgLevel == 1U) {
        printk("[BT event], Num Of Completed DataBlocks, Handle = 0x%x, Num_Of_Completed_Packets = 0x%x, Num_Of_Completed_Blocks = 0x%x\n",
               (int )*pHandle, (int )*pPackets, (int )*pDblocks);
      } else {
      }
    } else {
    }
    pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount = 0U;
    len = (unsigned int )len + 6U;
    pTriple = pTriple + (unsigned long )len;
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55874: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55873;
  } else {
  }
  j = (u8 )((int )j + 1);
  ldv_55877: ;
  if ((unsigned int )j <= 1U) {
    goto ldv_55876;
  } else {
  }
  *(pRetPar + 2UL) = handleNum;
  len = (unsigned int )len + 1U;
  pu2Temp = (u16 *)pRetPar;
  *pu2Temp = 256U;
  len = (unsigned int )len + 2U;
  PPacketIrpEvent->EventCode = 72U;
  PPacketIrpEvent->Length = len;
  if ((unsigned int )handleNum != 0U && (unsigned int )sent != 0U) {
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  } else {
  }
  return;
}
}
void BTHCI_EventAMPStatusChange(struct rtw_adapter *padapter , u8 AMP_Status )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 len ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  enum rt_status tmp___0 ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  len = 0U;
  localBuf[0] = '\000';
  tmp = 1U;
  while (1) {
    if (tmp >= 7U) {
      break;
    } else {
    }
    localBuf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )AMP_Status == 2U) {
    pBtMgnt->BTNeedAMPStatusChg = 1U;
    pBtMgnt->bNeedNotifyAMPNoCap = 0U;
    BTHCI_DisconnectAll(padapter);
  } else
  if ((unsigned int )AMP_Status == 6U) {
    pBtMgnt->BTNeedAMPStatusChg = 0U;
  } else {
  }
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
  pRetPar = (u8 *)(& PPacketIrpEvent->Data);
  *pRetPar = 0U;
  len = (unsigned int )len + 1U;
  *(pRetPar + 1UL) = AMP_Status;
  len = (unsigned int )len + 1U;
  PPacketIrpEvent->EventCode = 77U;
  PPacketIrpEvent->Length = len;
  tmp___0 = bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  if ((unsigned int )tmp___0 == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT event], AMP Status Change, AMP_Status = %d\n", (int )AMP_Status);
    } else {
    }
  } else {
  }
  return;
}
}
void BTHCI_DisconnectAll(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  u8 i ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  if (BTCoexDbgLevel == 1U) {
    printk(" DisconnectALL()\n");
  } else {
  }
  i = 0U;
  goto ldv_55896;
  ldv_55895: ;
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].b4waySuccess != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
             5335);
    } else {
    }
    BTHCI_StateMachine(padapter, 8, 2, (int )i);
  } else
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U) {
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].BtCurrentState == 2U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
               5338);
      } else {
      }
      BTHCI_StateMachine(padapter, 2, 9, (int )i);
    } else
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].BtCurrentState == 16U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
               5340);
      } else {
      }
      BTHCI_StateMachine(padapter, 16, 9, (int )i);
    } else {
    }
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_55896: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_55895;
  } else {
  }
  return;
}
}
enum hci_status BTHCI_HandleHCICMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd )
{
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u32 __i ;
  u8 *ptr ;
  {
  status = 0;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  if (BTCoexDbgLevel == 1U) {
    printk("\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI Command start, OGF = 0x%x, OCF = 0x%x, Length = 0x%x\n", (int )pHciCmd->OGF,
           (int )pHciCmd->OCF, (int )pHciCmd->Length);
  } else {
  }
  if ((unsigned int )pHciCmd->Length != 0U) {
    if (BTCoexDbgLevel == 1U) {
      ptr = (u8 *)(& pHciCmd->Data);
      printk("HCI Command, Hex Data :\n");
      __i = 0U;
      goto ldv_55908;
      ldv_55907:
      printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
      if (((__i + 1U) & 15U) == 0U) {
        printk("\n");
      } else {
      }
      __i = __i + 1U;
      ldv_55908: ;
      if ((u32 )pHciCmd->Length > __i) {
        goto ldv_55907;
      } else {
      }
      printk("\n");
    } else {
    }
  } else {
  }
  if ((unsigned int )*((unsigned char *)pHciCmd + 1UL) == 252U) {
    if ((unsigned int )*((unsigned short *)pHciCmd + 0UL) == 64U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BT cmd], ");
      } else {
      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[BT cmd], ");
    } else {
    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("[BT cmd], ");
  } else {
  }
  pBtDbg->dbgHciInfo.hciCmdCnt = pBtDbg->dbgHciInfo.hciCmdCnt + 1U;
  switch ((int )pHciCmd->OGF) {
  case 1:
  status = bthci_HandleOGFLinkControlCMD(padapter, pHciCmd);
  goto ldv_55911;
  case 2: ;
  goto ldv_55911;
  case 3:
  status = bthci_HandleOGFSetEventMaskCMD(padapter, pHciCmd);
  goto ldv_55911;
  case 4:
  status = bthci_HandleOGFInformationalParameters(padapter, pHciCmd);
  goto ldv_55911;
  case 5:
  status = bthci_HandleOGFStatusParameters(padapter, pHciCmd);
  goto ldv_55911;
  case 6:
  status = bthci_HandleOGFTestingCMD(padapter, pHciCmd);
  goto ldv_55911;
  case 63:
  status = bthci_HandleOGFExtension(padapter, pHciCmd);
  goto ldv_55911;
  default: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI Command(), Unknown OGF = 0x%x\n", (int )pHciCmd->OGF);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {
  }
  status = bthci_UnknownCMD(padapter, pHciCmd);
  goto ldv_55911;
  }
  ldv_55911: ;
  if (BTCoexDbgLevel == 1U) {
    printk("HCI Command execution end!!\n");
  } else {
  }
  return (status);
}
}
static char const * const BtStateString[9U] =
  { "BT_DISABLED", "BT_NO_CONNECTION", "BT_CONNECT_IDLE", "BT_INQ_OR_PAG",
        "BT_ACL_ONLY_BUSY", "BT_SCO_ONLY_BUSY", "BT_ACL_SCO_BUSY", "BT_ACL_INQ_OR_PAG",
        "BT_STATE_NOT_DEFINED"};
static void btdm_SetFwIgnoreWlanAct(struct rtw_adapter *padapter , u8 bEnable )
{
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[1U] ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  if ((unsigned int )bEnable != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], BT Ignore Wlan_Act !!\n");
    } else {
    }
    H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 1U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT don\'t ignore Wlan_Act !!\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], set FW for BT Ignore Wlan_Act, write 0x25 = 0x%02x\n", (int )H2C_Parameter[0]);
  } else {
  }
  FillH2CCmd(padapter, 37, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
static void btdm_NotifyFwScan(struct rtw_adapter *padapter , u8 scanType )
{
  u8 H2C_Parameter[1U] ;
  {
  H2C_Parameter[0] = 0U;
  if ((unsigned int )scanType == 1U) {
    H2C_Parameter[0] = 1U;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Notify FW for wifi scan, write 0x3b = 0x%02x\n", (int )H2C_Parameter[0]);
  } else {
  }
  FillH2CCmd(padapter, 59, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
static void btdm_1AntSetPSMode(struct rtw_adapter *padapter , u8 enable , u8 smartps ,
                               u8 mode )
{
  struct pwrctrl_priv *pwrctrl ;
  {
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Current LPS(%s, %d), smartps =%d\n", (unsigned int )enable == 1U ? (char *)"ON" : (char *)"OFF",
           (int )mode, (int )smartps);
  } else {
  }
  pwrctrl = & padapter->pwrctrlpriv;
  if ((unsigned int )enable == 1U) {
    rtw_set_ps_mode23a(padapter, 1, (int )smartps, (int )mode);
  } else {
    rtw_set_ps_mode23a(padapter, 0, 0, 0);
    LPS_RF_ON_check23a(padapter, 100U);
  }
  return;
}
}
static void btdm_1AntTSFSwitch(struct rtw_adapter *padapter , u8 enable )
{
  u8 oldVal ;
  u8 newVal ;
  {
  oldVal = rtl8723au_read8(padapter, 1360U);
  if ((unsigned int )enable != 0U) {
    newVal = (u8 )((unsigned int )oldVal | 8U);
  } else {
    newVal = (unsigned int )oldVal & 247U;
  }
  if ((int )oldVal != (int )newVal) {
    rtl8723au_write8(padapter, 1360U, (int )newVal);
  } else {
  }
  return;
}
}
static u8 btdm_Is1AntPsTdmaStateChange(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  if ((int )pBtdm8723->bPrePsTdmaOn != (int )pBtdm8723->bCurPsTdmaOn || (int )pBtdm8723->prePsTdma != (int )pBtdm8723->curPsTdma) {
    return (1U);
  } else {
    return (0U);
  }
}
}
static void btdm_1AntPsTdma(struct rtw_adapter *padapter , u8 bTurnOn , u8 type )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;
  u8 tmp___15 ;
  u8 tmp___16 ;
  u8 tmp___17 ;
  u8 tmp___18 ;
  u8 tmp___19 ;
  u8 tmp___20 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  pBtdm8723->bCurPsTdmaOn = bTurnOn;
  pBtdm8723->curPsTdma = type;
  if ((unsigned int )bTurnOn != 0U) {
    switch ((int )type) {
    case 1: ;
    default:
    tmp = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp != 0U) {
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 88);
    } else {
    }
    goto ldv_55958;
    case 2:
    tmp___0 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      BTDM_SetFw3a(padapter, 211, 18, 18, 0, 88);
    } else {
    }
    goto ldv_55958;
    case 3:
    tmp___1 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___1 != 0U) {
      BTDM_SetFw3a(padapter, 211, 48, 3, 16, 88);
    } else {
    }
    goto ldv_55958;
    case 4:
    tmp___2 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___2 != 0U) {
      BTDM_SetFw3a(padapter, 147, 21, 3, 20, 0);
    } else {
    }
    goto ldv_55958;
    case 5:
    tmp___3 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___3 != 0U) {
      BTDM_SetFw3a(padapter, 97, 21, 3, 49, 0);
    } else {
    }
    goto ldv_55958;
    case 9:
    tmp___4 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___4 != 0U) {
      BTDM_SetFw3a(padapter, 211, 10, 10, 0, 88);
    } else {
    }
    goto ldv_55958;
    case 10:
    tmp___5 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___5 != 0U) {
      BTDM_SetFw3a(padapter, 19, 10, 10, 0, 64);
    } else {
    }
    goto ldv_55958;
    case 11:
    tmp___6 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___6 != 0U) {
      BTDM_SetFw3a(padapter, 211, 5, 5, 0, 88);
    } else {
    }
    goto ldv_55958;
    case 12:
    tmp___7 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___7 != 0U) {
      BTDM_SetFw3a(padapter, 235, 10, 3, 49, 24);
    } else {
    }
    goto ldv_55958;
    case 20:
    tmp___8 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___8 != 0U) {
      BTDM_SetFw3a(padapter, 19, 37, 37, 0, 0);
    } else {
    }
    goto ldv_55958;
    case 27:
    tmp___9 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___9 != 0U) {
      BTDM_SetFw3a(padapter, 163, 37, 3, 49, 152);
    } else {
    }
    goto ldv_55958;
    case 28:
    tmp___10 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___10 != 0U) {
      BTDM_SetFw3a(padapter, 105, 37, 3, 49, 0);
    } else {
    }
    goto ldv_55958;
    case 29:
    tmp___11 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___11 != 0U) {
      BTDM_SetFw3a(padapter, 235, 26, 26, 1, 24);
      rtl8723au_write32(padapter, 1728U, 1526356730U);
      rtl8723au_write32(padapter, 1732U, 1526356730U);
    } else {
    }
    goto ldv_55958;
    case 30:
    tmp___12 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___12 != 0U) {
      BTDM_SetFw3a(padapter, 147, 21, 3, 20, 0);
    } else {
    }
    goto ldv_55958;
    case 31:
    tmp___13 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___13 != 0U) {
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 88);
    } else {
    }
    goto ldv_55958;
    case 32:
    tmp___14 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___14 != 0U) {
      BTDM_SetFw3a(padapter, 171, 10, 3, 17, 152);
    } else {
    }
    goto ldv_55958;
    case 33:
    tmp___15 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___15 != 0U) {
      BTDM_SetFw3a(padapter, 163, 37, 3, 48, 152);
    } else {
    }
    goto ldv_55958;
    case 34:
    tmp___16 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___16 != 0U) {
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 24);
    } else {
    }
    goto ldv_55958;
    case 35:
    tmp___17 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___17 != 0U) {
      BTDM_SetFw3a(padapter, 227, 26, 26, 0, 24);
    } else {
    }
    goto ldv_55958;
    }
    ldv_55958: ;
  } else {
    switch ((int )type) {
    case 8:
    tmp___18 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___18 != 0U) {
      BTDM_SetFw3a(padapter, 8, 0, 0, 0, 0);
    } else {
    }
    goto ldv_55978;
    case 0: ;
    default:
    tmp___19 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___19 != 0U) {
      BTDM_SetFw3a(padapter, 0, 0, 0, 8, 0);
    } else {
    }
    rtl8723au_write16(padapter, 2144U, 528);
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 0x860 = 0x210, Switch Antenna to BT\n");
    } else {
    }
    goto ldv_55978;
    case 9:
    tmp___20 = btdm_Is1AntPsTdmaStateChange(padapter);
    if ((unsigned int )tmp___20 != 0U) {
      BTDM_SetFw3a(padapter, 0, 0, 0, 8, 0);
    } else {
    }
    rtl8723au_write16(padapter, 2144U, 272);
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 0x860 = 0x110, Switch Antenna to WiFi\n");
    } else {
    }
    goto ldv_55978;
    }
    ldv_55978: ;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Current TDMA(%s, %d)\n", (unsigned int )pBtdm8723->bCurPsTdmaOn != 0U ? (char *)"ON" : (char *)"OFF",
           (int )pBtdm8723->curPsTdma);
  } else {
  }
  pBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;
  pBtdm8723->prePsTdma = pBtdm8723->curPsTdma;
  return;
}
}
static void _btdm_1AntSetPSTDMA(struct rtw_adapter *padapter , u8 bPSEn , u8 smartps ,
                                u8 psOption , u8 bTDMAOn , u8 tdmaType )
{
  struct pwrctrl_priv *pwrctrl ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 psMode ;
  u8 bSwitchPS ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  tmp = check_fwstate(& padapter->mlmepriv, 8);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    tmp___1 = get_fwstate(& padapter->mlmepriv);
    if (tmp___1 != 0) {
      btdm_1AntPsTdma(padapter, (int )bTDMAOn, (int )tdmaType);
      return;
    } else {
    }
  } else {
  }
  psOption = (unsigned int )psOption & 254U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Set LPS(%s, %d) TDMA(%s, %d)\n", (unsigned int )bPSEn == 1U ? (char *)"ON" : (char *)"OFF",
           (int )psOption, (unsigned int )bTDMAOn == 1U ? (char *)"ON" : (char *)"OFF",
           (int )tdmaType);
  } else {
  }
  pwrctrl = & padapter->pwrctrlpriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  if ((unsigned int )bPSEn != 0U) {
    if ((unsigned int )pBtdm8723->bWiFiHalt != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Enable PS Fail, WiFi in Halt!!\n");
      } else {
      }
      return;
    } else {
    }
    if ((unsigned int )pwrctrl->bInSuspend != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Enable PS Fail, WiFi in Suspend!!\n");
      } else {
      }
      return;
    } else {
    }
    if (padapter->bDriverStopped != 0) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Enable PS Fail, WiFi driver stopped!!\n");
      } else {
      }
      return;
    } else {
    }
    if (padapter->bSurpriseRemoved != 0) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Enable PS Fail, WiFi Surprise Removed!!\n");
      } else {
      }
      return;
    } else {
    }
    psMode = 1U;
  } else {
    psMode = 0U;
    psOption = 0U;
  }
  if ((int )pwrctrl->pwr_mode != (int )psMode) {
    bSwitchPS = 1U;
  } else
  if ((unsigned int )psMode != 0U) {
    if ((int )pwrctrl->bcn_ant_mode != (int )psOption) {
      bSwitchPS = 1U;
    } else
    if ((int )pwrctrl->smart_ps != (int )smartps) {
      bSwitchPS = 1U;
    } else {
      bSwitchPS = 0U;
    }
  } else {
    bSwitchPS = 0U;
  }
  if ((unsigned int )bSwitchPS != 0U) {
    if ((unsigned int )pBtdm8723->bCurPsTdmaOn != 0U) {
      if ((unsigned int )bTDMAOn == 0U) {
        btdm_1AntPsTdma(padapter, 0, (int )tdmaType);
      } else {
        tmp___2 = rtl8723a_BT_enabled(padapter);
        if (tmp___2) {
          tmp___3 = 0;
        } else {
          tmp___3 = 1;
        }
        if (((tmp___3 || (unsigned int )pHalData->bt_coexist.halCoex8723.c2hBtInfo == 1U) || (unsigned int )pHalData->bt_coexist.halCoex8723.c2hBtInfo == 2U) || (unsigned int )tdmaType == 29U) {
          btdm_1AntPsTdma(padapter, 0, 9);
        } else {
          btdm_1AntPsTdma(padapter, 0, 0);
        }
      }
    } else {
    }
    btdm_1AntSetPSMode(padapter, (int )bPSEn, (int )smartps, (int )psOption);
  } else {
  }
  btdm_1AntPsTdma(padapter, (int )bTDMAOn, (int )tdmaType);
  return;
}
}
static void btdm_1AntSetPSTDMA(struct rtw_adapter *padapter , u8 bPSEn , u8 psOption ,
                               u8 bTDMAOn , u8 tdmaType )
{
  {
  _btdm_1AntSetPSTDMA(padapter, (int )bPSEn, 0, (int )psOption, (int )bTDMAOn, (int )tdmaType);
  return;
}
}
static void btdm_1AntWifiParaAdjust(struct rtw_adapter *padapter , u8 bEnable )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  if ((unsigned int )bEnable != 0U) {
    pBtdm8723->curWifiPara = 1U;
    if ((int )pBtdm8723->preWifiPara != (int )pBtdm8723->curWifiPara) {
      BTDM_SetSwPenaltyTxRateAdaptive(padapter, 1);
    } else {
    }
  } else {
    pBtdm8723->curWifiPara = 2U;
    if ((int )pBtdm8723->preWifiPara != (int )pBtdm8723->curWifiPara) {
      BTDM_SetSwPenaltyTxRateAdaptive(padapter, 0);
    } else {
    }
  }
  return;
}
}
static void btdm_1AntPtaParaReload(struct rtw_adapter *padapter )
{
  {
  rtl8723au_write8(padapter, 1740U, 0);
  rtl8723au_write32(padapter, 1736U, 65535U);
  rtl8723au_write32(padapter, 1732U, 1431655765U);
  rtl8723au_write32(padapter, 2136U, 2863311530U);
  if ((unsigned int )((struct hal_data_8723a *)padapter->HalData)->VersionID.ICType == 4U && (unsigned int )((struct hal_data_8723a *)padapter->HalData)->VersionID.CUTVersion == 0U) {
    rtl8723au_write32(padapter, 2160U, 0U);
    rtl8723au_write8(padapter, 64U, 36);
  } else {
    rtl8723au_write8(padapter, 64U, 32);
    rtl8723au_write16(padapter, 2144U, 528);
    rtl8723au_write32(padapter, 2160U, 768U);
    rtl8723au_write32(padapter, 2164U, 578830336U);
  }
  rtl8723au_write8(padapter, 1912U, 1);
  btdm_SetFwIgnoreWlanAct(padapter, 0);
  return;
}
}
static s8 btdm_1AntTdmaJudgement(struct rtw_adapter *padapter , u8 retry )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  s8 up___0 ;
  s8 dn ;
  s8 m ;
  s8 n ;
  s8 WaitCount ;
  s8 ret ;
  {
  m = 1;
  n = 3;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  ret = 0;
  if (pBtdm8723->psTdmaMonitorCnt == 0U) {
    up___0 = 0;
    dn = 0;
    m = 1;
    n = 3;
    WaitCount = 0;
  } else {
    WaitCount = (s8 )((int )WaitCount + 1);
  }
  if ((unsigned int )retry == 0U) {
    up___0 = (s8 )((int )up___0 + 1);
    dn = (s8 )((int )dn - 1);
    if ((int )dn < 0) {
      dn = 0;
    } else {
    }
    if ((int )up___0 >= (int )m * 3) {
      ret = 1;
      n = 3;
      up___0 = 0;
      dn = 0;
      WaitCount = 0;
    } else {
    }
  } else
  if ((unsigned int )retry <= 3U) {
    up___0 = (s8 )((int )up___0 - 1);
    dn = (s8 )((int )dn + 1);
    if ((int )up___0 < 0) {
      up___0 = 0;
    } else {
    }
    if ((int )dn == 2) {
      ret = -1;
      if ((int )WaitCount <= 2) {
        m = (s8 )((int )m + 1);
      } else {
        m = 1;
      }
      if ((int )m > 19) {
        m = 20;
      } else {
      }
      up___0 = 0;
      dn = 0;
      WaitCount = 0;
    } else {
    }
  } else {
    ret = -1;
    if ((int )WaitCount == 1) {
      m = (s8 )((int )m + 1);
    } else {
      m = 1;
    }
    if ((int )m > 19) {
      m = 20;
    } else {
    }
    up___0 = 0;
    dn = 0;
    WaitCount = 0;
  }
  return (ret);
}
}
static void btdm_1AntTdmaDurationAdjustForACL(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  s32 judge ;
  s8 tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  if (pBtdm8723->psTdmaGlobalCnt != pBtdm8723->psTdmaMonitorCnt) {
    pBtdm8723->psTdmaMonitorCnt = 0U;
    pBtdm8723->psTdmaGlobalCnt = 0U;
  } else {
  }
  if (pBtdm8723->psTdmaMonitorCnt == 0U) {
    btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 2);
    pBtdm8723->psTdmaDuAdjType = 2U;
  } else {
    if ((((unsigned int )pBtdm8723->curPsTdma != 1U && (unsigned int )pBtdm8723->curPsTdma != 2U) && (unsigned int )pBtdm8723->curPsTdma != 9U) && (unsigned int )pBtdm8723->curPsTdma != 11U) {
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
    } else {
      judge = 0;
      tmp = btdm_1AntTdmaJudgement(padapter, (int )pHalData->bt_coexist.halCoex8723.btRetryCnt);
      judge = (s32 )tmp;
      if (judge == -1) {
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
            pBtdm8723->psTdmaDuAdjType = 2U;
          }
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 9);
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else {
        }
      } else
      if (judge == 1) {
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 9);
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
            pBtdm8723->psTdmaDuAdjType = 2U;
          }
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
            pBtdm8723->psTdmaDuAdjType = 1U;
          }
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else {
        }
      } else {
      }
    }
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], ACL current TDMA(%s, %d)\n", (unsigned int )pBtdm8723->bCurPsTdmaOn != 0U ? (char *)"ON" : (char *)"OFF",
             (int )pBtdm8723->curPsTdma);
    } else {
    }
  }
  pBtdm8723->psTdmaMonitorCnt = pBtdm8723->psTdmaMonitorCnt + 1U;
  return;
}
}
static void btdm_1AntCoexProcessForWifiConnect(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 BtState ;
  u8 tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBtdm8723 = & pBtCoex->btdm1Ant;
  BtState = pBtCoex->c2hBtInfo;
  if (BTCoexDbgLevel == 1U) {
    tmp = BTDM_IsWifiBusy(padapter);
    printk("[BTCoex], WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT is %s\n", BtStateString[(int )BtState]);
  } else {
  }
  padapter->pwrctrlpriv.btcoex_rfon = 0U;
  tmp___0 = BTDM_IsWifiBusy(padapter);
  if ((unsigned int )tmp___0 == 0U) {
    tmp___1 = check_fwstate(& padapter->mlmepriv, 16);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      if ((unsigned int )BtState == 1U || (unsigned int )BtState == 2U) {
        switch ((int )BtState) {
        case 1:
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 38, 0, 9);
        goto ldv_56038;
        case 2:
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 38, 0, 0);
        goto ldv_56038;
        }
        ldv_56038: ;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0:
    switch ((int )BtState) {
    case 1: ;
    case 2:
    btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 5);
    rtl8723au_write32(padapter, 1728U, 1515870810U);
    rtl8723au_write32(padapter, 1732U, 1515870810U);
    goto ldv_56042;
    case 7: ;
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], BT PROFILE is BT_INFO_STATE_ACL_INQ_OR_PAG\n");
    } else {
    }
    case 3:
    padapter->pwrctrlpriv.btcoex_rfon = 1U;
    btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 30);
    goto ldv_56042;
    case 5: ;
    case 6: ;
    if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
      btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 32);
    } else {
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
      rtl8723au_write32(padapter, 1728U, 1515870810U);
      rtl8723au_write32(padapter, 1732U, 1515870810U);
    }
    goto ldv_56042;
    case 4:
    padapter->pwrctrlpriv.btcoex_rfon = 1U;
    if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT PROFILE is HID\n");
      } else {
      }
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 31);
    } else
    if ((unsigned int )pBtCoex->c2hBtProfile == 128U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT PROFILE is FTP/OPP\n");
      } else {
      }
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 3);
    } else
    if ((unsigned int )pBtCoex->c2hBtProfile == 192U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT PROFILE is A2DP_FTP\n");
      } else {
      }
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 11);
    } else {
      if ((unsigned int )pBtCoex->c2hBtProfile == 64U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], BT PROFILE is A2DP\n");
        } else {
        }
      } else
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT PROFILE is UNKNOWN(0x%02X)! Use A2DP Profile\n", (int )pBtCoex->c2hBtProfile);
      } else {
      }
      btdm_1AntTdmaDurationAdjustForACL(padapter);
    }
    goto ldv_56042;
    }
    ldv_56042: ;
  }
  pBtdm8723->psTdmaGlobalCnt = pBtdm8723->psTdmaGlobalCnt + 1U;
  return;
}
}
static void btdm_1AntUpdateHalRAMask(struct rtw_adapter *padapter , u32 mac_id , u32 filter )
{
  u8 init_rate ;
  u8 raid ;
  u32 mask ;
  u8 shortGIrate ;
  int supportRateNum ;
  struct sta_info *psta ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  uint tmp ;
  unsigned int tmp___0 ;
  u32 tmp___1 ;
  int tmp___2 ;
  uint tmp___3 ;
  uint tmp___4 ;
  unsigned char tmp___5 ;
  u8 arg ;
  {
  init_rate = 0U;
  shortGIrate = 0U;
  supportRateNum = 0;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], %s, MACID =%d, filter = 0x%08x!!\n", "btdm_1AntUpdateHalRAMask",
           mac_id, filter);
  } else {
  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pdmpriv = & pHalData->dmpriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  cur_network = & pmlmeinfo->network;
  if (mac_id > 31U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], %s, MACID =%d illegal!!\n", "btdm_1AntUpdateHalRAMask", mac_id);
    } else {
    }
    return;
  } else {
  }
  psta = pmlmeinfo->FW_sta_info[mac_id].psta;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], %s, Can\'t find station!!\n", "btdm_1AntUpdateHalRAMask");
    } else {
    }
    return;
  } else {
  }
  raid = psta->raid;
  switch (mac_id) {
  case 0U:
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
  supportRateNum = (int )tmp;
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
  if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
    tmp___0 = update_MSC_rate23a(& pmlmeinfo->HT_caps);
    tmp___1 = tmp___0;
  } else {
    tmp___1 = 0U;
  }
  mask = tmp___1 | mask;
  tmp___2 = support_short_GI23a(padapter, & pmlmeinfo->HT_caps);
  if (tmp___2 != 0) {
    shortGIrate = 1U;
  } else {
  }
  goto ldv_56066;
  case 1U:
  tmp___3 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
  supportRateNum = (int )tmp___3;
  mask = update_basic_rate23a((unsigned char *)(& cur_network->SupportedRates), (unsigned int )supportRateNum);
  goto ldv_56066;
  default:
  tmp___4 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
  supportRateNum = (int )tmp___4;
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
  goto ldv_56066;
  }
  ldv_56066:
  mask = (u32 )((int )raid << 28) | mask;
  mask = mask;
  mask = ~ filter & mask;
  tmp___5 = get_highest_rate_idx23a(mask);
  init_rate = (unsigned int )tmp___5 & 63U;
  if ((unsigned int )pHalData->fw_ractrl != 0U) {
    arg = 0U;
    arg = (unsigned int )((u8 )mac_id) & 31U;
    arg = (u8 )((unsigned int )arg | 128U);
    if ((unsigned int )shortGIrate == 1U) {
      arg = (u8 )((unsigned int )arg | 32U);
    } else {
    }
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], Update FW RAID entry, MASK = 0x%08x, arg = 0x%02x\n", mask,
             (int )arg);
    } else {
    }
    rtl8723a_set_raid_cmd(padapter, mask, (int )arg);
  } else {
    if ((unsigned int )shortGIrate != 0U) {
      init_rate = (u8 )((unsigned int )init_rate | 64U);
    } else {
    }
    rtl8723au_write8(padapter, mac_id + 1156U, (int )init_rate);
  }
  psta->init_rate = init_rate;
  pdmpriv->INIDATA_RATE[mac_id] = init_rate;
  return;
}
}
static void btdm_1AntUpdateHalRAMaskForSCO(struct rtw_adapter *padapter , u8 forceUpdate )
{
  struct btdm_8723a_1ant *pBtdm8723 ;
  struct sta_priv *pstapriv ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_info *psta ;
  u32 macid ;
  u32 filter ;
  {
  filter = 0U;
  pBtdm8723 = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant;
  if ((unsigned int )pBtdm8723->bRAChanged == 1U && (unsigned int )forceUpdate == 0U) {
    return;
  } else {
  }
  pstapriv = & padapter->stapriv;
  cur_network = & padapter->mlmeextpriv.mlmext_info.network;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& cur_network->MacAddress));
  macid = psta->mac_id;
  filter = filter | 1U;
  filter = filter | 2U;
  filter = filter | 4U;
  filter = filter | 8U;
  filter = filter | 16U;
  filter = filter | 32U;
  btdm_1AntUpdateHalRAMask(padapter, macid, filter);
  pBtdm8723->bRAChanged = 1U;
  return;
}
}
static void btdm_1AntRecoverHalRAMask(struct rtw_adapter *padapter )
{
  struct btdm_8723a_1ant *pBtdm8723 ;
  struct sta_priv *pstapriv ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_info *psta ;
  {
  pBtdm8723 = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant;
  if ((unsigned int )pBtdm8723->bRAChanged == 0U) {
    return;
  } else {
  }
  pstapriv = & padapter->stapriv;
  cur_network = & padapter->mlmeextpriv.mlmext_info.network;
  psta = rtw_get_stainfo23a(pstapriv, (u8 const *)(& cur_network->MacAddress));
  Update_RA_Entry23a(padapter, psta);
  pBtdm8723->bRAChanged = 0U;
  return;
}
}
static void btdm_1AntBTStateChangeHandler(struct rtw_adapter *padapter , enum bt_state_1ant oldState ,
                                          enum bt_state_1ant newState )
{
  struct hal_data_8723a *phaldata ;
  bool tmp ;
  u8 tmp___0 ;
  struct hal_data_8723a *Hal ;
  struct hal_data_8723a *Hal___0 ;
  {
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT state change, %s => %s\n", BtStateString[(unsigned int )oldState],
           BtStateString[(unsigned int )newState]);
  } else {
  }
  if ((unsigned int )newState != 0U) {
    btdm_SetFwIgnoreWlanAct(padapter, 0);
  } else {
  }
  tmp = check_fwstate(& padapter->mlmepriv, 8);
  if ((int )tmp) {
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      if ((unsigned int )newState == 5U || (unsigned int )newState == 6U) {
        btdm_1AntUpdateHalRAMaskForSCO(padapter, 0);
      } else {
        btdm_1AntRecoverHalRAMask(padapter);
      }
    } else {
      phaldata = (struct hal_data_8723a *)padapter->HalData;
      phaldata->bt_coexist.halCoex8723.btdm1Ant.bRAChanged = 0U;
    }
  } else {
    phaldata = (struct hal_data_8723a *)padapter->HalData;
    phaldata->bt_coexist.halCoex8723.btdm1Ant.bRAChanged = 0U;
  }
  if ((unsigned int )oldState == (unsigned int )newState) {
    return;
  } else {
  }
  if ((unsigned int )oldState == 4U) {
    Hal = (struct hal_data_8723a *)padapter->HalData;
    Hal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCnt = 0U;
    Hal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0U;
  } else {
  }
  if ((unsigned int )oldState == 5U || (unsigned int )oldState == 6U) {
    Hal___0 = (struct hal_data_8723a *)padapter->HalData;
    Hal___0->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0U;
  } else {
  }
  if ((unsigned int )oldState == 0U || (unsigned int )oldState == 1U) {
    if ((unsigned int )newState != 0U && (unsigned int )newState != 1U) {
      BTDM_SetSwRfRxLpfCorner(padapter, 1);
      BTDM_AGCTable(padapter, 1);
      BTDM_BBBackOffLevel(padapter, 1);
    } else {
    }
  } else
  if ((unsigned int )newState == 0U || (unsigned int )newState == 1U) {
    BTDM_SetSwRfRxLpfCorner(padapter, 0);
    BTDM_AGCTable(padapter, 0);
    BTDM_BBBackOffLevel(padapter, 0);
  } else {
  }
  return;
}
}
static void btdm_1AntBtCoexistHandler(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex8723 ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex8723 = & pHalData->bt_coexist.halCoex8723;
  pBtdm8723 = & pBtCoex8723->btdm1Ant;
  padapter->pwrctrlpriv.btcoex_rfon = 0U;
  tmp___2 = rtl8723a_BT_enabled(padapter);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], BT is disabled\n");
    } else {
    }
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], wifi is connected\n");
      } else {
      }
      tmp = BTDM_IsWifiBusy(padapter);
      if ((unsigned int )tmp != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Wifi is busy\n");
        } else {
        }
        btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Wifi is idle\n");
        } else {
        }
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 1, 0, 9);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], wifi is disconnected\n");
      } else {
      }
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    }
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], BT is enabled\n");
    } else {
    }
    tmp___1 = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp___1 != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], wifi is connected\n");
      } else {
      }
      btdm_1AntWifiParaAdjust(padapter, 1);
      btdm_1AntCoexProcessForWifiConnect(padapter);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], wifi is disconnected\n");
      } else {
      }
      btdm_1AntWifiParaAdjust(padapter, 0);
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 0);
    }
  }
  btdm_1AntBTStateChangeHandler(padapter, (enum bt_state_1ant )pBtCoex8723->prec2hBtInfo,
                                (enum bt_state_1ant )pBtCoex8723->c2hBtInfo);
  pBtCoex8723->prec2hBtInfo = pBtCoex8723->c2hBtInfo;
  return;
}
}
void BTDM_1AntSignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 RSSI_WiFi_Cmpnstn ;
  u8 RSSI_BT_Cmpnstn ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
  RSSI_WiFi_Cmpnstn = 0U;
  RSSI_BT_Cmpnstn = 0U;
  switch ((int )pBtdm8723->curPsTdma) {
  case 1:
  RSSI_WiFi_Cmpnstn = 11U;
  goto ldv_56111;
  case 2:
  RSSI_WiFi_Cmpnstn = 14U;
  goto ldv_56111;
  case 9:
  RSSI_WiFi_Cmpnstn = 18U;
  goto ldv_56111;
  case 11:
  RSSI_WiFi_Cmpnstn = 20U;
  goto ldv_56111;
  case 4:
  RSSI_WiFi_Cmpnstn = 17U;
  goto ldv_56111;
  case 16:
  RSSI_WiFi_Cmpnstn = 18U;
  goto ldv_56111;
  case 18:
  RSSI_WiFi_Cmpnstn = 14U;
  goto ldv_56111;
  case 23: ;
  case 24: ;
  case 25: ;
  case 26: ;
  case 27: ;
  case 33:
  RSSI_WiFi_Cmpnstn = 22U;
  goto ldv_56111;
  default: ;
  goto ldv_56111;
  }
  ldv_56111: ;
  if ((unsigned long )rssi_wifi != (unsigned long )((u8 *)0U) && (unsigned int )RSSI_WiFi_Cmpnstn != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 1AntSgnlCmpnstn, case %d, WiFiCmpnstn =%d(%d => %d)\n", (int )pBtdm8723->curPsTdma,
             (int )RSSI_WiFi_Cmpnstn, (int )*rssi_wifi, (int )*rssi_wifi + (int )RSSI_WiFi_Cmpnstn);
    } else {
    }
    *rssi_wifi = (int )*rssi_wifi + (int )RSSI_WiFi_Cmpnstn;
  } else {
  }
  if ((unsigned long )rssi_bt != (unsigned long )((u8 *)0U) && (unsigned int )RSSI_BT_Cmpnstn != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 1AntSgnlCmpnstn, case %d, BTCmpnstn =%d(%d => %d)\n", (int )pBtdm8723->curPsTdma,
             (int )RSSI_BT_Cmpnstn, (int )*rssi_bt, (int )*rssi_bt + (int )RSSI_BT_Cmpnstn);
    } else {
    }
    *rssi_bt = (int )*rssi_bt + (int )RSSI_BT_Cmpnstn;
  } else {
  }
  return;
}
}
static void BTDM_1AntParaInit(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBtdm8723 = & pBtCoex->btdm1Ant;
  rtl8723au_write8(padapter, 1902U, 4);
  btdm_1AntPtaParaReload(padapter);
  pBtdm8723->wifiRssiThresh = 48U;
  pBtdm8723->bWiFiHalt = 0U;
  pBtdm8723->bRAChanged = 0U;
  if ((unsigned int )pBtCoex->c2hBtInfo != 0U && (unsigned int )pBtCoex->c2hBtInfo != 1U) {
    BTDM_SetSwRfRxLpfCorner(padapter, 1);
    BTDM_AGCTable(padapter, 1);
    BTDM_BBBackOffLevel(padapter, 1);
  } else {
  }
  return;
}
}
static void BTDM_1AntForHalt(struct rtw_adapter *padapter )
{
  {
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for halt\n");
  } else {
  }
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt = 1U;
  btdm_1AntWifiParaAdjust(padapter, 0);
  btdm_1AntPsTdma(padapter, 0, 0);
  btdm_SetFwIgnoreWlanAct(padapter, 1);
  return;
}
}
static void BTDM_1AntLpsLeave(struct rtw_adapter *padapter )
{
  {
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for LPS Leave\n");
  } else {
  }
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt = 1U;
  btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
  return;
}
}
static void BTDM_1AntWifiAssociateNotify(struct rtw_adapter *padapter , u8 type )
{
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 BtState ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for associate, type =%d\n", (int )type);
  } else {
  }
  if ((unsigned int )type != 0U) {
    rtl8723a_CheckAntenna_Selection(padapter);
    tmp = rtl8723a_BT_enabled(padapter);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    } else {
      pBtCoex = & pHalData->bt_coexist.halCoex8723;
      BtState = pBtCoex->c2hBtInfo;
      btdm_1AntTSFSwitch(padapter, 1);
      if ((unsigned int )BtState == 1U || (unsigned int )BtState == 2U) {
        btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 28);
      } else
      if ((unsigned int )BtState == 5U || (unsigned int )BtState == 6U) {
        btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
        rtl8723au_write32(padapter, 1728U, 1515870810U);
        rtl8723au_write32(padapter, 1732U, 1515870810U);
      } else
      if ((unsigned int )BtState == 4U || (unsigned int )BtState == 7U) {
        if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 35);
        } else {
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 29);
        }
      } else {
      }
    }
  } else {
    tmp___2 = rtl8723a_BT_enabled(padapter);
    if (tmp___2) {
      tmp___3 = 0;
    } else {
      tmp___3 = 1;
    }
    if (tmp___3) {
      tmp___1 = BTDM_IsWifiConnectionExist(padapter);
      if ((unsigned int )tmp___1 == 0U) {
        btdm_1AntPsTdma(padapter, 0, 0);
        btdm_1AntTSFSwitch(padapter, 0);
      } else {
      }
    } else {
    }
    btdm_1AntBtCoexistHandler(padapter);
  }
  return;
}
}
static void BTDM_1AntMediaStatusNotify(struct rtw_adapter *padapter , enum rt_media_status mstatus )
{
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;
  {
  pBtCoex = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723;
  if (BTCoexDbgLevel == 1U) {
    printk("\n\n[BTCoex]******************************\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], MediaStatus, WiFi %s !!\n", (unsigned int )mstatus == 1U ? (char *)"CONNECT" : (char *)"DISCONNECT");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex]******************************\n");
  } else {
  }
  if ((unsigned int )mstatus == 1U) {
    tmp = check_fwstate(& padapter->mlmepriv, 8);
    if ((int )tmp) {
      if ((unsigned int )pBtCoex->c2hBtInfo == 5U || (unsigned int )pBtCoex->c2hBtInfo == 6U) {
        btdm_1AntUpdateHalRAMaskForSCO(padapter, 1);
      } else {
      }
    } else {
    }
    padapter->pwrctrlpriv.DelayLPSLastTimeStamp = jiffies;
    BTDM_1AntForDhcp(padapter);
  } else {
    rtl8723a_DeinitAntenna_Selection(padapter);
    btdm_1AntBtCoexistHandler(padapter);
    pBtCoex->btdm1Ant.bRAChanged = 0U;
  }
  return;
}
}
void BTDM_1AntForDhcp(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u8 BtState ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  BtState = pBtCoex->c2hBtInfo;
  pBtdm8723 = & pBtCoex->btdm1Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for DHCP\n");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    tmp = BTDM_IsWifiBusy(padapter);
    printk("[BTCoex], 1Ant for DHCP, WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], 1Ant for DHCP, %s\n", BtStateString[(int )BtState]);
  } else {
  }
  BTDM_1AntWifiAssociateNotify(padapter, 1);
  return;
}
}
static void BTDM_1AntWifiScanNotify(struct rtw_adapter *padapter , u8 scanType )
{
  struct hal_data_8723a *pHalData ;
  u8 BtState ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  BtState = pHalData->bt_coexist.halCoex8723.c2hBtInfo;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBtdm8723 = & pBtCoex->btdm1Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("\n[BTCoex], 1Ant for wifi scan =%d!!\n", (int )scanType);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    tmp = BTDM_IsWifiBusy(padapter);
    printk("[BTCoex], 1Ant for wifi scan, WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], 1Ant for wifi scan, %s\n", BtStateString[(int )BtState]);
  } else {
  }
  if ((unsigned int )scanType != 0U) {
    rtl8723a_CheckAntenna_Selection(padapter);
    tmp___1 = rtl8723a_BT_enabled(padapter);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    } else {
      tmp___0 = BTDM_IsWifiConnectionExist(padapter);
      if ((unsigned int )tmp___0 == 0U) {
        BTDM_1AntWifiAssociateNotify(padapter, 1);
      } else
      if ((unsigned int )BtState == 5U || (unsigned int )BtState == 6U) {
        if ((unsigned int )pBtCoex->bC2hBtInquiryPage != 0U) {
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 32);
        } else {
          padapter->pwrctrlpriv.btcoex_rfon = 1U;
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 33);
        }
      } else
      if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
        btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 30);
      } else
      if ((unsigned int )BtState == 4U) {
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
        if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 34);
        } else {
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 4);
        }
      } else {
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
        btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 5);
      }
    }
    btdm_NotifyFwScan(padapter, 1);
  } else {
    btdm_NotifyFwScan(padapter, 0);
    btdm_1AntBtCoexistHandler(padapter);
  }
  return;
}
}
static void BTDM_1AntFwC2hBtInfo8723A(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 u1tmp ;
  u8 btState ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  u1tmp = pBtCoex->c2hBtInfoOriginal;
  btState = (unsigned int )u1tmp & 15U;
  pBtCoex->c2hBtProfile = (unsigned int )u1tmp & 224U;
  pBtMgnt->ExtConfig.bBTBusy = 0U;
  pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  if (((unsigned long )btState & 4UL) != 0UL) {
    pBtCoex->bC2hBtInquiryPage = 1U;
  } else {
    pBtCoex->bC2hBtInquiryPage = 0U;
  }
  btState = (unsigned int )btState & 251U;
  if (((unsigned long )btState & 1UL) == 0UL) {
    pBtCoex->c2hBtInfo = 1U;
  } else {
    if ((unsigned int )btState == 1U) {
      pBtCoex->c2hBtInfo = 2U;
    } else
    if ((unsigned int )btState == 9U) {
      if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
        pBtCoex->c2hBtInfo = 7U;
      } else {
        pBtCoex->c2hBtInfo = 4U;
      }
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else
    if ((unsigned int )btState == 3U) {
      pBtCoex->c2hBtInfo = 5U;
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else
    if ((unsigned int )btState == 11U) {
      pBtCoex->c2hBtInfo = 6U;
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else {
      pBtCoex->c2hBtInfo = 8U;
    }
    if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy != 0U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffefffULL;
    } else {
    }
  }
  if ((unsigned int )pBtCoex->c2hBtInfo == 1U || (unsigned int )pBtCoex->c2hBtInfo == 2U) {
    if ((unsigned int )pBtCoex->bC2hBtInquiryPage != 0U) {
      pBtCoex->c2hBtInfo = 3U;
    } else {
    }
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H], %s(%d)\n", BtStateString[(int )pBtCoex->c2hBtInfo], (int )pBtCoex->c2hBtInfo);
  } else {
  }
  if ((unsigned int )pBtCoex->c2hBtProfile != 32U) {
    pBtCoex->c2hBtProfile = (unsigned int )pBtCoex->c2hBtProfile & 223U;
  } else {
  }
  return;
}
}
void BTDM_1AntBtCoexist8723A(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  unsigned long delta_time ;
  bool tmp ;
  bool tmp___0 ;
  unsigned int tmp___1 ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = check_fwstate(pmlmepriv, 2048);
  if ((int )tmp) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], wifi is under scan progress!!\n");
    } else {
    }
    return;
  } else {
  }
  tmp___0 = check_fwstate(pmlmepriv, 128);
  if ((int )tmp___0) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], wifi is under link progress!!\n");
    } else {
    }
    return;
  } else {
  }
  delta_time = (unsigned long )jiffies - padapter->pwrctrlpriv.DelayLPSLastTimeStamp;
  tmp___1 = jiffies_to_msecs(delta_time);
  delta_time = (unsigned long )tmp___1;
  if (delta_time <= 499UL) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], wifi is under DHCP progress(%li ms)!!\n", delta_time);
    } else {
    }
    return;
  } else {
  }
  BTDM_CheckWiFiState(padapter);
  btdm_1AntBtCoexistHandler(padapter);
  return;
}
}
static u8 btdm_ActionAlgorithm(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 bScoExist ;
  u8 bBtLinkExist ;
  u8 bBtHsModeExist ;
  u8 algorithm ;
  u32 tmp ;
  u8 tmp___0 ;
  u32 tmp___1 ;
  u8 tmp___2 ;
  u32 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;
  u8 tmp___15 ;
  u8 tmp___16 ;
  u8 tmp___17 ;
  u8 tmp___18 ;
  u8 tmp___19 ;
  u8 tmp___20 ;
  u8 tmp___21 ;
  u8 tmp___22 ;
  u8 tmp___23 ;
  u8 tmp___24 ;
  u8 tmp___25 ;
  u8 tmp___26 ;
  u8 tmp___27 ;
  u8 tmp___28 ;
  u8 tmp___29 ;
  u8 tmp___30 ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  bScoExist = 0U;
  bBtLinkExist = 0U;
  bBtHsModeExist = 0U;
  algorithm = 0U;
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle != 0U) {
    bBtLinkExist = 1U;
  } else {
  }
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfSCO != 0U) {
    bScoExist = 1U;
  } else {
  }
  pBtdm8723->btStatus = 0U;
  if ((unsigned int )bScoExist != 0U || (unsigned int )bBtHsModeExist != 0U) {
    goto _L;
  } else {
    tmp___6 = BTHCI_CheckProfileExist(padapter, 3);
    if ((unsigned int )tmp___6 != 0U) {
      _L:
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], SCO or HID or HS exists, set BT non-idle !!!\n");
      } else {
      }
      pBtdm8723->btStatus = 2U;
    } else {
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
        tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___0 != 0U) {
          tmp = BTDM_BtTxRxCounterL(padapter);
          if (tmp <= 99U) {
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], A2DP, low priority tx+rx < 100, set BT connected-idle!!!\n");
            } else {
            }
            pBtdm8723->btStatus = 1U;
          } else {
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], A2DP, low priority tx+rx >= 100, set BT non-idle!!!\n");
            } else {
            }
            pBtdm8723->btStatus = 2U;
          }
        } else {
        }
      } else {
      }
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
        tmp___2 = BTHCI_CheckProfileExist(padapter, 2);
        if ((unsigned int )tmp___2 != 0U) {
          tmp___1 = BTDM_BtTxRxCounterL(padapter);
          if (tmp___1 <= 599U) {
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], PAN, low priority tx+rx < 600, set BT connected-idle!!!\n");
            } else {
            }
            pBtdm8723->btStatus = 1U;
          } else
          if (pHalData->bt_coexist.halCoex8723.lowPriorityTx != 0U) {
            if (pHalData->bt_coexist.halCoex8723.lowPriorityRx / pHalData->bt_coexist.halCoex8723.lowPriorityTx > 9U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN, low priority rx/tx > 9, set BT connected-idle!!!\n");
              } else {
              }
              pBtdm8723->btStatus = 1U;
            } else {
            }
          } else {
          }
          if ((unsigned int )pBtdm8723->btStatus != 1U) {
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], PAN, set BT non-idle!!!\n");
            } else {
            }
            pBtdm8723->btStatus = 2U;
          } else {
          }
        } else {
        }
      } else {
      }
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 2U) {
        tmp___4 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___4 != 0U) {
          tmp___5 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___5 != 0U) {
            tmp___3 = BTDM_BtTxRxCounterL(padapter);
            if (tmp___3 <= 599U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN+A2DP, low priority tx+rx < 600, set BT connected-idle!!!\n");
              } else {
              }
              pBtdm8723->btStatus = 1U;
            } else
            if (pHalData->bt_coexist.halCoex8723.lowPriorityTx != 0U) {
              if (pHalData->bt_coexist.halCoex8723.lowPriorityRx / pHalData->bt_coexist.halCoex8723.lowPriorityTx > 9U) {
                if (BTCoexDbgLevel == 1U) {
                  printk("[BTCoex], PAN+A2DP, low priority rx/tx > 9, set BT connected-idle!!!\n");
                } else {
                }
                pBtdm8723->btStatus = 1U;
              } else {
              }
            } else {
            }
            if ((unsigned int )pBtdm8723->btStatus != 1U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN+A2DP, set BT non-idle!!!\n");
              } else {
              }
              pBtdm8723->btStatus = 2U;
            } else {
            }
          } else {
          }
        } else {
        }
      } else {
      }
    }
  }
  if ((unsigned int )pBtdm8723->btStatus != 0U) {
    pBtMgnt->ExtConfig.bBTBusy = 1U;
  } else {
    pBtMgnt->ExtConfig.bBTBusy = 0U;
  }
  if ((unsigned int )bBtLinkExist == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], No profile exists!!!\n");
    } else {
    }
    return (algorithm);
  } else {
  }
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
    if ((unsigned int )bScoExist != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], SCO only\n");
      } else {
      }
      algorithm = 1U;
    } else {
      tmp___9 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___9 != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID only\n");
        } else {
        }
        algorithm = 2U;
      } else {
        tmp___8 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___8 != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], A2DP only\n");
          } else {
          }
          algorithm = 3U;
        } else {
          tmp___7 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___7 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN(HS) only\n");
              } else {
              }
              algorithm = 5U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], PAN(EDR) only\n");
              } else {
              }
              algorithm = 4U;
            }
          } else
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d \n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {
          }
        }
      }
    }
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 2U) {
    if ((unsigned int )bScoExist != 0U) {
      tmp___12 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___12 != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], SCO + HID\n");
        } else {
        }
        algorithm = 2U;
      } else {
        tmp___11 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___11 != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! SCO + A2DP\n");
          } else {
          }
        } else {
          tmp___10 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___10 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], SCO + PAN(HS)\n");
              } else {
              }
              algorithm = 1U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], SCO + PAN(EDR)\n");
              } else {
              }
              algorithm = 7U;
            }
          } else
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! SCO exists but why NO matched ACL profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {
          }
        }
      }
    } else {
      tmp___17 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___17 != 0U) {
        tmp___18 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___18 != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + A2DP\n");
          } else {
          }
          algorithm = 9U;
        } else {
          goto _L___2;
        }
      } else {
        _L___2:
        tmp___15 = BTHCI_CheckProfileExist(padapter, 3);
        if ((unsigned int )tmp___15 != 0U) {
          tmp___16 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___16 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], HID + PAN(HS)\n");
              } else {
              }
              algorithm = 9U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], HID + PAN(EDR)\n");
              } else {
              }
              algorithm = 7U;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1:
          tmp___13 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___13 != 0U) {
            tmp___14 = BTHCI_CheckProfileExist(padapter, 1);
            if ((unsigned int )tmp___14 != 0U) {
              if ((unsigned int )bBtHsModeExist != 0U) {
                if (BTCoexDbgLevel == 1U) {
                  printk("[BTCoex], A2DP + PAN(HS)\n");
                } else {
                }
                algorithm = 3U;
              } else {
                if (BTCoexDbgLevel == 1U) {
                  printk("[BTCoex], A2DP + PAN(EDR)\n");
                } else {
                }
                algorithm = 6U;
              }
            } else {
              goto _L___0;
            }
          } else
          _L___0:
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {
          }
        }
      }
    }
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 3U) {
    if ((unsigned int )bScoExist != 0U) {
      tmp___23 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___23 != 0U) {
        tmp___24 = BTHCI_CheckProfileExist(padapter, 1);
        if ((unsigned int )tmp___24 != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! SCO + HID + A2DP\n");
          } else {
          }
        } else {
          goto _L___5;
        }
      } else {
        _L___5:
        tmp___21 = BTHCI_CheckProfileExist(padapter, 3);
        if ((unsigned int )tmp___21 != 0U) {
          tmp___22 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___22 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], SCO + HID + PAN(HS)\n");
              } else {
              }
              algorithm = 9U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], SCO + HID + PAN(EDR)\n");
              } else {
              }
              algorithm = 7U;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4:
          tmp___19 = BTHCI_CheckProfileExist(padapter, 2);
          if ((unsigned int )tmp___19 != 0U) {
            tmp___20 = BTHCI_CheckProfileExist(padapter, 1);
            if ((unsigned int )tmp___20 != 0U) {
              if ((unsigned int )bBtHsModeExist != 0U) {
                if (BTCoexDbgLevel == 1U) {
                  printk("[BTCoex], Error!!! SCO + A2DP + PAN(HS)\n");
                } else {
                }
                algorithm = 1U;
              } else
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], Error!!! SCO + A2DP + PAN(EDR)\n");
              } else {
              }
            } else {
              goto _L___3;
            }
          } else
          _L___3:
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {
          }
        }
      }
    } else {
      tmp___25 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___25 != 0U) {
        tmp___26 = BTHCI_CheckProfileExist(padapter, 2);
        if ((unsigned int )tmp___26 != 0U) {
          tmp___27 = BTHCI_CheckProfileExist(padapter, 1);
          if ((unsigned int )tmp___27 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], HID + A2DP + PAN(HS)\n");
              } else {
              }
              algorithm = 10U;
            } else {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
              } else {
              }
              algorithm = 8U;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else
      _L___7:
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
      } else {
      }
    }
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle > 2U) {
    if ((unsigned int )bScoExist != 0U) {
      tmp___28 = BTHCI_CheckProfileExist(padapter, 3);
      if ((unsigned int )tmp___28 != 0U) {
        tmp___29 = BTHCI_CheckProfileExist(padapter, 2);
        if ((unsigned int )tmp___29 != 0U) {
          tmp___30 = BTHCI_CheckProfileExist(padapter, 1);
          if ((unsigned int )tmp___30 != 0U) {
            if ((unsigned int )bBtHsModeExist != 0U) {
              if (BTCoexDbgLevel == 1U) {
                printk("[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
              } else {
              }
            } else
            if (BTCoexDbgLevel == 1U) {
              printk("[BTCoex], Error!!! SCO + HID + A2DP + PAN(EDR)\n");
            } else {
            }
          } else {
            goto _L___9;
          }
        } else {
          goto _L___9;
        }
      } else
      _L___9:
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",
               (int )pBtMgnt->ExtConfig.NumberOfHandle);
      } else {
      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
    } else {
    }
  } else {
  }
  return (algorithm);
}
}
static u8 btdm_NeedToDecBtPwr(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  bRet = 0U;
  tmp___0 = BT_Operation(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB > 47) {
      if (BTCoexDbgLevel == 1U) {
        printk("Need to decrease bt power for HS mode!!\n");
      } else {
      }
      bRet = 1U;
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("NO Need to decrease bt power for HS mode!!\n");
    } else {
    }
  } else {
    tmp = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Need to decrease bt power for Wifi is connected!!\n");
      } else {
      }
      bRet = 1U;
    } else {
    }
  }
  return (bRet);
}
}
static void btdm_SetCoexTable(struct rtw_adapter *padapter , u32 val0x6c0 , u32 val0x6c8 ,
                              u8 val0x6cc )
{
  {
  if (BTCoexDbgLevel == 1U) {
    printk("set coex table, set 0x6c0 = 0x%x\n", val0x6c0);
  } else {
  }
  rtl8723au_write32(padapter, 1728U, val0x6c0);
  if (BTCoexDbgLevel == 1U) {
    printk("set coex table, set 0x6c8 = 0x%x\n", val0x6c8);
  } else {
  }
  rtl8723au_write32(padapter, 1736U, val0x6c8);
  if (BTCoexDbgLevel == 1U) {
    printk("set coex table, set 0x6cc = 0x%x\n", (int )val0x6cc);
  } else {
  }
  rtl8723au_write8(padapter, 1740U, (int )val0x6cc);
  return;
}
}
static void btdm_SetSwFullTimeDacSwing(struct rtw_adapter *padapter , u8 bSwDacSwingOn ,
                                       u32 swDacSwingLvl )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )bSwDacSwingOn != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], SwDacSwing = 0x%x\n", swDacSwingLvl);
    } else {
    }
    PHY_SetBBReg(padapter, 2176U, 4278190080U, swDacSwingLvl);
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], SwDacSwing Off!\n");
    } else {
    }
    PHY_SetBBReg(padapter, 2176U, 4278190080U, 192U);
  }
  return;
}
}
static void btdm_SetFwDacSwingLevel(struct rtw_adapter *padapter , u8 dacSwingLvl )
{
  u8 H2C_Parameter[1U] ;
  {
  H2C_Parameter[0] = 0U;
  H2C_Parameter[0] = dacSwingLvl;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Set Dac Swing Level = 0x%x\n", (int )dacSwingLvl);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], write 0x29 = 0x%x\n", (int )H2C_Parameter[0]);
  } else {
  }
  FillH2CCmd(padapter, 41, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
static void btdm_2AntDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Dec BT power = %s\n", (unsigned int )bDecBtPwr != 0U ? (char *)"ON" : (char *)"OFF");
  } else {
  }
  pBtdm8723->bCurDecBtPwr = bDecBtPwr;
  if ((int )pBtdm8723->bPreDecBtPwr == (int )pBtdm8723->bCurDecBtPwr) {
    return;
  } else {
  }
  BTDM_SetFwDecBtPwr(padapter, (int )pBtdm8723->bCurDecBtPwr);
  pBtdm8723->bPreDecBtPwr = pBtdm8723->bCurDecBtPwr;
  return;
}
}
static void btdm_2AntFwDacSwingLvl(struct rtw_adapter *padapter , u8 fwDacSwingLvl )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], set FW Dac Swing level = %d\n", (int )fwDacSwingLvl);
  } else {
  }
  pBtdm8723->curFwDacSwingLvl = fwDacSwingLvl;
  if ((int )pBtdm8723->preFwDacSwingLvl == (int )pBtdm8723->curFwDacSwingLvl) {
    return;
  } else {
  }
  btdm_SetFwDacSwingLevel(padapter, (int )pBtdm8723->curFwDacSwingLvl);
  pBtdm8723->preFwDacSwingLvl = pBtdm8723->curFwDacSwingLvl;
  return;
}
}
static void btdm_2AntRfShrink(struct rtw_adapter *padapter , u8 bRxRfShrinkOn )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn Rx RF Shrink = %s\n", (unsigned int )bRxRfShrinkOn != 0U ? (char *)"ON" : (char *)"OFF");
  } else {
  }
  pBtdm8723->bCurRfRxLpfShrink = bRxRfShrinkOn;
  if ((int )pBtdm8723->bPreRfRxLpfShrink == (int )pBtdm8723->bCurRfRxLpfShrink) {
    return;
  } else {
  }
  BTDM_SetSwRfRxLpfCorner(padapter, (int )pBtdm8723->bCurRfRxLpfShrink);
  pBtdm8723->bPreRfRxLpfShrink = pBtdm8723->bCurRfRxLpfShrink;
  return;
}
}
static void btdm_2AntLowPenaltyRa(struct rtw_adapter *padapter , u8 bLowPenaltyRa )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn LowPenaltyRA = %s\n", (unsigned int )bLowPenaltyRa != 0U ? (char *)"ON" : (char *)"OFF");
  } else {
  }
  pBtdm8723->bCurLowPenaltyRa = bLowPenaltyRa;
  if ((int )pBtdm8723->bPreLowPenaltyRa == (int )pBtdm8723->bCurLowPenaltyRa) {
    return;
  } else {
  }
  BTDM_SetSwPenaltyTxRateAdaptive(padapter, (int )pBtdm8723->bCurLowPenaltyRa);
  pBtdm8723->bPreLowPenaltyRa = pBtdm8723->bCurLowPenaltyRa;
  return;
}
}
static void btdm_2AntDacSwing(struct rtw_adapter *padapter , u8 bDacSwingOn , u32 dacSwingLvl )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  unsigned long __ms ;
  unsigned long tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn DacSwing =%s, dacSwingLvl = 0x%x\n", (unsigned int )bDacSwingOn != 0U ? (char *)"ON" : (char *)"OFF",
           dacSwingLvl);
  } else {
  }
  pBtdm8723->bCurDacSwingOn = bDacSwingOn;
  pBtdm8723->curDacSwingLvl = dacSwingLvl;
  if ((int )pBtdm8723->bPreDacSwingOn == (int )pBtdm8723->bCurDacSwingOn && pBtdm8723->preDacSwingLvl == pBtdm8723->curDacSwingLvl) {
    return;
  } else {
  }
  __ms = 30UL;
  goto ldv_56245;
  ldv_56244:
  __const_udelay(4295000UL);
  ldv_56245:
  tmp = __ms;
  __ms = __ms - 1UL;
  if (tmp != 0UL) {
    goto ldv_56244;
  } else {
  }
  btdm_SetSwFullTimeDacSwing(padapter, (int )bDacSwingOn, dacSwingLvl);
  pBtdm8723->bPreDacSwingOn = pBtdm8723->bCurDacSwingOn;
  pBtdm8723->preDacSwingLvl = pBtdm8723->curDacSwingLvl;
  return;
}
}
static void btdm_2AntAdcBackOff(struct rtw_adapter *padapter , u8 bAdcBackOff )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn AdcBackOff = %s\n", (unsigned int )bAdcBackOff != 0U ? (char *)"ON" : (char *)"OFF");
  } else {
  }
  pBtdm8723->bCurAdcBackOff = bAdcBackOff;
  if ((int )pBtdm8723->bPreAdcBackOff == (int )pBtdm8723->bCurAdcBackOff) {
    return;
  } else {
  }
  BTDM_BBBackOffLevel(padapter, (int )pBtdm8723->bCurAdcBackOff);
  pBtdm8723->bPreAdcBackOff = pBtdm8723->bCurAdcBackOff;
  return;
}
}
static void btdm_2AntAgcTable(struct rtw_adapter *padapter , u8 bAgcTableEn )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], %s Agc Table\n", (unsigned int )bAgcTableEn != 0U ? (char *)"Enable" : (char *)"Disable");
  } else {
  }
  pBtdm8723->bCurAgcTableEn = bAgcTableEn;
  if ((int )pBtdm8723->bPreAgcTableEn == (int )pBtdm8723->bCurAgcTableEn) {
    return;
  } else {
  }
  BTDM_AGCTable(padapter, (int )bAgcTableEn);
  pBtdm8723->bPreAgcTableEn = pBtdm8723->bCurAgcTableEn;
  return;
}
}
static void btdm_2AntCoexTable(struct rtw_adapter *padapter , u32 val0x6c0 , u32 val0x6c8 ,
                               u8 val0x6cc )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], write Coex Table 0x6c0 = 0x%x, 0x6c8 = 0x%x, 0x6cc = 0x%x\n",
           val0x6c0, val0x6c8, (int )val0x6cc);
  } else {
  }
  pBtdm8723->curVal0x6c0 = val0x6c0;
  pBtdm8723->curVal0x6c8 = val0x6c8;
  pBtdm8723->curVal0x6cc = val0x6cc;
  if ((pBtdm8723->preVal0x6c0 == pBtdm8723->curVal0x6c0 && pBtdm8723->preVal0x6c8 == pBtdm8723->curVal0x6c8) && (int )pBtdm8723->preVal0x6cc == (int )pBtdm8723->curVal0x6cc) {
    return;
  } else {
  }
  btdm_SetCoexTable(padapter, val0x6c0, val0x6c8, (int )val0x6cc);
  pBtdm8723->preVal0x6c0 = pBtdm8723->curVal0x6c0;
  pBtdm8723->preVal0x6c8 = pBtdm8723->curVal0x6c8;
  pBtdm8723->preVal0x6cc = pBtdm8723->curVal0x6cc;
  return;
}
}
static void btdm_2AntIgnoreWlanAct(struct rtw_adapter *padapter , u8 bEnable )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], turn Ignore WlanAct %s\n", (unsigned int )bEnable != 0U ? (char *)"ON" : (char *)"OFF");
  } else {
  }
  pBtdm8723->bCurIgnoreWlanAct = bEnable;
  if ((int )pBtdm8723->bPreIgnoreWlanAct == (int )pBtdm8723->bCurIgnoreWlanAct) {
    return;
  } else {
  }
  btdm_SetFwIgnoreWlanAct(padapter, (int )bEnable);
  pBtdm8723->bPreIgnoreWlanAct = pBtdm8723->bCurIgnoreWlanAct;
  return;
}
}
static void btdm_2AntSetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 ,
                             u8 byte3 , u8 byte4 , u8 byte5 )
{
  u8 H2C_Parameter[5U] ;
  unsigned int tmp ;
  struct hal_data_8723a *pHalData ;
  {
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {
    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )byte1 != 0U) {
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
  }
  H2C_Parameter[0] = byte1;
  H2C_Parameter[1] = byte2;
  H2C_Parameter[2] = byte3;
  H2C_Parameter[3] = byte4;
  H2C_Parameter[4] = byte5;
  pHalData->bt_coexist.fw3aVal[0] = byte1;
  pHalData->bt_coexist.fw3aVal[1] = byte2;
  pHalData->bt_coexist.fw3aVal[2] = byte3;
  pHalData->bt_coexist.fw3aVal[3] = byte4;
  pHalData->bt_coexist.fw3aVal[4] = byte5;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], FW write 0x3a(5bytes) = 0x%x%08x\n", (int )H2C_Parameter[0],
           ((((int )H2C_Parameter[1] << 24) | ((int )H2C_Parameter[2] << 16)) | ((int )H2C_Parameter[3] << 8)) | (int )H2C_Parameter[4]);
  } else {
  }
  FillH2CCmd(padapter, 58, 5U, (u8 *)(& H2C_Parameter));
  return;
}
}
static void btdm_2AntPsTdma(struct rtw_adapter *padapter , u8 bTurnOn , u8 type )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u32 btTxRxCnt ;
  u8 bTurnOnByCnt ;
  u8 psTdmaTypeByCnt ;
  u32 tmp ;
  u32 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  btTxRxCnt = 0U;
  bTurnOnByCnt = 0U;
  psTdmaTypeByCnt = 0U;
  tmp = BTDM_BtTxRxCounterH(padapter);
  tmp___0 = BTDM_BtTxRxCounterL(padapter);
  btTxRxCnt = tmp + tmp___0;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT TxRx Counters = %d\n", btTxRxCnt);
  } else {
  }
  if (btTxRxCnt > 3000U) {
    bTurnOnByCnt = 1U;
    psTdmaTypeByCnt = 8U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], For BTTxRxCounters, turn %s PS TDMA, type =%d\n", (unsigned int )bTurnOnByCnt != 0U ? (char *)"ON" : (char *)"OFF",
             (int )psTdmaTypeByCnt);
    } else {
    }
    pBtdm8723->bCurPsTdmaOn = bTurnOnByCnt;
    pBtdm8723->curPsTdma = psTdmaTypeByCnt;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], turn %s PS TDMA, type =%d\n", (unsigned int )bTurnOn != 0U ? (char *)"ON" : (char *)"OFF",
             (int )type);
    } else {
    }
    pBtdm8723->bCurPsTdmaOn = bTurnOn;
    pBtdm8723->curPsTdma = type;
  }
  if ((int )pBtdm8723->bPrePsTdmaOn == (int )pBtdm8723->bCurPsTdmaOn && (int )pBtdm8723->prePsTdma == (int )pBtdm8723->curPsTdma) {
    return;
  } else {
  }
  if ((unsigned int )bTurnOn != 0U) {
    switch ((int )type) {
    case 1: ;
    default:
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 161, 152);
    goto ldv_56295;
    case 2:
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 161, 152);
    goto ldv_56295;
    case 3:
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 161, 152);
    goto ldv_56295;
    case 4:
    btdm_2AntSetFw3a(padapter, 163, 5, 5, 161, 128);
    goto ldv_56295;
    case 5:
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 32, 152);
    goto ldv_56295;
    case 6:
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 32, 152);
    goto ldv_56295;
    case 7:
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 32, 152);
    goto ldv_56295;
    case 8:
    btdm_2AntSetFw3a(padapter, 163, 5, 5, 32, 128);
    goto ldv_56295;
    case 9:
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 161, 152);
    goto ldv_56295;
    case 10:
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 161, 152);
    goto ldv_56295;
    case 11:
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 161, 152);
    goto ldv_56295;
    case 12:
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 161, 152);
    goto ldv_56295;
    case 13:
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 32, 152);
    goto ldv_56295;
    case 14:
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 32, 152);
    goto ldv_56295;
    case 15:
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 32, 152);
    goto ldv_56295;
    case 16:
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 32, 152);
    goto ldv_56295;
    case 17:
    btdm_2AntSetFw3a(padapter, 163, 47, 47, 32, 128);
    goto ldv_56295;
    case 18:
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 161, 152);
    goto ldv_56295;
    case 19:
    btdm_2AntSetFw3a(padapter, 227, 37, 37, 161, 152);
    goto ldv_56295;
    case 20:
    btdm_2AntSetFw3a(padapter, 227, 37, 37, 32, 152);
    goto ldv_56295;
    }
    ldv_56295: ;
  } else {
    switch ((int )type) {
    case 0:
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 8, 0);
    goto ldv_56316;
    case 1:
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 0, 0);
    goto ldv_56316;
    default:
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 8, 0);
    goto ldv_56316;
    }
    ldv_56316: ;
  }
  pBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;
  pBtdm8723->prePsTdma = pBtdm8723->curPsTdma;
  return;
}
}
static void btdm_2AntBtInquiryPage(struct rtw_adapter *padapter )
{
  {
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
  btdm_2AntIgnoreWlanAct(padapter, 0);
  btdm_2AntPsTdma(padapter, 1, 8);
  return;
}
}
static u8 btdm_HoldForBtInqPage(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u32 curTime ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  curTime = (u32 )jiffies;
  if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage != 0U) {
    if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime == 0UL) {
      pHalData->bt_coexist.halCoex8723.btInqPageStartTime = (unsigned long )curTime;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT Inquiry/page is started at time : 0x%lx \n", pHalData->bt_coexist.halCoex8723.btInqPageStartTime);
      } else {
      }
    } else {
    }
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], BT Inquiry/page started time : 0x%lx, curTime : 0x%x \n", pHalData->bt_coexist.halCoex8723.btInqPageStartTime,
           curTime);
  } else {
  }
  if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime != 0UL) {
    if ((unsigned long )curTime - pHalData->bt_coexist.halCoex8723.btInqPageStartTime > 9999999UL) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], BT Inquiry/page >= 10sec!!!");
      } else {
      }
      pHalData->bt_coexist.halCoex8723.btInqPageStartTime = 0UL;
    } else {
    }
  } else {
  }
  if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime != 0UL) {
    btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
    btdm_2AntIgnoreWlanAct(padapter, 0);
    btdm_2AntPsTdma(padapter, 1, 8);
    return (1U);
  } else {
    return (0U);
  }
}
}
static u8 btdm_Is2Ant8723ACommonAction(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 bCommon ;
  bool tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  bool tmp___5 ;
  u8 tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  u8 tmp___9 ;
  bool tmp___10 ;
  u8 tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  bCommon = 0U;
  if (BTCoexDbgLevel == 1U) {
    tmp = check_fwstate(& padapter->mlmepriv, 2176);
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
    printk("%s :BTDM_IsWifiConnectionExist =%x check_fwstate =%x pmlmepriv->fw_state = 0x%x\n",
           "btdm_Is2Ant8723ACommonAction", (int )tmp___0, (int )tmp, padapter->mlmepriv.fw_state);
  } else {
  }
  tmp___11 = BTDM_IsWifiConnectionExist(padapter);
  if ((unsigned int )tmp___11 == 0U) {
    tmp___12 = check_fwstate(& padapter->mlmepriv, 2176);
    if (tmp___12) {
      tmp___13 = 0;
    } else {
      tmp___13 = 1;
    }
    if (tmp___13) {
      if ((unsigned int )pBtdm8723->btStatus == 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("Wifi idle + Bt idle!!\n");
        } else {
        }
        btdm_2AntLowPenaltyRa(padapter, 0);
        btdm_2AntRfShrink(padapter, 0);
        btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
        btdm_2AntIgnoreWlanAct(padapter, 0);
        btdm_2AntPsTdma(padapter, 0, 0);
        btdm_2AntFwDacSwingLvl(padapter, 32);
        btdm_2AntDecBtPwr(padapter, 0);
        btdm_2AntAgcTable(padapter, 0);
        btdm_2AntAdcBackOff(padapter, 0);
        btdm_2AntDacSwing(padapter, 0, 192U);
        bCommon = 1U;
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8:
    tmp___9 = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp___9 != 0U) {
      goto _L___6;
    } else {
      tmp___10 = check_fwstate(& padapter->mlmepriv, 2176);
      if ((int )tmp___10) {
        _L___6:
        if ((unsigned int )pBtdm8723->btStatus == 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("Wifi non-idle + BT idle!!\n");
          } else {
          }
          btdm_2AntLowPenaltyRa(padapter, 1);
          btdm_2AntRfShrink(padapter, 0);
          btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
          btdm_2AntIgnoreWlanAct(padapter, 0);
          btdm_2AntPsTdma(padapter, 0, 0);
          btdm_2AntFwDacSwingLvl(padapter, 32);
          btdm_2AntDecBtPwr(padapter, 1);
          btdm_2AntAgcTable(padapter, 0);
          btdm_2AntAdcBackOff(padapter, 0);
          btdm_2AntDacSwing(padapter, 0, 192U);
          bCommon = 1U;
        } else {
          goto _L___5;
        }
      } else {
        _L___5:
        tmp___6 = BTDM_IsWifiConnectionExist(padapter);
        if ((unsigned int )tmp___6 == 0U) {
          tmp___7 = check_fwstate(& padapter->mlmepriv, 2176);
          if (tmp___7) {
            tmp___8 = 0;
          } else {
            tmp___8 = 1;
          }
          if (tmp___8) {
            if ((unsigned int )pBtdm8723->btStatus == 1U) {
              if (BTCoexDbgLevel == 1U) {
                printk("Wifi idle + Bt connected idle!!\n");
              } else {
              }
              btdm_2AntLowPenaltyRa(padapter, 1);
              btdm_2AntRfShrink(padapter, 1);
              btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
              btdm_2AntIgnoreWlanAct(padapter, 0);
              btdm_2AntPsTdma(padapter, 0, 0);
              btdm_2AntFwDacSwingLvl(padapter, 32);
              btdm_2AntDecBtPwr(padapter, 0);
              btdm_2AntAgcTable(padapter, 0);
              btdm_2AntAdcBackOff(padapter, 0);
              btdm_2AntDacSwing(padapter, 0, 192U);
              bCommon = 1U;
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4:
          tmp___4 = BTDM_IsWifiConnectionExist(padapter);
          if ((unsigned int )tmp___4 != 0U) {
            goto _L___2;
          } else {
            tmp___5 = check_fwstate(& padapter->mlmepriv, 2176);
            if ((int )tmp___5) {
              _L___2:
              if ((unsigned int )pBtdm8723->btStatus == 1U) {
                if (BTCoexDbgLevel == 1U) {
                  printk("Wifi non-idle + Bt connected idle!!\n");
                } else {
                }
                btdm_2AntLowPenaltyRa(padapter, 1);
                btdm_2AntRfShrink(padapter, 1);
                btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
                btdm_2AntIgnoreWlanAct(padapter, 0);
                btdm_2AntPsTdma(padapter, 0, 0);
                btdm_2AntFwDacSwingLvl(padapter, 32);
                btdm_2AntDecBtPwr(padapter, 1);
                btdm_2AntAgcTable(padapter, 0);
                btdm_2AntAdcBackOff(padapter, 0);
                btdm_2AntDacSwing(padapter, 0, 192U);
                bCommon = 1U;
              } else {
                goto _L___1;
              }
            } else {
              _L___1:
              tmp___1 = BTDM_IsWifiConnectionExist(padapter);
              if ((unsigned int )tmp___1 == 0U) {
                tmp___2 = check_fwstate(& padapter->mlmepriv, 2176);
                if (tmp___2) {
                  tmp___3 = 0;
                } else {
                  tmp___3 = 1;
                }
                if (tmp___3) {
                  if ((unsigned int )pBtdm8723->btStatus == 2U) {
                    if (BTCoexDbgLevel == 1U) {
                      printk("Wifi idle + BT non-idle!!\n");
                    } else {
                    }
                    btdm_2AntLowPenaltyRa(padapter, 1);
                    btdm_2AntRfShrink(padapter, 1);
                    btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
                    btdm_2AntIgnoreWlanAct(padapter, 0);
                    btdm_2AntPsTdma(padapter, 0, 0);
                    btdm_2AntFwDacSwingLvl(padapter, 32);
                    btdm_2AntDecBtPwr(padapter, 0);
                    btdm_2AntAgcTable(padapter, 0);
                    btdm_2AntAdcBackOff(padapter, 0);
                    btdm_2AntDacSwing(padapter, 0, 192U);
                    bCommon = 1U;
                  } else {
                    goto _L___0;
                  }
                } else {
                  goto _L___0;
                }
              } else {
                _L___0:
                if (BTCoexDbgLevel == 1U) {
                  printk("Wifi non-idle + BT non-idle!!\n");
                } else {
                }
                btdm_2AntLowPenaltyRa(padapter, 1);
                btdm_2AntRfShrink(padapter, 1);
                btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
                btdm_2AntIgnoreWlanAct(padapter, 0);
                btdm_2AntFwDacSwingLvl(padapter, 32);
                bCommon = 0U;
              }
            }
          }
        }
      }
    }
  }
  return (bCommon);
}
}
static void btdm_2AntTdmaDurationAdjust(struct rtw_adapter *padapter , u8 bScoHid ,
                                        u8 bTxPause , u8 maxInterval )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  s32 up___0 ;
  s32 dn ;
  s32 m ;
  s32 n ;
  s32 WaitCount ;
  s32 result ;
  u8 retryCount ;
  bool tmp ;
  int tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  retryCount = 0U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], TdmaDurationAdjust()\n");
  } else {
  }
  if ((unsigned int )pBtdm8723->bResetTdmaAdjust != 0U) {
    pBtdm8723->bResetTdmaAdjust = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], first run TdmaDurationAdjust()!!\n");
    } else {
    }
    if ((unsigned int )bScoHid != 0U) {
      if ((unsigned int )bTxPause != 0U) {
        if ((unsigned int )maxInterval == 1U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )maxInterval == 2U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )maxInterval == 3U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        }
      } else
      if ((unsigned int )maxInterval == 1U) {
        btdm_2AntPsTdma(padapter, 1, 11);
        pBtdm8723->psTdmaDuAdjType = 11U;
      } else
      if ((unsigned int )maxInterval == 2U) {
        btdm_2AntPsTdma(padapter, 1, 11);
        pBtdm8723->psTdmaDuAdjType = 11U;
      } else
      if ((unsigned int )maxInterval == 3U) {
        btdm_2AntPsTdma(padapter, 1, 11);
        pBtdm8723->psTdmaDuAdjType = 11U;
      } else {
        btdm_2AntPsTdma(padapter, 1, 11);
        pBtdm8723->psTdmaDuAdjType = 11U;
      }
    } else
    if ((unsigned int )bTxPause != 0U) {
      if ((unsigned int )maxInterval == 1U) {
        btdm_2AntPsTdma(padapter, 1, 7);
        pBtdm8723->psTdmaDuAdjType = 7U;
      } else
      if ((unsigned int )maxInterval == 2U) {
        btdm_2AntPsTdma(padapter, 1, 7);
        pBtdm8723->psTdmaDuAdjType = 7U;
      } else
      if ((unsigned int )maxInterval == 3U) {
        btdm_2AntPsTdma(padapter, 1, 7);
        pBtdm8723->psTdmaDuAdjType = 7U;
      } else {
        btdm_2AntPsTdma(padapter, 1, 7);
        pBtdm8723->psTdmaDuAdjType = 7U;
      }
    } else
    if ((unsigned int )maxInterval == 1U) {
      btdm_2AntPsTdma(padapter, 1, 3);
      pBtdm8723->psTdmaDuAdjType = 3U;
    } else
    if ((unsigned int )maxInterval == 2U) {
      btdm_2AntPsTdma(padapter, 1, 3);
      pBtdm8723->psTdmaDuAdjType = 3U;
    } else
    if ((unsigned int )maxInterval == 3U) {
      btdm_2AntPsTdma(padapter, 1, 3);
      pBtdm8723->psTdmaDuAdjType = 3U;
    } else {
      btdm_2AntPsTdma(padapter, 1, 3);
      pBtdm8723->psTdmaDuAdjType = 3U;
    }
    up___0 = 0;
    dn = 0;
    m = 1;
    n = 3;
    result = 0;
    WaitCount = 0;
  } else {
    retryCount = pHalData->bt_coexist.halCoex8723.btRetryCnt;
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], retryCount = %d\n", (int )retryCount);
    } else {
    }
    result = 0;
    WaitCount = WaitCount + 1;
    if ((unsigned int )retryCount == 0U) {
      up___0 = up___0 + 1;
      dn = dn - 1;
      if (dn <= 0) {
        dn = 0;
      } else {
      }
      if (up___0 >= n) {
        WaitCount = 0;
        n = 3;
        up___0 = 0;
        dn = 0;
        result = 1;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Increase wifi duration!!\n");
        } else {
        }
      } else {
      }
    } else
    if ((unsigned int )retryCount <= 3U) {
      up___0 = up___0 - 1;
      dn = dn + 1;
      if (up___0 <= 0) {
        up___0 = 0;
      } else {
      }
      if (dn == 2) {
        if (WaitCount <= 2) {
          m = m + 1;
        } else {
          m = 1;
        }
        if (m > 19) {
          m = 20;
        } else {
        }
        n = m * 3;
        up___0 = 0;
        dn = 0;
        WaitCount = 0;
        result = -1;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Decrease wifi duration for retryCounter<3!!\n");
        } else {
        }
      } else {
      }
    } else {
      if (WaitCount == 1) {
        m = m + 1;
      } else {
        m = 1;
      }
      if (m > 19) {
        m = 20;
      } else {
      }
      n = m * 3;
      up___0 = 0;
      dn = 0;
      WaitCount = 0;
      result = -1;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], Decrease wifi duration for retryCounter>3!!\n");
      } else {
      }
    }
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], max Interval = %d\n", (int )maxInterval);
    } else {
    }
    if ((unsigned int )maxInterval == 1U) {
      if ((unsigned int )bTxPause != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 1\n");
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
          btdm_2AntPsTdma(padapter, 1, 5);
          pBtdm8723->psTdmaDuAdjType = 5U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          btdm_2AntPsTdma(padapter, 1, 6);
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
          btdm_2AntPsTdma(padapter, 1, 8);
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          btdm_2AntPsTdma(padapter, 1, 13);
          pBtdm8723->psTdmaDuAdjType = 13U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
          btdm_2AntPsTdma(padapter, 1, 14);
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
          btdm_2AntPsTdma(padapter, 1, 16);
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {
        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 8);
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 16);
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {
          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 5);
            pBtdm8723->psTdmaDuAdjType = 5U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 13);
            pBtdm8723->psTdmaDuAdjType = 13U;
          } else {
          }
        } else {
        }
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 0\n");
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
          btdm_2AntPsTdma(padapter, 1, 1);
          pBtdm8723->psTdmaDuAdjType = 1U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
          btdm_2AntPsTdma(padapter, 1, 2);
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
          btdm_2AntPsTdma(padapter, 1, 4);
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
          btdm_2AntPsTdma(padapter, 1, 9);
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
          btdm_2AntPsTdma(padapter, 1, 10);
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
          btdm_2AntPsTdma(padapter, 1, 12);
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {
        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 4);
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 12);
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {
          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 1);
            pBtdm8723->psTdmaDuAdjType = 1U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 9);
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
          }
        } else {
        }
      }
    } else
    if ((unsigned int )maxInterval == 2U) {
      if ((unsigned int )bTxPause != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 1\n");
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
          btdm_2AntPsTdma(padapter, 1, 6);
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          btdm_2AntPsTdma(padapter, 1, 6);
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
          btdm_2AntPsTdma(padapter, 1, 8);
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          btdm_2AntPsTdma(padapter, 1, 14);
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
          btdm_2AntPsTdma(padapter, 1, 14);
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
          btdm_2AntPsTdma(padapter, 1, 16);
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {
        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 8);
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 16);
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {
          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 6);
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 14);
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else {
          }
        } else {
        }
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 0\n");
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
          btdm_2AntPsTdma(padapter, 1, 2);
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
          btdm_2AntPsTdma(padapter, 1, 2);
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
          btdm_2AntPsTdma(padapter, 1, 4);
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
          btdm_2AntPsTdma(padapter, 1, 10);
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
          btdm_2AntPsTdma(padapter, 1, 10);
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
          btdm_2AntPsTdma(padapter, 1, 12);
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {
        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 4);
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 12);
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {
          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 2);
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 10);
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else {
          }
        } else {
        }
      }
    } else
    if ((unsigned int )maxInterval == 3U) {
      if ((unsigned int )bTxPause != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 1\n");
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
          btdm_2AntPsTdma(padapter, 1, 7);
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
          btdm_2AntPsTdma(padapter, 1, 8);
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
          btdm_2AntPsTdma(padapter, 1, 15);
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
          btdm_2AntPsTdma(padapter, 1, 16);
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {
        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 8);
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 16);
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {
          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
            btdm_2AntPsTdma(padapter, 1, 7);
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
            btdm_2AntPsTdma(padapter, 1, 15);
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else {
          }
        } else {
        }
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], TxPause = 0\n");
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
          btdm_2AntPsTdma(padapter, 1, 3);
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
          btdm_2AntPsTdma(padapter, 1, 4);
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {
        }
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
          btdm_2AntPsTdma(padapter, 1, 11);
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
          btdm_2AntPsTdma(padapter, 1, 12);
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {
        }
        if (result == -1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 4);
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 12);
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {
          }
        } else
        if (result == 1) {
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
            btdm_2AntPsTdma(padapter, 1, 3);
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
            btdm_2AntPsTdma(padapter, 1, 11);
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else {
          }
        } else {
        }
      }
    } else {
    }
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], PsTdma type : recordPsTdma =%d\n", (int )pBtdm8723->psTdmaDuAdjType);
  } else {
  }
  if ((int )pBtdm8723->curPsTdma != (int )pBtdm8723->psTdmaDuAdjType) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], PsTdma type dismatch!!!, curPsTdma =%d, recordPsTdma =%d\n",
             (int )pBtdm8723->curPsTdma, (int )pBtdm8723->psTdmaDuAdjType);
    } else {
    }
    tmp = check_fwstate(& padapter->mlmepriv, 2176);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      btdm_2AntPsTdma(padapter, 1, (int )pBtdm8723->psTdmaDuAdjType);
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
    } else {
    }
  } else {
  }
  return;
}
}
static void btdm_2Ant8723ASCOAction(struct rtw_adapter *padapter )
{
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntPsTdma(padapter, 1, 11);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      btdm_2AntPsTdma(padapter, 1, 15);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntPsTdma(padapter, 1, 11);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      btdm_2AntPsTdma(padapter, 1, 15);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AHIDAction(struct rtw_adapter *padapter )
{
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntPsTdma(padapter, 1, 9);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      btdm_2AntPsTdma(padapter, 1, 13);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 0);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntPsTdma(padapter, 1, 9);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      btdm_2AntPsTdma(padapter, 1, 13);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AA2DPAction(struct rtw_adapter *padapter )
{
  u8 btRssiState ;
  u8 btRssiState1 ;
  struct hal_data_8723a *pHalData ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
      }
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
      }
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723APANEDRAction(struct rtw_adapter *padapter )
{
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntPsTdma(padapter, 1, 2);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntPsTdma(padapter, 1, 6);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntPsTdma(padapter, 1, 2);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      btdm_2AntPsTdma(padapter, 1, 6);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723APANHSAction(struct rtw_adapter *padapter )
{
  u8 btRssiState ;
  u8 tmp ;
  {
  tmp = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      btdm_2AntDecBtPwr(padapter, 1);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntDecBtPwr(padapter, 0);
    }
    btdm_2AntPsTdma(padapter, 0, 0);
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high\n");
      } else {
      }
      btdm_2AntDecBtPwr(padapter, 1);
      btdm_2AntPsTdma(padapter, 0, 0);
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low\n");
      } else {
      }
      btdm_2AntDecBtPwr(padapter, 0);
      btdm_2AntPsTdma(padapter, 0, 0);
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723APANEDRA2DPAction(struct rtw_adapter *padapter )
{
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 4);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 2);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 8);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 6);
      }
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 4);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 2);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 8);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 6);
      }
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723APANEDRHIDAction(struct rtw_adapter *padapter )
{
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntPsTdma(padapter, 1, 10);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntPsTdma(padapter, 1, 14);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntPsTdma(padapter, 1, 10);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      btdm_2AntPsTdma(padapter, 1, 14);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AHIDA2DPPANEDRAction(struct rtw_adapter *padapter )
{
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 12);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 10);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 16);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 14);
      }
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 37, 0);
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 12);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 10);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 16);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntPsTdma(padapter, 1, 14);
      }
    }
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AHIDA2DPAction(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 1);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 1);
      }
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 1);
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      if ((int )btInfoExt & 1) {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp basic rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 3);
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("a2dp edr rate \n");
        } else {
        }
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 1);
      }
    }
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void btdm_2Ant8723AA2dp(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
  tmp = btdm_NeedToDecBtPwr(padapter);
  if ((unsigned int )tmp != 0U) {
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
    btdm_2AntDecBtPwr(padapter, 0);
  }
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
  btdm_2AntIgnoreWlanAct(padapter, 0);
  tmp___0 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("HT40\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
    }
    btdm_2AntAgcTable(padapter, 0);
    btdm_2AntAdcBackOff(padapter, 1);
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("HT20 or Legacy\n");
    } else {
    }
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 high \n");
      } else {
      }
      rtl8723au_write8(padapter, 2179U, 64);
      btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi-1 low \n");
      } else {
      }
      btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
    }
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi high \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 1);
      btdm_2AntAdcBackOff(padapter, 1);
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi rssi low \n");
      } else {
      }
      btdm_2AntAgcTable(padapter, 0);
      btdm_2AntAdcBackOff(padapter, 0);
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
  return;
}
}
static void BTDM_2AntParaInit(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], 2Ant Parameter Init!!\n");
  } else {
  }
  rtl8723au_write8(padapter, 1902U, 4);
  rtl8723au_write8(padapter, 1912U, 3);
  rtl8723au_write8(padapter, 64U, 32);
  pBtdm8723->preVal0x6c0 = 0U;
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
  pBtdm8723->bPrePsTdmaOn = 1U;
  btdm_2AntPsTdma(padapter, 0, 0);
  pBtdm8723->preFwDacSwingLvl = 16U;
  btdm_2AntFwDacSwingLvl(padapter, 32);
  pBtdm8723->bPreDecBtPwr = 1U;
  btdm_2AntDecBtPwr(padapter, 0);
  pBtdm8723->bPreAgcTableEn = 1U;
  btdm_2AntAgcTable(padapter, 0);
  pBtdm8723->bPreAdcBackOff = 1U;
  btdm_2AntAdcBackOff(padapter, 0);
  pBtdm8723->bPreLowPenaltyRa = 1U;
  btdm_2AntLowPenaltyRa(padapter, 0);
  pBtdm8723->bPreRfRxLpfShrink = 1U;
  btdm_2AntRfShrink(padapter, 0);
  pBtdm8723->bPreDacSwingOn = 1U;
  btdm_2AntDacSwing(padapter, 0, 192U);
  pBtdm8723->bPreIgnoreWlanAct = 1U;
  btdm_2AntIgnoreWlanAct(padapter, 0);
  return;
}
}
static void BTDM_2AntHwCoexAllOff8723A(struct rtw_adapter *padapter )
{
  {
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
  return;
}
}
static void BTDM_2AntFwCoexAllOff8723A(struct rtw_adapter *padapter )
{
  {
  btdm_2AntIgnoreWlanAct(padapter, 0);
  btdm_2AntPsTdma(padapter, 0, 0);
  btdm_2AntFwDacSwingLvl(padapter, 32);
  btdm_2AntDecBtPwr(padapter, 0);
  return;
}
}
static void BTDM_2AntSwCoexAllOff8723A(struct rtw_adapter *padapter )
{
  {
  btdm_2AntAgcTable(padapter, 0);
  btdm_2AntAdcBackOff(padapter, 0);
  btdm_2AntLowPenaltyRa(padapter, 0);
  btdm_2AntRfShrink(padapter, 0);
  btdm_2AntDacSwing(padapter, 0, 192U);
  return;
}
}
static void BTDM_2AntFwC2hBtInfo8723A(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 btInfo ;
  u8 algorithm ;
  u8 bBtLinkExist ;
  u8 bBtHsModeExist ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  btInfo = 0U;
  algorithm = 0U;
  bBtLinkExist = 0U;
  bBtHsModeExist = 0U;
  btInfo = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;
  pBtdm8723->btStatus = 0U;
  if (((unsigned long )btInfo & 4UL) != 0UL) {
    if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage == 0U) {
      pBtMgnt->ExtConfig.bHoldForBtOperation = 1U;
      pBtMgnt->ExtConfig.bHoldPeriodCnt = 1U;
      btdm_2AntBtInquiryPage(padapter);
    } else {
      pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      btdm_HoldForBtInqPage(padapter);
    }
    pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = 1U;
  } else {
    pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = 0U;
    pBtMgnt->ExtConfig.bHoldForBtOperation = 0U;
    pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H], pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage =%x pBtMgnt->ExtConfig.bHoldPeriodCnt =%x pBtMgnt->ExtConfig.bHoldForBtOperation =%x\n",
           (int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage, pBtMgnt->ExtConfig.bHoldPeriodCnt,
           (int )pBtMgnt->ExtConfig.bHoldForBtOperation);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H],   btInfo =%x   pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal =%x\n",
           (int )btInfo, (int )pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal);
  } else {
  }
  if ((int )btInfo & 1) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTC2H], BTInfo: bConnect = true   btInfo =%x\n", (int )btInfo);
    } else {
    }
    bBtLinkExist = 1U;
    if (((unsigned long )btInfo & 240UL) != 0UL || (unsigned int )pHalData->bt_coexist.halCoex8723.btRetryCnt != 0U) {
      pBtdm8723->btStatus = 2U;
    } else {
      pBtdm8723->btStatus = 1U;
    }
    if (((unsigned long )btInfo & 2UL) != 0UL || ((unsigned long )btInfo & 16UL) != 0UL) {
      if (((int )((signed char )btInfo) < 0 || ((unsigned long )btInfo & 64UL) != 0UL) || ((unsigned long )btInfo & 32UL) != 0UL) {
        switch ((int )btInfo & 224) {
        case 32: ;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], SCO + HID\n");
        } else {
        }
        algorithm = 2U;
        goto ldv_56434;
        case 64: ;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], Error!!! SCO + A2DP\n");
        } else {
        }
        goto ldv_56434;
        case 128: ;
        if ((unsigned int )bBtHsModeExist != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], SCO + PAN(HS)\n");
          } else {
          }
          algorithm = 1U;
        } else {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], SCO + PAN(EDR)\n");
          } else {
          }
          algorithm = 7U;
        }
        goto ldv_56434;
        case 96: ;
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + A2DP\n");
        } else {
        }
        algorithm = 9U;
        goto ldv_56434;
        case 160: ;
        if ((unsigned int )bBtHsModeExist != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + PAN(HS)\n");
          } else {
          }
          algorithm = 9U;
        } else {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + PAN(EDR)\n");
          } else {
          }
          algorithm = 7U;
        }
        goto ldv_56434;
        case 192: ;
        if ((unsigned int )bBtHsModeExist != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], A2DP + PAN(HS)\n");
          } else {
          }
          algorithm = 3U;
        } else {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], A2DP + PAN(EDR)\n");
          } else {
          }
          algorithm = 6U;
        }
        goto ldv_56434;
        case 224: ;
        if ((unsigned int )bBtHsModeExist != 0U) {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + A2DP + PAN(HS)\n");
          } else {
          }
          algorithm = 9U;
        } else {
          if (BTCoexDbgLevel == 1U) {
            printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
          } else {
          }
          algorithm = 8U;
        }
        goto ldv_56434;
        }
        ldv_56434: ;
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], SCO only\n");
        } else {
        }
        algorithm = 1U;
      }
    } else {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], non SCO\n");
      } else {
      }
      switch ((int )btInfo & 224) {
      case 32: ;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], HID\n");
      } else {
      }
      algorithm = 2U;
      goto ldv_56442;
      case 64: ;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex],  A2DP\n");
      } else {
      }
      algorithm = 3U;
      goto ldv_56442;
      case 128: ;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], PAN(EDR)\n");
      } else {
      }
      algorithm = 7U;
      goto ldv_56442;
      case 96: ;
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex], HID + A2DP\n");
      } else {
      }
      algorithm = 9U;
      goto ldv_56442;
      case 160: ;
      if ((unsigned int )bBtHsModeExist != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + PAN(HS)\n");
        } else {
        }
        algorithm = 9U;
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + PAN(EDR)\n");
        } else {
        }
        algorithm = 7U;
      }
      goto ldv_56442;
      case 192: ;
      if ((unsigned int )bBtHsModeExist != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], A2DP + PAN(HS)\n");
        } else {
        }
        algorithm = 3U;
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], A2DP + PAN(EDR)\n");
        } else {
        }
        algorithm = 6U;
      }
      goto ldv_56442;
      case 224: ;
      if ((unsigned int )bBtHsModeExist != 0U) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + A2DP + PAN(HS)\n");
        } else {
        }
        algorithm = 9U;
      } else {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
        } else {
        }
        algorithm = 8U;
      }
      goto ldv_56442;
      }
      ldv_56442: ;
    }
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTC2H], BTInfo: bConnect = false\n");
    } else {
    }
    pBtdm8723->btStatus = 0U;
  }
  pBtdm8723->curAlgorithm = algorithm;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], Algorithm = %d \n", (int )pBtdm8723->curAlgorithm);
  } else {
  }
  BTDM_CheckWiFiState(padapter);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Action Manual control, won\'t execute bt coexist mechanism!!\n");
    } else {
    }
    return;
  } else {
  }
  return;
}
}
void BTDM_2AntBtCoexist8723A(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 btInfoOriginal ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  btInfoOriginal = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
  tmp___1 = BTDM_BtProfileSupport(padapter);
  if ((unsigned int )tmp___1 != 0U) {
    if ((unsigned int )pBtMgnt->ExtConfig.bHoldForBtOperation != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Action for BT Operation adjust!!\n");
      } else {
      }
      return;
    } else {
    }
    if (pBtMgnt->ExtConfig.bHoldPeriodCnt != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Hold BT inquiry/page scan setting (cnt = %d)!!\n", pBtMgnt->ExtConfig.bHoldPeriodCnt);
      } else {
      }
      if (pBtMgnt->ExtConfig.bHoldPeriodCnt > 10U) {
        pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
      } else {
        pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      }
      return;
    } else {
    }
    if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[Dbg control], ");
      } else {
      }
    } else {
    }
    pBtdm8723->curAlgorithm = btdm_ActionAlgorithm(padapter);
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], Algorithm = %d \n", (int )pBtdm8723->curAlgorithm);
    } else {
    }
    tmp = btdm_Is2Ant8723ACommonAction(padapter);
    if ((unsigned int )tmp != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant common.\n");
      } else {
      }
      pBtdm8723->bResetTdmaAdjust = 1U;
    } else {
      if ((int )pBtdm8723->curAlgorithm != (int )pBtdm8723->preAlgorithm) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n", (int )pBtdm8723->preAlgorithm,
                 (int )pBtdm8723->curAlgorithm);
        } else {
        }
        pBtdm8723->bResetTdmaAdjust = 1U;
      } else {
      }
      switch ((int )pBtdm8723->curAlgorithm) {
      case 1: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = SCO.\n");
      } else {
      }
      btdm_2Ant8723ASCOAction(padapter);
      goto ldv_56459;
      case 2: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID.\n");
      } else {
      }
      btdm_2Ant8723AHIDAction(padapter);
      goto ldv_56459;
      case 3: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = A2DP.\n");
      } else {
      }
      btdm_2Ant8723AA2DPAction(padapter);
      goto ldv_56459;
      case 4: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN(EDR).\n");
      } else {
      }
      btdm_2Ant8723APANEDRAction(padapter);
      goto ldv_56459;
      case 5: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HS mode.\n");
      } else {
      }
      btdm_2Ant8723APANHSAction(padapter);
      goto ldv_56459;
      case 6: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN+A2DP.\n");
      } else {
      }
      btdm_2Ant8723APANEDRA2DPAction(padapter);
      goto ldv_56459;
      case 7: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
      } else {
      }
      btdm_2Ant8723APANEDRHIDAction(padapter);
      goto ldv_56459;
      case 8: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
      } else {
      }
      btdm_2Ant8723AHIDA2DPPANEDRAction(padapter);
      goto ldv_56459;
      case 9: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID+A2DP.\n");
      } else {
      }
      btdm_2Ant8723AHIDA2DPAction(padapter);
      goto ldv_56459;
      default: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = 0.\n");
      } else {
      }
      btdm_2Ant8723AA2DPAction(padapter);
      goto ldv_56459;
      }
      ldv_56459:
      pBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;
    }
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex] Get bt info by fw!!\n");
    } else {
    }
    if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInfoReqSent != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[BTCoex] c2h for btInfo not rcvd yet!!\n");
      } else {
      }
    } else {
    }
    btInfoOriginal = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;
    if ((unsigned int )pBtMgnt->ExtConfig.bHoldForBtOperation != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Action for BT Operation adjust!!\n");
      } else {
      }
      return;
    } else {
    }
    if (pBtMgnt->ExtConfig.bHoldPeriodCnt != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Hold BT inquiry/page scan setting (cnt = %d)!!\n", pBtMgnt->ExtConfig.bHoldPeriodCnt);
      } else {
      }
      if (pBtMgnt->ExtConfig.bHoldPeriodCnt > 10U) {
        pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
      } else {
        pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      }
      return;
    } else {
    }
    if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[Dbg control], ");
      } else {
      }
    } else {
    }
    tmp___0 = btdm_Is2Ant8723ACommonAction(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant common.\n");
      } else {
      }
      pBtdm8723->bResetTdmaAdjust = 1U;
    } else {
      if ((int )pBtdm8723->curAlgorithm != (int )pBtdm8723->preAlgorithm) {
        if (BTCoexDbgLevel == 1U) {
          printk("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n", (int )pBtdm8723->preAlgorithm,
                 (int )pBtdm8723->curAlgorithm);
        } else {
        }
        pBtdm8723->bResetTdmaAdjust = 1U;
      } else {
      }
      switch ((int )pBtdm8723->curAlgorithm) {
      case 1: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = SCO.\n");
      } else {
      }
      btdm_2Ant8723ASCOAction(padapter);
      goto ldv_56470;
      case 2: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID.\n");
      } else {
      }
      btdm_2Ant8723AHIDAction(padapter);
      goto ldv_56470;
      case 3: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = A2DP.\n");
      } else {
      }
      btdm_2Ant8723AA2dp(padapter);
      goto ldv_56470;
      case 4: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN(EDR).\n");
      } else {
      }
      btdm_2Ant8723APANEDRAction(padapter);
      goto ldv_56470;
      case 5: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HS mode.\n");
      } else {
      }
      btdm_2Ant8723APANHSAction(padapter);
      goto ldv_56470;
      case 6: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN+A2DP.\n");
      } else {
      }
      btdm_2Ant8723APANEDRA2DPAction(padapter);
      goto ldv_56470;
      case 7: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
      } else {
      }
      btdm_2Ant8723APANEDRHIDAction(padapter);
      goto ldv_56470;
      case 8: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
      } else {
      }
      btdm_2Ant8723AHIDA2DPPANEDRAction(padapter);
      goto ldv_56470;
      case 9: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = HID+A2DP.\n");
      } else {
      }
      btdm_2Ant8723AHIDA2DPAction(padapter);
      goto ldv_56470;
      default: ;
      if (BTCoexDbgLevel == 1U) {
        printk("Action 2-Ant, algorithm = 0.\n");
      } else {
      }
      btdm_2Ant8723AA2DPAction(padapter);
      goto ldv_56470;
      }
      ldv_56470:
      pBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;
    }
  }
  return;
}
}
static u8 btCoexDbgBuf[100U] ;
static char const * const BtProfileString[5U] = { "NONE", "A2DP", "PAN", "HID",
        "SCO"};
static char const * const BtSpecString[7U] = { "1.0b", "1.1", "1.2", "2.0+EDR",
        "2.1+EDR", "3.0+HS", "4.0"};
static char const * const BtLinkRoleString[2U] = { "Master", "Slave"};
static u8 btdm_BtWifiAntNum(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U) {
    if ((unsigned int )pBtCoex->TotalAntNum == 0U) {
      return (0U);
    } else {
      return (1U);
    }
  } else {
    return (1U);
  }
  return (0U);
}
}
static void btdm_BtHwCountersMonitor(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u32 regHPTxRx ;
  u32 regLPTxRx ;
  u32 u4Tmp ;
  u32 regHPTx ;
  u32 regHPRx ;
  u32 regLPTx ;
  u32 regLPRx ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  regHPTx = 0U;
  regHPRx = 0U;
  regLPTx = 0U;
  regLPRx = 0U;
  regHPTxRx = 1904U;
  regLPTxRx = 1908U;
  u4Tmp = rtl8723au_read32(padapter, regHPTxRx);
  regHPTx = u4Tmp & 65535U;
  regHPRx = u4Tmp >> 16;
  u4Tmp = rtl8723au_read32(padapter, regLPTxRx);
  regLPTx = u4Tmp & 65535U;
  regLPRx = u4Tmp >> 16;
  pHalData->bt_coexist.halCoex8723.highPriorityTx = regHPTx;
  pHalData->bt_coexist.halCoex8723.highPriorityRx = regHPRx;
  pHalData->bt_coexist.halCoex8723.lowPriorityTx = regLPTx;
  pHalData->bt_coexist.halCoex8723.lowPriorityRx = regLPRx;
  if (BTCoexDbgLevel == 1U) {
    printk("High Priority Tx/Rx = %d / %d\n", regHPTx, regHPRx);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("Low Priority Tx/Rx = %d / %d\n", regLPTx, regLPRx);
  } else {
  }
  rtl8723au_write8(padapter, 1902U, 12);
  return;
}
}
static void btdm_BtEnableDisableCheck8723A(struct rtw_adapter *padapter )
{
  u8 btAlife ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  {
  btAlife = 1U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 0U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 0U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 0U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 0U) {
    btAlife = 0U;
  } else {
  }
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 60138U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 60138U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 60138U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 60138U) {
    btAlife = 0U;
  } else {
  }
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 65535U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 65535U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 65535U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 65535U) {
    btAlife = 0U;
  } else {
  }
  if ((unsigned int )btAlife != 0U) {
    pHalData->bt_coexist.btActiveZeroCnt = 0U;
    pHalData->bt_coexist.bCurBtDisabled = 0U;
    if (BTCoexDbgLevel == 1U) {
      printk("8723A BT is enabled !!\n");
    } else {
    }
  } else {
    pHalData->bt_coexist.btActiveZeroCnt = (u8 )((int )pHalData->bt_coexist.btActiveZeroCnt + 1);
    if (BTCoexDbgLevel == 1U) {
      printk("8723A bt all counters = 0, %d times!!\n", (int )pHalData->bt_coexist.btActiveZeroCnt);
    } else {
    }
    if ((unsigned int )pHalData->bt_coexist.btActiveZeroCnt > 1U) {
      pHalData->bt_coexist.bCurBtDisabled = 1U;
      if (BTCoexDbgLevel == 1U) {
        printk("8723A BT is disabled !!\n");
      } else {
      }
    } else {
    }
  }
  if ((unsigned int )pHalData->bt_coexist.bCurBtDisabled == 0U) {
    tmp = BTDM_IsWifiConnectionExist(padapter);
    if ((unsigned int )tmp != 0U) {
      BTDM_SetFwChnlInfo(padapter, 1);
    } else {
      BTDM_SetFwChnlInfo(padapter, 0);
    }
  } else {
  }
  if ((int )pHalData->bt_coexist.bPreBtDisabled != (int )pHalData->bt_coexist.bCurBtDisabled) {
    if (BTCoexDbgLevel == 1U) {
      printk("8723A BT is from %s to %s!!\n", (unsigned int )pHalData->bt_coexist.bPreBtDisabled != 0U ? (char *)"disabled" : (char *)"enabled",
             (unsigned int )pHalData->bt_coexist.bCurBtDisabled != 0U ? (char *)"disabled" : (char *)"enabled");
    } else {
    }
    pHalData->bt_coexist.bPreBtDisabled = pHalData->bt_coexist.bCurBtDisabled;
  } else {
  }
  return;
}
}
static void btdm_BTCoexist8723AHandler(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 2 Ant mechanism\n");
    } else {
    }
    BTDM_2AntBtCoexist8723A(padapter);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], 1 Ant mechanism\n");
    } else {
    }
    BTDM_1AntBtCoexist8723A(padapter);
  }
  tmp___0 = BTDM_IsSameCoexistState(padapter);
  if ((unsigned int )tmp___0 == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], Coexist State[bitMap] change from 0x%llx to 0x%llx\n", pHalData->bt_coexist.PreviousState,
             pHalData->bt_coexist.CurrentState);
    } else {
    }
    pHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;
    if (BTCoexDbgLevel == 1U) {
      printk("[");
    } else {
    }
    if ((int )pHalData->bt_coexist.CurrentState & 1) {
      if (BTCoexDbgLevel == 1U) {
        printk("BT 3.0, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 2ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("HT20, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 4ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("HT40, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 8ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Legacy, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 16ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Rssi_Low, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 32ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Rssi_Mid, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 64ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Rssi_High, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 256ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi_Idle, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 512ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi_Uplink, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 1024ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("Wifi_Downlink, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 4096ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("BT_idle, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 1048576ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("PRO_HID, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 2097152ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("PRO_A2DP, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 4194304ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("PRO_PAN, ");
      } else {
      }
    } else {
    }
    if ((pHalData->bt_coexist.CurrentState & 8388608ULL) != 0ULL) {
      if (BTCoexDbgLevel == 1U) {
        printk("PRO_SCO, ");
      } else {
      }
    } else {
    }
    if (BTCoexDbgLevel == 1U) {
      printk("]\n");
    } else {
    }
  } else {
  }
  return;
}
}
u32 BTDM_BtTxRxCounterH(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u32 counters ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  counters = 0U;
  counters = pHalData->bt_coexist.halCoex8723.highPriorityTx + pHalData->bt_coexist.halCoex8723.highPriorityRx;
  return (counters);
}
}
u32 BTDM_BtTxRxCounterL(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u32 counters ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  counters = 0U;
  counters = pHalData->bt_coexist.halCoex8723.lowPriorityTx + pHalData->bt_coexist.halCoex8723.lowPriorityRx;
  return (counters);
}
}
void BTDM_SetFwChnlInfo(struct rtw_adapter *padapter , enum rt_media_status mstatus )
{
  struct mlme_ext_priv *pmlmeext ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  u8 chnl ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  u8 tmp___3 ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {
    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )mstatus == 1U) {
    H2C_Parameter[0] = 1U;
  } else {
  }
  tmp___2 = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp___2) {
    chnl = pmlmeext->cur_channel;
    tmp___0 = BTDM_IsHT40(padapter);
    if ((unsigned int )tmp___0 != 0U) {
      if ((unsigned int )pmlmeext->cur_ch_offset == 2U) {
        chnl = (unsigned int )chnl + 254U;
      } else
      if ((unsigned int )pmlmeext->cur_ch_offset == 1U) {
        chnl = (unsigned int )chnl + 2U;
      } else {
      }
    } else {
    }
    H2C_Parameter[1] = chnl;
  } else {
    tmp___1 = BT_Operation(padapter);
    if ((unsigned int )tmp___1 != 0U) {
      H2C_Parameter[1] = pBtMgnt->BTChannel;
    } else {
      H2C_Parameter[1] = pmlmeext->cur_channel;
    }
  }
  tmp___3 = BTDM_IsHT40(padapter);
  if ((unsigned int )tmp___3 != 0U) {
    H2C_Parameter[2] = 48U;
  } else {
    H2C_Parameter[2] = 32U;
  }
  FillH2CCmd(padapter, 25, 3U, (u8 *)(& H2C_Parameter));
  return;
}
}
u8 BTDM_IsWifiConnectionExist(struct rtw_adapter *padapter )
{
  u8 bRet ;
  u8 tmp ;
  bool tmp___0 ;
  {
  bRet = 0U;
  tmp = BTHCI_HsConnectionEstablished(padapter);
  if ((unsigned int )tmp != 0U) {
    bRet = 1U;
  } else {
  }
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
  if ((int )tmp___0) {
    bRet = 1U;
  } else {
  }
  return (bRet);
}
}
void BTDM_SetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 , u8 byte3 ,
                  u8 byte4 , u8 byte5 )
{
  u8 H2C_Parameter[5U] ;
  unsigned int tmp ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 BtState ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  {
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {
    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  tmp___3 = rtl8723a_BT_using_antenna_1(padapter);
  if ((int )tmp___3) {
    tmp___0 = check_fwstate(& padapter->mlmepriv, 8);
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      tmp___2 = get_fwstate(& padapter->mlmepriv);
      if (tmp___2 != 0) {
        pHalData = (struct hal_data_8723a *)padapter->HalData;
        pBtCoex = & pHalData->bt_coexist.halCoex8723;
        BtState = pBtCoex->c2hBtInfo;
        if ((unsigned int )BtState != 1U && (unsigned int )BtState != 2U) {
          if (((unsigned long )byte1 & 16UL) != 0UL) {
            byte1 = (unsigned int )byte1 & 239U;
            byte1 = (u8 )((unsigned int )byte1 | 32U);
          } else {
          }
          byte5 = (u8 )((unsigned int )byte5 | 32U);
          if (((unsigned long )byte5 & 64UL) != 0UL) {
            byte5 = (unsigned int )byte5 & 191U;
          } else {
          }
        } else {
        }
      } else {
      }
    } else {
    }
  } else {
  }
  H2C_Parameter[0] = byte1;
  H2C_Parameter[1] = byte2;
  H2C_Parameter[2] = byte3;
  H2C_Parameter[3] = byte4;
  H2C_Parameter[4] = byte5;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], FW write 0x3a(5bytes) = 0x%02x%08x\n", (int )H2C_Parameter[0],
           ((((int )H2C_Parameter[1] << 24) | ((int )H2C_Parameter[2] << 16)) | ((int )H2C_Parameter[3] << 8)) | (int )H2C_Parameter[4]);
  } else {
  }
  FillH2CCmd(padapter, 58, 5U, (u8 *)(& H2C_Parameter));
  return;
}
}
void BTDM_QueryBtInformation(struct rtw_adapter *padapter )
{
  u8 H2C_Parameter[1U] ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;
  int tmp___0 ;
  {
  H2C_Parameter[0] = 0U;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  tmp = rtl8723a_BT_enabled(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    pBtCoex->c2hBtInfo = 0U;
    pBtCoex->bC2hBtInfoReqSent = 0U;
    return;
  } else {
  }
  if ((unsigned int )pBtCoex->c2hBtInfo == 0U) {
    pBtCoex->c2hBtInfo = 1U;
  } else {
  }
  if ((unsigned int )pBtCoex->bC2hBtInfoReqSent == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], didn\'t recv previous BtInfo report!\n");
    } else {
    }
  } else {
    pBtCoex->bC2hBtInfoReqSent = 1U;
  }
  H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 1U);
  FillH2CCmd(padapter, 56, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
void BTDM_SetSwRfRxLpfCorner(struct rtw_adapter *padapter , u8 type )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )type == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Shrink RF Rx LPF corner!!\n");
    } else {
    }
    PHY_SetRFReg(padapter, 0, 30U, 1048575U, 987127U);
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else
  if ((unsigned int )type == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("Resume RF Rx LPF corner!!\n");
    } else {
    }
    PHY_SetRFReg(padapter, 0, 30U, 1048575U, pHalData->bt_coexist.BtRfRegOrigin1E);
  } else {
  }
  return;
}
}
void BTDM_SetSwPenaltyTxRateAdaptive(struct rtw_adapter *padapter , u8 raType )
{
  struct hal_data_8723a *pHalData ;
  u8 tmpU1 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmpU1 = rtl8723au_read8(padapter, 1277U);
  tmpU1 = (u8 )((unsigned int )tmpU1 | 1U);
  if ((unsigned int )raType == 1U) {
    tmpU1 = (unsigned int )tmpU1 & 251U;
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else
  if ((unsigned int )raType == 0U) {
    tmpU1 = (u8 )((unsigned int )tmpU1 | 4U);
  } else {
  }
  rtl8723au_write8(padapter, 1277U, (int )tmpU1);
  return;
}
}
void BTDM_SetFwDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr )
{
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[1U] ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  H2C_Parameter[0] = 0U;
  if ((unsigned int )bDecBtPwr != 0U) {
    H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 2U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], decrease Bt Power : %s, write 0x21 = 0x%x\n", (unsigned int )bDecBtPwr != 0U ? (char *)"Yes!!" : (char *)"No!!",
           (int )H2C_Parameter[0]);
  } else {
  }
  FillH2CCmd(padapter, 33, 1U, (u8 *)(& H2C_Parameter));
  return;
}
}
u8 BTDM_BtProfileSupport(struct rtw_adapter *padapter )
{
  u8 bRet ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  {
  bRet = 0U;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pBtMgnt->bSupportProfile != 0U && (unsigned int )pHalData->bt_coexist.halCoex8723.bForceFwBtInfo == 0U) {
    bRet = 1U;
  } else {
  }
  return (bRet);
}
}
static void BTDM_AdjustForBtOperation8723A(struct rtw_adapter *padapter )
{
  {
  return;
}
}
static void BTDM_FwC2hBtRssi8723A(struct rtw_adapter *padapter , u8 *tmpBuf )
{
  struct hal_data_8723a *pHalData ;
  u8 percent ;
  u8 u1tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  percent = 0U;
  u1tmp = 0U;
  u1tmp = *tmpBuf;
  percent = (unsigned int )((u8 )((int )u1tmp + 5)) * 2U;
  pHalData->bt_coexist.halCoex8723.btRssi = percent;
  return;
}
}
void rtl8723a_fw_c2h_BT_info(struct rtw_adapter *padapter , u8 *tmpBuf , u8 length )
{
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 i ;
  u8 tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBtCoex->bC2hBtInfoReqSent = 0U;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H], BT info[%d]=[", (int )length);
  } else {
  }
  pBtCoex->btRetryCnt = 0U;
  i = 0U;
  goto ldv_56600;
  ldv_56599: ;
  switch ((int )i) {
  case 0:
  pBtCoex->c2hBtInfoOriginal = *(tmpBuf + (unsigned long )i);
  goto ldv_56595;
  case 1:
  pBtCoex->btRetryCnt = *(tmpBuf + (unsigned long )i);
  goto ldv_56595;
  case 2:
  BTDM_FwC2hBtRssi8723A(padapter, tmpBuf + (unsigned long )i);
  goto ldv_56595;
  case 3:
  pBtCoex->btInfoExt = (unsigned int )*(tmpBuf + (unsigned long )i) & 1U;
  goto ldv_56595;
  }
  ldv_56595: ;
  if ((int )i == (int )length + -1) {
    if (BTCoexDbgLevel == 1U) {
      printk("0x%02x]\n", (int )*(tmpBuf + (unsigned long )i));
    } else {
    }
  } else
  if (BTCoexDbgLevel == 1U) {
    printk("0x%02x, ", (int )*(tmpBuf + (unsigned long )i));
  } else {
  }
  i = (u8 )((int )i + 1);
  ldv_56600: ;
  if ((int )i < (int )length) {
    goto ldv_56599;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[BTC2H], BT RSSI =%d\n", (int )pBtCoex->btRssi);
  } else {
  }
  if ((unsigned int )pBtCoex->btInfoExt != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTC2H], pBtCoex->btInfoExt =%x\n", (int )pBtCoex->btInfoExt);
    } else {
    }
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntFwC2hBtInfo8723A(padapter);
  } else {
    BTDM_2AntFwC2hBtInfo8723A(padapter);
  }
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("%s: Action Manual control!!\n", "rtl8723a_fw_c2h_BT_info");
    } else {
    }
    return;
  } else {
  }
  btdm_BTCoexist8723AHandler(padapter);
  return;
}
}
static void BTDM_Display8723ABtCoexInfo(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 u1Tmp ;
  u8 u1Tmp1 ;
  u8 u1Tmp2 ;
  u8 i ;
  u8 btInfoExt ;
  u8 psTdmaCase ;
  u32 u4Tmp[4U] ;
  u8 antNum ;
  bool tmp ;
  int tmp___0 ;
  s32 tmp___1 ;
  u8 tmp___3 ;
  char *tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___7 ;
  char *tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  psTdmaCase = 0U;
  antNum = 0U;
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n ============[BT Coexist info]============");
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n BT not exists !!!");
    return;
  } else {
  }
  antNum = btdm_BtWifiAntNum(padapter);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d/%d ", (char *)"Ant mechanism PG/Now run :",
           (unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U ? 2 : 1, (unsigned int )antNum == 0U ? 2 : 1);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"[Action Manual control]!!");
  } else {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s / %d", (char *)"BT stack/ hci ext ver",
             (unsigned int )pBtMgnt->bSupportProfile != 0U ? (char *)"Yes" : (char *)"No",
             (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  }
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = / %d", (char *)"Dot11 channel / BT channel",
           (int )pBtMgnt->BTChannel);
  tmp___1 = BTDM_GetRxSS(padapter);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = %d / %d / %d", (char *)"Wifi/BT/HS rssi",
           tmp___1, (int )pHalData->bt_coexist.halCoex8723.btRssi, pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    tmp___5 = BTDM_IsWifiBusy(padapter);
    if ((unsigned int )tmp___5 != 0U) {
      tmp___3 = BTDM_IsWifiUplink(padapter);
      tmp___4 = (unsigned int )tmp___3 != 0U ? (char *)"uplink" : (char *)"downlink";
    } else {
      tmp___4 = (char *)"idle";
    }
    tmp___9 = BTDM_Legacy(padapter);
    if ((unsigned int )tmp___9 == 0U) {
      tmp___7 = BTDM_IsHT40(padapter);
      tmp___8 = (unsigned int )tmp___7 != 0U ? (char *)"HT40" : (char *)"HT20";
    } else {
      tmp___8 = (char *)"Legacy";
    }
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = %s / %s ", (char *)"WIfi status",
             tmp___8, tmp___4);
    if ((unsigned int )pBtMgnt->bSupportProfile != 0U) {
      tmp___10 = BTHCI_CheckProfileExist(padapter, 1);
      tmp___11 = BTHCI_CheckProfileExist(padapter, 2);
      tmp___12 = BTHCI_CheckProfileExist(padapter, 3);
      tmp___13 = BTHCI_CheckProfileExist(padapter, 4);
      snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d / %d / %d",
               (char *)"SCO/HID/PAN/A2DP", (unsigned int )tmp___13 != 0U, (unsigned int )tmp___12 != 0U,
               (unsigned int )tmp___11 != 0U, (unsigned int )tmp___10 != 0U);
      i = 0U;
      goto ldv_56619;
      ldv_56618: ;
      if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer != 0U) {
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s/ %s/ %s", (char *)"Bt link type/spec/role",
                 BtProfileString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile],
                 BtSpecString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec],
                 BtLinkRoleString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole]);
        btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s", (char *)"A2DP rate",
                 (int )btInfoExt & 1 ? (char *)"Basic rate" : (char *)"EDR rate");
      } else {
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s/ %s", (char *)"Bt link type/spec",
                 BtProfileString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile],
                 BtSpecString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec]);
      }
      i = (u8 )((int )i + 1);
      ldv_56619: ;
      if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
        goto ldv_56618;
      } else {
      }
    } else {
    }
  } else {
  }
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Sw BT Coex mechanism]============");
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"AGC Table",
             (int )pBtCoex->btdm2Ant.bCurAgcTableEn);
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"ADC Backoff",
             (int )pBtCoex->btdm2Ant.bCurAdcBackOff);
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"Low penalty RA",
             (int )pBtCoex->btdm2Ant.bCurLowPenaltyRa);
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"RF Rx LPF Shrink",
             (int )pBtCoex->btdm2Ant.bCurRfRxLpfShrink);
  } else {
  }
  u4Tmp[0] = PHY_QueryRFReg(padapter, 0, 30U, 4080U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x", (char *)"RF-A, 0x1e[11:4]/original val",
           u4Tmp[0], pHalData->bt_coexist.BtRfRegOrigin1E);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Fw BT Coex mechanism]============");
  } else {
  }
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    tmp___14 = btdm_BtWifiAntNum(padapter);
    if ((unsigned int )tmp___14 == 1U) {
      psTdmaCase = pHalData->bt_coexist.halCoex8723.btdm1Ant.curPsTdma;
    } else {
      psTdmaCase = pHalData->bt_coexist.halCoex8723.btdm2Ant.curPsTdma;
    }
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %02x %02x %02x %02x %02x case-%d",
             (char *)"PS TDMA(0x3a)", (int )pHalData->bt_coexist.fw3aVal[0], (int )pHalData->bt_coexist.fw3aVal[1],
             (int )pHalData->bt_coexist.fw3aVal[2], (int )pHalData->bt_coexist.fw3aVal[3],
             (int )pHalData->bt_coexist.fw3aVal[4], (int )psTdmaCase);
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"Decrease Bt Power",
             (int )pBtCoex->btdm2Ant.bCurDecBtPwr);
  } else {
  }
  u1Tmp = rtl8723au_read8(padapter, 1912U);
  u1Tmp1 = rtl8723au_read8(padapter, 1923U);
  u1Tmp2 = rtl8723au_read8(padapter, 1942U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", (char *)"0x778/ 0x783/ 0x796",
           (int )u1Tmp, (int )u1Tmp1, (int )u1Tmp2);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x / 0x%x", (char *)"Sw DacSwing Ctrl/Val",
             (int )pBtCoex->btdm2Ant.bCurDacSwingOn, pBtCoex->btdm2Ant.curDacSwingLvl);
  } else {
  }
  u4Tmp[0] = rtl8723au_read32(padapter, 2176U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x880",
           u4Tmp[0]);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Hw BT Coex mechanism]============");
  } else {
  }
  u1Tmp = rtl8723au_read8(padapter, 64U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x40", (int )u1Tmp);
  u4Tmp[0] = rtl8723au_read32(padapter, 1360U);
  u1Tmp = rtl8723au_read8(padapter, 1314U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/0x%x", (char *)"0x550(bcn contrl)/0x522",
           u4Tmp[0], (int )u1Tmp);
  u4Tmp[0] = rtl8723au_read32(padapter, 1156U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x484(rate adaptive)",
           u4Tmp[0]);
  u4Tmp[0] = rtl8723au_read32(padapter, 80U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0xc50(dig)",
           u4Tmp[0]);
  u4Tmp[0] = rtl8723au_read32(padapter, 3488U);
  u4Tmp[1] = rtl8723au_read32(padapter, 3492U);
  u4Tmp[2] = rtl8723au_read32(padapter, 3496U);
  u4Tmp[3] = rtl8723au_read32(padapter, 3500U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
           (char *)"0xda0/0xda4/0xda8/0xdac(FA cnt)", u4Tmp[0], u4Tmp[1], u4Tmp[2],
           u4Tmp[3]);
  u4Tmp[0] = rtl8723au_read32(padapter, 1728U);
  u4Tmp[1] = rtl8723au_read32(padapter, 1732U);
  u4Tmp[2] = rtl8723au_read32(padapter, 1736U);
  u1Tmp = rtl8723au_read8(padapter, 1740U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
           (char *)"0x6c0/0x6c4/0x6c8/0x6cc(coexTable)", u4Tmp[0], u4Tmp[1], u4Tmp[2],
           (int )u1Tmp);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d", (char *)"0x770(Hi pri Rx[31:16]/Tx[15:0])",
           pHalData->bt_coexist.halCoex8723.highPriorityRx, pHalData->bt_coexist.halCoex8723.highPriorityTx);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d", (char *)"0x774(Lo pri Rx[31:16]/Tx[15:0])",
           pHalData->bt_coexist.halCoex8723.lowPriorityRx, pHalData->bt_coexist.halCoex8723.lowPriorityTx);
  u1Tmp = rtl8723au_read8(padapter, 1051U);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x41b (hang chk == 0xf)",
           (int )u1Tmp);
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"lastHMEBoxNum",
           (int )pHalData->LastHMEBoxNum);
  return;
}
}
static void BTDM_8723ASignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi ,
                                         u8 *rssi_bt )
{
  u8 tmp ;
  {
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntSignalCompensation(padapter, rssi_wifi, rssi_bt);
  } else {
  }
  return;
}
}
static void BTDM_8723AInit(struct rtw_adapter *padapter )
{
  u8 tmp ;
  {
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    BTDM_2AntParaInit(padapter);
  } else {
    BTDM_1AntParaInit(padapter);
  }
  return;
}
}
static void BTDM_HWCoexAllOff8723A(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    BTDM_2AntHwCoexAllOff8723A(padapter);
  } else {
  }
  return;
}
}
static void BTDM_FWCoexAllOff8723A(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    BTDM_2AntFwCoexAllOff8723A(padapter);
  } else {
  }
  return;
}
}
static void BTDM_SWCoexAllOff8723A(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 0U) {
    BTDM_2AntSwCoexAllOff8723A(padapter);
  } else {
  }
  return;
}
}
static void BTDM_Set8723ABtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum )
{
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  if ((unsigned int )antNum == 1U) {
    pBtCoex->TotalAntNum = 1U;
  } else
  if ((unsigned int )antNum == 2U) {
    pBtCoex->TotalAntNum = 0U;
  } else {
  }
  return;
}
}
void rtl8723a_BT_lps_leave(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntLpsLeave(padapter);
  } else {
  }
  return;
}
}
static void BTDM_ForHalt8723A(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntForHalt(padapter);
  } else {
  }
  return;
}
}
static void BTDM_WifiScanNotify8723A(struct rtw_adapter *padapter , u8 scanType )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntWifiScanNotify(padapter, (int )scanType);
  } else {
  }
  return;
}
}
static void BTDM_WifiAssociateNotify8723A(struct rtw_adapter *padapter , u8 action )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntWifiAssociateNotify(padapter, (int )action);
  } else {
  }
  return;
}
}
static void BTDM_MediaStatusNotify8723A(struct rtw_adapter *padapter , enum rt_media_status mstatus )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], MediaStatusNotify, %s\n", (unsigned int )mstatus != 0U ? (char *)"connect" : (char *)"disconnect");
  } else {
  }
  BTDM_SetFwChnlInfo(padapter, mstatus);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntMediaStatusNotify(padapter, mstatus);
  } else {
  }
  return;
}
}
static void BTDM_ForDhcp8723A(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    BTDM_1AntForDhcp(padapter);
  } else {
  }
  return;
}
}
bool rtl8723a_BT_using_antenna_1(struct rtw_adapter *padapter )
{
  u8 tmp ;
  {
  tmp = btdm_BtWifiAntNum(padapter);
  if ((unsigned int )tmp == 1U) {
    return (1);
  } else {
    return (0);
  }
}
}
static void BTDM_BTCoexist8723A(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
  if (BTCoexDbgLevel == 1U) {
    printk("[BTCoex], beacon RSSI = 0x%x(%d)\n", pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB,
           pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB);
  } else {
  }
  btdm_BtHwCountersMonitor(padapter);
  btdm_BtEnableDisableCheck8723A(padapter);
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("%s: Action Manual control!!\n", "BTDM_BTCoexist8723A");
    } else {
    }
    return;
  } else {
  }
  if ((unsigned int )pBtCoex->bC2hBtInfoReqSent != 0U) {
    tmp = rtl8723a_BT_enabled(padapter);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    if (tmp___0) {
      pBtCoex->c2hBtInfo = 0U;
    } else
    if ((unsigned int )pBtCoex->c2hBtInfo == 0U) {
      pBtCoex->c2hBtInfo = 1U;
    } else {
    }
    btdm_BTCoexist8723AHandler(padapter);
  } else {
    tmp___1 = rtl8723a_BT_enabled(padapter);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      pBtCoex->c2hBtInfo = 0U;
      btdm_BTCoexist8723AHandler(padapter);
    } else {
    }
  }
  BTDM_QueryBtInformation(padapter);
  return;
}
}
static void BTDM_SetAntenna(struct rtw_adapter *padapter , u8 who )
{
  {
  return;
}
}
void BTDM_SingleAnt(struct rtw_adapter *padapter , u8 bSingleAntOn , u8 bInterruptOn ,
                    u8 bMultiNAVOn )
{
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {
    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 1U) {
    return;
  } else {
  }
  H2C_Parameter[2] = 0U;
  H2C_Parameter[1] = 0U;
  H2C_Parameter[0] = 0U;
  if ((unsigned int )bInterruptOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 2U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
  }
  pHalData->bt_coexist.bInterruptOn = bInterruptOn;
  if ((unsigned int )bSingleAntOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 16U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
  }
  pHalData->bt_coexist.bSingleAntOn = bSingleAntOn;
  if ((unsigned int )bMultiNAVOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 32U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
  }
  pHalData->bt_coexist.bMultiNAVOn = bMultiNAVOn;
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], SingleAntenna =[%s:%s:%s], write 0xe = 0x%x\n", (unsigned int )bSingleAntOn != 0U ? (char *)"ON" : (char *)"OFF",
           (unsigned int )bInterruptOn != 0U ? (char *)"ON" : (char *)"OFF", (unsigned int )bMultiNAVOn != 0U ? (char *)"ON" : (char *)"OFF",
           (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {
  }
  return;
}
}
void BTDM_CheckBTIdleChange1Ant(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 stateChange ;
  u32 BT_Polling ;
  u32 Ratio_Act ;
  u32 Ratio_STA ;
  u32 BT_Active ;
  u32 BT_State ;
  u32 regBTActive ;
  u32 regBTState ;
  u32 regBTPolling ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  stateChange = 0U;
  regBTActive = 0U;
  regBTState = 0U;
  regBTPolling = 0U;
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
    return;
  } else {
  }
  if ((unsigned int )pHalData->bt_coexist.BT_CoexistType != 4U) {
    return;
  } else {
  }
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 1U) {
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], FirmwareVersion = 0x%x(%d)\n", (int )pHalData->FirmwareVersion,
           (int )pHalData->FirmwareVersion);
  } else {
  }
  regBTActive = 1092U;
  regBTState = 1096U;
  if ((unsigned int )pHalData->FirmwareVersion > 73U) {
    regBTPolling = 1100U;
  } else {
    regBTPolling = 1792U;
  }
  BT_Active = rtl8723au_read32(padapter, regBTActive);
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], BT_Active(0x%x) =%x\n", regBTActive, BT_Active);
  } else {
  }
  BT_Active = BT_Active & 16777215U;
  BT_State = rtl8723au_read32(padapter, regBTState);
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], BT_State(0x%x) =%x\n", regBTState, BT_State);
  } else {
  }
  BT_State = BT_State & 16777215U;
  BT_Polling = rtl8723au_read32(padapter, regBTPolling);
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], BT_Polling(0x%x) =%x\n", regBTPolling, BT_Polling);
  } else {
  }
  if ((BT_Active == 4294967295U && BT_State == 4294967295U) && BT_Polling == 4294967295U) {
    return;
  } else {
  }
  if (BT_Polling == 0U) {
    return;
  } else {
  }
  Ratio_Act = (BT_Active * 1000U) / BT_Polling;
  Ratio_STA = (BT_State * 1000U) / BT_Polling;
  pHalData->bt_coexist.Ratio_Tx = Ratio_Act;
  pHalData->bt_coexist.Ratio_PRI = Ratio_STA;
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], Ratio_Act =%d\n", Ratio_Act);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], Ratio_STA =%d\n", Ratio_STA);
  } else {
  }
  if (Ratio_STA <= 59U && Ratio_Act <= 499U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32768ULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffdffffULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffff7fffULL;
    if (Ratio_STA != 0U) {
      if (Ratio_Act / Ratio_STA <= 1U) {
        pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 65536ULL;
        pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffdffffULL;
      } else {
        pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
        pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 131072ULL;
      }
    } else {
      pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 0U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
      pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 1U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 131072ULL;
    }
  }
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfSCO == 0U) {
    pBtMgnt->ExtConfig.bBTBusy = 0U;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  } else
  if (Ratio_STA <= 59U) {
    pBtMgnt->ExtConfig.bBTBusy = 0U;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  } else {
    pBtMgnt->ExtConfig.bBTBusy = 1U;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffefffULL;
  }
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfSCO == 0U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffff7ffffULL;
    pBtMgnt->ExtConfig.MIN_BT_RSSI = 0;
    BTDM_SetAntenna(padapter, 0);
  } else
  if ((int )pBtMgnt->ExtConfig.MIN_BT_RSSI < -4) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 524288ULL;
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], core stack notify bt rssi Low\n");
    } else {
    }
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffff7ffffULL;
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], core stack notify bt rssi Normal\n");
    } else {
    }
  }
  if ((int )pHalData->bt_coexist.bBTBusyTraffic != (int )pBtMgnt->ExtConfig.bBTBusy) {
    pHalData->bt_coexist.bBTBusyTraffic = pBtMgnt->ExtConfig.bBTBusy;
    stateChange = 1U;
  } else {
  }
  if ((unsigned int )stateChange != 0U) {
    if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy == 0U) {
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], BT is idle or disable\n");
      } else {
      }
    } else
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], BT is non-idle\n");
    } else {
    }
  } else {
  }
  if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], BT is idle or disable\n");
    } else {
    }
    tmp___1 = check_fwstate(& padapter->mlmepriv, 2176);
    if ((int )tmp___1) {
      BTDM_SetAntenna(padapter, 1);
    } else {
    }
  } else {
  }
  return;
}
}
void BTDM_DiminishWiFi(struct rtw_adapter *padapter , u8 bDACOn , u8 bInterruptOn ,
                       u8 DACSwingLevel , u8 bNAVOn )
{
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {
    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 0U) {
    return;
  } else {
  }
  if ((pHalData->bt_coexist.CurrentState & 524288ULL) != 0ULL && (unsigned int )DACSwingLevel == 32U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]DiminishWiFi 0x20 original, but set 0x18 for Low RSSI!\n");
    } else {
    }
    DACSwingLevel = 24U;
  } else {
  }
  H2C_Parameter[2] = 0U;
  H2C_Parameter[1] = DACSwingLevel;
  H2C_Parameter[0] = 0U;
  if ((unsigned int )bDACOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 1U);
    if ((unsigned int )bInterruptOn != 0U) {
      H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 2U);
    } else {
    }
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
  }
  if ((unsigned int )bNAVOn != 0U) {
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 8U);
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], bDACOn = %s, bInterruptOn = %s, write 0xe = 0x%x\n", (unsigned int )bDACOn != 0U ? (char *)"ON" : (char *)"OFF",
           (unsigned int )bInterruptOn != 0U ? (char *)"ON" : (char *)"OFF", (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], bNAVOn = %s\n", (unsigned int )bNAVOn != 0U ? (char *)"ON" : (char *)"OFF");
  } else {
  }
  return;
}
}
static void btdm_ResetFWCoexState(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->bt_coexist.CurrentState = 0ULL;
  pHalData->bt_coexist.PreviousState = 0ULL;
  return;
}
}
static void btdm_InitBtCoexistDM(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->bt_coexist.BtRfRegOrigin1E = PHY_QueryRFReg(padapter, 0, 30U, 1048575U);
  pHalData->bt_coexist.BtRfRegOrigin1F = PHY_QueryRFReg(padapter, 0, 31U, 240U);
  pHalData->bt_coexist.CurrentState = 0ULL;
  pHalData->bt_coexist.PreviousState = 0ULL;
  BTDM_8723AInit(padapter);
  pHalData->bt_coexist.bInitlized = 1U;
  return;
}
}
void BTDM_CheckAntSelMode(struct rtw_adapter *padapter )
{
  {
  return;
}
}
void BTDM_FwC2hBtRssi(struct rtw_adapter *padapter , u8 *tmpBuf )
{
  {
  BTDM_FwC2hBtRssi8723A(padapter, tmpBuf);
  return;
}
}
void BTDM_DisplayBtCoexInfo(struct rtw_adapter *padapter )
{
  {
  BTDM_Display8723ABtCoexInfo(padapter);
  return;
}
}
void BTDM_RejectAPAggregatedPacket(struct rtw_adapter *padapter , u8 bReject )
{
  {
  return;
}
}
u8 BTDM_IsHT40(struct rtw_adapter *padapter )
{
  u8 isht40 ;
  enum ht_channel_width bw ;
  {
  isht40 = 1U;
  bw = (enum ht_channel_width )padapter->mlmeextpriv.cur_bwmode;
  if ((unsigned int )bw == 0U) {
    isht40 = 0U;
  } else
  if ((unsigned int )bw == 1U) {
    isht40 = 1U;
  } else {
  }
  return (isht40);
}
}
u8 BTDM_Legacy(struct rtw_adapter *padapter )
{
  struct mlme_ext_priv *pmlmeext ;
  u8 isLegacy ;
  {
  isLegacy = 0U;
  pmlmeext = & padapter->mlmeextpriv;
  if (((unsigned int )pmlmeext->cur_wireless_mode == 1U || (unsigned int )pmlmeext->cur_wireless_mode == 2U) || (unsigned int )pmlmeext->cur_wireless_mode == 3U) {
    isLegacy = 1U;
  } else {
  }
  return (isLegacy);
}
}
void BTDM_CheckWiFiState(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffeffULL;
    if ((int )pmlmepriv->LinkDetectInfo.bTxBusyTraffic) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 512ULL;
    } else {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffdffULL;
    }
    if ((int )pmlmepriv->LinkDetectInfo.bRxBusyTraffic) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1024ULL;
    } else {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffbffULL;
    }
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 256ULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffdffULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffbffULL;
  }
  tmp___0 = BTDM_Legacy(padapter);
  if ((unsigned int )tmp___0 != 0U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8ULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffdULL;
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffbULL;
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffff7ULL;
    tmp = BTDM_IsHT40(padapter);
    if ((unsigned int )tmp != 0U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffdULL;
    } else {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffbULL;
    }
  }
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1ULL;
  } else {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffeULL;
  }
  return;
}
}
s32 BTDM_GetRxSS(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  bool tmp ;
  {
  UndecoratedSmoothedPWDB = 0;
  pmlmepriv = & padapter->mlmepriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    UndecoratedSmoothedPWDB = ((struct hal_data_8723a *)padapter->HalData)->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  } else {
    UndecoratedSmoothedPWDB = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_GetRxSS() = %d\n", UndecoratedSmoothedPWDB);
  } else {
  }
  return (UndecoratedSmoothedPWDB);
}
}
static s32 BTDM_GetRxBeaconSS(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  s32 pwdbBeacon ;
  bool tmp ;
  {
  pwdbBeacon = 0;
  pmlmepriv = & padapter->mlmepriv;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = check_fwstate(pmlmepriv, 1);
  if ((int )tmp) {
    pwdbBeacon = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_GetRxBeaconSS() = %d\n", pwdbBeacon);
  } else {
  }
  return (pwdbBeacon);
}
}
u8 BTDM_CheckCoexBcnRssiState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                              u8 RssiThresh1 )
{
  struct hal_data_8723a *pHalData ;
  s32 pwdbBeacon ;
  u8 bcnRssiState ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pwdbBeacon = 0;
  bcnRssiState = 0U;
  pwdbBeacon = BTDM_GetRxBeaconSS(padapter);
  if ((unsigned int )levelNum == 2U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 2U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 5U) {
      if ((int )RssiThresh + 6 <= pwdbBeacon) {
        bcnRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 536870912ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state switch to High\n");
        } else {
        }
      } else {
        bcnRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state stay at Low\n");
        } else {
        }
      }
    } else
    if ((int )RssiThresh > pwdbBeacon) {
      bcnRssiState = 2U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 134217728ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON state switch to Low\n");
      } else {
      }
    } else {
      bcnRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON state stay at High\n");
      } else {
      }
    }
  } else
  if ((unsigned int )levelNum == 3U) {
    if ((int )RssiThresh > (int )RssiThresh1) {
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON thresh error!!\n");
      } else {
      }
      return (pHalData->bt_coexist.preRssiStateBeacon);
    } else {
    }
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 2U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 5U) {
      if ((int )RssiThresh + 6 <= pwdbBeacon) {
        bcnRssiState = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 268435456ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state switch to Medium\n");
        } else {
        }
      } else {
        bcnRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state stay at Low\n");
        } else {
        }
      }
    } else
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 1U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 4U) {
      if ((int )RssiThresh1 + 6 <= pwdbBeacon) {
        bcnRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 536870912ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state switch to High\n");
        } else {
        }
      } else
      if ((int )RssiThresh > pwdbBeacon) {
        bcnRssiState = 2U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 134217728ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state switch to Low\n");
        } else {
        }
      } else {
        bcnRssiState = 4U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_BEACON state stay at Medium\n");
        } else {
        }
      }
    } else
    if ((int )RssiThresh1 > pwdbBeacon) {
      bcnRssiState = 1U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 268435456ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON state switch to Medium\n");
      } else {
      }
    } else {
      bcnRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_BEACON state stay at High\n");
      } else {
      }
    }
  } else {
  }
  pHalData->bt_coexist.preRssiStateBeacon = bcnRssiState;
  return (bcnRssiState);
}
}
u8 BTDM_CheckCoexRSSIState1(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                            u8 RssiThresh1 )
{
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  u8 btRssiState ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  UndecoratedSmoothedPWDB = 0;
  btRssiState = 0U;
  UndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);
  if ((unsigned int )levelNum == 2U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 2U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 5U) {
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 67108864ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state switch to High\n");
        } else {
        }
      } else {
        btRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state stay at Low\n");
        } else {
        }
      }
    } else
    if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
      btRssiState = 2U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16777216ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 state switch to Low\n");
      } else {
      }
    } else {
      btRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 state stay at High\n");
      } else {
      }
    }
  } else
  if ((unsigned int )levelNum == 3U) {
    if ((int )RssiThresh > (int )RssiThresh1) {
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 thresh error!!\n");
      } else {
      }
      return (pHalData->bt_coexist.preRssiState1);
    } else {
    }
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 2U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 5U) {
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 33554432ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state switch to Medium\n");
        } else {
        }
      } else {
        btRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state stay at Low\n");
        } else {
        }
      }
    } else
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 1U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 4U) {
      if ((int )RssiThresh1 + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 67108864ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state switch to High\n");
        } else {
        }
      } else
      if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
        btRssiState = 2U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16777216ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state switch to Low\n");
        } else {
        }
      } else {
        btRssiState = 4U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI_1 state stay at Medium\n");
        } else {
        }
      }
    } else
    if ((int )RssiThresh1 > UndecoratedSmoothedPWDB) {
      btRssiState = 1U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 33554432ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 state switch to Medium\n");
      } else {
      }
    } else {
      btRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI_1 state stay at High\n");
      } else {
      }
    }
  } else {
  }
  pHalData->bt_coexist.preRssiState1 = btRssiState;
  return (btRssiState);
}
}
u8 BTDM_CheckCoexRSSIState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                           u8 RssiThresh1 )
{
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  u8 btRssiState ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  UndecoratedSmoothedPWDB = 0;
  btRssiState = 0U;
  UndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);
  if ((unsigned int )levelNum == 2U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 2U || (unsigned int )pHalData->bt_coexist.preRssiState == 5U) {
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 64ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state switch to High\n");
        } else {
        }
      } else {
        btRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state stay at Low\n");
        } else {
        }
      }
    } else
    if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
      btRssiState = 2U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI state switch to Low\n");
      } else {
      }
    } else {
      btRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI state stay at High\n");
      } else {
      }
    }
  } else
  if ((unsigned int )levelNum == 3U) {
    if ((int )RssiThresh > (int )RssiThresh1) {
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI thresh error!!\n");
      } else {
      }
      return (pHalData->bt_coexist.preRssiState);
    } else {
    }
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 2U || (unsigned int )pHalData->bt_coexist.preRssiState == 5U) {
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 1U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state switch to Medium\n");
        } else {
        }
      } else {
        btRssiState = 5U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state stay at Low\n");
        } else {
        }
      }
    } else
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 1U || (unsigned int )pHalData->bt_coexist.preRssiState == 4U) {
      if ((int )RssiThresh1 + 6 <= UndecoratedSmoothedPWDB) {
        btRssiState = 0U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 64ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state switch to High\n");
        } else {
        }
      } else
      if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
        btRssiState = 2U;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16ULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state switch to Low\n");
        } else {
        }
      } else {
        btRssiState = 4U;
        if (BTCoexDbgLevel == 1U) {
          printk("[DM][BT], RSSI state stay at Medium\n");
        } else {
        }
      }
    } else
    if ((int )RssiThresh1 > UndecoratedSmoothedPWDB) {
      btRssiState = 1U;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32ULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI state switch to Medium\n");
      } else {
      }
    } else {
      btRssiState = 3U;
      if (BTCoexDbgLevel == 1U) {
        printk("[DM][BT], RSSI state stay at High\n");
      } else {
      }
    }
  } else {
  }
  pHalData->bt_coexist.preRssiState = btRssiState;
  return (btRssiState);
}
}
bool rtl8723a_BT_disable_EDCA_turbo(struct rtw_adapter *padapter )
{
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 bBtChangeEDCA ;
  u32 EDCA_BT_BE ;
  u32 cur_EDCA_reg ;
  bool bRet ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  bBtChangeEDCA = 0U;
  EDCA_BT_BE = 6202411U;
  bRet = 0;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtMgnt = & pHalData->BtInfo.BtMgnt;
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    bRet = 0;
    pHalData->bt_coexist.lastBtEdca = 0U;
    return (bRet);
  } else {
  }
  if ((unsigned int )pBtMgnt->bSupportProfile == 0U && (unsigned int )pHalData->bt_coexist.BT_CoexistType != 4U) {
    bRet = 0;
    pHalData->bt_coexist.lastBtEdca = 0U;
    return (bRet);
  } else {
  }
  tmp___1 = rtl8723a_BT_using_antenna_1(padapter);
  if ((int )tmp___1) {
    bRet = 0;
    pHalData->bt_coexist.lastBtEdca = 0U;
    return (bRet);
  } else {
  }
  if ((unsigned int )pHalData->bt_coexist.exec_cnt <= 2U) {
    pHalData->bt_coexist.exec_cnt = (u8 )((int )pHalData->bt_coexist.exec_cnt + 1);
  } else {
    pHalData->bt_coexist.bEDCAInitialized = 1U;
  }
  if ((pHalData->bt_coexist.CurrentState & 4096ULL) == 0ULL) {
    if (BTCoexDbgLevel == 1U) {
      printk("BT state non idle, set bt EDCA\n");
    } else {
    }
    if ((int )pHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA) {
      bBtChangeEDCA = 1U;
      pHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA = 0;
      pHalData->dmpriv.prv_traffic_idx = 3U;
    } else {
    }
    cur_EDCA_reg = rtl8723au_read32(padapter, 1288U);
    if (cur_EDCA_reg != EDCA_BT_BE) {
      bBtChangeEDCA = 1U;
    } else {
    }
    if ((unsigned int )bBtChangeEDCA != 0U || (unsigned int )pHalData->bt_coexist.bEDCAInitialized == 0U) {
      rtl8723au_write32(padapter, 1288U, EDCA_BT_BE);
      pHalData->bt_coexist.lastBtEdca = EDCA_BT_BE;
    } else {
    }
    bRet = 1;
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("BT state idle, set original EDCA\n");
    } else {
    }
    pHalData->bt_coexist.lastBtEdca = 0U;
    bRet = 0;
  }
  return (bRet);
}
}
void BTDM_Balance(struct rtw_adapter *padapter , u8 bBalanceOn , u8 ms0 , u8 ms1 )
{
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {
    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  if ((unsigned int )bBalanceOn != 0U) {
    H2C_Parameter[2] = 1U;
    H2C_Parameter[1] = ms1;
    H2C_Parameter[0] = ms0;
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
    H2C_Parameter[2] = 0U;
    H2C_Parameter[1] = 0U;
    H2C_Parameter[0] = 0U;
  }
  pHalData->bt_coexist.bBalanceOn = bBalanceOn;
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], Balance =[%s:%dms:%dms], write 0xc = 0x%x\n", (unsigned int )bBalanceOn != 0U ? (char *)"ON" : (char *)"OFF",
           (int )ms0, (int )ms1, (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {
  }
  FillH2CCmd(padapter, 12, 3U, (u8 *)(& H2C_Parameter));
  return;
}
}
void BTDM_AGCTable(struct rtw_adapter *padapter , u8 type )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )type == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]AGCTable Off!\n");
    } else {
    }
    rtl8723au_write32(padapter, 3192U, 1679556609U);
    rtl8723au_write32(padapter, 3192U, 1662844929U);
    rtl8723au_write32(padapter, 3192U, 1646133249U);
    rtl8723au_write32(padapter, 3192U, 1629421569U);
    rtl8723au_write32(padapter, 3192U, 1612709889U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 204800U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 462848U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 720896U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 1032192U);
    PHY_SetRFReg(padapter, 0, 26U, 1048575U, 197461U);
    pHalData->bt_coexist.b8723aAgcTableOn = 0U;
  } else
  if ((unsigned int )type == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]AGCTable On!\n");
    } else {
    }
    rtl8723au_write32(padapter, 3192U, 1310457857U);
    rtl8723au_write32(padapter, 3192U, 1293746177U);
    rtl8723au_write32(padapter, 3192U, 1277034497U);
    rtl8723au_write32(padapter, 3192U, 1260322817U);
    rtl8723au_write32(padapter, 3192U, 1243611137U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 901120U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 589824U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 331776U);
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 73728U);
    PHY_SetRFReg(padapter, 0, 26U, 1048575U, 853U);
    pHalData->bt_coexist.b8723aAgcTableOn = 1U;
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {
  }
  return;
}
}
void BTDM_BBBackOffLevel(struct rtw_adapter *padapter , u8 type )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )type == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]BBBackOffLevel Off!\n");
    } else {
    }
    rtl8723au_write32(padapter, 3076U, 60839441U);
  } else
  if ((unsigned int )type == 1U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT]BBBackOffLevel On!\n");
    } else {
    }
    rtl8723au_write32(padapter, 3076U, 60847633U);
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {
  }
  return;
}
}
void BTDM_FWCoexAllOff(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_FWCoexAllOff()\n");
  } else {
  }
  if ((unsigned int )pHalData->bt_coexist.bFWCoexistAllOff != 0U) {
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_FWCoexAllOff(), real Do\n");
  } else {
  }
  BTDM_FWCoexAllOff8723A(padapter);
  pHalData->bt_coexist.bFWCoexistAllOff = 1U;
  return;
}
}
void BTDM_SWCoexAllOff(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_SWCoexAllOff()\n");
  } else {
  }
  if ((unsigned int )pHalData->bt_coexist.bSWCoexistAllOff != 0U) {
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_SWCoexAllOff(), real Do\n");
  } else {
  }
  BTDM_SWCoexAllOff8723A(padapter);
  pHalData->bt_coexist.bSWCoexistAllOff = 1U;
  return;
}
}
void BTDM_HWCoexAllOff(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_HWCoexAllOff()\n");
  } else {
  }
  if ((unsigned int )pHalData->bt_coexist.bHWCoexistAllOff != 0U) {
    return;
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("BTDM_HWCoexAllOff(), real Do\n");
  } else {
  }
  BTDM_HWCoexAllOff8723A(padapter);
  pHalData->bt_coexist.bHWCoexistAllOff = 1U;
  return;
}
}
void BTDM_CoexAllOff(struct rtw_adapter *padapter )
{
  {
  BTDM_FWCoexAllOff(padapter);
  BTDM_SWCoexAllOff(padapter);
  BTDM_HWCoexAllOff(padapter);
  return;
}
}
void rtl8723a_BT_disable_coexist(struct rtw_adapter *padapter )
{
  struct pwrctrl_priv *ppwrctrl ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  {
  ppwrctrl = & padapter->pwrctrlpriv;
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  tmp___1 = rtl8723a_BT_using_antenna_1(padapter);
  if ((int )tmp___1) {
    return;
  } else {
  }
  if ((unsigned int )ppwrctrl->reg_rfoff == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BT][DM], Before enter IPS, turn off all Coexist DM\n");
    } else {
    }
    btdm_ResetFWCoexState(padapter);
    BTDM_CoexAllOff(padapter);
    BTDM_SetAntenna(padapter, 2);
  } else {
  }
  return;
}
}
void BTDM_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt )
{
  {
  BTDM_8723ASignalCompensation(padapter, rssi_wifi, rssi_bt);
  return;
}
}
void rtl8723a_BT_do_coexist(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  int tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], BT not exists!!\n");
    } else {
    }
    return;
  } else {
  }
  if ((unsigned int )pHalData->bt_coexist.bInitlized == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], btdm_InitBtCoexistDM()\n");
    } else {
    }
    btdm_InitBtCoexistDM(padapter);
  } else {
  }
  if (BTCoexDbgLevel == 1U) {
    printk("\n\n[DM][BT], BTDM start!!\n");
  } else {
  }
  BTDM_PWDBMonitor(padapter);
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], HW type is 8723\n");
  } else {
  }
  BTDM_BTCoexist8723A(padapter);
  if (BTCoexDbgLevel == 1U) {
    printk("[DM][BT], BTDM end!!\n\n");
  } else {
  }
  return;
}
}
void BTDM_UpdateCoexState(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  tmp = BTDM_IsSameCoexistState(padapter);
  if ((unsigned int )tmp == 0U) {
    if (BTCoexDbgLevel == 1U) {
      printk("[BTCoex], Coexist State[bitMap] change from 0x%llx to 0x%llx,  changeBits = 0x%llx\n",
             pHalData->bt_coexist.PreviousState, pHalData->bt_coexist.CurrentState,
             pHalData->bt_coexist.PreviousState ^ pHalData->bt_coexist.CurrentState);
    } else {
    }
    pHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;
  } else {
  }
  return;
}
}
u8 BTDM_IsSameCoexistState(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState) {
    return (1U);
  } else {
    if (BTCoexDbgLevel == 1U) {
      printk("[DM][BT], Coexist state changed!!\n");
    } else {
    }
    return (0U);
  }
}
}
void BTDM_PWDBMonitor(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  s32 tmpBTEntryMaxPWDB ;
  s32 tmpBTEntryMinPWDB ;
  u8 i ;
  u32 __i ;
  u8 *ptr ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  H2C_Parameter[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {
    }
    H2C_Parameter[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  tmpBTEntryMaxPWDB = 0;
  tmpBTEntryMinPWDB = 255;
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
    i = 0U;
    goto ldv_56887;
    ldv_56886: ;
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U) {
      if (pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB < tmpBTEntryMinPWDB) {
        tmpBTEntryMinPWDB = pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      } else {
      }
      if (pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB > tmpBTEntryMaxPWDB) {
        tmpBTEntryMaxPWDB = pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      } else {
      }
      H2C_Parameter[2] = (unsigned char )pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      H2C_Parameter[0] = 63U - (unsigned int )i;
      if (BTCoexDbgLevel == 1U) {
        printk("RSSI report for BT[%d], H2C_Par = 0x%x\n", (int )i, (int )H2C_Parameter[0]);
      } else {
      }
      FillH2CCmd(padapter, 5, 3U, (u8 *)(& H2C_Parameter));
      if (BTCoexDbgLevel == 1U) {
        ptr = (u8 *)(& pBTInfo->BtAsocEntry[(int )i].BTRemoteMACAddr);
        printk("BT_Entry Mac :");
        printk(" ");
        __i = 0U;
        goto ldv_56884;
        ldv_56883:
        printk("%02X%s", (int )*(ptr + (unsigned long )__i), __i == 5U ? (char *)"" : (char *)"-");
        __i = __i + 1U;
        ldv_56884: ;
        if (__i <= 5U) {
          goto ldv_56883;
        } else {
        }
        printk("\n");
      } else {
      }
      if (BTCoexDbgLevel == 1U) {
        printk("BT rx pwdb[%d] = 0x%x(%d)\n", (int )i, pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB,
               pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB);
      } else {
      }
    } else {
    }
    i = (u8 )((int )i + 1);
    ldv_56887: ;
    if ((unsigned int )i <= 1U) {
      goto ldv_56886;
    } else {
    }
    if (tmpBTEntryMaxPWDB != 0) {
      pHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = tmpBTEntryMaxPWDB;
      if (BTCoexDbgLevel == 1U) {
        printk("BT_EntryMaxPWDB = 0x%x(%d)\n", tmpBTEntryMaxPWDB, tmpBTEntryMaxPWDB);
      } else {
      }
    } else {
      pHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = 0;
    }
    if (tmpBTEntryMinPWDB != 255) {
      pHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = tmpBTEntryMinPWDB;
      if (BTCoexDbgLevel == 1U) {
        printk("BT_EntryMinPWDB = 0x%x(%d)\n", tmpBTEntryMinPWDB, tmpBTEntryMinPWDB);
      } else {
      }
    } else {
      pHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = 0;
    }
  } else {
  }
  return;
}
}
u8 BTDM_IsBTBusy(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  {
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsWifiBusy(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtTraffic = & pBTInfo->BtTraffic;
  if (((int )pmlmepriv->LinkDetectInfo.bBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic != 0U) || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsCoexistStateChanged(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState) {
    return (0U);
  } else {
    return (1U);
  }
}
}
u8 BTDM_IsWifiUplink(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtTraffic = & pBTInfo->BtTraffic;
  if ((int )pmlmepriv->LinkDetectInfo.bTxBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsWifiDownlink(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtTraffic = & pBTInfo->BtTraffic;
  if ((int )pmlmepriv->LinkDetectInfo.bRxBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsBTHSMode(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_mgnt *pBtMgnt ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBtMgnt = & pHalData->BtInfo.BtMgnt;
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsBTUplink(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
u8 BTDM_IsBTDownlink(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic != 0U) {
    return (1U);
  } else {
    return (0U);
  }
}
}
void BTDM_AdjustForBtOperation(struct rtw_adapter *padapter )
{
  {
  if (BTCoexDbgLevel == 1U) {
    printk("[BT][DM], BTDM_AdjustForBtOperation()\n");
  } else {
  }
  BTDM_AdjustForBtOperation8723A(padapter);
  return;
}
}
void BTDM_SetBtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum )
{
  {
  BTDM_Set8723ABtCoexCurrAntNum(padapter, (int )antNum);
  return;
}
}
void BTDM_ForHalt(struct rtw_adapter *padapter )
{
  bool tmp ;
  int tmp___0 ;
  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  BTDM_ForHalt8723A(padapter);
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.bInitlized = 0U;
  return;
}
}
void BTDM_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType )
{
  bool tmp ;
  int tmp___0 ;
  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  BTDM_WifiScanNotify8723A(padapter, (int )scanType);
  return;
}
}
void BTDM_WifiAssociateNotify(struct rtw_adapter *padapter , u8 action )
{
  bool tmp ;
  int tmp___0 ;
  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  BTDM_WifiAssociateNotify8723A(padapter, (int )action);
  return;
}
}
void rtl8723a_BT_mediastatus_notify(struct rtw_adapter *padapter , enum rt_media_status mstatus )
{
  bool tmp ;
  int tmp___0 ;
  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  BTDM_MediaStatusNotify8723A(padapter, mstatus);
  return;
}
}
void rtl8723a_BT_specialpacket_notify(struct rtw_adapter *padapter )
{
  bool tmp ;
  int tmp___0 ;
  {
  tmp = rtl8723a_BT_coexist(padapter);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return;
  } else {
  }
  BTDM_ForDhcp8723A(padapter);
  return;
}
}
void BTDM_ResetActionProfileState(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffff0fffffULL;
  return;
}
}
u8 BTDM_IsActionSCO(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 1U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8388608ULL;
      bRet = 1U;
    } else {
    }
  } else
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfSCO != 0U) {
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8388608ULL;
    bRet = 1U;
  } else {
  }
  return (bRet);
}
}
u8 BTDM_IsActionHID(struct rtw_adapter *padapter )
{
  struct bt_30info *pBTInfo ;
  struct hal_data_8723a *pHalData ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 2U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1048576ULL;
      bRet = 1U;
    } else {
    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 3);
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1048576ULL;
      bRet = 1U;
    } else {
    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionA2DP(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 3U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2097152ULL;
      bRet = 1U;
    } else {
    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 1);
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2097152ULL;
      bRet = 1U;
    } else {
    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionPAN(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 4U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4194304ULL;
      bRet = 1U;
    } else {
    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 2);
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4194304ULL;
      bRet = 1U;
    } else {
    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionHIDA2DP(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtMgnt = & pBTInfo->BtMgnt;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 5U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 3145728ULL;
      bRet = 1U;
    } else {
    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 3);
    if ((unsigned int )tmp != 0U) {
      tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
      if ((unsigned int )tmp___0 != 0U) {
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 3145728ULL;
        bRet = 1U;
      } else {
      }
    } else {
    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionHIDPAN(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 6U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 5242880ULL;
      bRet = 1U;
    } else {
    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 3);
    if ((unsigned int )tmp != 0U) {
      tmp___0 = BTHCI_CheckProfileExist(padapter, 2);
      if ((unsigned int )tmp___0 != 0U) {
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 5242880ULL;
        bRet = 1U;
      } else {
      }
    } else {
    }
  }
  return (bRet);
}
}
u8 BTDM_IsActionPANA2DP(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtDbg = & pBTInfo->BtDbg;
  bRet = 0U;
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
    if (pBtDbg->dbgProfile == 7U) {
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 6291456ULL;
      bRet = 1U;
    } else {
    }
  } else {
    tmp = BTHCI_CheckProfileExist(padapter, 2);
    if ((unsigned int )tmp != 0U) {
      tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
      if ((unsigned int )tmp___0 != 0U) {
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 6291456ULL;
        bRet = 1U;
      } else {
      }
    } else {
    }
  }
  return (bRet);
}
}
bool rtl8723a_BT_enabled(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pHalData->bt_coexist.bCurBtDisabled != 0U) {
    return (0);
  } else {
    return (1);
  }
}
}
static void halbt_InitHwConfig8723A(struct rtw_adapter *padapter )
{
  {
  return;
}
}
u8 HALBT_GetPGAntNum(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  return (pHalData->bt_coexist.BT_Ant_Num);
}
}
void HALBT_SetKey(struct rtw_adapter *padapter , u8 EntryNum )
{
  struct bt_30info *pBTinfo ;
  struct bt_asoc_entry *pBtAssocEntry ;
  u16 usConfig ;
  {
  usConfig = 0U;
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtAssocEntry = (struct bt_asoc_entry *)(& pBTinfo->BtAsocEntry) + (unsigned long )EntryNum;
  pBtAssocEntry->HwCAMIndex = (unsigned int )EntryNum + 12U;
  usConfig = 32784U;
  rtl8723a_cam_write(padapter, (int )pBtAssocEntry->HwCAMIndex, (int )usConfig, (u8 const *)(& pBtAssocEntry->BTRemoteMACAddr),
                     (u8 const *)(& pBtAssocEntry->PTK) + 32U);
  return;
}
}
void HALBT_RemoveKey(struct rtw_adapter *padapter , u8 EntryNum )
{
  struct bt_30info *pBTinfo ;
  struct bt_asoc_entry *pBtAssocEntry ;
  {
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
  pBtAssocEntry = (struct bt_asoc_entry *)(& pBTinfo->BtAsocEntry) + (unsigned long )EntryNum;
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].HwCAMIndex != 0U) {
    if ((unsigned int )pBtAssocEntry->HwCAMIndex > 11U && (unsigned int )pBtAssocEntry->HwCAMIndex <= 15U) {
      rtl8723a_cam_empty_entry(padapter, (int )pBtAssocEntry->HwCAMIndex);
    } else {
    }
    pBTinfo->BtAsocEntry[(int )EntryNum].HwCAMIndex = 0U;
  } else {
  }
  return;
}
}
void rtl8723a_BT_init_hal_vars(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  bool tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pHalData->bt_coexist.BluetoothCoexist = pHalData->EEPROMBluetoothCoexist;
  pHalData->bt_coexist.BT_Ant_Num = pHalData->EEPROMBluetoothAntNum;
  pHalData->bt_coexist.BT_CoexistType = pHalData->EEPROMBluetoothType;
  pHalData->bt_coexist.BT_Ant_isolation = pHalData->EEPROMBluetoothAntIsolation;
  pHalData->bt_coexist.bt_radiosharedtype = pHalData->EEPROMBluetoothRadioShared;
  if (GlobalDebugLevel23A > 6U) {
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
    tmp = rtl8723a_BT_coexist(padapter);
    printk("\016BT Coexistance = 0x%x\n", (int )tmp);
  } else {
  }
  tmp___0 = rtl8723a_BT_coexist(padapter);
  if ((int )tmp___0) {
    if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U) {
      BTDM_SetBtCoexCurrAntNum(padapter, 2);
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
        printk("\016BlueTooth BT_Ant_Num = Antx2\n");
      } else {
      }
    } else
    if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 1U) {
      BTDM_SetBtCoexCurrAntNum(padapter, 1);
      if (GlobalDebugLevel23A > 6U) {
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
        printk("\016BlueTooth BT_Ant_Num = Antx1\n");
      } else {
      }
    } else {
    }
    pHalData->bt_coexist.bBTBusyTraffic = 0U;
    pHalData->bt_coexist.bBTTrafficModeSet = 0U;
    pHalData->bt_coexist.bBTNonTrafficModeSet = 0U;
    pHalData->bt_coexist.CurrentState = 0ULL;
    pHalData->bt_coexist.PreviousState = 0ULL;
    if (GlobalDebugLevel23A > 6U) {
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
      printk("\016bt_radiosharedType = 0x%x\n", (int )pHalData->bt_coexist.bt_radiosharedtype);
    } else {
    }
  } else {
  }
  return;
}
}
bool rtl8723a_BT_coexist(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  if ((unsigned int )pHalData->bt_coexist.BluetoothCoexist != 0U) {
    return (1);
  } else {
    return (0);
  }
}
}
u8 HALBT_BTChipType(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  return (pHalData->bt_coexist.BT_CoexistType);
}
}
void rtl8723a_BT_init_hwconfig(struct rtw_adapter *padapter )
{
  {
  halbt_InitHwConfig8723A(padapter);
  rtl8723a_BT_do_coexist(padapter);
  return;
}
}
void HALBT_SetRtsCtsNoLenLimit(struct rtw_adapter *padapter )
{
  {
  return;
}
}
void rtl8723a_dual_antenna_detection(struct rtw_adapter *padapter )
{
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct sw_ant_sw *pDM_SWAT_Table ;
  u8 i ;
  u8 btAntNum ;
  u8 tmp ;
  bool tmp___0 ;
  {
  pHalData = (struct hal_data_8723a *)padapter->HalData;
  pDM_Odm = & pHalData->odmpriv;
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
  if ((unsigned int )pHalData->bAntennaDetected == 0U) {
    tmp = HALBT_GetPGAntNum(padapter);
    btAntNum = tmp;
    if ((unsigned int )btAntNum == 0U) {
      pDM_SWAT_Table->ANTB_ON = 1;
    } else
    if ((unsigned int )btAntNum == 1U) {
      pDM_SWAT_Table->ANTB_ON = 0;
    } else {
      pDM_SWAT_Table->ANTB_ON = 1;
    }
    if ((unsigned int )pHalData->CustomerID != 9U) {
      i = 0U;
      goto ldv_57064;
      ldv_57063:
      tmp___0 = ODM_SingleDualAntennaDetection(& pHalData->odmpriv, 0);
      if ((int )tmp___0) {
        goto ldv_57062;
      } else {
      }
      i = (u8 )((int )i + 1);
      ldv_57064: ;
      if ((unsigned int )i <= 9U) {
        goto ldv_57063;
      } else {
      }
      ldv_57062: ;
      if ((unsigned int )btAntNum == 0U) {
        BTDM_SetBtCoexCurrAntNum(padapter, (int )pDM_SWAT_Table->ANTB_ON ? 2 : 1);
      } else {
      }
    } else {
    }
    pHalData->bAntennaDetected = 1U;
  } else {
  }
  return;
}
}
void *ldv_kmem_cache_alloc_2404(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2410(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2412(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2414(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2415(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2416(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2417(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2418(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2419(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2420(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
int ldv_mod_timer_2421(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2422(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2423(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2424(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2425(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_2426(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2427(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_2428(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2429(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2430(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2431(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2432(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2433(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2434(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2435(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_2436(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 )
{
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;
  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_2437(struct timer_list *ldv_func_arg1 )
{
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;
  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) ;
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
void *ldv_kmem_cache_alloc_2480(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2488(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_clone_2496(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
struct sk_buff *ldv_skb_copy_2490(struct sk_buff const *ldv_func_arg1 , gfp_t flags ) ;
int ldv_pskb_expand_head_2486(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2494(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
int ldv_pskb_expand_head_2495(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2491(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2492(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
struct sk_buff *ldv___netdev_alloc_skb_2493(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
void update_sta_info23a_apmode23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
void rtw_set_macaddr_acl23a(struct rtw_adapter *padapter , int mode ) ;
int rtw_acl_add_sta23a(struct rtw_adapter *padapter , u8 *addr ) ;
int rtw_acl_remove_sta23a(struct rtw_adapter *padapter , u8 *addr ) ;
u8 bss_cap_update_on_sta_leave23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
int rtw_ap_inform_ch_switch23a(struct rtw_adapter *padapter , u8 new_ch , u8 ch_offset ) ;
void init_mlme_ap_info23a(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct lock_class_key __key ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  spinlock_check(& pmlmepriv->bcn_update_lock);
  __raw_spin_lock_init(& pmlmepriv->bcn_update_lock.ldv_6347.rlock, "&(&pmlmepriv->bcn_update_lock)->rlock",
                       & __key);
  _rtw_init_queue23a(& pacl_list->acl_node_q);
  start_ap_mode23a(padapter);
  return;
}
}
void free_mlme_ap_info23a(struct rtw_adapter *padapter )
{
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pmlmepriv->update_bcn = 0U;
  pmlmeext->bstart_bss = 0U;
  rtw_sta_flush23a(padapter);
  pmlmeinfo->state = 0U;
  rtw_free_all_stainfo23a(padapter);
  psta = rtw_get_bcmc_stainfo23a(padapter);
  spin_lock_bh(& pstapriv->sta_hash_lock);
  rtw_free_stainfo23a(padapter, psta);
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return;
}
}
static void update_BCNTIM(struct rtw_adapter *padapter )
{
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork_mlmeext ;
  unsigned char *pie ;
  u8 *p ;
  u8 *dst_ie ;
  u8 *premainder_ie ;
  u8 *pbackup_remainder_ie ;
  __le16 tim_bitmap_le ;
  uint offset ;
  uint tmp_len ;
  uint tim_ielen ;
  uint tim_ie_offset ;
  uint remainder_ielen ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  {
  pstapriv = & padapter->stapriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork_mlmeext = & pmlmeinfo->network;
  pie = (unsigned char *)(& pnetwork_mlmeext->IEs);
  premainder_ie = (u8 *)0U;
  pbackup_remainder_ie = (u8 *)0U;
  tim_bitmap_le = pstapriv->tim_bitmap;
  p = rtw_get_ie23a(pie + 12U, 5, (int *)(& tim_ielen), (int )(pnetwork_mlmeext->IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && tim_ielen != 0U) {
    tim_ielen = tim_ielen + 2U;
    premainder_ie = p + (unsigned long )tim_ielen;
    tim_ie_offset = (unsigned int )((long )p) - (unsigned int )((long )pie);
    remainder_ielen = (pnetwork_mlmeext->IELength - tim_ie_offset) - tim_ielen;
    dst_ie = p;
  } else {
    tim_ielen = 0U;
    offset = 12U;
    p = rtw_get_ie23a(pie + 12U, 0, (int *)(& tmp_len), (int )(pnetwork_mlmeext->IELength - 12U));
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
      offset = (tmp_len + offset) + 2U;
    } else {
    }
    p = rtw_get_ie23a(pie + 12U, 1, (int *)(& tmp_len), (int )(pnetwork_mlmeext->IELength - 12U));
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
      offset = (tmp_len + offset) + 2U;
    } else {
    }
    offset = offset + 3U;
    premainder_ie = pie + (unsigned long )offset;
    remainder_ielen = (pnetwork_mlmeext->IELength - offset) - tim_ielen;
    dst_ie = pie + (unsigned long )offset;
  }
  if (remainder_ielen != 0U) {
    tmp = kmalloc((size_t )remainder_ielen, 32U);
    pbackup_remainder_ie = (u8 *)tmp;
    if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U) && (unsigned long )premainder_ie != (unsigned long )((u8 *)0U)) {
      __len = (size_t )remainder_ielen;
      __ret = memcpy((void *)pbackup_remainder_ie, (void const *)premainder_ie,
                               __len);
    } else {
    }
  } else {
  }
  tmp___0 = dst_ie;
  dst_ie = dst_ie + 1;
  *tmp___0 = 5U;
  if (((int )pstapriv->tim_bitmap & 65280) != 0 && ((int )pstapriv->tim_bitmap & 252) != 0) {
    tim_ielen = 5U;
  } else {
    tim_ielen = 4U;
  }
  tmp___1 = dst_ie;
  dst_ie = dst_ie + 1;
  *tmp___1 = (u8 )tim_ielen;
  tmp___2 = dst_ie;
  dst_ie = dst_ie + 1;
  *tmp___2 = 0U;
  tmp___3 = dst_ie;
  dst_ie = dst_ie + 1;
  *tmp___3 = 1U;
  if ((int )pstapriv->tim_bitmap & 1) {
    tmp___4 = dst_ie;
    dst_ie = dst_ie + 1;
    *tmp___4 = 1U;
  } else {
    tmp___5 = dst_ie;
    dst_ie = dst_ie + 1;
    *tmp___5 = 0U;
  }
  if (tim_ielen == 4U) {
    tmp___6 = dst_ie;
    dst_ie = dst_ie + 1;
    *tmp___6 = *((u8 *)(& tim_bitmap_le));
  } else
  if (tim_ielen == 5U) {
    __len___0 = 2UL;
    if (__len___0 > 63UL) {
      __ret___0 = memcpy((void *)dst_ie, (void const *)(& tim_bitmap_le), __len___0);
    } else {
      __ret___0 = memcpy((void *)dst_ie, (void const *)(& tim_bitmap_le),
                                   __len___0);
    }
    dst_ie = dst_ie + 2UL;
  } else {
  }
  if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
    __len___1 = (size_t )remainder_ielen;
    __ret___1 = memcpy((void *)dst_ie, (void const *)pbackup_remainder_ie,
                                 __len___1);
    kfree((void const *)pbackup_remainder_ie);
  } else {
  }
  offset = (unsigned int )((long )dst_ie) - (unsigned int )((long )pie);
  pnetwork_mlmeext->IELength = offset + remainder_ielen;
  set_tx_beacon_cmd23a(padapter);
  return;
}
}
static u8 chk_sta_is_alive(struct sta_info *psta )
{
  u8 ret ;
  {
  ret = 0U;
  if (psta->sta_stats.last_rx_data_pkts + psta->sta_stats.last_rx_ctrl_pkts != psta->sta_stats.rx_data_pkts + psta->sta_stats.rx_ctrl_pkts) {
    ret = 1U;
  } else {
  }
  psta->sta_stats.last_rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts;
  psta->sta_stats.last_rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts;
  psta->sta_stats.last_rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts;
  psta->sta_stats.last_rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts;
  psta->sta_stats.last_rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts;
  psta->sta_stats.last_rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts;
  psta->sta_stats.last_rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts;
  psta->sta_stats.last_rx_data_pkts = psta->sta_stats.rx_data_pkts;
  return (ret);
}
}
void expire_timeout_chk23a(struct rtw_adapter *padapter )
{
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 updated ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head const *__mptr ;
  struct list_head const *__mptr___0 ;
  u8 tmp ;
  struct mlme_ext_priv *pmlmeext ;
  u32 tmp___0 ;
  u8 tmp___1 ;
  u8 backup_oper_channel ;
  struct mlme_ext_priv *pmlmeext___0 ;
  u8 tmp___2 ;
  int ret ;
  int tmp___3 ;
  {
  updated = 0U;
  pstapriv = & padapter->stapriv;
  chk_alive_num = 0U;
  spin_lock_bh(& pstapriv->auth_list_lock);
  phead = & pstapriv->auth_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_54265;
  ldv_54264:
  __mptr = (struct list_head const *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb80UL;
  if (psta->expire_to != 0U) {
    psta->expire_to = psta->expire_to - 1U;
    if (psta->expire_to == 0U) {
      list_del_init(& psta->auth_list);
      pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: auth expire %pM\n", (u8 *)(& psta->hwaddr));
      } else {
      }
      spin_unlock_bh(& pstapriv->auth_list_lock);
      spin_lock_bh(& pstapriv->sta_hash_lock);
      rtw_free_stainfo23a(padapter, psta);
      spin_unlock_bh(& pstapriv->sta_hash_lock);
      spin_lock_bh(& pstapriv->auth_list_lock);
    } else {
    }
  } else {
  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_54265: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54264;
  } else {
  }
  spin_unlock_bh(& pstapriv->auth_list_lock);
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_54273;
  ldv_54272:
  __mptr___0 = (struct list_head const *)plist;
  psta = (struct sta_info *)__mptr___0 + 0xffffffffffffeb90UL;
  tmp = chk_sta_is_alive(psta);
  if ((unsigned int )tmp != 0U || psta->expire_to == 0U) {
    psta->expire_to = pstapriv->expire_to;
    psta->keep_alive_trycnt = 0U;
  } else {
    psta->expire_to = psta->expire_to - 1U;
  }
  if (psta->expire_to == 0U) {
    pmlmeext = & padapter->mlmeextpriv;
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
      psta->expire_to = pstapriv->expire_to;
      goto ldv_54270;
    } else {
    }
    if ((psta->state & 4U) != 0U) {
      if ((psta->state & 1024U) == 0U) {
        psta->expire_to = pstapriv->expire_to;
        psta->state = psta->state | 1024U;
        tmp___0 = CHKBIT(psta->aid);
        pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap | (int )((u16 )tmp___0);
        update_beacon23a(padapter, 5, (u8 *)0U, 0);
        if ((unsigned int )pmlmeext->active_keep_alive_check == 0U) {
          goto ldv_54270;
        } else {
        }
      } else {
      }
    } else {
    }
    if ((unsigned int )pmlmeext->active_keep_alive_check != 0U) {
      tmp___1 = chk_alive_num;
      chk_alive_num = (u8 )((int )chk_alive_num + 1);
      chk_alive_list[(int )tmp___1] = psta;
      goto ldv_54270;
    } else {
    }
    list_del_init(& psta->asoc_list);
    pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: asoc expire %02x:%02x:%02x:%02x:%02x:%02x, state = 0x%x\n",
             (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
             (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
             (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
             psta->state);
    } else {
    }
    updated = ap_free_sta23a(padapter, psta, 0, 3);
  } else
  if (psta->sleepq_len > (unsigned int )(256 / (int )pstapriv->asoc_list_cnt) && padapter->xmitpriv.free_xmitframe_cnt < 128 / (int )pstapriv->asoc_list_cnt) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s sta:%02x:%02x:%02x:%02x:%02x:%02x, sleepq_len:%u, free_xmitframe_cnt:%u, asoc_list_cnt:%u, clear sleep_q\n",
             "expire_timeout_chk23a", (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
             (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
             (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
             psta->sleepq_len, padapter->xmitpriv.free_xmitframe_cnt, (int )pstapriv->asoc_list_cnt);
    } else {
    }
    wakeup_sta_to_xmit23a(padapter, psta);
  } else {
  }
  ldv_54270:
  plist = ptmp;
  ptmp = plist->next;
  ldv_54273: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54272;
  } else {
  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  if ((unsigned int )chk_alive_num != 0U) {
    backup_oper_channel = 0U;
    pmlmeext___0 = & padapter->mlmeextpriv;
    tmp___2 = rtw_get_oper_ch23a(padapter);
    if ((int )tmp___2 != (int )pmlmeext___0->cur_channel) {
      backup_oper_channel = rtw_get_oper_ch23a(padapter);
      SelectChannel23a(padapter, (int )pmlmeext___0->cur_channel);
    } else {
    }
    i = 0;
    goto ldv_54280;
    ldv_54279:
    ret = 0;
    psta = chk_alive_list[i];
    if ((psta->state & 1U) == 0U) {
      goto ldv_54278;
    } else {
    }
    if ((psta->state & 4U) != 0U) {
      ret = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 1,
                              50);
    } else {
      ret = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 3,
                              50);
    }
    psta->keep_alive_trycnt = (u8 )((int )psta->keep_alive_trycnt + 1);
    if (ret == 1) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: asoc check, sta(%02x:%02x:%02x:%02x:%02x:%02x) is alive\n",
               (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
               (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
               (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL));
      } else {
      }
      psta->expire_to = pstapriv->expire_to;
      psta->keep_alive_trycnt = 0U;
      goto ldv_54278;
    } else
    if ((unsigned int )psta->keep_alive_trycnt <= 3U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: ack check for asoc expire, keep_alive_trycnt =%d\n",
               (int )psta->keep_alive_trycnt);
      } else {
      }
      psta->expire_to = 1U;
      goto ldv_54278;
    } else {
    }
    psta->keep_alive_trycnt = 0U;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: asoc expire %02x:%02x:%02x:%02x:%02x:%02x, state = 0x%x\n",
             (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
             (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
             (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
             psta->state);
    } else {
    }
    spin_lock_bh(& pstapriv->asoc_list_lock);
    tmp___3 = list_empty((struct list_head const *)(& psta->asoc_list));
    if (tmp___3 == 0) {
      list_del_init(& psta->asoc_list);
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
      updated = ap_free_sta23a(padapter, psta, 0, 3);
    } else {
    }
    spin_unlock_bh(& pstapriv->asoc_list_lock);
    ldv_54278:
    i = i + 1;
    ldv_54280: ;
    if ((int )chk_alive_num > i) {
      goto ldv_54279;
    } else {
    }
    if ((unsigned int )backup_oper_channel != 0U) {
      SelectChannel23a(padapter, (int )backup_oper_channel);
    } else {
    }
  } else {
  }
  associated_clients_update23a(padapter, (int )updated);
  return;
}
}
void add_RATid23a(struct rtw_adapter *padapter , struct sta_info *psta , u8 rssi_level )
{
  int i ;
  u8 rf_type ;
  u32 init_rate ;
  unsigned char sta_band ;
  unsigned char raid ;
  unsigned char shortGIrate ;
  unsigned char limit ;
  unsigned int tx_ra_bitmap ;
  struct ht_priv *psta_ht ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_network ;
  int tmp ;
  unsigned char tmp___0 ;
  u8 arg ;
  {
  init_rate = 0U;
  sta_band = 0U;
  shortGIrate = 0U;
  tx_ra_bitmap = 0U;
  psta_ht = (struct ht_priv *)0;
  pmlmepriv = & padapter->mlmepriv;
  pcur_network = & pmlmepriv->cur_network.network;
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    psta_ht = & psta->htpriv;
  } else {
    return;
  }
  if ((psta->state & 1U) == 0U) {
    return;
  } else {
  }
  i = 0;
  goto ldv_54299;
  ldv_54298: ;
  if ((unsigned int )psta->bssrateset[i] != 0U) {
    tmp = rtw_get_bit_value_from_ieee_value23a((int )psta->bssrateset[i] & 127);
    tx_ra_bitmap = (unsigned int )tmp | tx_ra_bitmap;
  } else {
  }
  i = i + 1;
  ldv_54299: ;
  if ((unsigned int )i <= 15U) {
    goto ldv_54298;
  } else {
  }
  if (psta_ht->ht_option != 0U) {
    rf_type = rtl8723a_get_rf_type(padapter);
    if ((unsigned int )rf_type == 2U) {
      limit = 16U;
    } else {
      limit = 8U;
    }
    i = 0;
    goto ldv_54302;
    ldv_54301: ;
    if ((int )((unsigned long )psta_ht->ht_cap.mcs.rx_mask[i / 8] >> i % 8) & 1) {
      tx_ra_bitmap = (unsigned int )(1UL << (i + 12)) | tx_ra_bitmap;
    } else {
    }
    i = i + 1;
    ldv_54302: ;
    if ((int )limit > i) {
      goto ldv_54301;
    } else {
    }
    shortGIrate = psta_ht->sgi;
  } else {
  }
  if (pcur_network->DSConfig > 14U) {
    if ((tx_ra_bitmap & 268431360U) != 0U) {
      sta_band = (unsigned int )sta_band | 20U;
    } else {
      sta_band = (unsigned int )sta_band | 4U;
    }
  } else
  if ((tx_ra_bitmap & 268431360U) != 0U) {
    sta_band = (unsigned int )sta_band | 11U;
  } else
  if ((tx_ra_bitmap & 4080U) != 0U) {
    sta_band = (unsigned int )sta_band | 3U;
  } else {
    sta_band = (unsigned int )sta_band | 1U;
  }
  psta->wireless_mode = sta_band;
  raid = networktype_to_raid23a((int )sta_band);
  tmp___0 = get_highest_rate_idx23a(tx_ra_bitmap & 268435455U);
  init_rate = (u32 )tmp___0 & 63U;
  if (psta->aid <= 31U) {
    arg = 0U;
    arg = (unsigned int )((u8 )psta->mac_id) & 31U;
    arg = (u8 )((unsigned int )arg | 128U);
    if ((unsigned int )shortGIrate == 1U) {
      arg = (u8 )((unsigned int )arg | 32U);
    } else {
    }
    tx_ra_bitmap = (unsigned int )((int )raid << 28) | tx_ra_bitmap;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s => mac_id:%d , raid:%d , bitmap = 0x%x, arg = 0x%x\n",
             "add_RATid23a", psta->mac_id, (int )raid, tx_ra_bitmap, (int )arg);
    } else {
    }
    rtl8723a_add_rateatid(padapter, tx_ra_bitmap, (int )arg, (int )rssi_level);
    if ((unsigned int )shortGIrate == 1U) {
      init_rate = init_rate | 64U;
    } else {
    }
    psta->raid = raid;
    psta->init_rate = (u8 )init_rate;
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: station aid %d exceed the max number\n", psta->aid);
  } else {
  }
  return;
}
}
static void update_bmc_sta(struct rtw_adapter *padapter )
{
  u32 init_rate ;
  unsigned char network_type ;
  unsigned char raid ;
  int i ;
  int supportRateNum ;
  unsigned int tx_ra_bitmap ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_network ;
  struct sta_info *psta ;
  struct sta_info *tmp ;
  uint tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  int tmp___2 ;
  unsigned char tmp___3 ;
  u8 arg ;
  {
  init_rate = 0U;
  supportRateNum = 0;
  tx_ra_bitmap = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pcur_network = & pmlmepriv->cur_network.network;
  tmp = rtw_get_bcmc_stainfo23a(padapter);
  psta = tmp;
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
    psta->aid = 0U;
    psta->mac_id = psta->aid + 1U;
    psta->qos_option = 0U;
    psta->htpriv.ht_option = 0U;
    psta->ieee8021x_blocked = 0U;
    memset((void *)(& psta->sta_stats), 0, 168UL);
    tmp___0 = rtw_get_rateset_len23a((u8 *)(& pcur_network->SupportedRates));
    supportRateNum = (int )tmp___0;
    tmp___1 = rtw_check_network_type23a((unsigned char *)(& pcur_network->SupportedRates),
                                        supportRateNum, 1);
    network_type = (unsigned char )tmp___1;
    __len = (size_t )supportRateNum;
    __ret = memcpy((void *)(& psta->bssrateset), (void const *)(& pcur_network->SupportedRates),
                             __len);
    psta->bssratelen = (u32 )supportRateNum;
    i = 0;
    goto ldv_54322;
    ldv_54321: ;
    if ((unsigned int )psta->bssrateset[i] != 0U) {
      tmp___2 = rtw_get_bit_value_from_ieee_value23a((int )psta->bssrateset[i] & 127);
      tx_ra_bitmap = (unsigned int )tmp___2 | tx_ra_bitmap;
    } else {
    }
    i = i + 1;
    ldv_54322: ;
    if (i < supportRateNum) {
      goto ldv_54321;
    } else {
    }
    if (pcur_network->DSConfig > 14U) {
      network_type = 4U;
      tx_ra_bitmap = 336U;
    } else {
      network_type = 1U;
      tx_ra_bitmap = 15U;
    }
    raid = networktype_to_raid23a((int )network_type);
    tmp___3 = get_highest_rate_idx23a(tx_ra_bitmap & 268435455U);
    init_rate = (u32 )tmp___3 & 63U;
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
    arg = 0U;
    arg = (unsigned int )((u8 )psta->mac_id) & 31U;
    arg = (u8 )((unsigned int )arg | 128U);
    tx_ra_bitmap = (unsigned int )((int )raid << 28) | tx_ra_bitmap;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: update_bmc_sta, mask = 0x%x, arg = 0x%x\n", tx_ra_bitmap,
             (int )arg);
    } else {
    }
    rtl8723a_add_rateatid(padapter, tx_ra_bitmap, (int )arg, 0);
    psta->raid = raid;
    psta->init_rate = (u8 )init_rate;
    spin_lock_bh(& psta->lock);
    psta->state = 1U;
    spin_unlock_bh(& psta->lock);
  } else
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: add_RATid23a_bmc_sta error!\n");
  } else {
  }
  return;
}
}
void update_sta_info23a_apmode23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct ht_priv *phtpriv_ap ;
  struct ht_priv *phtpriv_sta ;
  {
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmeext = & padapter->mlmeextpriv;
  phtpriv_ap = & pmlmepriv->htpriv;
  phtpriv_sta = & psta->htpriv;
  psta->mac_id = psta->aid + 1U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_sta_info23a_apmode23a");
  } else {
  }
  rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
  if (psecuritypriv->dot11AuthAlgrthm == 2U) {
    psta->ieee8021x_blocked = 1U;
  } else {
    psta->ieee8021x_blocked = 0U;
  }
  VCS_update23a(padapter, psta);
  if (phtpriv_sta->ht_option != 0U) {
    phtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;
    if ((((int )phtpriv_sta->ht_cap.cap_info & (int )phtpriv_ap->ht_cap.cap_info) & 96) != 0) {
      phtpriv_sta->sgi = 1U;
    } else {
    }
    if ((((int )phtpriv_sta->ht_cap.cap_info & (int )phtpriv_ap->ht_cap.cap_info) & 2) != 0) {
      phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
      phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
    } else {
    }
    psta->qos_option = 1U;
  } else {
    phtpriv_sta->ampdu_enable = 0U;
    phtpriv_sta->sgi = 0U;
    phtpriv_sta->bwmode = 0U;
    phtpriv_sta->ch_offset = 0U;
  }
  send_delba23a(padapter, 0, (u8 *)(& psta->hwaddr));
  send_delba23a(padapter, 1, (u8 *)(& psta->hwaddr));
  phtpriv_sta->agg_enable_bitmap = 0U;
  phtpriv_sta->candidate_tid_bitmap = 0U;
  memset((void *)(& psta->sta_stats), 0, 168UL);
  spin_lock_bh(& psta->lock);
  psta->state = psta->state | 1U;
  spin_unlock_bh(& psta->lock);
  return;
}
}
static void update_hw_ht_param(struct rtw_adapter *padapter )
{
  unsigned char max_AMPDU_len ;
  unsigned char min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  {
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_hw_ht_param");
  } else {
  }
  max_AMPDU_len = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 3U;
  min_MPDU_spacing = (unsigned char )(((int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 28) >> 2);
  rtl8723a_set_ampdu_min_space(padapter, (int )min_MPDU_spacing);
  rtl8723a_set_ampdu_factor(padapter, (int )max_AMPDU_len);
  pmlmeinfo->SM_PS = (u8 )(((int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 12) >> 2);
  if ((unsigned int )pmlmeinfo->SM_PS == 0U) {
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: %s(): WLAN_HT_CAP_SM_PS_STATIC\n", "update_hw_ht_param");
    } else {
    }
  } else {
  }
  return;
}
}
static void start_bss_network(struct rtw_adapter *padapter , u8 *pbuf )
{
  u8 const *p ;
  u8 val8 ;
  u8 cur_channel ;
  u8 cur_bwmode ;
  u8 cur_ch_offset ;
  u16 bcn_interval ;
  u32 acparm ;
  struct registry_priv *pregpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct wlan_bssid_ex *pnetwork ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork_mlmeext ;
  struct HT_info_element *pht_info ;
  int bcn_fixed_size ;
  u8 *tmp ;
  u16 tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  {
  pregpriv = & padapter->registrypriv;
  pmlmepriv = & padapter->mlmepriv;
  psecuritypriv = & padapter->securitypriv;
  pnetwork = & pmlmepriv->cur_network.network;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork_mlmeext = & pmlmeinfo->network;
  pht_info = (struct HT_info_element *)0;
  bcn_interval = pnetwork->BeaconPeriod;
  cur_channel = (u8 )pnetwork->DSConfig;
  cur_bwmode = 0U;
  cur_ch_offset = 0U;
  tmp = rtw_get_wps_ie23a((u8 *)(& pnetwork->IEs) + 12UL, pnetwork->IELength - 12U,
                          (u8 *)0U, (uint *)0U);
  if ((unsigned long )tmp == (unsigned long )((u8 *)0U)) {
    pmlmeext->bstart_bss = 1U;
  } else {
  }
  if (pmlmepriv->qos_option != 0U) {
    pmlmeinfo->WMM_enable = 1U;
  } else {
  }
  if (pmlmepriv->htpriv.ht_option != 0U) {
    pmlmeinfo->WMM_enable = 1U;
    pmlmeinfo->HT_enable = 1U;
    update_hw_ht_param(padapter);
  } else {
  }
  if (pmlmepriv->cur_network.join_res != 1) {
    if (psecuritypriv->dot11PrivacyAlgrthm != 1027073U && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
      flush_all_cam_entry23a(padapter);
    } else {
    }
  } else {
  }
  Set_MSR23a(padapter, 3);
  hw_var_set_bssid(padapter, (u8 *)(& pnetwork->MacAddress));
  acparm = 3093015U;
  rtl8723a_set_ac_param_vo(padapter, acparm);
  acparm = 6177559U;
  rtl8723a_set_ac_param_vi(padapter, acparm);
  acparm = 6202411U;
  rtl8723a_set_ac_param_be(padapter, acparm);
  acparm = 42052U;
  rtl8723a_set_ac_param_bk(padapter, acparm);
  val8 = psecuritypriv->dot11AuthAlgrthm == 2U ? 204U : 207U;
  rtl8723a_set_sec_cfg(padapter, (int )val8);
  rtl8723a_set_beacon_interval(padapter, (int )bcn_interval);
  UpdateBrateTbl23a(padapter, (u8 *)(& pnetwork->SupportedRates));
  HalSetBrateCfg23a(padapter, (u8 *)(& pnetwork->SupportedRates));
  if (pmlmepriv->cur_network.join_res == 0) {
    rtl8723a_odm_support_ability_set(padapter, 268435455U);
  } else {
  }
  bcn_fixed_size = 12;
  p = cfg80211_find_ie(61, (u8 const *)(& pnetwork->IEs) + (unsigned long )bcn_fixed_size,
                       (int )(pnetwork->IELength - (u32 )bcn_fixed_size));
  if ((unsigned long )p != (unsigned long )((u8 const *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
    pht_info = (struct HT_info_element *)p + 2U;
    if ((unsigned int )pregpriv->cbw40_enable != 0U && ((unsigned long )pht_info->infos[0] & 4UL) != 0UL) {
      cur_bwmode = 1U;
      switch ((int )pht_info->infos[0] & 3) {
      case 1:
      cur_ch_offset = 1U;
      goto ldv_54364;
      case 3:
      cur_ch_offset = 2U;
      goto ldv_54364;
      default:
      cur_ch_offset = 0U;
      goto ldv_54364;
      }
      ldv_54364: ;
    } else {
    }
  } else {
  }
  set_channel_bwmode23a(padapter, (int )cur_channel, (int )cur_ch_offset, (int )cur_bwmode);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: CH =%d, BW =%d, offset =%d\n", (int )cur_channel, (int )cur_bwmode,
           (int )cur_ch_offset);
  } else {
  }
  pmlmeext->cur_channel = cur_channel;
  pmlmeext->cur_bwmode = cur_bwmode;
  pmlmeext->cur_ch_offset = cur_ch_offset;
  pmlmeext->cur_wireless_mode = (unsigned char )pmlmepriv->cur_network.network_type;
  update_wireless_mode23a(padapter);
  tmp___0 = rtw_get_capability23a(pnetwork);
  update_capinfo23a(padapter, (int )tmp___0);
  __len = (size_t )pnetwork->Length;
  __ret = memcpy((void *)pnetwork_mlmeext, (void const *)pnetwork, __len);
  if ((unsigned int )pmlmeext->bstart_bss != 0U) {
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
    tmp___1 = send_beacon23a(padapter);
    if (tmp___1 == 0) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: issue_beacon23a, fail!\n");
      } else {
      }
    } else {
    }
  } else {
  }
  update_bmc_sta(padapter);
  return;
}
}
int rtw_check_beacon_data23a(struct rtw_adapter *padapter , u8 *pbuf , unsigned int len )
{
  int ret ;
  u8 *p ;
  u8 *pHT_caps_ie ;
  u8 *pHT_info_ie ;
  struct sta_info *psta ;
  __le16 *pbeacon ;
  u16 cap ;
  u16 ht_cap ;
  uint ie_len ;
  int group_cipher ;
  int pairwise_cipher ;
  u8 channel ;
  u8 network_type ;
  u8 supportRate[16U] ;
  int supportRateNum ;
  u8 WMM_PARA_IE[6U] ;
  struct registry_priv *pregistrypriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pbss_network ;
  u8 *ie ;
  bool tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  u8 rf_type ;
  struct ieee80211_ht_cap *pht_cap ;
  size_t __len___4 ;
  void *__ret___4 ;
  {
  ret = 1;
  pHT_caps_ie = (u8 *)0U;
  pHT_info_ie = (u8 *)0U;
  psta = (struct sta_info *)0;
  ht_cap = 0U;
  ie_len = 0U;
  supportRateNum = 0;
  WMM_PARA_IE[0] = 0U;
  WMM_PARA_IE[1] = 80U;
  WMM_PARA_IE[2] = 242U;
  WMM_PARA_IE[3] = 2U;
  WMM_PARA_IE[4] = 1U;
  WMM_PARA_IE[5] = 1U;
  pregistrypriv = & padapter->registrypriv;
  psecuritypriv = & padapter->securitypriv;
  pmlmepriv = & padapter->mlmepriv;
  pbss_network = & pmlmepriv->cur_network.network;
  ie = (u8 *)(& pbss_network->IEs);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, len =%d\n", "rtw_check_beacon_data23a", len);
  } else {
  }
  tmp = check_fwstate(pmlmepriv, 16);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    return (0);
  } else {
  }
  if (len > 768U) {
    return (0);
  } else {
  }
  pbss_network->IELength = len;
  memset((void *)ie, 0, 768UL);
  __len = (size_t )pbss_network->IELength;
  __ret = memcpy((void *)ie, (void const *)pbuf, __len);
  if ((unsigned int )pbss_network->ifmode != 3U && (unsigned int )pbss_network->ifmode != 9U) {
    return (0);
  } else {
  }
  pbss_network->Rssi = 0L;
  __len___0 = 6UL;
  if (__len___0 > 63UL) {
    tmp___1 = myid(& padapter->eeprompriv);
    __ret___0 = memcpy((void *)(& pbss_network->MacAddress), (void const *)tmp___1,
                         __len___0);
  } else {
    tmp___2 = myid(& padapter->eeprompriv);
    __ret___0 = memcpy((void *)(& pbss_network->MacAddress), (void const *)tmp___2,
                                 __len___0);
  }
  pbeacon = rtw_get_beacon_interval23a_from_ie(ie);
  pbss_network->BeaconPeriod = get_unaligned_le16((void const *)pbeacon);
  cap = get_unaligned_le16((void const *)ie);
  p = rtw_get_ie23a(ie + 12UL, 0, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    memset((void *)(& pbss_network->Ssid), 0, 33UL);
    __len___1 = (size_t )ie_len;
    __ret___1 = memcpy((void *)(& pbss_network->Ssid.ssid), (void const *)p + 2U,
                                 __len___1);
    pbss_network->Ssid.ssid_len = (u8 )ie_len;
  } else {
  }
  channel = 0U;
  p = rtw_get_ie23a(ie + 12UL, 3, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    channel = *(p + 2UL);
  } else {
  }
  pbss_network->DSConfig = (u32 )channel;
  memset((void *)(& supportRate), 0, 16UL);
  p = rtw_get_ie23a(ie + 12UL, 1, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
    __len___2 = (size_t )ie_len;
    __ret___2 = memcpy((void *)(& supportRate), (void const *)p + 2U,
                                 __len___2);
    supportRateNum = (int )ie_len;
  } else {
  }
  p = rtw_get_ie23a(ie + 12UL, 50, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
    __len___3 = (size_t )ie_len;
    __ret___3 = memcpy((void *)(& supportRate) + (unsigned long )supportRateNum,
                                 (void const *)p + 2U, __len___3);
    supportRateNum = (int )((uint )supportRateNum + ie_len);
  } else {
  }
  tmp___3 = rtw_check_network_type23a((unsigned char *)(& supportRate), supportRateNum,
                                      (int )channel);
  network_type = (u8 )tmp___3;
  rtw_set_supported_rate23a((u8 *)(& pbss_network->SupportedRates), (uint )network_type);
  p = rtw_get_ie23a(ie + 12UL, 42, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    ERP_IE_handler23a(padapter, p);
  } else {
  }
  if (((unsigned long )cap & 16UL) != 0UL) {
    pbss_network->Privacy = 1U;
  } else {
    pbss_network->Privacy = 0U;
  }
  psecuritypriv->wpa_psk = 0U;
  group_cipher = 0;
  pairwise_cipher = 0;
  psecuritypriv->wpa2_group_cipher = 0U;
  psecuritypriv->wpa2_pairwise_cipher = 0U;
  p = rtw_get_ie23a(ie + 12UL, 48, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    tmp___4 = rtw_parse_wpa2_ie23a((u8 const *)p, (int )(ie_len + 2U), & group_cipher,
                                   & pairwise_cipher, (int *)0);
    if (tmp___4 == 1) {
      psecuritypriv->dot11AuthAlgrthm = 2U;
      psecuritypriv->dot8021xalg = 1U;
      psecuritypriv->wpa_psk = psecuritypriv->wpa_psk | 2U;
      psecuritypriv->wpa2_group_cipher = (unsigned int )group_cipher;
      psecuritypriv->wpa2_pairwise_cipher = (unsigned int )pairwise_cipher;
    } else {
    }
  } else {
  }
  ie_len = 0U;
  group_cipher = 0;
  pairwise_cipher = 0;
  psecuritypriv->wpa_group_cipher = 0U;
  psecuritypriv->wpa_pairwise_cipher = 0U;
  p = ie + 12UL;
  ldv_54413:
  p = rtw_get_ie23a(p, 221, (int *)(& ie_len), (int )((pbss_network->IELength - ie_len) - 14U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
    tmp___6 = memcmp((void const *)p + 2U, (void const *)(& RTW_WPA_OUI23A_TYPE),
                     4UL);
    if (tmp___6 == 0) {
      tmp___5 = rtw_parse_wpa_ie23a((u8 const *)p, (int )(ie_len + 2U), & group_cipher,
                                    & pairwise_cipher, (int *)0);
      if (tmp___5 == 1) {
        psecuritypriv->dot11AuthAlgrthm = 2U;
        psecuritypriv->dot8021xalg = 1U;
        psecuritypriv->wpa_psk = psecuritypriv->wpa_psk | 1U;
        psecuritypriv->wpa_group_cipher = (unsigned int )group_cipher;
        psecuritypriv->wpa_pairwise_cipher = (unsigned int )pairwise_cipher;
      } else {
      }
      goto ldv_54412;
    } else {
    }
  } else {
  }
  if ((unsigned long )p == (unsigned long )((u8 *)0U) || ie_len == 0U) {
    goto ldv_54412;
  } else {
  }
  p = p + (unsigned long )(ie_len + 2U);
  goto ldv_54413;
  ldv_54412:
  ie_len = 0U;
  pmlmepriv->qos_option = 0U;
  if ((unsigned int )pregistrypriv->wmm_enable != 0U) {
    p = ie + 12UL;
    ldv_54415:
    p = rtw_get_ie23a(p, 221, (int *)(& ie_len), (int )((pbss_network->IELength - ie_len) - 14U));
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
      tmp___7 = memcmp((void const *)p + 2U, (void const *)(& WMM_PARA_IE), 6UL);
      if (tmp___7 == 0) {
        pmlmepriv->qos_option = 1U;
        *(p + 8UL) = (u8 )((unsigned int )*(p + 8UL) | 128U);
        *(p + 10UL) = (unsigned int )*(p + 10UL) & 239U;
        *(p + 14UL) = (unsigned int )*(p + 14UL) & 239U;
        *(p + 18UL) = (unsigned int )*(p + 18UL) & 239U;
        *(p + 22UL) = (unsigned int )*(p + 22UL) & 239U;
        goto ldv_54414;
      } else {
      }
    } else {
    }
    if ((unsigned long )p == (unsigned long )((u8 *)0U) || ie_len == 0U) {
      goto ldv_54414;
    } else {
    }
    p = p + (unsigned long )(ie_len + 2U);
    goto ldv_54415;
    ldv_54414: ;
  } else {
  }
  p = rtw_get_ie23a(ie + 12UL, 45, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    pht_cap = (struct ieee80211_ht_cap *)p + 2U;
    pHT_caps_ie = p;
    ht_cap = 1U;
    network_type = (u8 )((unsigned int )network_type | 8U);
    rf_type = rtl8723a_get_rf_type(padapter);
    if (((unsigned long )psecuritypriv->wpa_pairwise_cipher & 16UL) != 0UL || ((unsigned long )psecuritypriv->wpa2_pairwise_cipher & 16UL) != 0UL) {
      pht_cap->ampdu_params_info = (u8 )((unsigned int )pht_cap->ampdu_params_info | 28U);
    } else {
      pht_cap->ampdu_params_info = pht_cap->ampdu_params_info;
    }
    pht_cap->ampdu_params_info = (u8 )((unsigned int )pht_cap->ampdu_params_info | 3U);
    if ((unsigned int )rf_type == 3U) {
      pht_cap->mcs.rx_mask[0] = 255U;
      pht_cap->mcs.rx_mask[1] = 0U;
    } else {
    }
    __len___4 = (size_t )ie_len;
    __ret___4 = memcpy((void *)(& pmlmepriv->htpriv.ht_cap), (void const *)p + 2U,
                                 __len___4);
  } else {
  }
  p = rtw_get_ie23a(ie + 12UL, 61, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
    pHT_info_ie = p;
  } else {
  }
  pmlmepriv->cur_network.network_type = (int )network_type;
  pmlmepriv->htpriv.ht_option = 0U;
  if ((unsigned int )pregistrypriv->ht_enable != 0U && (unsigned int )ht_cap != 0U) {
    pmlmepriv->htpriv.ht_option = 1U;
    pmlmepriv->qos_option = 1U;
    if ((unsigned int )pregistrypriv->ampdu_enable == 1U) {
      pmlmepriv->htpriv.ampdu_enable = 1U;
    } else {
    }
    HT_caps_handler23a(padapter, pHT_caps_ie);
    HT_info_handler23a(padapter, pHT_info_ie);
  } else {
  }
  pbss_network->Length = get_wlan_bssid_ex_sz(pbss_network);
  start_bss_network(padapter, (u8 *)pbss_network);
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const *)(& pbss_network->MacAddress));
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    psta = rtw_alloc_stainfo23a(& padapter->stapriv, (u8 *)(& pbss_network->MacAddress),
                                208U);
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
      return (0);
    } else {
    }
  } else {
  }
  psta->state = psta->state | 16U;
  rtw_indicate_connect23a(padapter);
  pmlmepriv->cur_network.join_res = 1;
  return (ret);
}
}
void rtw_set_macaddr_acl23a(struct rtw_adapter *padapter , int mode )
{
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  {
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, mode =%d\n", "rtw_set_macaddr_acl23a", mode);
  } else {
  }
  pacl_list->mode = mode;
  return;
}
}
int rtw_acl_add_sta23a(struct rtw_adapter *padapter , u8 *addr )
{
  struct list_head *plist ;
  struct list_head *phead ;
  u8 added ;
  int i ;
  int ret ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head const *__mptr ;
  int tmp ;
  size_t __len ;
  void *__ret ;
  struct list_head *tmp___0 ;
  {
  added = 0U;
  ret = 0;
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  pacl_node_q = & pacl_list->acl_node_q;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(acl_num =%d) =%02x:%02x:%02x:%02x:%02x:%02x\n", "rtw_acl_add_sta23a",
           pacl_list->num, (int )*addr, (int )*(addr + 1UL), (int )*(addr + 2UL),
           (int )*(addr + 3UL), (int )*(addr + 4UL), (int )*(addr + 5UL));
  } else {
  }
  if (pacl_list->num > 15) {
    return (-1);
  } else {
  }
  spin_lock_bh(& pacl_node_q->lock);
  phead = get_list_head(pacl_node_q);
  plist = phead->next;
  goto ldv_54446;
  ldv_54445:
  __mptr = (struct list_head const *)plist;
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
  tmp = memcmp((void const *)(& paclnode->addr), (void const *)addr, 6UL);
  if (tmp == 0) {
    if ((unsigned int )paclnode->valid == 1U) {
      added = 1U;
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s, sta has been added\n", "rtw_acl_add_sta23a");
      } else {
      }
      goto ldv_54444;
    } else {
    }
  } else {
  }
  plist = plist->next;
  ldv_54446: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54445;
  } else {
  }
  ldv_54444:
  spin_unlock_bh(& pacl_node_q->lock);
  if ((unsigned int )added != 0U) {
    return (ret);
  } else {
  }
  spin_lock_bh(& pacl_node_q->lock);
  i = 0;
  goto ldv_54452;
  ldv_54451:
  paclnode = (struct rtw_wlan_acl_node *)(& pacl_list->aclnode) + (unsigned long )i;
  if ((unsigned int )paclnode->valid == 0U) {
    INIT_LIST_HEAD(& paclnode->list);
    __len = 6UL;
    if (__len > 63UL) {
      __ret = memcpy((void *)(& paclnode->addr), (void const *)addr, __len);
    } else {
      __ret = memcpy((void *)(& paclnode->addr), (void const *)addr, __len);
    }
    paclnode->valid = 1U;
    tmp___0 = get_list_head(pacl_node_q);
    list_add_tail(& paclnode->list, tmp___0);
    pacl_list->num = pacl_list->num + 1;
    goto ldv_54450;
  } else {
  }
  i = i + 1;
  ldv_54452: ;
  if (i <= 15) {
    goto ldv_54451;
  } else {
  }
  ldv_54450: ;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, acl_num =%d\n", "rtw_acl_add_sta23a", pacl_list->num);
  } else {
  }
  spin_unlock_bh(& pacl_node_q->lock);
  return (ret);
}
}
int rtw_acl_remove_sta23a(struct rtw_adapter *padapter , u8 *addr )
{
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  int ret ;
  struct list_head const *__mptr ;
  int tmp ;
  {
  pstapriv = & padapter->stapriv;
  pacl_list = & pstapriv->acl_list;
  pacl_node_q = & pacl_list->acl_node_q;
  ret = 0;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(acl_num =%d) = %pM\n", "rtw_acl_remove_sta23a", pacl_list->num,
           addr);
  } else {
  }
  spin_lock_bh(& pacl_node_q->lock);
  phead = get_list_head(pacl_node_q);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_54469;
  ldv_54468:
  __mptr = (struct list_head const *)plist;
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
  tmp = memcmp((void const *)(& paclnode->addr), (void const *)addr, 6UL);
  if (tmp == 0) {
    if ((unsigned int )paclnode->valid != 0U) {
      paclnode->valid = 0U;
      list_del_init(& paclnode->list);
      pacl_list->num = pacl_list->num - 1;
    } else {
    }
  } else {
  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_54469: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54468;
  } else {
  }
  spin_unlock_bh(& pacl_node_q->lock);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, acl_num =%d\n", "rtw_acl_remove_sta23a", pacl_list->num);
  } else {
  }
  return (ret);
}
}
static void update_bcn_fixed_ie(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_fixed_ie");
  } else {
  }
  return;
}
}
static void update_bcn_erpinfo_ie(struct rtw_adapter *padapter )
{
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  unsigned char *p ;
  unsigned char *ie ;
  u32 len ;
  u8 *tmp ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  ie = (unsigned char *)(& pnetwork->IEs);
  len = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, ERP_enable =%d\n", "update_bcn_erpinfo_ie", (int )pmlmeinfo->ERP_enable);
  } else {
  }
  if ((unsigned int )pmlmeinfo->ERP_enable == 0U) {
    return;
  } else {
  }
  tmp = rtw_get_ie23a(ie + 12U, 42, (int *)(& len), (int )(pnetwork->IELength - 12U));
  p = tmp;
  if ((unsigned long )p != (unsigned long )((unsigned char *)0U) && len != 0U) {
    if (pmlmepriv->num_sta_non_erp == 1) {
      *(p + 2UL) = (unsigned int )*(p + 2UL) | 3U;
    } else {
      *(p + 2UL) = (unsigned int )*(p + 2UL) & 252U;
    }
    if (pmlmepriv->num_sta_no_short_preamble > 0) {
      *(p + 2UL) = (unsigned int )*(p + 2UL) | 4U;
    } else {
      *(p + 2UL) = (unsigned int )*(p + 2UL) & 251U;
    }
    ERP_IE_handler23a(padapter, p);
  } else {
  }
  return;
}
}
static void update_bcn_htcap_ie(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_htcap_ie");
  } else {
  }
  return;
}
}
static void update_bcn_htinfo_ie(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_htinfo_ie");
  } else {
  }
  return;
}
}
static void update_bcn_rsn_ie(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_rsn_ie");
  } else {
  }
  return;
}
}
static void update_bcn_wpa_ie(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_wpa_ie");
  } else {
  }
  return;
}
}
static void update_bcn_wmm_ie(struct rtw_adapter *padapter )
{
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_wmm_ie");
  } else {
  }
  return;
}
}
static void update_bcn_wps_ie(struct rtw_adapter *padapter )
{
  u8 *pwps_ie ;
  u8 *pwps_ie_src ;
  u8 *premainder_ie ;
  u8 *pbackup_remainder_ie ;
  uint wps_ielen ;
  uint wps_offset ;
  uint remainder_ielen ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  unsigned char *ie ;
  u32 ielen ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  {
  pwps_ie = (u8 *)0U;
  pbackup_remainder_ie = (u8 *)0U;
  wps_ielen = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  pnetwork = & pmlmeinfo->network;
  ie = (unsigned char *)(& pnetwork->IEs);
  ielen = pnetwork->IELength;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_wps_ie");
  } else {
  }
  pwps_ie_src = pmlmepriv->wps_beacon_ie;
  if ((unsigned long )pwps_ie_src == (unsigned long )((u8 *)0U)) {
    return;
  } else {
  }
  pwps_ie = rtw_get_wps_ie23a(ie + 12U, ielen - 12U, (u8 *)0U, & wps_ielen);
  if ((unsigned long )pwps_ie == (unsigned long )((u8 *)0U) || wps_ielen == 0U) {
    return;
  } else {
  }
  wps_offset = (unsigned int )((long )pwps_ie) - (unsigned int )((long )ie);
  premainder_ie = pwps_ie + (unsigned long )wps_ielen;
  remainder_ielen = (ielen - wps_offset) - wps_ielen;
  if (remainder_ielen != 0U) {
    tmp = kmalloc((size_t )remainder_ielen, 32U);
    pbackup_remainder_ie = (u8 *)tmp;
    if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
      __len = (size_t )remainder_ielen;
      __ret = memcpy((void *)pbackup_remainder_ie, (void const *)premainder_ie,
                               __len);
    } else {
    }
  } else {
  }
  wps_ielen = (unsigned int )*(pwps_ie_src + 1UL);
  if (((wps_offset + wps_ielen) + remainder_ielen) + 2U <= 768U) {
    __len___0 = (size_t )(wps_ielen + 2U);
    __ret___0 = memcpy((void *)pwps_ie, (void const *)pwps_ie_src, __len___0);
    pwps_ie = pwps_ie + (unsigned long )(wps_ielen + 2U);
    if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
      __len___1 = (size_t )remainder_ielen;
      __ret___1 = memcpy((void *)pwps_ie, (void const *)pbackup_remainder_ie,
                                   __len___1);
    } else {
    }
    pnetwork->IELength = ((wps_ielen + wps_offset) + remainder_ielen) + 2U;
  } else {
  }
  if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
    kfree((void const *)pbackup_remainder_ie);
  } else {
  }
  return;
}
}
static void update_bcn_p2p_ie(struct rtw_adapter *padapter )
{
  {
  return;
}
}
static void update_bcn_vendor_spec_ie(struct rtw_adapter *padapter , u8 *oui )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  {
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s\n", "update_bcn_vendor_spec_ie");
  } else {
  }
  tmp___2 = memcmp((void const *)(& RTW_WPA_OUI23A_TYPE), (void const *)oui, 4UL);
  if (tmp___2 == 0) {
    update_bcn_wpa_ie(padapter);
  } else {
    tmp___1 = memcmp((void const *)(& WMM_OUI23A), (void const *)oui, 4UL);
    if (tmp___1 == 0) {
      update_bcn_wmm_ie(padapter);
    } else {
      tmp___0 = memcmp((void const *)(& WPS_OUI23A), (void const *)oui, 4UL);
      if (tmp___0 == 0) {
        update_bcn_wps_ie(padapter);
      } else {
        tmp = memcmp((void const *)(& P2P_OUI23A), (void const *)oui, 4UL);
        if (tmp == 0) {
          update_bcn_p2p_ie(padapter);
        } else
        if (GlobalDebugLevel23A > 3U) {
          printk("\016RTL8723AU: unknown OUI type!\n");
        } else {
        }
      }
    }
  }
  return;
}
}
void update_beacon23a(struct rtw_adapter *padapter , u8 ie_id , u8 *oui , u8 tx )
{
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  {
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
    return;
  } else {
  }
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned int )pmlmeext->bstart_bss == 0U) {
    return;
  } else {
  }
  spin_lock_bh(& pmlmepriv->bcn_update_lock);
  switch ((int )ie_id) {
  case 255:
  update_bcn_fixed_ie(padapter);
  goto ldv_54549;
  case 5:
  update_BCNTIM(padapter);
  goto ldv_54549;
  case 42:
  update_bcn_erpinfo_ie(padapter);
  goto ldv_54549;
  case 45:
  update_bcn_htcap_ie(padapter);
  goto ldv_54549;
  case 48:
  update_bcn_rsn_ie(padapter);
  goto ldv_54549;
  case 61:
  update_bcn_htinfo_ie(padapter);
  goto ldv_54549;
  case 221:
  update_bcn_vendor_spec_ie(padapter, oui);
  goto ldv_54549;
  default: ;
  goto ldv_54549;
  }
  ldv_54549:
  pmlmepriv->update_bcn = 1U;
  spin_unlock_bh(& pmlmepriv->bcn_update_lock);
  if ((unsigned int )tx != 0U) {
    set_tx_beacon_cmd23a(padapter);
  } else {
  }
  return;
}
}
static int rtw_ht_operation_update(struct rtw_adapter *padapter )
{
  u16 cur_op_mode ;
  u16 new_op_mode ;
  int op_mode_changes ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv_ap ;
  {
  op_mode_changes = 0;
  pmlmepriv = & padapter->mlmepriv;
  phtpriv_ap = & pmlmepriv->htpriv;
  if (pmlmepriv->htpriv.ht_option == 1U) {
    return (0);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s current operation mode = 0x%X\n", "rtw_ht_operation_update",
           (int )pmlmepriv->ht_op_mode);
  } else {
  }
  if (((int )pmlmepriv->ht_op_mode & 4) == 0 && pmlmepriv->num_sta_ht_no_gf != 0) {
    pmlmepriv->ht_op_mode = (u16 )((unsigned int )pmlmepriv->ht_op_mode | 4U);
    op_mode_changes = op_mode_changes + 1;
  } else
  if (((int )pmlmepriv->ht_op_mode & 4) != 0 && pmlmepriv->num_sta_ht_no_gf == 0) {
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65531U;
    op_mode_changes = op_mode_changes + 1;
  } else {
  }
  if (((int )pmlmepriv->ht_op_mode & 16) == 0 && (pmlmepriv->num_sta_no_ht != 0 || pmlmepriv->olbc_ht != 0)) {
    pmlmepriv->ht_op_mode = (u16 )((unsigned int )pmlmepriv->ht_op_mode | 16U);
    op_mode_changes = op_mode_changes + 1;
  } else
  if (((int )pmlmepriv->ht_op_mode & 16) != 0 && (pmlmepriv->num_sta_no_ht == 0 && pmlmepriv->olbc_ht == 0)) {
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65519U;
    op_mode_changes = op_mode_changes + 1;
  } else {
  }
  if (pmlmepriv->num_sta_no_ht != 0 || ((int )pmlmepriv->ht_op_mode & 4) != 0) {
    new_op_mode = 3U;
  } else
  if (((int )phtpriv_ap->ht_cap.cap_info & 2) != 0 && pmlmepriv->num_sta_ht_20mhz != 0) {
    new_op_mode = 2U;
  } else
  if (pmlmepriv->olbc_ht != 0) {
    new_op_mode = 1U;
  } else {
    new_op_mode = 0U;
  }
  cur_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 3U;
  if ((int )cur_op_mode != (int )new_op_mode) {
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65532U;
    pmlmepriv->ht_op_mode = (u16 )((int )pmlmepriv->ht_op_mode | (int )new_op_mode);
    op_mode_changes = op_mode_changes + 1;
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s new operation mode = 0x%X changes =%d\n", "rtw_ht_operation_update",
           (int )pmlmepriv->ht_op_mode, op_mode_changes);
  } else {
  }
  return (op_mode_changes);
}
}
void associated_clients_update23a(struct rtw_adapter *padapter , u8 updated )
{
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct list_head const *__mptr ;
  {
  if ((unsigned int )updated == 1U) {
    pstapriv = & padapter->stapriv;
    spin_lock_bh(& pstapriv->asoc_list_lock);
    phead = & pstapriv->asoc_list;
    plist = phead->next;
    ptmp = plist->next;
    goto ldv_54578;
    ldv_54577:
    __mptr = (struct list_head const *)plist;
    psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
    VCS_update23a(padapter, psta);
    plist = ptmp;
    ptmp = plist->next;
    ldv_54578: ;
    if ((unsigned long )plist != (unsigned long )phead) {
      goto ldv_54577;
    } else {
    }
    spin_unlock_bh(& pstapriv->asoc_list_lock);
  } else {
  }
  return;
}
}
void bss_cap_update_on_sta_join23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  u8 beacon_updated ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  u16 ht_capab ;
  int tmp ;
  {
  beacon_updated = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  if (((unsigned long )psta->flags & 128UL) == 0UL) {
    if ((unsigned int )psta->no_short_preamble_set == 0U) {
      psta->no_short_preamble_set = 1U;
      pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble + 1;
      if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 1) {
        beacon_updated = 1U;
        update_beacon23a(padapter, 255, (u8 *)0U, 1);
      } else {
      }
    } else {
    }
  } else
  if ((unsigned int )psta->no_short_preamble_set != 0U) {
    psta->no_short_preamble_set = 0U;
    pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble - 1;
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {
    }
  } else {
  }
  if (psta->flags < 0) {
    if ((unsigned int )psta->nonerp_set == 0U) {
      psta->nonerp_set = 1U;
      pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp + 1;
      if (pmlmepriv->num_sta_non_erp == 1) {
        beacon_updated = 1U;
        update_beacon23a(padapter, 42, (u8 *)0U, 1);
      } else {
      }
    } else {
    }
  } else
  if ((unsigned int )psta->nonerp_set != 0U) {
    psta->nonerp_set = 0U;
    pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp - 1;
    if (pmlmepriv->num_sta_non_erp == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 42, (u8 *)0U, 1);
    } else {
    }
  } else {
  }
  if (((int )psta->capability & 1024) == 0) {
    if ((unsigned int )psta->no_short_slot_time_set == 0U) {
      psta->no_short_slot_time_set = 1U;
      pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time + 1;
      if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 1) {
        beacon_updated = 1U;
        update_beacon23a(padapter, 255, (u8 *)0U, 1);
      } else {
      }
    } else {
    }
  } else
  if ((unsigned int )psta->no_short_slot_time_set != 0U) {
    psta->no_short_slot_time_set = 0U;
    pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time - 1;
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {
    }
  } else {
  }
  if (((unsigned long )psta->flags & 2048UL) != 0UL) {
    ht_capab = psta->htpriv.ht_cap.cap_info;
    if (GlobalDebugLevel23A > 3U) {
      printk("\016RTL8723AU: HT: STA %02x:%02x:%02x:%02x:%02x:%02x HT Capabilities Info: 0x%04x\n",
             (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
             (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
             (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
             (int )ht_capab);
    } else {
    }
    if ((unsigned int )psta->no_ht_set != 0U) {
      psta->no_ht_set = 0U;
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht - 1;
    } else {
    }
    if (((int )ht_capab & 16) == 0) {
      if ((unsigned int )psta->no_ht_gf_set == 0U) {
        psta->no_ht_gf_set = 1U;
        pmlmepriv->num_sta_ht_no_gf = pmlmepriv->num_sta_ht_no_gf + 1;
      } else {
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s STA %02x:%02x:%02x:%02x:%02x:%02x - no greenfield, num of non-gf stations %d\n",
               "bss_cap_update_on_sta_join23a", (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
               (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
               (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
               pmlmepriv->num_sta_ht_no_gf);
      } else {
      }
    } else {
    }
    if (((int )ht_capab & 2) == 0) {
      if ((unsigned int )psta->ht_20mhz_set == 0U) {
        psta->ht_20mhz_set = 1U;
        pmlmepriv->num_sta_ht_20mhz = pmlmepriv->num_sta_ht_20mhz + 1;
      } else {
      }
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s STA %02x:%02x:%02x:%02x:%02x:%02x - 20 MHz HT, num of 20MHz HT STAs %d\n",
               "bss_cap_update_on_sta_join23a", (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
               (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
               (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
               pmlmepriv->num_sta_ht_20mhz);
      } else {
      }
    } else {
    }
  } else {
    if ((unsigned int )psta->no_ht_set == 0U) {
      psta->no_ht_set = 1U;
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht + 1;
    } else {
    }
    if (pmlmepriv->htpriv.ht_option == 1U) {
      if (GlobalDebugLevel23A > 3U) {
        printk("\016RTL8723AU: %s STA %02x:%02x:%02x:%02x:%02x:%02x - no HT, num of non-HT stations %d\n",
               "bss_cap_update_on_sta_join23a", (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
               (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
               (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
               pmlmepriv->num_sta_no_ht);
      } else {
      }
    } else {
    }
  }
  tmp = rtw_ht_operation_update(padapter);
  if (tmp > 0) {
    update_beacon23a(padapter, 45, (u8 *)0U, 0);
    update_beacon23a(padapter, 61, (u8 *)0U, 1);
  } else {
  }
  associated_clients_update23a(padapter, (int )beacon_updated);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, updated =%d\n", "bss_cap_update_on_sta_join23a", (int )beacon_updated);
  } else {
  }
  return;
}
}
u8 bss_cap_update_on_sta_leave23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  u8 beacon_updated ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;
  {
  beacon_updated = 0U;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (beacon_updated);
  } else {
  }
  if ((unsigned int )psta->no_short_preamble_set != 0U) {
    psta->no_short_preamble_set = 0U;
    pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble - 1;
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {
    }
  } else {
  }
  if ((unsigned int )psta->nonerp_set != 0U) {
    psta->nonerp_set = 0U;
    pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp - 1;
    if (pmlmepriv->num_sta_non_erp == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 42, (u8 *)0U, 1);
    } else {
    }
  } else {
  }
  if ((unsigned int )psta->no_short_slot_time_set != 0U) {
    psta->no_short_slot_time_set = 0U;
    pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time - 1;
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 0) {
      beacon_updated = 1U;
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {
    }
  } else {
  }
  if ((unsigned int )psta->no_ht_gf_set != 0U) {
    psta->no_ht_gf_set = 0U;
    pmlmepriv->num_sta_ht_no_gf = pmlmepriv->num_sta_ht_no_gf - 1;
  } else {
  }
  if ((unsigned int )psta->no_ht_set != 0U) {
    psta->no_ht_set = 0U;
    pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht - 1;
  } else {
  }
  if ((unsigned int )psta->ht_20mhz_set != 0U) {
    psta->ht_20mhz_set = 0U;
    pmlmepriv->num_sta_ht_20mhz = pmlmepriv->num_sta_ht_20mhz - 1;
  } else {
  }
  tmp = rtw_ht_operation_update(padapter);
  if (tmp > 0) {
    update_beacon23a(padapter, 45, (u8 *)0U, 0);
    update_beacon23a(padapter, 61, (u8 *)0U, 1);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, updated =%d\n", "bss_cap_update_on_sta_leave23a", (int )beacon_updated);
  } else {
  }
  return (beacon_updated);
}
}
u8 ap_free_sta23a(struct rtw_adapter *padapter , struct sta_info *psta , bool active ,
                  u16 reason )
{
  struct sta_priv *pstapriv ;
  u8 beacon_updated ;
  {
  pstapriv = & padapter->stapriv;
  beacon_updated = 0U;
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
    return (beacon_updated);
  } else {
  }
  if ((int )active) {
    send_delba23a(padapter, 0, (u8 *)(& psta->hwaddr));
    send_delba23a(padapter, 1, (u8 *)(& psta->hwaddr));
    issue_deauth23a(padapter, (unsigned char *)(& psta->hwaddr), (int )reason);
  } else {
  }
  psta->htpriv.agg_enable_bitmap = 0U;
  psta->htpriv.candidate_tid_bitmap = 0U;
  rtw_clearstakey_cmd23a(padapter, (u8 *)psta, (int )((unsigned int )((unsigned char )psta->mac_id) + 3U),
                         1);
  spin_lock_bh(& psta->lock);
  psta->state = psta->state & 4294967294U;
  spin_unlock_bh(& psta->lock);
  rtw_cfg80211_indicate_sta_disassoc(padapter, (unsigned char *)(& psta->hwaddr),
                                     (int )reason);
  report_del_sta_event23a(padapter, (unsigned char *)(& psta->hwaddr), (int )reason);
  beacon_updated = bss_cap_update_on_sta_leave23a(padapter, psta);
  spin_lock_bh(& pstapriv->sta_hash_lock);
  rtw_free_stainfo23a(padapter, psta);
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  return (beacon_updated);
}
}
int rtw_ap_inform_ch_switch23a(struct rtw_adapter *padapter , u8 new_ch , u8 ch_offset )
{
  struct list_head *phead ;
  struct list_head *plist ;
  int ret ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 bc_addr[6U] ;
  struct list_head const *__mptr ;
  {
  ret = 0;
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  bc_addr[0] = 255U;
  bc_addr[1] = 255U;
  bc_addr[2] = 255U;
  bc_addr[3] = 255U;
  bc_addr[4] = 255U;
  bc_addr[5] = 255U;
  if ((pmlmeinfo->state & 3U) != 3U) {
    return (ret);
  } else {
  }
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s): with ch:%u, offset:%u\n", "rtw_ap_inform_ch_switch23a",
           (char *)(& (padapter->pnetdev)->name), (int )new_ch, (int )ch_offset);
  } else {
  }
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  goto ldv_54622;
  ldv_54621:
  __mptr = (struct list_head const *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
  issue_action_spct_ch_switch23a(padapter, (u8 *)(& psta->hwaddr), (int )new_ch, (int )ch_offset);
  psta->expire_to = 5U < pstapriv->expire_to * 2U ? 5U : pstapriv->expire_to * 2U;
  plist = plist->next;
  ldv_54622: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54621;
  } else {
  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  issue_action_spct_ch_switch23a(padapter, (u8 *)(& bc_addr), (int )new_ch, (int )ch_offset);
  return (ret);
}
}
int rtw_sta_flush23a(struct rtw_adapter *padapter )
{
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  int ret ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 bc_addr[6U] ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head const *__mptr ;
  u8 tmp ;
  {
  ret = 0;
  pstapriv = & padapter->stapriv;
  pmlmeext = & padapter->mlmeextpriv;
  pmlmeinfo = & pmlmeext->mlmext_info;
  bc_addr[0] = 255U;
  bc_addr[1] = 255U;
  bc_addr[2] = 255U;
  bc_addr[3] = 255U;
  bc_addr[4] = 255U;
  bc_addr[5] = 255U;
  chk_alive_num = 0U;
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s(%s)\n", "rtw_sta_flush23a", (char *)(& (padapter->pnetdev)->name));
  } else {
  }
  if ((pmlmeinfo->state & 3U) != 3U) {
    return (ret);
  } else {
  }
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_54643;
  ldv_54642:
  __mptr = (struct list_head const *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
  list_del_init(& psta->asoc_list);
  pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
  tmp = chk_alive_num;
  chk_alive_num = (u8 )((int )chk_alive_num + 1);
  chk_alive_list[(int )tmp] = psta;
  plist = ptmp;
  ptmp = plist->next;
  ldv_54643: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54642;
  } else {
  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  i = 0;
  goto ldv_54646;
  ldv_54645:
  ap_free_sta23a(padapter, chk_alive_list[i], 1, 3);
  i = i + 1;
  ldv_54646: ;
  if ((int )chk_alive_num > i) {
    goto ldv_54645;
  } else {
  }
  issue_deauth23a(padapter, (unsigned char *)(& bc_addr), 3);
  associated_clients_update23a(padapter, 1);
  return (ret);
}
}
void sta_info_update23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  int flags ;
  struct mlme_priv *pmlmepriv ;
  {
  flags = psta->flags;
  pmlmepriv = & padapter->mlmepriv;
  if ((flags & 512) != 0) {
    psta->qos_option = 1U;
  } else {
    psta->qos_option = 0U;
  }
  if (pmlmepriv->qos_option == 0U) {
    psta->qos_option = 0U;
  } else {
  }
  if ((flags & 2048) != 0) {
    psta->htpriv.ht_option = 1U;
    psta->qos_option = 1U;
  } else {
    psta->htpriv.ht_option = 0U;
  }
  if (pmlmepriv->htpriv.ht_option == 0U) {
    psta->htpriv.ht_option = 0U;
  } else {
  }
  update_sta_info23a_apmode23a(padapter, psta);
  return;
}
}
void ap_sta_info_defer_update23a(struct rtw_adapter *padapter , struct sta_info *psta )
{
  {
  if ((int )psta->state & 1) {
    add_RATid23a(padapter, psta, 0);
  } else {
  }
  return;
}
}
void rtw_ap_restore_network(struct rtw_adapter *padapter )
{
  struct mlme_priv *mlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct security_priv *psecuritypriv ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head const *__mptr ;
  u8 tmp ;
  {
  mlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pstapriv = & padapter->stapriv;
  psecuritypriv = & padapter->securitypriv;
  chk_alive_num = 0U;
  rtw_setopmode_cmd23a(padapter, 3);
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
  start_bss_network(padapter, (u8 *)(& mlmepriv->cur_network.network));
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
    rtw_set_key23a(padapter, psecuritypriv, (int )psecuritypriv->dot118021XGrpKeyid,
                   0);
  } else {
  }
  if (padapter->securitypriv.dot11PrivacyAlgrthm != 1027074U && padapter->securitypriv.dot11PrivacyAlgrthm != 1027076U) {
    return;
  } else {
  }
  spin_lock_bh(& pstapriv->asoc_list_lock);
  phead = & pstapriv->asoc_list;
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_54675;
  ldv_54674:
  __mptr = (struct list_head const *)plist;
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
  tmp = chk_alive_num;
  chk_alive_num = (u8 )((int )chk_alive_num + 1);
  chk_alive_list[(int )tmp] = psta;
  plist = ptmp;
  ptmp = plist->next;
  ldv_54675: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54674;
  } else {
  }
  spin_unlock_bh(& pstapriv->asoc_list_lock);
  i = 0;
  goto ldv_54678;
  ldv_54677:
  psta = chk_alive_list[i];
  if ((int )psta->state & 1) {
    Update_RA_Entry23a(padapter, psta);
    rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
  } else {
  }
  i = i + 1;
  ldv_54678: ;
  if ((int )chk_alive_num > i) {
    goto ldv_54677;
  } else {
  }
  return;
}
}
void start_ap_mode23a(struct rtw_adapter *padapter )
{
  int i ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_acl_pool *pacl_list ;
  {
  pmlmepriv = & padapter->mlmepriv;
  pstapriv = & padapter->stapriv;
  pmlmeext = & padapter->mlmeextpriv;
  pacl_list = & pstapriv->acl_list;
  pmlmepriv->update_bcn = 0U;
  pmlmeext->bstart_bss = 0U;
  pmlmepriv->num_sta_non_erp = 0;
  pmlmepriv->num_sta_no_short_slot_time = 0;
  pmlmepriv->num_sta_no_short_preamble = 0;
  pmlmepriv->num_sta_ht_no_gf = 0;
  pmlmepriv->num_sta_no_ht = 0;
  pmlmepriv->num_sta_ht_20mhz = 0;
  pmlmepriv->olbc = 0;
  pmlmepriv->olbc_ht = 0;
  pmlmepriv->ht_op_mode = 0U;
  i = 0;
  goto ldv_54689;
  ldv_54688:
  pstapriv->sta_aid[i] = (struct sta_info *)0;
  i = i + 1;
  ldv_54689: ;
  if (i <= 31) {
    goto ldv_54688;
  } else {
  }
  pmlmepriv->wps_beacon_ie = (u8 *)0U;
  pmlmepriv->wps_probe_resp_ie = (u8 *)0U;
  pmlmepriv->wps_assoc_resp_ie = (u8 *)0U;
  pmlmepriv->p2p_beacon_ie = (u8 *)0U;
  pmlmepriv->p2p_probe_resp_ie = (u8 *)0U;
  INIT_LIST_HEAD(& pacl_list->acl_node_q.queue);
  pacl_list->num = 0;
  pacl_list->mode = 0;
  i = 0;
  goto ldv_54692;
  ldv_54691:
  INIT_LIST_HEAD(& pacl_list->aclnode[i].list);
  pacl_list->aclnode[i].valid = 0U;
  i = i + 1;
  ldv_54692: ;
  if (i <= 15) {
    goto ldv_54691;
  } else {
  }
  return;
}
}
void stop_ap_mode23a(struct rtw_adapter *padapter )
{
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head const *__mptr ;
  {
  psta = (struct sta_info *)0;
  pstapriv = & padapter->stapriv;
  pmlmepriv = & padapter->mlmepriv;
  pmlmeext = & padapter->mlmeextpriv;
  pacl_list = & pstapriv->acl_list;
  pacl_node_q = & pacl_list->acl_node_q;
  pmlmepriv->update_bcn = 0U;
  pmlmeext->bstart_bss = 0U;
  memset((void *)(& padapter->securitypriv), 0, 4776UL);
  padapter->securitypriv.ndisauthtype = 0U;
  padapter->securitypriv.ndisencryptstatus = 1U;
  spin_lock_bh(& pacl_node_q->lock);
  phead = get_list_head(pacl_node_q);
  plist = phead->next;
  ptmp = plist->next;
  goto ldv_54710;
  ldv_54709:
  __mptr = (struct list_head const *)plist;
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
  if ((unsigned int )paclnode->valid == 1U) {
    paclnode->valid = 0U;
    list_del_init(& paclnode->list);
    pacl_list->num = pacl_list->num - 1;
  } else {
  }
  plist = ptmp;
  ptmp = plist->next;
  ldv_54710: ;
  if ((unsigned long )plist != (unsigned long )phead) {
    goto ldv_54709;
  } else {
  }
  spin_unlock_bh(& pacl_node_q->lock);
  if (GlobalDebugLevel23A > 3U) {
    printk("\016RTL8723AU: %s, free acl_node_queue, num =%d\n", "stop_ap_mode23a",
           pacl_list->num);
  } else {
  }
  rtw_sta_flush23a(padapter);
  rtw_free_all_stainfo23a(padapter);
  psta = rtw_get_bcmc_stainfo23a(padapter);
  spin_lock_bh(& pstapriv->sta_hash_lock);
  rtw_free_stainfo23a(padapter, psta);
  spin_unlock_bh(& pstapriv->sta_hash_lock);
  rtw_init_bcmc_stainfo23a(padapter);
  rtw23a_free_mlme_priv_ie_data(pmlmepriv);
  return;
}
}
void *ldv_kmem_cache_alloc_2480(struct kmem_cache *ldv_func_arg1 , gfp_t flags )
{
  {
  ldv_check_alloc_flags(flags);
  kmem_cache_alloc(ldv_func_arg1, flags);
  return ((void *)0);
}
}
int ldv_pskb_expand_head_2486(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2488(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_copy_2490(struct sk_buff const *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_copy(ldv_func_arg1, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2491(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2492(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
struct sk_buff *ldv___netdev_alloc_skb_2493(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2494(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
int ldv_pskb_expand_head_2495(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags )
{
  int tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
  return (tmp);
}
}
struct sk_buff *ldv_skb_clone_2496(struct sk_buff *ldv_func_arg1 , gfp_t flags )
{
  struct sk_buff *tmp ;
  {
  ldv_check_alloc_flags(flags);
  tmp = skb_clone(ldv_func_arg1, flags);
  return (tmp);
}
}
__inline static void ldv_error(void);
int ldv_spin = 0;
void ldv_check_alloc_flags(gfp_t flags )
{
  {
  if (ldv_spin == 0 || ! (flags & 16U)) {
  } else {
    ldv_error();
  }
  return;
}
}
extern struct page___0 *ldv_some_page(void) ;
struct page___0 *ldv_check_alloc_flags_and_return_some_page(gfp_t flags )
{
  struct page___0 *tmp ;
  {
  if (ldv_spin == 0 || ! (flags & 16U)) {
  } else {
    ldv_error();
  }
  tmp = ldv_some_page();
  return (tmp);
}
}
void ldv_check_alloc_nonatomic(void)
{
  {
  if (ldv_spin == 0) {
  } else {
    ldv_error();
  }
  return;
}
}
void ldv_spin_lock(void)
{
  {
  ldv_spin = 1;
  return;
}
}
void ldv_spin_unlock(void)
{
  {
  ldv_spin = 0;
  return;
}
}
int ldv_spin_trylock(void)
{
  int is_lock ;
  {
  is_lock = ldv_undef_int();
  if (is_lock) {
    return (0);
  } else {
    ldv_spin = 1;
    return (1);
  }
}
}
void *external_alloc(void);
struct workqueue_struct *__alloc_workqueue_key(const char *arg0, unsigned int arg1, int arg2, struct lock_class_key *arg3, const char *arg4, ...) {
  return (struct workqueue_struct *)external_alloc();
}
void __const_udelay(unsigned long arg0) {
  return;
}
void __dev_kfree_skb_any(struct sk_buff *arg0, enum skb_free_reason arg1) {
  return;
}
void *external_alloc(void);
struct ieee80211_channel *__ieee80211_get_channel(struct wiphy *arg0, int arg1) {
  return (struct ieee80211_channel *)external_alloc();
}
void __init_waitqueue_head(wait_queue_head_t *arg0, const char *arg1, struct lock_class_key *arg2) {
  return;
}
void __init_work(struct work_struct *arg0, int arg1) {
  return;
}
void __list_add(struct list_head *arg0, struct list_head *arg1, struct list_head *arg2) {
  return;
}
void __list_del_entry(struct list_head *arg0) {
  return;
}
void __mutex_init(struct mutex *arg0, const char *arg1, struct lock_class_key *arg2) {
  return;
}
void *external_alloc(void);
struct sk_buff *__netdev_alloc_skb(struct net_device *arg0, unsigned int arg1, gfp_t arg2) {
  return (struct sk_buff *)external_alloc();
}
void __netif_schedule(struct Qdisc *arg0) {
  return;
}
void __raw_spin_lock_init(raw_spinlock_t *arg0, const char *arg1, struct lock_class_key *arg2) {
  return;
}
void __tasklet_hi_schedule(struct tasklet_struct *arg0) {
  return;
}
void __tasklet_schedule(struct tasklet_struct *arg0) {
  return;
}
void __udelay(unsigned long arg0) {
  return;
}
void _raw_spin_lock(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_lock_bh(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_unlock(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_unlock_bh(raw_spinlock_t *arg0) {
  return;
}
void _raw_spin_unlock_irqrestore(raw_spinlock_t *arg0, unsigned long arg1) {
  return;
}
void *external_alloc(void);
struct net_device *alloc_etherdev_mqs(int arg0, unsigned int arg1, unsigned int arg2) {
  return (struct net_device *)external_alloc();
}
bool __VERIFIER_nondet_bool(void);
bool cancel_work_sync(struct work_struct *arg0) {
  return __VERIFIER_nondet_bool();
}
void cfg80211_connect_result(struct net_device *arg0, const u8 *arg1, const u8 *arg2, size_t arg3, const u8 *arg4, size_t arg5, u16 arg6, gfp_t arg7) {
  return;
}
void cfg80211_disconnected(struct net_device *arg0, u16 arg1, const u8 *arg2, size_t arg3, gfp_t arg4) {
  return;
}
void *external_alloc(void);
const u8 *cfg80211_find_ie(u8 arg0, const u8 *arg1, int arg2) {
  return (const u8 *)external_alloc();
}
void *external_alloc(void);
const u8 *cfg80211_find_vendor_ie(unsigned int arg0, u8 arg1, const u8 *arg2, int arg3) {
  return (const u8 *)external_alloc();
}
void *external_alloc(void);
struct cfg80211_bss *cfg80211_inform_bss_width_frame(struct wiphy *arg0, struct ieee80211_channel *arg1, enum nl80211_bss_scan_width arg2, struct ieee80211_mgmt *arg3, size_t arg4, s32 arg5, gfp_t arg6) {
  return (struct cfg80211_bss *)external_alloc();
}
void cfg80211_mgmt_tx_status(struct wireless_dev *arg0, u64 arg1, const u8 *arg2, size_t arg3, bool arg4, gfp_t arg5) {
  return;
}
void cfg80211_michael_mic_failure(struct net_device *arg0, const u8 *arg1, enum nl80211_key_type arg2, int arg3, const u8 *arg4, gfp_t arg5) {
  return;
}
void cfg80211_put_bss(struct wiphy *arg0, struct cfg80211_bss *arg1) {
  return;
}
void cfg80211_roamed(struct net_device *arg0, struct ieee80211_channel *arg1, const u8 *arg2, const u8 *arg3, size_t arg4, const u8 *arg5, size_t arg6, gfp_t arg7) {
  return;
}
bool __VERIFIER_nondet_bool(void);
bool cfg80211_rx_mgmt(struct wireless_dev *arg0, int arg1, int arg2, const u8 *arg3, size_t arg4, u32 arg5, gfp_t arg6) {
  return __VERIFIER_nondet_bool();
}
void cfg80211_scan_done(struct cfg80211_scan_request *arg0, bool arg1) {
  return;
}
void complete(struct completion *arg0) {
  return;
}
void consume_skb(struct sk_buff *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int del_timer_sync(struct timer_list *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int dev_alloc_name(struct net_device *arg0, const char *arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int device_init_wakeup(struct device *arg0, bool arg1) {
  return __VERIFIER_nondet_int();
}
void down(struct semaphore *arg0) {
  return;
}
unsigned short __VERIFIER_nondet_ushort(void);
__be16 eth_type_trans(struct sk_buff *arg0, struct net_device *arg1) {
  return __VERIFIER_nondet_ushort();
}
void *external_alloc(void);
struct pid *find_vpid(int arg0) {
  return (struct pid *)external_alloc();
}
void flush_workqueue(struct workqueue_struct *arg0) {
  return;
}
void free_netdev(struct net_device *arg0) {
  return;
}
void *external_alloc(void);
u8 *get_my_bssid23a(struct wlan_bssid_ex *arg0) {
  return (u8 *)external_alloc();
}
void get_random_bytes(void *arg0, int arg1) {
  return;
}
unsigned char __VERIFIER_nondet_uchar(void);
u8 hal_ch_offset_to_secondary_ch_offset23a(u8 arg0) {
  return __VERIFIER_nondet_uchar();
}
void ieee80211_amsdu_to_8023s(struct sk_buff *arg0, struct sk_buff_head *arg1, const u8 *arg2, enum nl80211_iftype arg3, const unsigned int arg4, bool arg5) {
  return;
}
int __VERIFIER_nondet_int(void);
int ieee80211_channel_to_frequency(int arg0, enum ieee80211_band arg1) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ieee80211_frequency_to_channel(int arg0) {
  return __VERIFIER_nondet_int();
}
unsigned int __VERIFIER_nondet_uint(void);
unsigned int jiffies_to_msecs(const unsigned long arg0) {
  return __VERIFIER_nondet_uint();
}
int __VERIFIER_nondet_int(void);
int kill_pid(struct pid *arg0, int arg1, int arg2) {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
void *kmem_cache_alloc(struct kmem_cache *arg0, gfp_t arg1) {
  return (void *)external_alloc();
}
void *external_alloc(void);
void *kmemdup(const void *arg0, size_t arg1, gfp_t arg2) {
  return (void *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int ldv_bind_14() {
  return __VERIFIER_nondet_int();
}
void ldv_check_final_state() {
  return;
}
void ldv_initialize() {
  return;
}
int __VERIFIER_nondet_int(void);
int ldv_ndo_init_13() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_ndo_init_15() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_ndo_uninit_13() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_ndo_uninit_15() {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int ldv_release_14() {
  return __VERIFIER_nondet_int();
}
void *external_alloc(void);
struct page___0 *ldv_some_page() {
  return (struct page___0 *)external_alloc();
}
void lockdep_init_map(struct lockdep_map *arg0, const char *arg1, struct lock_class_key *arg2, int arg3) {
  return;
}
int __VERIFIER_nondet_int(void);
int mod_timer(struct timer_list *arg0, unsigned long arg1) {
  return __VERIFIER_nondet_int();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int msecs_to_jiffies(const unsigned int arg0) {
  return __VERIFIER_nondet_ulong();
}
void msleep(unsigned int arg0) {
  return;
}
void mutex_destroy(struct mutex *arg0) {
  return;
}
void mutex_lock_nested(struct mutex *arg0, unsigned int arg1) {
  return;
}
void mutex_unlock(struct mutex *arg0) {
  return;
}
void netif_carrier_off(struct net_device *arg0) {
  return;
}
void netif_carrier_on(struct net_device *arg0) {
  return;
}
void netif_device_attach(struct net_device *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int netif_rx(struct sk_buff *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int printk(const char *arg0, ...) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int pskb_expand_head(struct sk_buff *arg0, int arg1, int arg2, gfp_t arg3) {
  return __VERIFIER_nondet_int();
}
bool __VERIFIER_nondet_bool(void);
bool queue_work_on(int arg0, struct workqueue_struct *arg1, struct work_struct *arg2) {
  return __VERIFIER_nondet_bool();
}
int __VERIFIER_nondet_int(void);
int register_netdev(struct net_device *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int register_netdevice(struct net_device *arg0) {
  return __VERIFIER_nondet_int();
}
void release_firmware(const struct firmware *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int request_firmware(const struct firmware **arg0, const char *arg1, struct device *arg2) {
  return __VERIFIER_nondet_int();
}
bool __VERIFIER_nondet_bool(void);
bool rtw_cfg80211_pwr_mgmt(struct rtw_adapter *arg0) {
  return __VERIFIER_nondet_bool();
}
unsigned char __VERIFIER_nondet_uchar(void);
u8 rtw_get_oper_ch23a(struct rtw_adapter *arg0) {
  return __VERIFIER_nondet_uchar();
}
bool __VERIFIER_nondet_bool(void);
bool rtw_is_scan_deny(struct rtw_adapter *arg0) {
  return __VERIFIER_nondet_bool();
}
void *external_alloc(void);
u8 *rtw_set_ie23a_ch_switch(u8 *arg0, u32 *arg1, u8 arg2, u8 arg3, u8 arg4) {
  return (u8 *)external_alloc();
}
void *external_alloc(void);
u8 *rtw_set_ie23a_secondary_ch_offset(u8 *arg0, u32 *arg1, u8 arg2) {
  return (u8 *)external_alloc();
}
void *external_alloc(void);
struct sk_buff *skb_clone(struct sk_buff *arg0, gfp_t arg1) {
  return (struct sk_buff *)external_alloc();
}
void *external_alloc(void);
struct sk_buff *skb_copy(const struct sk_buff *arg0, gfp_t arg1) {
  return (struct sk_buff *)external_alloc();
}
void *external_alloc(void);
struct sk_buff *skb_dequeue(struct sk_buff_head *arg0) {
  return (struct sk_buff *)external_alloc();
}
void *external_alloc(void);
unsigned char *skb_pull(struct sk_buff *arg0, unsigned int arg1) {
  return (unsigned char *)external_alloc();
}
void *external_alloc(void);
unsigned char *skb_put(struct sk_buff *arg0, unsigned int arg1) {
  return (unsigned char *)external_alloc();
}
void skb_queue_purge(struct sk_buff_head *arg0) {
  return;
}
void skb_queue_tail(struct sk_buff_head *arg0, struct sk_buff *arg1) {
  return;
}
void skb_trim(struct sk_buff *arg0, unsigned int arg1) {
  return;
}
void tasklet_init(struct tasklet_struct *arg0, void (*arg1)(unsigned long), unsigned long arg2) {
  return;
}
void tasklet_kill(struct tasklet_struct *arg0) {
  return;
}
void unregister_netdev(struct net_device *arg0) {
  return;
}
void unregister_netdevice_queue(struct net_device *arg0, struct list_head *arg1) {
  return;
}
void up(struct semaphore *arg0) {
  return;
}
void *external_alloc(void);
struct urb *usb_alloc_urb(int arg0, gfp_t arg1) {
  return (struct urb *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int usb_autopm_get_interface(struct usb_interface *arg0) {
  return __VERIFIER_nondet_int();
}
void usb_autopm_put_interface(struct usb_interface *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int usb_control_msg(struct usb_device *arg0, unsigned int arg1, __u8 arg2, __u8 arg3, __u16 arg4, __u16 arg5, void *arg6, __u16 arg7, int arg8) {
  return __VERIFIER_nondet_int();
}
void usb_deregister(struct usb_driver *arg0) {
  return;
}
void usb_free_urb(struct urb *arg0) {
  return;
}
void *external_alloc(void);
struct usb_device *usb_get_dev(struct usb_device *arg0) {
  return (struct usb_device *)external_alloc();
}
void usb_kill_urb(struct urb *arg0) {
  return;
}
void usb_put_dev(struct usb_device *arg0) {
  return;
}
int __VERIFIER_nondet_int(void);
int usb_register_driver(struct usb_driver *arg0, struct module *arg1, const char *arg2) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int usb_reset_device(struct usb_device *arg0) {
  return __VERIFIER_nondet_int();
}
int __VERIFIER_nondet_int(void);
int usb_submit_urb(struct urb *arg0, gfp_t arg1) {
  return __VERIFIER_nondet_int();
}
unsigned long __VERIFIER_nondet_ulong(void);
unsigned long int wait_for_completion_timeout(struct completion *arg0, unsigned long arg1) {
  return __VERIFIER_nondet_ulong();
}
void warn_slowpath_null(const char *arg0, const int arg1) {
  return;
}
void wiphy_free(struct wiphy *arg0) {
  return;
}
void *external_alloc(void);
struct wiphy *wiphy_new(const struct cfg80211_ops *arg0, int arg1) {
  return (struct wiphy *)external_alloc();
}
int __VERIFIER_nondet_int(void);
int wiphy_register(struct wiphy *arg0) {
  return __VERIFIER_nondet_int();
}
void wiphy_unregister(struct wiphy *arg0) {
  return;
}
void yield() {
  return;
}
void *__VERIFIER_nondet_pointer(void);
void *external_alloc(void) {
  return __VERIFIER_nondet_pointer();
}
void free(void *);
void kfree(void const *p) {
  free((void *)p);
}
