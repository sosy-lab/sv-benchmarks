/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 95 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 19 "include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 147 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 158 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 159 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 160 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 178 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 178 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 183 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 183 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 184 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 189
struct hlist_node;
#line 189 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 193 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 204 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 65 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1022_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct_ldv_1037_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
union __anonunion_ldv_1038_8 {
   struct __anonstruct_ldv_1022_9 ldv_1022 ;
   struct __anonstruct_ldv_1037_10 ldv_1037 ;
};
#line 59 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion_ldv_1038_8 ldv_1038 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 242 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 244 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 244 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 332
struct page;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 340
struct file;
#line 353
struct seq_file;
#line 390
struct thread_struct;
#line 392
struct mm_struct;
#line 393
struct task_struct;
#line 394
struct cpumask;
#line 327 "./arch/x86/include/asm/paravirt_types.h"
struct arch_spinlock;
#line 18 "./arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "./arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
union __anonunion_ldv_1458_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "./arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion_ldv_1458_15 ldv_1458 ;
};
#line 33 "./arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "./arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 142 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 400 "include/linux/printk.h"
struct file_operations;
#line 412
struct completion;
#line 416 "include/linux/kernel.h"
struct pid;
#line 527 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion_ldv_2998_20 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion_ldv_2998_20 ldv_2998 ;
};
#line 306 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 671 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 162 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 294 "./arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5289_25 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct __anonstruct_ldv_5295_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5296_24 {
   struct __anonstruct_ldv_5289_25 ldv_5289 ;
   struct __anonstruct_ldv_5295_26 ldv_5295 ;
};
#line 312 "./arch/x86/include/asm/processor.h"
union __anonunion_ldv_5305_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "./arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion_ldv_5296_24 ldv_5296 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion_ldv_5305_27 ldv_5305 ;
};
#line 346 "./arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "./arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "./arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 377 "./arch/x86/include/asm/processor.h"
struct bndregs_struct {
   u64 bndregs[8U] ;
};
#line 381 "./arch/x86/include/asm/processor.h"
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
#line 386 "./arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 392 "./arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
#line 401 "./arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "./arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 35 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 530 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct_ldv_6346_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion_ldv_6347_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct_ldv_6346_31 ldv_6346 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion_ldv_6347_30 ldv_6347 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 412 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 259 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_33 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 259 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_33 seqlock_t;
#line 433 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_34 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_34 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_35 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_35 kgid_t;
#line 127 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 34 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 39 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 98 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_36 {
   unsigned long bits[16U] ;
};
#line 98 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_36 nodemask_t;
#line 814 "include/linux/mmzone.h"
struct optimistic_spin_queue;
#line 815 "include/linux/mmzone.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 68 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 178
struct rw_semaphore;
#line 179 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   struct optimistic_spin_queue *osq ;
   struct lockdep_map dep_map ;
};
#line 174 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 105 "include/linux/debugobjects.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 323 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 412
struct tvec_base;
#line 413 "include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 258 "include/linux/timer.h"
struct hrtimer;
#line 259
enum hrtimer_restart;
#line 270
struct workqueue_struct;
#line 271
struct work_struct;
#line 53 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 546 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 614 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_101 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_101 mm_context_t;
#line 18 "include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 40 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct vm_area_struct;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 167 "./arch/x86/include/asm/fixmap.h"
struct notifier_block;
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 906 "include/linux/mmzone.h"
struct ctl_table;
#line 835 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "include/linux/sysctl.h"
struct __anonstruct_ldv_13800_129 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "include/linux/sysctl.h"
union __anonunion_ldv_13802_128 {
   struct __anonstruct_ldv_13800_129 ldv_13800 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion_ldv_13802_128 ldv_13802 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 24 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14046_136 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct_ldv_14050_137 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion_ldv_14051_135 {
   struct __anonstruct_ldv_14046_136 ldv_14046 ;
   struct __anonstruct_ldv_14050_137 ldv_14050 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion_ldv_14051_135 ldv_14051 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14160_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14166_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14176_144 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14178_143 {
   atomic_t _mapcount ;
   struct __anonstruct_ldv_14176_144 ldv_14176 ;
   int units ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14180_142 {
   union __anonunion_ldv_14178_143 ldv_14178 ;
   atomic_t _count ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14182_141 {
   unsigned long counters ;
   struct __anonstruct_ldv_14180_142 ldv_14180 ;
   unsigned int active ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14183_139 {
   union __anonunion_ldv_14166_140 ldv_14166 ;
   union __anonunion_ldv_14182_141 ldv_14182 ;
};
#line 134 "include/linux/uprobes.h"
struct __anonstruct_ldv_14190_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 134
struct slab;
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14195_145 {
   struct list_head lru ;
   struct __anonstruct_ldv_14190_146 ldv_14190 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
#line 134 "include/linux/uprobes.h"
union __anonunion_ldv_14201_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 134 "include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   union __anonunion_ldv_14160_138 ldv_14160 ;
   struct __anonstruct_ldv_14183_139 ldv_14183 ;
   union __anonunion_ldv_14195_145 ldv_14195 ;
   union __anonunion_ldv_14201_147 ldv_14201 ;
   unsigned long debug_flags ;
};
#line 187 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 239 "include/linux/mm_types.h"
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 239 "include/linux/mm_types.h"
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
#line 239
struct anon_vma;
#line 239
struct vm_operations_struct;
#line 239
struct mempolicy;
#line 239 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 311 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 317 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 330 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 338 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 343
struct kioctx_table;
#line 344
struct linux_binfmt;
#line 344
struct mmu_notifier_mm;
#line 344 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "include/linux/elf.h"
union __anonunion_ldv_14564_153 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 48 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion_ldv_14564_153 ldv_14564 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
#line 95 "include/linux/kernfs.h"
union __anonunion_ldv_14708_154 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion_ldv_14708_154 ldv_14708 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 186 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 462
struct sock;
#line 463
struct kobject;
#line 464
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 470 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 131 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 470 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "include/linux/moduleparam.h"
union __anonunion_ldv_15383_155 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion_ldv_15383_155 ldv_15383 ;
};
#line 70 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 461 "include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "include/linux/module.h"
struct module_param_attrs;
#line 36 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 72
struct exception_table_entry;
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212 "include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 226
struct module_sect_attrs;
#line 226
struct module_notes_attrs;
#line 226
struct tracepoint;
#line 226
struct ftrace_event_call;
#line 226 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 57 "include/linux/kmemleak.h"
struct mem_cgroup;
#line 368 "include/linux/slab.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_16003_157 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
#line 490 "include/linux/slab.h"
struct __anonstruct_ldv_16009_158 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   atomic_t nr_pages ;
};
#line 490 "include/linux/slab.h"
union __anonunion_ldv_16010_156 {
   struct __anonstruct_ldv_16003_157 ldv_16003 ;
   struct __anonstruct_ldv_16009_158 ldv_16009 ;
};
#line 490 "include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion_ldv_16010_156 ldv_16010 ;
};
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct wiphy;
#line 111
struct wireless_dev;
#line 123
struct usb_interface;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 69 "include/linux/miscdevice.h"
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 196
struct pinctrl;
#line 197
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 42 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 42 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 60 "include/linux/device.h"
struct device_attribute;
#line 60 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 195
struct of_device_id;
#line 195
struct acpi_device_id;
#line 195 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 321
struct class_attribute;
#line 321 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 414 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 482 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 510 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 640 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 649
struct acpi_device;
#line 650 "include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 656
struct dma_coherent_mem;
#line 656
struct cma;
#line 656 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 803 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1213 "include/linux/device.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 48 "include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 53
enum dev_pm_qos_req_type {
    DEV_PM_QOS_RESUME_LATENCY = 1,
    DEV_PM_QOS_LATENCY_TOLERANCE = 2,
    DEV_PM_QOS_FLAGS = 3
} ;
#line 59 "include/linux/pm_qos.h"
union __anonunion_data_159 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 59 "include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_159 data ;
   struct device *dev ;
};
#line 68
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 74 "include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   s32 no_constraint_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 88 "include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 93 "include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints resume_latency ;
   struct pm_qos_constraints latency_tolerance ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *resume_latency_req ;
   struct dev_pm_qos_request *latency_tolerance_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 461 "include/linux/rculist.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion_ldv_18051_160 {
   struct iovec  const  *iov ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion_ldv_18051_160 ldv_18051 ;
   unsigned long nr_segs ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 71
struct file_ra_state;
#line 72
struct user_struct;
#line 73
struct writeback_control;
#line 188 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 221 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 2112 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 38 "include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 1153 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_162 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_162 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_163 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_163 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_164 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_164 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_165 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_165 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_166 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_166 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_167 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_167 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_168 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_168 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_169 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_169 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_170 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_171 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_170 ifr_ifrn ;
   union __anonunion_ifr_ifru_171 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct_ldv_22130_174 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion_ldv_22131_173 {
   struct __anonstruct_ldv_22130_174 ldv_22130 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion_ldv_22131_173 ldv_22131 ;
};
#line 49 "include/linux/lockref.h"
struct nameidata;
#line 50
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct_ldv_22154_176 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion_ldv_22156_175 {
   struct __anonstruct_ldv_22154_176 ldv_22154 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion_ldv_22156_175 ldv_22156 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_177 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_177 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 477 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 30 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct_ldv_22517_179 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion_ldv_22519_178 {
   struct __anonstruct_ldv_22517_179 ldv_22517 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion_ldv_22519_178 ldv_22519 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 428
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 435
struct pid_namespace;
#line 435 "include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 218 "include/linux/capability.h"
struct semaphore {
   raw_spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 32
struct cgroup_subsys_state;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 59 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct kiocb;
#line 62
struct pipe_inode_info;
#line 63
struct poll_table_struct;
#line 64
struct kstatfs;
#line 65
struct swap_info_struct;
#line 69 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 253 "include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "./include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "./include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "./include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_181 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_181 kprojid_t;
#line 119 "include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "include/linux/quota.h"
typedef long long qsize_t;
#line 61 "include/linux/quota.h"
union __anonunion_ldv_23316_182 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "include/linux/quota.h"
struct kqid {
   union __anonunion_ldv_23316_182 ldv_23316 ;
   enum quota_type type ;
};
#line 178 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 334 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 380 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 323 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 382
struct backing_dev_info;
#line 383 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 405
struct request_queue;
#line 406
struct hd_struct;
#line 406
struct gendisk;
#line 406 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 478
struct posix_acl;
#line 479
struct inode_operations;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_23731_185 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 479 "include/linux/fs.h"
union __anonunion_ldv_23751_186 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 479
struct file_lock;
#line 479
struct cdev;
#line 479 "include/linux/fs.h"
union __anonunion_ldv_23768_187 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 479 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion_ldv_23731_185 ldv_23731 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion_ldv_23751_186 ldv_23751 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion_ldv_23768_187 ldv_23768 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 715 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 723 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 746 "include/linux/fs.h"
union __anonunion_f_u_188 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 746 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_188 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 836
struct files_struct;
#line 836 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 837 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 842 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 855
struct net;
#line 860
struct nlm_lockowner;
#line 861 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_190 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_189 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_190 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_189 fl_u ;
};
#line 963 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1157 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1173
struct super_operations;
#line 1173
struct xattr_handler;
#line 1173
struct mtd_info;
#line 1173 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
#line 1403 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1441 "include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1446 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1488 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1535 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1749 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_191 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_191 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_193 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_194 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_195 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_196 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_197 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_198 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_199 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_192 {
   int _pad[28U] ;
   struct __anonstruct__kill_193 _kill ;
   struct __anonstruct__timer_194 _timer ;
   struct __anonstruct__rt_195 _rt ;
   struct __anonstruct__sigchld_196 _sigchld ;
   struct __anonstruct__sigfault_197 _sigfault ;
   struct __anonstruct__sigpoll_198 _sigpoll ;
   struct __anonstruct__sigsys_199 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_192 _sifields ;
};
#line 109 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 246 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 260 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 46 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 463 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_26730_202 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion_ldv_26738_203 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct_ldv_26751_205 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_26752_204 {
   struct keyring_index_key index_key ;
   struct __anonstruct_ldv_26751_205 ldv_26751 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_206 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_208 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion_ldv_26767_207 {
   union __anonunion_payload_208 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion_ldv_26730_202 ldv_26730 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion_ldv_26738_203 ldv_26738 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion_ldv_26752_204 ldv_26752 ;
   union __anonunion_type_data_206 type_data ;
   union __anonunion_ldv_26767_207 ldv_26767 ;
};
#line 356
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 125 "include/linux/sched.h"
struct futex_pi_state;
#line 126
struct robust_list_head;
#line 127
struct bio_list;
#line 128
struct fs_struct;
#line 129
struct perf_event_context;
#line 130
struct blk_plug;
#line 180
struct cfs_rq;
#line 181
struct task_group;
#line 426 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 465 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 473 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 480 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 492 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 512 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 554
struct autogroup;
#line 555
struct tty_struct;
#line 555
struct taskstats;
#line 555
struct tty_audit_buf;
#line 555 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 735 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 778
struct reclaim_state;
#line 779 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 794 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1060
struct uts_namespace;
#line 1061 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1069 "include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1081 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1116 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1148
struct rt_rq;
#line 1148 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1164 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1222 "include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1643 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1650
struct sched_class;
#line 1650
struct css_set;
#line 1650
struct compat_robust_list_head;
#line 1650
struct numa_group;
#line 1650
struct ftrace_ret_stack;
#line 1650 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char no_new_privs : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults_memory ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer_memory ;
   unsigned long *numa_faults_cpu ;
   unsigned long *numa_faults_buffer_cpu ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 114 "include/linux/random.h"
enum ldv_22548 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_22548 socket_state;
#line 70 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 94 "include/linux/net.h"
struct proto_ops;
#line 94 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 120 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 166 "include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 18 "include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 137 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 147 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 360 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 361 "include/linux/skbuff.h"
struct __anonstruct_ldv_31170_227 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 361 "include/linux/skbuff.h"
union __anonunion_ldv_31171_226 {
   u64 v64 ;
   struct __anonstruct_ldv_31170_227 ldv_31170 ;
};
#line 361 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion_ldv_31171_226 ldv_31171 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_31190_228 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 414
struct sec_path;
#line 414 "include/linux/skbuff.h"
struct __anonstruct_ldv_31206_230 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_31207_229 {
   __wsum csum ;
   struct __anonstruct_ldv_31206_230 ldv_31206 ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_31246_231 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
#line 414 "include/linux/skbuff.h"
union __anonunion_ldv_31252_232 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 414 "include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion_ldv_31190_228 ldv_31190 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion_ldv_31207_229 ldv_31207 ;
   __u32 priority ;
   unsigned char ignore_df : 1 ;
   unsigned char cloned : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char nohdr : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char pkt_type : 3 ;
   unsigned char fclone : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char peeked : 1 ;
   unsigned char nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   union __anonunion_ldv_31246_231 ldv_31246 ;
   __u32 secmark ;
   union __anonunion_ldv_31252_232 ldv_31252 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 641
struct dst_entry;
#line 3161 "include/linux/skbuff.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 187 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 211 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 259 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 288 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 305 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 404 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 441 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 469 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 568 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 600 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 642 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 675 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 691 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 711 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 722 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 741 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 767 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 933 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 941 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1017 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 79 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 145 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[8U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[103U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118
struct proc_dir_entry;
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 180 "include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 181
struct ipv4_devconf;
#line 182
struct fib_rules_ops;
#line 183
struct fib_table;
#line 184 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
#line 22 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 27
struct inet_peer_base;
#line 27
struct xt_table;
#line 27 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 102
struct neighbour;
#line 102 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
};
#line 35 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 35
struct rt6_info;
#line 35
struct rt6_statistics;
#line 35
struct fib6_table;
#line 35 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
#line 80 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 86 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
   u16 max_dsize ;
};
#line 21
struct sctp_mib;
#line 22 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 324 "include/linux/netfilter.h"
struct nlattr;
#line 337
struct nf_logger;
#line 338 "include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 24 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 20 "include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 24 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 29 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 43 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 48 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 53 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 64 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 72
struct ip_conntrack_stat;
#line 72
struct nf_ct_event_notifier;
#line 72
struct nf_exp_event_notifier;
#line 72 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 111
struct nft_af_info;
#line 112 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   u8 gencursor ;
   u8 genctr ;
};
#line 450 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 663 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 17 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 74
struct net_generic;
#line 75
struct netns_ipvs;
#line 76 "include/net/netns/xfrm.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 400 "include/net/net_namespace.h"
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
#line 46 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 61
struct dsa_switch;
#line 61 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 94
struct dsa_switch_driver;
#line 94
struct mii_bus;
#line 94 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 146 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
#line 205 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 167 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 102 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 58 "./include/uapi/linux/cgroupstats.h"
struct percpu_ref;
#line 54 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 55 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
#line 205
struct cgroup_root;
#line 206
struct cgroup_subsys;
#line 207
struct cgroup;
#line 58 "include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 167 "include/linux/cgroup.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
};
#line 253 "include/linux/cgroup.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 355 "include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 438 "include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 609
struct cgroup_taskset;
#line 617 "include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *base_cftypes ;
};
#line 919 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 3161 "include/linux/security.h"
struct mnt_namespace;
#line 3162
struct ipc_namespace;
#line 3163 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 104 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 180 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 547 "include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
};
#line 28 "include/linux/if_link.h"
struct netpoll_info;
#line 29
struct phy_device;
#line 61 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 106 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 125 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 186
struct neigh_parms;
#line 207 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 212 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 241 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 292 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 336
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 384 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 385 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 522
struct Qdisc;
#line 522 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 591 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 603 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 615 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 666 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 689 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 702 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 713 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 724 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 740 "include/linux/netdevice.h"
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 753 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_adj_list_246 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_247 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1187
struct iw_handler_def;
#line 1187
struct iw_public_data;
#line 1187
struct forwarding_accel_ops;
#line 1187
struct vlan_info;
#line 1187
struct tipc_bearer;
#line 1187
struct in_device;
#line 1187
struct dn_dev;
#line 1187
struct inet6_dev;
#line 1187
struct cpu_rmap;
#line 1187
struct pcpu_lstats;
#line 1187
struct pcpu_sw_netstats;
#line 1187
struct pcpu_dstats;
#line 1187
struct pcpu_vstats;
#line 1187 "include/linux/netdevice.h"
union __anonunion_ldv_40510_248 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1187
struct garp_port;
#line 1187
struct mrp_port;
#line 1187
struct rtnl_link_ops;
#line 1187 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct __anonstruct_adj_list_246 adj_list ;
   struct __anonstruct_all_adj_list_247 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_t carrier_changes ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct forwarding_accel_ops  const  *fwd_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion_ldv_40510_248 ldv_40510 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 1806 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 430 "include/linux/debugfs.h"
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NUM_NL80211_IFTYPES = 11,
    NL80211_IFTYPE_MAX = 10
} ;
#line 2211 "./include/uapi/linux/nl80211.h"
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
} ;
#line 2259
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
} ;
#line 2266
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
} ;
#line 2381
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
} ;
#line 2422
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
} ;
#line 2440
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
} ;
#line 3431 "./include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};
#line 3544 "./include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};
#line 3556 "./include/uapi/linux/nl80211.h"
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};
#line 3776
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
} ;
#line 3798 "./include/uapi/linux/nl80211.h"
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};
#line 1137 "include/linux/ieee80211.h"
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};
#line 1162 "include/linux/ieee80211.h"
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};
#line 1272 "include/linux/ieee80211.h"
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};
#line 1353 "include/linux/ieee80211.h"
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};
#line 2353
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
} ;
#line 2359 "include/linux/ieee80211.h"
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};
#line 97 "include/net/regulatory.h"
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};
#line 154 "include/net/regulatory.h"
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};
#line 159 "include/net/regulatory.h"
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};
#line 166 "include/net/regulatory.h"
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};
#line 174
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
} ;
#line 196 "include/net/regulatory.h"
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
   int max_power ;
   int max_reg_power ;
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
   int orig_mpwr ;
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
   unsigned int dfs_cac_ms ;
};
#line 192 "include/net/cfg80211.h"
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};
#line 235 "include/net/cfg80211.h"
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};
#line 255 "include/net/cfg80211.h"
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};
#line 271 "include/net/cfg80211.h"
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
   int n_bitrates ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};
#line 350 "include/net/cfg80211.h"
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};
#line 566 "include/net/cfg80211.h"
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};
#line 629 "include/net/cfg80211.h"
struct mac_address {
   u8 addr[6U] ;
};
#line 1356 "include/net/cfg80211.h"
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};
#line 1487
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
} ;
#line 1688 "include/net/cfg80211.h"
struct cfg80211_ibss_params {
   u8 const   *ssid ;
   u8 const   *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const   *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};
#line 1736 "include/net/cfg80211.h"
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const   *bssid ;
   u8 const   *bssid_hint ;
   u8 const   *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const   *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
#line 1836 "include/net/cfg80211.h"
struct cfg80211_pkt_pattern {
   u8 const   *mask ;
   u8 const   *pattern ;
   int pattern_len ;
   int pkt_offset ;
};
#line 1853 "include/net/cfg80211.h"
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
   u8 const   *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const   *wake_data ;
   u8 const   *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};
#line 1888 "include/net/cfg80211.h"
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
};
#line 2598 "include/net/cfg80211.h"
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};
#line 2658 "include/net/cfg80211.h"
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit  const  *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};
#line 2730 "include/net/cfg80211.h"
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};
#line 2745 "include/net/cfg80211.h"
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature  const  *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};
#line 2769 "include/net/cfg80211.h"
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
   struct wiphy_wowlan_tcp_support  const  *tcp ;
};
#line 2788 "include/net/cfg80211.h"
struct wiphy_coalesce_support {
   int n_rules ;
   int max_delay ;
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};
#line 2813 "include/net/cfg80211.h"
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy * , struct wireless_dev * , void const   * , int  ) ;
};
#line 2834 "include/net/cfg80211.h"
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes  const  *mgmt_stypes ;
   struct ieee80211_iface_combination  const  *iface_combinations ;
   int n_iface_combinations ;
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
   u32 const   *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support  const  *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const   *extended_capabilities ;
   u8 const   *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const   *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy * , struct regulatory_request * ) ;
   struct ieee80211_regdomain  const  *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap  const  *ht_capa_mod_mask ;
   struct ieee80211_vht_cap  const  *vht_capa_mod_mask ;
   struct net *_net ;
   struct iw_handler_def  const  *wext ;
   struct wiphy_coalesce_support  const  *coalesce ;
   struct wiphy_vendor_command  const  *vendor_commands ;
   struct nl80211_vendor_cmd_info  const  *vendor_events ;
   int n_vendor_commands ;
   int n_vendor_events ;
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};
#line 3200
struct cfg80211_conn;
#line 3201
struct cfg80211_internal_bss;
#line 3202
struct cfg80211_cached_keys;
#line 3203 "include/net/cfg80211.h"
struct __anonstruct_wext_290 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const   *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};
#line 3203 "include/net/cfg80211.h"
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
   int beacon_interval ;
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
   unsigned int cac_time_ms ;
   u32 owner_nlportid ;
   struct __anonstruct_wext_290 wext ;
};
#line 4845 "include/net/cfg80211.h"
struct rtw_queue {
   struct list_head queue ;
   spinlock_t lock ;
};
#line 69 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
struct wlan_phy_info {
   u8 SignalStrength ;
   u8 SignalQuality ;
   u8 Optimum_antenna ;
   u8 Reserved_0 ;
};
#line 76 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
struct wlan_bcn_info {
   u8 encryp_protocol ;
   int group_cipher ;
   int pairwise_cipher ;
   int is_8021x ;
   unsigned short ht_cap_info ;
   unsigned char ht_info_infos_0 ;
};
#line 89 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
struct wlan_bssid_ex {
   u32 Length ;
   u8 MacAddress[6U] ;
   u16 reserved ;
   struct cfg80211_ssid Ssid ;
   u32 Privacy ;
   long Rssi ;
   u16 BeaconPeriod ;
   u32 ATIMWindow ;
   u32 DSConfig ;
   enum nl80211_iftype ifmode ;
   unsigned char SupportedRates[16U] ;
   struct wlan_phy_info PhyInfo ;
   u32 IELength ;
   u8 IEs[768U] ;
};
#line 111 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
struct wlan_network {
   struct list_head list ;
   int network_type ;
   int fixed ;
   unsigned long last_scanned ;
   int aid ;
   int join_res ;
   struct wlan_bssid_ex network ;
   struct wlan_bcn_info BcnInfo ;
};
#line 78 "drivers/staging/rtl8723au/include/wifi.h"
struct __anonstruct_HT_cap_element_292 {
   unsigned short HT_caps_info ;
   unsigned char AMPDU_para ;
   unsigned char MCS_rate[16U] ;
   unsigned short HT_ext_caps ;
   unsigned int Beamforming_caps ;
   unsigned char ASEL_caps ;
};
#line 78 "drivers/staging/rtl8723au/include/wifi.h"
union __anonunion_u_291 {
   struct __anonstruct_HT_cap_element_292 HT_cap_element ;
   unsigned char HT_cap[26U] ;
};
#line 78 "drivers/staging/rtl8723au/include/wifi.h"
struct HT_caps_element {
   union __anonunion_u_291 u ;
};
#line 92 "drivers/staging/rtl8723au/include/wifi.h"
struct HT_info_element {
   unsigned char primary_channel ;
   unsigned char infos[5U] ;
   unsigned char MCS_rate[16U] ;
};
#line 98 "drivers/staging/rtl8723au/include/wifi.h"
struct AC_param {
   unsigned char ACI_AIFSN ;
   unsigned char CW ;
   unsigned short TXOP_limit ;
};
#line 104 "drivers/staging/rtl8723au/include/wifi.h"
struct WMM_para_element {
   unsigned char QoS_info ;
   unsigned char reserved ;
   struct AC_param ac_param[4U] ;
};
#line 110 "drivers/staging/rtl8723au/include/wifi.h"
struct ADDBA_request {
   unsigned char dialog_token ;
   unsigned short BA_para_set ;
   unsigned short BA_timeout_value ;
   unsigned short BA_starting_seqctrl ;
};
#line 117 "drivers/staging/rtl8723au/include/wifi.h"
struct ht_priv {
   u32 ht_option ;
   u32 ampdu_enable ;
   u32 tx_amsdu_enable ;
   u32 tx_amdsu_maxlen ;
   u32 rx_ampdu_maxlen ;
   u8 bwmode ;
   u8 ch_offset ;
   u8 sgi ;
   u16 agg_enable_bitmap ;
   u16 candidate_tid_bitmap ;
   struct ieee80211_ht_cap ht_cap ;
};
#line 101 "drivers/staging/rtl8723au/include/rtw_ht.h"
enum led_ctl_mode {
    LED_CTL_POWER_ON = 1,
    LED_CTL_LINK = 2,
    LED_CTL_NO_LINK = 3,
    LED_CTL_TX = 4,
    LED_CTL_RX = 5,
    LED_CTL_SITE_SURVEY = 6,
    LED_CTL_POWER_OFF = 7,
    LED_CTL_START_TO_LINK = 8,
    LED_CTL_START_WPS = 9,
    LED_CTL_STOP_WPS = 10,
    LED_CTL_START_WPS_BOTTON = 11,
    LED_CTL_STOP_WPS_FAIL = 12,
    LED_CTL_STOP_WPS_FAIL_OVERLAP = 13,
    LED_CTL_CONNECTION_NO_TRANSFER = 14
} ;
#line 118
enum led_state_872x {
    LED_UNKNOWN = 0,
    RTW_LED_ON = 1,
    RTW_LED_OFF = 2,
    LED_BLINK_NORMAL = 3,
    LED_BLINK_SLOWLY = 4,
    LED_BLINK_POWER_ON = 5,
    LED_BLINK_SCAN = 6,
    LED_BLINK_NO_LINK = 7,
    LED_BLINK_StartToBlink = 8,
    LED_BLINK_TXRX = 9,
    LED_BLINK_WPS = 10,
    LED_BLINK_WPS_STOP = 11,
    LED_BLINK_WPS_STOP_OVERLAP = 12,
    LED_BLINK_RUNTOP = 13,
    LED_BLINK_CAMEO = 14,
    LED_BLINK_XAVI = 15,
    LED_BLINK_ALWAYS_ON = 16
} ;
#line 138
enum led_pin_8723a {
    LED_PIN_NULL = 0,
    LED_PIN_LED0 = 1,
    LED_PIN_LED1 = 2,
    LED_PIN_LED2 = 3,
    LED_PIN_GPIO0 = 4
} ;
#line 146
struct rtw_adapter;
#line 146 "drivers/staging/rtl8723au/include/rtw_ht.h"
struct led_8723a {
   struct rtw_adapter *padapter ;
   enum led_pin_8723a LedPin ;
   enum led_state_872x CurrLedState ;
   enum led_state_872x BlinkingLedState ;
   u8 bLedOn ;
   u8 bLedBlinkInProgress ;
   u8 bLedWPSBlinkInProgress ;
   u32 BlinkTimes ;
   struct timer_list BlinkTimer ;
   u8 bSWLedCtrl ;
   u8 bLedNoLinkBlinkInProgress ;
   u8 bLedLinkBlinkInProgress ;
   u8 bLedStartToLinkBlinkInProgress ;
   u8 bLedScanBlinkInProgress ;
   struct work_struct BlinkWorkItem ;
};
#line 126 "drivers/staging/rtl8723au/include/rtw_led.h"
enum led_strategy_8723a {
    SW_LED_MODE0 = 0,
    SW_LED_MODE1 = 1,
    SW_LED_MODE2 = 2,
    SW_LED_MODE3 = 3,
    SW_LED_MODE4 = 4,
    SW_LED_MODE5 = 5,
    SW_LED_MODE6 = 6,
    HW_LED = 50,
    LED_ST_NONE = 99
} ;
#line 151 "drivers/staging/rtl8723au/include/rtw_led.h"
struct led_priv {
   struct led_8723a SwLed0 ;
   struct led_8723a SwLed1 ;
   enum led_strategy_8723a LedStrategy ;
   u8 bRegUseLed ;
   void (*LedControlHandler)(struct rtw_adapter * , enum led_ctl_mode  ) ;
};
#line 240 "drivers/staging/rtl8723au/include/ieee80211.h"
struct rtw_ieee80211_channel {
   u16 hw_value ;
   u32 flags ;
};
#line 440
struct registry_priv;
#line 454 "drivers/staging/rtl8723au/include/ieee80211.h"
struct cmd_obj {
   struct work_struct work ;
   struct rtw_adapter *padapter ;
   u16 cmdcode ;
   int res ;
   u32 cmdsz ;
   u8 *parmbuf ;
   u8 *rsp ;
   u32 rspsz ;
};
#line 44 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct cmd_priv {
   struct workqueue_struct *wq ;
   u32 cmd_issued_cnt ;
   u32 cmd_done_cnt ;
   u32 rsp_cnt ;
   struct rtw_adapter *padapter ;
};
#line 52 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct evt_priv {
   struct workqueue_struct *wq ;
   struct work_struct irq_wk ;
};
#line 59 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct c2h_evt_hdr {
   unsigned char id : 4 ;
   unsigned char plen : 4 ;
   u8 seq ;
   u8 payload[0U] ;
};
#line 75 "drivers/staging/rtl8723au/include/rtw_cmd.h"
union __anonunion_u_300 {
   struct c2h_evt_hdr c2h_evt ;
   u8 buf[16U] ;
};
#line 75 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct evt_work {
   union __anonunion_u_300 u ;
   struct work_struct work ;
   struct rtw_adapter *adapter ;
};
#line 150 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct disconnect_parm {
   u32 deauth_timeout_ms ;
};
#line 171 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct setopmode_parm {
   enum nl80211_iftype mode ;
};
#line 175 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct sitesurvey_parm {
   int scan_mode ;
   u8 ssid_num ;
   u8 ch_num ;
   struct cfg80211_ssid ssid[9U] ;
   struct rtw_ieee80211_channel ch[51U] ;
};
#line 228 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_stakey_parm {
   u8 addr[6U] ;
   u8 id ;
   u32 algorithm ;
   u8 key[16U] ;
};
#line 244 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_stakey_rsp {
   u8 addr[6U] ;
   u8 keyid ;
   u8 rsvd ;
};
#line 250 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_assocsta_parm {
   u8 addr[6U] ;
};
#line 264 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_assocsta_rsp {
   u8 cam_id ;
   u8 rsvd[3U] ;
};
#line 457 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct drvextra_cmd_parm {
   int ec_id ;
   int type_size ;
   unsigned char *pbuf ;
};
#line 622 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct addBaReq_parm {
   unsigned int tid ;
   u8 addr[6U] ;
};
#line 627 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct set_ch_parm {
   u8 ch ;
   u8 bw ;
   u8 ch_offset ;
};
#line 737 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct _cmd_callback {
   u32 cmd_code ;
   void (*callback)(struct rtw_adapter * , struct cmd_obj * ) ;
};
#line 109 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct hw_xmit {
   struct rtw_queue *sta_queue ;
   int accnt ;
};
#line 114
struct sta_info;
#line 157 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct submit_ctx {
   u32 timeout_ms ;
   int status ;
   struct completion done ;
};
#line 200
struct urb;
#line 238 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct tx_servq {
   struct list_head tx_pending ;
   struct rtw_queue sta_pending ;
   int qcnt ;
};
#line 244 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct sta_xmit_priv {
   spinlock_t lock ;
   int option ;
   int apsd_setting ;
   struct tx_servq be_q ;
   struct tx_servq bk_q ;
   struct tx_servq vi_q ;
   struct tx_servq vo_q ;
   struct list_head legacy_dz ;
   struct list_head apsd ;
   u16 txseq_tid[16U] ;
};
#line 275 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct xmit_priv {
   spinlock_t lock ;
   struct semaphore xmit_sema ;
   struct semaphore terminate_xmitthread_sema ;
   struct rtw_queue be_pending ;
   struct rtw_queue bk_pending ;
   struct rtw_queue vi_pending ;
   struct rtw_queue vo_pending ;
   struct rtw_queue bm_pending ;
   int free_xmitframe_cnt ;
   struct rtw_queue free_xmit_queue ;
   int free_xframe_ext_cnt ;
   struct rtw_queue free_xframe_ext_queue ;
   uint frag_len ;
   struct rtw_adapter *adapter ;
   u8 vcs_setting ;
   u8 vcs ;
   u8 vcs_type ;
   u64 tx_bytes ;
   u64 tx_pkts ;
   u64 tx_drop ;
   u64 last_tx_bytes ;
   u64 last_tx_pkts ;
   struct hw_xmit *hwxmits ;
   u8 hwxmit_entry ;
   u8 wmm_para_seq[4U] ;
   struct semaphore tx_retevt ;
   u8 txirp_cnt ;
   struct tasklet_struct xmit_tasklet ;
   int beq_cnt ;
   int bkq_cnt ;
   int viq_cnt ;
   int voq_cnt ;
   struct rtw_queue free_xmitbuf_queue ;
   struct list_head xmitbuf_list ;
   struct rtw_queue pending_xmitbuf_queue ;
   uint free_xmitbuf_cnt ;
   struct rtw_queue free_xmit_extbuf_queue ;
   struct list_head xmitextbuf_list ;
   uint free_xmit_extbuf_cnt ;
   u16 nqos_ssn ;
   int ack_tx ;
   struct mutex ack_tx_mutex ;
   struct submit_ctx ack_tx_ops ;
   spinlock_t lock_sctx ;
};
#line 229 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
struct recv_reorder_ctrl {
   struct rtw_adapter *padapter ;
   u8 enable ;
   u16 indicate_seq ;
   u16 wend_b ;
   u8 wsize_b ;
   struct rtw_queue pending_recvframe_queue ;
   struct timer_list reordering_ctrl_timer ;
};
#line 42 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct stainfo_rxcache {
   u16 tid_rxseq[16U] ;
};
#line 71 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct signal_stat {
   u8 update_req ;
   u8 avg_val ;
   u32 total_num ;
   u32 total_val ;
};
#line 161 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_priv {
   spinlock_t lock ;
   struct rtw_queue free_recv_queue ;
   struct rtw_queue recv_pending_queue ;
   struct rtw_queue uc_swdec_pending_queue ;
   int free_recvframe_cnt ;
   struct rtw_adapter *adapter ;
   u32 bIsAnyNonBEPkts ;
   u64 rx_bytes ;
   u64 rx_pkts ;
   u64 rx_drop ;
   u64 last_rx_bytes ;
   uint rx_icv_err ;
   uint rx_largepacket_crcerr ;
   uint rx_smallpacket_crcerr ;
   uint rx_middlepacket_crcerr ;
   u8 rx_pending_cnt ;
   struct urb *int_in_urb ;
   u8 *int_in_buf ;
   struct tasklet_struct irq_prepare_beacon_tasklet ;
   struct tasklet_struct recv_tasklet ;
   struct sk_buff_head free_recv_skb_queue ;
   struct sk_buff_head rx_skb_queue ;
   u8 *precv_buf ;
   u8 is_signal_dbg ;
   u8 signal_strength_dbg ;
   s8 rssi ;
   s8 rxpwdb ;
   u8 signal_strength ;
   u8 signal_qual ;
   u8 noise ;
   int RxSNRdB[2U] ;
   s8 RxRssi[2U] ;
   int FalseAlmCnt_all ;
   struct timer_list signal_stat_timer ;
   u32 signal_stat_sampling_interval ;
   struct signal_stat signal_qual_data ;
   struct signal_stat signal_strength_data ;
};
#line 220 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct sta_recv_priv {
   spinlock_t lock ;
   int option ;
   struct rtw_queue defrag_q ;
   struct stainfo_rxcache rxcache ;
};
#line 132 "include/net/lib80211.h"
struct __anonstruct__byte__301 {
   u8 TSC0 ;
   u8 TSC1 ;
   u8 TSC2 ;
   u8 TSC3 ;
   u8 TSC4 ;
   u8 TSC5 ;
   u8 TSC6 ;
   u8 TSC7 ;
};
#line 132 "include/net/lib80211.h"
union pn48 {
   u64 val ;
   struct __anonstruct__byte__301 _byte_ ;
};
#line 64 "drivers/staging/rtl8723au/include/rtw_security.h"
union Keytype {
   u8 skey[16U] ;
   u32 lkey[4U] ;
};
#line 87 "drivers/staging/rtl8723au/include/rtw_security.h"
struct rtw_wep_key {
   u8 key[14U] ;
   u16 keylen ;
};
#line 92 "drivers/staging/rtl8723au/include/rtw_security.h"
struct rt_pmkid_list {
   u8 bUsed ;
   u8 Bssid[6U] ;
   u8 PMKID[16U] ;
   u8 SsidBuf[33U] ;
   u8 *ssid_octet ;
   u16 ssid_length ;
};
#line 101 "drivers/staging/rtl8723au/include/rtw_security.h"
struct security_priv {
   u32 dot11AuthAlgrthm ;
   u32 dot11PrivacyAlgrthm ;
   u32 dot11PrivacyKeyIndex ;
   struct rtw_wep_key wep_key[4U] ;
   u32 dot118021XGrpPrivacy ;
   u32 dot118021XGrpKeyid ;
   union Keytype dot118021XGrpKey[4U] ;
   union Keytype dot118021XGrptxmickey[4U] ;
   union Keytype dot118021XGrprxmickey[4U] ;
   union pn48 dot11Grptxpn ;
   union pn48 dot11Grprxpn ;
   unsigned int dot8021xalg ;
   unsigned int wpa_psk ;
   unsigned int wpa_group_cipher ;
   unsigned int wpa2_group_cipher ;
   unsigned int wpa_pairwise_cipher ;
   unsigned int wpa2_pairwise_cipher ;
   u8 wps_ie[512U] ;
   int wps_ie_len ;
   unsigned char binstallGrpkey : 1 ;
   unsigned char busetkipkey : 1 ;
   unsigned char bcheck_grpkey : 1 ;
   unsigned char hw_decrypted : 1 ;
   u32 ndisauthtype ;
   u32 ndisencryptstatus ;
   struct wlan_bssid_ex sec_bss ;
   u8 assoc_info[600U] ;
   u8 szofcapability[256U] ;
   u8 oidassociation[512U] ;
   u8 authenticator_ie[256U] ;
   u8 supplicant_ie[256U] ;
   unsigned long last_mic_err_time ;
   u8 btkip_countermeasure ;
   u8 btkip_wait_report ;
   unsigned long btkip_countermeasure_time ;
   struct rt_pmkid_list PMKIDList[16U] ;
   u8 PMKIDIndex ;
   u8 bWepDefaultKeyIdxSet ;
};
#line 98 "drivers/staging/rtl8723au/include/rtw_pwrctrl.h"
enum rt_rf_power_state {
    rf_on = 0,
    rf_sleep = 1,
    rf_off = 2,
    rf_max = 3
} ;
#line 119 "drivers/staging/rtl8723au/include/rtw_pwrctrl.h"
struct pwrctrl_priv {
   struct semaphore lock ;
   u8 volatile   rpwm ;
   u8 volatile   cpwm ;
   u8 volatile   tog ;
   u8 volatile   cpwm_tog ;
   u8 pwr_mode ;
   u8 smart_ps ;
   u8 bcn_ant_mode ;
   u32 alives ;
   struct work_struct cpwm_event ;
   u8 bpower_saving ;
   u8 reg_rfoff ;
   u8 reg_pdnmode ;
   u32 rfoff_reason ;
   u32 cur_ps_level ;
   u32 reg_rfps_level ;
   uint ips_enter23a_cnts ;
   uint ips_leave23a_cnts ;
   u8 ips_mode ;
   u8 ips_mode_req ;
   uint bips_processing ;
   unsigned long ips_deny_time ;
   u8 ps_processing ;
   u8 bLeisurePs ;
   u8 LpsIdleCount ;
   u8 power_mgnt ;
   u8 bFwCurrentInPSMode ;
   unsigned long DelayLPSLastTimeStamp ;
   u8 btcoex_rfon ;
   s32 pnp_current_pwr_state ;
   u8 pnp_bstop_trx ;
   u8 bInSuspend ;
   u8 bAutoResume ;
   u8 autopm_cnt ;
   u8 bSupportRemoteWakeup ;
   struct timer_list pwr_state_check_timer ;
   int pwr_state_check_interval ;
   u8 pwr_state_check_cnts ;
   int ps_flag ;
   enum rt_rf_power_state rf_pwrstate ;
   enum rt_rf_power_state change_rfpwrstate ;
   u8 wepkeymask ;
   u8 bHWPowerdown ;
   u8 bHWPwrPindetect ;
   u8 bkeepfwalive ;
   u8 brfoffbyhw ;
   unsigned long PS_BBRegBackup[4U] ;
};
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 253 "include/uapi/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
#line 275 "include/uapi/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
#line 343 "include/uapi/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
#line 363 "include/uapi/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
#line 613 "include/uapi/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
#line 692 "include/uapi/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
#line 751 "include/uapi/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
#line 801 "include/uapi/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
#line 811 "include/uapi/linux/usb/ch9.h"
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
#line 840 "include/uapi/linux/usb/ch9.h"
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
#line 905
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 914
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 272 "include/linux/pm_runtime.h"
struct usb_device;
#line 274
struct wusb_dev;
#line 275
struct ep_device;
#line 276 "include/linux/pm_runtime.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
   int streams ;
};
#line 77 "include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
#line 92
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 99 "include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char reset_running : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 206 "include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
#line 235 "include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
#line 299 "include/linux/usb.h"
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
#line 311 "include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
#line 323
struct mon_bus;
#line 323 "include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 374
struct usb_tt;
#line 375
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
#line 388 "include/linux/usb.h"
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
#line 409 "include/linux/usb.h"
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
#line 448 "include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
#line 1179 "include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 1221 "include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
#line 1241 "include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
#line 240 "drivers/staging/rtl8723au/include/rtw_io.h"
struct eeprom_priv {
   u8 bautoload_fail_flag ;
   u8 bloadfile_fail_flag ;
   u8 bloadmac_fail_flag ;
   u8 mac_addr[6U] ;
   u16 channel_plan ;
   u8 EepromOrEfuse ;
   u8 efuse_eeprom_data[512U] ;
};
#line 134 "drivers/staging/rtl8723au/include/rtw_eeprom.h"
struct rtw_wlan_acl_node {
   struct list_head list ;
   u8 addr[6U] ;
   u8 valid ;
};
#line 34 "drivers/staging/rtl8723au/include/sta_info.h"
struct wlan_acl_pool {
   int mode ;
   int num ;
   struct rtw_wlan_acl_node aclnode[16U] ;
   struct rtw_queue acl_node_q ;
};
#line 44 "drivers/staging/rtl8723au/include/sta_info.h"
struct rssi_sta {
   s32 UndecoratedSmoothedPWDB ;
   s32 UndecoratedSmoothedCCK ;
   s32 UndecoratedSmoothedOFDM ;
   u64 PacketMap ;
   u8 ValidBit ;
};
#line 52 "drivers/staging/rtl8723au/include/sta_info.h"
struct stainfo_stats {
   u64 rx_mgnt_pkts ;
   u64 rx_beacon_pkts ;
   u64 rx_probereq_pkts ;
   u64 rx_probersp_pkts ;
   u64 rx_probersp_bm_pkts ;
   u64 rx_probersp_uo_pkts ;
   u64 rx_ctrl_pkts ;
   u64 rx_data_pkts ;
   u64 last_rx_mgnt_pkts ;
   u64 last_rx_beacon_pkts ;
   u64 last_rx_probereq_pkts ;
   u64 last_rx_probersp_pkts ;
   u64 last_rx_probersp_bm_pkts ;
   u64 last_rx_probersp_uo_pkts ;
   u64 last_rx_ctrl_pkts ;
   u64 last_rx_data_pkts ;
   u64 rx_bytes ;
   u64 rx_drops ;
   u64 tx_pkts ;
   u64 tx_bytes ;
   u64 tx_drops ;
};
#line 79 "drivers/staging/rtl8723au/include/sta_info.h"
struct sta_info {
   spinlock_t lock ;
   struct list_head list ;
   struct list_head hash_list ;
   struct rtw_adapter *padapter ;
   struct sta_xmit_priv sta_xmitpriv ;
   struct sta_recv_priv sta_recvpriv ;
   struct rtw_queue sleep_q ;
   unsigned int sleepq_len ;
   uint state ;
   uint aid ;
   uint mac_id ;
   uint qos_option ;
   u8 hwaddr[6U] ;
   uint ieee8021x_blocked ;
   u32 dot118021XPrivacy ;
   union Keytype dot11tkiptxmickey ;
   union Keytype dot11tkiprxmickey ;
   union Keytype dot118021x_UncstKey ;
   union pn48 dot11txpn ;
   union pn48 dot11rxpn ;
   u8 bssrateset[16U] ;
   u32 bssratelen ;
   s32 rssi ;
   s32 signal_quality ;
   u8 cts2self ;
   u8 rtsen ;
   u8 raid ;
   u8 init_rate ;
   u32 ra_mask ;
   u8 wireless_mode ;
   struct stainfo_stats sta_stats ;
   struct timer_list addba_retry_timer ;
   struct recv_reorder_ctrl recvreorder_ctrl[16U] ;
   u16 BA_starting_seqctrl[16U] ;
   struct ht_priv htpriv ;
   struct list_head asoc_list ;
   struct list_head auth_list ;
   unsigned int expire_to ;
   unsigned int auth_seq ;
   unsigned int authalg ;
   unsigned char chg_txt[128U] ;
   u16 capability ;
   int flags ;
   int dot8021xalg ;
   int wpa_psk ;
   int wpa_group_cipher ;
   int wpa2_group_cipher ;
   int wpa_pairwise_cipher ;
   int wpa2_pairwise_cipher ;
   u8 bpairwise_key_installed ;
   u8 wpa_ie[32U] ;
   u8 nonerp_set ;
   u8 no_short_slot_time_set ;
   u8 no_short_preamble_set ;
   u8 no_ht_gf_set ;
   u8 no_ht_set ;
   u8 ht_20mhz_set ;
   unsigned int tx_ra_bitmap ;
   u8 qos_info ;
   u8 max_sp_len ;
   u8 uapsd_bk ;
   u8 uapsd_be ;
   u8 uapsd_vi ;
   u8 uapsd_vo ;
   u8 has_legacy_ac ;
   unsigned int sleepq_ac_len ;
   u8 is_p2p_device ;
   u8 p2p_status_code ;
   u8 keep_alive_trycnt ;
   u8 dev_addr[6U] ;
   u8 dev_cap ;
   u16 config_methods ;
   u8 primary_dev_type[8U] ;
   u8 num_of_secdev_type ;
   u8 secdev_types_list[32U] ;
   u16 dev_name_len ;
   u8 dev_name[32U] ;
   u8 *passoc_req ;
   u32 assoc_req_len ;
   struct rssi_sta rssi_stat ;
   u8 bValid ;
   u8 rssi_level ;
   u8 RSSI_Path[4U] ;
   u8 RSSI_Ave ;
   u8 RXEVM[4U] ;
   u8 RXSNR[4U] ;
   u16 RxMgmtFrameSeqNum ;
};
#line 230 "drivers/staging/rtl8723au/include/sta_info.h"
struct sta_priv {
   spinlock_t sta_hash_lock ;
   struct list_head sta_hash[32U] ;
   int asoc_sta_count ;
   struct rtw_adapter *padapter ;
   struct list_head asoc_list ;
   struct list_head auth_list ;
   spinlock_t asoc_list_lock ;
   spinlock_t auth_list_lock ;
   u8 asoc_list_cnt ;
   u8 auth_list_cnt ;
   unsigned int auth_to ;
   unsigned int assoc_to ;
   unsigned int expire_to ;
   struct sta_info *sta_aid[32U] ;
   u16 sta_dz_bitmap ;
   u16 tim_bitmap ;
   u16 max_num_sta ;
   struct wlan_acl_pool acl_list ;
};
#line 31 "drivers/staging/rtl8723au/include/mlme_osdep.h"
enum rt_scan_type {
    SCAN_PASSIVE = 0,
    SCAN_ACTIVE = 1,
    SCAN_MIX = 2
} ;
#line 43 "drivers/staging/rtl8723au/include/mlme_osdep.h"
struct rt_link_detect {
   u32 NumTxOkInPeriod ;
   u32 NumRxOkInPeriod ;
   u32 NumRxUnicastOkInPeriod ;
   bool bBusyTraffic ;
   bool bTxBusyTraffic ;
   bool bRxBusyTraffic ;
   bool bHigherBusyTraffic ;
   bool bHigherBusyRxTraffic ;
   bool bHigherBusyTxTraffic ;
};
#line 111 "drivers/staging/rtl8723au/include/rtw_mlme.h"
struct mlme_priv {
   spinlock_t lock ;
   int fw_state ;
   u8 bScanInProcess ;
   u8 to_join ;
   u8 to_roaming ;
   struct rtw_adapter *nic_hdl ;
   u8 not_indic_disco ;
   struct rtw_queue scanned_queue ;
   struct cfg80211_ssid assoc_ssid ;
   u8 assoc_bssid[6U] ;
   struct wlan_network cur_network ;
   u32 scan_interval ;
   struct timer_list assoc_timer ;
   uint assoc_by_bssid ;
   uint assoc_by_rssi ;
   struct timer_list scan_to_timer ;
   struct timer_list set_scan_deny_timer ;
   atomic_t set_scan_deny ;
   unsigned int qos_option ;
   int num_sta_no_ht ;
   int num_FortyMHzIntolerant ;
   struct ht_priv htpriv ;
   struct rt_link_detect LinkDetectInfo ;
   struct timer_list dynamic_chk_timer ;
   u8 key_mask ;
   u8 acm_mask ;
   u8 ChannelPlan ;
   enum rt_scan_type scan_mode ;
   u8 *wps_probe_req_ie ;
   u32 wps_probe_req_ie_len ;
   u8 *assoc_req ;
   u32 assoc_req_len ;
   u32 assoc_rsp_len ;
   u8 *assoc_rsp ;
   u32 wps_assoc_resp_ie_len ;
   u8 *wps_assoc_resp_ie ;
   u8 *wps_probe_resp_ie ;
   u32 wps_probe_resp_ie_len ;
   u8 *wps_beacon_ie ;
   u32 wps_beacon_ie_len ;
   u32 p2p_go_probe_resp_ie_len ;
   u32 p2p_assoc_req_ie_len ;
   u8 *p2p_beacon_ie ;
   u8 *p2p_probe_req_ie ;
   u8 *p2p_probe_resp_ie ;
   u8 *p2p_go_probe_resp_ie ;
   u8 *p2p_assoc_req_ie ;
   u32 p2p_beacon_ie_len ;
   u32 p2p_probe_req_ie_len ;
   u32 p2p_probe_resp_ie_len ;
   u8 *wfd_assoc_req_ie ;
   u32 wfd_assoc_req_ie_len ;
   int num_sta_non_erp ;
   int num_sta_no_short_slot_time ;
   int num_sta_no_short_preamble ;
   int olbc ;
   int num_sta_ht_no_gf ;
   int num_sta_ht_20mhz ;
   int olbc_ht ;
   u16 ht_op_mode ;
   spinlock_t bcn_update_lock ;
   u8 update_bcn ;
   u8 *wfd_beacon_ie ;
   u8 *wfd_probe_req_ie ;
   u8 *wfd_probe_resp_ie ;
   u8 *wfd_go_probe_resp_ie ;
   u32 wfd_beacon_ie_len ;
   u32 wfd_probe_req_ie_len ;
   u32 wfd_probe_resp_ie_len ;
   u32 wfd_go_probe_resp_ie_len ;
};
#line 272 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct ss_res {
   int state ;
   int bss_cnt ;
   int channel_idx ;
   int scan_mode ;
   u8 ssid_num ;
   u8 ch_num ;
   struct cfg80211_ssid ssid[9U] ;
   struct rtw_ieee80211_channel ch[51U] ;
};
#line 284 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct FW_Sta_Info {
   struct sta_info *psta ;
   u32 status ;
   u32 rx_pkt ;
   u32 retry ;
   unsigned char SupportedRates[16U] ;
};
#line 311 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct mlme_ext_info {
   u32 state ;
   u32 reauth_count ;
   u32 reassoc_count ;
   u32 link_count ;
   u32 auth_seq ;
   u32 auth_algo ;
   u32 authModeToggle ;
   u32 enc_algo ;
   u32 key_index ;
   u32 iv ;
   u8 chg_txt[128U] ;
   u16 aid ;
   u16 bcn_interval ;
   u16 capability ;
   u8 assoc_AP_vendor ;
   u8 slotTime ;
   u8 preamble_mode ;
   u8 WMM_enable ;
   u8 ERP_enable ;
   u8 ERP_IE ;
   u8 HT_enable ;
   u8 HT_caps_enable ;
   u8 HT_info_enable ;
   u8 HT_protection ;
   u8 turboMode_cts2self ;
   u8 turboMode_rtsen ;
   u8 SM_PS ;
   u8 ADDBA_retry_count ;
   u8 dialogToken ;
   bool bAcceptAddbaReq ;
   u8 bwmode_updated ;
   u8 hidden_ssid_mode ;
   struct ADDBA_request ADDBA_req ;
   struct WMM_para_element WMM_param ;
   struct HT_caps_element HT_caps ;
   struct HT_info_element HT_info ;
   struct wlan_bssid_ex network ;
   struct FW_Sta_Info FW_sta_info[32U] ;
};
#line 374 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_info {
   u8 ChannelNum ;
   enum rt_scan_type ScanType ;
};
#line 382 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct p2p_reg_class {
   u8 reg_class ;
   u8 channel[20U] ;
   size_t channels ;
};
#line 402 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct p2p_channels {
   struct p2p_reg_class reg_class[10U] ;
   size_t reg_classes ;
};
#line 417 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct mlme_ext_priv {
   struct rtw_adapter *padapter ;
   u8 mlmeext_init ;
   atomic_t event_seq ;
   u16 mgnt_seq ;
   unsigned char cur_channel ;
   unsigned char cur_bwmode ;
   unsigned char cur_ch_offset ;
   unsigned char cur_wireless_mode ;
   unsigned char max_chan_nums ;
   struct rt_channel_info channel_set[38U] ;
   struct p2p_channels channel_list ;
   unsigned char basicrate[13U] ;
   unsigned char datarate[13U] ;
   struct ss_res sitesurvey_res ;
   struct mlme_ext_info mlmext_info ;
   struct timer_list survey_timer ;
   struct timer_list link_timer ;
   u16 chan_scan_time ;
   u8 scan_abort ;
   u8 tx_rate ;
   u32 retry ;
   u64 TSFValue ;
   unsigned char bstart_bss ;
   u8 update_channel_plan_by_ap_done ;
   u8 action_public_dialog_token ;
   u16 action_public_rxseq ;
   u8 active_keep_alive_check ;
};
#line 610 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct cmd_hdl {
   uint parmsize ;
   int (*h2cfuns)(struct rtw_adapter * , u8 const   * ) ;
};
#line 68 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
struct registry_priv {
   u8 chip_version ;
   u8 rfintfs ;
   struct cfg80211_ssid ssid ;
   u8 channel ;
   u8 wireless_mode ;
   u8 scan_mode ;
   u8 preamble ;
   u8 vrtl_carrier_sense ;
   u8 vcs_type ;
   u16 rts_thresh ;
   u16 frag_thresh ;
   u8 adhoc_tx_pwr ;
   u8 soft_ap ;
   u8 power_mgnt ;
   u8 ips_mode ;
   u8 smart_ps ;
   u8 long_retry_lmt ;
   u8 short_retry_lmt ;
   u16 busy_thresh ;
   u8 ack_policy ;
   u8 software_encrypt ;
   u8 software_decrypt ;
   u8 acm_method ;
   u8 wmm_enable ;
   u8 uapsd_enable ;
   struct wlan_bssid_ex dev_network ;
   u8 ht_enable ;
   u8 cbw40_enable ;
   u8 ampdu_enable ;
   u8 rx_stbc ;
   u8 ampdu_amsdu ;
   u8 lowrate_two_xmit ;
   u8 rf_config ;
   u8 low_power ;
   u8 wifi_spec ;
   u8 channel_plan ;
   u8 btcoex ;
   u8 bt_iso ;
   u8 bt_sco ;
   u8 bt_ampdu ;
   bool bAcceptAddbaReq ;
   u8 antdiv_cfg ;
   u8 antdiv_type ;
   u8 usbss_enable ;
   u8 hwpdn_mode ;
   u8 hwpwrp_detect ;
   u8 hw_wps_pbc ;
   u8 max_roaming_times ;
   u8 enable80211d ;
   u8 ifname[16U] ;
   u8 if2name[16U] ;
   u8 notch_filter ;
   u8 regulatory_tid ;
};
#line 139 "drivers/staging/rtl8723au/include/drv_types.h"
struct dvobj_priv {
   struct rtw_adapter *if1 ;
   struct rtw_adapter *if2 ;
   struct mutex hw_init_mutex ;
   struct mutex h2c_fwcmd_mutex ;
   struct mutex setch_mutex ;
   struct mutex setbw_mutex ;
   unsigned char oper_channel ;
   unsigned char oper_bwmode ;
   unsigned char oper_ch_offset ;
   struct rtw_adapter *padapters[4U] ;
   u8 iface_nums ;
   u8 InterfaceNumber ;
   u8 NumInterfaces ;
   int RtInPipe[2U] ;
   int RtOutPipe[3U] ;
   u8 Queue2Pipe[8U] ;
   u8 nr_endpoint ;
   u8 ishighspeed ;
   u8 RtNumInPipes ;
   u8 RtNumOutPipes ;
   int ep_num[5U] ;
   struct mutex usb_vendor_req_mutex ;
   u8 *usb_alloc_vendor_req_buf ;
   u8 *usb_vendor_req_buf ;
   struct usb_interface *pusbintf ;
   struct usb_device *pusbdev ;
   atomic_t continual_urb_error ;
};
#line 210 "drivers/staging/rtl8723au/include/drv_types.h"
struct rtw_adapter {
   int pid[3U] ;
   int bDongle ;
   u16 chip_type ;
   u16 HardwareType ;
   struct dvobj_priv *dvobj ;
   struct mlme_priv mlmepriv ;
   struct mlme_ext_priv mlmeextpriv ;
   struct cmd_priv cmdpriv ;
   struct evt_priv evtpriv ;
   struct xmit_priv xmitpriv ;
   struct recv_priv recvpriv ;
   struct sta_priv stapriv ;
   struct security_priv securitypriv ;
   struct registry_priv registrypriv ;
   struct pwrctrl_priv pwrctrlpriv ;
   struct eeprom_priv eeprompriv ;
   struct led_priv ledpriv ;
   u32 setband ;
   void *HalData ;
   s32 bDriverStopped ;
   s32 bSurpriseRemoved ;
   s32 bCardDisableWOHSM ;
   u32 IsrContent ;
   u32 ImrContent ;
   u8 EepromAddressSize ;
   u8 hw_init_completed ;
   u8 bDriverIsGoingToUnload ;
   u8 init_adpt_in_progress ;
   u8 bHaltInProgress ;
   struct net_device *pnetdev ;
   int bup ;
   struct net_device_stats stats ;
   struct wireless_dev *rtw_wdev ;
   int net_closed ;
   u8 bFWReady ;
   u8 bReadPortCancel ;
   u8 bWritePortCancel ;
   u8 bNotifyChannelChange ;
   struct rtw_adapter *pbuddy_adapter ;
   u8 iface_id ;
};
#line 57 "drivers/staging/rtl8723au/include/rtl8723a_rf.h"
enum rt_media_status;
#line 57
enum rt_media_status;
#line 33 "drivers/staging/rtl8723au/include/odm_RegConfig8723A.h"
enum rt_media_status {
    RT_MEDIA_DISCONNECT = 0,
    RT_MEDIA_CONNECT = 1
} ;
#line 2059 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 2070 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 2081 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 2092 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 2103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___6;
#line 2114 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 2125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
typedef int ldv_func_ret_type___8;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 82 "drivers/staging/rtl8723au/include/osdep_service.h"
enum ndis_802_11_auth_mode {
    Ndis802_11AuthModeOpen = 0,
    Ndis802_11AuthModeShared = 1,
    Ndis802_11AuthModeAutoSwitch = 2,
    Ndis802_11AuthModeWPA = 3,
    Ndis802_11AuthModeWPAPSK = 4,
    Ndis802_11AuthModeWPANone = 5,
    dis802_11AuthModeMax = 6
} ;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 535
enum hrtimer_restart;
#line 2599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___9;
#line 2610 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___10;
#line 2621 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___11;
#line 2632 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___12;
#line 2643 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___13;
#line 2654 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___14;
#line 2665 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___15;
#line 2676 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___16;
#line 2687 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___17;
#line 2698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___18;
#line 2709 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___19;
#line 2720 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___20;
#line 2731 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___21;
#line 2742 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___22;
#line 2753 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___23;
#line 2764 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___24;
#line 2775 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___25;
#line 2786 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___26;
#line 2797 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___27;
#line 2808 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___28;
#line 2819 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___29;
#line 2830 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___30;
#line 2841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___31;
#line 2852 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___32;
#line 2863 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___33;
#line 2874 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___34;
#line 2885 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___35;
#line 2896 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___36;
#line 2907 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___37;
#line 2918 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___38;
#line 2929 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___39;
#line 2940 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___40;
#line 2951 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___41;
#line 2962 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___42;
#line 2973 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___43;
#line 2984 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___44;
#line 2995 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___45;
#line 3006 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___46;
#line 3017 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___47;
#line 3028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___48;
#line 3039 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___49;
#line 3050 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___50;
#line 3061 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___51;
#line 3072 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___52;
#line 3083 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___53;
#line 3094 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___54;
#line 3105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___55;
#line 3116 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___56;
#line 3127 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___57;
#line 3138 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___58;
#line 3149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___59;
#line 3160 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___60;
#line 3171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___61;
#line 3182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___62;
#line 3193 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___63;
#line 3204 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___64;
#line 3215 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___65;
#line 3226 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___66;
#line 3237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___67;
#line 3248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___68;
#line 3259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___69;
#line 3270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___70;
#line 3281 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___71;
#line 3292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___72;
#line 3303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___73;
#line 3314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___74;
#line 3325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___75;
#line 3336 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___76;
#line 3347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___77;
#line 3358 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___78;
#line 3369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___79;
#line 3380 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___80;
#line 3391 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___81;
#line 3402 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___82;
#line 3413 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___83;
#line 3424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___84;
#line 3435 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___85;
#line 3446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___86;
#line 3457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___87;
#line 3468 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___88;
#line 3479 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___89;
#line 3490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___90;
#line 3501 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___91;
#line 3512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___92;
#line 3523 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___93;
#line 3534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___94;
#line 3545 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___95;
#line 3556 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___96;
#line 3567 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___97;
#line 3578 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___98;
#line 3589 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___99;
#line 3600 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___100;
#line 3611 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___101;
#line 3622 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___102;
#line 3633 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___103;
#line 3644 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___104;
#line 3655 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___105;
#line 3666 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
typedef int ldv_func_ret_type___106;
#line 263 "include/linux/timer.h"
enum hrtimer_restart;
#line 2392 "./include/uapi/linux/nl80211.h"
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
} ;
#line 1389 "include/net/cfg80211.h"
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   u32 rates[3U] ;
   struct wireless_dev *wdev ;
   struct wiphy *wiphy ;
   unsigned long scan_start ;
   bool aborted ;
   bool notified ;
   bool no_cck ;
   struct ieee80211_channel *channels[0U] ;
};
#line 142 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
struct ieee80211_ht_addt_info {
   unsigned char control_chan ;
   unsigned char ht_param ;
   unsigned short operation_mode ;
   unsigned short stbc_param ;
   unsigned char basic_set[16U] ;
};
#line 194 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct setauth_parm {
   u8 mode ;
   u8 _1x ;
   u8 rsvd[2U] ;
};
#line 208 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct setkey_parm {
   u32 algorithm ;
   u8 keyid ;
   u8 grpkey ;
   u8 set_tx ;
   u8 key[16U] ;
};
#line 114 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct pkt_attrib {
   u16 type ;
   u8 bswenc ;
   u8 dhcp_pkt ;
   u16 ether_type ;
   u16 seqnum ;
   u16 pkt_hdrlen ;
   u16 hdrlen ;
   u32 pktlen ;
   u32 last_txcmdsz ;
   u32 encrypt ;
   u8 nr_frags ;
   u8 iv_len ;
   u8 icv_len ;
   u8 iv[18U] ;
   u8 icv[16U] ;
   u8 priority ;
   u8 ack_policy ;
   u8 mac_id ;
   u8 vcs_mode ;
   u8 dst[6U] ;
   u8 src[6U] ;
   u8 ta[6U] ;
   u8 ra[6U] ;
   u8 key_idx ;
   u8 qos_en ;
   u8 ht_en ;
   u8 raid ;
   u8 bwmode ;
   u8 ch_offset ;
   u8 sgi ;
   u8 ampdu_en ;
   u8 mdata ;
   u8 pctrl ;
   u8 triggered ;
   u8 qsel ;
   u8 eosp ;
   u8 rate ;
   u8 retry_ctrl ;
   struct sta_info *psta ;
};
#line 200 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct xmit_buf {
   struct list_head list ;
   struct list_head list2 ;
   struct rtw_adapter *padapter ;
   u8 *pallocated_buf ;
   u8 *pbuf ;
   void *priv_data ;
   u16 ext_tag ;
   u16 flags ;
   u32 alloc_sz ;
   u32 len ;
   struct submit_ctx *sctx ;
   u32 ff_hwaddr ;
   struct urb *pxmit_urb[8U] ;
   u8 bpending[8U] ;
   int last[8U] ;
};
#line 219 "drivers/staging/rtl8723au/include/rtw_xmit.h"
struct xmit_frame {
   struct list_head list ;
   struct pkt_attrib attrib ;
   struct sk_buff *pkt ;
   int frame_tag ;
   struct rtw_adapter *padapter ;
   u8 *buf_addr ;
   struct xmit_buf *pxmitbuf ;
   s8 pkt_offset ;
   u8 ack_report ;
   u8 ext_tag ;
};
#line 325 "drivers/staging/rtl8723au/include/rtw_recv.h"
enum hal_def_variable {
    HAL_DEF_UNDERCORATEDSMOOTHEDPWDB = 0,
    HAL_DEF_IS_SUPPORT_ANT_DIV = 1,
    HAL_DEF_CURRENT_ANTENNA = 2,
    HAL_DEF_DRVINFO_SZ = 3,
    HAL_DEF_MAX_RECVBUF_SZ = 4,
    HAL_DEF_RX_PACKET_OFFSET = 5,
    HAL_DEF_DBG_DUMP_RXPKT = 6,
    HAL_DEF_DBG_DM_FUNC = 7,
    HAL_DEF_RA_DECISION_RATE = 8,
    HAL_DEF_RA_SGI = 9,
    HAL_DEF_PT_PWR_STATUS = 10,
    HW_VAR_MAX_RX_AMPDU_FACTOR = 11,
    HW_DEF_RA_INFO_DUMP = 12,
    HAL_DEF_DBG_DUMP_TXPKT = 13,
    HW_DEF_FA_CNT_DUMP = 14,
    HW_DEF_ODM_DBG_FLAG = 15
} ;
#line 344
enum hal_odm_variable {
    HAL_ODM_STA_INFO = 0,
    HAL_ODM_P2P_STATE = 1,
    HAL_ODM_WIFI_DISPLAY_STATE = 2
} ;
#line 46 "drivers/staging/rtl8723au/include/rtw_event.h"
struct stassoc_event {
   unsigned char macaddr[6U] ;
   unsigned char rsvd[2U] ;
   int cam_id ;
};
#line 56 "drivers/staging/rtl8723au/include/rtw_event.h"
struct stadel_event {
   unsigned char macaddr[6U] ;
   unsigned char rsvd[2U] ;
   int mac_id ;
};
#line 51 "drivers/staging/rtl8723au/include/rtw_ap.h"
struct rtw_wdev_priv {
   struct wireless_dev *rtw_wdev ;
   struct rtw_adapter *padapter ;
   struct cfg80211_scan_request *scan_request ;
   spinlock_t scan_req_lock ;
   struct net_device *pmon_ndev ;
   char ifname_mon[17U] ;
   u8 p2p_enabled ;
   bool power_mgmt ;
};
#line 36 "include/uapi/linux/types.h"
typedef __u64 __le64;
#line 295 "include/linux/timer.h"
enum hrtimer_restart;
#line 141 "include/linux/ieee80211.h"
struct ieee80211_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   u8 addr4[6U] ;
};
#line 232 "include/linux/ieee80211.h"
struct ieee80211_qos_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   __le16 qos_ctrl ;
};
#line 671 "include/linux/ieee80211.h"
struct ieee80211_msrment_ie {
   u8 token ;
   u8 mode ;
   u8 type ;
   u8 request[0U] ;
};
#line 694 "include/linux/ieee80211.h"
struct ieee80211_ext_chansw_ie {
   u8 mode ;
   u8 new_operating_class ;
   u8 new_ch_num ;
   u8 count ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_auth_254 {
   __le16 auth_alg ;
   __le16 auth_transaction ;
   __le16 status_code ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_deauth_255 {
   __le16 reason_code ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_assoc_req_256 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_assoc_resp_257 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_reassoc_resp_258 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_reassoc_req_259 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 current_ap[6U] ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_disassoc_260 {
   __le16 reason_code ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_beacon_261 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_probe_req_262 {
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_probe_resp_263 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_wme_action_266 {
   u8 action_code ;
   u8 dialog_token ;
   u8 status_code ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_chan_switch_267 {
   u8 action_code ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_ext_chan_switch_268 {
   u8 action_code ;
   struct ieee80211_ext_chansw_ie data ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_measurement_269 {
   u8 action_code ;
   u8 dialog_token ;
   u8 element_id ;
   u8 length ;
   struct ieee80211_msrment_ie msr_elem ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_addba_req_270 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capab ;
   __le16 timeout ;
   __le16 start_seq_num ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_addba_resp_271 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 status ;
   __le16 capab ;
   __le16 timeout ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_delba_272 {
   u8 action_code ;
   __le16 params ;
   __le16 reason_code ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_self_prot_273 {
   u8 action_code ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_mesh_action_274 {
   u8 action_code ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_sa_query_275 {
   u8 action ;
   u8 trans_id[2U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_ht_smps_276 {
   u8 action ;
   u8 smps_control ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_ht_notify_cw_277 {
   u8 action_code ;
   u8 chanwidth ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_tdls_discover_resp_278 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capability ;
   u8 variable[0U] ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_vht_opmode_notif_279 {
   u8 action_code ;
   u8 operating_mode ;
};
#line 825 "include/linux/ieee80211.h"
union __anonunion_u_265 {
   struct __anonstruct_wme_action_266 wme_action ;
   struct __anonstruct_chan_switch_267 chan_switch ;
   struct __anonstruct_ext_chan_switch_268 ext_chan_switch ;
   struct __anonstruct_measurement_269 measurement ;
   struct __anonstruct_addba_req_270 addba_req ;
   struct __anonstruct_addba_resp_271 addba_resp ;
   struct __anonstruct_delba_272 delba ;
   struct __anonstruct_self_prot_273 self_prot ;
   struct __anonstruct_mesh_action_274 mesh_action ;
   struct __anonstruct_sa_query_275 sa_query ;
   struct __anonstruct_ht_smps_276 ht_smps ;
   struct __anonstruct_ht_notify_cw_277 ht_notify_cw ;
   struct __anonstruct_tdls_discover_resp_278 tdls_discover_resp ;
   struct __anonstruct_vht_opmode_notif_279 vht_opmode_notif ;
};
#line 825 "include/linux/ieee80211.h"
struct __anonstruct_action_264 {
   u8 category ;
   union __anonunion_u_265 u ;
};
#line 825 "include/linux/ieee80211.h"
union __anonunion_u_253 {
   struct __anonstruct_auth_254 auth ;
   struct __anonstruct_deauth_255 deauth ;
   struct __anonstruct_assoc_req_256 assoc_req ;
   struct __anonstruct_assoc_resp_257 assoc_resp ;
   struct __anonstruct_reassoc_resp_258 reassoc_resp ;
   struct __anonstruct_reassoc_req_259 reassoc_req ;
   struct __anonstruct_disassoc_260 disassoc ;
   struct __anonstruct_beacon_261 beacon ;
   struct __anonstruct_probe_req_262 probe_req ;
   struct __anonstruct_probe_resp_263 probe_resp ;
   struct __anonstruct_action_264 action ;
};
#line 825 "include/linux/ieee80211.h"
struct ieee80211_mgmt {
   __le16 frame_control ;
   __le16 duration ;
   u8 da[6U] ;
   u8 sa[6U] ;
   u8 bssid[6U] ;
   __le16 seq_ctrl ;
   union __anonunion_u_253 u ;
};
#line 452 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct Tx_Beacon_param {
   struct wlan_bssid_ex network ;
};
#line 634 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct SetChannelPlan_param {
   u8 channel_plan ;
};
#line 639 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct LedBlink_param {
   struct led_8723a *pLed ;
};
#line 78 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct phy_info {
   u8 RxPWDBAll ;
   u8 SignalQuality ;
   u8 RxMIMOSignalQuality[2U] ;
   u8 RxMIMOSignalStrength[2U] ;
   s8 RxPower ;
   s8 RecvSignalPower ;
   u8 BTRxRSSIPercentage ;
   u8 SignalStrength ;
   u8 RxPwr[2U] ;
   u8 RxSNR[2U] ;
};
#line 94 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct rx_pkt_attrib {
   u16 pkt_len ;
   u8 physt ;
   u8 drvinfo_sz ;
   u8 shift_sz ;
   u8 hdrlen ;
   u8 amsdu ;
   u8 qos ;
   u8 priority ;
   u8 pw_save ;
   u8 mdata ;
   u16 seq_num ;
   u8 frag_num ;
   u8 mfrag ;
   u8 order ;
   u8 privacy ;
   u8 bdecrypted ;
   u32 encrypt ;
   u8 iv_len ;
   u8 icv_len ;
   u8 crc_err ;
   u8 icv_err ;
   u16 eth_type ;
   u8 dst[6U] ;
   u8 src[6U] ;
   u8 ta[6U] ;
   u8 ra[6U] ;
   u8 bssid[6U] ;
   u8 ack_policy ;
   u8 tcpchk_valid ;
   u8 ip_chkrpt ;
   u8 tcp_chkrpt ;
   u8 key_index ;
   u8 mcs_rate ;
   u8 rxht ;
   u8 sgi ;
   u8 pkt_rpt_type ;
   u32 MacIDValidEntry[2U] ;
   struct phy_info phy_info ;
};
#line 249 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_frame {
   struct list_head list ;
   struct sk_buff *pkt ;
   struct rtw_adapter *adapter ;
   struct rx_pkt_attrib attrib ;
   struct sta_info *psta ;
   struct recv_reorder_ctrl *preorder_ctrl ;
};
#line 165 "drivers/staging/rtl8723au/include/rtw_debug.h"
struct survey_event {
   struct wlan_bssid_ex bss ;
};
#line 27 "drivers/staging/rtl8723au/include/rtw_event.h"
struct surveydone_event {
   unsigned int bss_cnt ;
};
#line 35 "drivers/staging/rtl8723au/include/rtw_event.h"
struct joinbss_event {
   struct wlan_network network ;
};
#line 66 "drivers/staging/rtl8723au/include/rtw_event.h"
struct fwevent {
   u32 parmsize ;
   void (*event_callback)(struct rtw_adapter * , u8 const   * ) ;
};
#line 181 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_plan {
   unsigned char Channel[38U] ;
   unsigned char Len ;
};
#line 204 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_plan_2g {
   unsigned char Channel[14U] ;
   unsigned char Len ;
};
#line 209 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_plan_5g {
   unsigned char Channel[24U] ;
   unsigned char Len ;
};
#line 214 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct rt_channel_plan_map {
   unsigned char Index2G ;
   unsigned char Index5G ;
};
#line 261 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct mlme_handler {
   char *str ;
   int (*func)(struct rtw_adapter * , struct recv_frame * ) ;
};
#line 266 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct action_handler {
   unsigned int num ;
   char *str ;
   int (*func)(struct rtw_adapter * , struct recv_frame * ) ;
};
#line 406
enum hw_mode {
    IEEE80211G = 0,
    IEEE80211A = 1
} ;
#line 411
enum ldv_33978 {
    BW20 = 0,
    BW40PLUS = 1,
    BW40MINUS = 2
} ;
#line 417 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct p2p_oper_class_map {
   enum hw_mode mode ;
   u8 op_class ;
   u8 min_chan ;
   u8 max_chan ;
   u8 inc ;
   enum ldv_33978 bw ;
};
#line 646 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
struct C2HEvent_Header {
   unsigned short len ;
   unsigned char ID ;
   unsigned char seq ;
   unsigned int rsvd ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 259
enum hrtimer_restart;
#line 2548 "include/linux/netdevice.h"
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
#line 1017 "include/linux/ieee80211.h"
struct ieee80211_pspoll {
   __le16 frame_control ;
   __le16 aid ;
   u8 bssid[6U] ;
   u8 ta[6U] ;
};
#line 234 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_buf {
   struct list_head list ;
   struct rtw_adapter *adapter ;
   struct urb *purb ;
   struct sk_buff *pskb ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 168 "drivers/staging/rtl8723au/include/rtw_security.h"
struct mic_data {
   u32 K0 ;
   u32 K1 ;
   u32 L ;
   u32 R ;
   u32 M ;
   u32 nBytesInM ;
};
#line 278 "drivers/staging/rtl8723au/include/drv_types.h"
struct arc4context {
   u32 x ;
   u32 y ;
   u8 state[256U] ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 77 "drivers/staging/rtl8723au/include/rtw_ht.h"
enum ht_channel_width {
    HT_CHANNEL_WIDTH_20 = 0,
    HT_CHANNEL_WIDTH_40 = 1,
    HT_CHANNEL_WIDTH_80 = 2,
    HT_CHANNEL_WIDTH_160 = 3,
    HT_CHANNEL_WIDTH_10 = 4
} ;
#line 65 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
enum WIRELESS_MODE {
    WIRELESS_MODE_UNKNOWN = 0,
    WIRELESS_MODE_A = 4,
    WIRELESS_MODE_B = 1,
    WIRELESS_MODE_G = 2,
    WIRELESS_MODE_AUTO = 32,
    WIRELESS_MODE_N_24G = 8,
    WIRELESS_MODE_N_5G = 16,
    WIRELESS_MODE_AC = 64
} ;
#line 100 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
struct bb_reg_define {
   u32 rfintfs ;
   u32 rfintfi ;
   u32 rfintfo ;
   u32 rfintfe ;
   u32 rf3wireOffset ;
   u32 rfLSSI_Select ;
   u32 rfTxGainStage ;
   u32 rfHSSIPara1 ;
   u32 rfHSSIPara2 ;
   u32 rfSwitchControl ;
   u32 rfAGCControl1 ;
   u32 rfAGCControl2 ;
   u32 rfRxIQImbalance ;
   u32 rfRxAFE ;
   u32 rfTxIQImbalance ;
   u32 rfTxAFE ;
   u32 rfLSSIReadBack ;
   u32 rfLSSIReadBackPi ;
};
#line 121 "drivers/staging/rtl8723au/include/hal_intf.h"
enum hal_ic_type {
    CHIP_8192S = 0,
    CHIP_8188C = 1,
    CHIP_8192C = 2,
    CHIP_8192D = 3,
    CHIP_8723A = 4,
    CHIP_8188E = 5,
    CHIP_8881A = 6,
    CHIP_8812A = 7,
    CHIP_8821A = 8,
    CHIP_8723B = 9,
    CHIP_8192E = 10
} ;
#line 135
enum hal_chip_type {
    TEST_CHIP = 0,
    NORMAL_CHIP = 1,
    FPGA = 2
} ;
#line 141
enum hal_cut_version {
    A_CUT_VERSION = 0,
    B_CUT_VERSION = 1,
    C_CUT_VERSION = 2,
    D_CUT_VERSION = 3,
    E_CUT_VERSION = 4,
    F_CUT_VERSION = 5,
    G_CUT_VERSION = 6
} ;
#line 151
enum hal_vendor {
    CHIP_VENDOR_TSMC = 0,
    CHIP_VENDOR_UMC = 1
} ;
#line 156
enum hal_rf_type {
    RF_TYPE_1T1R = 0,
    RF_TYPE_1T2R = 1,
    RF_TYPE_2T2R = 2,
    RF_TYPE_2T3R = 3,
    RF_TYPE_2T4R = 4,
    RF_TYPE_3T3R = 5,
    RF_TYPE_3T4R = 6,
    RF_TYPE_4T4R = 7
} ;
#line 167 "drivers/staging/rtl8723au/include/hal_intf.h"
struct hal_version {
   enum hal_ic_type ICType ;
   enum hal_chip_type ChipType ;
   enum hal_cut_version CUTVersion ;
   enum hal_vendor VendorType ;
   enum hal_rf_type RFType ;
   u8 ROMVer ;
};
#line 195 "drivers/staging/rtl8723au/include/rtw_io.h"
enum rt_customer_id {
    RT_CID_DEFAULT = 0,
    RT_CID_8187_ALPHA0 = 1,
    RT_CID_8187_SERCOMM_PS = 2,
    RT_CID_8187_HW_LED = 3,
    RT_CID_8187_NETGEAR = 4,
    RT_CID_WHQL = 5,
    RT_CID_819x_CAMEO = 6,
    RT_CID_819x_RUNTOP = 7,
    RT_CID_819x_Senao = 8,
    RT_CID_TOSHIBA = 9,
    RT_CID_819x_Netcore = 10,
    RT_CID_Nettronix = 11,
    RT_CID_DLINK = 12,
    RT_CID_PRONET = 13,
    RT_CID_COREGA = 14,
    RT_CID_CHINA_MOBILE = 15,
    RT_CID_819x_ALPHA = 16,
    RT_CID_819x_Sitecom = 17,
    RT_CID_CCX = 18,
    RT_CID_819x_Lenovo = 19,
    RT_CID_819x_QMI = 20,
    RT_CID_819x_Edimax_Belkin = 21,
    RT_CID_819x_Sercomm_Belkin = 22,
    RT_CID_819x_CAMEO1 = 23,
    RT_CID_819x_MSI = 24,
    RT_CID_819x_Acer = 25,
    RT_CID_819x_AzWave_ASUS = 26,
    RT_CID_819x_AzWave = 27,
    RT_CID_819x_HP = 28,
    RT_CID_819x_WNC_COREGA = 29,
    RT_CID_819x_Arcadyan_Belkin = 30,
    RT_CID_819x_SAMSUNG = 31,
    RT_CID_819x_CLEVO = 32,
    RT_CID_819x_DELL = 33,
    RT_CID_819x_PRONETS = 34,
    RT_CID_819x_Edimax_ASUS = 35,
    RT_CID_819x_CAMEO_NETGEAR = 36,
    RT_CID_PLANEX = 37,
    RT_CID_CC_C = 38,
    RT_CID_819x_Xavi = 39,
    RT_CID_819x_FUNAI_TV = 40,
    RT_CID_819x_ALPHA_WD = 41
} ;
#line 284 "drivers/staging/rtl8723au/include/drv_types.h"
struct sreset_priv {
   struct mutex silentreset_mutex ;
   u8 silent_reset_inprogress ;
   u8 Wifi_Error_Status ;
   unsigned long last_tx_time ;
   unsigned long last_tx_complete_time ;
   s32 dbg_trigger_point ;
};
#line 28 "drivers/staging/rtl8723au/include/Hal8723UHWImg_CE.h"
struct dig_t {
   u8 Dig_Enable_Flag ;
   u8 Dig_Ext_Port_Stage ;
   int RssiLowThresh ;
   int RssiHighThresh ;
   u32 FALowThresh ;
   u32 FAHighThresh ;
   u8 CurSTAConnectState ;
   u8 PreSTAConnectState ;
   u8 CurMultiSTAConnectState ;
   u8 PreIGValue ;
   u8 CurIGValue ;
   u8 BackupIGValue ;
   s8 BackoffVal ;
   s8 BackoffVal_range_max ;
   s8 BackoffVal_range_min ;
   u8 rx_gain_range_max ;
   u8 rx_gain_range_min ;
   u8 Rssi_val_min ;
   u8 PreCCK_CCAThres ;
   u8 CurCCK_CCAThres ;
   u8 PreCCKPDState ;
   u8 CurCCKPDState ;
   u8 LargeFAHit ;
   u8 ForbiddenIGI ;
   u32 Recover_cnt ;
   u8 DIG_Dynamic_MIN_0 ;
   u8 DIG_Dynamic_MIN_1 ;
   bool bMediaConnect_0 ;
   bool bMediaConnect_1 ;
   u32 AntDiv_RSSI_max ;
   u32 RSSI_max ;
};
#line 131 "drivers/staging/rtl8723au/include/odm.h"
struct dynamic_pwr_sav {
   u8 PreCCAState ;
   u8 CurCCAState ;
   u8 PreRFState ;
   u8 CurRFState ;
   int Rssi_val_min ;
   u8 initialize ;
   u32 Reg874 ;
   u32 RegC70 ;
   u32 Reg85C ;
   u32 RegA74 ;
};
#line 144 "drivers/staging/rtl8723au/include/odm.h"
struct false_alarm_stats {
   u32 Cnt_Parity_Fail ;
   u32 Cnt_Rate_Illegal ;
   u32 Cnt_Crc8_fail ;
   u32 Cnt_Mcs_fail ;
   u32 Cnt_Ofdm_fail ;
   u32 Cnt_Cck_fail ;
   u32 Cnt_all ;
   u32 Cnt_Fast_Fsync ;
   u32 Cnt_SB_Search_fail ;
   u32 Cnt_OFDM_CCA ;
   u32 Cnt_CCK_CCA ;
   u32 Cnt_CCA_all ;
   u32 Cnt_BW_USC ;
   u32 Cnt_BW_LSC ;
};
#line 161 "drivers/staging/rtl8723au/include/odm.h"
struct pri_cca {
   u8 PriCCA_flag ;
   u8 intf_flag ;
   u8 intf_type ;
   u8 DupRTS_flag ;
   u8 Monitor_flag ;
};
#line 169 "drivers/staging/rtl8723au/include/odm.h"
struct rx_hp {
   u8 RXHP_flag ;
   u8 PSD_func_trigger ;
   u8 PSD_bitmap_RXHP[80U] ;
   u8 Pre_IGI ;
   u8 Cur_IGI ;
   u8 Pre_pw_th ;
   u8 Cur_pw_th ;
   bool First_time_enter ;
   bool RXHP_enable ;
   u8 TP_Mode ;
};
#line 182 "drivers/staging/rtl8723au/include/odm.h"
struct sw_ant_sw {
   u8 try_flag ;
   s32 PreRSSI ;
   u8 CurAntenna ;
   u8 PreAntenna ;
   u8 RSSI_Trying ;
   u8 TestMode ;
   u8 bTriggerAntennaSwitch ;
   u8 SelectAntennaMap ;
   u8 RSSI_target ;
   u8 SWAS_NoLink_State ;
   u32 SWAS_NoLink_BK_Reg860 ;
   bool ANTA_ON ;
   bool ANTB_ON ;
   s32 RSSI_sum_A ;
   s32 RSSI_sum_B ;
   s32 RSSI_cnt_A ;
   s32 RSSI_cnt_B ;
   u64 lastTxOkCnt ;
   u64 lastRxOkCnt ;
   u64 TXByteCnt_A ;
   u64 TXByteCnt_B ;
   u64 RXByteCnt_A ;
   u64 RXByteCnt_B ;
   u8 TrafficLoad ;
};
#line 228 "drivers/staging/rtl8723au/include/odm.h"
struct edca_turbo {
   bool bCurrentTurboEDCA ;
   bool bIsCurRDLState ;
   u32 prv_traffic_idx ;
};
#line 234 "drivers/staging/rtl8723au/include/odm.h"
struct odm_rate_adapt {
   u8 Type ;
   u8 HighRSSIThresh ;
   u8 LowRSSIThresh ;
   u8 RATRState ;
   u32 LastRATR ;
};
#line 242 "drivers/staging/rtl8723au/include/odm.h"
struct odm_phy_dbg_info {
   s8 RxSNRdB[2U] ;
   u64 NumQryPhyStatus ;
   u64 NumQryPhyStatusCCK ;
   u64 NumQryPhyStatusOFDM ;
   s32 RxEVM[2U] ;
};
#line 493 "drivers/staging/rtl8723au/include/odm.h"
struct iqk_matrix_regs_set {
   bool bIQKDone ;
   s32 Value[1U][8U] ;
};
#line 551 "drivers/staging/rtl8723au/include/odm.h"
struct odm_rf_cal_t {
   u32 RegA24 ;
   s32 RegE94 ;
   s32 RegE9C ;
   s32 RegEB4 ;
   s32 RegEBC ;
   u8 TXPowercount ;
   bool bTXPowerTrackingInit ;
   bool bTXPowerTracking ;
   u8 TxPowerTrackControl ;
   u8 TM_Trigger ;
   u8 InternalPA5G[2U] ;
   u8 ThermalMeter[2U] ;
   u8 ThermalValue ;
   u8 ThermalValue_LCK ;
   u8 ThermalValue_IQK ;
   u8 ThermalValue_DPK ;
   u8 ThermalValue_AVG[8U] ;
   u8 ThermalValue_AVG_index ;
   u8 ThermalValue_RxGain ;
   u8 ThermalValue_Crystal ;
   u8 ThermalValue_DPKstore ;
   u8 ThermalValue_DPKtrack ;
   bool TxPowerTrackingInProgress ;
   bool bDPKenable ;
   bool bReloadtxpowerindex ;
   u8 bRfPiEnable ;
   u32 TXPowerTrackingCallbackCnt ;
   u8 bCCKinCH14 ;
   u8 CCK_index ;
   u8 OFDM_index[2U] ;
   bool bDoneTxpower ;
   u8 ThermalValue_HP[8U] ;
   u8 ThermalValue_HP_index ;
   struct iqk_matrix_regs_set IQKMatrixRegSetting[46U] ;
   u8 Delta_IQK ;
   u8 Delta_LCK ;
   u32 RegC04 ;
   u32 Reg874 ;
   u32 RegC08 ;
   u32 RegB68 ;
   u32 RegB6C ;
   u32 Reg870 ;
   u32 Reg860 ;
   u32 Reg864 ;
   bool bIQKInitialized ;
   bool bLCKInProgress ;
   bool bAntennaDetected ;
   u32 ADDA_backup[16U] ;
   u32 IQK_MAC_backup[4U] ;
   u32 IQK_BB_backup_recover[9U] ;
   u32 IQK_BB_backup[9U] ;
   u32 APKoutput[2U][2U] ;
   u8 bAPKdone ;
   u8 bAPKThermalMeterIgnore ;
   u8 bDPdone ;
   u8 bDPPathAOK ;
   u8 bDPPathBOK ;
};
#line 625 "drivers/staging/rtl8723au/include/odm.h"
struct odm_fat_t {
   u8 Bssid[6U] ;
   u8 antsel_rx_keep_0 ;
   u8 antsel_rx_keep_1 ;
   u8 antsel_rx_keep_2 ;
   u32 antSumRSSI[7U] ;
   u32 antRSSIcnt[7U] ;
   u32 antAveRSSI[7U] ;
   u8 FAT_State ;
   u32 TrainIdx ;
   u8 antsel_a[32U] ;
   u8 antsel_b[32U] ;
   u8 antsel_c[32U] ;
   u32 MainAnt_Sum[32U] ;
   u32 AuxAnt_Sum[32U] ;
   u32 MainAnt_Cnt[32U] ;
   u32 AuxAnt_Cnt[32U] ;
   u8 RxIdleAnt ;
   bool bBecomeLinked ;
};
#line 661 "drivers/staging/rtl8723au/include/odm.h"
struct dm_odm_t {
   struct rtw_adapter *Adapter ;
   u64 DebugComponents ;
   u32 DebugLevel ;
   bool bCckHighPower ;
   u8 RFPathRxEnable ;
   u8 ControlChannel ;
   u32 SupportAbility ;
   u8 SupportInterface ;
   u32 SupportICType ;
   u8 CutVersion ;
   u8 FabVersion ;
   u8 RFType ;
   u8 BoardType ;
   u8 ExtLNA ;
   u8 ExtPA ;
   u8 ExtTRSW ;
   u8 PatchID ;
   bool bInHctTest ;
   bool bWIFITest ;
   bool bDualMacSmartConcurrent ;
   u32 BK_SupportAbility ;
   u8 AntDivType ;
   u8 u8_temp ;
   bool bool_temp ;
   struct rtw_adapter *PADAPTER_temp ;
   u8 *pMacPhyMode ;
   u64 *pNumTxBytesUnicast ;
   u64 *pNumRxBytesUnicast ;
   u8 *pWirelessMode ;
   u8 *pBandType ;
   u8 *pSecChOffset ;
   u8 *pSecurity ;
   u8 *pBandWidth ;
   u8 *pChannel ;
   bool *pbGetValueFromOtherMac ;
   struct rtw_adapter **pBuddyAdapter ;
   bool *pbMasterOfDMSP ;
   bool *pbScanInProcess ;
   bool *pbPowerSaving ;
   u8 *pOnePathCCA ;
   u8 *pAntennaTest ;
   bool *pbNet_closed ;
   bool bWIFI_Direct ;
   bool bWIFI_Display ;
   bool bLinked ;
   u8 RSSI_Min ;
   u8 InterfaceIndex ;
   bool bIsMPChip ;
   bool bOneEntryOnly ;
   bool bBtDisabled ;
   bool bBtHsOperation ;
   u8 btHsDigVal ;
   bool bBtDisableEdcaTurbo ;
   bool bBtBusy ;
   struct sta_info *pODM_StaInfo[32U] ;
   bool RaSupport88E ;
   struct odm_phy_dbg_info PhyDbgInfo ;
   struct odm_fat_t DM_FatTable ;
   struct dig_t DM_DigTable ;
   struct dynamic_pwr_sav DM_PSTable ;
   struct pri_cca DM_PriCCA ;
   struct rx_hp DM_RXHP_Table ;
   struct false_alarm_stats FalseAlmCnt ;
   struct false_alarm_stats FlaseAlmCntBuddyAdapter ;
   struct sw_ant_sw DM_SWAT_Table ;
   bool RSSI_test ;
   struct edca_turbo DM_EDCA_Table ;
   u32 WMMEDCA_BE ;
   bool *pbDriverStopped ;
   bool *pbDriverIsGoingToPnpSetPowerSleep ;
   bool *pinit_adpt_in_progress ;
   bool bUserAssignLevel ;
   u8 RSSI_BT ;
   bool bPSDinProcess ;
   bool bDMInitialGainEnable ;
   u8 bUseRAMask ;
   struct odm_rate_adapt RateAdaptive ;
   struct odm_rf_cal_t RFCalibrateInfo ;
   u8 BbSwingIdxOfdm ;
   u8 BbSwingIdxOfdmCurrent ;
   u8 BbSwingIdxOfdmBase ;
   bool BbSwingFlagOfdm ;
   u8 BbSwingIdxCck ;
   u8 BbSwingIdxCckCurrent ;
   u8 BbSwingIdxCckBase ;
   bool BbSwingFlagCck ;
};
#line 36 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct octet_string {
   u8 *Octet ;
   u16 Length ;
};
#line 86
enum hci_status {
    HCI_STATUS_SUCCESS = 0,
    HCI_STATUS_UNKNOW_HCI_CMD = 1,
    HCI_STATUS_UNKNOW_CONNECT_ID = 2,
    HCI_STATUS_HW_FAIL = 3,
    HCI_STATUS_PAGE_TIMEOUT = 4,
    HCI_STATUS_AUTH_FAIL = 5,
    HCI_STATUS_PIN_OR_KEY_MISSING = 6,
    HCI_STATUS_MEM_CAP_EXCEED = 7,
    HCI_STATUS_CONNECT_TIMEOUT = 8,
    HCI_STATUS_CONNECT_LIMIT = 9,
    HCI_STATUS_SYN_CONNECT_LIMIT = 10,
    HCI_STATUS_ACL_CONNECT_EXISTS = 11,
    HCI_STATUS_CMD_DISALLOW = 12,
    HCI_STATUS_CONNECT_RJT_LIMIT_RESOURCE = 13,
    HCI_STATUS_CONNECT_RJT_SEC_REASON = 14,
    HCI_STATUS_CONNECT_RJT_UNACCEPT_BD_ADDR = 15,
    HCI_STATUS_CONNECT_ACCEPT_TIMEOUT = 16,
    HCI_STATUS_UNSUPPORT_FEATURE_PARA_VALUE = 17,
    HCI_STATUS_INVALID_HCI_CMD_PARA_VALUE = 18,
    HCI_STATUS_REMOTE_USER_TERMINATE_CONNECT = 19,
    HCI_STATUS_REMOTE_DEV_TERMINATE_LOW_RESOURCE = 20,
    HCI_STATUS_REMOTE_DEV_TERMINATE_CONNECT_POWER_OFF = 21,
    HCI_STATUS_CONNECT_TERMINATE_LOCAL_HOST = 22,
    HCI_STATUS_REPEATE_ATTEMPT = 23,
    HCI_STATUS_PAIR_NOT_ALLOW = 24,
    HCI_STATUS_UNKNOW_LMP_PDU = 25,
    HCI_STATUS_UNSUPPORT_REMOTE_LMP_FEATURE = 26,
    HCI_STATUS_SOC_OFFSET_REJECT = 27,
    HCI_STATUS_SOC_INTERVAL_REJECT = 28,
    HCI_STATUS_SOC_AIR_MODE_REJECT = 29,
    HCI_STATUS_INVALID_LMP_PARA = 30,
    HCI_STATUS_UNSPECIFIC_ERROR = 31,
    HCI_STATUS_UNSUPPORT_LMP_PARA_VALUE = 32,
    HCI_STATUS_ROLE_CHANGE_NOT_ALLOW = 33,
    HCI_STATUS_LMP_RESPONSE_TIMEOUT = 34,
    HCI_STATUS_LMP_ERROR_TRANSACTION_COLLISION = 35,
    HCI_STATUS_LMP_PDU_NOT_ALLOW = 36,
    HCI_STATUS_ENCRYPTION_MODE_NOT_ALLOW = 37,
    HCI_STATUS_LINK_KEY_CAN_NOT_CHANGE = 38,
    HCI_STATUS_REQUEST_QOS_NOT_SUPPORT = 39,
    HCI_STATUS_INSTANT_PASSED = 40,
    HCI_STATUS_PAIRING_UNIT_KEY_NOT_SUPPORT = 41,
    HCI_STATUS_DIFFERENT_TRANSACTION_COLLISION = 42,
    HCI_STATUS_RESERVE_1 = 43,
    HCI_STATUS_QOS_UNACCEPT_PARA = 44,
    HCI_STATUS_QOS_REJECT = 45,
    HCI_STATUS_CHNL_CLASSIFICATION_NOT_SUPPORT = 46,
    HCI_STATUS_INSUFFICIENT_SECURITY = 47,
    HCI_STATUS_PARA_OUT_OF_RANGE = 48,
    HCI_STATUS_RESERVE_2 = 49,
    HCI_STATUS_ROLE_SWITCH_PENDING = 50,
    HCI_STATUS_RESERVE_3 = 51,
    HCI_STATUS_RESERVE_SOLT_VIOLATION = 52,
    HCI_STATUS_ROLE_SWITCH_FAIL = 53,
    HCI_STATUS_EXTEND_INQUIRY_RSP_TOO_LARGE = 54,
    HCI_STATUS_SEC_SIMPLE_PAIRING_NOT_SUPPORT = 55,
    HCI_STATUS_HOST_BUSY_PAIRING = 56,
    HCI_STATUS_CONNECT_REJ_NOT_SUIT_CHNL_FOUND = 57,
    HCI_STATUS_CONTROLLER_BUSY = 58
} ;
#line 463
enum amp_btap_type {
    AMP_BTAP_NONE = 0,
    AMP_BTAP_CREATOR = 1,
    AMP_BTAP_JOINER = 2
} ;
#line 517
enum bt_connect_type {
    BT_CONNECT_AUTH_REQ = 0,
    BT_CONNECT_AUTH_RSP = 1,
    BT_CONNECT_ASOC_REQ = 2,
    BT_CONNECT_ASOC_RSP = 3,
    BT_DISCONNECT = 4
} ;
#line 563
enum bt_state_wpa_auth {
    STATE_WPA_AUTH_UNINITIALIZED = 0,
    STATE_WPA_AUTH_WAIT_PACKET_1 = 1,
    STATE_WPA_AUTH_WAIT_PACKET_2 = 2,
    STATE_WPA_AUTH_WAIT_PACKET_3 = 3,
    STATE_WPA_AUTH_WAIT_PACKET_4 = 4,
    STATE_WPA_AUTH_SUCCESSED = 5
} ;
#line 572 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_flow_spec {
   u8 Identifier ;
   u8 ServiceType ;
   u16 MaximumSDUSize ;
   u32 SDUInterArrivalTime ;
   u32 AccessLatency ;
   u32 FlushTimeout ;
};
#line 660 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_log_link_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 BtLogLinkhandle ;
   u8 BtTxFlowSpecID ;
   struct hci_flow_spec Tx_Flow_Spec ;
   struct hci_flow_spec Rx_Flow_Spec ;
   u32 TxPacketCount ;
   u32 BestEffortFlushTimeout ;
   u8 bLLCompleteEventIsSet ;
   u8 bLLCancelCMDIsSetandComplete ;
};
#line 674 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_phy_link_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 LinkSuperversionTimeout ;
   u8 BtAMPKeyLen ;
   u8 BtAMPKeyType ;
   u8 BtAMPKey[32U] ;
};
#line 705 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct amp_assoc_cmd_data {
   u8 BtPhyLinkhandle ;
   u16 LenSoFar ;
   u16 MaxRemoteASSOCLen ;
   u16 AMPAssocRemLen ;
   void *AMPAssocfragment ;
};
#line 718 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_link_info {
   u16 ConnectHandle ;
   u8 IncomingTrafficMode ;
   u8 OutgoingTrafficMode ;
   u8 BTProfile ;
   u8 BTCoreSpec ;
   s8 BT_RSSI ;
   u8 TrafficProfile ;
   u8 linkRole ;
};
#line 729 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_ext_config {
   struct hci_link_info linkInfo[2U] ;
   u8 btOperationCode ;
   u16 CurrentConnectHandle ;
   u8 CurrentIncomingTrafficMode ;
   u8 CurrentOutgoingTrafficMode ;
   s8 MIN_BT_RSSI ;
   u8 NumberOfHandle ;
   u8 NumberOfSCO ;
   u8 CurrentBTStatus ;
   u16 HCIExtensionVer ;
   u8 btProfileCase ;
   u8 btProfileAction ;
   u8 bManualControl ;
   u8 bBTBusy ;
   u8 bBTA2DPBusy ;
   u8 bEnableWifiScanNotify ;
   u8 bHoldForBtOperation ;
   u32 bHoldPeriodCnt ;
};
#line 753 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_acl_packet_data {
   u16 ACLDataPacketLen ;
   u8 SyncDataPacketLen ;
   u16 TotalNumACLDataPackets ;
   u16 TotalSyncNumDataPackets ;
};
#line 760 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct hci_phy_link_bss_info {
   u16 bdCap ;
};
#line 771 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_asoc_entry {
   u8 bUsed ;
   u8 mAssoc ;
   u8 b4waySuccess ;
   u8 Bssid[6U] ;
   struct hci_phy_link_cmd_data PhyLinkCmdData ;
   struct hci_log_link_cmd_data LogLinkCmdData[2U] ;
   struct hci_acl_packet_data ACLPacketsData ;
   struct amp_assoc_cmd_data AmpAsocCmdData ;
   struct octet_string BTSsid ;
   u8 BTSsidBuf[33U] ;
   enum hci_status PhyLinkDisconnectReason ;
   u8 bSendSupervisionPacket ;
   u32 NoRxPktCnt ;
   enum amp_btap_type AMPRole ;
   u8 BtCurrentState ;
   u8 BtNextState ;
   u8 bNeedPhysLinkCompleteEvent ;
   enum hci_status PhysLinkCompleteStatus ;
   u8 BTRemoteMACAddr[6U] ;
   u32 BTCapability ;
   u8 SyncDataPacketLen ;
   u16 TotalSyncNumDataPackets ;
   u16 TotalNumACLDataPackets ;
   u8 ShortRangeMode ;
   u8 PTK[64U] ;
   u8 GTK[32U] ;
   u8 ANonce[32U] ;
   u8 SNonce[32U] ;
   u64 KeyReplayCounter ;
   u8 WPAAuthReplayCount ;
   u8 AESKeyBuf[256U] ;
   u8 PMK[32U] ;
   enum bt_state_wpa_auth BTWPAAuthState ;
   s32 UndecoratedSmoothedPWDB ;
   u8 HwCAMIndex ;
   u8 bPeerQosSta ;
   u32 rxSuvpPktCnt ;
};
#line 833 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_traffic_statistics {
   u8 bTxBusyTraffic ;
   u8 bRxBusyTraffic ;
   u8 bIdle ;
   u32 TxPktCntInPeriod ;
   u32 RxPktCntInPeriod ;
   u64 TxPktLenInPeriod ;
   u64 RxPktLenInPeriod ;
};
#line 843 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_mgnt {
   u8 bBTConnectInProgress ;
   u8 bLogLinkInProgress ;
   u8 bPhyLinkInProgress ;
   u8 bPhyLinkInProgressStartLL ;
   u8 BtCurrentPhyLinkhandle ;
   u16 BtCurrentLogLinkhandle ;
   u8 CurrentConnectEntryNum ;
   u8 DisconnectEntryNum ;
   u8 CurrentBTConnectionCnt ;
   enum bt_connect_type BTCurrentConnectType ;
   enum bt_connect_type BTReceiveConnectPkt ;
   u8 BTAuthCount ;
   u8 BTAsocCount ;
   u8 bStartSendSupervisionPkt ;
   u8 BtOperationOn ;
   u8 BTNeedAMPStatusChg ;
   u8 JoinerNeedSendAuth ;
   struct hci_phy_link_bss_info bssDesc ;
   struct hci_ext_config ExtConfig ;
   u8 bNeedNotifyAMPNoCap ;
   u8 bCreateSpportQos ;
   u8 bSupportProfile ;
   u8 BTChannel ;
   u8 CheckChnlIsSuit ;
   u8 bBtScan ;
   u8 btLogoTest ;
};
#line 872 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_hci_dgb_info {
   u32 hciCmdCnt ;
   u32 hciCmdCntUnknown ;
   u32 hciCmdCntCreatePhyLink ;
   u32 hciCmdCntAcceptPhyLink ;
   u32 hciCmdCntDisconnectPhyLink ;
   u32 hciCmdPhyLinkStatus ;
   u32 hciCmdCntCreateLogLink ;
   u32 hciCmdCntAcceptLogLink ;
   u32 hciCmdCntDisconnectLogLink ;
   u32 hciCmdCntReadLocalAmpAssoc ;
   u32 hciCmdCntWriteRemoteAmpAssoc ;
   u32 hciCmdCntSetAclLinkStatus ;
   u32 hciCmdCntSetScoLinkStatus ;
   u32 hciCmdCntExtensionVersionNotify ;
   u32 hciCmdCntLinkStatusNotify ;
};
#line 890 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_irp_dgb_info {
   u32 irpMJCreate ;
   u32 irpIoControl ;
   u32 irpIoCtrlHciCmd ;
   u32 irpIoCtrlHciEvent ;
   u32 irpIoCtrlHciTxData ;
   u32 irpIoCtrlHciRxData ;
   u32 irpIoCtrlUnknown ;
   u32 irpIoCtrlHciTxData1s ;
};
#line 903 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_packet_dgb_info {
   u32 btPktTxProbReq ;
   u32 btPktRxProbReq ;
   u32 btPktRxProbReqFail ;
   u32 btPktTxProbRsp ;
   u32 btPktRxProbRsp ;
   u32 btPktTxAuth ;
   u32 btPktRxAuth ;
   u32 btPktRxAuthButDrop ;
   u32 btPktTxAssocReq ;
   u32 btPktRxAssocReq ;
   u32 btPktRxAssocReqButDrop ;
   u32 btPktTxAssocRsp ;
   u32 btPktRxAssocRsp ;
   u32 btPktTxDisassoc ;
   u32 btPktRxDisassoc ;
   u32 btPktRxDeauth ;
   u32 btPktTx4way1st ;
   u32 btPktRx4way1st ;
   u32 btPktTx4way2nd ;
   u32 btPktRx4way2nd ;
   u32 btPktTx4way3rd ;
   u32 btPktRx4way3rd ;
   u32 btPktTx4way4th ;
   u32 btPktRx4way4th ;
   u32 btPktTxLinkSuperReq ;
   u32 btPktRxLinkSuperReq ;
   u32 btPktTxLinkSuperRsp ;
   u32 btPktRxLinkSuperRsp ;
   u32 btPktTxData ;
   u32 btPktRxData ;
};
#line 936 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_dgb {
   u8 dbgCtrl ;
   u32 dbgProfile ;
   struct bt_hci_dgb_info dbgHciInfo ;
   struct bt_irp_dgb_info dbgIrpInfo ;
   struct bt_packet_dgb_info dbgBtPkt ;
};
#line 944 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_hci_info {
   u8 BTPalVersion ;
   u16 BTPalCompanyID ;
   u16 BTPalsubversion ;
   u16 BTConnectChnlListLen ;
   u8 BTConnectChnllist[64U] ;
   u16 FailContactCount ;
   u64 BTEventMask ;
   u64 BTEventMaskPage2 ;
   u16 ConnAcceptTimeout ;
   u16 LogicalAcceptTimeout ;
   u16 PageTimeout ;
   u8 LocationDomainAware ;
   u16 LocationDomain ;
   u8 LocationDomainOptions ;
   u8 LocationOptions ;
   u8 FlowControlMode ;
   u16 BtPreChnlListLen ;
   u8 BTPreChnllist[64U] ;
   u16 enFlush_LLH ;
   u16 FLTO_LLH ;
   u8 bInTestMode ;
   u8 bTestIsEnd ;
   u8 bTestNeedReport ;
   u8 TestScenario ;
   u8 TestReportInterval ;
   u8 TestCtrType ;
   u32 TestEventType ;
   u16 TestNumOfFrame ;
   u16 TestNumOfErrFrame ;
   u16 TestNumOfBits ;
   u16 TestNumOfErrBits ;
};
#line 995 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_traffic {
   u8 LastRxUniFragNum ;
   u16 LastRxUniSeqNum ;
   struct bt_traffic_statistics Bt30TrafficStatistics ;
};
#line 1007 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_security {
   struct octet_string RSNIE ;
   u8 RSNIEBuf[256U] ;
   u8 bRegNoEncrypt ;
   u8 bUsedHwEncrypt ;
};
#line 1020 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_30info {
   struct rtw_adapter *padapter ;
   struct bt_asoc_entry BtAsocEntry[2U] ;
   struct bt_mgnt BtMgnt ;
   struct bt_dgb BtDbg ;
   struct bt_hci_info BtHciInfo ;
   struct bt_traffic BtTraffic ;
   struct bt_security BtSec ;
   struct work_struct HCICmdWorkItem ;
   struct timer_list BTHCICmdTimer ;
   struct work_struct BTPsDisableWorkItem ;
   struct work_struct BTConnectWorkItem ;
   struct timer_list BTHCIDiscardAclDataTimer ;
   struct timer_list BTHCIJoinTimeoutTimer ;
   struct timer_list BTTestSendPacketTimer ;
   struct timer_list BTDisconnectPhyLinkTimer ;
   struct timer_list BTBeaconTimer ;
   u8 BTBeaconTmrOn ;
   struct timer_list BTPsDisableTimer ;
   void *pBtChnlList ;
};
#line 1118 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct btdm_8723a_1ant {
   u8 prePsTdma ;
   u8 curPsTdma ;
   u8 psTdmaDuAdjType ;
   u8 bPrePsTdmaOn ;
   u8 bCurPsTdmaOn ;
   u8 preWifiPara ;
   u8 curWifiPara ;
   u8 preCoexWifiCon ;
   u8 curCoexWifiCon ;
   u8 wifiRssiThresh ;
   u32 psTdmaMonitorCnt ;
   u32 psTdmaGlobalCnt ;
   u32 psTdmaMonitorCntForSCO ;
   u8 psTdmaDuAdjTypeForSCO ;
   u8 RSSI_WiFi_Last ;
   u8 RSSI_BT_Last ;
   u8 bWiFiHalt ;
   u8 bRAChanged ;
};
#line 1185 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct btdm_8723a_2ant {
   u8 bPreDecBtPwr ;
   u8 bCurDecBtPwr ;
   u8 preWlanActHi ;
   u8 curWlanActHi ;
   u8 preWlanActLo ;
   u8 curWlanActLo ;
   u8 preFwDacSwingLvl ;
   u8 curFwDacSwingLvl ;
   u8 bPreRfRxLpfShrink ;
   u8 bCurRfRxLpfShrink ;
   u8 bPreLowPenaltyRa ;
   u8 bCurLowPenaltyRa ;
   u8 preBtRetryIndex ;
   u8 curBtRetryIndex ;
   u8 bPreDacSwingOn ;
   u32 preDacSwingLvl ;
   u8 bCurDacSwingOn ;
   u32 curDacSwingLvl ;
   u8 bPreAdcBackOff ;
   u8 bCurAdcBackOff ;
   u8 bPreAgcTableEn ;
   u8 bCurAgcTableEn ;
   u32 preVal0x6c0 ;
   u32 curVal0x6c0 ;
   u32 preVal0x6c8 ;
   u32 curVal0x6c8 ;
   u8 preVal0x6cc ;
   u8 curVal0x6cc ;
   u8 bCurIgnoreWlanAct ;
   u8 bPreIgnoreWlanAct ;
   u8 prePsTdma ;
   u8 curPsTdma ;
   u8 psTdmaDuAdjType ;
   u8 bPrePsTdmaOn ;
   u8 bCurPsTdmaOn ;
   u8 preAlgorithm ;
   u8 curAlgorithm ;
   u8 bResetTdmaAdjust ;
   u8 btStatus ;
};
#line 1245 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_coexist_8723a {
   u32 highPriorityTx ;
   u32 highPriorityRx ;
   u32 lowPriorityTx ;
   u32 lowPriorityRx ;
   u8 btRssi ;
   u8 TotalAntNum ;
   u8 bC2hBtInfoSupport ;
   u8 c2hBtInfo ;
   u8 c2hBtInfoOriginal ;
   u8 prec2hBtInfo ;
   u8 bC2hBtInquiryPage ;
   unsigned long btInqPageStartTime ;
   u8 c2hBtProfile ;
   u8 btRetryCnt ;
   u8 btInfoExt ;
   u8 bC2hBtInfoReqSent ;
   u8 bForceFwBtInfo ;
   u8 bForceA2dpSink ;
   struct btdm_8723a_2ant btdm2Ant ;
   struct btdm_8723a_1ant btdm1Ant ;
};
#line 1365 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct bt_coexist_str {
   u8 BluetoothCoexist ;
   u8 BT_Ant_Num ;
   u8 BT_CoexistType ;
   u8 BT_Ant_isolation ;
   u8 bt_radiosharedtype ;
   u32 Ratio_Tx ;
   u32 Ratio_PRI ;
   u8 bInitlized ;
   u32 BtRfRegOrigin1E ;
   u32 BtRfRegOrigin1F ;
   u8 bBTBusyTraffic ;
   u8 bBTTrafficModeSet ;
   u8 bBTNonTrafficModeSet ;
   struct bt_traffic_statistics BT21TrafficStatistics ;
   u64 CurrentState ;
   u64 PreviousState ;
   u8 preRssiState ;
   u8 preRssiState1 ;
   u8 preRssiStateBeacon ;
   u8 bFWCoexistAllOff ;
   u8 bSWCoexistAllOff ;
   u8 bHWCoexistAllOff ;
   u8 bBalanceOn ;
   u8 bSingleAntOn ;
   u8 bInterruptOn ;
   u8 bMultiNAVOn ;
   u8 PreWLANActH ;
   u8 PreWLANActL ;
   u8 WLANActH ;
   u8 WLANActL ;
   u8 A2DPState ;
   u8 AntennaState ;
   u32 lastBtEdca ;
   u16 last_aggr_num ;
   u8 bEDCAInitialized ;
   u8 exec_cnt ;
   u8 b8723aAgcTableOn ;
   u8 b92DAgcTableOn ;
   struct bt_coexist_8723a halCoex8723 ;
   u8 btActiveZeroCnt ;
   u8 bCurBtDisabled ;
   u8 bPreBtDisabled ;
   u8 bNeedToRoamForBtDisableEnable ;
   u8 fw3aVal[5U] ;
};
#line 1616 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct dm_priv {
   u8 DM_Type ;
   u8 DMFlag ;
   u8 InitDMFlag ;
   u32 InitODMFlag ;
   int UndecoratedSmoothedPWDB ;
   int UndecoratedSmoothedCCK ;
   int EntryMinUndecoratedSmoothedPWDB ;
   int EntryMaxUndecoratedSmoothedPWDB ;
   int MinUndecoratedPWDBForDM ;
   int LastMinUndecoratedPWDBForDM ;
   s32 UndecoratedSmoothedBeacon ;
   s32 BT_EntryMinUndecoratedSmoothedPWDB ;
   s32 BT_EntryMaxUndecoratedSmoothedPWDB ;
   u8 DynamicTxHighPowerLvl ;
   u8 bTXPowerTracking ;
   u8 TXPowercount ;
   u8 bTXPowerTrackingInit ;
   u8 TxPowerTrackControl ;
   u8 TM_Trigger ;
   u8 ThermalMeter[2U] ;
   u8 ThermalValue ;
   u8 ThermalValue_LCK ;
   u8 ThermalValue_IQK ;
   u8 ThermalValue_DPK ;
   u8 bRfPiEnable ;
   u32 APKoutput[2U][2U] ;
   u8 bAPKdone ;
   u8 bAPKThermalMeterIgnore ;
   u8 bDPdone ;
   u8 bDPPathAOK ;
   u8 bDPPathBOK ;
   u32 RegC04 ;
   u32 Reg874 ;
   u32 RegC08 ;
   u32 RegB68 ;
   u32 RegB6C ;
   u32 Reg870 ;
   u32 Reg860 ;
   u32 Reg864 ;
   u32 ADDA_backup[16U] ;
   u32 IQK_MAC_backup[4U] ;
   u32 IQK_BB_backup_recover[9U] ;
   u32 IQK_BB_backup[9U] ;
   u8 PowerIndex_backup[6U] ;
   u8 bCCKinCH14 ;
   u8 CCK_index ;
   u8 OFDM_index[2U] ;
   u8 bDoneTxpower ;
   u8 CCK_index_HP ;
   u8 OFDM_index_HP[2U] ;
   u8 ThermalValue_HP[8U] ;
   u8 ThermalValue_HP_index ;
   s32 RegE94 ;
   s32 RegE9C ;
   s32 RegEB4 ;
   s32 RegEBC ;
   u32 TXPowerTrackingCallbackCnt ;
   u32 prv_traffic_idx ;
   s32 OFDM_Pkt_Cnt ;
   u8 RSSI_Select ;
   u8 INIDATA_RATE[32U] ;
};
#line 121 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
enum RT_MULTI_FUNC {
    RT_MULTI_FUNC_NONE = 0,
    RT_MULTI_FUNC_WIFI = 1,
    RT_MULTI_FUNC_BT = 2,
    RT_MULTI_FUNC_GPS = 4
} ;
#line 128
enum RT_POLARITY_CTL {
    RT_POLARITY_LOW_ACT = 0,
    RT_POLARITY_HIGH_ACT = 1
} ;
#line 133
enum RT_REGULATOR_MODE {
    RT_SWITCHING_REGULATOR = 0,
    RT_LDO_REGULATOR = 1
} ;
#line 153 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
struct hal_data_8723a {
   struct hal_version VersionID ;
   enum rt_customer_id CustomerID ;
   u16 FirmwareVersion ;
   u16 FirmwareVersionRev ;
   u16 FirmwareSubVersion ;
   u16 FirmwareSignature ;
   u32 ReceiveConfig ;
   enum WIRELESS_MODE CurrentWirelessMode ;
   enum ht_channel_width CurrentChannelBW ;
   u8 CurrentChannel ;
   u8 nCur40MhzPrimeSC ;
   u16 BasicRateSet ;
   u8 rf_chip ;
   u8 rf_type ;
   u8 NumTotalRFPath ;
   u8 BoardType ;
   u8 CrystalCap ;
   u8 EEPROMVersion ;
   u16 EEPROMVID ;
   u16 EEPROMPID ;
   u16 EEPROMSVID ;
   u16 EEPROMSDID ;
   u8 EEPROMCustomerID ;
   u8 EEPROMSubCustomerID ;
   u8 EEPROMRegulatory ;
   u8 EEPROMThermalMeter ;
   u8 EEPROMBluetoothCoexist ;
   u8 EEPROMBluetoothType ;
   u8 EEPROMBluetoothAntNum ;
   u8 EEPROMBluetoothAntIsolation ;
   u8 EEPROMBluetoothRadioShared ;
   u8 bTXPowerDataReadFromEEPORM ;
   u8 bAPKThermalMeterIgnore ;
   u8 bIQKInitialized ;
   u8 bAntennaDetected ;
   u8 TxPwrLevelCck[2U][14U] ;
   u8 TxPwrLevelHT40_1S[2U][14U] ;
   u8 TxPwrLevelHT40_2S[2U][14U] ;
   u8 TxPwrHt20Diff[2U][14U] ;
   u8 TxPwrLegacyHtDiff[2U][14U] ;
   u8 PwrGroupHT20[2U][14U] ;
   u8 PwrGroupHT40[2U][14U] ;
   u8 LegacyHTTxPowerDiff ;
   u8 framesync ;
   u32 framesyncC34 ;
   u8 framesyncMonitor ;
   u8 DefaultInitialGain[4U] ;
   u8 pwrGroupCnt ;
   u32 MCSTxPowerLevelOriginalOffset[7U][16U] ;
   u32 CCKTxPowerLevelOriginalOffset ;
   u32 AntennaTxPath ;
   u32 AntennaRxPath ;
   u8 ExternalPA ;
   u8 bLedOpenDrain ;
   u8 b1x1RecvCombine ;
   u32 AcParam_BE ;
   u8 CurrentCckTxPwrIdx ;
   u8 CurrentOfdm24GTxPwrIdx ;
   struct bb_reg_define PHYRegDef[4U] ;
   bool bRFPathRxEnable[4U] ;
   u32 RfRegChnlVal[2U] ;
   u8 bCckHighPower ;
   bool bRDGEnable ;
   u8 LastHMEBoxNum ;
   u8 fw_ractrl ;
   u8 RegTxPause ;
   u32 RegBcnCtrlVal ;
   u8 RegFwHwTxQCtrl ;
   u8 RegReg542 ;
   struct dm_priv dmpriv ;
   struct dm_odm_t odmpriv ;
   struct sreset_priv srestpriv ;
   u8 bBTMode ;
   struct bt_30info BtInfo ;
   struct bt_coexist_str bt_coexist ;
   u8 bDumpRxPkt ;
   u8 FwRsvdPageStartOffset ;
   u8 pwrdown ;
   u32 interfaceIndex ;
   u8 OutEpQueueSel ;
   u8 OutEpNumber ;
   bool UsbRxHighSpeedMode ;
   bool SlimComboDbg ;
   u8 EepromOrEfuse ;
   u16 EfuseUsedBytes ;
   u16 BTEfuseUsedBytes ;
   u32 SysIntrStatus ;
   u32 SysIntrMask ;
   enum RT_MULTI_FUNC MultiFunc ;
   enum RT_POLARITY_CTL PolarityCtl ;
   enum RT_REGULATOR_MODE RegulatorMode ;
   bool bMACFuncEnable ;
   u32 IntArray[2U] ;
   u32 IntrMask[2U] ;
};
#line 267 "include/linux/timer.h"
enum hrtimer_restart;
#line 39 "include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 93 "include/linux/rtnetlink.h"
struct iphdr {
   unsigned char ihl : 4 ;
   unsigned char version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 197 "drivers/staging/rtl8723au/include/ieee80211.h"
struct ieee80211_snap_hdr {
   u8 dsap ;
   u8 ssap ;
   u8 ctrl ;
   u8 oui[3U] ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 283 "drivers/staging/rtl8723au/include/drv_types.h"
struct wlan_pwr_cfg {
   u16 offset ;
   u8 cut_msk ;
   unsigned char fab_msk : 4 ;
   unsigned char interface_msk : 4 ;
   unsigned char base : 4 ;
   unsigned char cmd : 4 ;
   u8 msk ;
   u8 value ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 59 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
enum RF_RADIO_PATH {
    RF_PATH_A = 0,
    RF_PATH_B = 1,
    RF_PATH_MAX = 2
} ;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 267 "drivers/staging/rtl8723au/include/odm.h"
struct odm_packet_info {
   u8 Rate ;
   u8 StationID ;
   bool bPacketMatchBSSID ;
   bool bPacketToSelf ;
   bool bPacketBeacon ;
};
#line 854
enum odm_bb_config_type {
    CONFIG_BB_PHY_REG = 0,
    CONFIG_BB_AGC_TAB = 1,
    CONFIG_BB_AGC_TAB_2G = 2,
    CONFIG_BB_AGC_TAB_5G = 3,
    CONFIG_BB_PHY_REG_PG = 4
} ;
#line 1081 "drivers/staging/rtl8723au/include/odm.h"
struct phy_rx_agc_info {
   unsigned char gain : 7 ;
   unsigned char trsw : 1 ;
};
#line 72 "drivers/staging/rtl8723au/include/odm_HWConfig.h"
struct phy_status_rpt {
   struct phy_rx_agc_info path_agc[2U] ;
   u8 ch_corr[2U] ;
   u8 cck_sig_qual_ofdm_pwdb_all ;
   u8 cck_agc_rpt_ofdm_cfosho_a ;
   u8 cck_rpt_b_ofdm_cfosho_b ;
   u8 rsvd_1 ;
   u8 noise_power_db_msb ;
   u8 path_cfotail[2U] ;
   u8 pcts_mask[2U] ;
   s8 stream_rxevm[2U] ;
   u8 path_rxsnr[2U] ;
   u8 noise_power_db_lsb ;
   u8 rsvd_2[3U] ;
   u8 stream_csi[2U] ;
   u8 stream_target_csi[2U] ;
   s8 sig_evm ;
   u8 rsvd_3 ;
   unsigned char antsel_rx_keep_2 : 1 ;
   unsigned char sgi_en : 1 ;
   unsigned char rxsc : 2 ;
   unsigned char idle_long : 1 ;
   unsigned char r_ant_train_en : 1 ;
   unsigned char ant_sel_b : 1 ;
   unsigned char ant_sel : 1 ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 291 "drivers/staging/rtl8723au/include/odm.h"
enum odm_cmninfo {
    ODM_CMNINFO_PLATFORM = 0,
    ODM_CMNINFO_ABILITY = 1,
    ODM_CMNINFO_INTERFACE = 2,
    ODM_CMNINFO_MP_TEST_CHIP = 3,
    ODM_CMNINFO_IC_TYPE = 4,
    ODM_CMNINFO_CUT_VER = 5,
    ODM_CMNINFO_FAB_VER = 6,
    ODM_CMNINFO_RF_TYPE = 7,
    ODM_CMNINFO_BOARD_TYPE = 8,
    ODM_CMNINFO_EXT_LNA = 9,
    ODM_CMNINFO_EXT_PA = 10,
    ODM_CMNINFO_EXT_TRSW = 11,
    ODM_CMNINFO_PATCH_ID = 12,
    ODM_CMNINFO_BINHCT_TEST = 13,
    ODM_CMNINFO_BWIFI_TEST = 14,
    ODM_CMNINFO_SMART_CONCURRENT = 15,
    ODM_CMNINFO_MAC_PHY_MODE = 16,
    ODM_CMNINFO_TX_UNI = 17,
    ODM_CMNINFO_RX_UNI = 18,
    ODM_CMNINFO_WM_MODE = 19,
    ODM_CMNINFO_BAND = 20,
    ODM_CMNINFO_SEC_CHNL_OFFSET = 21,
    ODM_CMNINFO_SEC_MODE = 22,
    ODM_CMNINFO_BW = 23,
    ODM_CMNINFO_CHNL = 24,
    ODM_CMNINFO_DMSP_GET_VALUE = 25,
    ODM_CMNINFO_BUDDY_ADAPTOR = 26,
    ODM_CMNINFO_DMSP_IS_MASTER = 27,
    ODM_CMNINFO_SCAN = 28,
    ODM_CMNINFO_POWER_SAVING = 29,
    ODM_CMNINFO_ONE_PATH_CCA = 30,
    ODM_CMNINFO_DRV_STOP = 31,
    ODM_CMNINFO_PNP_IN = 32,
    ODM_CMNINFO_INIT_ON = 33,
    ODM_CMNINFO_ANT_TEST = 34,
    ODM_CMNINFO_NET_CLOSED = 35,
    ODM_CMNINFO_MP_MODE = 36,
    ODM_CMNINFO_WIFI_DIRECT = 37,
    ODM_CMNINFO_WIFI_DISPLAY = 38,
    ODM_CMNINFO_LINK = 39,
    ODM_CMNINFO_RSSI_MIN = 40,
    ODM_CMNINFO_DBG_COMP = 41,
    ODM_CMNINFO_DBG_LEVEL = 42,
    ODM_CMNINFO_RA_THRESHOLD_HIGH = 43,
    ODM_CMNINFO_RA_THRESHOLD_LOW = 44,
    ODM_CMNINFO_RF_ANTENNA_TYPE = 45,
    ODM_CMNINFO_BT_DISABLED = 46,
    ODM_CMNINFO_BT_OPERATION = 47,
    ODM_CMNINFO_BT_DIG = 48,
    ODM_CMNINFO_BT_BUSY = 49,
    ODM_CMNINFO_BT_DISABLE_EDCA = 50,
    ODM_CMNINFO_STA_STATUS = 51,
    ODM_CMNINFO_PHY_STATUS = 52,
    ODM_CMNINFO_MAC_STATUS = 53,
    ODM_CMNINFO_MAX = 54
} ;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 60 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
struct setpwrmode_parm {
   u8 Mode ;
   u8 SmartPS ;
   u8 AwakeInterval ;
   u8 bAllQueueUAPSD ;
   u8 BcnAntMode ;
};
#line 77 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
struct joinbssrpt_parm {
   u8 OpMode ;
};
#line 82 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
struct rsvdpage_loc {
   u8 LocProbeRsp ;
   u8 LocPsPoll ;
   u8 LocNullData ;
   u8 LocQosNull ;
   u8 LocBTQosNull ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 820 "drivers/staging/rtl8723au/include/rtw_cmd.h"
struct tx_desc {
   __le32 txdw0 ;
   __le32 txdw1 ;
   __le32 txdw2 ;
   __le32 txdw3 ;
   __le32 txdw4 ;
   __le32 txdw5 ;
   __le32 txdw6 ;
   __le32 txdw7 ;
};
#line 115 "drivers/staging/rtl8723au/include/rtw_efuse.h"
struct txpowerinfo {
   u8 CCKIndex[2U][12U] ;
   u8 HT40_1SIndex[2U][12U] ;
   u8 HT40_2SIndexDiff[2U][12U] ;
   u8 HT20IndexDiff[2U][12U] ;
   u8 OFDMIndexDiff[2U][12U] ;
   u8 HT40MaxOffset[2U][12U] ;
   u8 HT20MaxOffset[2U][12U] ;
   u8 TSSI_A[3U] ;
   u8 TSSI_B[3U] ;
   u8 TSSI_A_5G[3U] ;
   u8 TSSI_B_5G[3U] ;
};
#line 68 "drivers/staging/rtl8723au/include/rtl8723a_recv.h"
struct txdesc_8723a {
   unsigned short pktlen ;
   unsigned char offset ;
   unsigned char bmc : 1 ;
   unsigned char htc : 1 ;
   unsigned char ls : 1 ;
   unsigned char fs : 1 ;
   unsigned char linip : 1 ;
   unsigned char noacm : 1 ;
   unsigned char gf : 1 ;
   unsigned char own : 1 ;
   unsigned char macid : 5 ;
   unsigned char agg_en : 1 ;
   unsigned char bk : 1 ;
   unsigned char rd_en : 1 ;
   unsigned char qsel : 5 ;
   unsigned char rd_nav_ext : 1 ;
   unsigned char lsig_txop_en : 1 ;
   unsigned char pifs : 1 ;
   unsigned char rate_id : 4 ;
   unsigned char navusehdr : 1 ;
   unsigned char en_desc_id : 1 ;
   unsigned char sectype : 2 ;
   unsigned char rsvd0424 : 2 ;
   unsigned char pkt_offset : 5 ;
   unsigned char rsvd0431 : 1 ;
   unsigned char rts_rc : 6 ;
   unsigned char data_rc : 6 ;
   unsigned char rsvd0812 : 2 ;
   unsigned char bar_rty_th : 2 ;
   unsigned char rsvd0816 : 1 ;
   unsigned char morefrag : 1 ;
   unsigned char raw : 1 ;
   unsigned char ccx : 1 ;
   unsigned char ampdu_density : 3 ;
   unsigned char bt_null : 1 ;
   unsigned char ant_sel_a : 1 ;
   unsigned char ant_sel_b : 1 ;
   unsigned char tx_ant_cck : 2 ;
   unsigned char tx_antl : 2 ;
   unsigned char tx_ant_ht : 2 ;
   unsigned char nextheadpage ;
   unsigned char tailpage ;
   unsigned short seq : 12 ;
   unsigned char cpu_handle : 1 ;
   unsigned char tag1 : 1 ;
   unsigned char trigger_int : 1 ;
   unsigned char hwseq_en : 1 ;
   unsigned char rtsrate : 5 ;
   unsigned char ap_dcfe : 1 ;
   unsigned char hwseq_sel : 2 ;
   unsigned char userate : 1 ;
   unsigned char disrtsfb : 1 ;
   unsigned char disdatafb : 1 ;
   unsigned char cts2self : 1 ;
   unsigned char rtsen : 1 ;
   unsigned char hw_rts_en : 1 ;
   unsigned char port_id : 1 ;
   unsigned char rsvd1615 : 3 ;
   unsigned char wait_dcts : 1 ;
   unsigned char cts2ap_en : 1 ;
   unsigned char data_sc : 2 ;
   unsigned char data_stbc : 2 ;
   unsigned char data_short : 1 ;
   unsigned char data_bw : 1 ;
   unsigned char rts_short : 1 ;
   unsigned char rts_bw : 1 ;
   unsigned char rts_sc : 2 ;
   unsigned char vcs_stbc : 2 ;
   unsigned char datarate : 6 ;
   unsigned char sgi : 1 ;
   unsigned char try_rate : 1 ;
   unsigned char data_ratefb_lmt : 5 ;
   unsigned char rts_ratefb_lmt : 4 ;
   unsigned char rty_lmt_en : 1 ;
   unsigned char data_rt_lmt : 6 ;
   unsigned char usb_txagg_num ;
   unsigned char txagg_a : 5 ;
   unsigned char txagg_b : 5 ;
   unsigned char use_max_len : 1 ;
   unsigned char max_agg_num : 5 ;
   unsigned char mcsg1_max_len : 4 ;
   unsigned char mcsg2_max_len : 4 ;
   unsigned char mcsg3_max_len : 4 ;
   unsigned char mcs7_sgi_max_len : 4 ;
   unsigned short checksum ;
   unsigned char mcsg4_max_len : 4 ;
   unsigned char mcsg5_max_len : 4 ;
   unsigned char mcsg6_max_len : 4 ;
   unsigned char mcs15_sgi_max_len : 4 ;
};
#line 24 "drivers/staging/rtl8723au/include/rtl8723a_sreset.h"
struct rt_8723a_firmware_hdr {
   u16 Signature ;
   u8 Category ;
   u8 Function ;
   u16 Version ;
   u8 Subversion ;
   u16 Rsvd1 ;
   u8 Month ;
   u8 Date ;
   u8 Hour ;
   u8 Minute ;
   u16 RamCodeSize ;
   u16 Rsvd2 ;
   u32 SvnIdx ;
   u32 Rsvd3 ;
   u32 Rsvd4 ;
   u32 Rsvd5 ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 169 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
struct txrpt_ccx_8723a {
   unsigned char tag1 : 1 ;
   unsigned char rsvd : 4 ;
   unsigned char int_bt : 1 ;
   unsigned char int_tri : 1 ;
   unsigned char int_ccx : 1 ;
   unsigned char mac_id : 5 ;
   unsigned char pkt_drop : 1 ;
   unsigned char pkt_ok : 1 ;
   unsigned char bmc : 1 ;
   unsigned char retry_cnt : 6 ;
   unsigned char lifetime_over : 1 ;
   unsigned char retry_over : 1 ;
   u8 ccx_qtime0 ;
   u8 ccx_qtime1 ;
   u8 final_data_rate ;
   unsigned char sw1 : 4 ;
   unsigned char qsel : 4 ;
   u8 sw0 ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 142 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_stat {
   __le32 rxdw0 ;
   __le32 rxdw1 ;
   __le32 rxdw2 ;
   __le32 rxdw3 ;
   __le32 rxdw4 ;
   __le32 rxdw5 ;
};
#line 141 "drivers/staging/rtl8723au/include/rtl8723a_dm.h"
struct phy_stat {
   unsigned int phydw0 ;
   unsigned int phydw1 ;
   unsigned int phydw2 ;
   unsigned int phydw3 ;
   unsigned int phydw4 ;
   unsigned int phydw5 ;
   unsigned int phydw6 ;
   unsigned int phydw7 ;
};
#line 423 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
struct rxreport_8723a {
   unsigned short pktlen : 14 ;
   unsigned char crc32 : 1 ;
   unsigned char icverr : 1 ;
   unsigned char drvinfosize : 4 ;
   unsigned char security : 3 ;
   unsigned char qos : 1 ;
   unsigned char shift : 2 ;
   unsigned char physt : 1 ;
   unsigned char swdec : 1 ;
   unsigned char ls : 1 ;
   unsigned char fs : 1 ;
   unsigned char eor : 1 ;
   unsigned char own : 1 ;
   unsigned char macid : 5 ;
   unsigned char tid : 4 ;
   unsigned char hwrsvd : 4 ;
   unsigned char amsdu : 1 ;
   unsigned char paggr : 1 ;
   unsigned char faggr : 1 ;
   unsigned char a1fit : 4 ;
   unsigned char a2fit : 4 ;
   unsigned char pam : 1 ;
   unsigned char pwr : 1 ;
   unsigned char md : 1 ;
   unsigned char mf : 1 ;
   unsigned char type : 2 ;
   unsigned char mc : 1 ;
   unsigned char bc : 1 ;
   unsigned short seq : 12 ;
   unsigned char frag : 4 ;
   unsigned short nextpktlen : 14 ;
   unsigned char nextind : 1 ;
   unsigned char rsvd0831 : 1 ;
   unsigned char rxmcs : 6 ;
   unsigned char rxht : 1 ;
   unsigned char gf : 1 ;
   unsigned char splcp : 1 ;
   unsigned char bw : 1 ;
   unsigned char htc : 1 ;
   unsigned char eosp : 1 ;
   unsigned char bssidfit : 2 ;
   unsigned short rsvd1214 ;
   unsigned char unicastwake : 1 ;
   unsigned char magicwake : 1 ;
   unsigned char pattern0match : 1 ;
   unsigned char pattern1match : 1 ;
   unsigned char pattern2match : 1 ;
   unsigned char pattern3match : 1 ;
   unsigned char pattern4match : 1 ;
   unsigned char pattern5match : 1 ;
   unsigned char pattern6match : 1 ;
   unsigned char pattern7match : 1 ;
   unsigned char pattern8match : 1 ;
   unsigned char pattern9match : 1 ;
   unsigned char patternamatch : 1 ;
   unsigned char patternbmatch : 1 ;
   unsigned char patterncmatch : 1 ;
   unsigned int rsvd1613 : 19 ;
   u32 tsfl ;
   unsigned short bassn : 12 ;
   unsigned char bavld : 1 ;
   unsigned int rsvd2413 : 19 ;
};
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct recv_stat_cpu {
   u32 rxdw0 ;
   u32 rxdw1 ;
   u32 rxdw2 ;
   u32 rxdw3 ;
   u32 rxdw4 ;
   u32 rxdw5 ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 348 "drivers/staging/rtl8723au/include/rtw_security.h"
struct reportpwrstate_parm {
   unsigned char mode ;
   unsigned char state ;
   unsigned short rsvd ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct station_parameters;
#line 63
struct station_info;
#line 71
struct vif_params;
#line 129
struct cfg80211_pmksa;
#line 37 "include/linux/ip.h"
struct ieee80211_radiotap_header {
   u8 it_version ;
   u8 it_pad ;
   __le16 it_len ;
   __le32 it_present ;
};
#line 459 "include/linux/debugfs.h"
struct nl80211_sta_flag_update {
   __u32 mask ;
   __u32 set ;
};
#line 2298 "./include/uapi/linux/nl80211.h"
enum nl80211_mesh_power_mode {
    NL80211_MESH_POWER_UNKNOWN = 0,
    NL80211_MESH_POWER_ACTIVE = 1,
    NL80211_MESH_POWER_LIGHT_SLEEP = 2,
    NL80211_MESH_POWER_DEEP_SLEEP = 3,
    __NL80211_MESH_POWER_AFTER_LAST = 4,
    NL80211_MESH_POWER_MAX = 3
} ;
#line 2366
enum nl80211_ac {
    NL80211_AC_VO = 0,
    NL80211_AC_VI = 1,
    NL80211_AC_BE = 2,
    NL80211_AC_BK = 3,
    NL80211_NUM_ACS = 4
} ;
#line 3259
enum nl80211_txrate_gi {
    NL80211_TXRATE_DEFAULT_GI = 0,
    NL80211_TXRATE_FORCE_SGI = 1,
    NL80211_TXRATE_FORCE_LGI = 2
} ;
#line 3295
enum nl80211_tx_power_setting {
    NL80211_TX_POWER_AUTOMATIC = 0,
    NL80211_TX_POWER_LIMITED = 1,
    NL80211_TX_POWER_FIXED = 2
} ;
#line 3641
enum nl80211_coalesce_condition {
    NL80211_COALESCE_CONDITION_MATCH = 0,
    NL80211_COALESCE_CONDITION_NO_MATCH = 1
} ;
#line 3694
enum nl80211_hidden_ssid {
    NL80211_HIDDEN_SSID_NOT_IN_USE = 0,
    NL80211_HIDDEN_SSID_ZERO_LEN = 1,
    NL80211_HIDDEN_SSID_ZERO_CONTENTS = 2
} ;
#line 3717
enum nl80211_tdls_operation {
    NL80211_TDLS_DISCOVERY_REQ = 0,
    NL80211_TDLS_SETUP = 1,
    NL80211_TDLS_TEARDOWN = 2,
    NL80211_TDLS_ENABLE_LINK = 3,
    NL80211_TDLS_DISABLE_LINK = 4
} ;
#line 3764
enum nl80211_acl_policy {
    NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED = 0,
    NL80211_ACL_POLICY_DENY_UNLESS_LISTED = 1
} ;
#line 3786
enum nl80211_crit_proto_id {
    NL80211_CRIT_PROTO_UNSPEC = 0,
    NL80211_CRIT_PROTO_DHCP = 1,
    NL80211_CRIT_PROTO_EAPOL = 2,
    NL80211_CRIT_PROTO_APIPA = 3,
    NUM_NL80211_CRIT_PROTO = 4
} ;
#line 298 "include/net/cfg80211.h"
struct vif_params {
   int use_4addr ;
   u8 macaddr[6U] ;
};
#line 329 "include/net/cfg80211.h"
struct key_params {
   u8 const   *key ;
   u8 const   *seq ;
   int key_len ;
   int seq_len ;
   u32 cipher ;
};
#line 523 "include/net/cfg80211.h"
struct survey_info {
   struct ieee80211_channel *channel ;
   u64 channel_time ;
   u64 channel_time_busy ;
   u64 channel_time_ext_busy ;
   u64 channel_time_rx ;
   u64 channel_time_tx ;
   u32 filled ;
   s8 noise ;
};
#line 596 "include/net/cfg80211.h"
struct cfg80211_beacon_data {
   u8 const   *head ;
   u8 const   *tail ;
   u8 const   *beacon_ies ;
   u8 const   *proberesp_ies ;
   u8 const   *assocresp_ies ;
   u8 const   *probe_resp ;
   size_t head_len ;
   size_t tail_len ;
   size_t beacon_ies_len ;
   size_t proberesp_ies_len ;
   size_t assocresp_ies_len ;
   size_t probe_resp_len ;
};
#line 633 "include/net/cfg80211.h"
struct cfg80211_acl_data {
   enum nl80211_acl_policy acl_policy ;
   int n_acl_entries ;
   struct mac_address mac_addrs[] ;
};
#line 649 "include/net/cfg80211.h"
struct cfg80211_ap_settings {
   struct cfg80211_chan_def chandef ;
   struct cfg80211_beacon_data beacon ;
   int beacon_interval ;
   int dtim_period ;
   u8 const   *ssid ;
   size_t ssid_len ;
   enum nl80211_hidden_ssid hidden_ssid ;
   struct cfg80211_crypto_settings crypto ;
   bool privacy ;
   enum nl80211_auth_type auth_type ;
   int inactivity_timeout ;
   u8 p2p_ctwindow ;
   bool p2p_opp_ps ;
   struct cfg80211_acl_data  const  *acl ;
};
#line 689 "include/net/cfg80211.h"
struct cfg80211_csa_settings {
   struct cfg80211_chan_def chandef ;
   struct cfg80211_beacon_data beacon_csa ;
   u16 const   *counter_offsets_beacon ;
   u16 const   *counter_offsets_presp ;
   unsigned int n_counter_offsets_beacon ;
   unsigned int n_counter_offsets_presp ;
   struct cfg80211_beacon_data beacon_after ;
   bool radar_required ;
   bool block_tx ;
   u8 count ;
};
#line 724 "include/net/cfg80211.h"
struct station_parameters {
   u8 const   *supported_rates ;
   struct net_device *vlan ;
   u32 sta_flags_mask ;
   u32 sta_flags_set ;
   u32 sta_modify_mask ;
   int listen_interval ;
   u16 aid ;
   u8 supported_rates_len ;
   u8 plink_action ;
   u8 plink_state ;
   struct ieee80211_ht_cap  const  *ht_capa ;
   struct ieee80211_vht_cap  const  *vht_capa ;
   u8 uapsd_queues ;
   u8 max_sp ;
   enum nl80211_mesh_power_mode local_pm ;
   u16 capability ;
   u8 const   *ext_capab ;
   u8 ext_capab_len ;
   u8 const   *supported_channels ;
   u8 supported_channels_len ;
   u8 const   *supported_oper_classes ;
   u8 supported_oper_classes_len ;
   u8 opmode_notif ;
   bool opmode_notif_used ;
};
#line 881 "include/net/cfg80211.h"
struct rate_info {
   u8 flags ;
   u8 mcs ;
   u16 legacy ;
   u8 nss ;
};
#line 958 "include/net/cfg80211.h"
struct sta_bss_parameters {
   u8 flags ;
   u8 dtim_period ;
   u16 beacon_interval ;
};
#line 983 "include/net/cfg80211.h"
struct station_info {
   u32 filled ;
   u32 connected_time ;
   u32 inactive_time ;
   u64 rx_bytes ;
   u64 tx_bytes ;
   u16 llid ;
   u16 plid ;
   u8 plink_state ;
   s8 signal ;
   s8 signal_avg ;
   u8 chains ;
   s8 chain_signal[4U] ;
   s8 chain_signal_avg[4U] ;
   struct rate_info txrate ;
   struct rate_info rxrate ;
   u32 rx_packets ;
   u32 tx_packets ;
   u32 tx_retries ;
   u32 tx_failed ;
   u32 rx_dropped_misc ;
   struct sta_bss_parameters bss_param ;
   struct nl80211_sta_flag_update sta_flags ;
   int generation ;
   u8 const   *assoc_req_ies ;
   size_t assoc_req_ies_len ;
   u32 beacon_loss_count ;
   s64 t_offset ;
   enum nl80211_mesh_power_mode local_pm ;
   enum nl80211_mesh_power_mode peer_pm ;
   enum nl80211_mesh_power_mode nonpeer_pm ;
   u32 expected_throughput ;
};
#line 1107 "include/net/cfg80211.h"
struct mpath_info {
   u32 filled ;
   u32 frame_qlen ;
   u32 sn ;
   u32 metric ;
   u32 exptime ;
   u32 discovery_timeout ;
   u8 discovery_retries ;
   u8 flags ;
   int generation ;
};
#line 1166 "include/net/cfg80211.h"
struct bss_parameters {
   int use_cts_prot ;
   int use_short_preamble ;
   int use_short_slot_time ;
   u8 const   *basic_rates ;
   u8 basic_rates_len ;
   int ap_isolate ;
   int ht_opmode ;
   s8 p2p_ctwindow ;
   s8 p2p_opp_ps ;
};
#line 1197 "include/net/cfg80211.h"
struct mesh_config {
   u16 dot11MeshRetryTimeout ;
   u16 dot11MeshConfirmTimeout ;
   u16 dot11MeshHoldingTimeout ;
   u16 dot11MeshMaxPeerLinks ;
   u8 dot11MeshMaxRetries ;
   u8 dot11MeshTTL ;
   u8 element_ttl ;
   bool auto_open_plinks ;
   u32 dot11MeshNbrOffsetMaxNeighbor ;
   u8 dot11MeshHWMPmaxPREQretries ;
   u32 path_refresh_time ;
   u16 min_discovery_timeout ;
   u32 dot11MeshHWMPactivePathTimeout ;
   u16 dot11MeshHWMPpreqMinInterval ;
   u16 dot11MeshHWMPperrMinInterval ;
   u16 dot11MeshHWMPnetDiameterTraversalTime ;
   u8 dot11MeshHWMPRootMode ;
   u16 dot11MeshHWMPRannInterval ;
   bool dot11MeshGateAnnouncementProtocol ;
   bool dot11MeshForwarding ;
   s32 rssi_threshold ;
   u16 ht_opmode ;
   u32 dot11MeshHWMPactivePathToRootTimeout ;
   u16 dot11MeshHWMProotInterval ;
   u16 dot11MeshHWMPconfirmationInterval ;
   enum nl80211_mesh_power_mode power_mode ;
   u16 dot11MeshAwakeWindowDuration ;
   u32 plink_timeout ;
};
#line 1298 "include/net/cfg80211.h"
struct mesh_setup {
   struct cfg80211_chan_def chandef ;
   u8 const   *mesh_id ;
   u8 mesh_id_len ;
   u8 sync_method ;
   u8 path_sel_proto ;
   u8 path_metric ;
   u8 auth_id ;
   u8 const   *ie ;
   u8 ie_len ;
   bool is_authenticated ;
   bool is_secure ;
   bool user_mpm ;
   u8 dtim_period ;
   u16 beacon_interval ;
   int mcast_rate[3U] ;
   u32 basic_rates ;
};
#line 1338 "include/net/cfg80211.h"
struct ieee80211_txq_params {
   enum nl80211_ac ac ;
   u16 txop ;
   u16 cwmin ;
   u16 cwmax ;
   u8 aifs ;
};
#line 1431 "include/net/cfg80211.h"
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};
#line 1442 "include/net/cfg80211.h"
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
   s32 min_rssi_thold ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct ieee80211_channel *channels[0U] ;
};
#line 1493 "include/net/cfg80211.h"
struct cfg80211_bss_ies {
   u64 tsf ;
   struct callback_head callback_head ;
   int len ;
   u8 data[] ;
};
#line 1514 "include/net/cfg80211.h"
struct cfg80211_bss {
   struct ieee80211_channel *channel ;
   enum nl80211_bss_scan_width scan_width ;
   struct cfg80211_bss_ies  const  *ies ;
   struct cfg80211_bss_ies  const  *beacon_ies ;
   struct cfg80211_bss_ies  const  *proberesp_ies ;
   struct cfg80211_bss *hidden_beacon_bss ;
   s32 signal ;
   u16 beacon_interval ;
   u16 capability ;
   u8 bssid[6U] ;
   u8 priv[0U] ;
};
#line 1572 "include/net/cfg80211.h"
struct cfg80211_auth_request {
   struct cfg80211_bss *bss ;
   u8 const   *ie ;
   size_t ie_len ;
   enum nl80211_auth_type auth_type ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
   u8 const   *sae_data ;
   size_t sae_data_len ;
};
#line 1607 "include/net/cfg80211.h"
struct cfg80211_assoc_request {
   struct cfg80211_bss *bss ;
   u8 const   *ie ;
   u8 const   *prev_bssid ;
   size_t ie_len ;
   struct cfg80211_crypto_settings crypto ;
   bool use_mfp ;
   u32 flags ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
#line 1646 "include/net/cfg80211.h"
struct cfg80211_deauth_request {
   u8 const   *bssid ;
   u8 const   *ie ;
   size_t ie_len ;
   u16 reason_code ;
   bool local_state_change ;
};
#line 1667 "include/net/cfg80211.h"
struct cfg80211_disassoc_request {
   struct cfg80211_bss *bss ;
   u8 const   *ie ;
   size_t ie_len ;
   u16 reason_code ;
   bool local_state_change ;
};
#line 1803 "include/net/cfg80211.h"
struct __anonstruct_control_289 {
   u32 legacy ;
   u8 ht_mcs[10U] ;
   u16 vht_mcs[8U] ;
   enum nl80211_txrate_gi gi ;
};
#line 1803 "include/net/cfg80211.h"
struct cfg80211_bitrate_mask {
   struct __anonstruct_control_289 control[3U] ;
};
#line 1823 "include/net/cfg80211.h"
struct cfg80211_pmksa {
   u8 const   *bssid ;
   u8 const   *pmkid ;
};
#line 1914 "include/net/cfg80211.h"
struct cfg80211_coalesce_rules {
   int delay ;
   enum nl80211_coalesce_condition condition ;
   struct cfg80211_pkt_pattern *patterns ;
   int n_patterns ;
};
#line 1931 "include/net/cfg80211.h"
struct cfg80211_coalesce {
   struct cfg80211_coalesce_rules *rules ;
   int n_rules ;
};
#line 1973 "include/net/cfg80211.h"
struct cfg80211_gtk_rekey_data {
   u8 kek[16U] ;
   u8 kck[16U] ;
   u8 replay_ctr[8U] ;
};
#line 1985 "include/net/cfg80211.h"
struct cfg80211_update_ft_ies_params {
   u16 md ;
   u8 const   *ie ;
   size_t ie_len ;
};
#line 2000 "include/net/cfg80211.h"
struct cfg80211_mgmt_tx_params {
   struct ieee80211_channel *chan ;
   bool offchan ;
   unsigned int wait ;
   u8 const   *buf ;
   size_t len ;
   bool no_cck ;
   bool dont_wait_for_ack ;
   int n_csa_offsets ;
   u16 const   *csa_offsets ;
};
#line 2027 "include/net/cfg80211.h"
struct cfg80211_dscp_exception {
   u8 dscp ;
   u8 up ;
};
#line 2038 "include/net/cfg80211.h"
struct cfg80211_dscp_range {
   u8 low ;
   u8 high ;
};
#line 2049 "include/net/cfg80211.h"
struct cfg80211_qos_map {
   u8 num_des ;
   struct cfg80211_dscp_exception dscp_exception[21U] ;
   struct cfg80211_dscp_range up[8U] ;
};
#line 2071 "include/net/cfg80211.h"
struct cfg80211_ops {
   int (*suspend)(struct wiphy * , struct cfg80211_wowlan * ) ;
   int (*resume)(struct wiphy * ) ;
   void (*set_wakeup)(struct wiphy * , bool  ) ;
   struct wireless_dev *(*add_virtual_intf)(struct wiphy * , char const   * , enum nl80211_iftype  ,
                                            u32 * , struct vif_params * ) ;
   int (*del_virtual_intf)(struct wiphy * , struct wireless_dev * ) ;
   int (*change_virtual_intf)(struct wiphy * , struct net_device * , enum nl80211_iftype  ,
                              u32 * , struct vif_params * ) ;
   int (*add_key)(struct wiphy * , struct net_device * , u8  , bool  , u8 const   * ,
                  struct key_params * ) ;
   int (*get_key)(struct wiphy * , struct net_device * , u8  , bool  , u8 const   * ,
                  void * , void (*)(void * , struct key_params * ) ) ;
   int (*del_key)(struct wiphy * , struct net_device * , u8  , bool  , u8 const   * ) ;
   int (*set_default_key)(struct wiphy * , struct net_device * , u8  , bool  , bool  ) ;
   int (*set_default_mgmt_key)(struct wiphy * , struct net_device * , u8  ) ;
   int (*start_ap)(struct wiphy * , struct net_device * , struct cfg80211_ap_settings * ) ;
   int (*change_beacon)(struct wiphy * , struct net_device * , struct cfg80211_beacon_data * ) ;
   int (*stop_ap)(struct wiphy * , struct net_device * ) ;
   int (*add_station)(struct wiphy * , struct net_device * , u8 const   * , struct station_parameters * ) ;
   int (*del_station)(struct wiphy * , struct net_device * , u8 const   * ) ;
   int (*change_station)(struct wiphy * , struct net_device * , u8 const   * , struct station_parameters * ) ;
   int (*get_station)(struct wiphy * , struct net_device * , u8 const   * , struct station_info * ) ;
   int (*dump_station)(struct wiphy * , struct net_device * , int  , u8 * , struct station_info * ) ;
   int (*add_mpath)(struct wiphy * , struct net_device * , u8 const   * , u8 const   * ) ;
   int (*del_mpath)(struct wiphy * , struct net_device * , u8 const   * ) ;
   int (*change_mpath)(struct wiphy * , struct net_device * , u8 const   * , u8 const   * ) ;
   int (*get_mpath)(struct wiphy * , struct net_device * , u8 * , u8 * , struct mpath_info * ) ;
   int (*dump_mpath)(struct wiphy * , struct net_device * , int  , u8 * , u8 * , struct mpath_info * ) ;
   int (*get_mesh_config)(struct wiphy * , struct net_device * , struct mesh_config * ) ;
   int (*update_mesh_config)(struct wiphy * , struct net_device * , u32  , struct mesh_config  const  * ) ;
   int (*join_mesh)(struct wiphy * , struct net_device * , struct mesh_config  const  * ,
                    struct mesh_setup  const  * ) ;
   int (*leave_mesh)(struct wiphy * , struct net_device * ) ;
   int (*change_bss)(struct wiphy * , struct net_device * , struct bss_parameters * ) ;
   int (*set_txq_params)(struct wiphy * , struct net_device * , struct ieee80211_txq_params * ) ;
   int (*libertas_set_mesh_channel)(struct wiphy * , struct net_device * , struct ieee80211_channel * ) ;
   int (*set_monitor_channel)(struct wiphy * , struct cfg80211_chan_def * ) ;
   int (*scan)(struct wiphy * , struct cfg80211_scan_request * ) ;
   int (*auth)(struct wiphy * , struct net_device * , struct cfg80211_auth_request * ) ;
   int (*assoc)(struct wiphy * , struct net_device * , struct cfg80211_assoc_request * ) ;
   int (*deauth)(struct wiphy * , struct net_device * , struct cfg80211_deauth_request * ) ;
   int (*disassoc)(struct wiphy * , struct net_device * , struct cfg80211_disassoc_request * ) ;
   int (*connect)(struct wiphy * , struct net_device * , struct cfg80211_connect_params * ) ;
   int (*disconnect)(struct wiphy * , struct net_device * , u16  ) ;
   int (*join_ibss)(struct wiphy * , struct net_device * , struct cfg80211_ibss_params * ) ;
   int (*leave_ibss)(struct wiphy * , struct net_device * ) ;
   int (*set_mcast_rate)(struct wiphy * , struct net_device * , int * ) ;
   int (*set_wiphy_params)(struct wiphy * , u32  ) ;
   int (*set_tx_power)(struct wiphy * , struct wireless_dev * , enum nl80211_tx_power_setting  ,
                       int  ) ;
   int (*get_tx_power)(struct wiphy * , struct wireless_dev * , int * ) ;
   int (*set_wds_peer)(struct wiphy * , struct net_device * , u8 const   * ) ;
   void (*rfkill_poll)(struct wiphy * ) ;
   int (*testmode_cmd)(struct wiphy * , struct wireless_dev * , void * , int  ) ;
   int (*testmode_dump)(struct wiphy * , struct sk_buff * , struct netlink_callback * ,
                        void * , int  ) ;
   int (*set_bitrate_mask)(struct wiphy * , struct net_device * , u8 const   * , struct cfg80211_bitrate_mask  const  * ) ;
   int (*dump_survey)(struct wiphy * , struct net_device * , int  , struct survey_info * ) ;
   int (*set_pmksa)(struct wiphy * , struct net_device * , struct cfg80211_pmksa * ) ;
   int (*del_pmksa)(struct wiphy * , struct net_device * , struct cfg80211_pmksa * ) ;
   int (*flush_pmksa)(struct wiphy * , struct net_device * ) ;
   int (*remain_on_channel)(struct wiphy * , struct wireless_dev * , struct ieee80211_channel * ,
                            unsigned int  , u64 * ) ;
   int (*cancel_remain_on_channel)(struct wiphy * , struct wireless_dev * , u64  ) ;
   int (*mgmt_tx)(struct wiphy * , struct wireless_dev * , struct cfg80211_mgmt_tx_params * ,
                  u64 * ) ;
   int (*mgmt_tx_cancel_wait)(struct wiphy * , struct wireless_dev * , u64  ) ;
   int (*set_power_mgmt)(struct wiphy * , struct net_device * , bool  , int  ) ;
   int (*set_cqm_rssi_config)(struct wiphy * , struct net_device * , s32  , u32  ) ;
   int (*set_cqm_txe_config)(struct wiphy * , struct net_device * , u32  , u32  ,
                             u32  ) ;
   void (*mgmt_frame_register)(struct wiphy * , struct wireless_dev * , u16  , bool  ) ;
   int (*set_antenna)(struct wiphy * , u32  , u32  ) ;
   int (*get_antenna)(struct wiphy * , u32 * , u32 * ) ;
   int (*set_ringparam)(struct wiphy * , u32  , u32  ) ;
   void (*get_ringparam)(struct wiphy * , u32 * , u32 * , u32 * , u32 * ) ;
   int (*sched_scan_start)(struct wiphy * , struct net_device * , struct cfg80211_sched_scan_request * ) ;
   int (*sched_scan_stop)(struct wiphy * , struct net_device * ) ;
   int (*set_rekey_data)(struct wiphy * , struct net_device * , struct cfg80211_gtk_rekey_data * ) ;
   int (*tdls_mgmt)(struct wiphy * , struct net_device * , u8 const   * , u8  , u8  ,
                    u16  , u32  , u8 const   * , size_t  ) ;
   int (*tdls_oper)(struct wiphy * , struct net_device * , u8 const   * , enum nl80211_tdls_operation  ) ;
   int (*probe_client)(struct wiphy * , struct net_device * , u8 const   * , u64 * ) ;
   int (*set_noack_map)(struct wiphy * , struct net_device * , u16  ) ;
   int (*get_et_sset_count)(struct wiphy * , struct net_device * , int  ) ;
   void (*get_et_stats)(struct wiphy * , struct net_device * , struct ethtool_stats * ,
                        u64 * ) ;
   void (*get_et_strings)(struct wiphy * , struct net_device * , u32  , u8 * ) ;
   int (*get_channel)(struct wiphy * , struct wireless_dev * , struct cfg80211_chan_def * ) ;
   int (*start_p2p_device)(struct wiphy * , struct wireless_dev * ) ;
   void (*stop_p2p_device)(struct wiphy * , struct wireless_dev * ) ;
   int (*set_mac_acl)(struct wiphy * , struct net_device * , struct cfg80211_acl_data  const  * ) ;
   int (*start_radar_detection)(struct wiphy * , struct net_device * , struct cfg80211_chan_def * ,
                                u32  ) ;
   int (*update_ft_ies)(struct wiphy * , struct net_device * , struct cfg80211_update_ft_ies_params * ) ;
   int (*crit_proto_start)(struct wiphy * , struct wireless_dev * , enum nl80211_crit_proto_id  ,
                           u16  ) ;
   void (*crit_proto_stop)(struct wiphy * , struct wireless_dev * ) ;
   int (*set_coalesce)(struct wiphy * , struct cfg80211_coalesce * ) ;
   int (*channel_switch)(struct wiphy * , struct net_device * , struct cfg80211_csa_settings * ) ;
   int (*set_qos_map)(struct wiphy * , struct net_device * , struct cfg80211_qos_map * ) ;
   int (*set_ap_chanwidth)(struct wiphy * , struct net_device * , struct cfg80211_chan_def * ) ;
};
#line 121 "drivers/staging/rtl8723au/include/ieee80211.h"
struct __anonstruct_wpa_param_294 {
   u8 name ;
   u32 value ;
};
#line 121 "drivers/staging/rtl8723au/include/ieee80211.h"
struct __anonstruct_wpa_ie_295 {
   u32 len ;
   u8 reserved[32U] ;
   u8 data[0U] ;
};
#line 121 "drivers/staging/rtl8723au/include/ieee80211.h"
struct __anonstruct_mlme_296 {
   int command ;
   int reason_code ;
};
#line 121 "drivers/staging/rtl8723au/include/ieee80211.h"
struct __anonstruct_crypt_297 {
   u8 alg[16U] ;
   u8 set_tx ;
   u32 err ;
   u8 idx ;
   u8 seq[8U] ;
   u16 key_len ;
   u8 key[0U] ;
};
#line 121 "drivers/staging/rtl8723au/include/ieee80211.h"
struct __anonstruct_add_sta_298 {
   u16 aid ;
   u16 capability ;
   int flags ;
   u8 tx_supp_rates[16U] ;
   struct ieee80211_ht_cap ht_cap ;
};
#line 121 "drivers/staging/rtl8723au/include/ieee80211.h"
struct __anonstruct_bcn_ie_299 {
   u8 reserved[2U] ;
   u8 buf[0U] ;
};
#line 121 "drivers/staging/rtl8723au/include/ieee80211.h"
union __anonunion_u_293 {
   struct __anonstruct_wpa_param_294 wpa_param ;
   struct __anonstruct_wpa_ie_295 wpa_ie ;
   struct __anonstruct_mlme_296 mlme ;
   struct __anonstruct_crypt_297 crypt ;
   struct __anonstruct_add_sta_298 add_sta ;
   struct __anonstruct_bcn_ie_299 bcn_ie ;
};
#line 121 "drivers/staging/rtl8723au/include/ieee80211.h"
struct ieee_param {
   u32 cmd ;
   u8 sta_addr[6U] ;
   union __anonunion_u_293 u ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 279
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 386 "include/linux/etherdevice.h"
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
#line 680 "include/uapi/linux/wireless.h"
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
#line 691 "include/uapi/linux/wireless.h"
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
#line 708 "include/uapi/linux/wireless.h"
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
#line 864 "include/uapi/linux/wireless.h"
struct iw_michaelmicfailure {
   __u32 flags ;
   struct sockaddr src_addr ;
   __u8 tsc[8U] ;
};
#line 897 "include/uapi/linux/wireless.h"
union iwreq_data {
   char name[16U] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
#line 2433 "./include/uapi/linux/nl80211.h"
enum nl80211_key_type {
    NL80211_KEYTYPE_GROUP = 0,
    NL80211_KEYTYPE_PAIRWISE = 1,
    NL80211_KEYTYPE_PEERKEY = 2,
    NUM_NL80211_KEYTYPES = 3
} ;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 39 "include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info ;
};
#line 273 "include/linux/pm_runtime.h"
struct usb_driver;
#line 798 "include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 986 "include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
#line 996 "include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface * , struct usb_device_id  const  * ) ;
   void (*disconnect)(struct usb_interface * ) ;
   int (*unlocked_ioctl)(struct usb_interface * , unsigned int  , void * ) ;
   int (*suspend)(struct usb_interface * , pm_message_t  ) ;
   int (*resume)(struct usb_interface * ) ;
   int (*reset_resume)(struct usb_interface * ) ;
   int (*pre_reset)(struct usb_interface * ) ;
   int (*post_reset)(struct usb_interface * ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned char no_dynamic_id : 1 ;
   unsigned char supports_autosuspend : 1 ;
   unsigned char disable_hub_initiated_lpm : 1 ;
   unsigned char soft_unbind : 1 ;
};
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 307
enum hrtimer_restart;
#line 57 "drivers/staging/rtl8723au/include/rtl8723a_rf.h"
enum rt_media_status;
#line 57
enum rt_media_status;
#line 862 "drivers/staging/rtl8723au/include/odm.h"
enum rt_status {
    RT_STATUS_SUCCESS = 0,
    RT_STATUS_FAILURE = 1,
    RT_STATUS_PENDING = 2,
    RT_STATUS_RESOURCE = 3,
    RT_STATUS_INVALID_CONTEXT = 4,
    RT_STATUS_INVALID_PARAMETER = 5,
    RT_STATUS_NOT_SUPPORT = 6,
    RT_STATUS_OS_API_FAILED = 7
} ;
#line 69 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct chnl_txpower_triple {
   u8 FirstChnl ;
   u8 NumChnls ;
   s8 MaxTxPowerInDbm ;
};
#line 469
enum hci_state_with_cmd {
    STATE_CMD_CREATE_PHY_LINK = 0,
    STATE_CMD_ACCEPT_PHY_LINK = 1,
    STATE_CMD_DISCONNECT_PHY_LINK = 2,
    STATE_CMD_CONNECT_ACCEPT_TIMEOUT = 3,
    STATE_CMD_MAC_START_COMPLETE = 4,
    STATE_CMD_MAC_START_FAILED = 5,
    STATE_CMD_MAC_CONNECT_COMPLETE = 6,
    STATE_CMD_MAC_CONNECT_FAILED = 7,
    STATE_CMD_MAC_DISCONNECT_INDICATE = 8,
    STATE_CMD_MAC_CONNECT_CANCEL_INDICATE = 9,
    STATE_CMD_4WAY_FAILED = 10,
    STATE_CMD_4WAY_SUCCESSED = 11,
    STATE_CMD_ENTER_STATE = 12,
    STATE_CMD_NO_SUCH_CMD = 13
} ;
#line 550
enum bt_traffic_mode_profile {
    BT_PROFILE_NONE = 0,
    BT_PROFILE_A2DP = 1,
    BT_PROFILE_PAN = 2,
    BT_PROFILE_HID = 3,
    BT_PROFILE_SCO = 4
} ;
#line 690 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct amp_assoc_structure {
   u8 TypeID ;
   u16 Length ;
   u8 Data[1U] ;
};
#line 699 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct amp_pref_chnl_regulatory {
   u8 reXId ;
   u8 regulatoryClass ;
   u8 coverageClass ;
};
#line 764 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct packet_irp_hcicmd_data {
   unsigned short OCF : 10 ;
   unsigned char OGF : 6 ;
   u8 Length ;
   u8 Data[20U] ;
};
#line 1052 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct packet_irp_hcievent_data {
   u8 EventCode ;
   u8 Length ;
   u8 Data[20U] ;
};
#line 1058 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
struct common_triple {
   u8 byte_1st ;
   u8 byte_2nd ;
   u8 byte_3rd ;
};
#line 1106
enum bt_state_1ant {
    BT_INFO_STATE_DISABLED = 0,
    BT_INFO_STATE_NO_CONNECTION = 1,
    BT_INFO_STATE_CONNECT_IDLE = 2,
    BT_INFO_STATE_INQ_OR_PAG = 3,
    BT_INFO_STATE_ACL_ONLY_BUSY = 4,
    BT_INFO_STATE_SCO_ONLY_BUSY = 5,
    BT_INFO_STATE_ACL_SCO_BUSY = 6,
    BT_INFO_STATE_ACL_INQ_OR_PAG = 7,
    BT_INFO_STATE_MAX = 8
} ;
#line 255 "include/linux/timer.h"
enum hrtimer_restart;
#line 332 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page___0 *pgtable_t___0;
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_211 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_210 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_211 __annonCompField39 ;
   int units ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_209 {
   union __anonunion____missing_field_name_210 __annonCompField40 ;
   atomic_t _count ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_208 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_209 __annonCompField41 ;
   unsigned int active ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_206 {
   union __anonunion_ldv_14166_140 __annonCompField38 ;
   union __anonunion____missing_field_name_208 __annonCompField42 ;
};
#line 44 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_213 {
   struct page___0 *next ;
   int pages ;
   int pobjects ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_212 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_213 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t___0 pmd_huge_pte ;
};
#line 44 "include/linux/mm_types.h"
union __anonunion____missing_field_name_214 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache___0 *slab_cache ;
   struct page___0 *first_page ;
};
#line 44 "include/linux/mm_types.h"
struct page___0 {
   unsigned long flags ;
   union __anonunion_ldv_14160_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_206 __annonCompField43 ;
   union __anonunion____missing_field_name_212 __annonCompField45 ;
   union __anonunion____missing_field_name_214 __annonCompField46 ;
   unsigned long debug_flags ;
} __attribute__((__aligned__((2) *  (sizeof(unsigned long )) ))) ;
#line 27 "include/linux/sysfs.h"
enum kobj_ns_type;
#line 29 "include/linux/sysfs.h"
struct attribute___0 {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 175 "include/linux/sysfs.h"
struct sysfs_ops___0 {
   ssize_t (*show)(struct kobject___0 * , struct attribute___0 * , char * ) ;
   ssize_t (*store)(struct kobject___0 * , struct attribute___0 * , char const   * ,
                    size_t  ) ;
};
#line 63 "include/linux/kobject.h"
struct kobject___0 {
   char const   *name ;
   struct list_head entry ;
   struct kobject___0 *parent ;
   struct kset *kset ;
   struct kobj_type___0 *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 115 "include/linux/kobject.h"
struct kobj_type___0 {
   void (*release)(struct kobject___0 *kobj ) ;
   struct sysfs_ops___0  const  *sysfs_ops ;
   struct attribute___0 **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject___0 *kobj ) ;
   void const   *(*namespace)(struct kobject___0 *kobj ) ;
};
#line 40 "include/linux/slub_def.h"
struct kmem_cache_cpu___0 {
   void **freelist ;
   unsigned long tid ;
   struct page___0 *page ;
   struct page___0 *partial ;
   unsigned int stat[26] ;
};
#line 62 "include/linux/slub_def.h"
struct kmem_cache___0 {
   struct kmem_cache_cpu___0 *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject___0 kobj ;
   struct memcg_cache_params___0 *memcg_params ;
   int max_attr_size ;
   struct kset *memcg_kset ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 10] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_227 {
   struct callback_head callback_head ;
   struct kmem_cache___0 *memcg_caches[0] ;
};
#line 531 "include/linux/slab.h"
struct __anonstruct____missing_field_name_228 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache___0 *root_cache ;
   atomic_t nr_pages ;
};
#line 531 "include/linux/slab.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField50 ;
   struct __anonstruct____missing_field_name_228 __annonCompField51 ;
};
#line 531 "include/linux/slab.h"
struct memcg_cache_params___0 {
   bool is_root_cache ;
   union __anonunion____missing_field_name_226 __annonCompField52 ;
};
#line 1 "<compiler builtins>"
#line 1
long ldv__builtin_expect(long exp , long c ) ;
#line 2 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void ldv_spin_lock(void) ;
#line 3
void ldv_spin_unlock(void) ;
#line 139 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 24 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 47
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 76
  __list_add(new, head->prev, head);
#line 77
  return;
}
}
#line 34 "./arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 279 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 28 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 40
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 310 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_bh_2(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock_bh(& lock->ldv_6347.rlock);
#line 313
  return;
}
}
#line 310
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_bh_6(spinlock_t *lock ) 
{ 


  {
#line 356
  _raw_spin_unlock_bh(& lock->ldv_6347.rlock);
#line 357
  return;
}
}
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 77 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 303
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 176 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 179
int ldv_mod_timer_33(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 183
int ldv_mod_timer_34(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 187
int ldv_mod_timer_35(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 191
int ldv_mod_timer_36(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 195
int ldv_mod_timer_37(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 199
int ldv_mod_timer_38(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 245
extern int del_timer_sync(struct timer_list * ) ;
#line 248
int ldv_del_timer_sync_39(struct timer_list *ldv_func_arg1 ) ;
#line 180 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 364
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 431
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 447
extern bool cancel_work_sync(struct work_struct * ) ;
#line 471 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 474
  tmp = queue_work_on(8192, wq, work);
#line 474
  return (tmp);
}
}
#line 144 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 316
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void ldv_check_alloc_flags(gfp_t flags ) ;
#line 6 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t size ) ;
#line 7
extern void *calloc(size_t nmemb , size_t size ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int expression ) ;
#line 32 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 53
  tmp = __VERIFIER_nondet_int();
#line 53
  return (tmp);
}
}
#line 56 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 57
  tmp = __VERIFIER_nondet_pointer();
#line 57
  return (tmp);
}
}
#line 60 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 61
  tmp = __VERIFIER_nondet_ulong();
#line 61
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  goto ERROR;
}
}
#line 51 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 53
  return (exp);
}
}
#line 61 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
void ldv__builtin_trap(void) 
{ 


  {
#line 63
  ldv_error();
#line 64
  return;
}
}
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 165
void disable_suitable_timer_6(struct timer_list *timer ) ;
#line 169
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 756 "include/linux/skbuff.h"
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
#line 759
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 765
extern struct sk_buff *skb_copy(struct sk_buff  const  * , gfp_t  ) ;
#line 768
struct sk_buff *ldv_skb_copy_26(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 778
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 781
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 2016
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 227 "include/linux/etherdevice.h"
__inline static void ether_addr_copy(u8 *dst , u8 const   *src ) 
{ 


  {
#line 230
  *((u32 *)dst) = *((u32 const   *)src);
#line 231
  *((u16 *)dst + 4U) = *((u16 const   *)src + 4U);
#line 232
  return;
}
}
#line 107 "drivers/staging/rtl8723au/include/wlan_bssdef.h"
__inline static uint get_wlan_bssid_ex_sz(struct wlan_bssid_ex *bss ) 
{ 


  {
#line 109
  return (bss->IELength + 95U);
}
}
#line 92 "drivers/staging/rtl8723au/include/rtw_cmd.h"
void rtw_evt_work(struct work_struct *work ) ;
#line 94
int rtw_enqueue_cmd23a(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) ;
#line 95
void rtw_free_cmd_obj23a(struct cmd_obj *pcmd ) ;
#line 99
int rtw_init_cmd_priv23a(struct cmd_priv *pcmdpriv ) ;
#line 101
u32 rtw_init_evt_priv23a(struct evt_priv *pevtpriv ) ;
#line 102
void rtw_free_evt_priv23a(struct evt_priv *pevtpriv ) ;
#line 103
void rtw_cmd_clr_isr23a(struct cmd_priv *pcmdpriv ) ;
#line 683
int rtw_sitesurvey_cmd23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ,
                          int ssid_num , struct rtw_ieee80211_channel *ch , int ch_num ) ;
#line 684
int rtw_createbss_cmd23a(struct rtw_adapter *padapter ) ;
#line 687
int rtw_setstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 unicast_key ) ;
#line 688
int rtw_clearstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 entry , u8 enqueue ) ;
#line 689
int rtw_joinbss_cmd23a(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) ;
#line 690
int rtw_disassoc_cmd23a(struct rtw_adapter *padapter , u32 deauth_timeout_ms , bool enqueue ) ;
#line 691
int rtw_setopmode_cmd23a(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) ;
#line 706
int rtw_addbareq_cmd23a(struct rtw_adapter *padapter , u8 tid , u8 *addr ) ;
#line 708
int rtw_dynamic_chk_wk_cmd23a(struct rtw_adapter *padapter ) ;
#line 710
int rtw_lps_ctrl_wk_cmd23a(struct rtw_adapter *padapter , u8 lps_ctrl_type , u8 enqueue ) ;
#line 712
int rtw_ps_cmd23a(struct rtw_adapter *padapter ) ;
#line 715
int rtw_chk_hi_queue_cmd23a(struct rtw_adapter *padapter ) ;
#line 718
int rtw_set_ch_cmd23a(struct rtw_adapter *padapter , u8 ch , u8 bw , u8 ch_offset ,
                      u8 enqueue ) ;
#line 723
int rtw_c2h_wk_cmd23a(struct rtw_adapter *padapter , u8 *c2h_evt ) ;
#line 725
int rtw_drvextra_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 727
void rtw_survey_cmd_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 728
void rtw_disassoc_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 729
void rtw_joinbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 730
void rtw_createbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 731
void rtw_getbbrfreg_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 734
void rtw_setstaKey_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 735
void rtw_setassocsta_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) ;
#line 819
struct _cmd_callback rtw_cmd_callback[63U] ;
#line 168 "drivers/staging/rtl8723au/include/hal_com.h"
void c2h_evt_clear23a(struct rtw_adapter *adapter ) ;
#line 169
s32 c2h_evt_read23a(struct rtw_adapter *adapter , u8 *buf ) ;
#line 212
bool rtl8723a_chk_hi_queue_empty(struct rtw_adapter *padapter ) ;
#line 243 "drivers/staging/rtl8723au/include/rtw_pwrctrl.h"
void rtw_ps_processor23a(struct rtw_adapter *padapter ) ;
#line 248
void LPS_Enter23a(struct rtw_adapter *padapter ) ;
#line 249
void LPS_Leave23a(struct rtw_adapter *padapter ) ;
#line 365 "drivers/staging/rtl8723au/include/sta_info.h"
struct sta_info *rtw_alloc_stainfo23a(struct sta_priv *pstapriv , u8 *hwaddr , gfp_t gfp ) ;
#line 368
struct sta_info *rtw_get_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ) ;
#line 370
struct sta_info *rtw_get_bcmc_stainfo23a(struct rtw_adapter *padapter ) ;
#line 238 "drivers/staging/rtl8723au/include/rtw_mlme.h"
void rtw_free_network_queue23a(struct rtw_adapter *padapter ) ;
#line 255 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static bool check_fwstate(struct mlme_priv *pmlmepriv , int state ) 
{ 


  {
#line 257
  if ((pmlmepriv->fw_state & state) != 0) {
#line 258
    return (1);
  } else {

  }
#line 260
  return (0);
}
}
#line 275 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static void set_fwstate(struct mlme_priv *pmlmepriv , int state ) 
{ 


  {
#line 277
  pmlmepriv->fw_state = pmlmepriv->fw_state | state;
#line 279
  if (state == 2048) {
#line 280
    pmlmepriv->bScanInProcess = 1U;
  } else {

  }
#line 281
  return;
}
}
#line 283 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static void _clr_fwstate_(struct mlme_priv *pmlmepriv , int state ) 
{ 


  {
#line 285
  pmlmepriv->fw_state = pmlmepriv->fw_state & ~ state;
#line 287
  if (state == 2048) {
#line 288
    pmlmepriv->bScanInProcess = 0U;
  } else {

  }
#line 289
  return;
}
}
#line 295 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static void clr_fwstate(struct mlme_priv *pmlmepriv , int state ) 
{ 
  bool tmp ;

  {
#line 297
  spin_lock_bh(& pmlmepriv->lock);
#line 298
  tmp = check_fwstate(pmlmepriv, state);
#line 298
  if ((int )tmp) {
#line 299
    pmlmepriv->fw_state = pmlmepriv->fw_state ^ state;
  } else {

  }
#line 300
  spin_unlock_bh(& pmlmepriv->lock);
#line 301
  return;
}
}
#line 317
struct wlan_network *rtw_get_oldest_wlan_network23a(struct rtw_queue *scanned_queue ) ;
#line 322
void rtw_indicate_connect23a(struct rtw_adapter *padapter ) ;
#line 325
int rtw_restruct_sec_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len ) ;
#line 327
int rtw_restruct_wmm_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len , uint initial_out_len ) ;
#line 347
struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv , int gfp ) ;
#line 359
unsigned int rtw_restructure_ht_ie23a(struct rtw_adapter *padapter , u8 *in_ie , u8 *out_ie ,
                                      uint in_len , uint *pout_len ) ;
#line 164 "drivers/staging/rtl8723au/include/rtw_debug.h"
u32 GlobalDebugLevel23A ;
#line 489 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
void clear_cam_entry23a(struct rtw_adapter *padapter , u8 entry ) ;
#line 511
unsigned char check_assoc_AP23a(u8 *pframe , uint len ) ;
#line 594
void linked_status_chk23a(struct rtw_adapter *padapter ) ;
#line 625
int NULL_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 626
int join_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 627
int disconnect_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 628
int createbss_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 629
int setopmode_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 630
int sitesurvey_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 631
int setauth_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 632
int setkey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 633
int set_stakey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 636
int add_ba_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 638
int mlme_evt_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 639
int h2c_msg_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 640
int tx_beacon_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 641
int set_ch_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 642
int set_chplan_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 643
int led_blink_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 644
int set_csa_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 645
int tdls_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) ;
#line 31 "drivers/staging/rtl8723au/include/rtw_ap.h"
void update_beacon23a(struct rtw_adapter *padapter , u8 ie_id , u8 *oui , u8 tx ) ;
#line 33
void expire_timeout_chk23a(struct rtw_adapter *padapter ) ;
#line 146 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
void rtl8723a_set_FwJoinBssReport_cmd(struct rtw_adapter *padapter , u8 mstatus ) ;
#line 23 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
bool rtl8723a_BT_using_antenna_1(struct rtw_adapter *padapter ) ;
#line 25
bool rtl8723a_BT_coexist(struct rtw_adapter *padapter ) ;
#line 26
void rtl8723a_BT_do_coexist(struct rtw_adapter *padapter ) ;
#line 27
void rtl8723a_BT_wifiscan_notify(struct rtw_adapter *padapter , u8 scanType ) ;
#line 28
void rtl8723a_BT_mediastatus_notify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) ;
#line 30
void rtl8723a_BT_specialpacket_notify(struct rtw_adapter *padapter ) ;
#line 31
void rtl8723a_BT_lps_leave(struct rtw_adapter *padapter ) ;
#line 140 "drivers/staging/rtl8723au/include/rtl8723a_dm.h"
void rtl8723a_HalDmWatchDog(struct rtw_adapter *Adapter ) ;
#line 22 "drivers/staging/rtl8723au/include/rtl8723a_sreset.h"
void rtl8723a_sreset_xmit_status_check(struct rtw_adapter *padapter ) ;
#line 539 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
bool c2h_id_filter_ccx_8723a(u8 id ) ;
#line 540
int c2h_handler_8723a(struct rtw_adapter *padapter , struct c2h_evt_hdr *c2h_evt ) ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static struct cmd_hdl wlancmds[63U]  = 
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
  {      {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, & NULL_hdl23a}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {863U, & join_cmd_hdl23a}, 
        {4U, & disconnect_hdl23a}, 
        {863U, & createbss_hdl23a}, 
        {4U, & setopmode_hdl23a}, 
        {712U, & sitesurvey_cmd_hdl23a}, 
        {4U, & setauth_hdl23a}, 
        {24U, & setkey_hdl23a}, 
        {28U, & set_stakey_hdl23a}, 
        {6U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {6U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {8U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {13U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {14U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {128U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {2U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {4U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {12U, & add_ba_hdl23a}, 
        {3U, & set_ch_hdl23a}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (int (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {863U, & tx_beacon_hdl23a}, 
        {0U, & mlme_evt_hdl23a}, 
        {0U, & rtw_drvextra_cmd_hdl23a}, 
        {0U, & h2c_msg_hdl23a}, 
        {1U, & set_chplan_hdl23a}, 
        {8U, & led_blink_hdl23a}, 
        {1U, & set_csa_hdl23a}, 
        {7U, & tdls_hdl23a}};
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct _cmd_callback rtw_cmd_callback[63U]  = 
#line 311
  {      {0U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {1U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {2U, & rtw_getbbrfreg_cmdrsp_callback23a}, 
        {3U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {4U, & rtw_getbbrfreg_cmdrsp_callback23a}, 
        {5U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {6U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {7U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {8U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {9U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {10U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {11U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {12U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {13U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {14U, & rtw_joinbss_cmd23a_callback}, 
        {15U, & rtw_disassoc_cmd23a_callback}, 
        {16U, & rtw_createbss_cmd23a_callback}, 
        {17U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {18U, & rtw_survey_cmd_callback23a}, 
        {19U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {20U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {21U, & rtw_setstaKey_cmdrsp_callback23a}, 
        {22U, & rtw_setassocsta_cmdrsp_callback23a}, 
        {23U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {24U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {25U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {26U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {27U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {28U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {29U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {30U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {31U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {32U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {33U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {34U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {35U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {36U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {37U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {38U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {39U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {40U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {41U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {42U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {43U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {44U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {45U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {46U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {47U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {48U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {49U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {50U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {51U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {52U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {53U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {54U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {55U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {56U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {57U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {58U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {59U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {60U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {61U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}, 
        {62U, (void (*)(struct rtw_adapter * , struct cmd_obj * ))0}};
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_init_cmd_priv23a(struct cmd_priv *pcmdpriv ) 
{ 
  int res ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;

  {
#line 391
  res = 1;
#line 393
  pcmdpriv->cmd_issued_cnt = 0U;
#line 394
  pcmdpriv->cmd_done_cnt = 0U;
#line 395
  pcmdpriv->rsp_cnt = 0U;
#line 397
  __lock_name = "\"rtl8723au_cmd\"";
#line 397
  tmp = __alloc_workqueue_key("rtl8723au_cmd", 0U, 1, & __key, __lock_name);
#line 397
  pcmdpriv->wq = tmp;
#line 398
  if ((unsigned long )pcmdpriv->wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 399
    res = 0;
  } else {

  }
#line 401
  return (res);
}
}
#line 406
static void rtw_irq_work(struct work_struct *work ) ;
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
u32 rtw_init_evt_priv23a(struct evt_priv *pevtpriv ) 
{ 
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;

  {
#line 410
  __lock_name = "\"rtl8723au_evt\"";
#line 410
  tmp = __alloc_workqueue_key("rtl8723au_evt", 0U, 1, & __key, __lock_name);
#line 410
  pevtpriv->wq = tmp;
#line 412
  __init_work(& pevtpriv->irq_wk, 0);
#line 412
  __constr_expr_0.counter = 137438953408L;
#line 412
  pevtpriv->irq_wk.data = __constr_expr_0;
#line 412
  lockdep_init_map(& pevtpriv->irq_wk.lockdep_map, "(&pevtpriv->irq_wk)", & __key___0,
                   0);
#line 412
  INIT_LIST_HEAD(& pevtpriv->irq_wk.entry);
#line 412
  pevtpriv->irq_wk.func = & rtw_irq_work;
#line 414
  return (1U);
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_free_evt_priv23a(struct evt_priv *pevtpriv ) 
{ 


  {
#line 419
  cancel_work_sync(& pevtpriv->irq_wk);
#line 420
  return;
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static int rtw_cmd_filter(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) 
{ 
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  u8 bAllow ;

  {
#line 426
  bAllow = 0U;
#line 429
  if ((unsigned int )(pcmdpriv->padapter)->pwrctrlpriv.bHWPwrPindetect != 0U && (unsigned int )(pcmdpriv->padapter)->registrypriv.usbss_enable == 0U) {
#line 431
    if ((unsigned int )cmd_obj->cmdcode == 57U) {
#line 432
      pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)cmd_obj->parmbuf;
#line 434
      if (pdrvextra_cmd_parm->ec_id == 4) {
#line 436
        bAllow = 1U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 440
  if ((unsigned int )cmd_obj->cmdcode == 59U) {
#line 441
    bAllow = 1U;
  } else {

  }
#line 443
  if ((unsigned int )(pcmdpriv->padapter)->hw_init_completed == 0U && (unsigned int )bAllow == 0U) {
#line 444
    return (0);
  } else {

  }
#line 445
  return (1);
}
}
#line 448
static void rtw_cmd_work(struct work_struct *work ) ;
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_enqueue_cmd23a(struct cmd_priv *pcmdpriv , struct cmd_obj *cmd_obj ) 
{ 
  int res ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  bool tmp ;

  {
#line 452
  res = 0;
#line 454
  if ((unsigned long )cmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 455
    goto exit;
  } else {

  }
#line 457
  cmd_obj->padapter = pcmdpriv->padapter;
#line 459
  res = rtw_cmd_filter(pcmdpriv, cmd_obj);
#line 460
  if (res == 0) {
#line 461
    rtw_free_cmd_obj23a(cmd_obj);
#line 462
    goto exit;
  } else {

  }
#line 465
  __init_work(& cmd_obj->work, 0);
#line 465
  __constr_expr_0.counter = 137438953408L;
#line 465
  cmd_obj->work.data = __constr_expr_0;
#line 465
  lockdep_init_map(& cmd_obj->work.lockdep_map, "(&cmd_obj->work)", & __key, 0);
#line 465
  INIT_LIST_HEAD(& cmd_obj->work.entry);
#line 465
  cmd_obj->work.func = & rtw_cmd_work;
#line 467
  tmp = queue_work(pcmdpriv->wq, & cmd_obj->work);
#line 467
  res = (int )tmp;
#line 469
  if (res == 0) {
#line 470
    printk("\v%s: Call to queue_work() failed\n", "rtw_enqueue_cmd23a");
#line 471
    res = 0;
  } else {
#line 473
    res = 1;
  }
  exit: ;
#line 476
  return (res);
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_cmd_clr_isr23a(struct cmd_priv *pcmdpriv ) 
{ 


  {
#line 481
  pcmdpriv->cmd_done_cnt = pcmdpriv->cmd_done_cnt + 1U;
#line 482
  return;
}
}
#line 484 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_free_cmd_obj23a(struct cmd_obj *pcmd ) 
{ 


  {
#line 487
  if ((unsigned int )pcmd->cmdcode != 14U && (unsigned int )pcmd->cmdcode != 16U) {
#line 490
    kfree((void const   *)pcmd->parmbuf);
  } else {

  }
#line 493
  if ((unsigned long )pcmd->rsp != (unsigned long )((u8 *)0U)) {
#line 494
    if (pcmd->rspsz != 0U) {
#line 496
      kfree((void const   *)pcmd->rsp);
    } else {

    }
  } else {

  }
#line 500
  kfree((void const   *)pcmd);
#line 501
  return;
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static void rtw_cmd_work(struct work_struct *work ) 
{ 
  int (*cmd_hdl)(struct rtw_adapter * , u8 const   * ) ;
  void (*pcmd_callback)(struct rtw_adapter * , struct cmd_obj * ) ;
  struct cmd_priv *pcmdpriv ;
  struct cmd_obj *pcmd ;
  struct work_struct  const  *__mptr ;
  int tmp ;

  {
#line 508
  __mptr = (struct work_struct  const  *)work;
#line 508
  pcmd = (struct cmd_obj *)__mptr;
#line 510
  pcmdpriv = & (pcmd->padapter)->cmdpriv;
#line 512
  tmp = rtw_cmd_filter(pcmdpriv, pcmd);
#line 512
  if (tmp == 0) {
#line 513
    pcmd->res = 3;
#line 514
    goto post_process;
  } else {

  }
#line 517
  pcmdpriv->cmd_issued_cnt = pcmdpriv->cmd_issued_cnt + 1U;
#line 519
  pcmd->cmdsz = (pcmd->cmdsz + 3U) & 4294967292U;
#line 521
  if ((unsigned int )pcmd->cmdcode <= 62U) {
#line 522
    cmd_hdl = wlancmds[(int )pcmd->cmdcode].h2cfuns;
#line 524
    if ((unsigned long )cmd_hdl != (unsigned long )((int (*)(struct rtw_adapter * ,
                                                             u8 const   * ))0)) {
#line 525
      pcmd->res = (*cmd_hdl)(pcmd->padapter, (u8 const   *)pcmd->parmbuf);
    } else {
#line 527
      pcmd->res = 3;
    }
  } else {
#line 529
    pcmd->res = 4;
  }
  post_process: ;
#line 533
  if ((unsigned int )pcmd->cmdcode <= 62U) {
#line 535
    pcmd_callback = rtw_cmd_callback[(int )pcmd->cmdcode].callback;
#line 536
    if ((unsigned long )pcmd_callback == (unsigned long )((void (*)(struct rtw_adapter * ,
                                                                    struct cmd_obj * ))0)) {
#line 537
      if (GlobalDebugLevel23A > 6U) {
#line 537
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
#line 537
        printk("\016mlme_cmd_hdl(): pcmd_callback = 0x%p, cmdcode = 0x%x\n", pcmd_callback,
               (int )pcmd->cmdcode);
      } else {

      }
#line 541
      rtw_free_cmd_obj23a(pcmd);
    } else {
#line 545
      (*pcmd_callback)(pcmd->padapter, pcmd);
    }
  } else {
#line 548
    if (GlobalDebugLevel23A > 3U) {
#line 548
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 548
      printk("\016%s: cmdcode = 0x%x callback not defined!\n", "rtw_cmd_work", (int )pcmd->cmdcode);
    } else {

    }
#line 551
    rtw_free_cmd_obj23a(pcmd);
  }
#line 553
  return;
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_sitesurvey_cmd23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ,
                          int ssid_num , struct rtw_ieee80211_channel *ch , int ch_num ) 
{ 
  int res ;
  struct cmd_obj *ph2c ;
  struct sitesurvey_parm *psurveyPara ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int i ;
  size_t __len ;
  void *__ret ;
  int i___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned long tmp___2 ;

  {
#line 560
  res = 0;
#line 563
  pcmdpriv = & padapter->cmdpriv;
#line 564
  pmlmepriv = & padapter->mlmepriv;
#line 566
  tmp = check_fwstate(pmlmepriv, 1);
#line 566
  if ((int )tmp) {
#line 567
    rtw_lps_ctrl_wk_cmd23a(padapter, 0, 1);
  } else {

  }
#line 569
  tmp___0 = kzalloc(128UL, 32U);
#line 569
  ph2c = (struct cmd_obj *)tmp___0;
#line 570
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 571
    return (0);
  } else {

  }
#line 573
  tmp___1 = kzalloc(712UL, 32U);
#line 573
  psurveyPara = (struct sitesurvey_parm *)tmp___1;
#line 574
  if ((unsigned long )psurveyPara == (unsigned long )((struct sitesurvey_parm *)0)) {
#line 575
    kfree((void const   *)ph2c);
#line 576
    return (0);
  } else {

  }
#line 579
  rtw_free_network_queue23a(padapter);
#line 581
  if (GlobalDebugLevel23A > 6U) {
#line 581
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
#line 581
    printk("\016%s: flush network queue\n", "rtw_sitesurvey_cmd23a");
  } else {

  }
#line 584
  ph2c->cmdcode = 18U;
#line 584
  ph2c->parmbuf = (u8 *)psurveyPara;
#line 584
  ph2c->cmdsz = 712U;
#line 584
  ph2c->rsp = (u8 *)0U;
#line 584
  ph2c->rspsz = 0U;
#line 588
  psurveyPara->scan_mode = (int )pmlmepriv->scan_mode;
#line 591
  if ((unsigned long )ssid != (unsigned long )((struct cfg80211_ssid *)0)) {
#line 593
    i = 0;
#line 593
    goto ldv_54341;
    ldv_54340: ;
#line 594
    if ((unsigned int )(ssid + (unsigned long )i)->ssid_len != 0U) {
#line 595
      __len = 33UL;
#line 595
      if (__len > 63UL) {
#line 595
        __ret = __memcpy((void *)(& psurveyPara->ssid) + (unsigned long )i, (void const   *)ssid + (unsigned long )i,
                         __len);
      } else {
#line 595
        __ret = __builtin_memcpy((void *)(& psurveyPara->ssid) + (unsigned long )i,
                                 (void const   *)ssid + (unsigned long )i, __len);
      }
#line 597
      psurveyPara->ssid_num = (u8 )((int )psurveyPara->ssid_num + 1);
    } else {

    }
#line 593
    i = i + 1;
    ldv_54341: ;
#line 593
    if (i < ssid_num && i <= 8) {
#line 595
      goto ldv_54340;
    } else {

    }

  } else {

  }
#line 603
  if ((unsigned long )ch != (unsigned long )((struct rtw_ieee80211_channel *)0)) {
#line 605
    i___0 = 0;
#line 605
    goto ldv_54348;
    ldv_54347: ;
#line 606
    if ((unsigned int )(ch + (unsigned long )i___0)->hw_value != 0U && ((ch + (unsigned long )i___0)->flags & 1U) == 0U) {
#line 608
      __len___0 = 8UL;
#line 608
      if (__len___0 > 63UL) {
#line 608
        __ret___0 = __memcpy((void *)(& psurveyPara->ch) + (unsigned long )i___0,
                             (void const   *)ch + (unsigned long )i___0, __len___0);
      } else {
#line 608
        __ret___0 = __builtin_memcpy((void *)(& psurveyPara->ch) + (unsigned long )i___0,
                                     (void const   *)ch + (unsigned long )i___0, __len___0);
      }
#line 610
      psurveyPara->ch_num = (u8 )((int )psurveyPara->ch_num + 1);
    } else {

    }
#line 605
    i___0 = i___0 + 1;
    ldv_54348: ;
#line 605
    if (i___0 < ch_num && i___0 <= 50) {
#line 607
      goto ldv_54347;
    } else {

    }

  } else {

  }
#line 615
  set_fwstate(pmlmepriv, 2048);
#line 617
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
#line 619
  if (res == 1) {
#line 620
    tmp___2 = msecs_to_jiffies(8000U);
#line 620
    ldv_mod_timer_33(& pmlmepriv->scan_to_timer, tmp___2 + (unsigned long )jiffies);
#line 625
    pmlmepriv->scan_interval = 30U;
  } else {
#line 627
    _clr_fwstate_(pmlmepriv, 2048);
  }
#line 629
  return (res);
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_getbbrfreg_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 


  {
#line 635
  kfree((void const   *)pcmd->parmbuf);
#line 636
  kfree((void const   *)pcmd);
#line 637
  return;
}
}
#line 639 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_createbss_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *pcmd ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 res ;
  void *tmp ;
  int tmp___0 ;

  {
#line 642
  pcmdpriv = & padapter->cmdpriv;
#line 643
  pmlmepriv = & padapter->mlmepriv;
#line 645
  res = 1U;
#line 647
  pdev_network = & padapter->registrypriv.dev_network;
#line 651
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
#line 652
    if (GlobalDebugLevel23A > 6U) {
#line 652
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
#line 652
      printk("\016 createbss for Any SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
    } else {

    }
  } else
#line 656
  if (GlobalDebugLevel23A > 6U) {
#line 656
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
#line 656
    printk("\016 createbss for SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {

  }
#line 661
  tmp = kzalloc(128UL, 32U);
#line 661
  pcmd = (struct cmd_obj *)tmp;
#line 662
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 663
    res = 0U;
#line 664
    goto exit;
  } else {

  }
#line 667
  pcmd->cmdcode = 16U;
#line 668
  pcmd->parmbuf = (u8 *)pdev_network;
#line 669
  pcmd->cmdsz = get_wlan_bssid_ex_sz(pdev_network);
#line 670
  pcmd->rsp = (u8 *)0U;
#line 671
  pcmd->rspsz = 0U;
#line 673
  pdev_network->Length = pcmd->cmdsz;
#line 675
  tmp___0 = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
#line 675
  res = (u8 )tmp___0;
  exit: ;
#line 679
  return ((int )res);
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_joinbss_cmd23a(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) 
{ 
  u8 *auth ;
  int res ;
  struct wlan_bssid_ex *psecnetwork ;
  struct cmd_obj *pcmd ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct registry_priv *pregistrypriv ;
  struct ht_priv *phtpriv ;
  enum nl80211_iftype ifmode ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  uint tmp___2 ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___3 ;
  u32 tmp_len ;
  int tmp___4 ;
  u32 algo ;

  {
#line 686
  res = 1;
#line 689
  pcmdpriv = & padapter->cmdpriv;
#line 690
  pmlmepriv = & padapter->mlmepriv;
#line 691
  psecuritypriv = & padapter->securitypriv;
#line 692
  pregistrypriv = & padapter->registrypriv;
#line 693
  phtpriv = & pmlmepriv->htpriv;
#line 695
  pmlmeext = & padapter->mlmeextpriv;
#line 696
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 698
  ifmode = pnetwork->network.ifmode;
#line 702
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
#line 703
    if (GlobalDebugLevel23A > 6U) {
#line 703
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 7);
#line 703
      printk("\016+Join cmd: Any SSid\n");
    } else {

    }
  } else
#line 706
  if (GlobalDebugLevel23A > 5U) {
#line 706
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 6);
#line 706
    printk("\016+Join cmd: SSid =[%s]\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {

  }
#line 711
  tmp = kzalloc(128UL, 32U);
#line 711
  pcmd = (struct cmd_obj *)tmp;
#line 712
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 713
    res = 0;
#line 714
    if (GlobalDebugLevel23A > 3U) {
#line 714
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 714
      printk("\016rtw_joinbss_cmd23a: memory allocate for cmd_obj fail!!!\n");
    } else {

    }
#line 717
    goto exit;
  } else {

  }
#line 721
  tmp___0 = check_fwstate(pmlmepriv, 40);
#line 721
  if (tmp___0) {
#line 721
    tmp___1 = 0;
  } else {
#line 721
    tmp___1 = 1;
  }
#line 721
  if (tmp___1) {
#line 722
    switch ((unsigned int )ifmode) {
    case 1U: 
#line 724
    set_fwstate(pmlmepriv, 32);
#line 725
    goto ldv_54381;
    case 8U: ;
    case 2U: 
#line 728
    set_fwstate(pmlmepriv, 8);
#line 729
    goto ldv_54381;
    default: ;
#line 731
    goto ldv_54381;
    }
    ldv_54381: ;
  } else {

  }
#line 735
  psecnetwork = & psecuritypriv->sec_bss;
#line 736
  if ((unsigned long )psecnetwork == (unsigned long )((struct wlan_bssid_ex *)0)) {
#line 737
    if ((unsigned long )pcmd != (unsigned long )((struct cmd_obj *)0)) {
#line 738
      kfree((void const   *)pcmd);
    } else {

    }
#line 740
    res = 0;
#line 742
    if (GlobalDebugLevel23A > 3U) {
#line 742
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 742
      printk("\016rtw_joinbss_cmd23a :psecnetwork == NULL!!!\n");
    } else {

    }
#line 745
    goto exit;
  } else {

  }
#line 748
  memset((void *)psecnetwork, 0, 863UL);
#line 750
  tmp___2 = get_wlan_bssid_ex_sz(& pnetwork->network);
#line 750
  __len = (size_t )tmp___2;
#line 750
  __ret = __builtin_memcpy((void *)psecnetwork, (void const   *)(& pnetwork->network),
                           __len);
#line 753
  auth = (u8 *)(& psecuritypriv->authenticator_ie);
#line 754
  psecuritypriv->authenticator_ie[0] = (unsigned char )psecnetwork->IELength;
#line 757
  if (psecnetwork->IELength - 12U <= 254U) {
#line 758
    __len___0 = (size_t )(psecnetwork->IELength - 12U);
#line 758
    __ret___0 = __builtin_memcpy((void *)(& psecuritypriv->authenticator_ie) + 1U,
                                 (void const   *)(& psecnetwork->IEs) + 12U, __len___0);
  } else {
#line 761
    __len___1 = 255UL;
#line 761
    if (__len___1 > 63UL) {
#line 761
      __ret___1 = __memcpy((void *)(& psecuritypriv->authenticator_ie) + 1U, (void const   *)(& psecnetwork->IEs) + 12U,
                           __len___1);
    } else {
#line 761
      __ret___1 = __builtin_memcpy((void *)(& psecuritypriv->authenticator_ie) + 1U,
                                   (void const   *)(& psecnetwork->IEs) + 12U, __len___1);
    }
  }
#line 765
  psecnetwork->IELength = 0U;
#line 772
  if (pmlmepriv->assoc_by_bssid == 0U) {
#line 773
    ether_addr_copy((u8 *)(& pmlmepriv->assoc_bssid), (u8 const   *)(& pnetwork->network.MacAddress));
  } else {

  }
#line 776
  tmp___3 = rtw_restruct_sec_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                                   pnetwork->network.IELength);
#line 776
  psecnetwork->IELength = (u32 )tmp___3;
#line 781
  pmlmepriv->qos_option = 0U;
#line 783
  if ((unsigned int )pregistrypriv->wmm_enable != 0U) {
#line 786
    tmp___4 = rtw_restruct_wmm_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                                     pnetwork->network.IELength, psecnetwork->IELength);
#line 786
    tmp_len = (u32 )tmp___4;
#line 792
    if (psecnetwork->IELength != tmp_len) {
#line 793
      psecnetwork->IELength = tmp_len;
#line 795
      pmlmepriv->qos_option = 1U;
    } else {
#line 798
      pmlmepriv->qos_option = 0U;
    }
  } else {

  }
#line 802
  phtpriv->ht_option = 0U;
#line 803
  if ((unsigned int )pregistrypriv->ht_enable != 0U) {
#line 804
    algo = padapter->securitypriv.dot11PrivacyAlgrthm;
#line 809
    if ((algo != 1027073U && algo != 1027077U) && algo != 1027074U) {
#line 813
      rtw_restructure_ht_ie23a(padapter, (u8 *)(& pnetwork->network.IEs), (u8 *)(& psecnetwork->IEs),
                               pnetwork->network.IELength, & psecnetwork->IELength);
    } else {

    }
  } else {

  }
#line 821
  pmlmeinfo->assoc_AP_vendor = check_assoc_AP23a((u8 *)(& pnetwork->network.IEs),
                                                 pnetwork->network.IELength);
#line 825
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 16U) {
#line 826
    padapter->pwrctrlpriv.smart_ps = 0U;
  } else {
#line 828
    padapter->pwrctrlpriv.smart_ps = padapter->registrypriv.smart_ps;
  }
#line 831
  if (GlobalDebugLevel23A > 3U) {
#line 831
    printk("\016RTL8723AU: %s: smart_ps =%d\n", "rtw_joinbss_cmd23a", (int )padapter->pwrctrlpriv.smart_ps);
  } else {

  }
#line 835
  pcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);
#line 837
  pcmd->cmdcode = 14U;
#line 838
  pcmd->parmbuf = (u8 *)psecnetwork;
#line 839
  pcmd->rsp = (u8 *)0U;
#line 840
  pcmd->rspsz = 0U;
#line 842
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
#line 845
  return (res);
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_disassoc_cmd23a(struct rtw_adapter *padapter , u32 deauth_timeout_ms , bool enqueue ) 
{ 
  struct cmd_obj *cmdobj ;
  struct disconnect_parm *param ;
  struct cmd_priv *cmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 851
  cmdobj = (struct cmd_obj *)0;
#line 852
  param = (struct disconnect_parm *)0;
#line 853
  cmdpriv = & padapter->cmdpriv;
#line 854
  res = 1;
#line 856
  if (GlobalDebugLevel23A > 5U) {
#line 856
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 6);
#line 856
    printk("\016+rtw_disassoc_cmd23a\n");
  } else {

  }
#line 860
  tmp = kzalloc(4UL, 32U);
#line 860
  param = (struct disconnect_parm *)tmp;
#line 861
  if ((unsigned long )param == (unsigned long )((struct disconnect_parm *)0)) {
#line 862
    res = 0;
#line 863
    goto exit;
  } else {

  }
#line 865
  param->deauth_timeout_ms = deauth_timeout_ms;
#line 867
  if ((int )enqueue) {
#line 869
    tmp___0 = kzalloc(128UL, 32U);
#line 869
    cmdobj = (struct cmd_obj *)tmp___0;
#line 870
    if ((unsigned long )cmdobj == (unsigned long )((struct cmd_obj *)0)) {
#line 871
      res = 0;
#line 872
      kfree((void const   *)param);
#line 873
      goto exit;
    } else {

    }
#line 875
    cmdobj->cmdcode = 15U;
#line 875
    cmdobj->parmbuf = (u8 *)param;
#line 875
    cmdobj->cmdsz = 4U;
#line 875
    cmdobj->rsp = (u8 *)0U;
#line 875
    cmdobj->rspsz = 0U;
#line 876
    res = rtw_enqueue_cmd23a(cmdpriv, cmdobj);
  } else {
#line 880
    tmp___1 = disconnect_hdl23a(padapter, (u8 const   *)param);
#line 880
    if (tmp___1 != 0) {
#line 881
      res = 0;
    } else {

    }
#line 882
    kfree((void const   *)param);
  }
  exit: ;
#line 886
  return (res);
}
}
#line 889 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_setopmode_cmd23a(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) 
{ 
  struct cmd_obj *ph2c ;
  struct setopmode_parm *psetop ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 894
  pcmdpriv = & padapter->cmdpriv;
#line 895
  res = 1;
#line 897
  tmp = kzalloc(128UL, 208U);
#line 897
  ph2c = (struct cmd_obj *)tmp;
#line 898
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 899
    res = 0;
#line 900
    goto exit;
  } else {

  }
#line 902
  tmp___0 = kzalloc(4UL, 208U);
#line 902
  psetop = (struct setopmode_parm *)tmp___0;
#line 904
  if ((unsigned long )psetop == (unsigned long )((struct setopmode_parm *)0)) {
#line 905
    kfree((void const   *)ph2c);
#line 906
    res = 0;
#line 907
    goto exit;
  } else {

  }
#line 910
  ph2c->cmdcode = 17U;
#line 910
  ph2c->parmbuf = (u8 *)psetop;
#line 910
  ph2c->cmdsz = 4U;
#line 910
  ph2c->rsp = (u8 *)0U;
#line 910
  ph2c->rspsz = 0U;
#line 911
  psetop->mode = ifmode;
#line 913
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 915
  return (res);
}
}
#line 918 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_setstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 unicast_key ) 
{ 
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct sta_info *sta ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  size_t __len ;
  void *__ret ;
  int idx ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 922
  pcmdpriv = & padapter->cmdpriv;
#line 923
  psetstakey_rsp = (struct set_stakey_rsp *)0;
#line 924
  pmlmepriv = & padapter->mlmepriv;
#line 925
  psecuritypriv = & padapter->securitypriv;
#line 926
  sta = (struct sta_info *)psta;
#line 927
  res = 1;
#line 929
  tmp = kzalloc(128UL, 208U);
#line 929
  ph2c = (struct cmd_obj *)tmp;
#line 930
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 931
    res = 0;
#line 932
    goto exit;
  } else {

  }
#line 935
  tmp___0 = kzalloc(28UL, 208U);
#line 935
  psetstakey_para = (struct set_stakey_parm *)tmp___0;
#line 936
  if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
#line 937
    kfree((void const   *)ph2c);
#line 938
    res = 0;
#line 939
    goto exit;
  } else {

  }
#line 942
  tmp___1 = kzalloc(8UL, 208U);
#line 942
  psetstakey_rsp = (struct set_stakey_rsp *)tmp___1;
#line 943
  if ((unsigned long )psetstakey_rsp == (unsigned long )((struct set_stakey_rsp *)0)) {
#line 944
    kfree((void const   *)ph2c);
#line 945
    kfree((void const   *)psetstakey_para);
#line 946
    res = 0;
#line 947
    goto exit;
  } else {

  }
#line 950
  ph2c->cmdcode = 21U;
#line 950
  ph2c->parmbuf = (u8 *)psetstakey_para;
#line 950
  ph2c->cmdsz = 28U;
#line 950
  ph2c->rsp = (u8 *)0U;
#line 950
  ph2c->rspsz = 0U;
#line 951
  ph2c->rsp = (u8 *)psetstakey_rsp;
#line 952
  ph2c->rspsz = 8U;
#line 954
  ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const   *)(& sta->hwaddr));
#line 956
  tmp___2 = check_fwstate(pmlmepriv, 8);
#line 956
  if ((int )tmp___2) {
#line 957
    psetstakey_para->algorithm = (u32 )((unsigned char )psecuritypriv->dot11PrivacyAlgrthm);
  } else {
#line 960
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
#line 960
    psetstakey_para->algorithm = psecuritypriv->dot11PrivacyAlgrthm;
#line 960
    goto ldv_54433;
    case 2U: 
#line 960
    psetstakey_para->algorithm = sta->dot118021XPrivacy;
#line 960
    goto ldv_54433;
    }
    ldv_54433: ;
  }
#line 964
  if ((unsigned int )unicast_key == 1U) {
#line 965
    __len = 16UL;
#line 965
    if (__len > 63UL) {
#line 965
      __ret = __memcpy((void *)(& psetstakey_para->key), (void const   *)(& sta->dot118021x_UncstKey),
                       __len);
    } else {
#line 965
      __ret = __builtin_memcpy((void *)(& psetstakey_para->key), (void const   *)(& sta->dot118021x_UncstKey),
                               __len);
    }
  } else {
#line 967
    idx = (int )psecuritypriv->dot118021XGrpKeyid;
#line 968
    __len___0 = 16UL;
#line 968
    if (__len___0 > 63UL) {
#line 968
      __ret___0 = __memcpy((void *)(& psetstakey_para->key), (void const   *)(& psecuritypriv->dot118021XGrpKey[idx].skey),
                           __len___0);
    } else {
#line 968
      __ret___0 = __builtin_memcpy((void *)(& psetstakey_para->key), (void const   *)(& psecuritypriv->dot118021XGrpKey[idx].skey),
                                   __len___0);
    }
  }
#line 973
  padapter->securitypriv.busetkipkey = 1U;
#line 975
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 979
  return (res);
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_clearstakey_cmd23a(struct rtw_adapter *padapter , u8 *psta , u8 entry , u8 enqueue ) 
{ 
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct sta_info *sta ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 987
  pcmdpriv = & padapter->cmdpriv;
#line 988
  psetstakey_rsp = (struct set_stakey_rsp *)0;
#line 989
  sta = (struct sta_info *)psta;
#line 990
  res = 1;
#line 992
  if ((unsigned int )enqueue == 0U) {
#line 993
    clear_cam_entry23a(padapter, (int )entry);
  } else {
#line 995
    tmp = kzalloc(128UL, 208U);
#line 995
    ph2c = (struct cmd_obj *)tmp;
#line 996
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 997
      res = 0;
#line 998
      goto exit;
    } else {

    }
#line 1001
    tmp___0 = kzalloc(28UL, 208U);
#line 1001
    psetstakey_para = (struct set_stakey_parm *)tmp___0;
#line 1003
    if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
#line 1004
      kfree((void const   *)ph2c);
#line 1005
      res = 0;
#line 1006
      goto exit;
    } else {

    }
#line 1009
    tmp___1 = kzalloc(8UL, 208U);
#line 1009
    psetstakey_rsp = (struct set_stakey_rsp *)tmp___1;
#line 1011
    if ((unsigned long )psetstakey_rsp == (unsigned long )((struct set_stakey_rsp *)0)) {
#line 1012
      kfree((void const   *)ph2c);
#line 1013
      kfree((void const   *)psetstakey_para);
#line 1014
      res = 0;
#line 1015
      goto exit;
    } else {

    }
#line 1018
    ph2c->cmdcode = 21U;
#line 1018
    ph2c->parmbuf = (u8 *)psetstakey_para;
#line 1018
    ph2c->cmdsz = 28U;
#line 1018
    ph2c->rsp = (u8 *)0U;
#line 1018
    ph2c->rspsz = 0U;
#line 1020
    ph2c->rsp = (u8 *)psetstakey_rsp;
#line 1021
    ph2c->rspsz = 8U;
#line 1023
    ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const   *)(& sta->hwaddr));
#line 1025
    psetstakey_para->algorithm = 0U;
#line 1027
    psetstakey_para->id = entry;
#line 1029
    res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  }
  exit: ;
#line 1032
  return (res);
}
}
#line 1035 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_addbareq_cmd23a(struct rtw_adapter *padapter , u8 tid , u8 *addr ) 
{ 
  struct cmd_priv *pcmdpriv ;
  struct cmd_obj *ph2c ;
  struct addBaReq_parm *paddbareq_parm ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1037
  pcmdpriv = & padapter->cmdpriv;
#line 1040
  res = 1;
#line 1042
  if ((unsigned int )tid > 15U) {
#line 1043
    res = 0;
#line 1044
    goto exit;
  } else {

  }
#line 1047
  tmp = kzalloc(128UL, 32U);
#line 1047
  ph2c = (struct cmd_obj *)tmp;
#line 1048
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 1049
    res = 0;
#line 1050
    goto exit;
  } else {

  }
#line 1053
  tmp___0 = kzalloc(12UL, 32U);
#line 1053
  paddbareq_parm = (struct addBaReq_parm *)tmp___0;
#line 1054
  if ((unsigned long )paddbareq_parm == (unsigned long )((struct addBaReq_parm *)0)) {
#line 1055
    kfree((void const   *)ph2c);
#line 1056
    res = 0;
#line 1057
    goto exit;
  } else {

  }
#line 1060
  paddbareq_parm->tid = (unsigned int )tid;
#line 1061
  ether_addr_copy((u8 *)(& paddbareq_parm->addr), (u8 const   *)addr);
#line 1063
  ph2c->cmdcode = 45U;
#line 1063
  ph2c->parmbuf = (u8 *)paddbareq_parm;
#line 1063
  ph2c->cmdsz = 12U;
#line 1063
  ph2c->rsp = (u8 *)0U;
#line 1063
  ph2c->rspsz = 0U;
#line 1066
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 1068
  return (res);
}
}
#line 1071 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_dynamic_chk_wk_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1075
  pcmdpriv = & padapter->cmdpriv;
#line 1076
  res = 1;
#line 1078
  tmp = kzalloc(128UL, 32U);
#line 1078
  ph2c = (struct cmd_obj *)tmp;
#line 1079
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 1080
    res = 0;
#line 1081
    goto exit;
  } else {

  }
#line 1084
  tmp___0 = kzalloc(16UL, 32U);
#line 1084
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 1085
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 1086
    kfree((void const   *)ph2c);
#line 1087
    res = 0;
#line 1088
    goto exit;
  } else {

  }
#line 1091
  pdrvextra_cmd_parm->ec_id = 1;
#line 1092
  pdrvextra_cmd_parm->type_size = 0;
#line 1093
  pdrvextra_cmd_parm->pbuf = (unsigned char *)padapter;
#line 1095
  ph2c->cmdcode = 57U;
#line 1095
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 1095
  ph2c->cmdsz = 16U;
#line 1095
  ph2c->rsp = (u8 *)0U;
#line 1095
  ph2c->rspsz = 0U;
#line 1098
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 1101
  return (res);
}
}
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_set_ch_cmd23a(struct rtw_adapter *padapter , u8 ch , u8 bw , u8 ch_offset ,
                      u8 enqueue ) 
{ 
  struct cmd_obj *pcmdobj ;
  struct set_ch_parm *set_ch_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1113
  pcmdpriv = & padapter->cmdpriv;
#line 1114
  res = 1;
#line 1116
  if (GlobalDebugLevel23A > 3U) {
#line 1116
    printk("\016RTL8723AU: %s(%s): ch:%u, bw:%u, ch_offset:%u\n", "rtw_set_ch_cmd23a",
           (char *)(& (padapter->pnetdev)->name), (int )ch, (int )bw, (int )ch_offset);
  } else {

  }
#line 1122
  tmp = kzalloc(3UL, 208U);
#line 1122
  set_ch_parm = (struct set_ch_parm *)tmp;
#line 1123
  if ((unsigned long )set_ch_parm == (unsigned long )((struct set_ch_parm *)0)) {
#line 1124
    res = 0;
#line 1125
    goto exit;
  } else {

  }
#line 1127
  set_ch_parm->ch = ch;
#line 1128
  set_ch_parm->bw = bw;
#line 1129
  set_ch_parm->ch_offset = ch_offset;
#line 1131
  if ((unsigned int )enqueue != 0U) {
#line 1133
    tmp___0 = kzalloc(128UL, 208U);
#line 1133
    pcmdobj = (struct cmd_obj *)tmp___0;
#line 1134
    if ((unsigned long )pcmdobj == (unsigned long )((struct cmd_obj *)0)) {
#line 1135
      kfree((void const   *)set_ch_parm);
#line 1136
      res = 0;
#line 1137
      goto exit;
    } else {

    }
#line 1140
    pcmdobj->cmdcode = 46U;
#line 1140
    pcmdobj->parmbuf = (u8 *)set_ch_parm;
#line 1140
    pcmdobj->cmdsz = 3U;
#line 1140
    pcmdobj->rsp = (u8 *)0U;
#line 1140
    pcmdobj->rspsz = 0U;
#line 1142
    res = rtw_enqueue_cmd23a(pcmdpriv, pcmdobj);
  } else {
#line 1146
    tmp___1 = set_ch_hdl23a(padapter, (u8 const   *)set_ch_parm);
#line 1146
    if (tmp___1 != 0) {
#line 1147
      res = 0;
    } else {

    }
#line 1149
    kfree((void const   *)set_ch_parm);
  }
  exit: ;
#line 1155
  if (GlobalDebugLevel23A > 3U) {
#line 1155
    printk("\016RTL8723AU: %s(%s): res:%u\n", "rtw_set_ch_cmd23a", (char *)(& (padapter->pnetdev)->name),
           res);
  } else {

  }
#line 1157
  return (res);
}
}
#line 1160 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static void traffic_status_watchdog(struct rtw_adapter *padapter ) 
{ 
  u8 bEnterPS ;
  u8 bBusyTraffic ;
  u8 bTxBusyTraffic ;
  u8 bRxBusyTraffic ;
  u8 bHigherBusyTraffic ;
  u8 bHigherBusyRxTraffic ;
  u8 bHigherBusyTxTraffic ;
  struct mlme_priv *pmlmepriv ;
  int BusyThreshold ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;

  {
#line 1163
  bBusyTraffic = 0U;
#line 1163
  bTxBusyTraffic = 0U;
#line 1163
  bRxBusyTraffic = 0U;
#line 1164
  bHigherBusyTraffic = 0U;
#line 1164
  bHigherBusyRxTraffic = 0U;
#line 1165
  bHigherBusyTxTraffic = 0U;
#line 1166
  pmlmepriv = & padapter->mlmepriv;
#line 1167
  BusyThreshold = 100;
#line 1171
  tmp___4 = check_fwstate(pmlmepriv, 1);
#line 1171
  if ((int )tmp___4) {
#line 1172
    tmp = rtl8723a_BT_coexist(padapter);
#line 1172
    if ((int )tmp) {
#line 1173
      BusyThreshold = 50;
    } else
#line 1174
    if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
#line 1175
      BusyThreshold = 75;
    } else {

    }
#line 1178
    if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > (u32 )BusyThreshold || pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > (u32 )BusyThreshold) {
#line 1180
      bBusyTraffic = 1U;
#line 1182
      if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) {
#line 1184
        bRxBusyTraffic = 1U;
      } else {
#line 1186
        bTxBusyTraffic = 1U;
      }
    } else {

    }
#line 1190
    if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 4000U || pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 4000U) {
#line 1192
      bHigherBusyTraffic = 1U;
#line 1194
      if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) {
#line 1196
        bHigherBusyRxTraffic = 1U;
      } else {
#line 1198
        bHigherBusyTxTraffic = 1U;
      }
    } else {

    }
#line 1201
    tmp___0 = rtl8723a_BT_coexist(padapter);
#line 1201
    if (tmp___0) {
#line 1201
      tmp___1 = 0;
    } else {
#line 1201
      tmp___1 = 1;
    }
#line 1201
    if (tmp___1) {
#line 1201
      goto _L;
    } else {
#line 1201
      tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
#line 1201
      if (tmp___2) {
#line 1201
        tmp___3 = 0;
      } else {
#line 1201
        tmp___3 = 1;
      }
#line 1201
      if (tmp___3) {
        _L: /* CIL Label */ 
#line 1204
        if (pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 8U || pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2U) {
#line 1207
          bEnterPS = 0U;
        } else {
#line 1209
          bEnterPS = 1U;
        }
#line 1212
        if ((unsigned int )bEnterPS != 0U) {
#line 1213
          LPS_Enter23a(padapter);
        } else {
#line 1215
          LPS_Leave23a(padapter);
        }
      } else {

      }
    }
  } else {
#line 1218
    LPS_Leave23a(padapter);
  }
#line 1220
  pmlmepriv->LinkDetectInfo.NumRxOkInPeriod = 0U;
#line 1221
  pmlmepriv->LinkDetectInfo.NumTxOkInPeriod = 0U;
#line 1222
  pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod = 0U;
#line 1223
  pmlmepriv->LinkDetectInfo.bBusyTraffic = (unsigned int )bBusyTraffic != 0U;
#line 1224
  pmlmepriv->LinkDetectInfo.bTxBusyTraffic = (unsigned int )bTxBusyTraffic != 0U;
#line 1225
  pmlmepriv->LinkDetectInfo.bRxBusyTraffic = (unsigned int )bRxBusyTraffic != 0U;
#line 1226
  pmlmepriv->LinkDetectInfo.bHigherBusyTraffic = (unsigned int )bHigherBusyTraffic != 0U;
#line 1227
  pmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic = (unsigned int )bHigherBusyRxTraffic != 0U;
#line 1228
  pmlmepriv->LinkDetectInfo.bHigherBusyTxTraffic = (unsigned int )bHigherBusyTxTraffic != 0U;
#line 1229
  return;
}
}
#line 1231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static void dynamic_chk_wk_hdl(struct rtw_adapter *padapter , u8 *pbuf , int sz ) 
{ 
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
#line 1235
  padapter = (struct rtw_adapter *)pbuf;
#line 1236
  pmlmepriv = & padapter->mlmepriv;
#line 1239
  tmp = check_fwstate(pmlmepriv, 16);
#line 1239
  if ((int )tmp) {
#line 1240
    expire_timeout_chk23a(padapter);
  } else {

  }
#line 1243
  rtl8723a_sreset_xmit_status_check(padapter);
#line 1245
  linked_status_chk23a(padapter);
#line 1246
  traffic_status_watchdog(padapter);
#line 1248
  rtl8723a_HalDmWatchDog(padapter);
#line 1253
  rtl8723a_BT_do_coexist(padapter);
#line 1254
  return;
}
}
#line 1256 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static void lps_ctrl_wk_hdl(struct rtw_adapter *padapter , u8 lps_ctrl_type ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  u8 mstatus ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;

  {
#line 1258
  pwrpriv = & padapter->pwrctrlpriv;
#line 1259
  pmlmepriv = & padapter->mlmepriv;
#line 1262
  tmp = check_fwstate(pmlmepriv, 64);
#line 1262
  if ((int )tmp) {
#line 1264
    return;
  } else {
#line 1262
    tmp___0 = check_fwstate(pmlmepriv, 32);
#line 1262
    if ((int )tmp___0) {
#line 1264
      return;
    } else {

    }
  }
#line 1266
  switch ((int )lps_ctrl_type) {
  case 0: 
#line 1269
  rtl8723a_BT_wifiscan_notify(padapter, 1);
#line 1270
  tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
#line 1270
  if (tmp___2) {
#line 1270
    tmp___3 = 0;
  } else {
#line 1270
    tmp___3 = 1;
  }
#line 1270
  if (tmp___3) {
#line 1271
    tmp___1 = check_fwstate(pmlmepriv, 1);
#line 1271
    if ((int )tmp___1) {
#line 1272
      LPS_Leave23a(padapter);
    } else {

    }
  } else {

  }
#line 1274
  goto ldv_54512;
  case 1: 
#line 1276
  LPS_Leave23a(padapter);
#line 1277
  goto ldv_54512;
  case 2: 
#line 1279
  mstatus = 1U;
#line 1281
  padapter->pwrctrlpriv.LpsIdleCount = 0U;
#line 1282
  rtl8723a_set_FwJoinBssReport_cmd(padapter, 1);
#line 1283
  rtl8723a_BT_mediastatus_notify(padapter, (enum rt_media_status )mstatus);
#line 1284
  goto ldv_54512;
  case 3: 
#line 1286
  mstatus = 0U;
#line 1287
  rtl8723a_BT_mediastatus_notify(padapter, (enum rt_media_status )mstatus);
#line 1288
  tmp___4 = rtl8723a_BT_using_antenna_1(padapter);
#line 1288
  if (tmp___4) {
#line 1288
    tmp___5 = 0;
  } else {
#line 1288
    tmp___5 = 1;
  }
#line 1288
  if (tmp___5) {
#line 1289
    LPS_Leave23a(padapter);
  } else {

  }
#line 1290
  rtl8723a_set_FwJoinBssReport_cmd(padapter, 0);
#line 1291
  goto ldv_54512;
  case 4: 
#line 1293
  pwrpriv->DelayLPSLastTimeStamp = jiffies;
#line 1294
  rtl8723a_BT_specialpacket_notify(padapter);
#line 1295
  tmp___6 = rtl8723a_BT_using_antenna_1(padapter);
#line 1295
  if (tmp___6) {
#line 1295
    tmp___7 = 0;
  } else {
#line 1295
    tmp___7 = 1;
  }
#line 1295
  if (tmp___7) {
#line 1296
    LPS_Leave23a(padapter);
  } else {

  }
#line 1297
  goto ldv_54512;
  case 5: 
#line 1299
  rtl8723a_BT_lps_leave(padapter);
#line 1300
  tmp___8 = rtl8723a_BT_using_antenna_1(padapter);
#line 1300
  if (tmp___8) {
#line 1300
    tmp___9 = 0;
  } else {
#line 1300
    tmp___9 = 1;
  }
#line 1300
  if (tmp___9) {
#line 1301
    LPS_Leave23a(padapter);
  } else {

  }
#line 1302
  goto ldv_54512;
  default: ;
#line 1305
  goto ldv_54512;
  }
  ldv_54512: ;
#line 1308
  return;
}
}
#line 1309 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_lps_ctrl_wk_cmd23a(struct rtw_adapter *padapter , u8 lps_ctrl_type , u8 enqueue ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1314
  pcmdpriv = & padapter->cmdpriv;
#line 1315
  res = 1;
#line 1317
  if ((unsigned int )enqueue != 0U) {
#line 1318
    tmp = kzalloc(128UL, 32U);
#line 1318
    ph2c = (struct cmd_obj *)tmp;
#line 1319
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 1320
      res = 0;
#line 1321
      goto exit;
    } else {

    }
#line 1324
    tmp___0 = kzalloc(16UL, 32U);
#line 1324
    pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 1326
    if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 1327
      kfree((void const   *)ph2c);
#line 1328
      res = 0;
#line 1329
      goto exit;
    } else {

    }
#line 1332
    pdrvextra_cmd_parm->ec_id = 5;
#line 1333
    pdrvextra_cmd_parm->type_size = (int )lps_ctrl_type;
#line 1334
    pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
#line 1336
    ph2c->cmdcode = 57U;
#line 1336
    ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 1336
    ph2c->cmdsz = 16U;
#line 1336
    ph2c->rsp = (u8 *)0U;
#line 1336
    ph2c->rspsz = 0U;
#line 1339
    res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  } else {
#line 1341
    lps_ctrl_wk_hdl(padapter, (int )lps_ctrl_type);
  }
  exit: ;
#line 1344
  return (res);
}
}
#line 1347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static void power_saving_wk_hdl(struct rtw_adapter *padapter , u8 *pbuf , int sz ) 
{ 


  {
#line 1349
  rtw_ps_processor23a(padapter);
#line 1350
  return;
}
}
#line 1352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_ps_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ppscmd ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1356
  pcmdpriv = & padapter->cmdpriv;
#line 1357
  res = 1;
#line 1359
  tmp = kzalloc(128UL, 32U);
#line 1359
  ppscmd = (struct cmd_obj *)tmp;
#line 1360
  if ((unsigned long )ppscmd == (unsigned long )((struct cmd_obj *)0)) {
#line 1361
    res = 0;
#line 1362
    goto exit;
  } else {

  }
#line 1365
  tmp___0 = kzalloc(16UL, 32U);
#line 1365
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 1367
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 1368
    kfree((void const   *)ppscmd);
#line 1369
    res = 0;
#line 1370
    goto exit;
  } else {

  }
#line 1373
  pdrvextra_cmd_parm->ec_id = 4;
#line 1374
  pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
#line 1375
  ppscmd->cmdcode = 57U;
#line 1375
  ppscmd->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 1375
  ppscmd->cmdsz = 16U;
#line 1375
  ppscmd->rsp = (u8 *)0U;
#line 1375
  ppscmd->rspsz = 0U;
#line 1378
  res = rtw_enqueue_cmd23a(pcmdpriv, ppscmd);
  exit: ;
#line 1381
  return (res);
}
}
#line 1386 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static void rtw_chk_hi_queue_hdl(struct rtw_adapter *padapter ) 
{ 
  int cnt ;
  struct sta_info *psta_bmc ;
  struct sta_priv *pstapriv ;
  bool val ;

  {
#line 1388
  cnt = 0;
#line 1390
  pstapriv = & padapter->stapriv;
#line 1392
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 1393
  if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
#line 1394
    return;
  } else {

  }
#line 1396
  if (psta_bmc->sleepq_len == 0U) {
#line 1399
    val = rtl8723a_chk_hi_queue_empty(padapter);
#line 1401
    goto ldv_54551;
    ldv_54550: 
#line 1402
    msleep(100U);
#line 1404
    cnt = cnt + 1;
#line 1406
    if (cnt > 10) {
#line 1407
      goto ldv_54549;
    } else {

    }
#line 1409
    val = rtl8723a_chk_hi_queue_empty(padapter);
    ldv_54551: ;
#line 1401
    if (! val) {
#line 1403
      goto ldv_54550;
    } else {

    }
    ldv_54549: ;
#line 1412
    if (cnt <= 10) {
#line 1413
      pstapriv->tim_bitmap = (unsigned int )pstapriv->tim_bitmap & 65534U;
#line 1414
      pstapriv->sta_dz_bitmap = (unsigned int )pstapriv->sta_dz_bitmap & 65534U;
#line 1416
      update_beacon23a(padapter, 5, (u8 *)0U, 0);
    } else {
#line 1418
      rtw_chk_hi_queue_cmd23a(padapter);
    }
  } else {

  }
#line 1420
  return;
}
}
#line 1422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_chk_hi_queue_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1426
  pcmdpriv = & padapter->cmdpriv;
#line 1427
  res = 1;
#line 1429
  tmp = kzalloc(128UL, 32U);
#line 1429
  ph2c = (struct cmd_obj *)tmp;
#line 1430
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 1431
    res = 0;
#line 1432
    goto exit;
  } else {

  }
#line 1435
  tmp___0 = kzalloc(16UL, 32U);
#line 1435
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 1437
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 1438
    kfree((void const   *)ph2c);
#line 1439
    res = 0;
#line 1440
    goto exit;
  } else {

  }
#line 1443
  pdrvextra_cmd_parm->ec_id = 9;
#line 1444
  pdrvextra_cmd_parm->type_size = 0;
#line 1445
  pdrvextra_cmd_parm->pbuf = (unsigned char *)0U;
#line 1447
  ph2c->cmdcode = 57U;
#line 1447
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 1447
  ph2c->cmdsz = 16U;
#line 1447
  ph2c->rsp = (u8 *)0U;
#line 1447
  ph2c->rspsz = 0U;
#line 1450
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 1453
  return (res);
}
}
#line 1457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_c2h_wk_cmd23a(struct rtw_adapter *padapter , u8 *c2h_evt ) 
{ 
  struct cmd_obj *ph2c ;
  struct drvextra_cmd_parm *pdrvextra_cmd_parm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1461
  pcmdpriv = & padapter->cmdpriv;
#line 1462
  res = 1;
#line 1464
  tmp = kzalloc(128UL, 32U);
#line 1464
  ph2c = (struct cmd_obj *)tmp;
#line 1465
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 1466
    res = 0;
#line 1467
    goto exit;
  } else {

  }
#line 1470
  tmp___0 = kzalloc(16UL, 32U);
#line 1470
  pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)tmp___0;
#line 1472
  if ((unsigned long )pdrvextra_cmd_parm == (unsigned long )((struct drvextra_cmd_parm *)0)) {
#line 1473
    kfree((void const   *)ph2c);
#line 1474
    res = 0;
#line 1475
    goto exit;
  } else {

  }
#line 1478
  pdrvextra_cmd_parm->ec_id = 10;
#line 1479
  pdrvextra_cmd_parm->type_size = (unsigned long )c2h_evt != (unsigned long )((u8 *)0U) ? 16 : 0;
#line 1480
  pdrvextra_cmd_parm->pbuf = c2h_evt;
#line 1482
  ph2c->cmdcode = 57U;
#line 1482
  ph2c->parmbuf = (u8 *)pdrvextra_cmd_parm;
#line 1482
  ph2c->cmdsz = 16U;
#line 1482
  ph2c->rsp = (u8 *)0U;
#line 1482
  ph2c->rspsz = 0U;
#line 1485
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 1489
  return (res);
}
}
#line 1492 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static int c2h_evt_hdl(struct rtw_adapter *adapter , struct c2h_evt_hdr *c2h_evt ) 
{ 
  int ret ;
  u8 buf[16U] ;
  s32 tmp ;

  {
#line 1494
  ret = 0;
#line 1497
  if ((unsigned long )c2h_evt == (unsigned long )((struct c2h_evt_hdr *)0)) {
#line 1499
    tmp = c2h_evt_read23a(adapter, (u8 *)(& buf));
#line 1499
    if (tmp == 1) {
#line 1500
      c2h_evt = (struct c2h_evt_hdr *)(& buf);
#line 1502
      ret = c2h_handler_8723a(adapter, c2h_evt);
    } else {

    }
  } else {
#line 1505
    ret = c2h_handler_8723a(adapter, c2h_evt);
  }
#line 1507
  return (ret);
}
}
#line 1510 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
static void rtw_irq_work(struct work_struct *work ) 
{ 
  struct evt_priv *evtpriv ;
  struct rtw_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  struct evt_priv  const  *__mptr___0 ;

  {
#line 1515
  __mptr = (struct work_struct  const  *)work;
#line 1515
  evtpriv = (struct evt_priv *)__mptr + 0xfffffffffffffff8UL;
#line 1516
  __mptr___0 = (struct evt_priv  const  *)evtpriv;
#line 1516
  adapter = (struct rtw_adapter *)__mptr___0 + 0xffffffffffffe778UL;
#line 1518
  c2h_evt_clear23a(adapter);
#line 1519
  return;
}
}
#line 1521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_evt_work(struct work_struct *work ) 
{ 
  struct evt_work *ework ;
  struct rtw_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  bool tmp ;

  {
#line 1526
  __mptr = (struct work_struct  const  *)work;
#line 1526
  ework = (struct evt_work *)__mptr + 0xfffffffffffffff0UL;
#line 1527
  adapter = ework->adapter;
#line 1529
  c2h_evt_clear23a(adapter);
#line 1531
  if ((unsigned int )*((unsigned char *)ework + 0UL) == 0U && (unsigned int )*((unsigned char *)ework + 0UL) == 0U) {
#line 1532
    kfree((void const   *)ework);
#line 1533
    return;
  } else {

  }
#line 1536
  tmp = c2h_id_filter_ccx_8723a((int )ework->u.c2h_evt.id);
#line 1536
  if ((int )tmp) {
#line 1538
    c2h_handler_8723a(adapter, & ework->u.c2h_evt);
#line 1539
    kfree((void const   *)ework);
  } else {
#line 1546
    rtw_c2h_wk_cmd23a(adapter, (u8 *)(& ework->u.c2h_evt));
  }
#line 1547
  return;
}
}
#line 1550 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int rtw_drvextra_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct drvextra_cmd_parm  const  *pdrvextra_cmd ;

  {
#line 1554
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 1555
    return (4);
  } else {

  }
#line 1557
  pdrvextra_cmd = (struct drvextra_cmd_parm  const  *)pbuf;
#line 1559
  switch (pdrvextra_cmd->ec_id) {
  case 1: 
#line 1562
  dynamic_chk_wk_hdl(padapter, (u8 *)pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
#line 1564
  goto ldv_54597;
  case 4: 
#line 1566
  power_saving_wk_hdl(padapter, (u8 *)pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
#line 1568
  goto ldv_54597;
  case 5: 
#line 1570
  lps_ctrl_wk_hdl(padapter, (int )((unsigned char )pdrvextra_cmd->type_size));
#line 1571
  goto ldv_54597;
  case 9: 
#line 1574
  rtw_chk_hi_queue_hdl(padapter);
#line 1575
  goto ldv_54597;
  case 10: 
#line 1578
  c2h_evt_hdl(padapter, (struct c2h_evt_hdr *)pdrvextra_cmd->pbuf);
#line 1580
  goto ldv_54597;
  default: ;
#line 1583
  goto ldv_54597;
  }
  ldv_54597: ;
#line 1586
  if ((unsigned long )pdrvextra_cmd->pbuf != (unsigned long )((unsigned char */* const  */)0U) && (int )pdrvextra_cmd->type_size > 0) {
#line 1587
    kfree((void const   *)pdrvextra_cmd->pbuf);
  } else {

  }
#line 1595
  return (0);
}
}
#line 1598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_survey_cmd_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 1601
  pmlmepriv = & padapter->mlmepriv;
#line 1603
  if (pcmd->res == 3) {
#line 1606
    tmp = msecs_to_jiffies(1U);
#line 1606
    ldv_mod_timer_34(& pmlmepriv->scan_to_timer, tmp + (unsigned long )jiffies);
  } else
#line 1608
  if (pcmd->res != 0) {
#line 1609
    tmp___0 = msecs_to_jiffies(1U);
#line 1609
    ldv_mod_timer_35(& pmlmepriv->scan_to_timer, tmp___0 + (unsigned long )jiffies);
#line 1611
    if (GlobalDebugLevel23A > 3U) {
#line 1611
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 1611
      printk("\016\n ********Error: MgntActrtw_set_802_11_bssid23a_LIST_SCAN Fail ************\n\n.");
    } else {

    }
  } else {

  }
#line 1617
  rtw_free_cmd_obj23a(pcmd);
#line 1618
  return;
}
}
#line 1620 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_disassoc_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
#line 1623
  pmlmepriv = & padapter->mlmepriv;
#line 1625
  if (pcmd->res != 0) {
#line 1626
    spin_lock_bh(& pmlmepriv->lock);
#line 1627
    set_fwstate(pmlmepriv, 1);
#line 1628
    spin_unlock_bh(& pmlmepriv->lock);
#line 1629
    if (GlobalDebugLevel23A > 3U) {
#line 1629
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 1629
      printk("\016\n ***Error: disconnect_cmd_callback Fail ***\n.");
    } else {

    }
#line 1631
    return;
  } else {

  }
#line 1635
  rtw_free_cmd_obj23a(pcmd);
#line 1636
  return;
}
}
#line 1638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_joinbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 1641
  pmlmepriv = & padapter->mlmepriv;
#line 1643
  if (pcmd->res == 3) {
#line 1646
    tmp = msecs_to_jiffies(1U);
#line 1646
    ldv_mod_timer_36(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
  } else
#line 1648
  if (pcmd->res != 0) {
#line 1649
    if (GlobalDebugLevel23A > 3U) {
#line 1649
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 1649
      printk("\016********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n");
    } else {

    }
#line 1652
    tmp___0 = msecs_to_jiffies(1U);
#line 1652
    ldv_mod_timer_37(& pmlmepriv->assoc_timer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
#line 1656
  rtw_free_cmd_obj23a(pcmd);
#line 1657
  return;
}
}
#line 1659 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_createbss_cmd23a_callback(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct sta_info *psta ;
  struct wlan_network *pwlan ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_network *tgt_network ;
  unsigned long tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  uint tmp___0 ;
  void *__ret___0 ;
  bool tmp___1 ;

  {
#line 1664
  pmlmepriv = & padapter->mlmepriv;
#line 1665
  pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;
#line 1666
  tgt_network = & pmlmepriv->cur_network;
#line 1668
  if (pcmd->res != 0) {
#line 1669
    if (GlobalDebugLevel23A > 3U) {
#line 1669
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 1669
      printk("\016\n ********Error: rtw_createbss_cmd23a_callback  Fail ************\n\n.");
    } else {

    }
#line 1672
    tmp = msecs_to_jiffies(1U);
#line 1672
    ldv_mod_timer_38(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
  } else {

  }
#line 1676
  ldv_del_timer_sync_39(& pmlmepriv->assoc_timer);
#line 1678
  tmp___1 = check_fwstate(pmlmepriv, 16);
#line 1678
  if ((int )tmp___1) {
#line 1679
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pnetwork->MacAddress));
#line 1681
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1682
      psta = rtw_alloc_stainfo23a(& padapter->stapriv, (u8 *)(& pnetwork->MacAddress),
                                  208U);
#line 1685
      if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1686
        if (GlobalDebugLevel23A > 3U) {
#line 1686
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 1686
          printk("\016\nCan\'t alloc sta_info when createbss_cmd_callback\n");
        } else {

        }
#line 1689
        goto createbss_cmd_fail;
      } else {

      }
    } else {

    }
#line 1693
    spin_lock_bh(& pmlmepriv->lock);
#line 1694
    rtw_indicate_connect23a(padapter);
#line 1695
    spin_unlock_bh(& pmlmepriv->lock);
  } else {
#line 1697
    pwlan = rtw_alloc_network(pmlmepriv, 208);
#line 1698
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1699
    if ((unsigned long )pwlan == (unsigned long )((struct wlan_network *)0)) {
#line 1700
      pwlan = rtw_get_oldest_wlan_network23a(& pmlmepriv->scanned_queue);
#line 1701
      if ((unsigned long )pwlan == (unsigned long )((struct wlan_network *)0)) {
#line 1702
        if (GlobalDebugLevel23A > 3U) {
#line 1702
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 1702
          printk("\016\n Error:  can\'t get pwlan in rtw23a_joinbss_event_cb\n");
        } else {

        }
#line 1705
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1706
        goto createbss_cmd_fail;
      } else {

      }
#line 1708
      pwlan->last_scanned = jiffies;
    } else {
#line 1710
      list_add_tail(& pwlan->list, & pmlmepriv->scanned_queue.queue);
    }
#line 1714
    pnetwork->Length = get_wlan_bssid_ex_sz(pnetwork);
#line 1715
    __len = (size_t )pnetwork->Length;
#line 1715
    __ret = __builtin_memcpy((void *)(& pwlan->network), (void const   *)pnetwork,
                             __len);
#line 1723
    tmp___0 = get_wlan_bssid_ex_sz(pnetwork);
#line 1723
    __len___0 = (size_t )tmp___0;
#line 1723
    __ret___0 = __builtin_memcpy((void *)(& tgt_network->network), (void const   *)pnetwork,
                                 __len___0);
#line 1728
    clr_fwstate(pmlmepriv, 128);
#line 1730
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  }
  createbss_cmd_fail: 
#line 1737
  rtw_free_cmd_obj23a(pcmd);
#line 1738
  return;
}
}
#line 1740 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_setstaKey_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct sta_priv *pstapriv ;
  struct set_stakey_rsp *psetstakey_rsp ;
  struct sta_info *psta ;

  {
#line 1747
  pstapriv = & padapter->stapriv;
#line 1748
  psetstakey_rsp = (struct set_stakey_rsp *)pcmd->rsp;
#line 1749
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& psetstakey_rsp->addr));
#line 1751
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1752
    if (GlobalDebugLevel23A > 3U) {
#line 1752
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 1752
      printk("\016\nERROR: rtw_setstaKey_cmdrsp_callback23a => can\'t get sta_info\n\n");
    } else {

    }
#line 1755
    goto exit;
  } else {

  }
  exit: 
#line 1760
  rtw_free_cmd_obj23a(pcmd);
#line 1761
  return;
}
}
#line 1763 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void rtw_setassocsta_cmdrsp_callback23a(struct rtw_adapter *padapter , struct cmd_obj *pcmd ) 
{ 
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct set_assocsta_parm *passocsta_parm ;
  struct set_assocsta_rsp *passocsta_rsp ;
  struct sta_info *psta ;
  uint tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 1766
  pstapriv = & padapter->stapriv;
#line 1767
  pmlmepriv = & padapter->mlmepriv;
#line 1772
  passocsta_parm = (struct set_assocsta_parm *)pcmd->parmbuf;
#line 1773
  passocsta_rsp = (struct set_assocsta_rsp *)pcmd->rsp;
#line 1774
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& passocsta_parm->addr));
#line 1776
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1777
    if (GlobalDebugLevel23A > 3U) {
#line 1777
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 1777
      printk("\016\nERROR: setassocsta_cmdrsp_callbac => can\'t get sta_info\n\n");
    } else {

    }
#line 1780
    goto exit;
  } else {

  }
#line 1783
  tmp = (uint )passocsta_rsp->cam_id;
#line 1783
  psta->mac_id = tmp;
#line 1783
  psta->aid = tmp;
#line 1785
  spin_lock_bh(& pmlmepriv->lock);
#line 1787
  tmp___0 = check_fwstate(pmlmepriv, 65536);
#line 1787
  if ((int )tmp___0) {
#line 1787
    tmp___1 = check_fwstate(pmlmepriv, 128);
#line 1787
    if ((int )tmp___1) {
#line 1789
      _clr_fwstate_(pmlmepriv, 128);
    } else {

    }
  } else {

  }
#line 1791
  set_fwstate(pmlmepriv, 1);
#line 1792
  spin_unlock_bh(& pmlmepriv->lock);
  exit: 
#line 1795
  rtw_free_cmd_obj23a(pcmd);
#line 1796
  return;
}
}
#line 1806 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 1809
  ldv_spin_lock();
#line 1811
  ldv_spin_lock_bh_2(lock);
#line 1812
  return;
}
}
#line 1841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 1844
  ldv_spin_unlock();
#line 1846
  ldv_spin_unlock_bh_6(lock);
#line 1847
  return;
}
}
#line 1925 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
void *ldv_kmem_cache_alloc_16(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1928
  ldv_check_alloc_flags(flags);
#line 1930
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1931
  return ((void *)0);
}
}
#line 1933 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 


  {
#line 1936
  ldv_check_alloc_flags(flags);
#line 1937
  return ((void *)0);
}
}
#line 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_pskb_expand_head_22(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1972
  ldv_check_alloc_flags(flags);
#line 1974
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1974
  return (tmp);
}
}
#line 1985 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct sk_buff *ldv_skb_clone_24(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1988
  ldv_check_alloc_flags(flags);
#line 1990
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1990
  return (tmp);
}
}
#line 2001 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct sk_buff *ldv_skb_copy_26(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2004
  ldv_check_alloc_flags(flags);
#line 2006
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2006
  return (tmp);
}
}
#line 2009 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_27(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2012
  ldv_check_alloc_flags(flags);
#line 2014
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2014
  return (tmp);
}
}
#line 2017 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_28(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2020
  ldv_check_alloc_flags(flags);
#line 2022
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2022
  return (tmp);
}
}
#line 2025 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_29(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2028
  ldv_check_alloc_flags(flags);
#line 2030
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2030
  return (tmp);
}
}
#line 2033 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_pskb_expand_head_30(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2036
  ldv_check_alloc_flags(flags);
#line 2038
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2038
  return (tmp);
}
}
#line 2041 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_pskb_expand_head_31(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2044
  ldv_check_alloc_flags(flags);
#line 2046
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2046
  return (tmp);
}
}
#line 2049 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
struct sk_buff *ldv_skb_clone_32(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2052
  ldv_check_alloc_flags(flags);
#line 2054
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2054
  return (tmp);
}
}
#line 2057 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_33(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 2061
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2061
  ldv_func_res = tmp;
#line 2063
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2065
  return (ldv_func_res);
}
}
#line 2068 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_34(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 2072
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2072
  ldv_func_res = tmp;
#line 2074
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2076
  return (ldv_func_res);
}
}
#line 2079 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_35(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 2083
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2083
  ldv_func_res = tmp;
#line 2085
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2087
  return (ldv_func_res);
}
}
#line 2090 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_36(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 2094
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2094
  ldv_func_res = tmp;
#line 2096
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2098
  return (ldv_func_res);
}
}
#line 2101 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_37(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 2105
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2105
  ldv_func_res = tmp;
#line 2107
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2109
  return (ldv_func_res);
}
}
#line 2112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_mod_timer_38(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 2116
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2116
  ldv_func_res = tmp;
#line 2118
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2120
  return (ldv_func_res);
}
}
#line 2123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_cmd.o.c.prepared"
int ldv_del_timer_sync_39(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 2127
  tmp = del_timer_sync(ldv_func_arg1);
#line 2127
  ldv_func_res = tmp;
#line 2129
  disable_suitable_timer_6(ldv_func_arg1);
#line 2131
  return (ldv_func_res);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_72(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 10 "include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_80(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_88(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_82(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_78(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_87(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_83(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_84(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_85(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) ;
#line 84 "drivers/staging/rtl8723au/include/rtw_efuse.h"
u16 efuse_GetMaxSize23a(struct rtw_adapter *padapter ) ;
#line 85
int rtw_efuse_access23a(struct rtw_adapter *padapter , u8 bWrite , u16 start_addr ,
                        u16 cnts , u8 *data ) ;
#line 86
int rtw_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts , u8 *data ) ;
#line 88
int rtw_BT_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts ,
                             u8 *data ) ;
#line 91
u16 Efuse_GetCurrentSize23a(struct rtw_adapter *pAdapter , u8 efuseType ) ;
#line 92
u8 Efuse_CalculateWordCnts23a(u8 word_en ) ;
#line 93
void ReadEFuseByte23a(struct rtw_adapter *Adapter , u16 _offset , u8 *pbuf ) ;
#line 94
void EFUSE_GetEfuseDefinition23a(struct rtw_adapter *pAdapter , u8 efuseType , u8 type ,
                                 void *pOut ) ;
#line 95
int efuse_OneByteRead23a(struct rtw_adapter *pAdapter , u16 addr , u8 *data ) ;
#line 96
int efuse_OneByteWrite23a(struct rtw_adapter *pAdapter , u16 addr , u8 data ) ;
#line 101
void efuse_WordEnableDataRead23a(u8 word_en , u8 *sourdata , u8 *targetdata ) ;
#line 104
u8 EFUSE_Read1Byte23a(struct rtw_adapter *Adapter , u16 Address ) ;
#line 105
void EFUSE_ShadowMapUpdate23a(struct rtw_adapter *pAdapter , u8 efuseType ) ;
#line 106
void EFUSE_ShadowRead23a(struct rtw_adapter *pAdapter , u8 Type , u16 Offset , u32 *Value ) ;
#line 550 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_readefuse(struct rtw_adapter *padapter , u8 efuseType , u16 _offset ,
                        u16 _size_byte , u8 *pbuf ) ;
#line 552
u16 rtl8723a_EfuseGetCurrentSize_WiFi(struct rtw_adapter *padapter ) ;
#line 553
u16 rtl8723a_EfuseGetCurrentSize_BT(struct rtw_adapter *padapter ) ;
#line 32 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
u8 rtl8723au_read8(struct rtw_adapter *padapter , u32 addr ) ;
#line 33
u16 rtl8723au_read16(struct rtw_adapter *padapter , u32 addr ) ;
#line 34
u32 rtl8723au_read32(struct rtw_adapter *padapter , u32 addr ) ;
#line 35
int rtl8723au_write8(struct rtw_adapter *padapter , u32 addr , u8 val ) ;
#line 36
int rtl8723au_write16(struct rtw_adapter *padapter , u32 addr , u16 val ) ;
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
static void Efuse_PowerSwitch(struct rtw_adapter *padapter , u8 bWrite , u8 PwrState ) 
{ 
  u8 tempval ;
  u16 tmpV16 ;

  {
#line 276
  if ((unsigned int )PwrState == 1U) {
#line 277
    rtl8723au_write8(padapter, 207U, 105);
#line 281
    tmpV16 = rtl8723au_read16(padapter, 0U);
#line 282
    if ((int )((short )tmpV16) >= 0) {
#line 283
      tmpV16 = (u16 )((unsigned int )tmpV16 | 32768U);
#line 284
      rtl8723au_write16(padapter, 0U, (int )tmpV16);
    } else {

    }
#line 287
    tmpV16 = rtl8723au_read16(padapter, 2U);
#line 288
    if (((unsigned long )tmpV16 & 4096UL) == 0UL) {
#line 289
      tmpV16 = (u16 )((unsigned int )tmpV16 | 4096U);
#line 290
      rtl8723au_write16(padapter, 2U, (int )tmpV16);
    } else {

    }
#line 295
    tmpV16 = rtl8723au_read16(padapter, 8U);
#line 296
    if (((unsigned long )tmpV16 & 32UL) == 0UL || ((unsigned long )tmpV16 & 2UL) == 0UL) {
#line 297
      tmpV16 = (u16 )((unsigned int )tmpV16 | 34U);
#line 298
      rtl8723au_write16(padapter, 8U, (int )tmpV16);
    } else {

    }
#line 301
    if ((unsigned int )bWrite == 1U) {
#line 303
      tempval = rtl8723au_read8(padapter, 55U);
#line 304
      tempval = (unsigned int )tempval & 15U;
#line 305
      tempval = (u8 )((unsigned int )tempval | 48U);
#line 306
      rtl8723au_write8(padapter, 55U, (int )((unsigned int )tempval | 128U));
    } else {

    }
  } else {
#line 310
    rtl8723au_write8(padapter, 207U, 0);
#line 312
    if ((unsigned int )bWrite == 1U) {
#line 314
      tempval = rtl8723au_read8(padapter, 55U);
#line 315
      rtl8723au_write8(padapter, 55U, (int )tempval & 127);
    } else {

    }
  }
#line 318
  return;
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
u16 Efuse_GetCurrentSize23a(struct rtw_adapter *pAdapter , u8 efuseType ) 
{ 
  u16 ret ;

  {
#line 340
  ret = 0U;
#line 342
  if ((unsigned int )efuseType == 0U) {
#line 343
    ret = rtl8723a_EfuseGetCurrentSize_WiFi(pAdapter);
  } else {
#line 345
    ret = rtl8723a_EfuseGetCurrentSize_BT(pAdapter);
  }
#line 347
  return (ret);
}
}
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
u8 Efuse_CalculateWordCnts23a(u8 word_en ) 
{ 
  u8 word_cnts ;

  {
#line 354
  word_cnts = 0U;
#line 355
  if (((unsigned long )word_en & 1UL) == 0UL) {
#line 355
    word_cnts = (u8 )((int )word_cnts + 1);
  } else {

  }
#line 356
  if (((unsigned long )word_en & 2UL) == 0UL) {
#line 356
    word_cnts = (u8 )((int )word_cnts + 1);
  } else {

  }
#line 357
  if (((unsigned long )word_en & 4UL) == 0UL) {
#line 357
    word_cnts = (u8 )((int )word_cnts + 1);
  } else {

  }
#line 358
  if (((unsigned long )word_en & 8UL) == 0UL) {
#line 358
    word_cnts = (u8 )((int )word_cnts + 1);
  } else {

  }
#line 359
  return (word_cnts);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
void ReadEFuseByte23a(struct rtw_adapter *Adapter , u16 _offset , u8 *pbuf ) 
{ 
  u32 value32 ;
  u8 readbyte ;
  u16 retry ;

  {
#line 381
  rtl8723au_write8(Adapter, 49U, (int )((u8 )_offset));
#line 382
  readbyte = rtl8723au_read8(Adapter, 50U);
#line 383
  rtl8723au_write8(Adapter, 50U, (int )((u8 )(((int )((signed char )((int )_offset >> 8)) & 3) | ((int )((signed char )readbyte) & -4))));
#line 387
  readbyte = rtl8723au_read8(Adapter, 51U);
#line 388
  rtl8723au_write8(Adapter, 51U, (int )readbyte & 127);
#line 391
  retry = 0U;
#line 392
  value32 = rtl8723au_read32(Adapter, 48U);
#line 394
  goto ldv_54268;
  ldv_54267: 
#line 396
  value32 = rtl8723au_read32(Adapter, 48U);
#line 397
  retry = (u16 )((int )retry + 1);
  ldv_54268: ;
#line 394
  if ((int )value32 >= 0 && (unsigned int )retry <= 9999U) {
#line 396
    goto ldv_54267;
  } else {

  }
#line 404
  __const_udelay(214750UL);
#line 405
  value32 = rtl8723au_read32(Adapter, 48U);
#line 407
  *pbuf = (unsigned char )value32;
#line 408
  return;
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
void EFUSE_GetEfuseDefinition23a(struct rtw_adapter *pAdapter , u8 efuseType , u8 type ,
                                 void *pOut ) 
{ 
  u8 *pu1Tmp ;
  u16 *pu2Tmp ;
  u8 *pMax_section ;

  {
#line 418
  switch ((int )type) {
  case 0: 
#line 420
  pMax_section = (u8 *)pOut;
#line 422
  if ((unsigned int )efuseType == 0U) {
#line 423
    *pMax_section = 32U;
  } else {
#line 425
    *pMax_section = 128U;
  }
#line 426
  goto ldv_54280;
  case 1: 
#line 429
  pu2Tmp = (u16 *)pOut;
#line 431
  if ((unsigned int )efuseType == 0U) {
#line 432
    *pu2Tmp = 512U;
  } else {
#line 434
    *pu2Tmp = 1536U;
  }
#line 435
  goto ldv_54280;
  case 2: 
#line 438
  pu2Tmp = (u16 *)pOut;
#line 440
  if ((unsigned int )efuseType == 0U) {
#line 441
    *pu2Tmp = 497U;
  } else {
#line 444
    *pu2Tmp = 496U;
  }
#line 446
  goto ldv_54280;
  case 3: 
#line 449
  pu2Tmp = (u16 *)pOut;
#line 451
  if ((unsigned int )efuseType == 0U) {
#line 452
    *pu2Tmp = 497U;
  } else {
#line 455
    *pu2Tmp = 1488U;
  }
#line 457
  goto ldv_54280;
  case 4: 
#line 460
  pu2Tmp = (u16 *)pOut;
#line 462
  if ((unsigned int )efuseType == 0U) {
#line 463
    *pu2Tmp = 256U;
  } else {
#line 465
    *pu2Tmp = 1024U;
  }
#line 466
  goto ldv_54280;
  case 5: 
#line 469
  pu1Tmp = (u8 *)pOut;
#line 471
  if ((unsigned int )efuseType == 0U) {
#line 472
    *pu1Tmp = 15U;
  } else {
#line 474
    *pu1Tmp = 16U;
  }
#line 475
  goto ldv_54280;
  case 6: 
#line 478
  pu2Tmp = (u16 *)pOut;
#line 480
  if ((unsigned int )efuseType == 0U) {
#line 481
    *pu2Tmp = 512U;
  } else {
#line 483
    *pu2Tmp = 512U;
  }
#line 484
  goto ldv_54280;
  default: 
#line 487
  pu1Tmp = (u8 *)pOut;
#line 488
  *pu1Tmp = 0U;
#line 489
  goto ldv_54280;
  }
  ldv_54280: ;
#line 492
  return;
}
}
#line 510 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
u8 EFUSE_Read1Byte23a(struct rtw_adapter *Adapter , u16 Address ) 
{ 
  u8 data ;
  u8 Bytetemp ;
  u8 temp ;
  u32 k ;
  u16 contentLen ;

  {
#line 513
  Bytetemp = 0U;
#line 514
  temp = 0U;
#line 515
  k = 0U;
#line 516
  contentLen = 0U;
#line 518
  EFUSE_GetEfuseDefinition23a(Adapter, 0, 1, (void *)(& contentLen));
#line 522
  if ((int )Address < (int )contentLen) {
#line 525
    temp = (u8 )Address;
#line 526
    rtl8723au_write8(Adapter, 49U, (int )temp);
#line 527
    Bytetemp = rtl8723au_read8(Adapter, 50U);
#line 529
    temp = (u8 )(((int )((signed char )((int )Address >> 8)) & 3) | ((int )((signed char )Bytetemp) & -4));
#line 530
    rtl8723au_write8(Adapter, 50U, (int )temp);
#line 533
    Bytetemp = rtl8723au_read8(Adapter, 51U);
#line 534
    temp = (unsigned int )Bytetemp & 127U;
#line 535
    rtl8723au_write8(Adapter, 51U, (int )temp);
#line 538
    Bytetemp = rtl8723au_read8(Adapter, 51U);
#line 539
    goto ldv_54299;
    ldv_54298: 
#line 541
    Bytetemp = rtl8723au_read8(Adapter, 51U);
#line 542
    k = k + 1U;
#line 543
    if (k == 1000U) {
#line 545
      k = 0U;
#line 546
      goto ldv_54297;
    } else {

    }
    ldv_54299: ;
#line 539
    if ((int )((signed char )Bytetemp) >= 0) {
#line 541
      goto ldv_54298;
    } else {

    }
    ldv_54297: 
#line 549
    data = rtl8723au_read8(Adapter, 48U);
#line 550
    return (data);
  } else {
#line 553
    return (255U);
  }
}
}
#line 574
void EFUSE_Write1Byte(struct rtw_adapter *Adapter , u16 Address , u8 Value ) ;
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
void EFUSE_Write1Byte(struct rtw_adapter *Adapter , u16 Address , u8 Value ) 
{ 
  u8 Bytetemp ;
  u8 temp ;
  u32 k ;
  u16 contentLen ;

  {
#line 584
  Bytetemp = 0U;
#line 585
  temp = 0U;
#line 586
  k = 0U;
#line 587
  contentLen = 0U;
#line 590
  EFUSE_GetEfuseDefinition23a(Adapter, 0, 1, (void *)(& contentLen));
#line 594
  if ((int )Address < (int )contentLen) {
#line 596
    rtl8723au_write8(Adapter, 48U, (int )Value);
#line 599
    temp = (u8 )Address;
#line 600
    rtl8723au_write8(Adapter, 49U, (int )temp);
#line 601
    Bytetemp = rtl8723au_read8(Adapter, 50U);
#line 604
    temp = (u8 )(((int )((signed char )((int )Address >> 8)) & 3) | ((int )((signed char )Bytetemp) & -4));
#line 605
    rtl8723au_write8(Adapter, 50U, (int )temp);
#line 608
    Bytetemp = rtl8723au_read8(Adapter, 51U);
#line 609
    temp = (u8 )((unsigned int )Bytetemp | 128U);
#line 610
    rtl8723au_write8(Adapter, 51U, (int )temp);
#line 613
    Bytetemp = rtl8723au_read8(Adapter, 51U);
#line 614
    goto ldv_54315;
    ldv_54314: 
#line 616
    Bytetemp = rtl8723au_read8(Adapter, 51U);
#line 617
    k = k + 1U;
#line 618
    if (k == 100U) {
#line 620
      k = 0U;
#line 621
      goto ldv_54313;
    } else {

    }
    ldv_54315: ;
#line 614
    if ((int )((signed char )Bytetemp) < 0) {
#line 616
      goto ldv_54314;
    } else {

    }
    ldv_54313: ;
  } else {

  }
#line 622
  return;
}
}
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
int efuse_OneByteRead23a(struct rtw_adapter *pAdapter , u16 addr , u8 *data ) 
{ 
  u8 tmpidx ;
  int bResult ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 631
  tmpidx = 0U;
#line 636
  rtl8723au_write8(pAdapter, 49U, (int )((unsigned char )addr));
#line 637
  tmp = rtl8723au_read8(pAdapter, 50U);
#line 637
  rtl8723au_write8(pAdapter, 50U, (int )((u8 )(((int )((signed char )((int )addr >> 8)) & 3) | ((int )((signed char )tmp) & -4))));
#line 640
  rtl8723au_write8(pAdapter, 51U, 114);
#line 642
  goto ldv_54324;
  ldv_54323: 
#line 643
  tmpidx = (u8 )((int )tmpidx + 1);
  ldv_54324: 
#line 642
  tmp___0 = rtl8723au_read8(pAdapter, 51U);
#line 642
  if ((int )((signed char )tmp___0) >= 0 && (unsigned int )tmpidx <= 99U) {
#line 644
    goto ldv_54323;
  } else {

  }

#line 644
  if ((unsigned int )tmpidx <= 99U) {
#line 645
    *data = rtl8723au_read8(pAdapter, 48U);
#line 646
    bResult = 1;
  } else {
#line 648
    *data = 255U;
#line 649
    bResult = 0;
  }
#line 651
  return (bResult);
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
int efuse_OneByteWrite23a(struct rtw_adapter *pAdapter , u16 addr , u8 data ) 
{ 
  u8 tmpidx ;
  int bResult ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 658
  tmpidx = 0U;
#line 667
  rtl8723au_write8(pAdapter, 49U, (int )((unsigned char )addr));
#line 668
  tmp = rtl8723au_read8(pAdapter, 50U);
#line 668
  rtl8723au_write8(pAdapter, 50U, (int )((u8 )(((int )((signed char )tmp) & -4) | ((int )((signed char )((int )addr >> 8)) & 3))));
#line 670
  rtl8723au_write8(pAdapter, 48U, (int )data);
#line 672
  rtl8723au_write8(pAdapter, 51U, 242);
#line 674
  goto ldv_54334;
  ldv_54333: 
#line 676
  tmpidx = (u8 )((int )tmpidx + 1);
  ldv_54334: 
#line 674
  tmp___0 = rtl8723au_read8(pAdapter, 51U);
#line 674
  if ((int )((signed char )tmp___0) < 0 && (unsigned int )tmpidx <= 99U) {
#line 677
    goto ldv_54333;
  } else {

  }

#line 679
  if ((unsigned int )tmpidx <= 99U) {
#line 680
    bResult = 1;
  } else {
#line 682
    bResult = 0;
  }
#line 684
  return (bResult);
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
void efuse_WordEnableDataRead23a(u8 word_en , u8 *sourdata , u8 *targetdata ) 
{ 


  {
#line 709
  if (((unsigned long )word_en & 1UL) == 0UL) {
#line 711
    *targetdata = *sourdata;
#line 712
    *(targetdata + 1UL) = *(sourdata + 1UL);
  } else {

  }
#line 714
  if (((unsigned long )word_en & 2UL) == 0UL) {
#line 716
    *(targetdata + 2UL) = *(sourdata + 2UL);
#line 717
    *(targetdata + 3UL) = *(sourdata + 3UL);
  } else {

  }
#line 719
  if (((unsigned long )word_en & 4UL) == 0UL) {
#line 721
    *(targetdata + 4UL) = *(sourdata + 4UL);
#line 722
    *(targetdata + 5UL) = *(sourdata + 5UL);
  } else {

  }
#line 724
  if (((unsigned long )word_en & 8UL) == 0UL) {
#line 726
    *(targetdata + 6UL) = *(sourdata + 6UL);
#line 727
    *(targetdata + 7UL) = *(sourdata + 7UL);
  } else {

  }
#line 729
  return;
}
}
#line 731 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
static int efuse_read8(struct rtw_adapter *padapter , u16 address , u8 *value ) 
{ 
  int tmp ;

  {
#line 733
  tmp = efuse_OneByteRead23a(padapter, (int )address, value);
#line 733
  return (tmp);
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
static int efuse_write8(struct rtw_adapter *padapter , u16 address , u8 *value ) 
{ 
  int tmp ;

  {
#line 738
  tmp = efuse_OneByteWrite23a(padapter, (int )address, (int )*value);
#line 738
  return (tmp);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
int rtw_efuse_access23a(struct rtw_adapter *padapter , u8 bWrite , u16 start_addr ,
                        u16 cnts , u8 *data ) 
{ 
  int i ;
  u16 real_content_len ;
  u16 max_available_size ;
  int res ;
  int (*rw8)(struct rtw_adapter * , u16  , u8 * ) ;
  u8 *tmp ;
  u16 tmp___0 ;

  {
#line 747
  i = 0;
#line 748
  real_content_len = 0U;
#line 748
  max_available_size = 0U;
#line 749
  res = 0;
#line 752
  EFUSE_GetEfuseDefinition23a(padapter, 0, 1, (void *)(& real_content_len));
#line 755
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& max_available_size));
#line 759
  if ((int )start_addr > (int )real_content_len) {
#line 760
    return (0);
  } else {

  }
#line 762
  if ((unsigned int )bWrite == 1U) {
#line 763
    if ((int )start_addr + (int )cnts > (int )max_available_size) {
#line 764
      return (0);
    } else {

    }
#line 765
    rw8 = & efuse_write8;
  } else {
#line 767
    rw8 = & efuse_read8;
  }
#line 769
  Efuse_PowerSwitch(padapter, (int )bWrite, 1);
#line 772
  i = 0;
#line 772
  goto ldv_54368;
  ldv_54367: ;
#line 773
  if ((int )start_addr >= (int )real_content_len) {
#line 774
    res = 0;
#line 775
    goto ldv_54366;
  } else {

  }
#line 778
  tmp = data;
#line 778
  data = data + 1;
#line 778
  tmp___0 = start_addr;
#line 778
  start_addr = (u16 )((int )start_addr + 1);
#line 778
  res = (*rw8)(padapter, (int )tmp___0, tmp);
#line 779
  if (res == 0) {
#line 780
    goto ldv_54366;
  } else {

  }
#line 772
  i = i + 1;
  ldv_54368: ;
#line 772
  if ((int )cnts > i) {
#line 774
    goto ldv_54367;
  } else {

  }
  ldv_54366: 
#line 783
  Efuse_PowerSwitch(padapter, (int )bWrite, 0);
#line 785
  return (res);
}
}
#line 788 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
u16 efuse_GetMaxSize23a(struct rtw_adapter *padapter ) 
{ 
  u16 max_size ;

  {
#line 791
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& max_size));
#line 794
  return (max_size);
}
}
#line 797 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
int efuse_GetCurrentSize23a(struct rtw_adapter *padapter , u16 *size ) 
{ 


  {
#line 799
  Efuse_PowerSwitch(padapter, 0, 1);
#line 800
  *size = Efuse_GetCurrentSize23a(padapter, 0);
#line 801
  Efuse_PowerSwitch(padapter, 0, 0);
#line 803
  return (1);
}
}
#line 806 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
int rtw_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts , u8 *data ) 
{ 
  u16 mapLen ;

  {
#line 809
  mapLen = 0U;
#line 811
  EFUSE_GetEfuseDefinition23a(padapter, 0, 4, (void *)(& mapLen));
#line 814
  if ((int )addr + (int )cnts > (int )mapLen) {
#line 815
    return (0);
  } else {

  }
#line 817
  Efuse_PowerSwitch(padapter, 0, 1);
#line 819
  rtl8723a_readefuse(padapter, 0, (int )addr, (int )cnts, data);
#line 821
  Efuse_PowerSwitch(padapter, 0, 0);
#line 823
  return (1);
}
}
#line 826 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
int rtw_BT_efuse_map_read23a(struct rtw_adapter *padapter , u16 addr , u16 cnts ,
                             u8 *data ) 
{ 
  u16 mapLen ;

  {
#line 829
  mapLen = 0U;
#line 831
  EFUSE_GetEfuseDefinition23a(padapter, 1, 4, (void *)(& mapLen));
#line 834
  if ((int )addr + (int )cnts > (int )mapLen) {
#line 835
    return (0);
  } else {

  }
#line 837
  Efuse_PowerSwitch(padapter, 0, 1);
#line 839
  rtl8723a_readefuse(padapter, 1, (int )addr, (int )cnts, data);
#line 841
  Efuse_PowerSwitch(padapter, 0, 0);
#line 843
  return (1);
}
}
#line 863
void Efuse_ReadAllMap(struct rtw_adapter *pAdapter , u8 efuseType , u8 *Efuse ) ;
#line 865 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
void Efuse_ReadAllMap(struct rtw_adapter *pAdapter , u8 efuseType , u8 *Efuse ) 
{ 
  u16 mapLen ;

  {
#line 867
  mapLen = 0U;
#line 869
  Efuse_PowerSwitch(pAdapter, 0, 1);
#line 871
  EFUSE_GetEfuseDefinition23a(pAdapter, (int )efuseType, 4, (void *)(& mapLen));
#line 874
  rtl8723a_readefuse(pAdapter, (int )efuseType, 0, (int )mapLen, Efuse);
#line 876
  Efuse_PowerSwitch(pAdapter, 0, 0);
#line 877
  return;
}
}
#line 898 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
static void efuse_ShadowRead1Byte(struct rtw_adapter *pAdapter , u16 Offset , u8 *Value ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
#line 903
  pEEPROM = & pAdapter->eeprompriv;
#line 905
  *Value = pEEPROM->efuse_eeprom_data[(int )Offset];
#line 906
  return;
}
}
#line 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
static void efuse_ShadowRead2Byte(struct rtw_adapter *pAdapter , u16 Offset , u16 *Value ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
#line 915
  pEEPROM = & pAdapter->eeprompriv;
#line 917
  *Value = (u16 )pEEPROM->efuse_eeprom_data[(int )Offset];
#line 918
  *Value = (u16 )((int )((short )*Value) | (int )((short )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 1] << 8)));
#line 919
  return;
}
}
#line 923 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
static void efuse_ShadowRead4Byte(struct rtw_adapter *pAdapter , u16 Offset , u32 *Value ) 
{ 
  struct eeprom_priv *pEEPROM ;

  {
#line 928
  pEEPROM = & pAdapter->eeprompriv;
#line 930
  *Value = (u32 )pEEPROM->efuse_eeprom_data[(int )Offset];
#line 931
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 1] << 8);
#line 932
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 2] << 16);
#line 933
  *Value = *Value | (u32 )((int )pEEPROM->efuse_eeprom_data[(int )Offset + 3] << 24);
#line 934
  return;
}
}
#line 952 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
void EFUSE_ShadowMapUpdate23a(struct rtw_adapter *pAdapter , u8 efuseType ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u16 mapLen ;

  {
#line 954
  pEEPROM = & pAdapter->eeprompriv;
#line 955
  mapLen = 0U;
#line 957
  EFUSE_GetEfuseDefinition23a(pAdapter, (int )efuseType, 4, (void *)(& mapLen));
#line 960
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 1U) {
#line 961
    memset((void *)(& pEEPROM->efuse_eeprom_data), 255, (size_t )mapLen);
  } else {
#line 963
    Efuse_ReadAllMap(pAdapter, (int )efuseType, (u8 *)(& pEEPROM->efuse_eeprom_data));
  }
#line 965
  return;
}
}
#line 985 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
void EFUSE_ShadowRead23a(struct rtw_adapter *pAdapter , u8 Type , u16 Offset , u32 *Value ) 
{ 


  {
#line 991
  if ((unsigned int )Type == 1U) {
#line 992
    efuse_ShadowRead1Byte(pAdapter, (int )Offset, (u8 *)Value);
  } else
#line 993
  if ((unsigned int )Type == 2U) {
#line 994
    efuse_ShadowRead2Byte(pAdapter, (int )Offset, (u16 *)Value);
  } else
#line 995
  if ((unsigned int )Type == 4U) {
#line 996
    efuse_ShadowRead4Byte(pAdapter, (int )Offset, Value);
  } else {

  }
#line 997
  return;
}
}
#line 1126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
void *ldv_kmem_cache_alloc_72(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1129
  ldv_check_alloc_flags(flags);
#line 1131
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1132
  return ((void *)0);
}
}
#line 1170 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
int ldv_pskb_expand_head_78(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1173
  ldv_check_alloc_flags(flags);
#line 1175
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1175
  return (tmp);
}
}
#line 1186 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
struct sk_buff *ldv_skb_clone_80(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1189
  ldv_check_alloc_flags(flags);
#line 1191
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1191
  return (tmp);
}
}
#line 1202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
struct sk_buff *ldv_skb_copy_82(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1205
  ldv_check_alloc_flags(flags);
#line 1207
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1207
  return (tmp);
}
}
#line 1210 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_83(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1213
  ldv_check_alloc_flags(flags);
#line 1215
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1215
  return (tmp);
}
}
#line 1218 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_84(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1221
  ldv_check_alloc_flags(flags);
#line 1223
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1223
  return (tmp);
}
}
#line 1226 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_85(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                          gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1229
  ldv_check_alloc_flags(flags);
#line 1231
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1231
  return (tmp);
}
}
#line 1234 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
int ldv_pskb_expand_head_86(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1237
  ldv_check_alloc_flags(flags);
#line 1239
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1239
  return (tmp);
}
}
#line 1242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
int ldv_pskb_expand_head_87(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                            gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1245
  ldv_check_alloc_flags(flags);
#line 1247
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1247
  return (tmp);
}
}
#line 1250 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_efuse.o.c.prepared"
struct sk_buff *ldv_skb_clone_88(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1253
  ldv_check_alloc_flags(flags);
#line 1255
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1255
  return (tmp);
}
}
#line 186 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 188
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 60 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 179 "include/linux/timer.h"
int ldv_mod_timer_131(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_114(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_122(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_130(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_124(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_120(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_128(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_129(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_125(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_126(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_127(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 3606 "include/net/cfg80211.h"
extern u8 const   *cfg80211_find_ie(u8  , u8 const   * , int  ) ;
#line 55 "drivers/staging/rtl8723au/include/osdep_service.h"
__inline static struct list_head *get_list_head(struct rtw_queue *queue ) 
{ 


  {
#line 57
  return (& queue->queue);
}
}
#line 451 "drivers/staging/rtl8723au/include/ieee80211.h"
u16 rtw_mcs_rate23a(u8 rf_type , u8 bw_40MHz , u8 short_GI_20 , u8 short_GI_40 , unsigned char *MCS_rate ) ;
#line 210 "drivers/staging/rtl8723au/include/hal_com.h"
u8 rtl8723a_get_rf_type(struct rtw_adapter *padapter ) ;
#line 243 "drivers/staging/rtl8723au/include/rtw_mlme.h"
int rtw_select_and_join_from_scanned_queue23a(struct mlme_priv *pmlmepriv ) ;
#line 246
int rtw_set_auth23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ) ;
#line 263 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static int get_fwstate(struct mlme_priv *pmlmepriv ) 
{ 


  {
#line 265
  return (pmlmepriv->fw_state);
}
}
#line 315
void rtw_generate_random_ibss23a(u8 *pibss ) ;
#line 319
void rtw_free_assoc_resources23a(struct rtw_adapter *adapter , int lock_scanned_queue ) ;
#line 321
void rtw_indicate_disconnect23a(struct rtw_adapter *padapter ) ;
#line 331
void rtw_update_registrypriv_dev_network23a(struct rtw_adapter *adapter ) ;
#line 338
extern bool rtw_is_scan_deny(struct rtw_adapter * ) ;
#line 366
int rtw_is_same_ibss23a(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) ;
#line 20 "drivers/staging/rtl8723au/include/rtw_ioctl_set.h"
int rtw_set_802_11_authentication_mode23a(struct rtw_adapter *padapter , enum ndis_802_11_auth_mode authmode ) ;
#line 22
int rtw_set_802_11_bssid23a_list_scan(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                      int ssid_max_num ) ;
#line 25
int rtw_set_802_11_ssid23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ) ;
#line 28
u16 rtw_get_cur_max_rate23a(struct rtw_adapter *adapter ) ;
#line 30
int rtw_do_join23a(struct rtw_adapter *padapter ) ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
int rtw_do_join23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  u8 *pibss ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *queue ;
  int ret ;
  int select_ret ;
  unsigned long tmp ;
  struct wlan_bssid_ex *pdev_network ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 246
  pibss = (u8 *)0U;
#line 247
  pmlmepriv = & padapter->mlmepriv;
#line 248
  queue = & pmlmepriv->scanned_queue;
#line 249
  ret = 1;
#line 251
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 252
  phead = get_list_head(queue);
#line 253
  plist = phead->next;
#line 255
  if (GlobalDebugLevel23A > 6U) {
#line 255
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 255
    printk("\016\n rtw_do_join23a: phead = %p; plist = %p\n\n\n", phead, plist);
  } else {

  }
#line 259
  pmlmepriv->cur_network.join_res = -2;
#line 261
  set_fwstate(pmlmepriv, 128);
#line 263
  pmlmepriv->to_join = 1U;
#line 265
  tmp___2 = list_empty((struct list_head  const  *)(& queue->queue));
#line 265
  if (tmp___2 != 0) {
#line 266
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 267
    _clr_fwstate_(pmlmepriv, 128);
#line 273
    if (! pmlmepriv->LinkDetectInfo.bBusyTraffic || (unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 275
      if (GlobalDebugLevel23A > 6U) {
#line 275
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 275
        printk("\016rtw_do_join23a(): site survey if scanned_queue is empty\n.");
      } else {

      }
#line 279
      ret = rtw_sitesurvey_cmd23a(padapter, & pmlmepriv->assoc_ssid, 1, (struct rtw_ieee80211_channel *)0,
                                  0);
#line 282
      if (ret != 1) {
#line 283
        pmlmepriv->to_join = 0U;
#line 284
        if (GlobalDebugLevel23A > 3U) {
#line 284
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 284
          printk("\016rtw_do_join23a(): site survey return error\n.");
        } else {

        }
      } else {

      }
    } else {
#line 289
      pmlmepriv->to_join = 0U;
#line 290
      ret = 0;
    }
#line 293
    goto exit;
  } else {
#line 296
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 297
    select_ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
#line 298
    if (select_ret == 1) {
#line 299
      pmlmepriv->to_join = 0U;
#line 300
      tmp = msecs_to_jiffies(6500U);
#line 300
      ldv_mod_timer_131(& pmlmepriv->assoc_timer, tmp + (unsigned long )jiffies);
    } else {
#line 303
      tmp___1 = check_fwstate(pmlmepriv, 32);
#line 303
      if ((int )tmp___1) {
#line 310
        pdev_network = & padapter->registrypriv.dev_network;
#line 313
        pmlmepriv->fw_state = 64;
#line 315
        pibss = (u8 *)(& padapter->registrypriv.dev_network.MacAddress);
#line 317
        __len = 33UL;
#line 317
        if (__len > 63UL) {
#line 317
          __ret = __memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pmlmepriv->assoc_ssid),
                           __len);
        } else {
#line 317
          __ret = __builtin_memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pmlmepriv->assoc_ssid),
                                   __len);
        }
#line 321
        rtw_update_registrypriv_dev_network23a(padapter);
#line 323
        rtw_generate_random_ibss23a(pibss);
#line 325
        tmp___0 = rtw_createbss_cmd23a(padapter);
#line 325
        if (tmp___0 != 1) {
#line 326
          if (GlobalDebugLevel23A > 3U) {
#line 326
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 326
            printk("\016***Error =>do_goin: rtw_createbss_cmd status FAIL***\n");
          } else {

          }
#line 330
          ret = 0;
#line 331
          goto exit;
        } else {

        }
#line 334
        pmlmepriv->to_join = 0U;
#line 336
        if (GlobalDebugLevel23A > 6U) {
#line 336
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 336
          printk("\016***Error => rtw_select_and_join_from_scanned_queue FAIL under STA_Mode***\n ");
        } else {

        }
      } else {
#line 343
        _clr_fwstate_(pmlmepriv, 128);
#line 349
        if (! pmlmepriv->LinkDetectInfo.bBusyTraffic || (unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 354
          ret = rtw_sitesurvey_cmd23a(padapter, & pmlmepriv->assoc_ssid, 1, (struct rtw_ieee80211_channel *)0,
                                      0);
#line 355
          if (ret != 1) {
#line 356
            pmlmepriv->to_join = 0U;
#line 357
            if (GlobalDebugLevel23A > 3U) {
#line 357
              printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 357
              printk("\016do_join(): site survey return error\n.");
            } else {

            }
          } else {

          }
        } else {
#line 360
          ret = 0;
#line 361
          pmlmepriv->to_join = 0U;
        }
      }
    }
  }
  exit: ;
#line 369
  return (ret);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
int rtw_set_802_11_ssid23a(struct rtw_adapter *padapter , struct cfg80211_ssid *ssid ) 
{ 
  int status ;
  u32 cur_time ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  bool tmp___12 ;
  size_t __len ;
  void *__ret ;
  bool tmp___13 ;

  {
#line 375
  status = 1;
#line 376
  cur_time = 0U;
#line 378
  pmlmepriv = & padapter->mlmepriv;
#line 379
  pnetwork = & pmlmepriv->cur_network;
#line 383
  if (GlobalDebugLevel23A != 0U) {
#line 383
    tmp = get_fwstate(pmlmepriv);
#line 383
    printk("\016RTL8723AU: OLD_ERROR set ssid [%s] fw_state = 0x%08x\n", (u8 *)(& ssid->ssid),
           tmp);
  } else {

  }
#line 386
  if ((unsigned int )padapter->hw_init_completed == 0U) {
#line 387
    if (GlobalDebugLevel23A > 3U) {
#line 387
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 387
      printk("\016set_ssid: hw_init_completed == false =>exit!!!\n");
    } else {

    }
#line 389
    status = 0;
#line 390
    goto exit;
  } else {

  }
#line 393
  spin_lock_bh(& pmlmepriv->lock);
#line 395
  if (GlobalDebugLevel23A > 3U) {
#line 395
    tmp___0 = get_fwstate(pmlmepriv);
#line 395
    printk("\016RTL8723AU: Set SSID under fw_state = 0x%08x\n", tmp___0);
  } else {

  }
#line 396
  tmp___2 = check_fwstate(pmlmepriv, 2048);
#line 396
  if ((int )tmp___2) {
#line 397
    goto handle_tkip_countermeasure;
  } else {
#line 398
    tmp___1 = check_fwstate(pmlmepriv, 128);
#line 398
    if ((int )tmp___1) {
#line 399
      goto release_mlme_lock;
    } else {

    }
  }
#line 401
  tmp___12 = check_fwstate(pmlmepriv, 65);
#line 401
  if ((int )tmp___12) {
#line 402
    if (GlobalDebugLevel23A > 6U) {
#line 402
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 402
      printk("\016set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n");
    } else {

    }
#line 405
    if ((int )pmlmepriv->assoc_ssid.ssid_len == (int )ssid->ssid_len) {
#line 405
      tmp___11 = memcmp((void const   *)(& pmlmepriv->assoc_ssid.ssid), (void const   *)(& ssid->ssid),
                        (size_t )ssid->ssid_len);
#line 405
      if (tmp___11 == 0) {
#line 408
        tmp___7 = check_fwstate(pmlmepriv, 8);
#line 408
        if (tmp___7) {
#line 408
          tmp___8 = 0;
        } else {
#line 408
          tmp___8 = 1;
        }
#line 408
        if (tmp___8) {
#line 409
          if (GlobalDebugLevel23A > 3U) {
#line 409
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 409
            tmp___3 = get_fwstate(pmlmepriv);
#line 409
            printk("\016Set SSID is the same ssid, fw_state = 0x%08x\n", tmp___3);
          } else {

          }
#line 413
          tmp___6 = rtw_is_same_ibss23a(padapter, pnetwork);
#line 413
          if (tmp___6 == 0) {
#line 416
            rtw_disassoc_cmd23a(padapter, 0U, 1);
#line 418
            tmp___4 = check_fwstate(pmlmepriv, 1);
#line 418
            if ((int )tmp___4) {
#line 419
              rtw_indicate_disconnect23a(padapter);
            } else {

            }
#line 421
            rtw_free_assoc_resources23a(padapter, 1);
#line 423
            tmp___5 = check_fwstate(pmlmepriv, 64);
#line 423
            if ((int )tmp___5) {
#line 424
              _clr_fwstate_(pmlmepriv, 64);
#line 425
              set_fwstate(pmlmepriv, 32);
            } else {

            }
          } else {
#line 428
            goto release_mlme_lock;
          }
        } else {
#line 431
          rtw_lps_ctrl_wk_cmd23a(padapter, 1, 1);
        }
      } else {
#line 405
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 434
      if (GlobalDebugLevel23A > 6U) {
#line 434
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 434
        printk("\016Set SSID not the same ssid\n");
      } else {

      }
#line 436
      if (GlobalDebugLevel23A > 6U) {
#line 436
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 436
        printk("\016set_ssid =[%s] len = 0x%x\n", (u8 *)(& ssid->ssid), (unsigned int )ssid->ssid_len);
      } else {

      }
#line 439
      if (GlobalDebugLevel23A > 6U) {
#line 439
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 439
        printk("\016assoc_ssid =[%s] len = 0x%x\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid),
               (unsigned int )pmlmepriv->assoc_ssid.ssid_len);
      } else {

      }
#line 444
      rtw_disassoc_cmd23a(padapter, 0U, 1);
#line 446
      tmp___9 = check_fwstate(pmlmepriv, 1);
#line 446
      if ((int )tmp___9) {
#line 447
        rtw_indicate_disconnect23a(padapter);
      } else {

      }
#line 449
      rtw_free_assoc_resources23a(padapter, 1);
#line 451
      tmp___10 = check_fwstate(pmlmepriv, 64);
#line 451
      if ((int )tmp___10) {
#line 452
        _clr_fwstate_(pmlmepriv, 64);
#line 453
        set_fwstate(pmlmepriv, 32);
      } else {

      }
    }
  } else {

  }
  handle_tkip_countermeasure: ;
#line 460
  if ((unsigned int )padapter->securitypriv.btkip_countermeasure == 1U) {
#line 461
    cur_time = (u32 )jiffies;
#line 463
    if ((unsigned long )cur_time - padapter->securitypriv.btkip_countermeasure_time > 15000UL) {
#line 465
      padapter->securitypriv.btkip_countermeasure = 0U;
#line 466
      padapter->securitypriv.btkip_countermeasure_time = 0UL;
    } else {
#line 470
      status = 0;
#line 471
      goto release_mlme_lock;
    }
  } else {

  }
#line 475
  __len = 33UL;
#line 475
  if (__len > 63UL) {
#line 475
    __ret = __memcpy((void *)(& pmlmepriv->assoc_ssid), (void const   *)ssid, __len);
  } else {
#line 475
    __ret = __builtin_memcpy((void *)(& pmlmepriv->assoc_ssid), (void const   *)ssid,
                             __len);
  }
#line 476
  pmlmepriv->assoc_by_bssid = 0U;
#line 478
  tmp___13 = check_fwstate(pmlmepriv, 2048);
#line 478
  if ((int )tmp___13) {
#line 479
    pmlmepriv->to_join = 1U;
  } else {
#line 481
    status = rtw_do_join23a(padapter);
  }
  release_mlme_lock: 
#line 484
  spin_unlock_bh(& pmlmepriv->lock);
  exit: ;
#line 487
  if (GlobalDebugLevel23A > 3U) {
#line 487
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 487
    printk("\016-rtw_set_802_11_ssid23a: status =%d\n", status);
  } else {

  }
#line 492
  return (status);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
int rtw_set_802_11_bssid23a_list_scan(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                      int ssid_max_num ) 
{ 
  struct mlme_priv *pmlmepriv ;
  int res ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 499
  pmlmepriv = & padapter->mlmepriv;
#line 500
  res = 1;
#line 502
  if (GlobalDebugLevel23A > 3U) {
#line 502
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 502
    tmp = get_fwstate(pmlmepriv);
#line 502
    printk("\016+rtw_set_802_11_bssid23a_list_scan(), fw_state =%x\n", tmp);
  } else {

  }
#line 506
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 507
    res = 0;
#line 508
    goto exit;
  } else {

  }
#line 510
  if ((unsigned int )padapter->hw_init_completed == 0U) {
#line 511
    res = 0;
#line 512
    if (GlobalDebugLevel23A > 3U) {
#line 512
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 512
      printk("\016\n === rtw_set_802_11_bssid23a_list_scan:hw_init_completed == false ===\n");
    } else {

    }
#line 515
    goto exit;
  } else {

  }
#line 518
  tmp___3 = check_fwstate(pmlmepriv, 2176);
#line 518
  if ((int )tmp___3 || (int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
#line 521
    if (GlobalDebugLevel23A > 3U) {
#line 521
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 521
      tmp___0 = get_fwstate(pmlmepriv);
#line 521
      printk("\016rtw_set_802_11_bssid23a_list_scan fail since fw_state = %x\n", tmp___0);
    } else {

    }
#line 525
    tmp___1 = check_fwstate(pmlmepriv, 2176);
#line 525
    if ((int )tmp___1) {
#line 527
      if (GlobalDebugLevel23A > 3U) {
#line 527
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 527
        printk("\016\n###_FW_UNDER_SURVEY|_FW_UNDER_LINKING\n");
      } else {

      }
    } else
#line 530
    if (GlobalDebugLevel23A > 3U) {
#line 530
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 530
      printk("\016\n###pmlmepriv->sitesurveyctrl.traffic_busy == true\n");
    } else {

    }
  } else {
#line 535
    tmp___2 = rtw_is_scan_deny(padapter);
#line 535
    if ((int )tmp___2) {
#line 536
      if (GlobalDebugLevel23A > 3U) {
#line 536
        printk("\016RTL8723AU: %s(%s): scan deny\n", "rtw_set_802_11_bssid23a_list_scan",
               (char *)(& (padapter->pnetdev)->name));
      } else {

      }
#line 538
      return (1);
    } else {

    }
#line 541
    spin_lock_bh(& pmlmepriv->lock);
#line 543
    res = rtw_sitesurvey_cmd23a(padapter, pssid, ssid_max_num, (struct rtw_ieee80211_channel *)0,
                                0);
#line 546
    spin_unlock_bh(& pmlmepriv->lock);
  }
  exit: ;
#line 549
  return (res);
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
int rtw_set_802_11_authentication_mode23a(struct rtw_adapter *padapter , enum ndis_802_11_auth_mode authmode ) 
{ 
  struct security_priv *psecuritypriv ;
  int res ;

  {
#line 555
  psecuritypriv = & padapter->securitypriv;
#line 558
  if (GlobalDebugLevel23A > 6U) {
#line 558
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 558
    printk("\016set_802_11_auth.mode(): mode =%x\n", (unsigned int )authmode);
  } else {

  }
#line 561
  psecuritypriv->ndisauthtype = (u32 )authmode;
#line 563
  if (GlobalDebugLevel23A > 6U) {
#line 563
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 563
    printk("\016rtw_set_802_11_authentication_mode23a:psecuritypriv->ndisauthtype =%d",
           psecuritypriv->ndisauthtype);
  } else {

  }
#line 568
  if (psecuritypriv->ndisauthtype > 3U) {
#line 569
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else {

  }
#line 571
  res = rtw_set_auth23a(padapter, psecuritypriv);
#line 573
  return (res);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
u16 rtw_get_cur_max_rate23a(struct rtw_adapter *adapter ) 
{ 
  int i ;
  u8 const   *p ;
  u16 rate ;
  u16 max_rate ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct registry_priv *pregistrypriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_bss ;
  struct ieee80211_ht_cap *pht_capie ;
  u8 rf_type ;
  u8 bw_40MHz ;
  u8 short_GI_20 ;
  u8 short_GI_40 ;
  u16 mcs_rate ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  size_t __len ;
  void *__ret ;

  {
#line 584
  i = 0;
#line 586
  rate = 0U;
#line 586
  max_rate = 0U;
#line 587
  pmlmeext = & adapter->mlmeextpriv;
#line 588
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 589
  pregistrypriv = & adapter->registrypriv;
#line 590
  pmlmepriv = & adapter->mlmepriv;
#line 591
  pcur_bss = & pmlmepriv->cur_network.network;
#line 593
  rf_type = 0U;
#line 594
  bw_40MHz = 0U;
#line 594
  short_GI_20 = 0U;
#line 594
  short_GI_40 = 0U;
#line 595
  mcs_rate = 0U;
#line 597
  tmp = check_fwstate(pmlmepriv, 1);
#line 597
  if (tmp) {
#line 597
    tmp___0 = 0;
  } else {
#line 597
    tmp___0 = 1;
  }
#line 597
  if (tmp___0) {
#line 597
    tmp___1 = check_fwstate(pmlmepriv, 64);
#line 597
    if (tmp___1) {
#line 597
      tmp___2 = 0;
    } else {
#line 597
      tmp___2 = 1;
    }
#line 597
    if (tmp___2) {
#line 599
      return (0U);
    } else {

    }
  } else {

  }
#line 601
  if (((int )pmlmeext->cur_wireless_mode & 24) != 0) {
#line 602
    p = cfg80211_find_ie(45, (u8 const   *)(& pcur_bss->IEs) + 12U, (int )(pcur_bss->IELength - 12U));
#line 605
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 606
      pht_capie = (struct ieee80211_ht_cap *)p + 2U;
#line 608
      __len = 2UL;
#line 608
      if (__len > 63UL) {
#line 608
        __ret = __memcpy((void *)(& mcs_rate), (void const   *)(& pht_capie->mcs),
                         __len);
      } else {
#line 608
        __ret = __builtin_memcpy((void *)(& mcs_rate), (void const   *)(& pht_capie->mcs),
                                 __len);
      }
#line 614
      bw_40MHz = (u8 )((unsigned int )pmlmeext->cur_bwmode != 0U && ((unsigned int )pmlmeinfo->HT_info.infos[0] & 4U) != 0U);
#line 620
      short_GI_20 = ((int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 32) != 0;
#line 621
      short_GI_40 = ((int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 64) != 0;
#line 623
      rf_type = rtl8723a_get_rf_type(adapter);
#line 624
      max_rate = rtw_mcs_rate23a((int )rf_type, (int )pregistrypriv->cbw40_enable & (int )bw_40MHz,
                                 (int )short_GI_20, (int )short_GI_40, (unsigned char *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate));
    } else {

    }
  } else {
#line 631
    goto ldv_51560;
    ldv_51559: 
#line 633
    rate = (unsigned int )((u16 )pcur_bss->SupportedRates[i]) & 127U;
#line 634
    if ((int )rate > (int )max_rate) {
#line 635
      max_rate = rate;
    } else {

    }
#line 636
    i = i + 1;
    ldv_51560: ;
#line 631
    if ((unsigned int )pcur_bss->SupportedRates[i] != 0U && (unsigned int )pcur_bss->SupportedRates[i] != 255U) {
#line 634
      goto ldv_51559;
    } else {

    }
#line 639
    max_rate = (u16 )(((int )max_rate * 10) / 2);
  }
#line 642
  return (max_rate);
}
}
#line 772 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
void *ldv_kmem_cache_alloc_114(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 775
  ldv_check_alloc_flags(flags);
#line 777
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 778
  return ((void *)0);
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
int ldv_pskb_expand_head_120(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 819
  ldv_check_alloc_flags(flags);
#line 821
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 821
  return (tmp);
}
}
#line 832 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
struct sk_buff *ldv_skb_clone_122(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 835
  ldv_check_alloc_flags(flags);
#line 837
  tmp = skb_clone(ldv_func_arg1, flags);
#line 837
  return (tmp);
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
struct sk_buff *ldv_skb_copy_124(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 851
  ldv_check_alloc_flags(flags);
#line 853
  tmp = skb_copy(ldv_func_arg1, flags);
#line 853
  return (tmp);
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_125(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 859
  ldv_check_alloc_flags(flags);
#line 861
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 861
  return (tmp);
}
}
#line 864 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_126(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 867
  ldv_check_alloc_flags(flags);
#line 869
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 869
  return (tmp);
}
}
#line 872 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_127(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 875
  ldv_check_alloc_flags(flags);
#line 877
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 877
  return (tmp);
}
}
#line 880 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
int ldv_pskb_expand_head_128(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 883
  ldv_check_alloc_flags(flags);
#line 885
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 885
  return (tmp);
}
}
#line 888 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
int ldv_pskb_expand_head_129(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 891
  ldv_check_alloc_flags(flags);
#line 893
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 893
  return (tmp);
}
}
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
struct sk_buff *ldv_skb_clone_130(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 899
  ldv_check_alloc_flags(flags);
#line 901
  tmp = skb_clone(ldv_func_arg1, flags);
#line 901
  return (tmp);
}
}
#line 904 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ioctl_set.o.c.prepared"
int ldv_mod_timer_131(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 908
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 908
  ldv_func_res = tmp;
#line 910
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 912
  return (ldv_func_res);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 154 "include/uapi/linux/swab.h"
__inline static __u16 __swab16p(__u16 const   *p ) 
{ 
  __u16 tmp ;

  {
#line 159
  tmp = __fswab16((int )*p);
#line 159
  return (tmp);
}
}
#line 63 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __le16_to_cpup(__le16 const   *p ) 
{ 


  {
#line 65
  return ((__u16 )*p);
}
}
#line 87 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ 
  __u16 tmp ;

  {
#line 89
  tmp = __swab16p(p);
#line 89
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_158(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_166(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_174(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_168(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_164(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_173(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_169(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_170(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_171(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 7 "include/linux/unaligned/access_ok.h"
__inline static u16 get_unaligned_le16(void const   *p ) 
{ 
  __u16 tmp ;

  {
#line 9
  tmp = __le16_to_cpup((__le16 const   *)p);
#line 9
  return (tmp);
}
}
#line 22 "include/linux/unaligned/access_ok.h"
__inline static u16 get_unaligned_be16(void const   *p ) 
{ 
  __u16 tmp ;

  {
#line 24
  tmp = __be16_to_cpup((__be16 const   *)p);
#line 24
  return (tmp);
}
}
#line 3624 "include/net/cfg80211.h"
extern u8 const   *cfg80211_find_vendor_ie(unsigned int  , u8  , u8 const   * , int  ) ;
#line 68 "drivers/staging/rtl8723au/include/ieee80211.h"
u8 RTW_WPA_OUI23A_TYPE[4U] ;
#line 69
u16 RTW_WPA_VERSION23A ;
#line 70
u8 WPA_AUTH_KEY_MGMT_NONE23A[4U] ;
#line 71
u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] ;
#line 72
u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] ;
#line 73
u8 WPA_CIPHER_SUITE_NONE23A[4U] ;
#line 74
u8 WPA_CIPHER_SUITE_WEP4023A[4U] ;
#line 75
u8 WPA_CIPHER_SUITE_TKIP23A[4U] ;
#line 76
u8 WPA_CIPHER_SUITE_WRAP23A[4U] ;
#line 77
u8 WPA_CIPHER_SUITE_CCMP23A[4U] ;
#line 78
u8 WPA_CIPHER_SUITE_WEP10423A[4U] ;
#line 84
u16 RSN_VERSION_BSD23A ;
#line 85
u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U] ;
#line 86
u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U] ;
#line 87
u8 RSN_CIPHER_SUITE_NONE23A[4U] ;
#line 88
u8 RSN_CIPHER_SUITE_WEP4023A[4U] ;
#line 89
u8 RSN_CIPHER_SUITE_TKIP23A[4U] ;
#line 90
u8 RSN_CIPHER_SUITE_WRAP23A[4U] ;
#line 91
u8 RSN_CIPHER_SUITE_CCMP23A[4U] ;
#line 92
u8 RSN_CIPHER_SUITE_WEP10423A[4U] ;
#line 410
u8 *rtw_set_fixed_ie23a(unsigned char *pbuf , unsigned int len , unsigned char *source ,
                        unsigned int *frlen ) ;
#line 411
u8 *rtw_set_ie23a(u8 *pbuf , int index , uint len , u8 const   *source , uint *frlen ) ;
#line 422
u8 *rtw_get_ie23a(u8 *pbuf , int index , int *len , int limit ) ;
#line 423
u8 *rtw_get_ie23a_ex(u8 *in_ie , uint in_len , u8 eid , u8 *oui , u8 oui_len , u8 *ie ,
                     uint *ielen ) ;
#line 424
int rtw_ies_remove_ie23a(u8 *ies , uint *ies_len , uint offset , u8 eid , u8 *oui ,
                         u8 oui_len ) ;
#line 426
void rtw_set_supported_rate23a(u8 *SupportedRates , uint mode ) ;
#line 428
int rtw_get_wpa_cipher_suite23a(u8 const   *s ) ;
#line 429
int rtw_get_wpa2_cipher_suite23a(u8 const   *s ) ;
#line 430
int rtw_parse_wpa_ie23a(u8 const   *wpa_ie , int wpa_ie_len , int *group_cipher ,
                        int *pairwise_cipher , int *is_8021x ) ;
#line 431
int rtw_parse_wpa2_ie23a(u8 const   *rsn_ie , int rsn_ie_len , int *group_cipher ,
                         int *pairwise_cipher , int *is_8021x ) ;
#line 433
int rtw_get_sec_ie23a(u8 *in_ie , uint in_len , u8 *rsn_ie , u16 *rsn_len , u8 *wpa_ie ,
                      u16 *wpa_len ) ;
#line 435
u8 *rtw_get_wps_ie23a(u8 *in_ie , uint in_len , u8 *wps_ie , uint *wps_ielen ) ;
#line 436
u8 *rtw_get_wps_attr23a(u8 *wps_ie , uint wps_ielen , u16 target_attr_id , u8 *buf_attr ,
                        u32 *len_attr ) ;
#line 437
u8 *rtw_get_wps_attr_content23a(u8 *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                u8 *buf_content , uint *len_content ) ;
#line 439
uint rtw_get_rateset_len23a(u8 *rateset ) ;
#line 442
int rtw_generate_ie23a(struct registry_priv *pregistrypriv ) ;
#line 445
int rtw_get_bit_value_from_ieee_value23a(u8 val ) ;
#line 447
int rtw_check_network_type23a(unsigned char *rate , int ratelen , int channel ) ;
#line 449
void rtw_get_bcn_info23a(struct wlan_network *pnetwork ) ;
#line 453
char const   *action_public_str23a(u8 action ) ;
#line 353 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__le16 *rtw_get_capability23a_from_ie(u8 *ie ) ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 RTW_WPA_OUI23A_TYPE[4U]  = {      0U,      80U,      242U,      1U};
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u16 RTW_WPA_VERSION23A  =    1U;
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 WPA_AUTH_KEY_MGMT_NONE23A[4U]  = {      0U,      80U,      242U,      0U};
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U]  = {      0U,      80U,      242U,      1U};
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U]  = {      0U,      80U,      242U,      2U};
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 WPA_CIPHER_SUITE_NONE23A[4U]  = {      0U,      80U,      242U,      0U};
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 WPA_CIPHER_SUITE_WEP4023A[4U]  = {      0U,      80U,      242U,      1U};
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 WPA_CIPHER_SUITE_TKIP23A[4U]  = {      0U,      80U,      242U,      2U};
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 WPA_CIPHER_SUITE_WRAP23A[4U]  = {      0U,      80U,      242U,      3U};
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 WPA_CIPHER_SUITE_CCMP23A[4U]  = {      0U,      80U,      242U,      4U};
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 WPA_CIPHER_SUITE_WEP10423A[4U]  = {      0U,      80U,      242U,      5U};
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u16 RSN_VERSION_BSD23A  =    1U;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X23A[4U]  = {      0U,      15U,      172U,      1U};
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X23A[4U]  = {      0U,      15U,      172U,      2U};
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 RSN_CIPHER_SUITE_NONE23A[4U]  = {      0U,      15U,      172U,      0U};
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 RSN_CIPHER_SUITE_WEP4023A[4U]  = {      0U,      15U,      172U,      1U};
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 RSN_CIPHER_SUITE_TKIP23A[4U]  = {      0U,      15U,      172U,      2U};
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 RSN_CIPHER_SUITE_WRAP23A[4U]  = {      0U,      15U,      172U,      3U};
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 RSN_CIPHER_SUITE_CCMP23A[4U]  = {      0U,      15U,      172U,      4U};
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 RSN_CIPHER_SUITE_WEP10423A[4U]  = {      0U,      15U,      172U,      5U};
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
static u8 WIFI_CCKRATES[4U]  = {      130U,      132U,      139U,      150U};
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
static u8 WIFI_OFDMRATES[8U]  = 
#line 274
  {      12U,      18U,      24U,      36U, 
        48U,      72U,      96U,      108U};
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int rtw_get_bit_value_from_ieee_value23a(u8 val ) 
{ 
  unsigned char dot11_rate_table[13U] ;
  int i ;

  {
#line 287
  dot11_rate_table[0] = 2U;
#line 287
  dot11_rate_table[1] = 4U;
#line 287
  dot11_rate_table[2] = 11U;
#line 287
  dot11_rate_table[3] = 22U;
#line 287
  dot11_rate_table[4] = 12U;
#line 287
  dot11_rate_table[5] = 18U;
#line 287
  dot11_rate_table[6] = 24U;
#line 287
  dot11_rate_table[7] = 36U;
#line 287
  dot11_rate_table[8] = 48U;
#line 287
  dot11_rate_table[9] = 72U;
#line 287
  dot11_rate_table[10] = 96U;
#line 287
  dot11_rate_table[11] = 108U;
#line 287
  dot11_rate_table[12] = 0U;
#line 290
  i = 0;
#line 291
  goto ldv_51435;
  ldv_51434: ;
#line 292
  if ((int )dot11_rate_table[i] == (int )val) {
#line 293
    return ((int )(1UL << i));
  } else {

  }
#line 294
  i = i + 1;
  ldv_51435: ;
#line 291
  if ((unsigned int )dot11_rate_table[i] != 0U) {
#line 293
    goto ldv_51434;
  } else {

  }

#line 296
  return (0);
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
static bool rtw_is_cckrates_included(u8 *rate ) 
{ 
  u32 i ;

  {
#line 301
  i = 0U;
#line 303
  goto ldv_51442;
  ldv_51441: ;
#line 304
  if (((((int )*(rate + (unsigned long )i) & 127) == 2 || ((int )*(rate + (unsigned long )i) & 127) == 4) || ((int )*(rate + (unsigned long )i) & 127) == 11) || ((int )*(rate + (unsigned long )i) & 127) == 22) {
#line 306
    return (1);
  } else {

  }
#line 307
  i = i + 1U;
  ldv_51442: ;
#line 303
  if ((unsigned int )*(rate + (unsigned long )i) != 0U) {
#line 305
    goto ldv_51441;
  } else {

  }

#line 310
  return (0);
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
static bool rtw_is_cckratesonly_included(u8 *rate ) 
{ 
  u32 i ;

  {
#line 315
  i = 0U;
#line 317
  goto ldv_51449;
  ldv_51448: ;
#line 318
  if (((((int )*(rate + (unsigned long )i) & 127) != 2 && ((int )*(rate + (unsigned long )i) & 127) != 4) && ((int )*(rate + (unsigned long )i) & 127) != 11) && ((int )*(rate + (unsigned long )i) & 127) != 22) {
#line 320
    return (0);
  } else {

  }
#line 322
  i = i + 1U;
  ldv_51449: ;
#line 317
  if ((unsigned int )*(rate + (unsigned long )i) != 0U) {
#line 319
    goto ldv_51448;
  } else {

  }

#line 325
  return (1);
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int rtw_check_network_type23a(unsigned char *rate , int ratelen , int channel ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 330
  if (channel > 14) {
#line 331
    tmp = rtw_is_cckrates_included(rate);
#line 331
    if ((int )tmp) {
#line 332
      return (0);
    } else {
#line 334
      return (4);
    }
  } else {
#line 336
    tmp___1 = rtw_is_cckratesonly_included(rate);
#line 336
    if ((int )tmp___1) {
#line 337
      return (1);
    } else {
#line 338
      tmp___0 = rtw_is_cckrates_included(rate);
#line 338
      if ((int )tmp___0) {
#line 339
        return (3);
      } else {
#line 341
        return (2);
      }
    }
  }
}
}
#line 345 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 *rtw_set_fixed_ie23a(unsigned char *pbuf , unsigned int len , unsigned char *source ,
                        unsigned int *frlen ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 348
  __len = (size_t )len;
#line 348
  __ret = __builtin_memcpy((void *)pbuf, (void const   *)source, __len);
#line 349
  *frlen = *frlen + len;
#line 350
  return (pbuf + (unsigned long )len);
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 *rtw_set_ie23a(u8 *pbuf , int index , uint len , u8 const   *source , uint *frlen ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 357
  *pbuf = (unsigned char )index;
#line 359
  *(pbuf + 1UL) = (unsigned char )len;
#line 361
  if (len != 0U) {
#line 362
    __len = (size_t )len;
#line 362
    __ret = __builtin_memcpy((void *)pbuf + 2U, (void const   *)source, __len);
  } else {

  }
#line 364
  *frlen = (*frlen + len) + 2U;
#line 366
  return (pbuf + ((unsigned long )len + 2UL));
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 *rtw_get_ie23a(u8 *pbuf , int index , int *len , int limit ) 
{ 
  int tmp ;
  int i ;
  u8 *p ;

  {
#line 407
  if (limit <= 0) {
#line 409
    return ((u8 *)0U);
  } else {

  }
#line 412
  p = pbuf;
#line 413
  i = 0;
#line 414
  *len = 0;
  ldv_51501: ;
#line 416
  if ((int )*p == index) {
#line 417
    *len = (int )*(p + 1UL);
#line 418
    return (p);
  } else {
#line 420
    tmp = (int )*(p + 1UL);
#line 421
    p = p + ((unsigned long )tmp + 2UL);
#line 422
    i = (tmp + 2) + i;
  }
#line 424
  if (i >= limit) {
#line 425
    goto ldv_51500;
  } else {

  }
#line 426
  goto ldv_51501;
  ldv_51500: ;
#line 428
  return ((u8 *)0U);
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 *rtw_get_ie23a_ex(u8 *in_ie , uint in_len , u8 eid , u8 *oui , u8 oui_len , u8 *ie ,
                     uint *ielen ) 
{ 
  uint cnt ;
  u8 *target_ie ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 449
  target_ie = (u8 *)0U;
#line 451
  if ((unsigned long )ielen != (unsigned long )((uint *)0U)) {
#line 452
    *ielen = 0U;
  } else {

  }
#line 454
  if ((unsigned long )in_ie == (unsigned long )((u8 *)0U) || in_len == 0U) {
#line 455
    return (target_ie);
  } else {

  }
#line 457
  cnt = 0U;
#line 459
  goto ldv_51518;
  ldv_51517: ;
#line 460
  if ((int )*(in_ie + (unsigned long )cnt) == (int )eid) {
#line 460
    if ((unsigned long )oui == (unsigned long )((u8 *)0U)) {
#line 460
      goto _L;
    } else {
#line 460
      tmp = memcmp((void const   *)in_ie + (unsigned long )(cnt + 2U), (void const   *)oui,
                   (size_t )oui_len);
#line 460
      if (tmp == 0) {
        _L: /* CIL Label */ 
#line 462
        target_ie = in_ie + (unsigned long )cnt;
#line 464
        if ((unsigned long )ie != (unsigned long )((u8 *)0U)) {
#line 465
          __len = (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
#line 465
          __ret = __builtin_memcpy((void *)ie, (void const   *)in_ie + (unsigned long )cnt,
                                   __len);
        } else {

        }
#line 467
        if ((unsigned long )ielen != (unsigned long )((uint *)0U)) {
#line 468
          *ielen = (uint )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
        } else {

        }
#line 469
        goto ldv_51516;
      } else {
#line 471
        cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
      }
    }
  } else {
#line 471
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  }
  ldv_51518: ;
#line 459
  if (cnt < in_len) {
#line 461
    goto ldv_51517;
  } else {

  }
  ldv_51516: ;
#line 475
  return (target_ie);
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int rtw_ies_remove_ie23a(u8 *ies , uint *ies_len , uint offset , u8 eid , u8 *oui ,
                         u8 oui_len ) 
{ 
  int ret ;
  u8 *target_ie ;
  u32 target_ielen ;
  u8 *start ;
  uint search_len ;
  u8 buf[768U] ;
  unsigned int tmp ;
  u8 *remain_ies ;
  uint remain_len ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 492
  ret = 0;
#line 498
  if (((unsigned long )ies == (unsigned long )((u8 *)0U) || (unsigned long )ies_len == (unsigned long )((uint *)0U)) || *ies_len <= offset) {
#line 499
    goto exit;
  } else {

  }
#line 501
  start = ies + (unsigned long )offset;
#line 502
  search_len = *ies_len - offset;
  ldv_51543: 
#line 505
  target_ie = rtw_get_ie23a_ex(start, search_len, (int )eid, oui, (int )oui_len, (u8 *)0U,
                               & target_ielen);
#line 507
  if ((unsigned long )target_ie != (unsigned long )((u8 *)0U) && target_ielen != 0U) {
#line 508
    buf[0] = 0U;
#line 508
    tmp = 1U;
#line 508
    while (1) {
#line 508
      if (tmp >= 768U) {
#line 508
        break;
      } else {

      }
#line 508
      buf[tmp] = (unsigned char)0;
#line 508
      tmp = tmp + 1U;
    }
#line 509
    remain_ies = target_ie + (unsigned long )target_ielen;
#line 510
    remain_len = ((uint )((long )start) - (uint )((long )remain_ies)) + search_len;
#line 512
    __len = (size_t )remain_len;
#line 512
    __ret = __builtin_memcpy((void *)(& buf), (void const   *)remain_ies, __len);
#line 513
    __len___0 = (size_t )remain_len;
#line 513
    __ret___0 = __builtin_memcpy((void *)target_ie, (void const   *)(& buf), __len___0);
#line 514
    *ies_len = *ies_len - target_ielen;
#line 515
    ret = 1;
#line 517
    start = target_ie;
#line 518
    search_len = remain_len;
  } else {
#line 520
    goto ldv_51542;
  }
#line 522
  goto ldv_51543;
  ldv_51542: ;
  exit: ;
#line 524
  return (ret);
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
void rtw_set_supported_rate23a(u8 *SupportedRates , uint mode ) 
{ 
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;

  {
#line 531
  memset((void *)SupportedRates, 0, 16UL);
#line 533
  switch (mode) {
  case 1U: 
#line 536
  __len = 4UL;
#line 536
  if (__len > 63UL) {
#line 536
    __ret = __memcpy((void *)SupportedRates, (void const   *)(& WIFI_CCKRATES), __len);
  } else {
#line 536
    __ret = __builtin_memcpy((void *)SupportedRates, (void const   *)(& WIFI_CCKRATES),
                             __len);
  }
#line 537
  goto ldv_51552;
  case 2U: ;
  case 4U: ;
  case 16U: ;
  case 20U: 
#line 543
  __len___0 = 8UL;
#line 543
  if (__len___0 > 63UL) {
#line 543
    __ret___0 = __memcpy((void *)SupportedRates, (void const   *)(& WIFI_OFDMRATES),
                         __len___0);
  } else {
#line 543
    __ret___0 = __builtin_memcpy((void *)SupportedRates, (void const   *)(& WIFI_OFDMRATES),
                                 __len___0);
  }
#line 545
  goto ldv_51552;
  case 3U: ;
  case 10U: ;
  case 8U: ;
  case 11U: 
#line 551
  __len___1 = 4UL;
#line 551
  if (__len___1 > 63UL) {
#line 551
    __ret___1 = __memcpy((void *)SupportedRates, (void const   *)(& WIFI_CCKRATES),
                         __len___1);
  } else {
#line 551
    __ret___1 = __builtin_memcpy((void *)SupportedRates, (void const   *)(& WIFI_CCKRATES),
                                 __len___1);
  }
#line 552
  __len___2 = 8UL;
#line 552
  if (__len___2 > 63UL) {
#line 552
    __ret___2 = __memcpy((void *)SupportedRates + 4U, (void const   *)(& WIFI_OFDMRATES),
                         __len___2);
  } else {
#line 552
    __ret___2 = __builtin_memcpy((void *)SupportedRates + 4U, (void const   *)(& WIFI_OFDMRATES),
                                 __len___2);
  }
#line 554
  goto ldv_51552;
  }
  ldv_51552: ;
#line 558
  return;
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
uint rtw_get_rateset_len23a(u8 *rateset ) 
{ 
  uint i ;

  {
#line 561
  i = 0U;
  ldv_51575: ;
#line 564
  if ((unsigned int )*(rateset + (unsigned long )i) == 0U) {
#line 565
    goto ldv_51574;
  } else {

  }
#line 567
  if (i > 12U) {
#line 568
    goto ldv_51574;
  } else {

  }
#line 570
  i = i + 1U;
#line 571
  goto ldv_51575;
  ldv_51574: ;
#line 573
  return (i);
}
}
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int rtw_generate_ie23a(struct registry_priv *pregistrypriv ) 
{ 
  u8 wireless_mode ;
  int sz ;
  int rateLen ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *ie ;
  uint tmp ;

  {
#line 579
  sz = 0;
#line 580
  pdev_network = & pregistrypriv->dev_network;
#line 581
  ie = (u8 *)(& pdev_network->IEs);
#line 586
  sz = sz + 8;
#line 587
  ie = ie + (unsigned long )sz;
#line 591
  *((u16 *)ie) = pdev_network->BeaconPeriod;
#line 592
  sz = sz + 2;
#line 593
  ie = ie + 2UL;
#line 596
  *((u16 *)ie) = 0U;
#line 598
  *((u16 *)ie) = (u16 )((unsigned int )*((u16 *)ie) | 2U);
#line 600
  if ((unsigned int )pregistrypriv->preamble == 3U) {
#line 601
    *((u16 *)ie) = (u16 )((unsigned int )*((u16 *)ie) | 32U);
  } else {

  }
#line 603
  if (pdev_network->Privacy != 0U) {
#line 604
    *((u16 *)ie) = (u16 )((unsigned int )*((u16 *)ie) | 16U);
  } else {

  }
#line 606
  sz = sz + 2;
#line 607
  ie = ie + 2UL;
#line 610
  ie = rtw_set_ie23a(ie, 0, (uint )pdev_network->Ssid.ssid_len, (u8 const   *)(& pdev_network->Ssid.ssid),
                     (uint *)(& sz));
#line 614
  if ((unsigned int )pregistrypriv->wireless_mode == 31U) {
#line 615
    if (pdev_network->DSConfig > 14U) {
#line 616
      wireless_mode = 20U;
    } else {
#line 618
      wireless_mode = 11U;
    }
  } else {
#line 620
    wireless_mode = pregistrypriv->wireless_mode;
  }
#line 623
  rtw_set_supported_rate23a((u8 *)(& pdev_network->SupportedRates), (uint )wireless_mode);
#line 625
  tmp = rtw_get_rateset_len23a((u8 *)(& pdev_network->SupportedRates));
#line 625
  rateLen = (int )tmp;
#line 627
  if (rateLen > 8) {
#line 628
    ie = rtw_set_ie23a(ie, 1, 8U, (u8 const   *)(& pdev_network->SupportedRates),
                       (uint *)(& sz));
  } else {
#line 632
    ie = rtw_set_ie23a(ie, 1, (uint )rateLen, (u8 const   *)(& pdev_network->SupportedRates),
                       (uint *)(& sz));
  }
#line 637
  ie = rtw_set_ie23a(ie, 3, 1U, (u8 const   *)(& pdev_network->DSConfig), (uint *)(& sz));
#line 642
  ie = rtw_set_ie23a(ie, 6, 2U, (u8 const   *)(& pdev_network->ATIMWindow), (uint *)(& sz));
#line 645
  if (rateLen > 8) {
#line 646
    ie = rtw_set_ie23a(ie, 50, (uint )(rateLen + -8), (u8 const   *)(& pdev_network->SupportedRates) + 8U,
                       (uint *)(& sz));
  } else {

  }
#line 654
  return (sz);
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int rtw_get_wpa_cipher_suite23a(u8 const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 659
  tmp = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_NONE23A), 4UL);
#line 659
  if (tmp == 0) {
#line 660
    return (1);
  } else {

  }
#line 661
  tmp___0 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_WEP4023A),
                   4UL);
#line 661
  if (tmp___0 == 0) {
#line 662
    return (2);
  } else {

  }
#line 663
  tmp___1 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_TKIP23A),
                   4UL);
#line 663
  if (tmp___1 == 0) {
#line 664
    return (8);
  } else {

  }
#line 665
  tmp___2 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_CCMP23A),
                   4UL);
#line 665
  if (tmp___2 == 0) {
#line 666
    return (16);
  } else {

  }
#line 667
  tmp___3 = memcmp((void const   *)s, (void const   *)(& WPA_CIPHER_SUITE_WEP10423A),
                   4UL);
#line 667
  if (tmp___3 == 0) {
#line 668
    return (4);
  } else {

  }
#line 670
  return (0);
}
}
#line 673 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int rtw_get_wpa2_cipher_suite23a(u8 const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 675
  tmp = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_NONE23A), 4UL);
#line 675
  if (tmp == 0) {
#line 676
    return (1);
  } else {

  }
#line 677
  tmp___0 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_WEP4023A),
                   4UL);
#line 677
  if (tmp___0 == 0) {
#line 678
    return (2);
  } else {

  }
#line 679
  tmp___1 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_TKIP23A),
                   4UL);
#line 679
  if (tmp___1 == 0) {
#line 680
    return (8);
  } else {

  }
#line 681
  tmp___2 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_CCMP23A),
                   4UL);
#line 681
  if (tmp___2 == 0) {
#line 682
    return (16);
  } else {

  }
#line 683
  tmp___3 = memcmp((void const   *)s, (void const   *)(& RSN_CIPHER_SUITE_WEP10423A),
                   4UL);
#line 683
  if (tmp___3 == 0) {
#line 684
    return (4);
  } else {

  }
#line 686
  return (0);
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int rtw_parse_wpa_ie23a(u8 const   *wpa_ie , int wpa_ie_len , int *group_cipher ,
                        int *pairwise_cipher , int *is_8021x ) 
{ 
  int i ;
  int ret ;
  int left ;
  int count ;
  u8 const   *pos ;
  u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 691
  ret = 1;
#line 695
  if (wpa_ie_len <= 0) {
#line 697
    return (0);
  } else {

  }
#line 700
  if ((unsigned int )((unsigned char )*(wpa_ie + 1UL)) != (unsigned int )((unsigned char )wpa_ie_len) - 2U) {
#line 701
    return (0);
  } else {

  }
#line 703
  pos = wpa_ie;
#line 705
  pos = pos + 8UL;
#line 706
  left = wpa_ie_len + -8;
#line 709
  if (left > 3) {
#line 711
    *group_cipher = rtw_get_wpa_cipher_suite23a(pos);
#line 713
    pos = pos + 4UL;
#line 714
    left = left + -4;
  } else
#line 715
  if (left > 0) {
#line 716
    if (GlobalDebugLevel23A > 3U) {
#line 716
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 716
      printk("\016%s: ie length mismatch, %u too much", "rtw_parse_wpa_ie23a", left);
    } else {

    }
#line 720
    return (0);
  } else {

  }
#line 724
  if (left > 1) {
#line 726
    tmp = get_unaligned_le16((void const   *)pos);
#line 726
    count = (int )tmp;
#line 727
    pos = pos + 2UL;
#line 728
    left = left + -2;
#line 730
    if (count == 0 || count * 4 > left) {
#line 731
      if (GlobalDebugLevel23A > 3U) {
#line 731
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 731
        printk("\016%s: ie count botch (pairwise), count %u left %u", "rtw_parse_wpa_ie23a",
               count, left);
      } else {

      }
#line 735
      return (0);
    } else {

    }
#line 738
    i = 0;
#line 738
    goto ldv_51604;
    ldv_51603: 
#line 739
    tmp___0 = rtw_get_wpa_cipher_suite23a(pos);
#line 739
    *pairwise_cipher = *pairwise_cipher | tmp___0;
#line 741
    pos = pos + 4UL;
#line 742
    left = left + -4;
#line 738
    i = i + 1;
    ldv_51604: ;
#line 738
    if (i < count) {
#line 740
      goto ldv_51603;
    } else {

    }

  } else
#line 744
  if (left == 1) {
#line 745
    if (GlobalDebugLevel23A > 3U) {
#line 745
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 745
      printk("\016%s: ie too short (for key mgmt)", "rtw_parse_wpa_ie23a");
    } else {

    }
#line 747
    return (0);
  } else {

  }
#line 750
  if ((unsigned long )is_8021x != (unsigned long )((int *)0)) {
#line 751
    if (left > 5) {
#line 752
      pos = pos + 2UL;
#line 753
      tmp___1 = memcmp((void const   *)pos, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                       4UL);
#line 753
      if (tmp___1 == 0) {
#line 754
        if (GlobalDebugLevel23A > 6U) {
#line 754
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 754
          printk("\016%s : there has 802.1x auth\n", "rtw_parse_wpa_ie23a");
        } else {

        }
#line 757
        *is_8021x = 1;
      } else {

      }
    } else {

    }
  } else {

  }
#line 762
  return (ret);
}
}
#line 765 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int rtw_parse_wpa2_ie23a(u8 const   *rsn_ie , int rsn_ie_len , int *group_cipher ,
                         int *pairwise_cipher , int *is_8021x ) 
{ 
  int i ;
  int ret ;
  int left ;
  int count ;
  u8 const   *pos ;
  u8 SUITE_1X[4U] ;
  u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 768
  ret = 1;
#line 771
  SUITE_1X[0] = 0U;
#line 771
  SUITE_1X[1] = 15U;
#line 771
  SUITE_1X[2] = 172U;
#line 771
  SUITE_1X[3] = 1U;
#line 773
  if (rsn_ie_len <= 0) {
#line 775
    return (0);
  } else {

  }
#line 778
  if ((unsigned int )((unsigned char )*rsn_ie) != 48U || (unsigned int )((unsigned char )*(rsn_ie + 1UL)) != (unsigned int )((unsigned char )rsn_ie_len) - 2U) {
#line 779
    return (0);
  } else {

  }
#line 782
  pos = rsn_ie;
#line 783
  pos = pos + 4UL;
#line 784
  left = rsn_ie_len + -4;
#line 787
  if (left > 3) {
#line 788
    *group_cipher = rtw_get_wpa2_cipher_suite23a(pos);
#line 790
    pos = pos + 4UL;
#line 791
    left = left + -4;
  } else
#line 792
  if (left > 0) {
#line 793
    if (GlobalDebugLevel23A > 3U) {
#line 793
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 793
      printk("\016%s: ie length mismatch, %u too much", "rtw_parse_wpa2_ie23a", left);
    } else {

    }
#line 796
    return (0);
  } else {

  }
#line 800
  if (left > 1) {
#line 802
    tmp = get_unaligned_le16((void const   *)pos);
#line 802
    count = (int )tmp;
#line 803
    pos = pos + 2UL;
#line 804
    left = left + -2;
#line 806
    if (count == 0 || count * 4 > left) {
#line 807
      if (GlobalDebugLevel23A > 3U) {
#line 807
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 807
        printk("\016%s: ie count botch (pairwise), count %u left %u", "rtw_parse_wpa2_ie23a",
               count, left);
      } else {

      }
#line 811
      return (0);
    } else {

    }
#line 814
    i = 0;
#line 814
    goto ldv_51621;
    ldv_51620: 
#line 815
    tmp___0 = rtw_get_wpa2_cipher_suite23a(pos);
#line 815
    *pairwise_cipher = *pairwise_cipher | tmp___0;
#line 817
    pos = pos + 4UL;
#line 818
    left = left + -4;
#line 814
    i = i + 1;
    ldv_51621: ;
#line 814
    if (i < count) {
#line 816
      goto ldv_51620;
    } else {

    }

  } else
#line 820
  if (left == 1) {
#line 821
    if (GlobalDebugLevel23A > 3U) {
#line 821
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 821
      printk("\016%s: ie too short (for key mgmt)", "rtw_parse_wpa2_ie23a");
    } else {

    }
#line 824
    return (0);
  } else {

  }
#line 827
  if ((unsigned long )is_8021x != (unsigned long )((int *)0)) {
#line 828
    if (left > 5) {
#line 829
      pos = pos + 2UL;
#line 830
      tmp___1 = memcmp((void const   *)pos, (void const   *)(& SUITE_1X), 4UL);
#line 830
      if (tmp___1 == 0) {
#line 831
        if (GlobalDebugLevel23A > 6U) {
#line 831
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 831
          printk("\016%s (): there has 802.1x auth\n", "rtw_parse_wpa2_ie23a");
        } else {

        }
#line 834
        *is_8021x = 1;
      } else {

      }
    } else {

    }
  } else {

  }
#line 839
  return (ret);
}
}
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int rtw_get_sec_ie23a(u8 *in_ie , uint in_len , u8 *rsn_ie , u16 *rsn_len , u8 *wpa_ie ,
                      u16 *wpa_len ) 
{ 
  u8 authmode ;
  u8 sec_idx ;
  u8 i ;
  uint cnt ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp ;

  {
#line 851
  cnt = 12U;
#line 853
  sec_idx = 0U;
#line 855
  goto ldv_51648;
  ldv_51647: 
#line 856
  authmode = *(in_ie + (unsigned long )cnt);
#line 858
  if ((unsigned int )authmode == 221U) {
#line 858
    tmp = memcmp((void const   *)in_ie + (unsigned long )(cnt + 2U), (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
#line 858
    if (tmp == 0) {
#line 860
      if (GlobalDebugLevel23A > 6U) {
#line 860
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 860
        printk("\016\n rtw_get_wpa_ie23a: sec_idx =%d in_ie[cnt+1]+2 =%d\n", (int )sec_idx,
               (int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
      } else {

      }
#line 865
      if ((unsigned long )wpa_ie != (unsigned long )((u8 *)0U)) {
#line 866
        __len = (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
#line 866
        __ret = __builtin_memcpy((void *)wpa_ie, (void const   *)in_ie + (unsigned long )cnt,
                                 __len);
#line 868
        i = 0U;
#line 868
        goto ldv_51639;
        ldv_51638: ;
#line 869
        if (GlobalDebugLevel23A > 6U) {
#line 869
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 869
          printk("\016\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n", (int )*(wpa_ie + (unsigned long )i),
                 (int )*(wpa_ie + ((unsigned long )i + 1UL)), (int )*(wpa_ie + ((unsigned long )i + 2UL)),
                 (int )*(wpa_ie + ((unsigned long )i + 3UL)), (int )*(wpa_ie + ((unsigned long )i + 4UL)),
                 (int )*(wpa_ie + ((unsigned long )i + 5UL)), (int )*(wpa_ie + ((unsigned long )i + 6UL)),
                 (int )*(wpa_ie + ((unsigned long )i + 7UL)));
        } else {

        }
#line 868
        i = (unsigned int )i + 8U;
        ldv_51639: ;
#line 868
        if ((int )i < (int )*(in_ie + (unsigned long )(cnt + 1U)) + 2) {
#line 870
          goto ldv_51638;
        } else {

        }

      } else {

      }
#line 880
      *wpa_len = (unsigned int )((u16 )*(in_ie + (unsigned long )(cnt + 1U))) + 2U;
#line 881
      cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
    } else {
#line 858
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 883
  if ((unsigned int )authmode == 48U) {
#line 884
    if (GlobalDebugLevel23A > 6U) {
#line 884
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 884
      printk("\016\n get_rsn_ie: sec_idx =%d in_ie[cnt+1]+2 =%d\n", (int )sec_idx,
             (int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
    } else {

    }
#line 889
    if ((unsigned long )rsn_ie != (unsigned long )((u8 *)0U)) {
#line 890
      __len___0 = (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
#line 890
      __ret___0 = __builtin_memcpy((void *)rsn_ie, (void const   *)in_ie + (unsigned long )cnt,
                                   __len___0);
#line 892
      i = 0U;
#line 892
      goto ldv_51645;
      ldv_51644: ;
#line 893
      if (GlobalDebugLevel23A > 6U) {
#line 893
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 893
        printk("\016\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n", (int )*(rsn_ie + (unsigned long )i),
               (int )*(rsn_ie + ((unsigned long )i + 1UL)), (int )*(rsn_ie + ((unsigned long )i + 2UL)),
               (int )*(rsn_ie + ((unsigned long )i + 3UL)), (int )*(rsn_ie + ((unsigned long )i + 4UL)),
               (int )*(rsn_ie + ((unsigned long )i + 5UL)), (int )*(rsn_ie + ((unsigned long )i + 6UL)),
               (int )*(rsn_ie + ((unsigned long )i + 7UL)));
      } else {

      }
#line 892
      i = (unsigned int )i + 8U;
      ldv_51645: ;
#line 892
      if ((int )i < (int )*(in_ie + (unsigned long )(cnt + 1U)) + 2) {
#line 894
        goto ldv_51644;
      } else {

      }

    } else {

    }
#line 904
    *rsn_len = (unsigned int )((u16 )*(in_ie + (unsigned long )(cnt + 1U))) + 2U;
#line 905
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  } else {
#line 907
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  }
  ldv_51648: ;
#line 855
  if (cnt < in_len) {
#line 857
    goto ldv_51647;
  } else {

  }

#line 914
  return ((int )*rsn_len + (int )*wpa_len);
}
}
#line 928 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 *rtw_get_wps_ie23a(u8 *in_ie , uint in_len , u8 *wps_ie , uint *wps_ielen ) 
{ 
  uint cnt ;
  u8 *wpsie_ptr ;
  u8 eid ;
  u8 wps_oui[4U] ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 931
  wpsie_ptr = (u8 *)0U;
#line 932
  wps_oui[0] = 0U;
#line 932
  wps_oui[1] = 80U;
#line 932
  wps_oui[2] = 242U;
#line 932
  wps_oui[3] = 4U;
#line 934
  if ((unsigned long )wps_ielen != (unsigned long )((uint *)0U)) {
#line 935
    *wps_ielen = 0U;
  } else {

  }
#line 937
  if ((unsigned long )in_ie == (unsigned long )((u8 *)0U) || in_len == 0U) {
#line 938
    return (wpsie_ptr);
  } else {

  }
#line 940
  cnt = 0U;
#line 942
  goto ldv_51665;
  ldv_51664: 
#line 943
  eid = *(in_ie + (unsigned long )cnt);
#line 945
  if ((unsigned int )eid == 221U) {
#line 945
    tmp = memcmp((void const   *)in_ie + (unsigned long )(cnt + 2U), (void const   *)(& wps_oui),
                 4UL);
#line 945
    if (tmp == 0) {
#line 947
      wpsie_ptr = in_ie + (unsigned long )cnt;
#line 949
      if ((unsigned long )wps_ie != (unsigned long )((u8 *)0U)) {
#line 950
        __len = (size_t )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
#line 950
        __ret = __builtin_memcpy((void *)wps_ie, (void const   *)in_ie + (unsigned long )cnt,
                                 __len);
      } else {

      }
#line 952
      if ((unsigned long )wps_ielen != (unsigned long )((uint *)0U)) {
#line 953
        *wps_ielen = (uint )((int )*(in_ie + (unsigned long )(cnt + 1U)) + 2);
      } else {

      }
#line 955
      cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
#line 957
      goto ldv_51663;
    } else {
#line 959
      cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
    }
  } else {
#line 959
    cnt = ((uint )*(in_ie + (unsigned long )(cnt + 1U)) + cnt) + 2U;
  }
  ldv_51665: ;
#line 942
  if (cnt < in_len) {
#line 944
    goto ldv_51664;
  } else {

  }
  ldv_51663: ;
#line 963
  return (wpsie_ptr);
}
}
#line 978 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 *rtw_get_wps_attr23a(u8 *wps_ie , uint wps_ielen , u16 target_attr_id , u8 *buf_attr ,
                        u32 *len_attr ) 
{ 
  u8 *attr_ptr ;
  u8 *target_attr_ptr ;
  u8 wps_oui[4U] ;
  int tmp ;
  u16 attr_id ;
  u16 tmp___0 ;
  u16 attr_data_len ;
  u16 tmp___1 ;
  u16 attr_len ;
  size_t __len ;
  void *__ret ;

  {
#line 981
  attr_ptr = (u8 *)0U;
#line 982
  target_attr_ptr = (u8 *)0U;
#line 983
  wps_oui[0] = 0U;
#line 983
  wps_oui[1] = 80U;
#line 983
  wps_oui[2] = 242U;
#line 983
  wps_oui[3] = 4U;
#line 985
  if ((unsigned long )len_attr != (unsigned long )((u32 *)0U)) {
#line 986
    *len_attr = 0U;
  } else {

  }
#line 988
  if ((unsigned int )*wps_ie != 221U) {
#line 990
    return (attr_ptr);
  } else {
#line 988
    tmp = memcmp((void const   *)wps_ie + 2U, (void const   *)(& wps_oui), 4UL);
#line 988
    if (tmp != 0) {
#line 990
      return (attr_ptr);
    } else {

    }
  }
#line 994
  attr_ptr = wps_ie + 6UL;
#line 996
  goto ldv_51684;
  ldv_51683: 
#line 998
  tmp___0 = get_unaligned_be16((void const   *)attr_ptr);
#line 998
  attr_id = tmp___0;
#line 999
  tmp___1 = get_unaligned_be16((void const   *)attr_ptr + 2U);
#line 999
  attr_data_len = tmp___1;
#line 1000
  attr_len = (unsigned int )attr_data_len + 4U;
#line 1003
  if ((int )attr_id == (int )target_attr_id) {
#line 1004
    target_attr_ptr = attr_ptr;
#line 1006
    if ((unsigned long )buf_attr != (unsigned long )((u8 *)0U)) {
#line 1007
      __len = (size_t )attr_len;
#line 1007
      __ret = __builtin_memcpy((void *)buf_attr, (void const   *)attr_ptr, __len);
    } else {

    }
#line 1009
    if ((unsigned long )len_attr != (unsigned long )((u32 *)0U)) {
#line 1010
      *len_attr = (u32 )attr_len;
    } else {

    }
#line 1012
    goto ldv_51682;
  } else {
#line 1014
    attr_ptr = attr_ptr + (unsigned long )attr_len;
  }
  ldv_51684: ;
#line 996
  if ((long )attr_ptr - (long )wps_ie < (long )wps_ielen) {
#line 998
    goto ldv_51683;
  } else {

  }
  ldv_51682: ;
#line 1018
  return (target_attr_ptr);
}
}
#line 1034 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u8 *rtw_get_wps_attr_content23a(u8 *wps_ie , uint wps_ielen , u16 target_attr_id ,
                                u8 *buf_content , uint *len_content ) 
{ 
  u8 *attr_ptr ;
  u32 attr_len ;
  size_t __len ;
  void *__ret ;

  {
#line 1040
  if ((unsigned long )len_content != (unsigned long )((uint *)0U)) {
#line 1041
    *len_content = 0U;
  } else {

  }
#line 1043
  attr_ptr = rtw_get_wps_attr23a(wps_ie, wps_ielen, (int )target_attr_id, (u8 *)0U,
                                 & attr_len);
#line 1046
  if ((unsigned long )attr_ptr != (unsigned long )((u8 *)0U) && attr_len != 0U) {
#line 1047
    if ((unsigned long )buf_content != (unsigned long )((u8 *)0U)) {
#line 1048
      __len = (size_t )(attr_len - 4U);
#line 1048
      __ret = __builtin_memcpy((void *)buf_content, (void const   *)attr_ptr + 4U,
                               __len);
    } else {

    }
#line 1050
    if ((unsigned long )len_content != (unsigned long )((uint *)0U)) {
#line 1051
      *len_content = attr_len - 4U;
    } else {

    }
#line 1053
    return (attr_ptr + 4UL);
  } else {

  }
#line 1056
  return ((u8 *)0U);
}
}
#line 1059 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
static int rtw_get_cipher_info(struct wlan_network *pnetwork ) 
{ 
  u8 const   *pbuf ;
  int group_cipher ;
  int pairwise_cipher ;
  int is8021x ;
  int ret ;
  int r ;
  int offset ;
  int plen ;
  char *pie ;

  {
#line 1062
  group_cipher = 0;
#line 1062
  pairwise_cipher = 0;
#line 1062
  is8021x = 0;
#line 1063
  ret = 0;
#line 1067
  offset = 12;
#line 1069
  pie = (char *)(& pnetwork->network.IEs) + (unsigned long )offset;
#line 1070
  plen = (int )(pnetwork->network.IELength - (u32 )offset);
#line 1072
  pbuf = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)pie, plen);
#line 1075
  if ((unsigned long )pbuf != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pbuf + 1UL)) != 0U) {
#line 1076
    if (GlobalDebugLevel23A > 6U) {
#line 1076
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1076
      printk("\016rtw_get_cipher_info: wpa_ielen: %d", (int )*(pbuf + 1UL));
    } else {

    }
#line 1078
    r = rtw_parse_wpa_ie23a(pbuf, (int )*(pbuf + 1UL) + 2, & group_cipher, & pairwise_cipher,
                            & is8021x);
#line 1080
    if (r == 1) {
#line 1081
      pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
#line 1082
      pnetwork->BcnInfo.group_cipher = group_cipher;
#line 1083
      pnetwork->BcnInfo.is_8021x = is8021x;
#line 1084
      if (GlobalDebugLevel23A > 6U) {
#line 1084
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1084
        printk("\016%s: pnetwork->pairwise_cipher: %d, is_8021x is %d", "rtw_get_cipher_info",
               pnetwork->BcnInfo.pairwise_cipher, pnetwork->BcnInfo.is_8021x);
      } else {

      }
#line 1089
      ret = 1;
    } else {

    }
  } else {
#line 1092
    pbuf = cfg80211_find_ie(48, (u8 const   *)pie, plen);
#line 1094
    if ((unsigned long )pbuf != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pbuf + 1UL)) != 0U) {
#line 1095
      if (GlobalDebugLevel23A > 6U) {
#line 1095
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1095
        printk("\016get RSN IE\n");
      } else {

      }
#line 1097
      r = rtw_parse_wpa2_ie23a(pbuf, (int )*(pbuf + 1UL) + 2, & group_cipher, & pairwise_cipher,
                               & is8021x);
#line 1100
      if (r == 1) {
#line 1101
        if (GlobalDebugLevel23A > 6U) {
#line 1101
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1101
          printk("\016get RSN IE  OK!!!\n");
        } else {

        }
#line 1103
        pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
#line 1105
        pnetwork->BcnInfo.group_cipher = group_cipher;
#line 1106
        pnetwork->BcnInfo.is_8021x = is8021x;
#line 1107
        if (GlobalDebugLevel23A > 6U) {
#line 1107
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1107
          printk("\016%s: pnetwork->pairwise_cipher: %d,pnetwork->group_cipher is %d, is_8021x is %d",
                 "rtw_get_cipher_info", pnetwork->BcnInfo.pairwise_cipher, pnetwork->BcnInfo.group_cipher,
                 pnetwork->BcnInfo.is_8021x);
        } else {

        }
#line 1114
        ret = 1;
      } else {

      }
    } else {

    }
  }
#line 1119
  return (ret);
}
}
#line 1122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
void rtw_get_bcn_info23a(struct wlan_network *pnetwork ) 
{ 
  unsigned short cap ;
  u8 bencrypt ;
  u16 wpa_len ;
  u16 rsn_len ;
  struct HT_info_element *pht_info ;
  struct ieee80211_ht_cap *pht_cap ;
  u8 const   *p ;
  __le16 *tmp ;

  {
#line 1125
  bencrypt = 0U;
#line 1127
  wpa_len = 0U;
#line 1127
  rsn_len = 0U;
#line 1132
  tmp = rtw_get_capability23a_from_ie((u8 *)(& pnetwork->network.IEs));
#line 1132
  cap = get_unaligned_le16((void const   *)tmp);
#line 1134
  if (((int )cap & 16) != 0) {
#line 1135
    bencrypt = 1U;
#line 1136
    pnetwork->network.Privacy = 1U;
  } else {
#line 1138
    pnetwork->BcnInfo.encryp_protocol = 0U;
  }
#line 1140
  rtw_get_sec_ie23a((u8 *)(& pnetwork->network.IEs), pnetwork->network.IELength, (u8 *)0U,
                    & rsn_len, (u8 *)0U, & wpa_len);
#line 1142
  if (GlobalDebugLevel23A > 6U) {
#line 1142
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1142
    printk("\016rtw_get_bcn_info23a: ssid =%s\n", (u8 *)(& pnetwork->network.Ssid.ssid));
  } else {

  }
#line 1144
  if (GlobalDebugLevel23A > 6U) {
#line 1144
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1144
    printk("\016rtw_get_bcn_info23a: wpa_len =%d rsn_len =%d\n", (int )wpa_len, (int )rsn_len);
  } else {

  }
#line 1147
  if (GlobalDebugLevel23A > 6U) {
#line 1147
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1147
    printk("\016rtw_get_bcn_info23a: ssid =%s\n", (u8 *)(& pnetwork->network.Ssid.ssid));
  } else {

  }
#line 1149
  if (GlobalDebugLevel23A > 6U) {
#line 1149
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1149
    printk("\016rtw_get_bcn_info23a: wpa_len =%d rsn_len =%d\n", (int )wpa_len, (int )rsn_len);
  } else {

  }
#line 1153
  if ((unsigned int )rsn_len != 0U) {
#line 1154
    pnetwork->BcnInfo.encryp_protocol = 3U;
  } else
#line 1155
  if ((unsigned int )wpa_len != 0U) {
#line 1156
    pnetwork->BcnInfo.encryp_protocol = 2U;
  } else
#line 1158
  if ((unsigned int )bencrypt != 0U) {
#line 1159
    pnetwork->BcnInfo.encryp_protocol = 1U;
  } else {

  }
#line 1161
  if (GlobalDebugLevel23A > 6U) {
#line 1161
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1161
    printk("\016rtw_get_bcn_info23a: pnetwork->encryp_protocol is %x\n", (int )pnetwork->BcnInfo.encryp_protocol);
  } else {

  }
#line 1164
  if (GlobalDebugLevel23A > 6U) {
#line 1164
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1164
    printk("\016rtw_get_bcn_info23a: pnetwork->encryp_protocol is %x\n", (int )pnetwork->BcnInfo.encryp_protocol);
  } else {

  }
#line 1167
  rtw_get_cipher_info(pnetwork);
#line 1171
  p = cfg80211_find_ie(45, (u8 const   *)(& pnetwork->network.IEs) + 12U, (int )(pnetwork->network.IELength - 12U));
#line 1174
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1175
    pht_cap = (struct ieee80211_ht_cap *)p + 2U;
#line 1176
    pnetwork->BcnInfo.ht_cap_info = pht_cap->cap_info;
  } else {
#line 1178
    pnetwork->BcnInfo.ht_cap_info = 0U;
  }
#line 1181
  p = cfg80211_find_ie(61, (u8 const   *)(& pnetwork->network.IEs) + 12U, (int )(pnetwork->network.IELength - 12U));
#line 1184
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1185
    pht_info = (struct HT_info_element *)p + 2U;
#line 1186
    pnetwork->BcnInfo.ht_info_infos_0 = pht_info->infos[0];
  } else {
#line 1188
    pnetwork->BcnInfo.ht_info_infos_0 = 0U;
  }
#line 1189
  return;
}
}
#line 1192 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
u16 rtw_mcs_rate23a(u8 rf_type , u8 bw_40MHz , u8 short_GI_20 , u8 short_GI_40 , unsigned char *MCS_rate ) 
{ 
  u16 max_rate ;

  {
#line 1195
  max_rate = 0U;
#line 1197
  if ((unsigned int )rf_type == 3U) {
#line 1198
    if ((int )((signed char )*MCS_rate) < 0) {
#line 1199
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1500U : 1350U) : ((unsigned int )short_GI_20 != 0U ? 722U : 650U);
    } else
#line 1201
    if (((unsigned long )*MCS_rate & 64UL) != 0UL) {
#line 1202
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1350U : 1215U) : ((unsigned int )short_GI_20 != 0U ? 650U : 585U);
    } else
#line 1204
    if (((unsigned long )*MCS_rate & 32UL) != 0UL) {
#line 1205
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
    } else
#line 1207
    if (((unsigned long )*MCS_rate & 16UL) != 0UL) {
#line 1208
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
    } else
#line 1210
    if (((unsigned long )*MCS_rate & 8UL) != 0UL) {
#line 1211
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
    } else
#line 1213
    if (((unsigned long )*MCS_rate & 4UL) != 0UL) {
#line 1214
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 450U : 405U) : ((unsigned int )short_GI_20 != 0U ? 217U : 195U);
    } else
#line 1216
    if (((unsigned long )*MCS_rate & 2UL) != 0UL) {
#line 1217
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
    } else
#line 1219
    if ((int )*MCS_rate & 1) {
#line 1220
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 150U : 135U) : ((unsigned int )short_GI_20 != 0U ? 72U : 65U);
    } else {

    }
  } else
#line 1223
  if ((unsigned int )*(MCS_rate + 1UL) != 0U) {
#line 1224
    if ((int )((signed char )*(MCS_rate + 1UL)) < 0) {
#line 1225
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 3000U : 2700U) : ((unsigned int )short_GI_20 != 0U ? 1444U : 1300U);
    } else
#line 1226
    if (((unsigned long )*(MCS_rate + 1UL) & 64UL) != 0UL) {
#line 1227
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 2700U : 2430U) : ((unsigned int )short_GI_20 != 0U ? 1300U : 1170U);
    } else
#line 1228
    if (((unsigned long )*(MCS_rate + 1UL) & 32UL) != 0UL) {
#line 1229
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 2400U : 2160U) : ((unsigned int )short_GI_20 != 0U ? 1156U : 1040U);
    } else
#line 1230
    if (((unsigned long )*(MCS_rate + 1UL) & 16UL) != 0UL) {
#line 1231
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1800U : 1620U) : ((unsigned int )short_GI_20 != 0U ? 867U : 780U);
    } else
#line 1232
    if (((unsigned long )*(MCS_rate + 1UL) & 8UL) != 0UL) {
#line 1233
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
    } else
#line 1234
    if (((unsigned long )*(MCS_rate + 1UL) & 4UL) != 0UL) {
#line 1235
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
    } else
#line 1236
    if (((unsigned long )*(MCS_rate + 1UL) & 2UL) != 0UL) {
#line 1237
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
    } else
#line 1238
    if ((int )*(MCS_rate + 1UL) & 1) {
#line 1239
      max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
    } else {

    }
  } else
#line 1241
  if ((int )((signed char )*MCS_rate) < 0) {
#line 1242
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1500U : 1350U) : ((unsigned int )short_GI_20 != 0U ? 722U : 650U);
  } else
#line 1243
  if (((unsigned long )*MCS_rate & 64UL) != 0UL) {
#line 1244
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1350U : 1215U) : ((unsigned int )short_GI_20 != 0U ? 650U : 585U);
  } else
#line 1245
  if (((unsigned long )*MCS_rate & 32UL) != 0UL) {
#line 1246
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 1200U : 1080U) : ((unsigned int )short_GI_20 != 0U ? 578U : 520U);
  } else
#line 1247
  if (((unsigned long )*MCS_rate & 16UL) != 0UL) {
#line 1248
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 900U : 810U) : ((unsigned int )short_GI_20 != 0U ? 433U : 390U);
  } else
#line 1249
  if (((unsigned long )*MCS_rate & 8UL) != 0UL) {
#line 1250
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 600U : 540U) : ((unsigned int )short_GI_20 != 0U ? 289U : 260U);
  } else
#line 1251
  if (((unsigned long )*MCS_rate & 4UL) != 0UL) {
#line 1252
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 450U : 405U) : ((unsigned int )short_GI_20 != 0U ? 217U : 195U);
  } else
#line 1253
  if (((unsigned long )*MCS_rate & 2UL) != 0UL) {
#line 1254
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 300U : 270U) : ((unsigned int )short_GI_20 != 0U ? 144U : 130U);
  } else
#line 1255
  if ((int )*MCS_rate & 1) {
#line 1256
    max_rate = (unsigned int )bw_40MHz != 0U ? ((unsigned int )short_GI_40 != 0U ? 150U : 135U) : ((unsigned int )short_GI_20 != 0U ? 72U : 65U);
  } else {

  }
#line 1259
  return (max_rate);
}
}
#line 1262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
static char const   *_action_public_str23a[17U]  = 
#line 1262
  {      "ACT_PUB_BSSCOEXIST",      "ACT_PUB_DSE_ENABLE",      "ACT_PUB_DSE_DEENABLE",      "ACT_PUB_DSE_REG_LOCATION", 
        "ACT_PUB_EXT_CHL_SWITCH",      "ACT_PUB_DSE_MSR_REQ",      "ACT_PUB_DSE_MSR_RPRT",      "ACT_PUB_MP", 
        "ACT_PUB_DSE_PWR_CONSTRAINT",      "ACT_PUB_VENDOR",      "ACT_PUB_GAS_INITIAL_REQ",      "ACT_PUB_GAS_INITIAL_RSP", 
        "ACT_PUB_GAS_COMEBACK_REQ",      "ACT_PUB_GAS_COMEBACK_RSP",      "ACT_PUB_TDLS_DISCOVERY_RSP",      "ACT_PUB_LOCATION_TRACK", 
        "ACT_PUB_RSVD"};
#line 1282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
char const   *action_public_str23a(u8 action ) 
{ 


  {
#line 1284
  action = (u8 )(16U < (unsigned int )action ? 16U : action);
#line 1285
  return (_action_public_str23a[(int )action]);
}
}
#line 1415 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
void *ldv_kmem_cache_alloc_158(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1418
  ldv_check_alloc_flags(flags);
#line 1420
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1421
  return ((void *)0);
}
}
#line 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int ldv_pskb_expand_head_164(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1462
  ldv_check_alloc_flags(flags);
#line 1464
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1464
  return (tmp);
}
}
#line 1475 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
struct sk_buff *ldv_skb_clone_166(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1478
  ldv_check_alloc_flags(flags);
#line 1480
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1480
  return (tmp);
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
struct sk_buff *ldv_skb_copy_168(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1494
  ldv_check_alloc_flags(flags);
#line 1496
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1496
  return (tmp);
}
}
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_169(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1502
  ldv_check_alloc_flags(flags);
#line 1504
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1504
  return (tmp);
}
}
#line 1507 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_170(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1510
  ldv_check_alloc_flags(flags);
#line 1512
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1512
  return (tmp);
}
}
#line 1515 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_171(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1518
  ldv_check_alloc_flags(flags);
#line 1520
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1520
  return (tmp);
}
}
#line 1523 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int ldv_pskb_expand_head_172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1526
  ldv_check_alloc_flags(flags);
#line 1528
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1528
  return (tmp);
}
}
#line 1531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
int ldv_pskb_expand_head_173(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1534
  ldv_check_alloc_flags(flags);
#line 1536
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1536
  return (tmp);
}
}
#line 1539 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ieee80211.o.c.prepared"
struct sk_buff *ldv_skb_clone_174(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1542
  ldv_check_alloc_flags(flags);
#line 1544
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1544
  return (tmp);
}
}
#line 179 "include/linux/timer.h"
int ldv_mod_timer_218(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 183
int ldv_mod_timer_219(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 187
int ldv_mod_timer_220(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 191
int ldv_mod_timer_221(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 195
int ldv_mod_timer_222(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 199
int ldv_mod_timer_223(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 203
int ldv_mod_timer_224(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 207
int ldv_mod_timer_225(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 211
int ldv_mod_timer_226(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 215
int ldv_mod_timer_227(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 219
int ldv_mod_timer_228(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 223
int ldv_mod_timer_229(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 227
int ldv_mod_timer_230(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 231
int ldv_mod_timer_255(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 235
int ldv_mod_timer_264(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 239
int ldv_mod_timer_275(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 243
int ldv_mod_timer_277(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 247
int ldv_mod_timer_280(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 251
int ldv_mod_timer_281(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 255
int ldv_mod_timer_283(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 259
int ldv_mod_timer_285(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 263
int ldv_mod_timer_288(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 267
int ldv_mod_timer_290(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 271
int ldv_mod_timer_292(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 275
int ldv_mod_timer_296(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 279
int ldv_mod_timer_297(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 283
int ldv_mod_timer_299(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 287
int ldv_mod_timer_301(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 291
int ldv_mod_timer_303(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 295
int ldv_mod_timer_305(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 299
int ldv_mod_timer_307(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 303
int ldv_mod_timer_315(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 307
int ldv_mod_timer_317(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 311
int ldv_mod_timer_318(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 315
int ldv_mod_timer_321(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 248
int ldv_del_timer_sync_217(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_231(struct timer_list *ldv_func_arg1 ) ;
#line 256
int ldv_del_timer_sync_232(struct timer_list *ldv_func_arg1 ) ;
#line 260
int ldv_del_timer_sync_233(struct timer_list *ldv_func_arg1 ) ;
#line 264
int ldv_del_timer_sync_234(struct timer_list *ldv_func_arg1 ) ;
#line 268
int ldv_del_timer_sync_235(struct timer_list *ldv_func_arg1 ) ;
#line 272
int ldv_del_timer_sync_236(struct timer_list *ldv_func_arg1 ) ;
#line 276
int ldv_del_timer_sync_237(struct timer_list *ldv_func_arg1 ) ;
#line 280
int ldv_del_timer_sync_238(struct timer_list *ldv_func_arg1 ) ;
#line 284
int ldv_del_timer_sync_239(struct timer_list *ldv_func_arg1 ) ;
#line 288
int ldv_del_timer_sync_240(struct timer_list *ldv_func_arg1 ) ;
#line 292
int ldv_del_timer_sync_241(struct timer_list *ldv_func_arg1 ) ;
#line 296
int ldv_del_timer_sync_242(struct timer_list *ldv_func_arg1 ) ;
#line 300
int ldv_del_timer_sync_243(struct timer_list *ldv_func_arg1 ) ;
#line 304
int ldv_del_timer_sync_244(struct timer_list *ldv_func_arg1 ) ;
#line 308
int ldv_del_timer_sync_245(struct timer_list *ldv_func_arg1 ) ;
#line 312
int ldv_del_timer_sync_246(struct timer_list *ldv_func_arg1 ) ;
#line 316
int ldv_del_timer_sync_247(struct timer_list *ldv_func_arg1 ) ;
#line 320
int ldv_del_timer_sync_248(struct timer_list *ldv_func_arg1 ) ;
#line 324
int ldv_del_timer_sync_249(struct timer_list *ldv_func_arg1 ) ;
#line 328
int ldv_del_timer_sync_250(struct timer_list *ldv_func_arg1 ) ;
#line 332
int ldv_del_timer_sync_251(struct timer_list *ldv_func_arg1 ) ;
#line 336
int ldv_del_timer_sync_252(struct timer_list *ldv_func_arg1 ) ;
#line 340
int ldv_del_timer_sync_253(struct timer_list *ldv_func_arg1 ) ;
#line 344
int ldv_del_timer_sync_254(struct timer_list *ldv_func_arg1 ) ;
#line 348
int ldv_del_timer_sync_256(struct timer_list *ldv_func_arg1 ) ;
#line 352
int ldv_del_timer_sync_257(struct timer_list *ldv_func_arg1 ) ;
#line 356
int ldv_del_timer_sync_258(struct timer_list *ldv_func_arg1 ) ;
#line 360
int ldv_del_timer_sync_259(struct timer_list *ldv_func_arg1 ) ;
#line 364
int ldv_del_timer_sync_260(struct timer_list *ldv_func_arg1 ) ;
#line 368
int ldv_del_timer_sync_261(struct timer_list *ldv_func_arg1 ) ;
#line 372
int ldv_del_timer_sync_262(struct timer_list *ldv_func_arg1 ) ;
#line 376
int ldv_del_timer_sync_263(struct timer_list *ldv_func_arg1 ) ;
#line 380
int ldv_del_timer_sync_265(struct timer_list *ldv_func_arg1 ) ;
#line 384
int ldv_del_timer_sync_266(struct timer_list *ldv_func_arg1 ) ;
#line 388
int ldv_del_timer_sync_267(struct timer_list *ldv_func_arg1 ) ;
#line 392
int ldv_del_timer_sync_268(struct timer_list *ldv_func_arg1 ) ;
#line 396
int ldv_del_timer_sync_269(struct timer_list *ldv_func_arg1 ) ;
#line 400
int ldv_del_timer_sync_270(struct timer_list *ldv_func_arg1 ) ;
#line 404
int ldv_del_timer_sync_271(struct timer_list *ldv_func_arg1 ) ;
#line 408
int ldv_del_timer_sync_272(struct timer_list *ldv_func_arg1 ) ;
#line 412
int ldv_del_timer_sync_273(struct timer_list *ldv_func_arg1 ) ;
#line 416
int ldv_del_timer_sync_274(struct timer_list *ldv_func_arg1 ) ;
#line 420
int ldv_del_timer_sync_276(struct timer_list *ldv_func_arg1 ) ;
#line 424
int ldv_del_timer_sync_278(struct timer_list *ldv_func_arg1 ) ;
#line 428
int ldv_del_timer_sync_279(struct timer_list *ldv_func_arg1 ) ;
#line 432
int ldv_del_timer_sync_282(struct timer_list *ldv_func_arg1 ) ;
#line 436
int ldv_del_timer_sync_284(struct timer_list *ldv_func_arg1 ) ;
#line 440
int ldv_del_timer_sync_286(struct timer_list *ldv_func_arg1 ) ;
#line 444
int ldv_del_timer_sync_287(struct timer_list *ldv_func_arg1 ) ;
#line 448
int ldv_del_timer_sync_289(struct timer_list *ldv_func_arg1 ) ;
#line 452
int ldv_del_timer_sync_291(struct timer_list *ldv_func_arg1 ) ;
#line 456
int ldv_del_timer_sync_293(struct timer_list *ldv_func_arg1 ) ;
#line 460
int ldv_del_timer_sync_294(struct timer_list *ldv_func_arg1 ) ;
#line 464
int ldv_del_timer_sync_295(struct timer_list *ldv_func_arg1 ) ;
#line 468
int ldv_del_timer_sync_298(struct timer_list *ldv_func_arg1 ) ;
#line 472
int ldv_del_timer_sync_300(struct timer_list *ldv_func_arg1 ) ;
#line 476
int ldv_del_timer_sync_302(struct timer_list *ldv_func_arg1 ) ;
#line 480
int ldv_del_timer_sync_304(struct timer_list *ldv_func_arg1 ) ;
#line 484
int ldv_del_timer_sync_306(struct timer_list *ldv_func_arg1 ) ;
#line 488
int ldv_del_timer_sync_308(struct timer_list *ldv_func_arg1 ) ;
#line 492
int ldv_del_timer_sync_309(struct timer_list *ldv_func_arg1 ) ;
#line 496
int ldv_del_timer_sync_310(struct timer_list *ldv_func_arg1 ) ;
#line 500
int ldv_del_timer_sync_311(struct timer_list *ldv_func_arg1 ) ;
#line 504
int ldv_del_timer_sync_312(struct timer_list *ldv_func_arg1 ) ;
#line 508
int ldv_del_timer_sync_313(struct timer_list *ldv_func_arg1 ) ;
#line 512
int ldv_del_timer_sync_314(struct timer_list *ldv_func_arg1 ) ;
#line 516
int ldv_del_timer_sync_316(struct timer_list *ldv_func_arg1 ) ;
#line 520
int ldv_del_timer_sync_319(struct timer_list *ldv_func_arg1 ) ;
#line 524
int ldv_del_timer_sync_320(struct timer_list *ldv_func_arg1 ) ;
#line 355 "include/linux/workqueue.h"
extern struct workqueue_struct *system_wq ;
#line 530 "include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 532
  tmp = queue_work(system_wq, work);
#line 532
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_200(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 22 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_timer_1_3 ;
#line 56
struct timer_list *ldv_timer_list_1_1 ;
#line 62
int ldv_timer_1_1 ;
#line 99
int ldv_timer_1_0 ;
#line 112
struct timer_list *ldv_timer_list_1_3 ;
#line 114
struct timer_list *ldv_timer_list_1_0 ;
#line 116
int ldv_timer_1_2 ;
#line 120
struct timer_list *ldv_timer_list_1_2 ;
#line 149
void timer_init_1(void) ;
#line 155
int reg_timer_1(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 160
void activate_suitable_timer_1(struct timer_list *timer , unsigned long data ) ;
#line 167
void choose_timer_1(void) ;
#line 186
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 188
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 198
void disable_suitable_timer_1(struct timer_list *timer ) ;
#line 215
void ldv_timer_1(int state , struct timer_list *timer ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_208(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_216(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_210(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_206(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_214(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_215(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_211(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_212(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_213(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 150 "drivers/staging/rtl8723au/include/rtw_led.h"
void LedControl871x23a(struct rtw_adapter *padapter , enum led_ctl_mode LedAction ) ;
#line 164
void BlinkWorkItemCallback23a(struct work_struct *work ) ;
#line 166
void ResetLedStatus23a(struct led_8723a *pLed ) ;
#line 169
void InitLed871x23a(struct rtw_adapter *padapter , struct led_8723a *pLed , enum led_pin_8723a LedPin ) ;
#line 176
void DeInitLed871x23a(struct led_8723a *pLed ) ;
#line 179
void BlinkHandler23a(struct led_8723a *pLed ) ;
#line 27 "drivers/staging/rtl8723au/include/rtl8723a_led.h"
void SwLedOn23a(struct rtw_adapter *padapter , struct led_8723a *pLed ) ;
#line 28
void SwLedOff23a(struct rtw_adapter *padapter , struct led_8723a *pLed ) ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void BlinkTimerCallback(unsigned long data ) 
{ 
  struct led_8723a *pLed ;
  struct rtw_adapter *padapter ;

  {
#line 244
  pLed = (struct led_8723a *)data;
#line 245
  padapter = pLed->padapter;
#line 249
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
#line 252
    return;
  } else {

  }
#line 254
  schedule_work(& pLed->BlinkWorkItem);
#line 255
  return;
}
}
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void BlinkWorkItemCallback23a(struct work_struct *work ) 
{ 
  struct led_8723a *pLed ;
  struct work_struct  const  *__mptr ;

  {
#line 264
  __mptr = (struct work_struct  const  *)work;
#line 264
  pLed = (struct led_8723a *)__mptr + 0xffffffffffffff58UL;
#line 265
  BlinkHandler23a(pLed);
#line 266
  return;
}
}
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void ResetLedStatus23a(struct led_8723a *pLed ) 
{ 


  {
#line 274
  pLed->CurrLedState = 2;
#line 275
  pLed->bLedOn = 0U;
#line 277
  pLed->bLedBlinkInProgress = 0U;
#line 278
  pLed->bLedWPSBlinkInProgress = 0U;
#line 280
  pLed->BlinkTimes = 0U;
#line 281
  pLed->BlinkingLedState = 0;
#line 283
  pLed->bLedNoLinkBlinkInProgress = 0U;
#line 284
  pLed->bLedLinkBlinkInProgress = 0U;
#line 285
  pLed->bLedStartToLinkBlinkInProgress = 0U;
#line 286
  pLed->bLedScanBlinkInProgress = 0U;
#line 287
  return;
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void InitLed871x23a(struct rtw_adapter *padapter , struct led_8723a *pLed , enum led_pin_8723a LedPin ) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 296
  pLed->padapter = padapter;
#line 297
  pLed->LedPin = LedPin;
#line 299
  ResetLedStatus23a(pLed);
#line 301
  reg_timer_6(& pLed->BlinkTimer, & BlinkTimerCallback, (unsigned long )pLed);
#line 303
  __init_work(& pLed->BlinkWorkItem, 0);
#line 303
  __constr_expr_0.counter = 137438953408L;
#line 303
  pLed->BlinkWorkItem.data = __constr_expr_0;
#line 303
  lockdep_init_map(& pLed->BlinkWorkItem.lockdep_map, "(&pLed->BlinkWorkItem)", & __key,
                   0);
#line 303
  INIT_LIST_HEAD(& pLed->BlinkWorkItem.entry);
#line 303
  pLed->BlinkWorkItem.func = & BlinkWorkItemCallback23a;
#line 305
  return;
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void DeInitLed871x23a(struct led_8723a *pLed ) 
{ 


  {
#line 313
  cancel_work_sync(& pLed->BlinkWorkItem);
#line 314
  ldv_del_timer_sync_217(& pLed->BlinkTimer);
#line 315
  ResetLedStatus23a(pLed);
#line 316
  return;
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedBlink(struct led_8723a *pLed ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  u8 bStopBlinking ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;

  {
#line 324
  padapter = pLed->padapter;
#line 325
  pmlmepriv = & padapter->mlmepriv;
#line 326
  bStopBlinking = 0U;
#line 329
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 330
    SwLedOn23a(padapter, pLed);
#line 331
    if (GlobalDebugLevel23A > 6U) {
#line 331
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 331
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {

    }
  } else {
#line 333
    SwLedOff23a(padapter, pLed);
#line 334
    if (GlobalDebugLevel23A > 6U) {
#line 334
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 334
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {

    }
  }
#line 338
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 339
  switch ((unsigned int )pLed->CurrLedState) {
  case 3U: ;
#line 342
  if (pLed->BlinkTimes == 0U) {
#line 343
    bStopBlinking = 1U;
  } else {

  }
#line 344
  goto ldv_51938;
  case 8U: 
#line 346
  tmp = check_fwstate(pmlmepriv, 1);
#line 346
  if ((int )tmp) {
#line 346
    tmp___0 = check_fwstate(pmlmepriv, 8);
#line 346
    if ((int )tmp___0) {
#line 348
      bStopBlinking = 1U;
    } else {

    }
  } else {

  }
#line 349
  tmp___1 = check_fwstate(pmlmepriv, 1);
#line 349
  if ((int )tmp___1) {
#line 349
    tmp___2 = check_fwstate(pmlmepriv, 32);
#line 349
    if ((int )tmp___2) {
#line 352
      bStopBlinking = 1U;
    } else {
#line 349
      tmp___3 = check_fwstate(pmlmepriv, 64);
#line 349
      if ((int )tmp___3) {
#line 352
        bStopBlinking = 1U;
      } else {
#line 349
        goto _L;
      }
    }
  } else
  _L: /* CIL Label */ 
#line 353
  if (pLed->BlinkTimes == 0U) {
#line 354
    bStopBlinking = 1U;
  } else {

  }
#line 355
  goto ldv_51938;
  case 10U: ;
#line 357
  if (pLed->BlinkTimes == 0U) {
#line 358
    bStopBlinking = 1U;
  } else {

  }
#line 359
  goto ldv_51938;
  default: 
#line 361
  bStopBlinking = 1U;
#line 362
  goto ldv_51938;
  }
  ldv_51938: ;
#line 365
  if ((unsigned int )bStopBlinking != 0U) {
#line 366
    tmp___5 = check_fwstate(pmlmepriv, 1);
#line 366
    if ((int )tmp___5 && (unsigned int )pLed->bLedOn == 0U) {
#line 367
      SwLedOn23a(padapter, pLed);
    } else {
#line 368
      tmp___4 = check_fwstate(pmlmepriv, 1);
#line 368
      if ((int )tmp___4 && (unsigned int )pLed->bLedOn != 0U) {
#line 369
        SwLedOff23a(padapter, pLed);
      } else {

      }
    }
#line 371
    pLed->BlinkTimes = 0U;
#line 372
    pLed->bLedBlinkInProgress = 0U;
  } else {
#line 375
    if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 376
      pLed->BlinkingLedState = 2;
    } else {
#line 378
      pLed->BlinkingLedState = 1;
    }
#line 381
    switch ((unsigned int )pLed->CurrLedState) {
    case 3U: 
#line 383
    tmp___6 = msecs_to_jiffies(100U);
#line 383
    ldv_mod_timer_218(& pLed->BlinkTimer, tmp___6 + (unsigned long )jiffies);
#line 385
    goto ldv_51943;
    case 4U: ;
    case 8U: 
#line 388
    tmp___7 = msecs_to_jiffies(200U);
#line 388
    ldv_mod_timer_219(& pLed->BlinkTimer, tmp___7 + (unsigned long )jiffies);
#line 390
    goto ldv_51943;
    case 10U: 
#line 392
    tmp___8 = msecs_to_jiffies(400U);
#line 392
    ldv_mod_timer_220(& pLed->BlinkTimer, tmp___8 + (unsigned long )jiffies);
#line 394
    goto ldv_51943;
    default: 
#line 396
    tmp___9 = msecs_to_jiffies(200U);
#line 396
    ldv_mod_timer_221(& pLed->BlinkTimer, tmp___9 + (unsigned long )jiffies);
#line 398
    goto ldv_51943;
    }
    ldv_51943: ;
  }
#line 402
  return;
}
}
#line 403 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedBlink1(struct led_8723a *pLed ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  unsigned long delay ;
  u8 bStopBlinking ;
  bool tmp ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 405
  padapter = pLed->padapter;
#line 406
  pmlmepriv = & padapter->mlmepriv;
#line 407
  delay = 0UL;
#line 408
  bStopBlinking = 0U;
#line 411
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 412
    SwLedOn23a(padapter, pLed);
#line 413
    if (GlobalDebugLevel23A > 6U) {
#line 413
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 413
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {

    }
  } else {
#line 416
    SwLedOff23a(padapter, pLed);
#line 417
    if (GlobalDebugLevel23A > 6U) {
#line 417
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 417
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {

    }
  }
#line 421
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 422
    SwLedOff23a(padapter, pLed);
#line 423
    ResetLedStatus23a(pLed);
#line 424
    return;
  } else {

  }
#line 426
  switch ((unsigned int )pLed->CurrLedState) {
  case 4U: ;
#line 428
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 429
    pLed->BlinkingLedState = 2;
  } else {
#line 431
    pLed->BlinkingLedState = 1;
  }
#line 432
  delay = 1000UL;
#line 433
  goto ldv_51956;
  case 3U: ;
#line 435
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 436
    pLed->BlinkingLedState = 2;
  } else {
#line 438
    pLed->BlinkingLedState = 1;
  }
#line 439
  delay = 500UL;
#line 440
  goto ldv_51956;
  case 6U: 
#line 442
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 443
  if (pLed->BlinkTimes == 0U) {
#line 444
    bStopBlinking = 1U;
  } else {

  }
#line 445
  if ((unsigned int )bStopBlinking != 0U) {
#line 446
    tmp = check_fwstate(pmlmepriv, 1);
#line 446
    if ((int )tmp) {
#line 447
      pLed->bLedLinkBlinkInProgress = 1U;
#line 448
      pLed->CurrLedState = 3;
#line 449
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 450
        pLed->BlinkingLedState = 2;
      } else {
#line 452
        pLed->BlinkingLedState = 1;
      }
#line 453
      delay = 500UL;
#line 454
      if (GlobalDebugLevel23A > 6U) {
#line 454
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 454
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {

      }
    } else {
#line 456
      pLed->bLedNoLinkBlinkInProgress = 1U;
#line 457
      pLed->CurrLedState = 4;
#line 458
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 459
        pLed->BlinkingLedState = 2;
      } else {
#line 461
        pLed->BlinkingLedState = 1;
      }
#line 462
      delay = 1000UL;
#line 463
      if (GlobalDebugLevel23A > 6U) {
#line 463
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 463
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {

      }
    }
#line 465
    pLed->bLedScanBlinkInProgress = 0U;
  } else {
#line 467
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 468
      pLed->BlinkingLedState = 2;
    } else {
#line 470
      pLed->BlinkingLedState = 1;
    }
#line 471
    delay = 180UL;
  }
#line 473
  goto ldv_51956;
  case 9U: 
#line 475
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 476
  if (pLed->BlinkTimes == 0U) {
#line 477
    bStopBlinking = 1U;
  } else {

  }
#line 478
  if ((unsigned int )bStopBlinking != 0U) {
#line 479
    tmp___0 = check_fwstate(pmlmepriv, 1);
#line 479
    if ((int )tmp___0) {
#line 480
      pLed->bLedLinkBlinkInProgress = 1U;
#line 481
      pLed->CurrLedState = 3;
#line 482
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 483
        pLed->BlinkingLedState = 2;
      } else {
#line 485
        pLed->BlinkingLedState = 1;
      }
#line 486
      delay = 500UL;
#line 487
      if (GlobalDebugLevel23A > 6U) {
#line 487
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 487
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {

      }
    } else {
#line 489
      pLed->bLedNoLinkBlinkInProgress = 1U;
#line 490
      pLed->CurrLedState = 4;
#line 491
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 492
        pLed->BlinkingLedState = 2;
      } else {
#line 494
        pLed->BlinkingLedState = 1;
      }
#line 495
      delay = 1000UL;
#line 496
      if (GlobalDebugLevel23A > 6U) {
#line 496
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 496
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {

      }
    }
#line 498
    pLed->BlinkTimes = 0U;
#line 499
    pLed->bLedBlinkInProgress = 0U;
  } else {
#line 501
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 502
      pLed->BlinkingLedState = 2;
    } else {
#line 504
      pLed->BlinkingLedState = 1;
    }
#line 505
    delay = 50UL;
  }
#line 507
  goto ldv_51956;
  case 10U: ;
#line 509
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 510
    pLed->BlinkingLedState = 2;
  } else {
#line 512
    pLed->BlinkingLedState = 1;
  }
#line 513
  delay = 180UL;
#line 514
  goto ldv_51956;
  case 11U: ;
#line 516
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 517
    bStopBlinking = 0U;
  } else {
#line 519
    bStopBlinking = 1U;
  }
#line 520
  if ((unsigned int )bStopBlinking != 0U) {
#line 521
    pLed->bLedLinkBlinkInProgress = 1U;
#line 522
    pLed->CurrLedState = 3;
#line 523
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 524
      pLed->BlinkingLedState = 2;
    } else {
#line 526
      pLed->BlinkingLedState = 1;
    }
#line 527
    delay = 500UL;
#line 528
    if (GlobalDebugLevel23A > 6U) {
#line 528
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 528
      printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
    } else {

    }
#line 530
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
#line 532
    pLed->BlinkingLedState = 2;
#line 533
    delay = 5000UL;
  }
#line 535
  goto ldv_51956;
  default: ;
#line 537
  goto ldv_51956;
  }
  ldv_51956: ;
#line 539
  if (delay != 0UL) {
#line 540
    tmp___1 = msecs_to_jiffies((unsigned int const   )delay);
#line 540
    ldv_mod_timer_222(& pLed->BlinkTimer, tmp___1 + (unsigned long )jiffies);
  } else {

  }
#line 541
  return;
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedBlink2(struct led_8723a *pLed ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  u8 bStopBlinking ;
  bool tmp ;
  unsigned long tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 545
  padapter = pLed->padapter;
#line 546
  pmlmepriv = & padapter->mlmepriv;
#line 547
  bStopBlinking = 0U;
#line 550
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 551
    SwLedOn23a(padapter, pLed);
#line 552
    if (GlobalDebugLevel23A > 6U) {
#line 552
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 552
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {

    }
  } else {
#line 555
    SwLedOff23a(padapter, pLed);
#line 556
    if (GlobalDebugLevel23A > 6U) {
#line 556
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 556
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {

    }
  }
#line 559
  switch ((unsigned int )pLed->CurrLedState) {
  case 6U: 
#line 561
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 562
  if (pLed->BlinkTimes == 0U) {
#line 563
    bStopBlinking = 1U;
  } else {

  }
#line 564
  if ((unsigned int )bStopBlinking != 0U) {
#line 565
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 566
      SwLedOff23a(padapter, pLed);
    } else {
#line 567
      tmp = check_fwstate(pmlmepriv, 1);
#line 567
      if ((int )tmp) {
#line 568
        pLed->CurrLedState = 1;
#line 569
        pLed->BlinkingLedState = 1;
#line 570
        SwLedOn23a(padapter, pLed);
#line 571
        if (GlobalDebugLevel23A > 6U) {
#line 571
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 571
          printk("\016stop scan blink CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {

        }
      } else {
#line 575
        pLed->CurrLedState = 2;
#line 576
        pLed->BlinkingLedState = 2;
#line 577
        SwLedOff23a(padapter, pLed);
#line 578
        if (GlobalDebugLevel23A > 6U) {
#line 578
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 578
          printk("\016stop scan blink CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {

        }
      }
    }
#line 582
    pLed->bLedScanBlinkInProgress = 0U;
  } else
#line 584
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 585
    SwLedOff23a(padapter, pLed);
  } else {
#line 587
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 588
      pLed->BlinkingLedState = 2;
    } else {
#line 590
      pLed->BlinkingLedState = 1;
    }
#line 591
    tmp___0 = msecs_to_jiffies(180U);
#line 591
    ldv_mod_timer_223(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  }
#line 595
  goto ldv_51970;
  case 9U: 
#line 597
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 598
  if (pLed->BlinkTimes == 0U) {
#line 599
    bStopBlinking = 1U;
  } else {

  }
#line 600
  if ((unsigned int )bStopBlinking != 0U) {
#line 601
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 602
      SwLedOff23a(padapter, pLed);
    } else {
#line 603
      tmp___1 = check_fwstate(pmlmepriv, 1);
#line 603
      if ((int )tmp___1) {
#line 604
        pLed->CurrLedState = 1;
#line 605
        pLed->BlinkingLedState = 1;
#line 606
        SwLedOn23a(padapter, pLed);
#line 607
        if (GlobalDebugLevel23A > 6U) {
#line 607
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 607
          printk("\016stop CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {

        }
      } else {
#line 611
        pLed->CurrLedState = 2;
#line 612
        pLed->BlinkingLedState = 2;
#line 613
        SwLedOff23a(padapter, pLed);
#line 614
        if (GlobalDebugLevel23A > 6U) {
#line 614
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 614
          printk("\016stop CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {

        }
      }
    }
#line 617
    pLed->bLedBlinkInProgress = 0U;
  } else
#line 619
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 620
    SwLedOff23a(padapter, pLed);
  } else {
#line 622
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 623
      pLed->BlinkingLedState = 2;
    } else {
#line 625
      pLed->BlinkingLedState = 1;
    }
#line 626
    tmp___2 = msecs_to_jiffies(50U);
#line 626
    ldv_mod_timer_224(& pLed->BlinkTimer, tmp___2 + (unsigned long )jiffies);
  }
#line 630
  goto ldv_51970;
  default: ;
#line 632
  goto ldv_51970;
  }
  ldv_51970: ;
#line 635
  return;
}
}
#line 636 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedBlink3(struct led_8723a *pLed ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  u8 bStopBlinking ;
  bool tmp ;
  unsigned long tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 638
  padapter = pLed->padapter;
#line 639
  pmlmepriv = & padapter->mlmepriv;
#line 640
  bStopBlinking = 0U;
#line 643
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 645
    SwLedOn23a(padapter, pLed);
#line 646
    if (GlobalDebugLevel23A > 6U) {
#line 646
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 646
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {

    }
  } else {
#line 650
    if ((unsigned int )pLed->CurrLedState != 11U) {
#line 651
      SwLedOff23a(padapter, pLed);
    } else {

    }
#line 652
    if (GlobalDebugLevel23A > 6U) {
#line 652
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 652
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {

    }
  }
#line 655
  switch ((unsigned int )pLed->CurrLedState) {
  case 6U: 
#line 658
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 659
  if (pLed->BlinkTimes == 0U) {
#line 661
    bStopBlinking = 1U;
  } else {

  }
#line 664
  if ((unsigned int )bStopBlinking != 0U) {
#line 666
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 668
      SwLedOff23a(padapter, pLed);
    } else {
#line 670
      tmp = check_fwstate(pmlmepriv, 1);
#line 670
      if ((int )tmp) {
#line 671
        pLed->CurrLedState = 1;
#line 672
        pLed->BlinkingLedState = 1;
#line 673
        if ((unsigned int )pLed->bLedOn == 0U) {
#line 674
          SwLedOn23a(padapter, pLed);
        } else {

        }
#line 676
        if (GlobalDebugLevel23A > 6U) {
#line 676
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 676
          printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {

        }
      } else {
#line 678
        pLed->CurrLedState = 2;
#line 679
        pLed->BlinkingLedState = 2;
#line 680
        if ((unsigned int )pLed->bLedOn != 0U) {
#line 681
          SwLedOff23a(padapter, pLed);
        } else {

        }
#line 683
        if (GlobalDebugLevel23A > 6U) {
#line 683
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 683
          printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {

        }
      }
    }
#line 685
    pLed->bLedScanBlinkInProgress = 0U;
  } else
#line 689
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 691
    SwLedOff23a(padapter, pLed);
  } else {
#line 695
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 696
      pLed->BlinkingLedState = 2;
    } else {
#line 698
      pLed->BlinkingLedState = 1;
    }
#line 699
    tmp___0 = msecs_to_jiffies(180U);
#line 699
    ldv_mod_timer_225(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  }
#line 703
  goto ldv_51980;
  case 9U: 
#line 706
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 707
  if (pLed->BlinkTimes == 0U) {
#line 709
    bStopBlinking = 1U;
  } else {

  }
#line 711
  if ((unsigned int )bStopBlinking != 0U) {
#line 713
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 715
      SwLedOff23a(padapter, pLed);
    } else {
#line 716
      tmp___1 = check_fwstate(pmlmepriv, 1);
#line 716
      if ((int )tmp___1) {
#line 718
        pLed->CurrLedState = 1;
#line 719
        pLed->BlinkingLedState = 1;
#line 721
        if ((unsigned int )pLed->bLedOn == 0U) {
#line 722
          SwLedOn23a(padapter, pLed);
        } else {

        }
#line 724
        if (GlobalDebugLevel23A > 6U) {
#line 724
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 724
          printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {

        }
      } else {
#line 726
        pLed->CurrLedState = 2;
#line 727
        pLed->BlinkingLedState = 2;
#line 729
        if ((unsigned int )pLed->bLedOn != 0U) {
#line 730
          SwLedOff23a(padapter, pLed);
        } else {

        }
#line 732
        if (GlobalDebugLevel23A > 6U) {
#line 732
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 732
          printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
        } else {

        }
      }
    }
#line 734
    pLed->bLedBlinkInProgress = 0U;
  } else
#line 738
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 740
    SwLedOff23a(padapter, pLed);
  } else {
#line 744
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 745
      pLed->BlinkingLedState = 2;
    } else {
#line 747
      pLed->BlinkingLedState = 1;
    }
#line 748
    tmp___2 = msecs_to_jiffies(50U);
#line 748
    ldv_mod_timer_226(& pLed->BlinkTimer, tmp___2 + (unsigned long )jiffies);
  }
#line 752
  goto ldv_51980;
  case 10U: ;
#line 755
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 756
    pLed->BlinkingLedState = 2;
  } else {
#line 758
    pLed->BlinkingLedState = 1;
  }
#line 759
  tmp___3 = msecs_to_jiffies(180U);
#line 759
  ldv_mod_timer_227(& pLed->BlinkTimer, tmp___3 + (unsigned long )jiffies);
#line 761
  goto ldv_51980;
  case 11U: ;
#line 764
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 766
    pLed->BlinkingLedState = 2;
#line 767
    tmp___4 = msecs_to_jiffies(5000U);
#line 767
    ldv_mod_timer_228(& pLed->BlinkTimer, tmp___4 + (unsigned long )jiffies);
#line 769
    bStopBlinking = 0U;
  } else {
#line 771
    bStopBlinking = 1U;
  }
#line 774
  if ((unsigned int )bStopBlinking != 0U) {
#line 776
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 778
      SwLedOff23a(padapter, pLed);
    } else {
#line 782
      pLed->CurrLedState = 1;
#line 783
      pLed->BlinkingLedState = 1;
#line 784
      SwLedOn23a(padapter, pLed);
#line 785
      if (GlobalDebugLevel23A > 6U) {
#line 785
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 785
        printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
      } else {

      }
    }
#line 787
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 789
  goto ldv_51980;
  default: ;
#line 792
  goto ldv_51980;
  }
  ldv_51980: ;
#line 795
  return;
}
}
#line 796 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedBlink4(struct led_8723a *pLed ) 
{ 
  struct rtw_adapter *padapter ;
  struct led_priv *ledpriv ;
  struct led_8723a *pLed1 ;
  u8 bStopBlinking ;
  unsigned long delay ;
  unsigned long tmp ;

  {
#line 798
  padapter = pLed->padapter;
#line 799
  ledpriv = & padapter->ledpriv;
#line 800
  pLed1 = & ledpriv->SwLed1;
#line 801
  bStopBlinking = 0U;
#line 802
  delay = 0UL;
#line 805
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 807
    SwLedOn23a(padapter, pLed);
#line 808
    if (GlobalDebugLevel23A > 6U) {
#line 808
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 808
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {

    }
  } else {
#line 810
    SwLedOff23a(padapter, pLed);
#line 811
    if (GlobalDebugLevel23A > 6U) {
#line 811
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 811
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {

    }
  }
#line 814
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress == 0U && (unsigned int )pLed1->BlinkingLedState == 0U) {
#line 816
    pLed1->BlinkingLedState = 2;
#line 817
    pLed1->CurrLedState = 2;
#line 818
    SwLedOff23a(padapter, pLed1);
  } else {

  }
#line 821
  switch ((unsigned int )pLed->CurrLedState) {
  case 4U: ;
#line 824
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 825
    pLed->BlinkingLedState = 2;
  } else {
#line 827
    pLed->BlinkingLedState = 1;
  }
#line 828
  delay = 1000UL;
#line 829
  goto ldv_51994;
  case 8U: ;
#line 832
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 833
    pLed->BlinkingLedState = 2;
#line 834
    delay = 200UL;
  } else {
#line 836
    pLed->BlinkingLedState = 1;
#line 837
    delay = 100UL;
  }
#line 839
  goto ldv_51994;
  case 6U: 
#line 842
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 843
  if (pLed->BlinkTimes == 0U) {
#line 844
    bStopBlinking = 0U;
  } else {

  }
#line 847
  if ((unsigned int )bStopBlinking != 0U) {
#line 848
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
#line 849
      SwLedOff23a(padapter, pLed);
    } else {
#line 851
      pLed->bLedNoLinkBlinkInProgress = 0U;
#line 852
      pLed->CurrLedState = 4;
#line 853
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 854
        pLed->BlinkingLedState = 2;
      } else {
#line 856
        pLed->BlinkingLedState = 1;
      }
#line 857
      delay = 1000UL;
    }
#line 859
    pLed->bLedScanBlinkInProgress = 0U;
  } else
#line 861
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
#line 862
    SwLedOff23a(padapter, pLed);
  } else {
#line 864
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 865
      pLed->BlinkingLedState = 2;
    } else {
#line 867
      pLed->BlinkingLedState = 1;
    }
#line 868
    delay = 180UL;
  }
#line 871
  goto ldv_51994;
  case 9U: 
#line 874
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 875
  if (pLed->BlinkTimes == 0U) {
#line 876
    bStopBlinking = 1U;
  } else {

  }
#line 878
  if ((unsigned int )bStopBlinking != 0U) {
#line 879
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
#line 880
      SwLedOff23a(padapter, pLed);
    } else {
#line 882
      pLed->bLedNoLinkBlinkInProgress = 1U;
#line 883
      pLed->CurrLedState = 4;
#line 884
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 885
        pLed->BlinkingLedState = 2;
      } else {
#line 887
        pLed->BlinkingLedState = 1;
      }
#line 888
      delay = 1000UL;
    }
#line 890
    pLed->bLedBlinkInProgress = 0U;
  } else
#line 892
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
#line 893
    SwLedOff23a(padapter, pLed);
  } else {
#line 895
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 896
      pLed->BlinkingLedState = 2;
    } else {
#line 898
      pLed->BlinkingLedState = 1;
    }
#line 899
    delay = 50UL;
  }
#line 902
  goto ldv_51994;
  case 10U: ;
#line 905
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 906
    pLed->BlinkingLedState = 2;
#line 907
    delay = 200UL;
  } else {
#line 909
    pLed->BlinkingLedState = 1;
#line 910
    delay = 100UL;
  }
#line 912
  goto ldv_51994;
  case 11U: ;
#line 915
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 916
    pLed->BlinkingLedState = 2;
  } else {
#line 918
    pLed->BlinkingLedState = 1;
  }
#line 920
  delay = 100UL;
#line 921
  goto ldv_51994;
  case 12U: 
#line 924
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 925
  if (pLed->BlinkTimes == 0U) {
#line 926
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 927
      pLed->BlinkTimes = 1U;
    } else {
#line 929
      bStopBlinking = 1U;
    }
  } else {

  }
#line 933
  if ((unsigned int )bStopBlinking != 0U) {
#line 934
    pLed->BlinkTimes = 10U;
#line 935
    pLed->BlinkingLedState = 1;
#line 936
    delay = 500UL;
  } else {
#line 938
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 939
      pLed->BlinkingLedState = 2;
    } else {
#line 941
      pLed->BlinkingLedState = 1;
    }
#line 943
    delay = 100UL;
  }
#line 945
  goto ldv_51994;
  default: ;
#line 948
  goto ldv_51994;
  }
  ldv_51994: ;
#line 950
  if (delay != 0UL) {
#line 951
    tmp = msecs_to_jiffies((unsigned int const   )delay);
#line 951
    ldv_mod_timer_229(& pLed->BlinkTimer, tmp + (unsigned long )jiffies);
  } else {

  }
#line 953
  if (GlobalDebugLevel23A > 6U) {
#line 953
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 953
    printk("\016SwLedBlink4 CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
  } else {

  }
#line 955
  return;
}
}
#line 956 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedBlink5(struct led_8723a *pLed ) 
{ 
  struct rtw_adapter *padapter ;
  u8 bStopBlinking ;
  unsigned long delay ;
  unsigned long tmp ;

  {
#line 958
  padapter = pLed->padapter;
#line 959
  bStopBlinking = 0U;
#line 960
  delay = 0UL;
#line 963
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 964
    SwLedOn23a(padapter, pLed);
#line 965
    if (GlobalDebugLevel23A > 6U) {
#line 965
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 965
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {

    }
  } else {
#line 967
    SwLedOff23a(padapter, pLed);
#line 968
    if (GlobalDebugLevel23A > 6U) {
#line 968
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 968
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {

    }
  }
#line 971
  switch ((unsigned int )pLed->CurrLedState) {
  case 6U: 
#line 974
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 975
  if (pLed->BlinkTimes == 0U) {
#line 976
    bStopBlinking = 1U;
  } else {

  }
#line 979
  if ((unsigned int )bStopBlinking != 0U) {
#line 980
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
#line 981
      pLed->CurrLedState = 2;
#line 982
      pLed->BlinkingLedState = 2;
#line 983
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 984
        SwLedOff23a(padapter, pLed);
      } else {

      }
    } else {
#line 986
      pLed->CurrLedState = 1;
#line 987
      pLed->BlinkingLedState = 1;
#line 988
      if ((unsigned int )pLed->bLedOn == 0U) {
#line 989
        delay = 50UL;
      } else {

      }
    }
#line 992
    pLed->bLedScanBlinkInProgress = 0U;
  } else
#line 994
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
#line 995
    SwLedOff23a(padapter, pLed);
  } else {
#line 997
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 998
      pLed->BlinkingLedState = 2;
    } else {
#line 1000
      pLed->BlinkingLedState = 1;
    }
#line 1001
    delay = 180UL;
  }
#line 1004
  goto ldv_52009;
  case 9U: 
#line 1007
  pLed->BlinkTimes = pLed->BlinkTimes - 1U;
#line 1008
  if (pLed->BlinkTimes == 0U) {
#line 1009
    bStopBlinking = 1U;
  } else {

  }
#line 1012
  if ((unsigned int )bStopBlinking != 0U) {
#line 1013
    if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
#line 1014
      pLed->CurrLedState = 2;
#line 1015
      pLed->BlinkingLedState = 2;
#line 1016
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 1017
        SwLedOff23a(padapter, pLed);
      } else {

      }
    } else {
#line 1019
      pLed->CurrLedState = 1;
#line 1020
      pLed->BlinkingLedState = 1;
#line 1021
      if ((unsigned int )pLed->bLedOn == 0U) {
#line 1022
        delay = 50UL;
      } else {

      }
    }
#line 1025
    pLed->bLedBlinkInProgress = 0U;
  } else
#line 1027
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) {
#line 1028
    SwLedOff23a(padapter, pLed);
  } else {
#line 1030
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1031
      pLed->BlinkingLedState = 2;
    } else {
#line 1033
      pLed->BlinkingLedState = 1;
    }
#line 1034
    delay = 50UL;
  }
#line 1037
  goto ldv_52009;
  default: ;
#line 1040
  goto ldv_52009;
  }
  ldv_52009: ;
#line 1043
  if (delay != 0UL) {
#line 1044
    tmp = msecs_to_jiffies((unsigned int const   )delay);
#line 1044
    ldv_mod_timer_230(& pLed->BlinkTimer, tmp + (unsigned long )jiffies);
  } else {

  }
#line 1046
  if (GlobalDebugLevel23A > 6U) {
#line 1046
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1046
    printk("\016SwLedBlink5 CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
  } else {

  }
#line 1048
  return;
}
}
#line 1049 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedBlink6(struct led_8723a *pLed ) 
{ 
  struct rtw_adapter *padapter ;

  {
#line 1051
  padapter = pLed->padapter;
#line 1054
  if ((unsigned int )pLed->BlinkingLedState == 1U) {
#line 1055
    SwLedOn23a(padapter, pLed);
#line 1056
    if (GlobalDebugLevel23A > 6U) {
#line 1056
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1056
      printk("\016Blinktimes (%d): turn on\n", pLed->BlinkTimes);
    } else {

    }
  } else {
#line 1058
    SwLedOff23a(padapter, pLed);
#line 1059
    if (GlobalDebugLevel23A > 6U) {
#line 1059
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1059
      printk("\016Blinktimes (%d): turn off\n", pLed->BlinkTimes);
    } else {

    }
  }
#line 1061
  if (GlobalDebugLevel23A > 6U) {
#line 1061
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1061
    printk("\016<==== blink6\n");
  } else {

  }
#line 1063
  return;
}
}
#line 1066 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedControlMode1(struct rtw_adapter *padapter , enum led_ctl_mode LedAction ) 
{ 
  struct led_priv *ledpriv ;
  struct led_8723a *pLed ;
  struct mlme_priv *pmlmepriv ;
  long delay ;
  bool tmp ;
  unsigned long tmp___0 ;

  {
#line 1068
  ledpriv = & padapter->ledpriv;
#line 1069
  pLed = & ledpriv->SwLed0;
#line 1070
  pmlmepriv = & padapter->mlmepriv;
#line 1072
  delay = -1L;
#line 1074
  switch ((unsigned int )LedAction) {
  case 1U: ;
  case 8U: ;
  case 3U: ;
#line 1079
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 0U) {
#line 1080
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
#line 1082
      return;
    } else {

    }
#line 1084
    if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
#line 1085
      ldv_del_timer_sync_231(& pLed->BlinkTimer);
#line 1086
      pLed->bLedLinkBlinkInProgress = 0U;
    } else {

    }
#line 1088
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1089
      ldv_del_timer_sync_232(& pLed->BlinkTimer);
#line 1090
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1093
    pLed->bLedNoLinkBlinkInProgress = 1U;
#line 1094
    pLed->CurrLedState = 4;
#line 1095
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1096
      pLed->BlinkingLedState = 2;
    } else {
#line 1098
      pLed->BlinkingLedState = 1;
    }
#line 1099
    delay = 1000L;
  } else {

  }
#line 1101
  goto ldv_52027;
  case 2U: ;
#line 1104
  if ((unsigned int )pLed->bLedLinkBlinkInProgress == 0U) {
#line 1105
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
#line 1107
      return;
    } else {

    }
#line 1109
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
#line 1110
      ldv_del_timer_sync_233(& pLed->BlinkTimer);
#line 1111
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {

    }
#line 1113
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1114
      ldv_del_timer_sync_234(& pLed->BlinkTimer);
#line 1115
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1117
    pLed->bLedLinkBlinkInProgress = 1U;
#line 1118
    pLed->CurrLedState = 3;
#line 1119
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1120
      pLed->BlinkingLedState = 2;
    } else {
#line 1122
      pLed->BlinkingLedState = 1;
    }
#line 1123
    delay = 500L;
  } else {

  }
#line 1125
  goto ldv_52027;
  case 6U: ;
#line 1128
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
#line 1128
    tmp = check_fwstate(pmlmepriv, 1);
#line 1128
    if ((int )tmp) {

    } else {
#line 1128
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1131
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
#line 1132
    if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1133
      return;
    } else {

    }
#line 1135
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
#line 1136
      ldv_del_timer_sync_235(& pLed->BlinkTimer);
#line 1137
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {

    }
#line 1139
    if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
#line 1140
      ldv_del_timer_sync_236(& pLed->BlinkTimer);
#line 1141
      pLed->bLedLinkBlinkInProgress = 0U;
    } else {

    }
#line 1143
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1144
      ldv_del_timer_sync_237(& pLed->BlinkTimer);
#line 1145
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1147
    pLed->bLedScanBlinkInProgress = 1U;
#line 1148
    pLed->CurrLedState = 6;
#line 1149
    pLed->BlinkTimes = 24U;
#line 1150
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1151
      pLed->BlinkingLedState = 2;
    } else {
#line 1153
      pLed->BlinkingLedState = 1;
    }
#line 1154
    delay = 180L;
  } else {

  }
#line 1156
  goto ldv_52027;
  case 4U: ;
  case 5U: ;
#line 1160
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
#line 1161
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
#line 1163
      return;
    } else {

    }
#line 1165
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
#line 1166
      ldv_del_timer_sync_238(& pLed->BlinkTimer);
#line 1167
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {

    }
#line 1169
    if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
#line 1170
      ldv_del_timer_sync_239(& pLed->BlinkTimer);
#line 1171
      pLed->bLedLinkBlinkInProgress = 0U;
    } else {

    }
#line 1173
    pLed->bLedBlinkInProgress = 1U;
#line 1174
    pLed->CurrLedState = 9;
#line 1175
    pLed->BlinkTimes = 2U;
#line 1176
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1177
      pLed->BlinkingLedState = 2;
    } else {
#line 1179
      pLed->BlinkingLedState = 1;
    }
#line 1180
    delay = 50L;
  } else {

  }
#line 1182
  goto ldv_52027;
  case 9U: ;
  case 11U: ;
#line 1186
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U) {
#line 1187
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
#line 1188
      ldv_del_timer_sync_240(& pLed->BlinkTimer);
#line 1189
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {

    }
#line 1191
    if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
#line 1192
      ldv_del_timer_sync_241(& pLed->BlinkTimer);
#line 1193
      pLed->bLedLinkBlinkInProgress = 0U;
    } else {

    }
#line 1195
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1196
      ldv_del_timer_sync_242(& pLed->BlinkTimer);
#line 1197
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1199
    if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
#line 1200
      ldv_del_timer_sync_243(& pLed->BlinkTimer);
#line 1201
      pLed->bLedScanBlinkInProgress = 0U;
    } else {

    }
#line 1203
    pLed->bLedWPSBlinkInProgress = 1U;
#line 1204
    pLed->CurrLedState = 10;
#line 1205
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1206
      pLed->BlinkingLedState = 2;
    } else {
#line 1208
      pLed->BlinkingLedState = 1;
    }
#line 1209
    delay = 180L;
  } else {

  }
#line 1211
  goto ldv_52027;
  case 10U: ;
#line 1214
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
#line 1215
    ldv_del_timer_sync_244(& pLed->BlinkTimer);
#line 1216
    pLed->bLedNoLinkBlinkInProgress = 0U;
  } else {

  }
#line 1218
  if ((unsigned int )pLed->bLedLinkBlinkInProgress == 1U) {
#line 1219
    ldv_del_timer_sync_245(& pLed->BlinkTimer);
#line 1220
    pLed->bLedLinkBlinkInProgress = 0U;
  } else {

  }
#line 1222
  if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1223
    ldv_del_timer_sync_246(& pLed->BlinkTimer);
#line 1224
    pLed->bLedBlinkInProgress = 0U;
  } else {

  }
#line 1226
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
#line 1227
    ldv_del_timer_sync_247(& pLed->BlinkTimer);
#line 1228
    pLed->bLedScanBlinkInProgress = 0U;
  } else {

  }
#line 1230
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1231
    ldv_del_timer_sync_248(& pLed->BlinkTimer);
  } else {
#line 1233
    pLed->bLedWPSBlinkInProgress = 1U;
  }
#line 1236
  pLed->CurrLedState = 11;
#line 1237
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 1238
    pLed->BlinkingLedState = 2;
#line 1239
    delay = 5000L;
  } else {
#line 1241
    pLed->BlinkingLedState = 1;
#line 1242
    delay = 0L;
  }
#line 1244
  goto ldv_52027;
  case 12U: ;
#line 1247
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1248
    ldv_del_timer_sync_249(& pLed->BlinkTimer);
#line 1249
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1252
  pLed->bLedNoLinkBlinkInProgress = 1U;
#line 1253
  pLed->CurrLedState = 4;
#line 1254
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 1255
    pLed->BlinkingLedState = 2;
  } else {
#line 1257
    pLed->BlinkingLedState = 1;
  }
#line 1258
  delay = 1000L;
#line 1259
  goto ldv_52027;
  case 7U: 
#line 1262
  pLed->CurrLedState = 2;
#line 1263
  pLed->BlinkingLedState = 2;
#line 1264
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress != 0U) {
#line 1265
    ldv_del_timer_sync_250(& pLed->BlinkTimer);
#line 1266
    pLed->bLedNoLinkBlinkInProgress = 0U;
  } else {

  }
#line 1268
  if ((unsigned int )pLed->bLedLinkBlinkInProgress != 0U) {
#line 1269
    ldv_del_timer_sync_251(& pLed->BlinkTimer);
#line 1270
    pLed->bLedLinkBlinkInProgress = 0U;
  } else {

  }
#line 1272
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
#line 1273
    ldv_del_timer_sync_252(& pLed->BlinkTimer);
#line 1274
    pLed->bLedBlinkInProgress = 0U;
  } else {

  }
#line 1276
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1277
    ldv_del_timer_sync_253(& pLed->BlinkTimer);
#line 1278
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1280
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
#line 1281
    ldv_del_timer_sync_254(& pLed->BlinkTimer);
#line 1282
    pLed->bLedScanBlinkInProgress = 0U;
  } else {

  }
#line 1285
  SwLedOff23a(padapter, pLed);
#line 1286
  goto ldv_52027;
  default: ;
#line 1289
  goto ldv_52027;
  }
  ldv_52027: ;
#line 1293
  if (delay != -1L) {
#line 1294
    tmp___0 = msecs_to_jiffies((unsigned int const   )delay);
#line 1294
    ldv_mod_timer_255(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
#line 1296
  if (GlobalDebugLevel23A > 6U) {
#line 1296
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1296
    printk("\016Led %d\n", (unsigned int )pLed->CurrLedState);
  } else {

  }
#line 1298
  return;
}
}
#line 1301 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedControlMode2(struct rtw_adapter *padapter , enum led_ctl_mode LedAction ) 
{ 
  struct led_priv *ledpriv ;
  struct mlme_priv *pmlmepriv ;
  struct led_8723a *pLed ;
  long delay ;
  bool tmp ;
  unsigned long tmp___0 ;

  {
#line 1303
  ledpriv = & padapter->ledpriv;
#line 1304
  pmlmepriv = & padapter->mlmepriv;
#line 1305
  pLed = & ledpriv->SwLed0;
#line 1306
  delay = -1L;
#line 1308
  switch ((unsigned int )LedAction) {
  case 6U: ;
#line 1310
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {

  } else
#line 1312
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
#line 1313
    if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1314
      return;
    } else {

    }
#line 1316
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1317
      ldv_del_timer_sync_256(& pLed->BlinkTimer);
#line 1318
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1320
    pLed->bLedScanBlinkInProgress = 1U;
#line 1321
    pLed->CurrLedState = 6;
#line 1322
    pLed->BlinkTimes = 24U;
#line 1323
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1324
      pLed->BlinkingLedState = 2;
    } else {
#line 1326
      pLed->BlinkingLedState = 1;
    }
#line 1327
    delay = 180L;
  } else {

  }
#line 1329
  goto ldv_52047;
  case 4U: ;
  case 5U: ;
#line 1332
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
#line 1332
    tmp = check_fwstate(pmlmepriv, 1);
#line 1332
    if ((int )tmp) {
#line 1334
      if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
#line 1336
        return;
      } else {

      }
#line 1339
      pLed->bLedBlinkInProgress = 1U;
#line 1340
      pLed->CurrLedState = 9;
#line 1341
      pLed->BlinkTimes = 2U;
#line 1342
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 1343
        pLed->BlinkingLedState = 2;
      } else {
#line 1345
        pLed->BlinkingLedState = 1;
      }
#line 1346
      delay = 50L;
    } else {

    }
  } else {

  }
#line 1348
  goto ldv_52047;
  case 2U: 
#line 1350
  pLed->CurrLedState = 1;
#line 1351
  pLed->BlinkingLedState = 1;
#line 1352
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
#line 1353
    ldv_del_timer_sync_257(& pLed->BlinkTimer);
#line 1354
    pLed->bLedBlinkInProgress = 0U;
  } else {

  }
#line 1356
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
#line 1357
    ldv_del_timer_sync_258(& pLed->BlinkTimer);
#line 1358
    pLed->bLedScanBlinkInProgress = 0U;
  } else {

  }
#line 1361
  delay = 0L;
#line 1362
  goto ldv_52047;
  case 9U: ;
  case 11U: ;
#line 1365
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U) {
#line 1366
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1367
      ldv_del_timer_sync_259(& pLed->BlinkTimer);
#line 1368
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1370
    if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
#line 1371
      ldv_del_timer_sync_260(& pLed->BlinkTimer);
#line 1372
      pLed->bLedScanBlinkInProgress = 0U;
    } else {

    }
#line 1374
    pLed->bLedWPSBlinkInProgress = 1U;
#line 1375
    pLed->CurrLedState = 1;
#line 1376
    pLed->BlinkingLedState = 1;
#line 1377
    delay = 0L;
  } else {

  }
#line 1379
  goto ldv_52047;
  case 10U: 
#line 1381
  pLed->bLedWPSBlinkInProgress = 0U;
#line 1382
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 1383
    SwLedOff23a(padapter, pLed);
  } else {
#line 1385
    pLed->CurrLedState = 1;
#line 1386
    pLed->BlinkingLedState = 1;
#line 1387
    delay = 0L;
#line 1388
    if (GlobalDebugLevel23A > 6U) {
#line 1388
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1388
      printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
    } else {

    }
  }
#line 1390
  goto ldv_52047;
  case 12U: 
#line 1392
  pLed->bLedWPSBlinkInProgress = 0U;
#line 1393
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U) {
#line 1394
    SwLedOff23a(padapter, pLed);
  } else {
#line 1396
    pLed->CurrLedState = 2;
#line 1397
    pLed->BlinkingLedState = 2;
#line 1398
    delay = 0L;
#line 1399
    if (GlobalDebugLevel23A > 6U) {
#line 1399
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1399
      printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
    } else {

    }
  }
#line 1401
  goto ldv_52047;
  case 8U: ;
  case 3U: ;
#line 1404
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U && (unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
#line 1406
    pLed->CurrLedState = 2;
#line 1407
    pLed->BlinkingLedState = 2;
#line 1408
    delay = 0L;
  } else {

  }
#line 1410
  goto ldv_52047;
  case 7U: 
#line 1412
  pLed->CurrLedState = 2;
#line 1413
  pLed->BlinkingLedState = 2;
#line 1414
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
#line 1415
    ldv_del_timer_sync_261(& pLed->BlinkTimer);
#line 1416
    pLed->bLedBlinkInProgress = 0U;
  } else {

  }
#line 1418
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
#line 1419
    ldv_del_timer_sync_262(& pLed->BlinkTimer);
#line 1420
    pLed->bLedScanBlinkInProgress = 0U;
  } else {

  }
#line 1422
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1423
    ldv_del_timer_sync_263(& pLed->BlinkTimer);
#line 1424
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1427
  delay = 0L;
#line 1428
  goto ldv_52047;
  default: ;
#line 1430
  goto ldv_52047;
  }
  ldv_52047: ;
#line 1434
  if (delay != -1L) {
#line 1435
    tmp___0 = msecs_to_jiffies((unsigned int const   )delay);
#line 1435
    ldv_mod_timer_264(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
#line 1437
  if (GlobalDebugLevel23A > 6U) {
#line 1437
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1437
    printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
  } else {

  }
#line 1439
  return;
}
}
#line 1442 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedControlMode3(struct rtw_adapter *padapter , enum led_ctl_mode LedAction ) 
{ 
  struct led_priv *ledpriv ;
  struct mlme_priv *pmlmepriv ;
  struct led_8723a *pLed ;
  long delay ;
  bool tmp ;
  unsigned long tmp___0 ;

  {
#line 1444
  ledpriv = & padapter->ledpriv;
#line 1445
  pmlmepriv = & padapter->mlmepriv;
#line 1446
  pLed = & ledpriv->SwLed0;
#line 1447
  delay = -1L;
#line 1449
  switch ((unsigned int )LedAction) {
  case 6U: ;
#line 1452
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {

  } else
#line 1454
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
#line 1455
    if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1456
      return;
    } else {

    }
#line 1458
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1459
      ldv_del_timer_sync_265(& pLed->BlinkTimer);
#line 1460
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1462
    pLed->bLedScanBlinkInProgress = 1U;
#line 1463
    pLed->CurrLedState = 6;
#line 1464
    pLed->BlinkTimes = 24U;
#line 1465
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1466
      pLed->BlinkingLedState = 2;
    } else {
#line 1468
      pLed->BlinkingLedState = 1;
    }
#line 1469
    delay = 180L;
  } else {

  }
#line 1471
  goto ldv_52068;
  case 4U: ;
  case 5U: ;
#line 1475
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
#line 1475
    tmp = check_fwstate(pmlmepriv, 1);
#line 1475
    if ((int )tmp) {
#line 1477
      if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
#line 1479
        return;
      } else {

      }
#line 1482
      pLed->bLedBlinkInProgress = 1U;
#line 1483
      pLed->CurrLedState = 9;
#line 1484
      pLed->BlinkTimes = 2U;
#line 1485
      if ((unsigned int )pLed->bLedOn != 0U) {
#line 1486
        pLed->BlinkingLedState = 2;
      } else {
#line 1488
        pLed->BlinkingLedState = 1;
      }
#line 1489
      delay = 50L;
    } else {

    }
  } else {

  }
#line 1491
  goto ldv_52068;
  case 2U: ;
#line 1494
  if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1495
    return;
  } else {

  }
#line 1497
  pLed->CurrLedState = 1;
#line 1498
  pLed->BlinkingLedState = 1;
#line 1499
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
#line 1500
    ldv_del_timer_sync_266(& pLed->BlinkTimer);
#line 1501
    pLed->bLedBlinkInProgress = 0U;
  } else {

  }
#line 1503
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
#line 1504
    ldv_del_timer_sync_267(& pLed->BlinkTimer);
#line 1505
    pLed->bLedScanBlinkInProgress = 0U;
  } else {

  }
#line 1508
  delay = 0L;
#line 1509
  goto ldv_52068;
  case 9U: ;
  case 11U: ;
#line 1513
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U) {
#line 1514
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1515
      ldv_del_timer_sync_268(& pLed->BlinkTimer);
#line 1516
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1518
    if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
#line 1519
      ldv_del_timer_sync_269(& pLed->BlinkTimer);
#line 1520
      pLed->bLedScanBlinkInProgress = 0U;
    } else {

    }
#line 1522
    pLed->bLedWPSBlinkInProgress = 1U;
#line 1523
    pLed->CurrLedState = 10;
#line 1524
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1525
      pLed->BlinkingLedState = 2;
    } else {
#line 1527
      pLed->BlinkingLedState = 1;
    }
#line 1528
    delay = 180L;
  } else {

  }
#line 1530
  goto ldv_52068;
  case 10U: ;
#line 1533
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1534
    ldv_del_timer_sync_270(& pLed->BlinkTimer);
#line 1535
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {
#line 1537
    pLed->bLedWPSBlinkInProgress = 1U;
  }
#line 1540
  pLed->CurrLedState = 11;
#line 1541
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 1542
    pLed->BlinkingLedState = 2;
#line 1543
    delay = 5000L;
  } else {
#line 1545
    pLed->BlinkingLedState = 1;
#line 1546
    delay = 0L;
  }
#line 1549
  goto ldv_52068;
  case 12U: ;
#line 1552
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1553
    ldv_del_timer_sync_271(& pLed->BlinkTimer);
#line 1554
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1557
  pLed->CurrLedState = 2;
#line 1558
  pLed->BlinkingLedState = 2;
#line 1559
  delay = 0L;
#line 1560
  goto ldv_52068;
  case 8U: ;
  case 3U: ;
#line 1564
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U && (unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
#line 1566
    pLed->CurrLedState = 2;
#line 1567
    pLed->BlinkingLedState = 2;
#line 1568
    delay = 0L;
  } else {

  }
#line 1570
  goto ldv_52068;
  case 7U: 
#line 1573
  pLed->CurrLedState = 2;
#line 1574
  pLed->BlinkingLedState = 2;
#line 1575
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
#line 1576
    ldv_del_timer_sync_272(& pLed->BlinkTimer);
#line 1577
    pLed->bLedBlinkInProgress = 0U;
  } else {

  }
#line 1579
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
#line 1580
    ldv_del_timer_sync_273(& pLed->BlinkTimer);
#line 1581
    pLed->bLedScanBlinkInProgress = 0U;
  } else {

  }
#line 1583
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1584
    ldv_del_timer_sync_274(& pLed->BlinkTimer);
#line 1585
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1588
  delay = 0L;
#line 1589
  goto ldv_52068;
  default: ;
#line 1592
  goto ldv_52068;
  }
  ldv_52068: ;
#line 1596
  if (delay != -1L) {
#line 1597
    tmp___0 = msecs_to_jiffies((unsigned int const   )delay);
#line 1597
    ldv_mod_timer_275(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
#line 1599
  if (GlobalDebugLevel23A > 6U) {
#line 1599
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1599
    printk("\016CurrLedState %d\n", (unsigned int )pLed->CurrLedState);
  } else {

  }
#line 1601
  return;
}
}
#line 1604 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedControlMode4(struct rtw_adapter *padapter , enum led_ctl_mode LedAction ) 
{ 
  struct led_priv *ledpriv ;
  struct mlme_priv *pmlmepriv ;
  struct led_8723a *pLed ;
  struct led_8723a *pLed1 ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  bool tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;

  {
#line 1606
  ledpriv = & padapter->ledpriv;
#line 1607
  pmlmepriv = & padapter->mlmepriv;
#line 1608
  pLed = & ledpriv->SwLed0;
#line 1609
  pLed1 = & ledpriv->SwLed1;
#line 1611
  switch ((unsigned int )LedAction) {
  case 8U: ;
#line 1614
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
#line 1615
    pLed1->bLedWPSBlinkInProgress = 0U;
#line 1616
    ldv_del_timer_sync_276(& pLed1->BlinkTimer);
#line 1618
    pLed1->BlinkingLedState = 2;
#line 1619
    pLed1->CurrLedState = 2;
#line 1621
    if ((unsigned int )pLed1->bLedOn != 0U) {
#line 1622
      ldv_mod_timer_277(& pLed->BlinkTimer, jiffies);
    } else {

    }
  } else {

  }
#line 1625
  if ((unsigned int )pLed->bLedStartToLinkBlinkInProgress == 0U) {
#line 1626
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
#line 1628
      return;
    } else {

    }
#line 1630
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1631
      ldv_del_timer_sync_278(& pLed->BlinkTimer);
#line 1632
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1634
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
#line 1635
      ldv_del_timer_sync_279(& pLed->BlinkTimer);
#line 1636
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {

    }
#line 1639
    pLed->bLedStartToLinkBlinkInProgress = 1U;
#line 1640
    pLed->CurrLedState = 8;
#line 1641
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1642
      pLed->BlinkingLedState = 2;
#line 1643
      tmp = msecs_to_jiffies(200U);
#line 1643
      ldv_mod_timer_280(& pLed->BlinkTimer, tmp + (unsigned long )jiffies);
    } else {
#line 1646
      pLed->BlinkingLedState = 1;
#line 1647
      tmp___0 = msecs_to_jiffies(100U);
#line 1647
      ldv_mod_timer_281(& pLed->BlinkTimer, tmp___0 + (unsigned long )jiffies);
    }
  } else {

  }
#line 1651
  goto ldv_52089;
  case 2U: ;
  case 3U: ;
#line 1656
  if ((unsigned int )LedAction == 2U) {
#line 1657
    if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
#line 1658
      pLed1->bLedWPSBlinkInProgress = 0U;
#line 1659
      ldv_del_timer_sync_282(& pLed1->BlinkTimer);
#line 1661
      pLed1->BlinkingLedState = 2;
#line 1662
      pLed1->CurrLedState = 2;
#line 1664
      if ((unsigned int )pLed1->bLedOn != 0U) {
#line 1665
        ldv_mod_timer_283(& pLed->BlinkTimer, jiffies);
      } else {

      }
    } else {

    }
  } else {

  }
#line 1669
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 0U) {
#line 1670
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
#line 1672
      return;
    } else {

    }
#line 1674
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1675
      ldv_del_timer_sync_284(& pLed->BlinkTimer);
#line 1676
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1679
    pLed->bLedNoLinkBlinkInProgress = 1U;
#line 1680
    pLed->CurrLedState = 4;
#line 1681
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1682
      pLed->BlinkingLedState = 2;
    } else {
#line 1684
      pLed->BlinkingLedState = 1;
    }
#line 1685
    tmp___1 = msecs_to_jiffies(1000U);
#line 1685
    ldv_mod_timer_285(& pLed->BlinkTimer, tmp___1 + (unsigned long )jiffies);
  } else {

  }
#line 1688
  goto ldv_52089;
  case 6U: ;
#line 1691
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
#line 1691
    tmp___3 = check_fwstate(pmlmepriv, 1);
#line 1691
    if ((int )tmp___3) {

    } else {
#line 1691
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1694
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
#line 1695
    if (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1696
      return;
    } else {

    }
#line 1698
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
#line 1699
      ldv_del_timer_sync_286(& pLed->BlinkTimer);
#line 1700
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {

    }
#line 1702
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1703
      ldv_del_timer_sync_287(& pLed->BlinkTimer);
#line 1704
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1706
    pLed->bLedScanBlinkInProgress = 1U;
#line 1707
    pLed->CurrLedState = 6;
#line 1708
    pLed->BlinkTimes = 24U;
#line 1709
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1710
      pLed->BlinkingLedState = 2;
    } else {
#line 1712
      pLed->BlinkingLedState = 1;
    }
#line 1713
    tmp___2 = msecs_to_jiffies(180U);
#line 1713
    ldv_mod_timer_288(& pLed->BlinkTimer, tmp___2 + (unsigned long )jiffies);
  } else {

  }
#line 1716
  goto ldv_52089;
  case 4U: ;
  case 5U: ;
#line 1720
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
#line 1721
    if ((unsigned int )pLed->CurrLedState == 6U || (((unsigned int )pLed->CurrLedState == 10U || (unsigned int )pLed->CurrLedState == 11U) || (unsigned int )pLed->bLedWPSBlinkInProgress != 0U)) {
#line 1723
      return;
    } else {

    }
#line 1725
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
#line 1726
      ldv_del_timer_sync_289(& pLed->BlinkTimer);
#line 1727
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {

    }
#line 1729
    pLed->bLedBlinkInProgress = 1U;
#line 1730
    pLed->CurrLedState = 9;
#line 1731
    pLed->BlinkTimes = 2U;
#line 1732
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1733
      pLed->BlinkingLedState = 2;
    } else {
#line 1735
      pLed->BlinkingLedState = 1;
    }
#line 1736
    tmp___4 = msecs_to_jiffies(50U);
#line 1736
    ldv_mod_timer_290(& pLed->BlinkTimer, tmp___4 + (unsigned long )jiffies);
  } else {

  }
#line 1739
  goto ldv_52089;
  case 9U: ;
  case 11U: ;
#line 1743
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
#line 1744
    pLed1->bLedWPSBlinkInProgress = 0U;
#line 1745
    ldv_del_timer_sync_291(& pLed1->BlinkTimer);
#line 1747
    pLed1->BlinkingLedState = 2;
#line 1748
    pLed1->CurrLedState = 2;
#line 1750
    if ((unsigned int )pLed1->bLedOn != 0U) {
#line 1751
      ldv_mod_timer_292(& pLed->BlinkTimer, jiffies);
    } else {

    }
  } else {

  }
#line 1754
  if ((unsigned int )pLed->bLedWPSBlinkInProgress == 0U) {
#line 1755
    if ((unsigned int )pLed->bLedNoLinkBlinkInProgress == 1U) {
#line 1756
      ldv_del_timer_sync_293(& pLed->BlinkTimer);
#line 1757
      pLed->bLedNoLinkBlinkInProgress = 0U;
    } else {

    }
#line 1759
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1760
      ldv_del_timer_sync_294(& pLed->BlinkTimer);
#line 1761
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1763
    if ((unsigned int )pLed->bLedScanBlinkInProgress == 1U) {
#line 1764
      ldv_del_timer_sync_295(& pLed->BlinkTimer);
#line 1765
      pLed->bLedScanBlinkInProgress = 0U;
    } else {

    }
#line 1767
    pLed->bLedWPSBlinkInProgress = 1U;
#line 1768
    pLed->CurrLedState = 10;
#line 1769
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1771
      pLed->BlinkingLedState = 2;
#line 1772
      tmp___5 = msecs_to_jiffies(200U);
#line 1772
      ldv_mod_timer_296(& pLed->BlinkTimer, tmp___5 + (unsigned long )jiffies);
    } else {
#line 1775
      pLed->BlinkingLedState = 1;
#line 1776
      tmp___6 = msecs_to_jiffies(100U);
#line 1776
      ldv_mod_timer_297(& pLed->BlinkTimer, tmp___6 + (unsigned long )jiffies);
    }
  } else {

  }
#line 1780
  goto ldv_52089;
  case 10U: ;
#line 1783
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1784
    ldv_del_timer_sync_298(& pLed->BlinkTimer);
#line 1785
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1788
  pLed->bLedNoLinkBlinkInProgress = 1U;
#line 1789
  pLed->CurrLedState = 4;
#line 1790
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 1791
    pLed->BlinkingLedState = 2;
  } else {
#line 1793
    pLed->BlinkingLedState = 1;
  }
#line 1794
  tmp___7 = msecs_to_jiffies(1000U);
#line 1794
  ldv_mod_timer_299(& pLed->BlinkTimer, tmp___7 + (unsigned long )jiffies);
#line 1796
  goto ldv_52089;
  case 12U: ;
#line 1799
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1800
    ldv_del_timer_sync_300(& pLed->BlinkTimer);
#line 1801
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1804
  pLed->bLedNoLinkBlinkInProgress = 1U;
#line 1805
  pLed->CurrLedState = 4;
#line 1806
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 1807
    pLed->BlinkingLedState = 2;
  } else {
#line 1809
    pLed->BlinkingLedState = 1;
  }
#line 1810
  tmp___8 = msecs_to_jiffies(1000U);
#line 1810
  ldv_mod_timer_301(& pLed->BlinkTimer, tmp___8 + (unsigned long )jiffies);
#line 1814
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
#line 1815
    ldv_del_timer_sync_302(& pLed1->BlinkTimer);
  } else {
#line 1817
    pLed1->bLedWPSBlinkInProgress = 1U;
  }
#line 1819
  pLed1->CurrLedState = 11;
#line 1820
  if ((unsigned int )pLed1->bLedOn != 0U) {
#line 1821
    pLed1->BlinkingLedState = 2;
  } else {
#line 1823
    pLed1->BlinkingLedState = 1;
  }
#line 1824
  tmp___9 = msecs_to_jiffies(100U);
#line 1824
  ldv_mod_timer_303(& pLed->BlinkTimer, tmp___9 + (unsigned long )jiffies);
#line 1827
  goto ldv_52089;
  case 13U: ;
#line 1830
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1831
    ldv_del_timer_sync_304(& pLed->BlinkTimer);
#line 1832
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1835
  pLed->bLedNoLinkBlinkInProgress = 1U;
#line 1836
  pLed->CurrLedState = 4;
#line 1837
  if ((unsigned int )pLed->bLedOn != 0U) {
#line 1838
    pLed->BlinkingLedState = 2;
  } else {
#line 1840
    pLed->BlinkingLedState = 1;
  }
#line 1841
  tmp___10 = msecs_to_jiffies(1000U);
#line 1841
  ldv_mod_timer_305(& pLed->BlinkTimer, tmp___10 + (unsigned long )jiffies);
#line 1845
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
#line 1846
    ldv_del_timer_sync_306(& pLed1->BlinkTimer);
  } else {
#line 1848
    pLed1->bLedWPSBlinkInProgress = 1U;
  }
#line 1850
  pLed1->CurrLedState = 12;
#line 1851
  pLed1->BlinkTimes = 10U;
#line 1852
  if ((unsigned int )pLed1->bLedOn != 0U) {
#line 1853
    pLed1->BlinkingLedState = 2;
  } else {
#line 1855
    pLed1->BlinkingLedState = 1;
  }
#line 1856
  tmp___11 = msecs_to_jiffies(100U);
#line 1856
  ldv_mod_timer_307(& pLed->BlinkTimer, tmp___11 + (unsigned long )jiffies);
#line 1859
  goto ldv_52089;
  case 7U: 
#line 1862
  pLed->CurrLedState = 2;
#line 1863
  pLed->BlinkingLedState = 2;
#line 1865
  if ((unsigned int )pLed->bLedNoLinkBlinkInProgress != 0U) {
#line 1866
    ldv_del_timer_sync_308(& pLed->BlinkTimer);
#line 1867
    pLed->bLedNoLinkBlinkInProgress = 0U;
  } else {

  }
#line 1869
  if ((unsigned int )pLed->bLedLinkBlinkInProgress != 0U) {
#line 1870
    ldv_del_timer_sync_309(& pLed->BlinkTimer);
#line 1871
    pLed->bLedLinkBlinkInProgress = 0U;
  } else {

  }
#line 1873
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
#line 1874
    ldv_del_timer_sync_310(& pLed->BlinkTimer);
#line 1875
    pLed->bLedBlinkInProgress = 0U;
  } else {

  }
#line 1877
  if ((unsigned int )pLed->bLedWPSBlinkInProgress != 0U) {
#line 1878
    ldv_del_timer_sync_311(& pLed->BlinkTimer);
#line 1879
    pLed->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1881
  if ((unsigned int )pLed->bLedScanBlinkInProgress != 0U) {
#line 1882
    ldv_del_timer_sync_312(& pLed->BlinkTimer);
#line 1883
    pLed->bLedScanBlinkInProgress = 0U;
  } else {

  }
#line 1885
  if ((unsigned int )pLed->bLedStartToLinkBlinkInProgress != 0U) {
#line 1886
    ldv_del_timer_sync_313(& pLed->BlinkTimer);
#line 1887
    pLed->bLedStartToLinkBlinkInProgress = 0U;
  } else {

  }
#line 1890
  if ((unsigned int )pLed1->bLedWPSBlinkInProgress != 0U) {
#line 1891
    ldv_del_timer_sync_314(& pLed1->BlinkTimer);
#line 1892
    pLed1->bLedWPSBlinkInProgress = 0U;
  } else {

  }
#line 1895
  pLed1->BlinkingLedState = 0;
#line 1896
  SwLedOff23a(padapter, pLed);
#line 1897
  SwLedOff23a(padapter, pLed1);
#line 1898
  goto ldv_52089;
  default: ;
#line 1901
  goto ldv_52089;
  }
  ldv_52089: ;
#line 1905
  if (GlobalDebugLevel23A > 6U) {
#line 1905
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1905
    printk("\016Led %d\n", (unsigned int )pLed->CurrLedState);
  } else {

  }
#line 1907
  return;
}
}
#line 1910 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedControlMode5(struct rtw_adapter *padapter , enum led_ctl_mode LedAction ) 
{ 
  struct led_priv *ledpriv ;
  struct mlme_priv *pmlmepriv ;
  struct led_8723a *pLed ;
  unsigned long tmp ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 1912
  ledpriv = & padapter->ledpriv;
#line 1913
  pmlmepriv = & padapter->mlmepriv;
#line 1914
  pLed = & ledpriv->SwLed0;
#line 1916
  switch ((unsigned int )LedAction) {
  case 1U: ;
  case 3U: ;
  case 2U: 
#line 1921
  pLed->CurrLedState = 1;
#line 1922
  pLed->BlinkingLedState = 1;
#line 1924
  ldv_mod_timer_315(& pLed->BlinkTimer, jiffies);
#line 1925
  goto ldv_52112;
  case 6U: ;
#line 1928
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
#line 1928
    tmp___0 = check_fwstate(pmlmepriv, 1);
#line 1928
    if ((int )tmp___0) {

    } else {
#line 1928
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1931
  if ((unsigned int )pLed->bLedScanBlinkInProgress == 0U) {
#line 1933
    if ((unsigned int )pLed->bLedBlinkInProgress == 1U) {
#line 1935
      ldv_del_timer_sync_316(& pLed->BlinkTimer);
#line 1936
      pLed->bLedBlinkInProgress = 0U;
    } else {

    }
#line 1938
    pLed->bLedScanBlinkInProgress = 1U;
#line 1939
    pLed->CurrLedState = 6;
#line 1940
    pLed->BlinkTimes = 24U;
#line 1941
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1942
      pLed->BlinkingLedState = 2;
    } else {
#line 1944
      pLed->BlinkingLedState = 1;
    }
#line 1945
    tmp = msecs_to_jiffies(180U);
#line 1945
    ldv_mod_timer_317(& pLed->BlinkTimer, tmp + (unsigned long )jiffies);
  } else {

  }
#line 1948
  goto ldv_52112;
  case 4U: ;
  case 5U: ;
#line 1952
  if ((unsigned int )pLed->bLedBlinkInProgress == 0U) {
#line 1953
    if ((unsigned int )pLed->CurrLedState == 6U) {
#line 1954
      return;
    } else {

    }
#line 1956
    pLed->bLedBlinkInProgress = 1U;
#line 1957
    pLed->CurrLedState = 9;
#line 1958
    pLed->BlinkTimes = 2U;
#line 1959
    if ((unsigned int )pLed->bLedOn != 0U) {
#line 1960
      pLed->BlinkingLedState = 2;
    } else {
#line 1962
      pLed->BlinkingLedState = 1;
    }
#line 1963
    tmp___1 = msecs_to_jiffies(50U);
#line 1963
    ldv_mod_timer_318(& pLed->BlinkTimer, tmp___1 + (unsigned long )jiffies);
  } else {

  }
#line 1966
  goto ldv_52112;
  case 7U: 
#line 1969
  pLed->CurrLedState = 2;
#line 1970
  pLed->BlinkingLedState = 2;
#line 1972
  if ((unsigned int )pLed->bLedBlinkInProgress != 0U) {
#line 1973
    ldv_del_timer_sync_319(& pLed->BlinkTimer);
#line 1974
    pLed->bLedBlinkInProgress = 0U;
  } else {

  }
#line 1977
  SwLedOff23a(padapter, pLed);
#line 1978
  goto ldv_52112;
  default: ;
#line 1981
  goto ldv_52112;
  }
  ldv_52112: ;
#line 1985
  if (GlobalDebugLevel23A > 6U) {
#line 1985
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 1985
    printk("\016Led %d\n", (unsigned int )pLed->CurrLedState);
  } else {

  }
#line 1987
  return;
}
}
#line 1989 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
static void SwLedControlMode6(struct rtw_adapter *padapter , enum led_ctl_mode LedAction ) 
{ 
  struct led_priv *ledpriv ;
  struct led_8723a *pLed0 ;

  {
#line 1992
  ledpriv = & padapter->ledpriv;
#line 1993
  pLed0 = & ledpriv->SwLed0;
#line 1995
  switch ((unsigned int )LedAction) {
  case 1U: ;
  case 2U: ;
  case 3U: 
#line 1999
  ldv_del_timer_sync_320(& pLed0->BlinkTimer);
#line 2000
  pLed0->CurrLedState = 1;
#line 2001
  pLed0->BlinkingLedState = 1;
#line 2002
  ldv_mod_timer_321(& pLed0->BlinkTimer, jiffies);
#line 2003
  goto ldv_52127;
  case 7U: 
#line 2005
  SwLedOff23a(padapter, pLed0);
#line 2006
  goto ldv_52127;
  default: ;
#line 2008
  goto ldv_52127;
  }
  ldv_52127: ;
#line 2011
  if (GlobalDebugLevel23A > 6U) {
#line 2011
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 2011
    printk("\016ledcontrol 6 Led %d\n", (unsigned int )pLed0->CurrLedState);
  } else {

  }
#line 2013
  return;
}
}
#line 2019 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void BlinkHandler23a(struct led_8723a *pLed ) 
{ 
  struct rtw_adapter *padapter ;
  struct led_priv *ledpriv ;

  {
#line 2021
  padapter = pLed->padapter;
#line 2022
  ledpriv = & padapter->ledpriv;
#line 2026
  if (padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) {
#line 2027
    return;
  } else {

  }
#line 2029
  switch ((unsigned int )ledpriv->LedStrategy) {
  case 0U: 
#line 2031
  SwLedBlink(pLed);
#line 2032
  goto ldv_52136;
  case 1U: 
#line 2034
  SwLedBlink1(pLed);
#line 2035
  goto ldv_52136;
  case 2U: 
#line 2037
  SwLedBlink2(pLed);
#line 2038
  goto ldv_52136;
  case 3U: 
#line 2040
  SwLedBlink3(pLed);
#line 2041
  goto ldv_52136;
  case 4U: 
#line 2043
  SwLedBlink4(pLed);
#line 2044
  goto ldv_52136;
  case 5U: 
#line 2046
  SwLedBlink5(pLed);
#line 2047
  goto ldv_52136;
  case 6U: 
#line 2049
  SwLedBlink6(pLed);
#line 2050
  goto ldv_52136;
  default: ;
#line 2052
  goto ldv_52136;
  }
  ldv_52136: ;
#line 2055
  return;
}
}
#line 2057 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void LedControl871x23a(struct rtw_adapter *padapter , enum led_ctl_mode LedAction ) 
{ 
  struct led_priv *ledpriv ;

  {
#line 2058
  ledpriv = & padapter->ledpriv;
#line 2060
  if ((padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) || (unsigned int )padapter->hw_init_completed == 0U) {
#line 2063
    return;
  } else {

  }
#line 2066
  if ((unsigned int )ledpriv->bRegUseLed == 0U) {
#line 2067
    return;
  } else {

  }
#line 2075
  if (((unsigned int )padapter->pwrctrlpriv.rf_pwrstate != 0U && padapter->pwrctrlpriv.rfoff_reason > 536870912U) && ((((((unsigned int )LedAction == 4U || (unsigned int )LedAction == 5U) || (unsigned int )LedAction == 6U) || (unsigned int )LedAction == 2U) || (unsigned int )LedAction == 3U) || (unsigned int )LedAction == 1U)) {
#line 2082
    return;
  } else {

  }
#line 2085
  switch ((unsigned int )ledpriv->LedStrategy) {
  case 0U: ;
#line 2087
  goto ldv_52150;
  case 1U: 
#line 2089
  SwLedControlMode1(padapter, LedAction);
#line 2090
  goto ldv_52150;
  case 2U: 
#line 2092
  SwLedControlMode2(padapter, LedAction);
#line 2093
  goto ldv_52150;
  case 3U: 
#line 2095
  SwLedControlMode3(padapter, LedAction);
#line 2096
  goto ldv_52150;
  case 4U: 
#line 2098
  SwLedControlMode4(padapter, LedAction);
#line 2099
  goto ldv_52150;
  case 5U: 
#line 2101
  SwLedControlMode5(padapter, LedAction);
#line 2102
  goto ldv_52150;
  case 6U: 
#line 2104
  SwLedControlMode6(padapter, LedAction);
#line 2105
  goto ldv_52150;
  default: ;
#line 2107
  goto ldv_52150;
  }
  ldv_52150: ;
#line 2110
  if (GlobalDebugLevel23A > 6U) {
#line 2110
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2147483648U, 7);
#line 2110
    printk("\016LedStrategy:%d, LedAction %d\n", (unsigned int )ledpriv->LedStrategy,
           (unsigned int )LedAction);
  } else {

  }
#line 2112
  return;
}
}
#line 2114 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void timer_init_1(void) 
{ 


  {
#line 2115
  ldv_timer_1_0 = 0;
#line 2116
  ldv_timer_1_1 = 0;
#line 2117
  ldv_timer_1_2 = 0;
#line 2118
  ldv_timer_1_3 = 0;
#line 2119
  return;
}
}
#line 2122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int reg_timer_1(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 2123
  if ((unsigned long )function == (unsigned long )(& BlinkTimerCallback)) {
#line 2124
    activate_suitable_timer_1(timer, data);
  } else {

  }
#line 2125
  return (0);
}
}
#line 2129 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void activate_suitable_timer_1(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 2130
  if (ldv_timer_1_0 == 0 || ldv_timer_1_0 == 2) {
#line 2131
    ldv_timer_list_1_0 = timer;
#line 2132
    ldv_timer_list_1_0->data = data;
#line 2133
    ldv_timer_1_0 = 1;
#line 2134
    return;
  } else {

  }
#line 2136
  if (ldv_timer_1_1 == 0 || ldv_timer_1_1 == 2) {
#line 2137
    ldv_timer_list_1_1 = timer;
#line 2138
    ldv_timer_list_1_1->data = data;
#line 2139
    ldv_timer_1_1 = 1;
#line 2140
    return;
  } else {

  }
#line 2142
  if (ldv_timer_1_2 == 0 || ldv_timer_1_2 == 2) {
#line 2143
    ldv_timer_list_1_2 = timer;
#line 2144
    ldv_timer_list_1_2->data = data;
#line 2145
    ldv_timer_1_2 = 1;
#line 2146
    return;
  } else {

  }
#line 2148
  if (ldv_timer_1_3 == 0 || ldv_timer_1_3 == 2) {
#line 2149
    ldv_timer_list_1_3 = timer;
#line 2150
    ldv_timer_list_1_3->data = data;
#line 2151
    ldv_timer_1_3 = 1;
#line 2152
    return;
  } else {

  }
#line 2154
  return;
}
}
#line 2158 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void choose_timer_1(void) 
{ 
  int tmp ;

  {
#line 2159
  tmp = __VERIFIER_nondet_int();
#line 2159
  switch (tmp) {
  case 0: ;
#line 2161
  if (ldv_timer_1_0 == 1) {
#line 2162
    ldv_timer_1_0 = 2;
#line 2163
    ldv_timer_1(ldv_timer_1_0, ldv_timer_list_1_0);
  } else {

  }
#line 2166
  goto ldv_52175;
  case 1: ;
#line 2168
  if (ldv_timer_1_1 == 1) {
#line 2169
    ldv_timer_1_1 = 2;
#line 2170
    ldv_timer_1(ldv_timer_1_1, ldv_timer_list_1_1);
  } else {

  }
#line 2173
  goto ldv_52175;
  case 2: ;
#line 2175
  if (ldv_timer_1_2 == 1) {
#line 2176
    ldv_timer_1_2 = 2;
#line 2177
    ldv_timer_1(ldv_timer_1_2, ldv_timer_list_1_2);
  } else {

  }
#line 2180
  goto ldv_52175;
  case 3: ;
#line 2182
  if (ldv_timer_1_3 == 1) {
#line 2183
    ldv_timer_1_3 = 2;
#line 2184
    ldv_timer_1(ldv_timer_1_3, ldv_timer_list_1_3);
  } else {

  }
#line 2187
  goto ldv_52175;
  default: 
#line 2188
  ldv_stop();
  }
  ldv_52175: ;
#line 2190
  return;
}
}
#line 2194 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void activate_pending_timer_1(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 2195
  if ((unsigned long )ldv_timer_list_1_0 == (unsigned long )timer) {
#line 2196
    if (ldv_timer_1_0 == 2 || pending_flag != 0) {
#line 2197
      ldv_timer_list_1_0 = timer;
#line 2198
      ldv_timer_list_1_0->data = data;
#line 2199
      ldv_timer_1_0 = 1;
    } else {

    }
#line 2201
    return;
  } else {

  }
#line 2204
  if ((unsigned long )ldv_timer_list_1_1 == (unsigned long )timer) {
#line 2205
    if (ldv_timer_1_1 == 2 || pending_flag != 0) {
#line 2206
      ldv_timer_list_1_1 = timer;
#line 2207
      ldv_timer_list_1_1->data = data;
#line 2208
      ldv_timer_1_1 = 1;
    } else {

    }
#line 2210
    return;
  } else {

  }
#line 2213
  if ((unsigned long )ldv_timer_list_1_2 == (unsigned long )timer) {
#line 2214
    if (ldv_timer_1_2 == 2 || pending_flag != 0) {
#line 2215
      ldv_timer_list_1_2 = timer;
#line 2216
      ldv_timer_list_1_2->data = data;
#line 2217
      ldv_timer_1_2 = 1;
    } else {

    }
#line 2219
    return;
  } else {

  }
#line 2222
  if ((unsigned long )ldv_timer_list_1_3 == (unsigned long )timer) {
#line 2223
    if (ldv_timer_1_3 == 2 || pending_flag != 0) {
#line 2224
      ldv_timer_list_1_3 = timer;
#line 2225
      ldv_timer_list_1_3->data = data;
#line 2226
      ldv_timer_1_3 = 1;
    } else {

    }
#line 2228
    return;
  } else {

  }
#line 2230
  activate_suitable_timer_1(timer, data);
#line 2231
  return;
}
}
#line 2234 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void disable_suitable_timer_1(struct timer_list *timer ) 
{ 


  {
#line 2235
  if (ldv_timer_1_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_1_0) {
#line 2236
    ldv_timer_1_0 = 0;
#line 2237
    return;
  } else {

  }
#line 2239
  if (ldv_timer_1_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_1_1) {
#line 2240
    ldv_timer_1_1 = 0;
#line 2241
    return;
  } else {

  }
#line 2243
  if (ldv_timer_1_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_1_2) {
#line 2244
    ldv_timer_1_2 = 0;
#line 2245
    return;
  } else {

  }
#line 2247
  if (ldv_timer_1_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_1_3) {
#line 2248
    ldv_timer_1_3 = 0;
#line 2249
    return;
  } else {

  }
#line 2251
  return;
}
}
#line 2255 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void ldv_timer_1(int state , struct timer_list *timer ) 
{ 


  {
#line 2256
  LDV_IN_INTERRUPT = 2;
#line 2257
  BlinkTimerCallback(timer->data);
#line 2258
  LDV_IN_INTERRUPT = 1;
#line 2259
  return;
}
}
#line 2388 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
void *ldv_kmem_cache_alloc_200(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2391
  ldv_check_alloc_flags(flags);
#line 2393
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2394
  return ((void *)0);
}
}
#line 2432 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_pskb_expand_head_206(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2435
  ldv_check_alloc_flags(flags);
#line 2437
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2437
  return (tmp);
}
}
#line 2448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
struct sk_buff *ldv_skb_clone_208(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2451
  ldv_check_alloc_flags(flags);
#line 2453
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2453
  return (tmp);
}
}
#line 2464 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
struct sk_buff *ldv_skb_copy_210(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2467
  ldv_check_alloc_flags(flags);
#line 2469
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2469
  return (tmp);
}
}
#line 2472 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_211(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2475
  ldv_check_alloc_flags(flags);
#line 2477
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2477
  return (tmp);
}
}
#line 2480 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_212(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2483
  ldv_check_alloc_flags(flags);
#line 2485
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2485
  return (tmp);
}
}
#line 2488 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_213(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2491
  ldv_check_alloc_flags(flags);
#line 2493
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2493
  return (tmp);
}
}
#line 2496 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_pskb_expand_head_214(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2499
  ldv_check_alloc_flags(flags);
#line 2501
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2501
  return (tmp);
}
}
#line 2504 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_pskb_expand_head_215(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2507
  ldv_check_alloc_flags(flags);
#line 2509
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2509
  return (tmp);
}
}
#line 2512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
struct sk_buff *ldv_skb_clone_216(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2515
  ldv_check_alloc_flags(flags);
#line 2517
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2517
  return (tmp);
}
}
#line 2520 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_217(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 2524
  tmp = del_timer_sync(ldv_func_arg1);
#line 2524
  ldv_func_res = tmp;
#line 2526
  disable_suitable_timer_6(ldv_func_arg1);
#line 2528
  return (ldv_func_res);
}
}
#line 2531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_218(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 2535
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2535
  ldv_func_res = tmp;
#line 2537
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2539
  return (ldv_func_res);
}
}
#line 2542 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_219(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 2546
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2546
  ldv_func_res = tmp;
#line 2548
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2550
  return (ldv_func_res);
}
}
#line 2553 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_220(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 2557
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2557
  ldv_func_res = tmp;
#line 2559
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2561
  return (ldv_func_res);
}
}
#line 2564 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_221(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 2568
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2568
  ldv_func_res = tmp;
#line 2570
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2572
  return (ldv_func_res);
}
}
#line 2575 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_222(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 2579
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2579
  ldv_func_res = tmp;
#line 2581
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2583
  return (ldv_func_res);
}
}
#line 2586 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_223(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 2590
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2590
  ldv_func_res = tmp;
#line 2592
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2594
  return (ldv_func_res);
}
}
#line 2597 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_224(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 2601
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2601
  ldv_func_res = tmp;
#line 2603
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2605
  return (ldv_func_res);
}
}
#line 2608 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_225(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 2612
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2612
  ldv_func_res = tmp;
#line 2614
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2616
  return (ldv_func_res);
}
}
#line 2619 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_226(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 2623
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2623
  ldv_func_res = tmp;
#line 2625
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2627
  return (ldv_func_res);
}
}
#line 2630 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_227(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 2634
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2634
  ldv_func_res = tmp;
#line 2636
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2638
  return (ldv_func_res);
}
}
#line 2641 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_228(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 2645
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2645
  ldv_func_res = tmp;
#line 2647
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2649
  return (ldv_func_res);
}
}
#line 2652 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_229(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 2656
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2656
  ldv_func_res = tmp;
#line 2658
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2660
  return (ldv_func_res);
}
}
#line 2663 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_230(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
#line 2667
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2667
  ldv_func_res = tmp;
#line 2669
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2671
  return (ldv_func_res);
}
}
#line 2674 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_231(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
#line 2678
  tmp = del_timer_sync(ldv_func_arg1);
#line 2678
  ldv_func_res = tmp;
#line 2680
  disable_suitable_timer_6(ldv_func_arg1);
#line 2682
  return (ldv_func_res);
}
}
#line 2685 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_232(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
#line 2689
  tmp = del_timer_sync(ldv_func_arg1);
#line 2689
  ldv_func_res = tmp;
#line 2691
  disable_suitable_timer_6(ldv_func_arg1);
#line 2693
  return (ldv_func_res);
}
}
#line 2696 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_233(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;

  {
#line 2700
  tmp = del_timer_sync(ldv_func_arg1);
#line 2700
  ldv_func_res = tmp;
#line 2702
  disable_suitable_timer_6(ldv_func_arg1);
#line 2704
  return (ldv_func_res);
}
}
#line 2707 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_234(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___19 ldv_func_res ;
  int tmp ;

  {
#line 2711
  tmp = del_timer_sync(ldv_func_arg1);
#line 2711
  ldv_func_res = tmp;
#line 2713
  disable_suitable_timer_6(ldv_func_arg1);
#line 2715
  return (ldv_func_res);
}
}
#line 2718 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_235(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___20 ldv_func_res ;
  int tmp ;

  {
#line 2722
  tmp = del_timer_sync(ldv_func_arg1);
#line 2722
  ldv_func_res = tmp;
#line 2724
  disable_suitable_timer_6(ldv_func_arg1);
#line 2726
  return (ldv_func_res);
}
}
#line 2729 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_236(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___21 ldv_func_res ;
  int tmp ;

  {
#line 2733
  tmp = del_timer_sync(ldv_func_arg1);
#line 2733
  ldv_func_res = tmp;
#line 2735
  disable_suitable_timer_6(ldv_func_arg1);
#line 2737
  return (ldv_func_res);
}
}
#line 2740 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_237(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___22 ldv_func_res ;
  int tmp ;

  {
#line 2744
  tmp = del_timer_sync(ldv_func_arg1);
#line 2744
  ldv_func_res = tmp;
#line 2746
  disable_suitable_timer_6(ldv_func_arg1);
#line 2748
  return (ldv_func_res);
}
}
#line 2751 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_238(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___23 ldv_func_res ;
  int tmp ;

  {
#line 2755
  tmp = del_timer_sync(ldv_func_arg1);
#line 2755
  ldv_func_res = tmp;
#line 2757
  disable_suitable_timer_6(ldv_func_arg1);
#line 2759
  return (ldv_func_res);
}
}
#line 2762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_239(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___24 ldv_func_res ;
  int tmp ;

  {
#line 2766
  tmp = del_timer_sync(ldv_func_arg1);
#line 2766
  ldv_func_res = tmp;
#line 2768
  disable_suitable_timer_6(ldv_func_arg1);
#line 2770
  return (ldv_func_res);
}
}
#line 2773 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_240(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___25 ldv_func_res ;
  int tmp ;

  {
#line 2777
  tmp = del_timer_sync(ldv_func_arg1);
#line 2777
  ldv_func_res = tmp;
#line 2779
  disable_suitable_timer_6(ldv_func_arg1);
#line 2781
  return (ldv_func_res);
}
}
#line 2784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_241(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___26 ldv_func_res ;
  int tmp ;

  {
#line 2788
  tmp = del_timer_sync(ldv_func_arg1);
#line 2788
  ldv_func_res = tmp;
#line 2790
  disable_suitable_timer_6(ldv_func_arg1);
#line 2792
  return (ldv_func_res);
}
}
#line 2795 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_242(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___27 ldv_func_res ;
  int tmp ;

  {
#line 2799
  tmp = del_timer_sync(ldv_func_arg1);
#line 2799
  ldv_func_res = tmp;
#line 2801
  disable_suitable_timer_6(ldv_func_arg1);
#line 2803
  return (ldv_func_res);
}
}
#line 2806 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_243(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___28 ldv_func_res ;
  int tmp ;

  {
#line 2810
  tmp = del_timer_sync(ldv_func_arg1);
#line 2810
  ldv_func_res = tmp;
#line 2812
  disable_suitable_timer_6(ldv_func_arg1);
#line 2814
  return (ldv_func_res);
}
}
#line 2817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_244(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___29 ldv_func_res ;
  int tmp ;

  {
#line 2821
  tmp = del_timer_sync(ldv_func_arg1);
#line 2821
  ldv_func_res = tmp;
#line 2823
  disable_suitable_timer_6(ldv_func_arg1);
#line 2825
  return (ldv_func_res);
}
}
#line 2828 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_245(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___30 ldv_func_res ;
  int tmp ;

  {
#line 2832
  tmp = del_timer_sync(ldv_func_arg1);
#line 2832
  ldv_func_res = tmp;
#line 2834
  disable_suitable_timer_6(ldv_func_arg1);
#line 2836
  return (ldv_func_res);
}
}
#line 2839 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_246(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___31 ldv_func_res ;
  int tmp ;

  {
#line 2843
  tmp = del_timer_sync(ldv_func_arg1);
#line 2843
  ldv_func_res = tmp;
#line 2845
  disable_suitable_timer_6(ldv_func_arg1);
#line 2847
  return (ldv_func_res);
}
}
#line 2850 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_247(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___32 ldv_func_res ;
  int tmp ;

  {
#line 2854
  tmp = del_timer_sync(ldv_func_arg1);
#line 2854
  ldv_func_res = tmp;
#line 2856
  disable_suitable_timer_6(ldv_func_arg1);
#line 2858
  return (ldv_func_res);
}
}
#line 2861 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_248(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___33 ldv_func_res ;
  int tmp ;

  {
#line 2865
  tmp = del_timer_sync(ldv_func_arg1);
#line 2865
  ldv_func_res = tmp;
#line 2867
  disable_suitable_timer_6(ldv_func_arg1);
#line 2869
  return (ldv_func_res);
}
}
#line 2872 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_249(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___34 ldv_func_res ;
  int tmp ;

  {
#line 2876
  tmp = del_timer_sync(ldv_func_arg1);
#line 2876
  ldv_func_res = tmp;
#line 2878
  disable_suitable_timer_6(ldv_func_arg1);
#line 2880
  return (ldv_func_res);
}
}
#line 2883 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_250(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___35 ldv_func_res ;
  int tmp ;

  {
#line 2887
  tmp = del_timer_sync(ldv_func_arg1);
#line 2887
  ldv_func_res = tmp;
#line 2889
  disable_suitable_timer_6(ldv_func_arg1);
#line 2891
  return (ldv_func_res);
}
}
#line 2894 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_251(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___36 ldv_func_res ;
  int tmp ;

  {
#line 2898
  tmp = del_timer_sync(ldv_func_arg1);
#line 2898
  ldv_func_res = tmp;
#line 2900
  disable_suitable_timer_6(ldv_func_arg1);
#line 2902
  return (ldv_func_res);
}
}
#line 2905 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_252(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___37 ldv_func_res ;
  int tmp ;

  {
#line 2909
  tmp = del_timer_sync(ldv_func_arg1);
#line 2909
  ldv_func_res = tmp;
#line 2911
  disable_suitable_timer_6(ldv_func_arg1);
#line 2913
  return (ldv_func_res);
}
}
#line 2916 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_253(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___38 ldv_func_res ;
  int tmp ;

  {
#line 2920
  tmp = del_timer_sync(ldv_func_arg1);
#line 2920
  ldv_func_res = tmp;
#line 2922
  disable_suitable_timer_6(ldv_func_arg1);
#line 2924
  return (ldv_func_res);
}
}
#line 2927 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_254(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___39 ldv_func_res ;
  int tmp ;

  {
#line 2931
  tmp = del_timer_sync(ldv_func_arg1);
#line 2931
  ldv_func_res = tmp;
#line 2933
  disable_suitable_timer_6(ldv_func_arg1);
#line 2935
  return (ldv_func_res);
}
}
#line 2938 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_255(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___40 ldv_func_res ;
  int tmp ;

  {
#line 2942
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 2942
  ldv_func_res = tmp;
#line 2944
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 2946
  return (ldv_func_res);
}
}
#line 2949 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_256(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___41 ldv_func_res ;
  int tmp ;

  {
#line 2953
  tmp = del_timer_sync(ldv_func_arg1);
#line 2953
  ldv_func_res = tmp;
#line 2955
  disable_suitable_timer_6(ldv_func_arg1);
#line 2957
  return (ldv_func_res);
}
}
#line 2960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_257(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___42 ldv_func_res ;
  int tmp ;

  {
#line 2964
  tmp = del_timer_sync(ldv_func_arg1);
#line 2964
  ldv_func_res = tmp;
#line 2966
  disable_suitable_timer_6(ldv_func_arg1);
#line 2968
  return (ldv_func_res);
}
}
#line 2971 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_258(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___43 ldv_func_res ;
  int tmp ;

  {
#line 2975
  tmp = del_timer_sync(ldv_func_arg1);
#line 2975
  ldv_func_res = tmp;
#line 2977
  disable_suitable_timer_6(ldv_func_arg1);
#line 2979
  return (ldv_func_res);
}
}
#line 2982 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_259(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___44 ldv_func_res ;
  int tmp ;

  {
#line 2986
  tmp = del_timer_sync(ldv_func_arg1);
#line 2986
  ldv_func_res = tmp;
#line 2988
  disable_suitable_timer_6(ldv_func_arg1);
#line 2990
  return (ldv_func_res);
}
}
#line 2993 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_260(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___45 ldv_func_res ;
  int tmp ;

  {
#line 2997
  tmp = del_timer_sync(ldv_func_arg1);
#line 2997
  ldv_func_res = tmp;
#line 2999
  disable_suitable_timer_6(ldv_func_arg1);
#line 3001
  return (ldv_func_res);
}
}
#line 3004 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_261(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___46 ldv_func_res ;
  int tmp ;

  {
#line 3008
  tmp = del_timer_sync(ldv_func_arg1);
#line 3008
  ldv_func_res = tmp;
#line 3010
  disable_suitable_timer_6(ldv_func_arg1);
#line 3012
  return (ldv_func_res);
}
}
#line 3015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_262(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___47 ldv_func_res ;
  int tmp ;

  {
#line 3019
  tmp = del_timer_sync(ldv_func_arg1);
#line 3019
  ldv_func_res = tmp;
#line 3021
  disable_suitable_timer_6(ldv_func_arg1);
#line 3023
  return (ldv_func_res);
}
}
#line 3026 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_263(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___48 ldv_func_res ;
  int tmp ;

  {
#line 3030
  tmp = del_timer_sync(ldv_func_arg1);
#line 3030
  ldv_func_res = tmp;
#line 3032
  disable_suitable_timer_6(ldv_func_arg1);
#line 3034
  return (ldv_func_res);
}
}
#line 3037 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_264(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___49 ldv_func_res ;
  int tmp ;

  {
#line 3041
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3041
  ldv_func_res = tmp;
#line 3043
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3045
  return (ldv_func_res);
}
}
#line 3048 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_265(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___50 ldv_func_res ;
  int tmp ;

  {
#line 3052
  tmp = del_timer_sync(ldv_func_arg1);
#line 3052
  ldv_func_res = tmp;
#line 3054
  disable_suitable_timer_6(ldv_func_arg1);
#line 3056
  return (ldv_func_res);
}
}
#line 3059 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_266(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___51 ldv_func_res ;
  int tmp ;

  {
#line 3063
  tmp = del_timer_sync(ldv_func_arg1);
#line 3063
  ldv_func_res = tmp;
#line 3065
  disable_suitable_timer_6(ldv_func_arg1);
#line 3067
  return (ldv_func_res);
}
}
#line 3070 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_267(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___52 ldv_func_res ;
  int tmp ;

  {
#line 3074
  tmp = del_timer_sync(ldv_func_arg1);
#line 3074
  ldv_func_res = tmp;
#line 3076
  disable_suitable_timer_6(ldv_func_arg1);
#line 3078
  return (ldv_func_res);
}
}
#line 3081 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_268(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___53 ldv_func_res ;
  int tmp ;

  {
#line 3085
  tmp = del_timer_sync(ldv_func_arg1);
#line 3085
  ldv_func_res = tmp;
#line 3087
  disable_suitable_timer_6(ldv_func_arg1);
#line 3089
  return (ldv_func_res);
}
}
#line 3092 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_269(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___54 ldv_func_res ;
  int tmp ;

  {
#line 3096
  tmp = del_timer_sync(ldv_func_arg1);
#line 3096
  ldv_func_res = tmp;
#line 3098
  disable_suitable_timer_6(ldv_func_arg1);
#line 3100
  return (ldv_func_res);
}
}
#line 3103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_270(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___55 ldv_func_res ;
  int tmp ;

  {
#line 3107
  tmp = del_timer_sync(ldv_func_arg1);
#line 3107
  ldv_func_res = tmp;
#line 3109
  disable_suitable_timer_6(ldv_func_arg1);
#line 3111
  return (ldv_func_res);
}
}
#line 3114 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_271(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___56 ldv_func_res ;
  int tmp ;

  {
#line 3118
  tmp = del_timer_sync(ldv_func_arg1);
#line 3118
  ldv_func_res = tmp;
#line 3120
  disable_suitable_timer_6(ldv_func_arg1);
#line 3122
  return (ldv_func_res);
}
}
#line 3125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_272(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___57 ldv_func_res ;
  int tmp ;

  {
#line 3129
  tmp = del_timer_sync(ldv_func_arg1);
#line 3129
  ldv_func_res = tmp;
#line 3131
  disable_suitable_timer_6(ldv_func_arg1);
#line 3133
  return (ldv_func_res);
}
}
#line 3136 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_273(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___58 ldv_func_res ;
  int tmp ;

  {
#line 3140
  tmp = del_timer_sync(ldv_func_arg1);
#line 3140
  ldv_func_res = tmp;
#line 3142
  disable_suitable_timer_6(ldv_func_arg1);
#line 3144
  return (ldv_func_res);
}
}
#line 3147 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_274(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___59 ldv_func_res ;
  int tmp ;

  {
#line 3151
  tmp = del_timer_sync(ldv_func_arg1);
#line 3151
  ldv_func_res = tmp;
#line 3153
  disable_suitable_timer_6(ldv_func_arg1);
#line 3155
  return (ldv_func_res);
}
}
#line 3158 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_275(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___60 ldv_func_res ;
  int tmp ;

  {
#line 3162
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3162
  ldv_func_res = tmp;
#line 3164
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3166
  return (ldv_func_res);
}
}
#line 3169 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_276(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___61 ldv_func_res ;
  int tmp ;

  {
#line 3173
  tmp = del_timer_sync(ldv_func_arg1);
#line 3173
  ldv_func_res = tmp;
#line 3175
  disable_suitable_timer_6(ldv_func_arg1);
#line 3177
  return (ldv_func_res);
}
}
#line 3180 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_277(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___62 ldv_func_res ;
  int tmp ;

  {
#line 3184
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3184
  ldv_func_res = tmp;
#line 3186
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3188
  return (ldv_func_res);
}
}
#line 3191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_278(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___63 ldv_func_res ;
  int tmp ;

  {
#line 3195
  tmp = del_timer_sync(ldv_func_arg1);
#line 3195
  ldv_func_res = tmp;
#line 3197
  disable_suitable_timer_6(ldv_func_arg1);
#line 3199
  return (ldv_func_res);
}
}
#line 3202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_279(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___64 ldv_func_res ;
  int tmp ;

  {
#line 3206
  tmp = del_timer_sync(ldv_func_arg1);
#line 3206
  ldv_func_res = tmp;
#line 3208
  disable_suitable_timer_6(ldv_func_arg1);
#line 3210
  return (ldv_func_res);
}
}
#line 3213 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_280(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___65 ldv_func_res ;
  int tmp ;

  {
#line 3217
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3217
  ldv_func_res = tmp;
#line 3219
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3221
  return (ldv_func_res);
}
}
#line 3224 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_281(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___66 ldv_func_res ;
  int tmp ;

  {
#line 3228
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3228
  ldv_func_res = tmp;
#line 3230
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3232
  return (ldv_func_res);
}
}
#line 3235 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_282(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___67 ldv_func_res ;
  int tmp ;

  {
#line 3239
  tmp = del_timer_sync(ldv_func_arg1);
#line 3239
  ldv_func_res = tmp;
#line 3241
  disable_suitable_timer_6(ldv_func_arg1);
#line 3243
  return (ldv_func_res);
}
}
#line 3246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_283(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___68 ldv_func_res ;
  int tmp ;

  {
#line 3250
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3250
  ldv_func_res = tmp;
#line 3252
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3254
  return (ldv_func_res);
}
}
#line 3257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_284(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___69 ldv_func_res ;
  int tmp ;

  {
#line 3261
  tmp = del_timer_sync(ldv_func_arg1);
#line 3261
  ldv_func_res = tmp;
#line 3263
  disable_suitable_timer_6(ldv_func_arg1);
#line 3265
  return (ldv_func_res);
}
}
#line 3268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_285(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___70 ldv_func_res ;
  int tmp ;

  {
#line 3272
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3272
  ldv_func_res = tmp;
#line 3274
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3276
  return (ldv_func_res);
}
}
#line 3279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_286(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___71 ldv_func_res ;
  int tmp ;

  {
#line 3283
  tmp = del_timer_sync(ldv_func_arg1);
#line 3283
  ldv_func_res = tmp;
#line 3285
  disable_suitable_timer_6(ldv_func_arg1);
#line 3287
  return (ldv_func_res);
}
}
#line 3290 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_287(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___72 ldv_func_res ;
  int tmp ;

  {
#line 3294
  tmp = del_timer_sync(ldv_func_arg1);
#line 3294
  ldv_func_res = tmp;
#line 3296
  disable_suitable_timer_6(ldv_func_arg1);
#line 3298
  return (ldv_func_res);
}
}
#line 3301 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_288(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___73 ldv_func_res ;
  int tmp ;

  {
#line 3305
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3305
  ldv_func_res = tmp;
#line 3307
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3309
  return (ldv_func_res);
}
}
#line 3312 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_289(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___74 ldv_func_res ;
  int tmp ;

  {
#line 3316
  tmp = del_timer_sync(ldv_func_arg1);
#line 3316
  ldv_func_res = tmp;
#line 3318
  disable_suitable_timer_6(ldv_func_arg1);
#line 3320
  return (ldv_func_res);
}
}
#line 3323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_290(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___75 ldv_func_res ;
  int tmp ;

  {
#line 3327
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3327
  ldv_func_res = tmp;
#line 3329
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3331
  return (ldv_func_res);
}
}
#line 3334 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_291(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___76 ldv_func_res ;
  int tmp ;

  {
#line 3338
  tmp = del_timer_sync(ldv_func_arg1);
#line 3338
  ldv_func_res = tmp;
#line 3340
  disable_suitable_timer_6(ldv_func_arg1);
#line 3342
  return (ldv_func_res);
}
}
#line 3345 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_292(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___77 ldv_func_res ;
  int tmp ;

  {
#line 3349
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3349
  ldv_func_res = tmp;
#line 3351
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3353
  return (ldv_func_res);
}
}
#line 3356 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_293(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___78 ldv_func_res ;
  int tmp ;

  {
#line 3360
  tmp = del_timer_sync(ldv_func_arg1);
#line 3360
  ldv_func_res = tmp;
#line 3362
  disable_suitable_timer_6(ldv_func_arg1);
#line 3364
  return (ldv_func_res);
}
}
#line 3367 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_294(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___79 ldv_func_res ;
  int tmp ;

  {
#line 3371
  tmp = del_timer_sync(ldv_func_arg1);
#line 3371
  ldv_func_res = tmp;
#line 3373
  disable_suitable_timer_6(ldv_func_arg1);
#line 3375
  return (ldv_func_res);
}
}
#line 3378 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_295(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___80 ldv_func_res ;
  int tmp ;

  {
#line 3382
  tmp = del_timer_sync(ldv_func_arg1);
#line 3382
  ldv_func_res = tmp;
#line 3384
  disable_suitable_timer_6(ldv_func_arg1);
#line 3386
  return (ldv_func_res);
}
}
#line 3389 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_296(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___81 ldv_func_res ;
  int tmp ;

  {
#line 3393
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3393
  ldv_func_res = tmp;
#line 3395
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3397
  return (ldv_func_res);
}
}
#line 3400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_297(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___82 ldv_func_res ;
  int tmp ;

  {
#line 3404
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3404
  ldv_func_res = tmp;
#line 3406
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3408
  return (ldv_func_res);
}
}
#line 3411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_298(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___83 ldv_func_res ;
  int tmp ;

  {
#line 3415
  tmp = del_timer_sync(ldv_func_arg1);
#line 3415
  ldv_func_res = tmp;
#line 3417
  disable_suitable_timer_6(ldv_func_arg1);
#line 3419
  return (ldv_func_res);
}
}
#line 3422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_299(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___84 ldv_func_res ;
  int tmp ;

  {
#line 3426
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3426
  ldv_func_res = tmp;
#line 3428
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3430
  return (ldv_func_res);
}
}
#line 3433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_300(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___85 ldv_func_res ;
  int tmp ;

  {
#line 3437
  tmp = del_timer_sync(ldv_func_arg1);
#line 3437
  ldv_func_res = tmp;
#line 3439
  disable_suitable_timer_6(ldv_func_arg1);
#line 3441
  return (ldv_func_res);
}
}
#line 3444 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_301(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___86 ldv_func_res ;
  int tmp ;

  {
#line 3448
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3448
  ldv_func_res = tmp;
#line 3450
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3452
  return (ldv_func_res);
}
}
#line 3455 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_302(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___87 ldv_func_res ;
  int tmp ;

  {
#line 3459
  tmp = del_timer_sync(ldv_func_arg1);
#line 3459
  ldv_func_res = tmp;
#line 3461
  disable_suitable_timer_6(ldv_func_arg1);
#line 3463
  return (ldv_func_res);
}
}
#line 3466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_303(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___88 ldv_func_res ;
  int tmp ;

  {
#line 3470
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3470
  ldv_func_res = tmp;
#line 3472
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3474
  return (ldv_func_res);
}
}
#line 3477 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_304(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___89 ldv_func_res ;
  int tmp ;

  {
#line 3481
  tmp = del_timer_sync(ldv_func_arg1);
#line 3481
  ldv_func_res = tmp;
#line 3483
  disable_suitable_timer_6(ldv_func_arg1);
#line 3485
  return (ldv_func_res);
}
}
#line 3488 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_305(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___90 ldv_func_res ;
  int tmp ;

  {
#line 3492
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3492
  ldv_func_res = tmp;
#line 3494
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3496
  return (ldv_func_res);
}
}
#line 3499 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_306(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___91 ldv_func_res ;
  int tmp ;

  {
#line 3503
  tmp = del_timer_sync(ldv_func_arg1);
#line 3503
  ldv_func_res = tmp;
#line 3505
  disable_suitable_timer_6(ldv_func_arg1);
#line 3507
  return (ldv_func_res);
}
}
#line 3510 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_307(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___92 ldv_func_res ;
  int tmp ;

  {
#line 3514
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3514
  ldv_func_res = tmp;
#line 3516
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3518
  return (ldv_func_res);
}
}
#line 3521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_308(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___93 ldv_func_res ;
  int tmp ;

  {
#line 3525
  tmp = del_timer_sync(ldv_func_arg1);
#line 3525
  ldv_func_res = tmp;
#line 3527
  disable_suitable_timer_6(ldv_func_arg1);
#line 3529
  return (ldv_func_res);
}
}
#line 3532 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_309(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___94 ldv_func_res ;
  int tmp ;

  {
#line 3536
  tmp = del_timer_sync(ldv_func_arg1);
#line 3536
  ldv_func_res = tmp;
#line 3538
  disable_suitable_timer_6(ldv_func_arg1);
#line 3540
  return (ldv_func_res);
}
}
#line 3543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_310(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___95 ldv_func_res ;
  int tmp ;

  {
#line 3547
  tmp = del_timer_sync(ldv_func_arg1);
#line 3547
  ldv_func_res = tmp;
#line 3549
  disable_suitable_timer_6(ldv_func_arg1);
#line 3551
  return (ldv_func_res);
}
}
#line 3554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_311(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___96 ldv_func_res ;
  int tmp ;

  {
#line 3558
  tmp = del_timer_sync(ldv_func_arg1);
#line 3558
  ldv_func_res = tmp;
#line 3560
  disable_suitable_timer_6(ldv_func_arg1);
#line 3562
  return (ldv_func_res);
}
}
#line 3565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_312(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___97 ldv_func_res ;
  int tmp ;

  {
#line 3569
  tmp = del_timer_sync(ldv_func_arg1);
#line 3569
  ldv_func_res = tmp;
#line 3571
  disable_suitable_timer_6(ldv_func_arg1);
#line 3573
  return (ldv_func_res);
}
}
#line 3576 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_313(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___98 ldv_func_res ;
  int tmp ;

  {
#line 3580
  tmp = del_timer_sync(ldv_func_arg1);
#line 3580
  ldv_func_res = tmp;
#line 3582
  disable_suitable_timer_6(ldv_func_arg1);
#line 3584
  return (ldv_func_res);
}
}
#line 3587 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_314(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___99 ldv_func_res ;
  int tmp ;

  {
#line 3591
  tmp = del_timer_sync(ldv_func_arg1);
#line 3591
  ldv_func_res = tmp;
#line 3593
  disable_suitable_timer_6(ldv_func_arg1);
#line 3595
  return (ldv_func_res);
}
}
#line 3598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_315(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___100 ldv_func_res ;
  int tmp ;

  {
#line 3602
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3602
  ldv_func_res = tmp;
#line 3604
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3606
  return (ldv_func_res);
}
}
#line 3609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_316(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___101 ldv_func_res ;
  int tmp ;

  {
#line 3613
  tmp = del_timer_sync(ldv_func_arg1);
#line 3613
  ldv_func_res = tmp;
#line 3615
  disable_suitable_timer_6(ldv_func_arg1);
#line 3617
  return (ldv_func_res);
}
}
#line 3620 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_317(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___102 ldv_func_res ;
  int tmp ;

  {
#line 3624
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3624
  ldv_func_res = tmp;
#line 3626
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3628
  return (ldv_func_res);
}
}
#line 3631 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_318(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___103 ldv_func_res ;
  int tmp ;

  {
#line 3635
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3635
  ldv_func_res = tmp;
#line 3637
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3639
  return (ldv_func_res);
}
}
#line 3642 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_319(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___104 ldv_func_res ;
  int tmp ;

  {
#line 3646
  tmp = del_timer_sync(ldv_func_arg1);
#line 3646
  ldv_func_res = tmp;
#line 3648
  disable_suitable_timer_6(ldv_func_arg1);
#line 3650
  return (ldv_func_res);
}
}
#line 3653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_del_timer_sync_320(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___105 ldv_func_res ;
  int tmp ;

  {
#line 3657
  tmp = del_timer_sync(ldv_func_arg1);
#line 3657
  ldv_func_res = tmp;
#line 3659
  disable_suitable_timer_6(ldv_func_arg1);
#line 3661
  return (ldv_func_res);
}
}
#line 3664 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_led.o.c.prepared"
int ldv_mod_timer_321(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___106 ldv_func_res ;
  int tmp ;

  {
#line 3668
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3668
  ldv_func_res = tmp;
#line 3670
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3672
  return (ldv_func_res);
}
}
#line 111 "include/linux/list.h"
extern void __list_del_entry(struct list_head * ) ;
#line 142 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 144
  __list_del_entry(entry);
#line 145
  INIT_LIST_HEAD(entry);
#line 146
  return;
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 290 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 292
  return (& lock->ldv_6347.rlock);
}
}
#line 310
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 295 "include/linux/jiffies.h"
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 179 "include/linux/timer.h"
int ldv_mod_timer_470(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 183
int ldv_mod_timer_471(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 187
int ldv_mod_timer_472(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 191
int ldv_mod_timer_473(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 195
int ldv_mod_timer_474(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 199
int ldv_mod_timer_476(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 203
int ldv_mod_timer_477(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 207
int ldv_mod_timer_478(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 211
int ldv_mod_timer_479(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 248
int ldv_del_timer_sync_469(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_475(struct timer_list *ldv_func_arg1 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_452(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct timer_list *ldv_timer_list_2_0 ;
#line 28
int ldv_timer_5_2 ;
#line 30
struct timer_list *ldv_timer_list_5_0 ;
#line 34
struct timer_list *ldv_timer_list_3_2 ;
#line 36
int ldv_timer_2_2 ;
#line 37
int ldv_timer_3_3 ;
#line 39
struct timer_list *ldv_timer_list_5_3 ;
#line 41
int ldv_timer_4_3 ;
#line 44
struct timer_list *ldv_timer_list_5_1 ;
#line 55
struct timer_list *ldv_timer_list_4_0 ;
#line 58
struct timer_list *ldv_timer_list_2_1 ;
#line 61
int ldv_timer_2_0 ;
#line 69
struct timer_list *ldv_timer_list_4_3 ;
#line 72
int ldv_timer_5_3 ;
#line 74
int ldv_timer_3_2 ;
#line 77
int ldv_timer_3_0 ;
#line 78
int ldv_timer_4_1 ;
#line 79
struct timer_list *ldv_timer_list_4_1 ;
#line 80
struct timer_list *ldv_timer_list_2_2 ;
#line 88
int ldv_timer_4_0 ;
#line 89
int ldv_timer_2_1 ;
#line 90
struct timer_list *ldv_timer_list_5_2 ;
#line 95
struct timer_list *ldv_timer_list_3_1 ;
#line 96
int ldv_timer_5_1 ;
#line 98
int ldv_timer_2_3 ;
#line 100
struct timer_list *ldv_timer_list_3_3 ;
#line 104
int ldv_timer_3_1 ;
#line 110
int ldv_timer_4_2 ;
#line 122
int ldv_timer_5_0 ;
#line 126
struct timer_list *ldv_timer_list_4_2 ;
#line 132
struct timer_list *ldv_timer_list_2_3 ;
#line 133
struct timer_list *ldv_timer_list_3_0 ;
#line 139
void ldv_timer_5(int state , struct timer_list *timer ) ;
#line 140
void choose_timer_5(void) ;
#line 142
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 143
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 144
void timer_init_4(void) ;
#line 147
void timer_init_2(void) ;
#line 151
void disable_suitable_timer_3(struct timer_list *timer ) ;
#line 152
void activate_suitable_timer_3(struct timer_list *timer , unsigned long data ) ;
#line 158
void timer_init_5(void) ;
#line 159
void disable_suitable_timer_2(struct timer_list *timer ) ;
#line 164
int reg_timer_3(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 166
void disable_suitable_timer_5(struct timer_list *timer ) ;
#line 170
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) ;
#line 171
void ldv_timer_2(int state , struct timer_list *timer ) ;
#line 174
void choose_timer_2(void) ;
#line 175
int reg_timer_2(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 179
void choose_timer_3(void) ;
#line 185
void timer_init_3(void) ;
#line 193
void choose_timer_4(void) ;
#line 195
void disable_suitable_timer_4(struct timer_list *timer ) ;
#line 197
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 201
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 205
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 211
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 212
void ldv_timer_4(int state , struct timer_list *timer ) ;
#line 213
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) ;
#line 216
void activate_suitable_timer_2(struct timer_list *timer , unsigned long data ) ;
#line 218
void ldv_timer_3(int state , struct timer_list *timer ) ;
#line 111 "include/linux/pid.h"
extern struct pid *find_vpid(int  ) ;
#line 2311 "include/linux/sched.h"
extern int kill_pid(struct pid * , int  , int  ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_460(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_468(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_462(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_458(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_466(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_467(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_463(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_464(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_465(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2695 "include/linux/netdevice.h"
extern void netif_carrier_on(struct net_device * ) ;
#line 89 "include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 92
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
#line 107 "include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 109
  return (((int )*addr & 1) != 0);
}
}
#line 266 "include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 269
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 272
  return (fold == 0U);
}
}
#line 3109 "include/net/cfg80211.h"
__inline static void *wiphy_priv(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
#line 3111
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
#line 3111
  if (tmp != 0L) {
#line 3111
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3111), "i" (12UL));
    ldv_45953: ;
#line 3111
    goto ldv_45953;
  } else {

  }
#line 3112
  return ((void *)(& wiphy->priv));
}
}
#line 3341 "include/net/cfg80211.h"
__inline static void *wdev_priv(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 3343
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
#line 3343
  if (tmp != 0L) {
#line 3343
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3343), "i" (12UL));
    ldv_46033: ;
#line 3343
    goto ldv_46033;
  } else {

  }
#line 3344
  tmp___0 = wiphy_priv(wdev->wiphy);
#line 3344
  return (tmp___0);
}
}
#line 76 "drivers/staging/rtl8723au/include/osdep_service.h"
unsigned char MCS_rate_2R23A[16U] ;
#line 79
unsigned char MCS_rate_1R23A[16U] ;
#line 81
void _rtw_init_queue23a(struct rtw_queue *pqueue ) ;
#line 351 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void rtw_update_protection23a(struct rtw_adapter *padapter , u8 *ie , uint ie_len ) ;
#line 26 "drivers/staging/rtl8723au/include/xmit_osdep.h"
void rtw_os_xmit_schedule23a(struct rtw_adapter *padapter ) ;
#line 283 "drivers/staging/rtl8723au/include/rtw_recv.h"
u32 rtw_free_uc_swdec_pending_queue23a(struct rtw_adapter *adapter ) ;
#line 291 "drivers/staging/rtl8723au/include/rtw_recv.h"
__inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex ) 
{ 
  s32 SignalPower ;

  {
#line 296
  SignalPower = (int )((SignalStrengthIndex + 1U) >> 1);
#line 297
  SignalPower = SignalPower + -95;
#line 299
  return (SignalPower);
}
}
#line 120 "drivers/staging/rtl8723au/include/hal_intf.h"
int GetHalDefVar8192CUsb(struct rtw_adapter *Adapter , enum hal_def_variable eVariable ,
                         void *pValue ) ;
#line 199 "drivers/staging/rtl8723au/include/hal_com.h"
void rtl8723a_set_rxdma_agg_pg_th(struct rtw_adapter *padapter , u8 val ) ;
#line 366 "drivers/staging/rtl8723au/include/sta_info.h"
int rtw_free_stainfo23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 367
void rtw_free_all_stainfo23a(struct rtw_adapter *padapter ) ;
#line 369
int rtw_init_bcmc_stainfo23a(struct rtw_adapter *padapter ) ;
#line 371
bool rtw_access_ctrl23a(struct rtw_adapter *padapter , u8 *mac_addr ) ;
#line 21 "drivers/staging/rtl8723au/include/mlme_osdep.h"
void rtw_os_indicate_disconnect23a(struct rtw_adapter *adapter ) ;
#line 22
void rtw_reset_securitypriv23a(struct rtw_adapter *adapter ) ;
#line 228 "drivers/staging/rtl8723au/include/rtw_mlme.h"
void rtw_joinbss_event_prehandle23a(struct rtw_adapter *adapter , u8 *pbuf ) ;
#line 229
void rtw_survey_event_cb23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 230
void rtw_surveydone_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 231
void rtw23a_joinbss_event_cb(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 232
void rtw_stassoc_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 233
void rtw_stadel_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) ;
#line 236
void rtw23a_join_to_handler(unsigned long data ) ;
#line 239
int rtw_init_mlme_priv23a(struct rtw_adapter *padapter ) ;
#line 241
void rtw_free_mlme_priv23a(struct mlme_priv *pmlmepriv ) ;
#line 244
int rtw_set_key23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ,
                   int keyid , u8 set_tx ) ;
#line 310
u16 rtw_get_capability23a(struct wlan_bssid_ex *bss ) ;
#line 311
void rtw_update_scanned_network23a(struct rtw_adapter *adapter , struct wlan_bssid_ex *target ) ;
#line 316
struct wlan_network *rtw_find_network23a(struct rtw_queue *scanned_queue , u8 *addr ) ;
#line 323
void rtw_scan_abort23a(struct rtw_adapter *adapter ) ;
#line 329
void rtw_init_registrypriv_dev_network23a(struct rtw_adapter *adapter ) ;
#line 333
void rtw_get_encrypt_decrypt_from_registrypriv23a(struct rtw_adapter *adapter ) ;
#line 335
void rtw_scan_timeout_handler23a(unsigned long data ) ;
#line 337
void rtw_dynamic_check_timer_handler(unsigned long data ) ;
#line 339
void rtw_clear_scan_deny(struct rtw_adapter *adapter ) ;
#line 340
void rtw_set_scan_deny_timer_hdl(unsigned long data ) ;
#line 341
void rtw_set_scan_deny(struct rtw_adapter *adapter , u32 ms ) ;
#line 343
void rtw23a_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv ) ;
#line 349
int rtw_if_up23a(struct rtw_adapter *padapter ) ;
#line 351
int rtw_linked_check(struct rtw_adapter *padapter ) ;
#line 354
__le16 *rtw_get_beacon_interval23a_from_ie(u8 *ie ) ;
#line 357
void rtw_joinbss_reset23a(struct rtw_adapter *padapter ) ;
#line 361
void rtw_update_ht_cap23a(struct rtw_adapter *padapter , u8 *pie , uint ie_len ) ;
#line 363
void rtw_issue_addbareq_cmd23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 368
int is_same_network23a(struct wlan_bssid_ex *src , struct wlan_bssid_ex *dst ) ;
#line 370
void rtw23a_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) ;
#line 372
void rtw_set_roaming(struct rtw_adapter *adapter , u8 to_roaming ) ;
#line 501 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
void update_network23a(struct wlan_bssid_ex *dst , struct wlan_bssid_ex *src , struct rtw_adapter *padapter ,
                       bool update_ie ) ;
#line 536
void update_sta_info23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 590
void mlmeext_joinbss_event_callback23a(struct rtw_adapter *padapter , int join_res ) ;
#line 591
void mlmeext_sta_del_event_callback23a(struct rtw_adapter *padapter ) ;
#line 592
void mlmeext_sta_add_event_callback23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 45 "drivers/staging/rtl8723au/include/rtw_ap.h"
void ap_sta_info_defer_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 50 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter ) ;
#line 52
void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter ) ;
#line 53
void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter ) ;
#line 54
void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv , bool aborted ) ;
#line 274 "drivers/staging/rtl8723au/include/drv_types.h"
__inline static u8 *myid(struct eeprom_priv *peepriv ) 
{ 


  {
#line 276
  return ((u8 *)(& peepriv->mac_addr));
}
}
#line 546 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_SetHalODMVar(struct rtw_adapter *Adapter , enum hal_odm_variable eVariable ,
                           void *pValue1 , bool bSet ) ;
#line 54 "drivers/staging/rtl8723au/include/rtw_sreset.h"
void rtw_sreset_reset(struct rtw_adapter *active_adapter ) ;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void rtw_init_mlme_timer(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
#line 250
  pmlmepriv = & padapter->mlmepriv;
#line 252
  reg_timer_6(& pmlmepriv->assoc_timer, & rtw23a_join_to_handler, (unsigned long )padapter);
#line 255
  reg_timer_6(& pmlmepriv->scan_to_timer, & rtw_scan_timeout_handler23a, (unsigned long )padapter);
#line 258
  reg_timer_6(& pmlmepriv->dynamic_chk_timer, & rtw_dynamic_check_timer_handler, (unsigned long )padapter);
#line 261
  reg_timer_6(& pmlmepriv->set_scan_deny_timer, & rtw_set_scan_deny_timer_hdl, (unsigned long )padapter);
#line 262
  return;
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int rtw_init_mlme_priv23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  int res ;
  struct lock_class_key __key ;

  {
#line 267
  pmlmepriv = & padapter->mlmepriv;
#line 268
  res = 1;
#line 270
  pmlmepriv->nic_hdl = padapter;
#line 272
  pmlmepriv->fw_state = 0;
#line 273
  pmlmepriv->cur_network.network.ifmode = 0;
#line 276
  pmlmepriv->scan_mode = 1;
#line 278
  spinlock_check(& pmlmepriv->lock);
#line 278
  __raw_spin_lock_init(& pmlmepriv->lock.ldv_6347.rlock, "&(&pmlmepriv->lock)->rlock",
                       & __key);
#line 279
  _rtw_init_queue23a(& pmlmepriv->scanned_queue);
#line 281
  memset((void *)(& pmlmepriv->assoc_ssid), 0, 33UL);
#line 283
  rtw_clear_scan_deny(padapter);
#line 285
  rtw_init_mlme_timer(padapter);
#line 286
  return (res);
}
}
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void rtw_free_mlme_ie_data(u8 **ppie , u32 *plen ) 
{ 


  {
#line 292
  if ((unsigned long )*ppie != (unsigned long )((u8 *)0U)) {
#line 293
    kfree((void const   *)*ppie);
#line 294
    *plen = 0U;
#line 295
    *ppie = (u8 *)0U;
  } else {

  }
#line 297
  return;
}
}
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw23a_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv ) 
{ 


  {
#line 303
  kfree((void const   *)pmlmepriv->assoc_req);
#line 304
  kfree((void const   *)pmlmepriv->assoc_rsp);
#line 305
  rtw_free_mlme_ie_data(& pmlmepriv->wps_beacon_ie, & pmlmepriv->wps_beacon_ie_len);
#line 307
  rtw_free_mlme_ie_data(& pmlmepriv->wps_probe_req_ie, & pmlmepriv->wps_probe_req_ie_len);
#line 309
  rtw_free_mlme_ie_data(& pmlmepriv->wps_probe_resp_ie, & pmlmepriv->wps_probe_resp_ie_len);
#line 311
  rtw_free_mlme_ie_data(& pmlmepriv->wps_assoc_resp_ie, & pmlmepriv->wps_assoc_resp_ie_len);
#line 314
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_beacon_ie, & pmlmepriv->p2p_beacon_ie_len);
#line 316
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_probe_req_ie, & pmlmepriv->p2p_probe_req_ie_len);
#line 318
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_probe_resp_ie, & pmlmepriv->p2p_probe_resp_ie_len);
#line 320
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_go_probe_resp_ie, & pmlmepriv->p2p_go_probe_resp_ie_len);
#line 322
  rtw_free_mlme_ie_data(& pmlmepriv->p2p_assoc_req_ie, & pmlmepriv->p2p_assoc_req_ie_len);
#line 325
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_beacon_ie, & pmlmepriv->wfd_beacon_ie_len);
#line 327
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_probe_req_ie, & pmlmepriv->wfd_probe_req_ie_len);
#line 329
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_probe_resp_ie, & pmlmepriv->wfd_probe_resp_ie_len);
#line 331
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_go_probe_resp_ie, & pmlmepriv->wfd_go_probe_resp_ie_len);
#line 333
  rtw_free_mlme_ie_data(& pmlmepriv->wfd_assoc_req_ie, & pmlmepriv->wfd_assoc_req_ie_len);
#line 335
  return;
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_free_mlme_priv23a(struct mlme_priv *pmlmepriv ) 
{ 


  {
#line 340
  if (GlobalDebugLevel23A > 3U) {
#line 340
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 340
    printk("\016rtw_free_mlme_priv23a\n");
  } else {

  }
#line 343
  rtw23a_free_mlme_priv_ie_data(pmlmepriv);
#line 344
  return;
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv , int gfp ) 
{ 
  struct wlan_network *pnetwork ;
  void *tmp ;

  {
#line 350
  tmp = kzalloc(928UL, (gfp_t )gfp);
#line 350
  pnetwork = (struct wlan_network *)tmp;
#line 351
  if ((unsigned long )pnetwork != (unsigned long )((struct wlan_network *)0)) {
#line 352
    INIT_LIST_HEAD(& pnetwork->list);
#line 353
    pnetwork->network_type = 0;
#line 354
    pnetwork->fixed = 0;
#line 355
    pnetwork->last_scanned = jiffies;
#line 356
    pnetwork->aid = 0;
#line 357
    pnetwork->join_res = 0;
  } else {

  }
#line 360
  return (pnetwork);
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void _rtw_free_network23a(struct mlme_priv *pmlmepriv , struct wlan_network *pnetwork ) 
{ 


  {
#line 366
  if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
#line 367
    return;
  } else {

  }
#line 369
  if (pnetwork->fixed == 1) {
#line 370
    return;
  } else {

  }
#line 372
  list_del_init(& pnetwork->list);
#line 374
  kfree((void const   *)pnetwork);
#line 375
  return;
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct wlan_network *rtw_find_network23a(struct rtw_queue *scanned_queue , u8 *addr ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct wlan_network *pnetwork ;
  bool tmp ;
  struct list_head  const  *__mptr ;
  bool tmp___0 ;

  {
#line 386
  pnetwork = (struct wlan_network *)0;
#line 388
  tmp = is_zero_ether_addr((u8 const   *)addr);
#line 388
  if ((int )tmp) {
#line 389
    pnetwork = (struct wlan_network *)0;
#line 390
    goto exit;
  } else {

  }
#line 395
  phead = get_list_head(scanned_queue);
#line 396
  plist = phead->next;
#line 398
  goto ldv_54345;
  ldv_54344: 
#line 399
  __mptr = (struct list_head  const  *)plist;
#line 399
  pnetwork = (struct wlan_network *)__mptr;
#line 401
  tmp___0 = ether_addr_equal((u8 const   *)addr, (u8 const   *)(& pnetwork->network.MacAddress));
#line 401
  if ((int )tmp___0) {
#line 402
    goto ldv_54343;
  } else {

  }
#line 404
  plist = plist->next;
  ldv_54345: ;
#line 398
  if ((unsigned long )plist != (unsigned long )phead) {
#line 400
    goto ldv_54344;
  } else {

  }
  ldv_54343: ;
#line 407
  if ((unsigned long )plist == (unsigned long )phead) {
#line 408
    pnetwork = (struct wlan_network *)0;
  } else {

  }
  exit: ;
#line 414
  return (pnetwork);
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_free_network_queue23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct wlan_network *pnetwork ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *scanned_queue ;
  struct list_head  const  *__mptr ;

  {
#line 421
  pmlmepriv = & padapter->mlmepriv;
#line 422
  scanned_queue = & pmlmepriv->scanned_queue;
#line 424
  spin_lock_bh(& scanned_queue->lock);
#line 426
  phead = get_list_head(scanned_queue);
#line 428
  plist = phead->next;
#line 428
  ptmp = plist->next;
#line 428
  goto ldv_54358;
  ldv_54357: 
#line 429
  __mptr = (struct list_head  const  *)plist;
#line 429
  pnetwork = (struct wlan_network *)__mptr;
#line 431
  _rtw_free_network23a(pmlmepriv, pnetwork);
#line 428
  plist = ptmp;
#line 428
  ptmp = plist->next;
  ldv_54358: ;
#line 428
  if ((unsigned long )plist != (unsigned long )phead) {
#line 430
    goto ldv_54357;
  } else {

  }
#line 434
  spin_unlock_bh(& scanned_queue->lock);
#line 435
  return;
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int rtw_if_up23a(struct rtw_adapter *padapter ) 
{ 
  int res ;
  bool tmp ;
  int tmp___0 ;

  {
#line 441
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 441
    goto _L;
  } else {
#line 441
    tmp = check_fwstate(& padapter->mlmepriv, 1);
#line 441
    if (tmp) {
#line 441
      tmp___0 = 0;
    } else {
#line 441
      tmp___0 = 1;
    }
#line 441
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 443
      if (GlobalDebugLevel23A > 6U) {
#line 443
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 443
        printk("\016rtw_if_up23a:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped,
               padapter->bSurpriseRemoved);
      } else {

      }
#line 447
      res = 0;
    } else {
#line 449
      res = 1;
    }
  }
#line 451
  return (res);
}
}
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_generate_random_ibss23a(u8 *pibss ) 
{ 
  unsigned long curtime ;

  {
#line 456
  curtime = jiffies;
#line 458
  *pibss = 2U;
#line 459
  *(pibss + 1UL) = 17U;
#line 460
  *(pibss + 2UL) = 135U;
#line 461
  *(pibss + 3UL) = (u8 )curtime;
#line 462
  *(pibss + 4UL) = (u8 )(curtime >> 8);
#line 463
  *(pibss + 5UL) = (u8 )(curtime >> 16);
#line 465
  return;
}
}
#line 468 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_set_roaming(struct rtw_adapter *adapter , u8 to_roaming ) 
{ 


  {
#line 470
  if ((unsigned int )to_roaming == 0U) {
#line 471
    adapter->mlmepriv.to_join = 0U;
  } else {

  }
#line 472
  adapter->mlmepriv.to_roaming = to_roaming;
#line 473
  return;
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void _rtw_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  int do_join_r ;
  size_t __len ;
  void *__ret ;

  {
#line 478
  pmlmepriv = & padapter->mlmepriv;
#line 482
  if ((unsigned long )tgt_network != (unsigned long )((struct wlan_network *)0)) {
#line 483
    pnetwork = tgt_network;
  } else {
#line 485
    pnetwork = & pmlmepriv->cur_network;
  }
#line 487
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 488
    if (GlobalDebugLevel23A > 3U) {
#line 488
      printk("\016RTL8723AU: roaming from %s(%02x:%02x:%02x:%02x:%02x:%02x), length:%d\n",
             (u8 *)(& pnetwork->network.Ssid.ssid), (int )*((u8 *)(& pnetwork->network.MacAddress)),
             (int )*((u8 *)(& pnetwork->network.MacAddress) + 1UL), (int )*((u8 *)(& pnetwork->network.MacAddress) + 2UL),
             (int )*((u8 *)(& pnetwork->network.MacAddress) + 3UL), (int )*((u8 *)(& pnetwork->network.MacAddress) + 4UL),
             (int )*((u8 *)(& pnetwork->network.MacAddress) + 5UL), (int )pnetwork->network.Ssid.ssid_len);
    } else {

    }
#line 492
    __len = 33UL;
#line 492
    if (__len > 63UL) {
#line 492
      __ret = __memcpy((void *)(& pmlmepriv->assoc_ssid), (void const   *)(& pnetwork->network.Ssid),
                       __len);
    } else {
#line 492
      __ret = __builtin_memcpy((void *)(& pmlmepriv->assoc_ssid), (void const   *)(& pnetwork->network.Ssid),
                               __len);
    }
#line 495
    pmlmepriv->assoc_by_bssid = 0U;
    ldv_54385: 
#line 498
    do_join_r = rtw_do_join23a(padapter);
#line 499
    if (do_join_r == 1) {
#line 500
      goto ldv_54382;
    } else {
#line 502
      if (GlobalDebugLevel23A > 3U) {
#line 502
        printk("\016RTL8723AU: roaming do_join return %d\n", do_join_r);
      } else {

      }
#line 504
      pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
#line 506
      if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 507
        goto ldv_54383;
      } else {
#line 509
        if (GlobalDebugLevel23A > 3U) {
#line 509
          printk("\016RTL8723AU: %s(%d) -to roaming fail, indicate_disconnect\n",
                 "_rtw_roaming", 511);
        } else {

        }
#line 512
        rtw_indicate_disconnect23a(padapter);
#line 513
        goto ldv_54382;
      }
    }
    ldv_54383: ;
#line 516
    goto ldv_54385;
    ldv_54382: ;
  } else {

  }
#line 519
  return;
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw23a_roaming(struct rtw_adapter *padapter , struct wlan_network *tgt_network ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
#line 523
  pmlmepriv = & padapter->mlmepriv;
#line 525
  spin_lock_bh(& pmlmepriv->lock);
#line 526
  _rtw_roaming(padapter, tgt_network);
#line 527
  spin_unlock_bh(& pmlmepriv->lock);
#line 528
  return;
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
__le16 *rtw_get_capability23a_from_ie(u8 *ie ) 
{ 


  {
#line 532
  return ((__le16 *)ie + 10U);
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
u16 rtw_get_capability23a(struct wlan_bssid_ex *bss ) 
{ 
  u16 val ;
  size_t __len ;
  void *__ret ;
  __le16 *tmp ;
  __le16 *tmp___0 ;

  {
#line 539
  __len = 2UL;
#line 539
  if (__len > 63UL) {
#line 539
    tmp = rtw_get_capability23a_from_ie((u8 *)(& bss->IEs));
#line 539
    __ret = __memcpy((void *)(& val), (void const   *)tmp, __len);
  } else {
#line 539
    tmp___0 = rtw_get_capability23a_from_ie((u8 *)(& bss->IEs));
#line 539
    __ret = __builtin_memcpy((void *)(& val), (void const   *)tmp___0, __len);
  }
#line 541
  return (val);
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
__le16 *rtw_get_beacon_interval23a_from_ie(u8 *ie ) 
{ 


  {
#line 546
  return ((__le16 *)ie + 8U);
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void rtw_free_network_nolock(struct mlme_priv *pmlmepriv , struct wlan_network *pnetwork ) 
{ 


  {
#line 552
  _rtw_free_network23a(pmlmepriv, pnetwork);
#line 553
  return;
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int rtw_is_same_ibss23a(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) 
{ 
  int ret ;
  struct security_priv *psecuritypriv ;

  {
#line 558
  ret = 1;
#line 559
  psecuritypriv = & adapter->securitypriv;
#line 561
  if (psecuritypriv->dot11PrivacyAlgrthm != 0U && pnetwork->network.Privacy == 0U) {
#line 563
    ret = 0;
  } else
#line 564
  if (psecuritypriv->dot11PrivacyAlgrthm == 0U && pnetwork->network.Privacy == 1U) {
#line 566
    ret = 0;
  } else {
#line 568
    ret = 1;
  }
#line 570
  return (ret);
}
}
#line 573
__inline int is_same_ess(struct wlan_bssid_ex *a , struct wlan_bssid_ex *b ) ;
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
__inline int is_same_ess(struct wlan_bssid_ex *a , struct wlan_bssid_ex *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 576
  if ((int )a->Ssid.ssid_len == (int )b->Ssid.ssid_len) {
#line 576
    tmp = memcmp((void const   *)(& a->Ssid.ssid), (void const   *)(& b->Ssid.ssid),
                 (size_t )a->Ssid.ssid_len);
#line 576
    if (tmp == 0) {
#line 576
      tmp___0 = 1;
    } else {
#line 576
      tmp___0 = 0;
    }
  } else {
#line 576
    tmp___0 = 0;
  }
#line 576
  return (tmp___0);
}
}
#line 580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int is_same_network23a(struct wlan_bssid_ex *src , struct wlan_bssid_ex *dst ) 
{ 
  u16 s_cap ;
  u16 d_cap ;
  __le16 *tmp ;
  __le16 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 584
  tmp = rtw_get_capability23a_from_ie((u8 *)(& src->IEs));
#line 584
  s_cap = get_unaligned_le16((void const   *)tmp);
#line 585
  tmp___0 = rtw_get_capability23a_from_ie((u8 *)(& dst->IEs));
#line 585
  d_cap = get_unaligned_le16((void const   *)tmp___0);
#line 587
  if ((int )src->Ssid.ssid_len == (int )dst->Ssid.ssid_len) {
#line 587
    tmp___1 = ether_addr_equal((u8 const   *)(& src->MacAddress), (u8 const   *)(& dst->MacAddress));
#line 587
    if ((int )tmp___1) {
#line 587
      tmp___2 = memcmp((void const   *)(& src->Ssid.ssid), (void const   *)(& dst->Ssid.ssid),
                       (size_t )src->Ssid.ssid_len);
#line 587
      if (tmp___2 == 0) {
#line 587
        if ((((int )s_cap ^ (int )d_cap) & 2) == 0) {
#line 587
          if ((((int )s_cap ^ (int )d_cap) & 1) == 0) {
#line 587
            tmp___3 = 1;
          } else {
#line 587
            tmp___3 = 0;
          }
        } else {
#line 587
          tmp___3 = 0;
        }
      } else {
#line 587
        tmp___3 = 0;
      }
    } else {
#line 587
      tmp___3 = 0;
    }
  } else {
#line 587
    tmp___3 = 0;
  }
#line 587
  return (tmp___3);
}
}
#line 598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct wlan_network *rtw_get_oldest_wlan_network23a(struct rtw_queue *scanned_queue ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct wlan_network *pwlan ;
  struct wlan_network *oldest ;
  struct list_head  const  *__mptr ;

  {
#line 602
  oldest = (struct wlan_network *)0;
#line 604
  phead = get_list_head(scanned_queue);
#line 606
  plist = phead->next;
#line 606
  goto ldv_54443;
  ldv_54442: 
#line 607
  __mptr = (struct list_head  const  *)plist;
#line 607
  pwlan = (struct wlan_network *)__mptr;
#line 609
  if (pwlan->fixed != 1) {
#line 610
    if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0) || (long )(pwlan->last_scanned - oldest->last_scanned) < 0L) {
#line 612
      oldest = pwlan;
    } else {

    }
  } else {

  }
#line 606
  plist = plist->next;
  ldv_54443: ;
#line 606
  if ((unsigned long )plist != (unsigned long )phead) {
#line 608
    goto ldv_54442;
  } else {

  }

#line 616
  return (oldest);
}
}
#line 619 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void update_network23a(struct wlan_bssid_ex *dst , struct wlan_bssid_ex *src , struct rtw_adapter *padapter ,
                       bool update_ie ) 
{ 
  u8 ss_ori ;
  u8 sq_ori ;
  long rssi_ori ;
  u8 ss_smp ;
  u8 sq_smp ;
  long rssi_smp ;
  u8 ss_final ;
  u8 sq_final ;
  long rssi_final ;
  bool tmp ;
  int tmp___0 ;
  size_t __len ;
  uint tmp___1 ;
  void *__ret ;

  {
#line 622
  ss_ori = dst->PhyInfo.SignalStrength;
#line 623
  sq_ori = dst->PhyInfo.SignalQuality;
#line 624
  rssi_ori = dst->Rssi;
#line 626
  ss_smp = src->PhyInfo.SignalStrength;
#line 627
  sq_smp = src->PhyInfo.SignalQuality;
#line 628
  rssi_smp = src->Rssi;
#line 634
  if (GlobalDebugLevel23A > 3U) {
#line 634
    printk("\016RTL8723AU: %s %s(%pM, ch%u) ss_ori:%3u, sq_ori:%3u, rssi_ori:%3ld, ss_smp:%3u, sq_smp:%3u, rssi_smp:%3ld\n",
           "update_network23a", (u8 *)(& src->Ssid.ssid), (u8 *)(& src->MacAddress),
           src->DSConfig, (int )ss_ori, (int )sq_ori, rssi_ori, (int )ss_smp, (int )sq_smp,
           rssi_smp);
  } else {

  }
#line 642
  tmp = check_fwstate(& padapter->mlmepriv, 1);
#line 642
  if ((int )tmp) {
#line 642
    tmp___0 = is_same_network23a(& padapter->mlmepriv.cur_network.network, src);
#line 642
    if (tmp___0 != 0) {
#line 645
      ss_final = padapter->recvpriv.signal_strength;
#line 646
      sq_final = padapter->recvpriv.signal_qual;
#line 649
      if ((unsigned int )sq_smp != 101U) {
#line 650
        rssi_final = (src->Rssi + dst->Rssi * 4L) / 5L;
      } else {
#line 652
        rssi_final = rssi_ori;
      }
    } else {
#line 642
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 654
  if ((unsigned int )sq_smp != 101U) {
#line 655
    ss_final = (u8 )(((unsigned int )src->PhyInfo.SignalStrength + (unsigned int )dst->PhyInfo.SignalStrength * 4U) / 5U);
#line 657
    sq_final = (u8 )(((unsigned int )src->PhyInfo.SignalQuality + (unsigned int )dst->PhyInfo.SignalQuality * 4U) / 5U);
#line 659
    rssi_final = src->Rssi + (dst->Rssi * 4L) / 5L;
  } else {
#line 663
    ss_final = dst->PhyInfo.SignalStrength;
#line 664
    sq_final = dst->PhyInfo.SignalQuality;
#line 665
    rssi_final = dst->Rssi;
  }
#line 670
  if ((int )update_ie) {
#line 671
    tmp___1 = get_wlan_bssid_ex_sz(src);
#line 671
    __len = (size_t )tmp___1;
#line 671
    __ret = __builtin_memcpy((void *)dst, (void const   *)src, __len);
  } else {

  }
#line 673
  dst->PhyInfo.SignalStrength = ss_final;
#line 674
  dst->PhyInfo.SignalQuality = sq_final;
#line 675
  dst->Rssi = rssi_final;
#line 677
  if (GlobalDebugLevel23A > 3U) {
#line 677
    printk("\016RTL8723AU: %s %s(%pM), SignalStrength:%u, SignalQuality:%u, RawRSSI:%ld\n",
           "update_network23a", (u8 *)(& dst->Ssid.ssid), (u8 *)(& dst->MacAddress),
           (int )dst->PhyInfo.SignalStrength, (int )dst->PhyInfo.SignalQuality, dst->Rssi);
  } else {

  }
#line 678
  return;
}
}
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void update_current_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *pnetwork ) 
{ 
  struct mlme_priv *pmlmepriv ;
  int bcn_size ;
  bool tmp ;
  int tmp___0 ;

  {
#line 686
  pmlmepriv = & adapter->mlmepriv;
#line 688
  tmp = check_fwstate(pmlmepriv, 1);
#line 688
  if ((int )tmp) {
#line 688
    tmp___0 = is_same_network23a(& pmlmepriv->cur_network.network, pnetwork);
#line 688
    if (tmp___0 != 0) {
#line 691
      update_network23a(& pmlmepriv->cur_network.network, pnetwork, adapter, 1);
#line 694
      bcn_size = 12;
#line 697
      rtw_update_protection23a(adapter, (u8 *)(& pmlmepriv->cur_network.network.IEs) + (unsigned long )bcn_size,
                               pmlmepriv->cur_network.network.IELength);
    } else {

    }
  } else {

  }
#line 702
  return;
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_update_scanned_network23a(struct rtw_adapter *adapter , struct wlan_bssid_ex *target ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  struct wlan_network *oldest ;
  struct rtw_queue *queue ;
  u32 bssid_ex_sz ;
  int found ;
  struct list_head  const  *__mptr ;
  int tmp ;
  size_t __len ;
  void *__ret ;
  bool update_ie ;

  {
#line 713
  pmlmepriv = & adapter->mlmepriv;
#line 714
  pnetwork = (struct wlan_network *)0;
#line 715
  oldest = (struct wlan_network *)0;
#line 716
  queue = & pmlmepriv->scanned_queue;
#line 718
  found = 0;
#line 720
  spin_lock_bh(& queue->lock);
#line 721
  phead = get_list_head(queue);
#line 723
  plist = phead->next;
#line 723
  goto ldv_54492;
  ldv_54491: 
#line 724
  __mptr = (struct list_head  const  *)plist;
#line 724
  pnetwork = (struct wlan_network *)__mptr;
#line 726
  tmp = is_same_network23a(& pnetwork->network, target);
#line 726
  if (tmp != 0) {
#line 727
    found = 1;
#line 728
    goto ldv_54484;
  } else {

  }
#line 730
  if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0) || (long )(pnetwork->last_scanned - oldest->last_scanned) < 0L) {
#line 732
    oldest = pnetwork;
  } else {

  }
#line 723
  plist = plist->next;
  ldv_54492: ;
#line 723
  if ((unsigned long )plist != (unsigned long )phead) {
#line 725
    goto ldv_54491;
  } else {

  }
  ldv_54484: ;
#line 737
  if (found == 0) {
#line 738
    pnetwork = rtw_alloc_network(pmlmepriv, 32);
#line 739
    if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
#line 740
      if ((unsigned long )oldest == (unsigned long )((struct wlan_network *)0)) {
#line 741
        if (GlobalDebugLevel23A > 3U) {
#line 741
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 741
          printk("\016\n\n\nsomething wrong here\n\n\n");
        } else {

        }
#line 743
        goto exit;
      } else {

      }
#line 745
      pnetwork = oldest;
    } else {
#line 747
      list_add_tail(& pnetwork->list, & queue->queue);
    }
#line 749
    bssid_ex_sz = get_wlan_bssid_ex_sz(target);
#line 750
    target->Length = bssid_ex_sz;
#line 751
    __len = (size_t )bssid_ex_sz;
#line 751
    __ret = __builtin_memcpy((void *)(& pnetwork->network), (void const   *)target,
                             __len);
#line 754
    pnetwork->fixed = 0;
#line 755
    pnetwork->last_scanned = jiffies;
#line 757
    pnetwork->network_type = 0;
#line 758
    pnetwork->aid = 0;
#line 759
    pnetwork->join_res = 0;
#line 762
    if ((unsigned int )pnetwork->network.PhyInfo.SignalQuality == 101U) {
#line 763
      pnetwork->network.PhyInfo.SignalQuality = 0U;
    } else {

    }
  } else {
#line 771
    update_ie = 1;
#line 773
    pnetwork->last_scanned = jiffies;
#line 777
    if (pnetwork->network.IELength > target->IELength && (unsigned int )target->reserved == 1U) {
#line 779
      update_ie = 0;
    } else {

    }
#line 781
    update_network23a(& pnetwork->network, target, adapter, (int )update_ie);
  }
  exit: 
#line 786
  spin_unlock_bh(& queue->lock);
#line 787
  return;
}
}
#line 789 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void rtw_add_network(struct rtw_adapter *adapter , struct wlan_bssid_ex *pnetwork ) 
{ 


  {
#line 792
  update_current_network(adapter, pnetwork);
#line 793
  rtw_update_scanned_network23a(adapter, pnetwork);
#line 794
  return;
}
}
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static int rtw_is_desired_network(struct rtw_adapter *adapter , struct wlan_network *pnetwork ) 
{ 
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  u32 desired_encmode ;
  u32 privacy ;
  uint wps_ielen ;
  int bselected ;
  u8 *tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 805
  psecuritypriv = & adapter->securitypriv;
#line 806
  pmlmepriv = & adapter->mlmepriv;
#line 813
  bselected = 1;
#line 815
  desired_encmode = psecuritypriv->ndisencryptstatus;
#line 816
  privacy = pnetwork->network.Privacy;
#line 818
  tmp___0 = check_fwstate(pmlmepriv, 256);
#line 818
  if ((int )tmp___0) {
#line 819
    tmp = rtw_get_wps_ie23a((u8 *)(& pnetwork->network.IEs) + 12UL, pnetwork->network.IELength - 12U,
                            (u8 *)0U, & wps_ielen);
#line 819
    if ((unsigned long )tmp != (unsigned long )((u8 *)0U)) {
#line 822
      return (1);
    } else {
#line 824
      return (0);
    }
  } else {

  }
#line 826
  if ((unsigned int )adapter->registrypriv.wifi_spec == 1U) {
#line 828
    if (desired_encmode == 1U && privacy != 0U) {
#line 830
      bselected = 0;
    } else {

    }
  } else {

  }
#line 833
  if (desired_encmode != 1U && privacy == 0U) {
#line 835
    if (GlobalDebugLevel23A > 3U) {
#line 835
      printk("\016RTL8723AU: desired_encmode: %d, privacy: %d\n", desired_encmode,
             privacy);
    } else {

    }
#line 837
    bselected = 0;
  } else {

  }
#line 840
  tmp___1 = check_fwstate(pmlmepriv, 32);
#line 840
  if ((int )tmp___1) {
#line 841
    if ((unsigned int )pnetwork->network.ifmode != (unsigned int )pmlmepriv->cur_network.network.ifmode) {
#line 843
      bselected = 0;
    } else {

    }
  } else {

  }
#line 846
  return (bselected);
}
}
#line 850 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_atimdone_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 


  {
#line 852
  if (GlobalDebugLevel23A > 3U) {
#line 852
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 852
    printk("\016receive atimdone_evet\n");
  } else {

  }
#line 854
  return;
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_survey_event_cb23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  u32 len ;
  struct wlan_bssid_ex *pnetwork ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *ibss_wlan ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 861
  pmlmepriv = & adapter->mlmepriv;
#line 863
  pnetwork = (struct wlan_bssid_ex *)pbuf;
#line 865
  if (GlobalDebugLevel23A > 6U) {
#line 865
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 865
    printk("\016rtw_survey_event_cb23a, ssid=%s\n", (u8 *)(& pnetwork->Ssid.ssid));
  } else {

  }
#line 868
  len = get_wlan_bssid_ex_sz(pnetwork);
#line 869
  if (len > 863U) {
#line 870
    if (GlobalDebugLevel23A > 3U) {
#line 870
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 870
      printk("\016\n ****rtw_survey_event_cb23a: return a wrong bss ***\n");
    } else {

    }
#line 873
    return;
  } else {

  }
#line 876
  spin_lock_bh(& pmlmepriv->lock);
#line 879
  tmp___0 = check_fwstate(pmlmepriv, 64);
#line 879
  if ((int )tmp___0) {
#line 882
    tmp = ether_addr_equal((u8 const   *)(& pmlmepriv->cur_network.network.MacAddress),
                           (u8 const   *)(& pnetwork->MacAddress));
#line 882
    if ((int )tmp) {
#line 886
      __len = 8UL;
#line 886
      if (__len > 63UL) {
#line 886
        __ret = __memcpy((void *)(& pmlmepriv->cur_network.network.IEs), (void const   *)(& pnetwork->IEs),
                         __len);
      } else {
#line 886
        __ret = __builtin_memcpy((void *)(& pmlmepriv->cur_network.network.IEs), (void const   *)(& pnetwork->IEs),
                                 __len);
      }
#line 888
      spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 889
      ibss_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->MacAddress));
#line 892
      if ((unsigned long )ibss_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 893
        __len___0 = 8UL;
#line 893
        if (__len___0 > 63UL) {
#line 893
          __ret___0 = __memcpy((void *)(& ibss_wlan->network.IEs), (void const   *)(& pnetwork->IEs),
                               __len___0);
        } else {
#line 893
          __ret___0 = __builtin_memcpy((void *)(& ibss_wlan->network.IEs), (void const   *)(& pnetwork->IEs),
                                       __len___0);
        }
#line 895
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 896
        goto exit;
      } else {

      }
#line 898
      spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
    } else {

    }
  } else {

  }
#line 903
  tmp___1 = check_fwstate(pmlmepriv, 128);
#line 903
  if (tmp___1) {
#line 903
    tmp___2 = 0;
  } else {
#line 903
    tmp___2 = 1;
  }
#line 903
  if (tmp___2) {
#line 904
    if ((unsigned int )pnetwork->Ssid.ssid[0] == 0U) {
#line 905
      pnetwork->Ssid.ssid_len = 0U;
    } else {

    }
#line 907
    rtw_add_network(adapter, pnetwork);
  } else {

  }
  exit: 
#line 912
  spin_unlock_bh(& pmlmepriv->lock);
#line 914
  return;
}
}
#line 918 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_surveydone_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *pibss ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  size_t __len ;
  void *__ret ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int ret ;
  unsigned long e ;
  int tmp___8 ;
  bool tmp___9 ;

  {
#line 920
  pmlmepriv = & adapter->mlmepriv;
#line 921
  pmlmeext = & adapter->mlmeextpriv;
#line 925
  spin_lock_bh(& pmlmepriv->lock);
#line 927
  if ((unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
#line 928
    pmlmepriv->wps_probe_req_ie_len = 0U;
#line 929
    kfree((void const   *)pmlmepriv->wps_probe_req_ie);
#line 930
    pmlmepriv->wps_probe_req_ie = (u8 *)0U;
  } else {

  }
#line 933
  if (GlobalDebugLevel23A > 6U) {
#line 933
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 933
    tmp = get_fwstate(pmlmepriv);
#line 933
    printk("\016rtw_surveydone_event_callback23a: fw_state:%x\n\n", tmp);
  } else {

  }
#line 937
  tmp___1 = check_fwstate(pmlmepriv, 2048);
#line 937
  if ((int )tmp___1) {
#line 938
    ldv_del_timer_sync_469(& pmlmepriv->scan_to_timer);
#line 940
    _clr_fwstate_(pmlmepriv, 2048);
  } else
#line 942
  if (GlobalDebugLevel23A > 3U) {
#line 942
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 942
    tmp___0 = get_fwstate(pmlmepriv);
#line 942
    printk("\016nic status =%x, survey done event comes too late!\n", tmp___0);
  } else {

  }
#line 947
  tmp___2 = msecs_to_jiffies(adapter->recvpriv.signal_stat_sampling_interval);
#line 947
  ldv_mod_timer_470(& adapter->recvpriv.signal_stat_timer, tmp___2 + (unsigned long )jiffies);
#line 949
  if ((unsigned int )pmlmepriv->to_join == 1U) {
#line 950
    tmp___9 = check_fwstate(pmlmepriv, 32);
#line 950
    if ((int )tmp___9) {
#line 951
      tmp___6 = check_fwstate(pmlmepriv, 1);
#line 951
      if (tmp___6) {
#line 951
        tmp___7 = 0;
      } else {
#line 951
        tmp___7 = 1;
      }
#line 951
      if (tmp___7) {
#line 952
        set_fwstate(pmlmepriv, 128);
#line 954
        tmp___5 = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
#line 954
        if (tmp___5 == 1) {
#line 956
          tmp___3 = msecs_to_jiffies(6500U);
#line 956
          ldv_mod_timer_471(& pmlmepriv->assoc_timer, tmp___3 + (unsigned long )jiffies);
        } else {
#line 959
          pdev_network = & adapter->registrypriv.dev_network;
#line 960
          pibss = (u8 *)(& adapter->registrypriv.dev_network.MacAddress);
#line 962
          _clr_fwstate_(pmlmepriv, 2048);
#line 965
          if (GlobalDebugLevel23A > 3U) {
#line 965
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 965
            printk("\016switching to adhoc master\n");
          } else {

          }
#line 970
          memset((void *)(& pdev_network->Ssid), 0, 33UL);
#line 972
          __len = 33UL;
#line 972
          if (__len > 63UL) {
#line 972
            __ret = __memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pmlmepriv->assoc_ssid),
                             __len);
          } else {
#line 972
            __ret = __builtin_memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pmlmepriv->assoc_ssid),
                                     __len);
          }
#line 976
          rtw_update_registrypriv_dev_network23a(adapter);
#line 978
          rtw_generate_random_ibss23a(pibss);
#line 980
          pmlmepriv->fw_state = 64;
#line 983
          tmp___4 = rtw_createbss_cmd23a(adapter);
#line 983
          if (tmp___4 != 1) {
#line 985
            if (GlobalDebugLevel23A > 3U) {
#line 985
              printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 985
              printk("\016Error =>rtw_createbss_cmd23a status FAIL\n");
            } else {

            }
          } else {

          }
#line 990
          pmlmepriv->to_join = 0U;
        }
      } else {

      }
    } else {
#line 995
      set_fwstate(pmlmepriv, 128);
#line 996
      pmlmepriv->to_join = 0U;
#line 997
      ret = rtw_select_and_join_from_scanned_queue23a(pmlmepriv);
#line 999
      if (ret == 1) {
#line 1001
        e = msecs_to_jiffies(6500U);
#line 1002
        ldv_mod_timer_472(& pmlmepriv->assoc_timer, (unsigned long )jiffies + e);
      } else
#line 1003
      if (ret == 2) {
#line 1004
        _clr_fwstate_(pmlmepriv, 128);
#line 1005
        rtw_indicate_connect23a(adapter);
      } else {
#line 1007
        if (GlobalDebugLevel23A > 3U) {
#line 1007
          printk("\016RTL8723AU: try_to_join, but select scanning queue fail, to_roaming:%d\n",
                 (int )adapter->mlmepriv.to_roaming);
        } else {

        }
#line 1010
        if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
#line 1011
          pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
#line 1011
          if ((unsigned int )pmlmepriv->to_roaming == 0U) {
#line 1016
            rtw_set_roaming(adapter, 0);
#line 1017
            rtw_free_assoc_resources23a(adapter, 1);
#line 1019
            rtw_indicate_disconnect23a(adapter);
          } else {
#line 1011
            tmp___8 = rtw_sitesurvey_cmd23a(adapter, & pmlmepriv->assoc_ssid, 1, (struct rtw_ieee80211_channel *)0,
                                            0);
#line 1011
            if (tmp___8 != 1) {
#line 1016
              rtw_set_roaming(adapter, 0);
#line 1017
              rtw_free_assoc_resources23a(adapter, 1);
#line 1019
              rtw_indicate_disconnect23a(adapter);
            } else {
#line 1022
              pmlmepriv->to_join = 1U;
            }
          }
        } else {

        }
#line 1024
        _clr_fwstate_(pmlmepriv, 128);
      }
    }
  } else {

  }
#line 1029
  spin_unlock_bh(& pmlmepriv->lock);
#line 1031
  rtw_os_xmit_schedule23a(adapter);
#line 1033
  if (pmlmeext->sitesurvey_res.bss_cnt == 0) {
#line 1034
    rtw_sreset_reset(adapter);
  } else {

  }
#line 1036
  rtw_cfg80211_surveydone_event_callback(adapter);
#line 1037
  return;
}
}
#line 1039 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void free_scanqueue(struct mlme_priv *pmlmepriv ) 
{ 
  struct wlan_network *pnetwork ;
  struct rtw_queue *scan_queue ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptemp ;
  struct list_head  const  *__mptr ;

  {
#line 1042
  scan_queue = & pmlmepriv->scanned_queue;
#line 1045
  if (GlobalDebugLevel23A > 5U) {
#line 1045
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
#line 1045
    printk("\016+free_scanqueue\n");
  } else {

  }
#line 1046
  spin_lock_bh(& scan_queue->lock);
#line 1048
  phead = get_list_head(scan_queue);
#line 1050
  plist = phead->next;
#line 1050
  ptemp = plist->next;
#line 1050
  goto ldv_54555;
  ldv_54554: 
#line 1051
  list_del_init(plist);
#line 1052
  __mptr = (struct list_head  const  *)plist;
#line 1052
  pnetwork = (struct wlan_network *)__mptr;
#line 1053
  kfree((void const   *)pnetwork);
#line 1050
  plist = ptemp;
#line 1050
  ptemp = plist->next;
  ldv_54555: ;
#line 1050
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1052
    goto ldv_54554;
  } else {

  }
#line 1056
  spin_unlock_bh(& scan_queue->lock);
#line 1057
  return;
}
}
#line 1062 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_free_assoc_resources23a(struct rtw_adapter *adapter , int lock_scanned_queue ) 
{ 
  struct wlan_network *pwlan ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct wlan_network *tgt_network ;
  struct sta_info *psta ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 1066
  pmlmepriv = & adapter->mlmepriv;
#line 1067
  pstapriv = & adapter->stapriv;
#line 1068
  tgt_network = & pmlmepriv->cur_network;
#line 1071
  if (GlobalDebugLevel23A > 5U) {
#line 1071
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
#line 1071
    printk("\016+rtw_free_assoc_resources23a\n");
  } else {

  }
#line 1073
  if (GlobalDebugLevel23A > 6U) {
#line 1073
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1073
    printk("\016tgt_network->network.MacAddress=%02x:%02x:%02x:%02x:%02x:%02x ssid=%s\n",
           (int )*((u8 *)(& tgt_network->network.MacAddress)), (int )*((u8 *)(& tgt_network->network.MacAddress) + 1UL),
           (int )*((u8 *)(& tgt_network->network.MacAddress) + 2UL), (int )*((u8 *)(& tgt_network->network.MacAddress) + 3UL),
           (int )*((u8 *)(& tgt_network->network.MacAddress) + 4UL), (int )*((u8 *)(& tgt_network->network.MacAddress) + 5UL),
           (u8 *)(& tgt_network->network.Ssid.ssid));
  } else {

  }
#line 1078
  tmp = check_fwstate(pmlmepriv, 24);
#line 1078
  if ((int )tmp) {
#line 1079
    psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& tgt_network->network.MacAddress));
#line 1082
    spin_lock_bh(& pstapriv->sta_hash_lock);
#line 1083
    rtw_free_stainfo23a(adapter, psta);
#line 1084
    spin_unlock_bh(& pstapriv->sta_hash_lock);
  } else {

  }
#line 1087
  tmp___0 = check_fwstate(pmlmepriv, 112);
#line 1087
  if ((int )tmp___0) {
#line 1089
    rtw_free_all_stainfo23a(adapter);
#line 1091
    psta = rtw_get_bcmc_stainfo23a(adapter);
#line 1092
    spin_lock_bh(& pstapriv->sta_hash_lock);
#line 1093
    rtw_free_stainfo23a(adapter, psta);
#line 1094
    spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 1096
    rtw_init_bcmc_stainfo23a(adapter);
  } else {

  }
#line 1099
  if (lock_scanned_queue != 0) {
#line 1100
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
  } else {

  }
#line 1102
  pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
#line 1104
  if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
#line 1105
    pwlan->fixed = 0;
  } else
#line 1107
  if (GlobalDebugLevel23A > 3U) {
#line 1107
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1107
    printk("\016rtw_free_assoc_resources23a : pwlan== NULL\n");
  } else {

  }
#line 1110
  tmp___1 = check_fwstate(pmlmepriv, 64);
#line 1110
  if ((int )tmp___1 && adapter->stapriv.asoc_sta_count == 1) {
#line 1112
    rtw_free_network_nolock(pmlmepriv, pwlan);
  } else {

  }
#line 1114
  if (lock_scanned_queue != 0) {
#line 1115
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  } else {

  }
#line 1117
  pmlmepriv->key_mask = 0U;
#line 1118
  return;
}
}
#line 1123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_indicate_connect23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct pid *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1125
  pmlmepriv = & padapter->mlmepriv;
#line 1127
  if (GlobalDebugLevel23A > 3U) {
#line 1127
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1127
    printk("\016+rtw_indicate_connect23a\n");
  } else {

  }
#line 1130
  pmlmepriv->to_join = 0U;
#line 1132
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 1132
  if (tmp___0) {
#line 1132
    tmp___1 = 0;
  } else {
#line 1132
    tmp___1 = 1;
  }
#line 1132
  if (tmp___1) {
#line 1133
    set_fwstate(pmlmepriv, 1);
#line 1137
    rtw_cfg80211_indicate_connect(padapter);
#line 1139
    netif_carrier_on(padapter->pnetdev);
#line 1141
    if (padapter->pid[2] != 0) {
#line 1142
      tmp = find_vpid(padapter->pid[2]);
#line 1142
      kill_pid(tmp, 14, 1);
    } else {

    }
  } else {

  }
#line 1145
  rtw_set_roaming(padapter, 0);
#line 1147
  rtw_set_scan_deny(padapter, 3000U);
#line 1149
  if (GlobalDebugLevel23A > 3U) {
#line 1149
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1149
    tmp___2 = get_fwstate(pmlmepriv);
#line 1149
    printk("\016-rtw_indicate_connect23a: fw_state=0x%08x\n", tmp___2);
  } else {

  }
#line 1151
  return;
}
}
#line 1157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_indicate_disconnect23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
#line 1159
  pmlmepriv = & padapter->mlmepriv;
#line 1161
  if (GlobalDebugLevel23A > 3U) {
#line 1161
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1161
    printk("\016+rtw_indicate_disconnect23a\n");
  } else {

  }
#line 1164
  _clr_fwstate_(pmlmepriv, 384);
#line 1168
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 1169
    _clr_fwstate_(pmlmepriv, 1);
  } else {

  }
#line 1171
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 1171
  if ((int )tmp___0 || (unsigned int )padapter->mlmepriv.to_roaming == 0U) {
#line 1173
    rtw_os_indicate_disconnect23a(padapter);
#line 1176
    tmp = msecs_to_jiffies(3000U);
#line 1176
    padapter->pwrctrlpriv.ips_deny_time = tmp + (unsigned long )jiffies;
#line 1179
    _clr_fwstate_(pmlmepriv, 1);
#line 1183
    rtw_clear_scan_deny(padapter);
  } else {

  }
#line 1187
  rtw_lps_ctrl_wk_cmd23a(padapter, 3, 1);
#line 1188
  return;
}
}
#line 1190 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_scan_abort23a(struct rtw_adapter *adapter ) 
{ 
  unsigned long start ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  bool tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;

  {
#line 1193
  pmlmepriv = & adapter->mlmepriv;
#line 1194
  pmlmeext = & adapter->mlmeextpriv;
#line 1196
  start = jiffies;
#line 1197
  pmlmeext->scan_abort = 1U;
#line 1198
  goto ldv_54583;
  ldv_54582: ;
#line 1200
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
#line 1201
    goto ldv_54580;
  } else {

  }
#line 1203
  if (GlobalDebugLevel23A > 3U) {
#line 1203
    printk("\016RTL8723AU: %s(%s): fw_state = _FW_UNDER_SURVEY!\n", "rtw_scan_abort23a",
           (char *)(& (adapter->pnetdev)->name));
  } else {

  }
#line 1205
  msleep(20U);
  ldv_54583: 
#line 1198
  tmp = check_fwstate(pmlmepriv, 2048);
#line 1198
  if ((int )tmp) {
#line 1198
    tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 1198
    if (tmp___0 <= 200U) {
#line 1201
      goto ldv_54582;
    } else {
#line 1204
      goto ldv_54580;
    }
  } else {

  }
  ldv_54580: 
#line 1208
  tmp___2 = check_fwstate(pmlmepriv, 2048);
#line 1208
  if ((int )tmp___2) {
#line 1209
    if (adapter->bDriverStopped == 0 && adapter->bSurpriseRemoved == 0) {
#line 1210
      if (GlobalDebugLevel23A > 3U) {
#line 1210
        printk("\016RTL8723AU: %s(%s): waiting for scan_abort time out!\n", "rtw_scan_abort23a",
               (char *)(& (adapter->pnetdev)->name));
      } else {

      }
    } else {

    }
#line 1212
    tmp___1 = wdev_priv(adapter->rtw_wdev);
#line 1212
    rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___1, 1);
  } else {

  }
#line 1215
  pmlmeext->scan_abort = 0U;
#line 1216
  return;
}
}
#line 1219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static struct sta_info *rtw_joinbss_update_stainfo(struct rtw_adapter *padapter ,
                                                   struct wlan_network *pnetwork ) 
{ 
  int i ;
  struct sta_info *bmc_sta ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_priv *pstapriv ;

  {
#line 1225
  pstapriv = & padapter->stapriv;
#line 1227
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pnetwork->network.MacAddress));
#line 1228
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1229
    psta = rtw_alloc_stainfo23a(pstapriv, (u8 *)(& pnetwork->network.MacAddress),
                                32U);
  } else {

  }
#line 1233
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1234
    if (GlobalDebugLevel23A > 3U) {
#line 1234
      printk("\016RTL8723AU: %s\n", "rtw_joinbss_update_stainfo");
    } else {

    }
#line 1236
    psta->aid = (uint )pnetwork->join_res;
#line 1237
    psta->mac_id = 0U;
#line 1240
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
#line 1243
    if (padapter->securitypriv.dot11AuthAlgrthm == 2U) {
#line 1245
      padapter->securitypriv.binstallGrpkey = 0U;
#line 1246
      padapter->securitypriv.busetkipkey = 0U;
#line 1248
      psta->ieee8021x_blocked = 1U;
#line 1249
      psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
#line 1252
      memset((void *)(& psta->dot118021x_UncstKey), 0, 16UL);
#line 1255
      memset((void *)(& psta->dot11tkiprxmickey), 0, 16UL);
#line 1257
      memset((void *)(& psta->dot11tkiptxmickey), 0, 16UL);
#line 1260
      memset((void *)(& psta->dot11txpn), 0, 8UL);
#line 1261
      memset((void *)(& psta->dot11rxpn), 0, 8UL);
    } else {

    }
#line 1268
    if (padapter->securitypriv.wps_ie_len != 0) {
#line 1269
      psta->ieee8021x_blocked = 1U;
#line 1270
      padapter->securitypriv.wps_ie_len = 0;
    } else {

    }
#line 1279
    i = 0;
#line 1279
    goto ldv_54595;
    ldv_54594: 
#line 1281
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
#line 1282
    preorder_ctrl->enable = 0U;
#line 1283
    preorder_ctrl->indicate_seq = 65535U;
#line 1284
    preorder_ctrl->wend_b = 65535U;
#line 1286
    preorder_ctrl->wsize_b = 64U;
#line 1279
    i = i + 1;
    ldv_54595: ;
#line 1279
    if (i <= 15) {
#line 1281
      goto ldv_54594;
    } else {

    }
#line 1289
    bmc_sta = rtw_get_bcmc_stainfo23a(padapter);
#line 1290
    if ((unsigned long )bmc_sta != (unsigned long )((struct sta_info *)0)) {
#line 1291
      i = 0;
#line 1291
      goto ldv_54598;
      ldv_54597: 
#line 1292
      preorder_ctrl = (struct recv_reorder_ctrl *)(& bmc_sta->recvreorder_ctrl) + (unsigned long )i;
#line 1293
      preorder_ctrl->enable = 0U;
#line 1294
      preorder_ctrl->indicate_seq = 65535U;
#line 1295
      preorder_ctrl->wend_b = 65535U;
#line 1298
      preorder_ctrl->wsize_b = 64U;
#line 1291
      i = i + 1;
      ldv_54598: ;
#line 1291
      if (i <= 15) {
#line 1293
        goto ldv_54597;
      } else {

      }

    } else {

    }
#line 1303
    update_sta_info23a(padapter, psta);
  } else {

  }
#line 1307
  return (psta);
}
}
#line 1313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void rtw_joinbss_update_network23a(struct rtw_adapter *padapter , struct wlan_network *ptarget_wlan ,
                                          struct wlan_network *pnetwork ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  int bcn_size ;
  int tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned long tmp___0 ;
  s32 tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 1317
  pmlmepriv = & padapter->mlmepriv;
#line 1318
  cur_network = & pmlmepriv->cur_network;
#line 1321
  if (GlobalDebugLevel23A > 3U) {
#line 1321
    printk("\016RTL8723AU: %s\n", "rtw_joinbss_update_network23a");
  } else {

  }
#line 1323
  if (GlobalDebugLevel23A > 6U) {
#line 1323
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1323
    tmp = get_fwstate(pmlmepriv);
#line 1323
    printk("\016\nfw_state:%x, BSSID:%02x:%02x:%02x:%02x:%02x:%02x\n", tmp, (int )*((u8 *)(& pnetwork->network.MacAddress)),
           (int )*((u8 *)(& pnetwork->network.MacAddress) + 1UL), (int )*((u8 *)(& pnetwork->network.MacAddress) + 2UL),
           (int )*((u8 *)(& pnetwork->network.MacAddress) + 3UL), (int )*((u8 *)(& pnetwork->network.MacAddress) + 4UL),
           (int )*((u8 *)(& pnetwork->network.MacAddress) + 5UL));
  } else {

  }
#line 1328
  __len = (size_t )pnetwork->network.Length;
#line 1328
  __ret = __builtin_memcpy((void *)(& cur_network->network), (void const   *)(& pnetwork->network),
                           __len);
#line 1331
  cur_network->network.IELength = ptarget_wlan->network.IELength;
#line 1332
  __len___0 = 768UL;
#line 1332
  if (__len___0 > 63UL) {
#line 1332
    __ret___0 = __memcpy((void *)(& cur_network->network.IEs), (void const   *)(& ptarget_wlan->network.IEs),
                         __len___0);
  } else {
#line 1332
    __ret___0 = __builtin_memcpy((void *)(& cur_network->network.IEs), (void const   *)(& ptarget_wlan->network.IEs),
                                 __len___0);
  }
#line 1335
  cur_network->aid = pnetwork->join_res;
#line 1337
  tmp___0 = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
#line 1337
  ldv_mod_timer_473(& padapter->recvpriv.signal_stat_timer, tmp___0 + (unsigned long )jiffies);
#line 1338
  padapter->recvpriv.signal_strength = ptarget_wlan->network.PhyInfo.SignalStrength;
#line 1340
  padapter->recvpriv.signal_qual = ptarget_wlan->network.PhyInfo.SignalQuality;
#line 1346
  tmp___1 = translate_percentage_to_dbm((u32 )ptarget_wlan->network.PhyInfo.SignalStrength);
#line 1346
  padapter->recvpriv.rssi = (s8 )tmp___1;
#line 1348
  if (GlobalDebugLevel23A > 3U) {
#line 1348
    printk("\016RTL8723AU: %s signal_strength:%3u, rssi:%3d, signal_qual:%3u\n", "rtw_joinbss_update_network23a",
           (int )padapter->recvpriv.signal_strength, (int )padapter->recvpriv.rssi,
           (int )padapter->recvpriv.signal_qual);
  } else {

  }
#line 1351
  tmp___2 = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
#line 1351
  ldv_mod_timer_474(& padapter->recvpriv.signal_stat_timer, tmp___2 + (unsigned long )jiffies);
#line 1354
  switch ((unsigned int )pnetwork->network.ifmode) {
  case 8U: ;
  case 2U: ;
#line 1357
  if ((pmlmepriv->fw_state & 256) != 0) {
#line 1358
    pmlmepriv->fw_state = 264;
  } else {
#line 1360
    pmlmepriv->fw_state = 8;
  }
#line 1361
  goto ldv_54617;
  case 1U: 
#line 1363
  pmlmepriv->fw_state = 32;
#line 1364
  goto ldv_54617;
  default: 
#line 1366
  pmlmepriv->fw_state = 0;
#line 1367
  if (GlobalDebugLevel23A > 3U) {
#line 1367
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1367
    printk("\016Invalid network_mode\n");
  } else {

  }
#line 1369
  goto ldv_54617;
  }
  ldv_54617: 
#line 1372
  bcn_size = 12;
#line 1375
  rtw_update_protection23a(padapter, (u8 *)(& cur_network->network.IEs) + (unsigned long )bcn_size,
                           cur_network->network.IELength);
#line 1378
  rtw_update_ht_cap23a(padapter, (u8 *)(& cur_network->network.IEs), cur_network->network.IELength);
#line 1380
  return;
}
}
#line 1395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_joinbss_event_prehandle23a(struct rtw_adapter *adapter , u8 *pbuf ) 
{ 
  struct sta_info *ptarget_sta ;
  struct sta_info *pcur_sta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *pnetwork ;
  struct wlan_network *cur_network ;
  struct wlan_network *pcur_wlan ;
  struct wlan_network *ptarget_wlan ;
  bool the_same_macaddr ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  unsigned long tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  unsigned long tmp___11 ;

  {
#line 1398
  pstapriv = & adapter->stapriv;
#line 1399
  pmlmepriv = & adapter->mlmepriv;
#line 1400
  pnetwork = (struct wlan_network *)pbuf;
#line 1401
  cur_network = & pmlmepriv->cur_network;
#line 1402
  ptarget_wlan = (struct wlan_network *)0;
#line 1405
  if (GlobalDebugLevel23A > 6U) {
#line 1405
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1405
    printk("\016joinbss event call back received with res=%d\n", pnetwork->join_res);
  } else {

  }
#line 1409
  rtw_get_encrypt_decrypt_from_registrypriv23a(adapter);
#line 1411
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len == 0U) {
#line 1412
    if (GlobalDebugLevel23A > 3U) {
#line 1412
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1412
      printk("\016@@@@@   joinbss event call back  for Any SSid\n");
    } else {

    }
  } else
#line 1415
  if (GlobalDebugLevel23A > 3U) {
#line 1415
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1415
    printk("\016@@@@@   rtw23a_joinbss_event_cb for SSid:%s\n", (u8 *)(& pmlmepriv->assoc_ssid.ssid));
  } else {

  }
#line 1420
  tmp = ether_addr_equal((u8 const   *)(& pnetwork->network.MacAddress), (u8 const   *)(& cur_network->network.MacAddress));
#line 1420
  if ((int )tmp) {
#line 1422
    the_same_macaddr = 1;
  } else {
#line 1424
    the_same_macaddr = 0;
  }
#line 1426
  pnetwork->network.Length = get_wlan_bssid_ex_sz(& pnetwork->network);
#line 1427
  if (pnetwork->network.Length > 863U) {
#line 1428
    if (GlobalDebugLevel23A > 3U) {
#line 1428
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1428
      printk("\016\n\n ***joinbss_evt_callback return a wrong bss ***\n\n");
    } else {

    }
#line 1431
    return;
  } else {

  }
#line 1434
  spin_lock_bh(& pmlmepriv->lock);
#line 1436
  if (GlobalDebugLevel23A > 6U) {
#line 1436
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1436
    printk("\016\n rtw23a_joinbss_event_cb !! _enter_critical\n");
  } else {

  }
#line 1439
  if (pnetwork->join_res > 0) {
#line 1440
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1441
    tmp___7 = check_fwstate(pmlmepriv, 128);
#line 1441
    if ((int )tmp___7) {
#line 1443
      tmp___2 = check_fwstate(pmlmepriv, 1);
#line 1443
      if ((int )tmp___2) {
#line 1444
        if ((int )the_same_macaddr) {
#line 1445
          ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
        } else {
#line 1447
          pcur_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
#line 1448
          if ((unsigned long )pcur_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1449
            pcur_wlan->fixed = 0;
          } else {

          }
#line 1451
          pcur_sta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->network.MacAddress));
#line 1452
          if ((unsigned long )pcur_sta != (unsigned long )((struct sta_info *)0)) {
#line 1453
            spin_lock_bh(& pstapriv->sta_hash_lock);
#line 1454
            rtw_free_stainfo23a(adapter, pcur_sta);
#line 1456
            spin_unlock_bh(& pstapriv->sta_hash_lock);
          } else {

          }
#line 1459
          ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->network.MacAddress));
#line 1460
          tmp___0 = check_fwstate(pmlmepriv, 8);
#line 1460
          if ((int )tmp___0) {
#line 1462
            if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1463
              ptarget_wlan->fixed = 1;
            } else {

            }
          } else {

          }
        }
      } else {
#line 1469
        ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& pnetwork->network.MacAddress));
#line 1472
        tmp___1 = check_fwstate(pmlmepriv, 8);
#line 1472
        if ((int )tmp___1) {
#line 1474
          if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1475
            ptarget_wlan->fixed = 1;
          } else {

          }
        } else {

        }
      }
#line 1480
      if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1481
        rtw_joinbss_update_network23a(adapter, ptarget_wlan, pnetwork);
      } else {
#line 1485
        if (GlobalDebugLevel23A > 3U) {
#line 1485
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1485
          printk("\016Can\'t find ptarget_wlan when joinbss_event callback\n");
        } else {

        }
#line 1488
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1489
        goto ignore_joinbss_callback;
      }
#line 1494
      tmp___3 = check_fwstate(pmlmepriv, 8);
#line 1494
      if ((int )tmp___3) {
#line 1495
        ptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);
#line 1497
        if ((unsigned long )ptarget_sta == (unsigned long )((struct sta_info *)0)) {
#line 1498
          if (GlobalDebugLevel23A > 3U) {
#line 1498
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1498
            printk("\016Can\'t update stainfo when joinbss_event callback\n");
          } else {

          }
#line 1502
          spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1503
          goto ignore_joinbss_callback;
        } else {

        }
      } else {

      }
#line 1508
      tmp___5 = check_fwstate(pmlmepriv, 8);
#line 1508
      if ((int )tmp___5) {
#line 1509
        rtw_indicate_connect23a(adapter);
      } else
#line 1513
      if (GlobalDebugLevel23A > 6U) {
#line 1513
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1513
        tmp___4 = get_fwstate(pmlmepriv);
#line 1513
        printk("\016adhoc mode, fw_state:%x", tmp___4);
      } else {

      }
#line 1519
      ldv_del_timer_sync_475(& pmlmepriv->assoc_timer);
#line 1521
      if (GlobalDebugLevel23A > 6U) {
#line 1521
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1521
        printk("\016Cancle assoc_timer\n");
      } else {

      }
    } else {
#line 1524
      if (GlobalDebugLevel23A > 3U) {
#line 1524
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1524
        tmp___6 = get_fwstate(pmlmepriv);
#line 1524
        printk("\016rtw23a_joinbss_event_cb err: fw_state:%x", tmp___6);
      } else {

      }
#line 1527
      spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1528
      goto ignore_joinbss_callback;
    }
#line 1530
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
  } else
#line 1531
  if (pnetwork->join_res == -4) {
#line 1532
    rtw_reset_securitypriv23a(adapter);
#line 1533
    tmp___8 = msecs_to_jiffies(1U);
#line 1533
    ldv_mod_timer_476(& pmlmepriv->assoc_timer, tmp___8 + (unsigned long )jiffies);
#line 1538
    tmp___10 = check_fwstate(pmlmepriv, 128);
#line 1538
    if ((int )tmp___10) {
#line 1539
      if (GlobalDebugLevel23A > 3U) {
#line 1539
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1539
        tmp___9 = get_fwstate(pmlmepriv);
#line 1539
        printk("\016fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", tmp___9);
      } else {

      }
#line 1542
      _clr_fwstate_(pmlmepriv, 128);
    } else {

    }
  } else {
#line 1546
    tmp___11 = msecs_to_jiffies(1U);
#line 1546
    ldv_mod_timer_477(& pmlmepriv->assoc_timer, tmp___11 + (unsigned long )jiffies);
#line 1548
    _clr_fwstate_(pmlmepriv, 128);
  }
  ignore_joinbss_callback: 
#line 1553
  spin_unlock_bh(& pmlmepriv->lock);
#line 1554
  return;
}
}
#line 1556 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw23a_joinbss_event_cb(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  struct wlan_network *pnetwork ;

  {
#line 1558
  pnetwork = (struct wlan_network *)pbuf;
#line 1560
  mlmeext_joinbss_event_callback23a(adapter, pnetwork->join_res);
#line 1562
  rtw_os_xmit_schedule23a(adapter);
#line 1563
  return;
}
}
#line 1565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_stassoc_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  struct sta_info *psta ;
  struct mlme_priv *pmlmepriv ;
  struct stassoc_event *pstassoc ;
  struct wlan_network *cur_network ;
  struct wlan_network *ptarget_wlan ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 1568
  pmlmepriv = & adapter->mlmepriv;
#line 1569
  pstassoc = (struct stassoc_event *)pbuf;
#line 1570
  cur_network = & pmlmepriv->cur_network;
#line 1573
  tmp = rtw_access_ctrl23a(adapter, (u8 *)(& pstassoc->macaddr));
#line 1573
  if (tmp) {
#line 1573
    tmp___0 = 0;
  } else {
#line 1573
    tmp___0 = 1;
  }
#line 1573
  if (tmp___0) {
#line 1574
    return;
  } else {

  }
#line 1577
  tmp___1 = check_fwstate(pmlmepriv, 16);
#line 1577
  if ((int )tmp___1) {
#line 1578
    psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstassoc->macaddr));
#line 1579
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1582
      ap_sta_info_defer_update23a(adapter, psta);
    } else {

    }
#line 1584
    return;
  } else {

  }
#line 1588
  psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstassoc->macaddr));
#line 1589
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1591
    if (GlobalDebugLevel23A > 3U) {
#line 1591
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1591
      printk("\016Error: rtw_stassoc_event_callback23a: sta has been in sta_hash_queue\n");
    } else {

    }
#line 1596
    return;
  } else {

  }
#line 1599
  psta = rtw_alloc_stainfo23a(& adapter->stapriv, (u8 *)(& pstassoc->macaddr), 208U);
#line 1601
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1602
    if (GlobalDebugLevel23A > 3U) {
#line 1602
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1602
      printk("\016Can\'t alloc sta_info when rtw_stassoc_event_callback23a\n");
    } else {

    }
#line 1605
    return;
  } else {

  }
#line 1609
  psta->qos_option = 0U;
#line 1610
  psta->mac_id = (unsigned int )pstassoc->cam_id;
#line 1612
  if (GlobalDebugLevel23A > 3U) {
#line 1612
    printk("\016RTL8723AU: %s\n", "rtw_stassoc_event_callback23a");
  } else {

  }
#line 1614
  rtl8723a_SetHalODMVar(adapter, 0, (void *)psta, 1);
#line 1616
  if (adapter->securitypriv.dot11AuthAlgrthm == 2U) {
#line 1617
    psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
  } else {

  }
#line 1620
  psta->ieee8021x_blocked = 0U;
#line 1622
  spin_lock_bh(& pmlmepriv->lock);
#line 1624
  tmp___2 = check_fwstate(pmlmepriv, 64);
#line 1624
  if ((int )tmp___2) {
#line 1624
    goto _L;
  } else {
#line 1624
    tmp___3 = check_fwstate(pmlmepriv, 32);
#line 1624
    if ((int )tmp___3) {
      _L: /* CIL Label */ 
#line 1626
      if (adapter->stapriv.asoc_sta_count == 2) {
#line 1627
        spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1628
        ptarget_wlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& cur_network->network.MacAddress));
#line 1631
        if ((unsigned long )ptarget_wlan != (unsigned long )((struct wlan_network *)0)) {
#line 1632
          ptarget_wlan->fixed = 1;
        } else {

        }
#line 1633
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1635
        rtw_indicate_connect23a(adapter);
      } else {

      }
    } else {

    }
  }
#line 1639
  spin_unlock_bh(& pmlmepriv->lock);
#line 1641
  mlmeext_sta_add_event_callback23a(adapter, psta);
#line 1642
  return;
}
}
#line 1644 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_stadel_event_callback23a(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 
  int mac_id ;
  struct sta_info *psta ;
  struct wlan_network *pwlan ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *pibss ;
  struct mlme_priv *pmlmepriv ;
  struct stadel_event *pstadel ;
  struct sta_priv *pstapriv ;
  struct wlan_network *tgt_network ;
  bool tmp ;
  bool tmp___0 ;
  size_t __len ;
  uint tmp___1 ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
#line 1651
  pmlmepriv = & adapter->mlmepriv;
#line 1652
  pstadel = (struct stadel_event *)pbuf;
#line 1653
  pstapriv = & adapter->stapriv;
#line 1654
  tgt_network = & pmlmepriv->cur_network;
#line 1656
  psta = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& pstadel->macaddr));
#line 1657
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1658
    mac_id = (int )psta->mac_id;
  } else {
#line 1660
    mac_id = pstadel->mac_id;
  }
#line 1662
  if (GlobalDebugLevel23A > 3U) {
#line 1662
    printk("\016RTL8723AU: %s(mac_id=%d)=%02x:%02x:%02x:%02x:%02x:%02x\n", "rtw_stadel_event_callback23a",
           mac_id, (int )*((u8 *)(& pstadel->macaddr)), (int )*((u8 *)(& pstadel->macaddr) + 1UL),
           (int )*((u8 *)(& pstadel->macaddr) + 2UL), (int )*((u8 *)(& pstadel->macaddr) + 3UL),
           (int )*((u8 *)(& pstadel->macaddr) + 4UL), (int )*((u8 *)(& pstadel->macaddr) + 5UL));
  } else {

  }
#line 1665
  tmp = check_fwstate(pmlmepriv, 16);
#line 1665
  if ((int )tmp) {
#line 1666
    return;
  } else {

  }
#line 1668
  mlmeext_sta_del_event_callback23a(adapter);
#line 1670
  spin_lock_bh(& pmlmepriv->lock);
#line 1672
  tmp___0 = check_fwstate(pmlmepriv, 8);
#line 1672
  if ((int )tmp___0) {
#line 1673
    if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
#line 1676
      pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
    } else
#line 1677
    if ((unsigned int )adapter->mlmepriv.to_roaming == 0U) {
#line 1678
      rtw_set_roaming(adapter, (int )adapter->registrypriv.max_roaming_times);
    } else {

    }
#line 1679
    if ((unsigned int )*((u16 *)(& pstadel->rsvd)) != 65535U) {
#line 1680
      rtw_set_roaming(adapter, 0);
    } else {

    }
#line 1682
    rtw_free_uc_swdec_pending_queue23a(adapter);
#line 1684
    rtw_free_assoc_resources23a(adapter, 1);
#line 1685
    rtw_indicate_disconnect23a(adapter);
#line 1686
    spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1688
    pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
#line 1690
    if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
#line 1691
      pwlan->fixed = 0;
#line 1692
      rtw_free_network_nolock(pmlmepriv, pwlan);
    } else {

    }
#line 1694
    spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1696
    _rtw_roaming(adapter, tgt_network);
  } else {

  }
#line 1699
  tmp___4 = check_fwstate(pmlmepriv, 64);
#line 1699
  if ((int )tmp___4) {
#line 1699
    goto _L;
  } else {
#line 1699
    tmp___5 = check_fwstate(pmlmepriv, 32);
#line 1699
    if ((int )tmp___5) {
      _L: /* CIL Label */ 
#line 1702
      spin_lock_bh(& pstapriv->sta_hash_lock);
#line 1703
      rtw_free_stainfo23a(adapter, psta);
#line 1704
      spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 1707
      if (adapter->stapriv.asoc_sta_count == 1) {
#line 1708
        spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1712
        pwlan = rtw_find_network23a(& pmlmepriv->scanned_queue, (u8 *)(& tgt_network->network.MacAddress));
#line 1714
        if ((unsigned long )pwlan != (unsigned long )((struct wlan_network *)0)) {
#line 1715
          pwlan->fixed = 0;
#line 1716
          rtw_free_network_nolock(pmlmepriv, pwlan);
        } else {

        }
#line 1718
        spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1720
        pdev_network = & adapter->registrypriv.dev_network;
#line 1721
        pibss = (u8 *)(& adapter->registrypriv.dev_network.MacAddress);
#line 1723
        tmp___1 = get_wlan_bssid_ex_sz(& tgt_network->network);
#line 1723
        __len = (size_t )tmp___1;
#line 1723
        __ret = __builtin_memcpy((void *)pdev_network, (void const   *)(& tgt_network->network),
                                 __len);
#line 1726
        memset((void *)(& pdev_network->Ssid), 0, 33UL);
#line 1728
        __len___0 = 33UL;
#line 1728
        if (__len___0 > 63UL) {
#line 1728
          __ret___0 = __memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pmlmepriv->assoc_ssid),
                               __len___0);
        } else {
#line 1728
          __ret___0 = __builtin_memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pmlmepriv->assoc_ssid),
                                       __len___0);
        }
#line 1731
        rtw_update_registrypriv_dev_network23a(adapter);
#line 1733
        rtw_generate_random_ibss23a(pibss);
#line 1735
        tmp___2 = check_fwstate(pmlmepriv, 32);
#line 1735
        if ((int )tmp___2) {
#line 1736
          set_fwstate(pmlmepriv, 64);
#line 1737
          _clr_fwstate_(pmlmepriv, 32);
        } else {

        }
#line 1740
        tmp___3 = rtw_createbss_cmd23a(adapter);
#line 1740
        if (tmp___3 != 1) {
#line 1741
          if (GlobalDebugLevel23A > 3U) {
#line 1741
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 1741
            printk("\016***Error =>stadel_event_callback: rtw_createbss_cmd23a status FAIL***\n");
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  }
#line 1750
  spin_unlock_bh(& pmlmepriv->lock);
#line 1751
  return;
}
}
#line 1757 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw23a_join_to_handler(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  int do_join_r ;
  int tmp ;

  {
#line 1759
  adapter = (struct rtw_adapter *)data;
#line 1760
  pmlmepriv = & adapter->mlmepriv;
#line 1763
  if (GlobalDebugLevel23A > 3U) {
#line 1763
    tmp = get_fwstate(pmlmepriv);
#line 1763
    printk("\016RTL8723AU: %s, fw_state=%x\n", "rtw23a_join_to_handler", tmp);
  } else {

  }
#line 1765
  if (adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) {
#line 1766
    return;
  } else {

  }
#line 1768
  spin_lock_bh(& pmlmepriv->lock);
#line 1770
  if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
    ldv_54678: 
#line 1773
    pmlmepriv->to_roaming = (u8 )((int )pmlmepriv->to_roaming - 1);
#line 1774
    if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
#line 1776
      if (GlobalDebugLevel23A > 3U) {
#line 1776
        printk("\016RTL8723AU: %s try another roaming\n", "rtw23a_join_to_handler");
      } else {

      }
#line 1777
      do_join_r = rtw_do_join23a(adapter);
#line 1778
      if (do_join_r != 1) {
#line 1779
        if (GlobalDebugLevel23A > 3U) {
#line 1779
          printk("\016RTL8723AU: %s roaming do_join return %d\n", "rtw23a_join_to_handler",
                 do_join_r);
        } else {

        }
#line 1781
        goto ldv_54676;
      } else {

      }
#line 1783
      goto ldv_54677;
    } else {
#line 1785
      if (GlobalDebugLevel23A > 3U) {
#line 1785
        printk("\016RTL8723AU: %s We\'ve try roaming but fail\n", "rtw23a_join_to_handler");
      } else {

      }
#line 1787
      rtw_indicate_disconnect23a(adapter);
#line 1788
      goto ldv_54677;
    }
    ldv_54676: ;
#line 1790
    goto ldv_54678;
    ldv_54677: ;
  } else {
#line 1792
    rtw_indicate_disconnect23a(adapter);
#line 1793
    free_scanqueue(pmlmepriv);
#line 1797
    rtw_cfg80211_indicate_disconnect(adapter);
  }
#line 1800
  spin_unlock_bh(& pmlmepriv->lock);
#line 1801
  return;
}
}
#line 1808 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_scan_timeout_handler23a(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1810
  adapter = (struct rtw_adapter *)data;
#line 1811
  pmlmepriv = & adapter->mlmepriv;
#line 1813
  if (GlobalDebugLevel23A > 3U) {
#line 1813
    tmp = get_fwstate(pmlmepriv);
#line 1813
    printk("\016RTL8723AU: %s(%s): fw_state =%x\n", "rtw_scan_timeout_handler23a",
           (char *)(& (adapter->pnetdev)->name), tmp);
  } else {

  }
#line 1816
  spin_lock_bh(& pmlmepriv->lock);
#line 1818
  _clr_fwstate_(pmlmepriv, 2048);
#line 1820
  spin_unlock_bh(& pmlmepriv->lock);
#line 1822
  tmp___0 = wdev_priv(adapter->rtw_wdev);
#line 1822
  rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___0, 1);
#line 1823
  return;
}
}
#line 1825 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static void rtw_auto_scan_handler(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;

  {
#line 1827
  pmlmepriv = & padapter->mlmepriv;
#line 1830
  if (pmlmepriv->scan_interval != 0U) {
#line 1831
    pmlmepriv->scan_interval = pmlmepriv->scan_interval - 1U;
#line 1832
    if (pmlmepriv->scan_interval == 0U) {
#line 1833
      if (GlobalDebugLevel23A > 3U) {
#line 1833
        printk("\016RTL8723AU: %s\n", "rtw_auto_scan_handler");
      } else {

      }
#line 1834
      rtw_set_802_11_bssid23a_list_scan(padapter, (struct cfg80211_ssid *)0, 0);
#line 1836
      pmlmepriv->scan_interval = 30U;
    } else {

    }
  } else {

  }
#line 1839
  return;
}
}
#line 1841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_dynamic_check_timer_handler(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct registry_priv *pregistrypriv ;
  unsigned long tmp ;

  {
#line 1843
  adapter = (struct rtw_adapter *)data;
#line 1844
  pregistrypriv = & adapter->registrypriv;
#line 1846
  if ((unsigned int )adapter->hw_init_completed == 0U) {
#line 1847
    goto out;
  } else {

  }
#line 1849
  if (adapter->bDriverStopped == 1 || adapter->bSurpriseRemoved == 1) {
#line 1851
    goto out;
  } else {

  }
#line 1853
  if (adapter->net_closed == 1) {
#line 1854
    goto out;
  } else {

  }
#line 1856
  rtw_dynamic_chk_wk_cmd23a(adapter);
#line 1858
  if ((unsigned int )pregistrypriv->wifi_spec == 1U) {
#line 1860
    rtw_auto_scan_handler(adapter);
  } else {

  }
  out: 
#line 1863
  tmp = msecs_to_jiffies(2000U);
#line 1863
  ldv_mod_timer_478(& adapter->mlmepriv.dynamic_chk_timer, tmp + (unsigned long )jiffies);
#line 1865
  return;
}
}
#line 1873 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_clear_scan_deny(struct rtw_adapter *adapter ) 
{ 
  struct mlme_priv *mlmepriv ;

  {
#line 1875
  mlmepriv = & adapter->mlmepriv;
#line 1876
  atomic_set(& mlmepriv->set_scan_deny, 0);
#line 1877
  return;
}
}
#line 1879 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_set_scan_deny_timer_hdl(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;

  {
#line 1881
  adapter = (struct rtw_adapter *)data;
#line 1882
  rtw_clear_scan_deny(adapter);
#line 1883
  return;
}
}
#line 1885 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_set_scan_deny(struct rtw_adapter *adapter , u32 ms ) 
{ 
  struct mlme_priv *mlmepriv ;
  unsigned long tmp ;

  {
#line 1887
  mlmepriv = & adapter->mlmepriv;
#line 1889
  atomic_set(& mlmepriv->set_scan_deny, 1);
#line 1890
  tmp = msecs_to_jiffies(ms);
#line 1890
  ldv_mod_timer_479(& mlmepriv->set_scan_deny_timer, tmp + (unsigned long )jiffies);
#line 1892
  return;
}
}
#line 1906 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv , struct wlan_network **candidate ,
                                    struct wlan_network *competitor ) 
{ 
  int updated ;
  struct rtw_adapter *adapter ;
  struct mlme_priv  const  *__mptr ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int passed ;
  int tmp___3 ;

  {
#line 1910
  updated = 0;
#line 1913
  __mptr = (struct mlme_priv  const  *)pmlmepriv;
#line 1913
  adapter = (struct rtw_adapter *)__mptr + 0xffffffffffffffe0UL;
#line 1916
  if (pmlmepriv->assoc_by_bssid == 1U) {
#line 1917
    tmp = ether_addr_equal((u8 const   *)(& competitor->network.MacAddress), (u8 const   *)(& pmlmepriv->assoc_bssid));
#line 1917
    if (tmp) {
#line 1917
      tmp___0 = 0;
    } else {
#line 1917
      tmp___0 = 1;
    }
#line 1917
    if (tmp___0) {
#line 1919
      goto exit;
    } else {

    }
  } else {

  }
#line 1923
  if ((unsigned int )pmlmepriv->assoc_ssid.ssid_len != 0U) {
#line 1924
    if ((int )competitor->network.Ssid.ssid_len != (int )pmlmepriv->assoc_ssid.ssid_len) {
#line 1929
      goto exit;
    } else {
#line 1924
      tmp___1 = memcmp((void const   *)(& competitor->network.Ssid.ssid), (void const   *)(& pmlmepriv->assoc_ssid.ssid),
                       (size_t )pmlmepriv->assoc_ssid.ssid_len);
#line 1924
      if (tmp___1 != 0) {
#line 1929
        goto exit;
      } else {

      }
    }
  } else {

  }
#line 1932
  tmp___2 = rtw_is_desired_network(adapter, competitor);
#line 1932
  if (tmp___2 == 0) {
#line 1933
    goto exit;
  } else {

  }
#line 1935
  if ((unsigned int )adapter->mlmepriv.to_roaming != 0U) {
#line 1938
    passed = jiffies_to_msecs((unsigned long )jiffies - competitor->last_scanned);
#line 1939
    if (passed > 1999U) {
#line 1942
      goto exit;
    } else {
#line 1939
      tmp___3 = is_same_ess(& competitor->network, & pmlmepriv->cur_network.network);
#line 1939
      if (tmp___3 == 0) {
#line 1942
        goto exit;
      } else {

      }
    }
  } else {

  }
#line 1945
  if ((unsigned long )*candidate == (unsigned long )((struct wlan_network *)0) || (*candidate)->network.Rssi < competitor->network.Rssi) {
#line 1947
    *candidate = competitor;
#line 1948
    updated = 1;
  } else {

  }
#line 1951
  if (updated != 0) {
#line 1952
    if (GlobalDebugLevel23A > 3U) {
#line 1952
      printk("\016RTL8723AU: [by_bssid:%u][assoc_ssid:%s][to_roaming:%u] new candidate: %s(%02x:%02x:%02x:%02x:%02x:%02x) rssi:%d\n",
             pmlmepriv->assoc_by_bssid, (u8 *)(& pmlmepriv->assoc_ssid.ssid), (int )adapter->mlmepriv.to_roaming,
             (u8 *)(& (*candidate)->network.Ssid.ssid), (int )*((u8 *)(& (*candidate)->network.MacAddress)),
             (int )*((u8 *)(& (*candidate)->network.MacAddress) + 1UL), (int )*((u8 *)(& (*candidate)->network.MacAddress) + 2UL),
             (int )*((u8 *)(& (*candidate)->network.MacAddress) + 3UL), (int )*((u8 *)(& (*candidate)->network.MacAddress) + 4UL),
             (int )*((u8 *)(& (*candidate)->network.MacAddress) + 5UL), (int )(*candidate)->network.Rssi);
    } else {

    }
  } else {

  }
  exit: ;
#line 1963
  return (updated);
}
}
#line 1976 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int rtw_select_and_join_from_scanned_queue23a(struct mlme_priv *pmlmepriv ) 
{ 
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct rtw_adapter *adapter ;
  struct rtw_queue *queue ;
  struct wlan_network *pnetwork ;
  struct wlan_network *candidate ;
  struct list_head  const  *__mptr ;
  bool tmp ;

  {
#line 1981
  queue = & pmlmepriv->scanned_queue;
#line 1983
  candidate = (struct wlan_network *)0;
#line 1985
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1986
  phead = get_list_head(queue);
#line 1987
  adapter = pmlmepriv->nic_hdl;
#line 1989
  plist = phead->next;
#line 1989
  ptmp = plist->next;
#line 1989
  goto ldv_54740;
  ldv_54739: 
#line 1990
  __mptr = (struct list_head  const  *)plist;
#line 1990
  pnetwork = (struct wlan_network *)__mptr;
#line 1991
  if ((unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
#line 1992
    if (GlobalDebugLevel23A > 3U) {
#line 1992
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1992
      printk("\016%s return _FAIL:(pnetwork == NULL)\n", "rtw_select_and_join_from_scanned_queue23a");
    } else {

    }
#line 1995
    ret = 0;
#line 1996
    goto exit;
  } else {

  }
#line 1999
  rtw_check_join_candidate(pmlmepriv, & candidate, pnetwork);
#line 1989
  plist = ptmp;
#line 1989
  ptmp = plist->next;
  ldv_54740: ;
#line 1989
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1991
    goto ldv_54739;
  } else {

  }

#line 2002
  if ((unsigned long )candidate == (unsigned long )((struct wlan_network *)0)) {
#line 2003
    if (GlobalDebugLevel23A > 3U) {
#line 2003
      printk("\016RTL8723AU: %s: return _FAIL(candidate == NULL)\n", "rtw_select_and_join_from_scanned_queue23a");
    } else {

    }
#line 2004
    ret = 0;
#line 2005
    goto exit;
  } else
#line 2007
  if (GlobalDebugLevel23A > 3U) {
#line 2007
    printk("\016RTL8723AU: %s: candidate: %s(%02x:%02x:%02x:%02x:%02x:%02x, ch:%u)\n",
           "rtw_select_and_join_from_scanned_queue23a", (u8 *)(& candidate->network.Ssid.ssid),
           (int )*((u8 *)(& candidate->network.MacAddress)), (int )*((u8 *)(& candidate->network.MacAddress) + 1UL),
           (int )*((u8 *)(& candidate->network.MacAddress) + 2UL), (int )*((u8 *)(& candidate->network.MacAddress) + 3UL),
           (int )*((u8 *)(& candidate->network.MacAddress) + 4UL), (int )*((u8 *)(& candidate->network.MacAddress) + 5UL),
           candidate->network.DSConfig);
  } else {

  }
#line 2014
  tmp = check_fwstate(pmlmepriv, 1);
#line 2014
  if ((int )tmp) {
#line 2015
    if (GlobalDebugLevel23A > 3U) {
#line 2015
      printk("\016RTL8723AU: %s: _FW_LINKED while ask_for_joinbss!!!\n", "rtw_select_and_join_from_scanned_queue23a");
    } else {

    }
#line 2018
    rtw_disassoc_cmd23a(adapter, 0U, 1);
#line 2019
    rtw_indicate_disconnect23a(adapter);
#line 2020
    rtw_free_assoc_resources23a(adapter, 0);
  } else {

  }
#line 2022
  set_fwstate(pmlmepriv, 128);
#line 2023
  ret = rtw_joinbss_cmd23a(adapter, candidate);
  exit: 
#line 2026
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 2028
  return (ret);
}
}
#line 2031 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int rtw_set_auth23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ) 
{ 
  struct cmd_obj *pcmd ;
  struct setauth_parm *psetauthparm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2036
  pcmdpriv = & adapter->cmdpriv;
#line 2037
  res = 1;
#line 2039
  tmp = kzalloc(128UL, 208U);
#line 2039
  pcmd = (struct cmd_obj *)tmp;
#line 2040
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 2041
    res = 0;
#line 2042
    goto exit;
  } else {

  }
#line 2045
  tmp___0 = kzalloc(4UL, 208U);
#line 2045
  psetauthparm = (struct setauth_parm *)tmp___0;
#line 2046
  if ((unsigned long )psetauthparm == (unsigned long )((struct setauth_parm *)0)) {
#line 2047
    kfree((void const   *)pcmd);
#line 2048
    res = 0;
#line 2049
    goto exit;
  } else {

  }
#line 2052
  psetauthparm->mode = (unsigned char )psecuritypriv->dot11AuthAlgrthm;
#line 2054
  pcmd->cmdcode = 19U;
#line 2055
  pcmd->parmbuf = (u8 *)psetauthparm;
#line 2056
  pcmd->cmdsz = 4U;
#line 2057
  pcmd->rsp = (u8 *)0U;
#line 2058
  pcmd->rspsz = 0U;
#line 2060
  if (GlobalDebugLevel23A > 3U) {
#line 2060
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 2060
    printk("\016after enqueue set_auth_cmd, auth_mode=%x\n", psecuritypriv->dot11AuthAlgrthm);
  } else {

  }
#line 2064
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
#line 2068
  return (res);
}
}
#line 2071 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int rtw_set_key23a(struct rtw_adapter *adapter , struct security_priv *psecuritypriv ,
                   int keyid , u8 set_tx ) 
{ 
  u8 keylen ;
  struct cmd_obj *pcmd ;
  struct setkey_parm *psetkeyparm ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_priv *pmlmepriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;

  {
#line 2077
  pcmdpriv = & adapter->cmdpriv;
#line 2078
  pmlmepriv = & adapter->mlmepriv;
#line 2079
  res = 1;
#line 2081
  if (keyid > 3) {
#line 2082
    res = 0;
#line 2083
    goto exit;
  } else {

  }
#line 2086
  tmp = kzalloc(128UL, 208U);
#line 2086
  pcmd = (struct cmd_obj *)tmp;
#line 2087
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 2088
    res = 0;
#line 2089
    goto exit;
  } else {

  }
#line 2091
  tmp___0 = kzalloc(24UL, 208U);
#line 2091
  psetkeyparm = (struct setkey_parm *)tmp___0;
#line 2092
  if ((unsigned long )psetkeyparm == (unsigned long )((struct setkey_parm *)0)) {
#line 2093
    kfree((void const   *)pcmd);
#line 2094
    res = 0;
#line 2095
    goto exit;
  } else {

  }
#line 2098
  if (psecuritypriv->dot11AuthAlgrthm == 2U) {
#line 2099
    psetkeyparm->algorithm = (u32 )((unsigned char )psecuritypriv->dot118021XGrpPrivacy);
#line 2101
    if (GlobalDebugLevel23A > 3U) {
#line 2101
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 2101
      printk("\016\n rtw_set_key23a: psetkeyparm->algorithm = (unsigned char)psecuritypriv->dot118021XGrpPrivacy =%d\n",
             psetkeyparm->algorithm);
    } else {

    }
  } else {
#line 2106
    psetkeyparm->algorithm = (u32 )((unsigned char )psecuritypriv->dot11PrivacyAlgrthm);
#line 2107
    if (GlobalDebugLevel23A > 3U) {
#line 2107
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 2107
      printk("\016\n rtw_set_key23a: psetkeyparm->algorithm = (u8)psecuritypriv->dot11PrivacyAlgrthm =%d\n",
             psetkeyparm->algorithm);
    } else {

    }
  }
#line 2112
  psetkeyparm->keyid = (u8 )keyid;
#line 2113
  psetkeyparm->set_tx = set_tx;
#line 2114
  if (psetkeyparm->algorithm == 1027073U || psetkeyparm->algorithm == 1027077U) {
#line 2115
    pmlmepriv->key_mask = (int )pmlmepriv->key_mask | (int )((u8 )(1UL << (int )psetkeyparm->keyid));
  } else {

  }
#line 2117
  if (GlobalDebugLevel23A > 3U) {
#line 2117
    printk("\016RTL8723AU: ==> rtw_set_key23a algorithm(%x), keyid(%x), key_mask(%x)\n",
           psetkeyparm->algorithm, (int )psetkeyparm->keyid, (int )pmlmepriv->key_mask);
  } else {

  }
#line 2120
  if (GlobalDebugLevel23A > 3U) {
#line 2120
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 2120
    printk("\016\n rtw_set_key23a: psetkeyparm->algorithm =%d psetkeyparm->keyid = (u8)keyid =%d\n",
           psetkeyparm->algorithm, keyid);
  } else {

  }
#line 2124
  switch (psetkeyparm->algorithm) {
  case 1027073U: 
#line 2126
  keylen = 5U;
#line 2127
  __len = (size_t )keylen;
#line 2127
  __ret = __builtin_memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->wep_key[keyid].key),
                           __len);
#line 2129
  goto ldv_54768;
  case 1027077U: 
#line 2131
  keylen = 13U;
#line 2132
  __len___0 = (size_t )keylen;
#line 2132
  __ret___0 = __builtin_memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->wep_key[keyid].key),
                               __len___0);
#line 2134
  goto ldv_54768;
  case 1027074U: 
#line 2136
  keylen = 16U;
#line 2137
  __len___1 = (size_t )keylen;
#line 2137
  __ret___1 = __builtin_memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->dot118021XGrpKey) + (unsigned long )keyid,
                               __len___1);
#line 2139
  psetkeyparm->grpkey = 1U;
#line 2140
  goto ldv_54768;
  case 1027076U: 
#line 2142
  keylen = 16U;
#line 2143
  __len___2 = (size_t )keylen;
#line 2143
  __ret___2 = __builtin_memcpy((void *)(& psetkeyparm->key), (void const   *)(& psecuritypriv->dot118021XGrpKey) + (unsigned long )keyid,
                               __len___2);
#line 2145
  psetkeyparm->grpkey = 1U;
#line 2146
  goto ldv_54768;
  default: ;
#line 2148
  if (GlobalDebugLevel23A > 3U) {
#line 2148
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 2148
    printk("\016\n rtw_set_key23a:psecuritypriv->dot11PrivacyAlgrthm = %x (must be 1 or 2 or 4 or 5)\n",
           psecuritypriv->dot11PrivacyAlgrthm);
  } else {

  }
#line 2152
  res = 0;
#line 2153
  kfree((void const   *)pcmd);
#line 2154
  kfree((void const   *)psetkeyparm);
#line 2155
  goto exit;
  }
  ldv_54768: 
#line 2158
  pcmd->cmdcode = 20U;
#line 2159
  pcmd->parmbuf = (u8 *)psetkeyparm;
#line 2160
  pcmd->cmdsz = 24U;
#line 2161
  pcmd->rsp = (u8 *)0U;
#line 2162
  pcmd->rspsz = 0U;
#line 2166
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
#line 2170
  return (res);
}
}
#line 2174 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int rtw_restruct_wmm_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len , uint initial_out_len ) 
{ 
  unsigned int ielength ;
  unsigned int i ;
  unsigned int j ;

  {
#line 2177
  ielength = 0U;
#line 2180
  i = 12U;
#line 2181
  goto ldv_54797;
  ldv_54796: 
#line 2182
  ielength = initial_out_len;
#line 2185
  if ((((((unsigned int )*(in_ie + (unsigned long )i) == 221U && (unsigned int )*(in_ie + (unsigned long )(i + 2U)) == 0U) && (unsigned int )*(in_ie + (unsigned long )(i + 3U)) == 80U) && (unsigned int )*(in_ie + (unsigned long )(i + 4U)) == 242U) && (unsigned int )*(in_ie + (unsigned long )(i + 5U)) == 2U) && i + 5U < in_len) {
#line 2190
    j = i;
#line 2190
    goto ldv_54793;
    ldv_54792: 
#line 2191
    *(out_ie + (unsigned long )ielength) = *(in_ie + (unsigned long )j);
#line 2192
    ielength = ielength + 1U;
#line 2190
    j = j + 1U;
    ldv_54793: ;
#line 2190
    if (i + 9U > j) {
#line 2192
      goto ldv_54792;
    } else {

    }
#line 2194
    *(out_ie + (unsigned long )(initial_out_len + 1U)) = 7U;
#line 2195
    *(out_ie + (unsigned long )(initial_out_len + 6U)) = 0U;
#line 2196
    *(out_ie + (unsigned long )(initial_out_len + 8U)) = 0U;
#line 2198
    goto ldv_54795;
  } else {

  }
#line 2201
  i = ((unsigned int )*(in_ie + (unsigned long )(i + 1U)) + i) + 2U;
  ldv_54797: ;
#line 2181
  if (i < in_len) {
#line 2183
    goto ldv_54796;
  } else {

  }
  ldv_54795: ;
#line 2204
  return ((int )ielength);
}
}
#line 2219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static int SecIsInPMKIDList(struct rtw_adapter *Adapter , u8 *bssid ) 
{ 
  struct security_priv *psecuritypriv ;
  int i ;
  bool tmp ;

  {
#line 2221
  psecuritypriv = & Adapter->securitypriv;
#line 2222
  i = 0;
  ldv_54805: ;
#line 2225
  if ((unsigned int )psecuritypriv->PMKIDList[i].bUsed != 0U) {
#line 2225
    tmp = ether_addr_equal((u8 const   *)(& psecuritypriv->PMKIDList[i].Bssid), (u8 const   *)bssid);
#line 2225
    if ((int )tmp) {
#line 2227
      goto ldv_54804;
    } else {
#line 2229
      i = i + 1;
    }
  } else {
#line 2229
    i = i + 1;
  }
#line 2232
  if (i <= 15) {
#line 2234
    goto ldv_54805;
  } else {

  }
  ldv_54804: ;
#line 2234
  if (i == 16) {
#line 2235
    i = -1;
  } else {

  }
#line 2241
  return (i);
}
}
#line 2253 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
static int rtw_append_pmkid(struct rtw_adapter *Adapter , int iEntry , u8 *ie , uint ie_len ) 
{ 
  struct security_priv *psecuritypriv ;
  size_t __len ;
  void *__ret ;

  {
#line 2256
  psecuritypriv = & Adapter->securitypriv;
#line 2258
  if ((unsigned int )*(ie + 13UL) <= 20U) {
#line 2261
    *(ie + (unsigned long )ie_len) = 1U;
#line 2262
    ie_len = ie_len + 1U;
#line 2263
    *(ie + (unsigned long )ie_len) = 0U;
#line 2264
    ie_len = ie_len + 1U;
#line 2265
    __len = 16UL;
#line 2265
    if (__len > 63UL) {
#line 2265
      __ret = __memcpy((void *)ie + (unsigned long )ie_len, (void const   *)(& psecuritypriv->PMKIDList[iEntry].PMKID),
                       __len);
    } else {
#line 2265
      __ret = __builtin_memcpy((void *)ie + (unsigned long )ie_len, (void const   *)(& psecuritypriv->PMKIDList[iEntry].PMKID),
                               __len);
    }
#line 2268
    ie_len = ie_len + 16U;
#line 2269
    *(ie + 13UL) = (unsigned int )*(ie + 13UL) + 18U;
  } else {

  }
#line 2271
  return ((int )ie_len);
}
}
#line 2274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int rtw_restruct_sec_ie23a(struct rtw_adapter *adapter , u8 *in_ie , u8 *out_ie ,
                           uint in_len ) 
{ 
  u8 authmode ;
  uint ielength ;
  int iEntry ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  uint ndisauthmode ;
  uint ndissecuritytype ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 2280
  pmlmepriv = & adapter->mlmepriv;
#line 2281
  psecuritypriv = & adapter->securitypriv;
#line 2282
  ndisauthmode = psecuritypriv->ndisauthtype;
#line 2283
  ndissecuritytype = psecuritypriv->ndisencryptstatus;
#line 2285
  if (GlobalDebugLevel23A > 5U) {
#line 2285
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
#line 2285
    printk("\016+rtw_restruct_sec_ie23a: ndisauthmode=%d ndissecuritytype=%d\n", ndisauthmode,
           ndissecuritytype);
  } else {

  }
#line 2290
  __len = 12UL;
#line 2290
  if (__len > 63UL) {
#line 2290
    __ret = __memcpy((void *)out_ie, (void const   *)in_ie, __len);
  } else {
#line 2290
    __ret = __builtin_memcpy((void *)out_ie, (void const   *)in_ie, __len);
  }
#line 2291
  ielength = 12U;
#line 2292
  if (ndisauthmode == 3U || ndisauthmode == 4U) {
#line 2294
    authmode = 221U;
  } else {

  }
#line 2295
  if (ndisauthmode == 6U || ndisauthmode == 7U) {
#line 2297
    authmode = 48U;
  } else {

  }
#line 2299
  tmp = check_fwstate(pmlmepriv, 256);
#line 2299
  if ((int )tmp) {
#line 2300
    __len___0 = (size_t )psecuritypriv->wps_ie_len;
#line 2300
    __ret___0 = __builtin_memcpy((void *)out_ie + (unsigned long )ielength, (void const   *)(& psecuritypriv->wps_ie),
                                 __len___0);
#line 2303
    ielength = (uint )psecuritypriv->wps_ie_len + ielength;
  } else
#line 2304
  if ((unsigned int )authmode == 221U || (unsigned int )authmode == 48U) {
#line 2307
    __len___1 = (size_t )((int )psecuritypriv->supplicant_ie[1] + 2);
#line 2307
    __ret___1 = __builtin_memcpy((void *)out_ie + (unsigned long )ielength, (void const   *)(& psecuritypriv->supplicant_ie),
                                 __len___1);
#line 2309
    ielength = ((uint )psecuritypriv->supplicant_ie[1] + ielength) + 2U;
  } else {

  }
#line 2312
  iEntry = SecIsInPMKIDList(adapter, (u8 *)(& pmlmepriv->assoc_bssid));
#line 2313
  if (iEntry < 0) {
#line 2314
    return ((int )ielength);
  } else
#line 2316
  if ((unsigned int )authmode == 48U) {
#line 2317
    tmp___0 = rtw_append_pmkid(adapter, iEntry, out_ie, ielength);
#line 2317
    ielength = (uint )tmp___0;
  } else {

  }
#line 2321
  return ((int )ielength);
}
}
#line 2324 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_init_registrypriv_dev_network23a(struct rtw_adapter *adapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct eeprom_priv *peepriv ;
  struct wlan_bssid_ex *pdev_network ;
  u8 *myhwaddr ;
  u8 *tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 2326
  pregistrypriv = & adapter->registrypriv;
#line 2327
  peepriv = & adapter->eeprompriv;
#line 2328
  pdev_network = & pregistrypriv->dev_network;
#line 2329
  tmp = myid(peepriv);
#line 2329
  myhwaddr = tmp;
#line 2331
  ether_addr_copy((u8 *)(& pdev_network->MacAddress), (u8 const   *)myhwaddr);
#line 2333
  __len = 33UL;
#line 2333
  if (__len > 63UL) {
#line 2333
    __ret = __memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pregistrypriv->ssid),
                     __len);
  } else {
#line 2333
    __ret = __builtin_memcpy((void *)(& pdev_network->Ssid), (void const   *)(& pregistrypriv->ssid),
                             __len);
  }
#line 2336
  pdev_network->BeaconPeriod = 100U;
#line 2337
  return;
}
}
#line 2339 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_update_registrypriv_dev_network23a(struct rtw_adapter *adapter ) 
{ 
  int sz ;
  struct registry_priv *pregistrypriv ;
  struct wlan_bssid_ex *pdev_network ;
  struct security_priv *psecuritypriv ;
  struct wlan_network *cur_network ;

  {
#line 2341
  sz = 0;
#line 2342
  pregistrypriv = & adapter->registrypriv;
#line 2343
  pdev_network = & pregistrypriv->dev_network;
#line 2344
  psecuritypriv = & adapter->securitypriv;
#line 2345
  cur_network = & adapter->mlmepriv.cur_network;
#line 2348
  pdev_network->Privacy = psecuritypriv->dot11PrivacyAlgrthm != 0U;
#line 2351
  pdev_network->Rssi = 0L;
#line 2353
  pdev_network->DSConfig = (u32 )pregistrypriv->channel;
#line 2354
  if (GlobalDebugLevel23A > 6U) {
#line 2354
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 2354
    printk("\016pregistrypriv->channel =%d, pdev_network->DSConfig = 0x%x\n", (int )pregistrypriv->channel,
           pdev_network->DSConfig);
  } else {

  }
#line 2358
  if ((unsigned int )cur_network->network.ifmode == 1U) {
#line 2359
    pdev_network->ATIMWindow = 0U;
  } else {

  }
#line 2361
  pdev_network->ifmode = cur_network->network.ifmode;
#line 2366
  sz = rtw_generate_ie23a(pregistrypriv);
#line 2368
  pdev_network->IELength = (u32 )sz;
#line 2370
  pdev_network->Length = get_wlan_bssid_ex_sz(pdev_network);
#line 2372
  return;
}
}
#line 2378 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_get_encrypt_decrypt_from_registrypriv23a(struct rtw_adapter *adapter ) 
{ 


  {
#line 2380
  return;
}
}
#line 2384 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_joinbss_reset23a(struct rtw_adapter *padapter ) 
{ 
  u8 threshold ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;

  {
#line 2387
  pmlmepriv = & padapter->mlmepriv;
#line 2388
  phtpriv = & pmlmepriv->htpriv;
#line 2393
  pmlmepriv->num_FortyMHzIntolerant = 0;
#line 2395
  pmlmepriv->num_sta_no_ht = 0;
#line 2397
  phtpriv->ampdu_enable = 0U;
#line 2401
  if (phtpriv->ht_option != 0U) {
#line 2402
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
#line 2403
      threshold = 1U;
    } else {
#line 2405
      threshold = 0U;
    }
  } else {
#line 2407
    threshold = 1U;
  }
#line 2409
  rtl8723a_set_rxdma_agg_pg_th(padapter, (int )threshold);
#line 2410
  return;
}
}
#line 2413 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
unsigned int rtw_restructure_ht_ie23a(struct rtw_adapter *padapter , u8 *in_ie , u8 *out_ie ,
                                      uint in_len , uint *pout_len ) 
{ 
  u32 out_len ;
  int max_rx_ampdu_factor ;
  unsigned char *pframe ;
  u8 const   *p ;
  struct ieee80211_ht_cap ht_capie ;
  unsigned char WMM_IE[7U] ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  u32 rx_packet_offset ;
  u32 max_recvbuf_sz ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;

  {
#line 2421
  WMM_IE[0] = 0U;
#line 2421
  WMM_IE[1] = 80U;
#line 2421
  WMM_IE[2] = 242U;
#line 2421
  WMM_IE[3] = 2U;
#line 2421
  WMM_IE[4] = 0U;
#line 2421
  WMM_IE[5] = 1U;
#line 2421
  WMM_IE[6] = 0U;
#line 2422
  pmlmepriv = & padapter->mlmepriv;
#line 2423
  phtpriv = & pmlmepriv->htpriv;
#line 2425
  phtpriv->ht_option = 0U;
#line 2427
  p = cfg80211_find_ie(45, (u8 const   *)in_ie + 12U, (int )(in_len - 12U));
#line 2429
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 2431
    if (pmlmepriv->qos_option == 0U) {
#line 2432
      out_len = *pout_len;
#line 2433
      tmp = rtw_set_ie23a(out_ie + (unsigned long )out_len, 221, 7U, (u8 const   *)(& WMM_IE),
                          pout_len);
#line 2433
      pframe = tmp;
#line 2437
      pmlmepriv->qos_option = 1U;
    } else {

    }
#line 2440
    out_len = *pout_len;
#line 2442
    memset((void *)(& ht_capie), 0, 26UL);
#line 2444
    ht_capie.cap_info = 4322U;
#line 2448
    GetHalDefVar8192CUsb(padapter, 5, (void *)(& rx_packet_offset));
#line 2450
    GetHalDefVar8192CUsb(padapter, 4, (void *)(& max_recvbuf_sz));
#line 2453
    GetHalDefVar8192CUsb(padapter, 11, (void *)(& max_rx_ampdu_factor));
#line 2455
    ht_capie.ampdu_params_info = (unsigned int )((u8 )max_rx_ampdu_factor) & 3U;
#line 2457
    if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 2459
      ht_capie.ampdu_params_info = (u8 )((unsigned int )ht_capie.ampdu_params_info | 28U);
    } else {
#line 2462
      ht_capie.ampdu_params_info = ht_capie.ampdu_params_info;
    }
#line 2465
    tmp___0 = rtw_set_ie23a(out_ie + (unsigned long )out_len, 45, 26U, (u8 const   *)(& ht_capie),
                            pout_len);
#line 2465
    pframe = tmp___0;
#line 2469
    phtpriv->ht_option = 1U;
#line 2471
    p = cfg80211_find_ie(61, (u8 const   *)in_ie + 12U, (int )(in_len - 12U));
#line 2473
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) == 22U) {
#line 2474
      out_len = *pout_len;
#line 2475
      tmp___1 = rtw_set_ie23a(out_ie + (unsigned long )out_len, 61, (uint )*(p + 1UL),
                              p + 2UL, pout_len);
#line 2475
      pframe = tmp___1;
    } else {

    }
  } else {

  }
#line 2481
  return (phtpriv->ht_option);
}
}
#line 2485 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_update_ht_cap23a(struct rtw_adapter *padapter , u8 *pie , uint ie_len ) 
{ 
  u8 max_ampdu_sz ;
  u8 const   *p ;
  struct ieee80211_ht_cap *pht_capie ;
  struct ieee80211_ht_addt_info *pht_addtinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bcn_fixed_size ;
  int i ;
  u8 rf_type ;

  {
#line 2491
  pmlmepriv = & padapter->mlmepriv;
#line 2492
  phtpriv = & pmlmepriv->htpriv;
#line 2493
  pregistrypriv = & padapter->registrypriv;
#line 2494
  pmlmeext = & padapter->mlmeextpriv;
#line 2495
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2498
  if (phtpriv->ht_option == 0U) {
#line 2499
    return;
  } else {

  }
#line 2501
  if ((unsigned int )pmlmeinfo->HT_info_enable == 0U || (unsigned int )pmlmeinfo->HT_caps_enable == 0U) {
#line 2502
    return;
  } else {

  }
#line 2504
  if (GlobalDebugLevel23A > 3U) {
#line 2504
    printk("\016RTL8723AU: +rtw_update_ht_cap23a()\n");
  } else {

  }
#line 2506
  bcn_fixed_size = 12;
#line 2510
  pie = pie + (unsigned long )bcn_fixed_size;
#line 2511
  ie_len = ie_len - (uint )bcn_fixed_size;
#line 2514
  if (phtpriv->ampdu_enable == 0U && (unsigned int )pregistrypriv->ampdu_enable == 1U) {
#line 2516
    if ((unsigned int )pregistrypriv->wifi_spec == 1U) {
#line 2517
      phtpriv->ampdu_enable = 0U;
    } else {
#line 2519
      phtpriv->ampdu_enable = 1U;
    }
  } else
#line 2520
  if ((unsigned int )pregistrypriv->ampdu_enable == 2U) {
#line 2521
    phtpriv->ampdu_enable = 1U;
  } else {

  }
#line 2524
  p = cfg80211_find_ie(45, (u8 const   *)pie, (int )ie_len);
#line 2526
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 2527
    pht_capie = (struct ieee80211_ht_cap *)p + 2U;
#line 2528
    max_ampdu_sz = (unsigned int )pht_capie->ampdu_params_info & 3U;
#line 2531
    max_ampdu_sz = (u8 )(1 << ((int )max_ampdu_sz + 3));
#line 2533
    phtpriv->rx_ampdu_maxlen = (u32 )max_ampdu_sz;
  } else {

  }
#line 2536
  p = cfg80211_find_ie(61, (u8 const   *)pie, (int )ie_len);
#line 2537
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 2538
    pht_addtinfo = (struct ieee80211_ht_addt_info *)p + 2U;
  } else {

  }
#line 2543
  if (((unsigned int )pregistrypriv->cbw40_enable != 0U && ((unsigned long )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 2UL) != 0UL) && ((unsigned long )pmlmeinfo->HT_info.infos[0] & 4UL) != 0UL) {
#line 2549
    rf_type = rtl8723a_get_rf_type(padapter);
#line 2552
    i = 0;
#line 2552
    goto ldv_54900;
    ldv_54899: ;
#line 2553
    if ((unsigned int )rf_type == 3U || (unsigned int )rf_type == 0U) {
#line 2554
      pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] = (int )pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] & (int )MCS_rate_1R23A[i];
    } else {
#line 2556
      pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] = (int )pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] & (int )MCS_rate_2R23A[i];
    }
#line 2552
    i = i + 1;
    ldv_54900: ;
#line 2552
    if (i <= 15) {
#line 2554
      goto ldv_54899;
    } else {

    }
#line 2559
    pmlmeext->cur_bwmode = 1U;
#line 2560
    switch ((int )pmlmeinfo->HT_info.infos[0] & 3) {
    case 1: 
#line 2563
    pmlmeext->cur_ch_offset = 1U;
#line 2564
    goto ldv_54903;
    case 3: 
#line 2567
    pmlmeext->cur_ch_offset = 2U;
#line 2568
    goto ldv_54903;
    default: 
#line 2571
    pmlmeext->cur_ch_offset = 0U;
#line 2573
    goto ldv_54903;
    }
    ldv_54903: ;
  } else {

  }
#line 2580
  pmlmeinfo->SM_PS = (u8 )(((int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 12) >> 2);
#line 2582
  if ((unsigned int )pmlmeinfo->SM_PS == 0U) {
#line 2583
    if (GlobalDebugLevel23A > 3U) {
#line 2583
      printk("\016RTL8723AU: %s(): WLAN_HT_CAP_SM_PS_STATIC\n", "rtw_update_ht_cap23a");
    } else {

    }
  } else {

  }
#line 2588
  pmlmeinfo->HT_protection = (unsigned int )pmlmeinfo->HT_info.infos[1] & 3U;
#line 2589
  return;
}
}
#line 2591 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void rtw_issue_addbareq_cmd23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  u8 issued ;
  int priority ;
  struct sta_info *psta ;
  struct ht_priv *phtpriv ;
  struct pkt_attrib *pattrib ;
  s32 bmcst ;
  bool tmp ;

  {
#line 2598
  pattrib = & pxmitframe->attrib;
#line 2599
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 2599
  bmcst = (s32 )tmp;
#line 2601
  if (bmcst != 0 || padapter->mlmepriv.LinkDetectInfo.NumTxOkInPeriod <= 99U) {
#line 2602
    return;
  } else {

  }
#line 2604
  priority = (int )pattrib->priority;
#line 2606
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 2607
    psta = pattrib->psta;
  } else {
#line 2609
    if (GlobalDebugLevel23A > 3U) {
#line 2609
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_issue_addbareq_cmd23a");
    } else {

    }
#line 2610
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 2613
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 2614
    if (GlobalDebugLevel23A > 3U) {
#line 2614
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_issue_addbareq_cmd23a");
    } else {

    }
#line 2615
    return;
  } else {

  }
#line 2618
  if ((psta->state & 1U) == 0U) {
#line 2619
    if (GlobalDebugLevel23A > 3U) {
#line 2619
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_issue_addbareq_cmd23a",
             psta->state);
    } else {

    }
#line 2621
    return;
  } else {

  }
#line 2624
  phtpriv = & psta->htpriv;
#line 2626
  if (phtpriv->ht_option == 1U && phtpriv->ampdu_enable == 1U) {
#line 2627
    issued = (unsigned int )((u8 )((int )phtpriv->agg_enable_bitmap >> priority)) & 1U;
#line 2628
    issued = (u8 )(((int )((signed char )((int )phtpriv->candidate_tid_bitmap >> priority)) & 1) | (int )((signed char )issued));
#line 2630
    if ((unsigned int )issued == 0U) {
#line 2631
      if (GlobalDebugLevel23A > 3U) {
#line 2631
        printk("\016RTL8723AU: rtw_issue_addbareq_cmd23a, p =%d\n", priority);
      } else {

      }
#line 2633
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap | (int )((u16 )(1UL << priority));
#line 2634
      rtw_addbareq_cmd23a(padapter, (int )((unsigned char )priority), (u8 *)(& pattrib->ra));
    } else {

    }
  } else {

  }
#line 2638
  return;
}
}
#line 2640 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int rtw_linked_check(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 2642
  tmp___0 = check_fwstate(& padapter->mlmepriv, 16);
#line 2642
  if ((int )tmp___0) {
#line 2642
    goto _L;
  } else {
#line 2642
    tmp___1 = check_fwstate(& padapter->mlmepriv, 96);
#line 2642
    if ((int )tmp___1) {
      _L: /* CIL Label */ 
#line 2645
      if (padapter->stapriv.asoc_sta_count > 2) {
#line 2646
        return (1);
      } else {

      }
    } else {
#line 2648
      tmp = check_fwstate(& padapter->mlmepriv, 1);
#line 2648
      if ((int )tmp) {
#line 2649
        return (1);
      } else {

      }
    }
  }
#line 2651
  return (0);
}
}
#line 2655 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void ldv_timer_5(int state , struct timer_list *timer ) 
{ 


  {
#line 2656
  LDV_IN_INTERRUPT = 2;
#line 2657
  rtw_set_scan_deny_timer_hdl(timer->data);
#line 2658
  LDV_IN_INTERRUPT = 1;
#line 2659
  return;
}
}
#line 2662 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void choose_timer_5(void) 
{ 
  int tmp ;

  {
#line 2663
  tmp = __VERIFIER_nondet_int();
#line 2663
  switch (tmp) {
  case 0: ;
#line 2665
  if (ldv_timer_5_0 == 1) {
#line 2666
    ldv_timer_5_0 = 2;
#line 2667
    ldv_timer_5(ldv_timer_5_0, ldv_timer_list_5_0);
  } else {

  }
#line 2670
  goto ldv_54929;
  case 1: ;
#line 2672
  if (ldv_timer_5_1 == 1) {
#line 2673
    ldv_timer_5_1 = 2;
#line 2674
    ldv_timer_5(ldv_timer_5_1, ldv_timer_list_5_1);
  } else {

  }
#line 2677
  goto ldv_54929;
  case 2: ;
#line 2679
  if (ldv_timer_5_2 == 1) {
#line 2680
    ldv_timer_5_2 = 2;
#line 2681
    ldv_timer_5(ldv_timer_5_2, ldv_timer_list_5_2);
  } else {

  }
#line 2684
  goto ldv_54929;
  case 3: ;
#line 2686
  if (ldv_timer_5_3 == 1) {
#line 2687
    ldv_timer_5_3 = 2;
#line 2688
    ldv_timer_5(ldv_timer_5_3, ldv_timer_list_5_3);
  } else {

  }
#line 2691
  goto ldv_54929;
  default: 
#line 2692
  ldv_stop();
  }
  ldv_54929: ;
#line 2694
  return;
}
}
#line 2698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 2699
  if ((unsigned long )ldv_timer_list_2_0 == (unsigned long )timer) {
#line 2700
    if (ldv_timer_2_0 == 2 || pending_flag != 0) {
#line 2701
      ldv_timer_list_2_0 = timer;
#line 2702
      ldv_timer_list_2_0->data = data;
#line 2703
      ldv_timer_2_0 = 1;
    } else {

    }
#line 2705
    return;
  } else {

  }
#line 2708
  if ((unsigned long )ldv_timer_list_2_1 == (unsigned long )timer) {
#line 2709
    if (ldv_timer_2_1 == 2 || pending_flag != 0) {
#line 2710
      ldv_timer_list_2_1 = timer;
#line 2711
      ldv_timer_list_2_1->data = data;
#line 2712
      ldv_timer_2_1 = 1;
    } else {

    }
#line 2714
    return;
  } else {

  }
#line 2717
  if ((unsigned long )ldv_timer_list_2_2 == (unsigned long )timer) {
#line 2718
    if (ldv_timer_2_2 == 2 || pending_flag != 0) {
#line 2719
      ldv_timer_list_2_2 = timer;
#line 2720
      ldv_timer_list_2_2->data = data;
#line 2721
      ldv_timer_2_2 = 1;
    } else {

    }
#line 2723
    return;
  } else {

  }
#line 2726
  if ((unsigned long )ldv_timer_list_2_3 == (unsigned long )timer) {
#line 2727
    if (ldv_timer_2_3 == 2 || pending_flag != 0) {
#line 2728
      ldv_timer_list_2_3 = timer;
#line 2729
      ldv_timer_list_2_3->data = data;
#line 2730
      ldv_timer_2_3 = 1;
    } else {

    }
#line 2732
    return;
  } else {

  }
#line 2734
  activate_suitable_timer_2(timer, data);
#line 2735
  return;
}
}
#line 2738 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 2739
  if ((unsigned long )ldv_timer_list_4_0 == (unsigned long )timer) {
#line 2740
    if (ldv_timer_4_0 == 2 || pending_flag != 0) {
#line 2741
      ldv_timer_list_4_0 = timer;
#line 2742
      ldv_timer_list_4_0->data = data;
#line 2743
      ldv_timer_4_0 = 1;
    } else {

    }
#line 2745
    return;
  } else {

  }
#line 2748
  if ((unsigned long )ldv_timer_list_4_1 == (unsigned long )timer) {
#line 2749
    if (ldv_timer_4_1 == 2 || pending_flag != 0) {
#line 2750
      ldv_timer_list_4_1 = timer;
#line 2751
      ldv_timer_list_4_1->data = data;
#line 2752
      ldv_timer_4_1 = 1;
    } else {

    }
#line 2754
    return;
  } else {

  }
#line 2757
  if ((unsigned long )ldv_timer_list_4_2 == (unsigned long )timer) {
#line 2758
    if (ldv_timer_4_2 == 2 || pending_flag != 0) {
#line 2759
      ldv_timer_list_4_2 = timer;
#line 2760
      ldv_timer_list_4_2->data = data;
#line 2761
      ldv_timer_4_2 = 1;
    } else {

    }
#line 2763
    return;
  } else {

  }
#line 2766
  if ((unsigned long )ldv_timer_list_4_3 == (unsigned long )timer) {
#line 2767
    if (ldv_timer_4_3 == 2 || pending_flag != 0) {
#line 2768
      ldv_timer_list_4_3 = timer;
#line 2769
      ldv_timer_list_4_3->data = data;
#line 2770
      ldv_timer_4_3 = 1;
    } else {

    }
#line 2772
    return;
  } else {

  }
#line 2774
  activate_suitable_timer_4(timer, data);
#line 2775
  return;
}
}
#line 2778 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void timer_init_4(void) 
{ 


  {
#line 2779
  ldv_timer_4_0 = 0;
#line 2780
  ldv_timer_4_1 = 0;
#line 2781
  ldv_timer_4_2 = 0;
#line 2782
  ldv_timer_4_3 = 0;
#line 2783
  return;
}
}
#line 2786 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void timer_init_2(void) 
{ 


  {
#line 2787
  ldv_timer_2_0 = 0;
#line 2788
  ldv_timer_2_1 = 0;
#line 2789
  ldv_timer_2_2 = 0;
#line 2790
  ldv_timer_2_3 = 0;
#line 2791
  return;
}
}
#line 2794 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void disable_suitable_timer_3(struct timer_list *timer ) 
{ 


  {
#line 2795
  if (ldv_timer_3_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_0) {
#line 2796
    ldv_timer_3_0 = 0;
#line 2797
    return;
  } else {

  }
#line 2799
  if (ldv_timer_3_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_1) {
#line 2800
    ldv_timer_3_1 = 0;
#line 2801
    return;
  } else {

  }
#line 2803
  if (ldv_timer_3_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_2) {
#line 2804
    ldv_timer_3_2 = 0;
#line 2805
    return;
  } else {

  }
#line 2807
  if (ldv_timer_3_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_3) {
#line 2808
    ldv_timer_3_3 = 0;
#line 2809
    return;
  } else {

  }
#line 2811
  return;
}
}
#line 2815 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_suitable_timer_3(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 2816
  if (ldv_timer_3_0 == 0 || ldv_timer_3_0 == 2) {
#line 2817
    ldv_timer_list_3_0 = timer;
#line 2818
    ldv_timer_list_3_0->data = data;
#line 2819
    ldv_timer_3_0 = 1;
#line 2820
    return;
  } else {

  }
#line 2822
  if (ldv_timer_3_1 == 0 || ldv_timer_3_1 == 2) {
#line 2823
    ldv_timer_list_3_1 = timer;
#line 2824
    ldv_timer_list_3_1->data = data;
#line 2825
    ldv_timer_3_1 = 1;
#line 2826
    return;
  } else {

  }
#line 2828
  if (ldv_timer_3_2 == 0 || ldv_timer_3_2 == 2) {
#line 2829
    ldv_timer_list_3_2 = timer;
#line 2830
    ldv_timer_list_3_2->data = data;
#line 2831
    ldv_timer_3_2 = 1;
#line 2832
    return;
  } else {

  }
#line 2834
  if (ldv_timer_3_3 == 0 || ldv_timer_3_3 == 2) {
#line 2835
    ldv_timer_list_3_3 = timer;
#line 2836
    ldv_timer_list_3_3->data = data;
#line 2837
    ldv_timer_3_3 = 1;
#line 2838
    return;
  } else {

  }
#line 2840
  return;
}
}
#line 2844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void timer_init_5(void) 
{ 


  {
#line 2845
  ldv_timer_5_0 = 0;
#line 2846
  ldv_timer_5_1 = 0;
#line 2847
  ldv_timer_5_2 = 0;
#line 2848
  ldv_timer_5_3 = 0;
#line 2849
  return;
}
}
#line 2852 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void disable_suitable_timer_2(struct timer_list *timer ) 
{ 


  {
#line 2853
  if (ldv_timer_2_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_0) {
#line 2854
    ldv_timer_2_0 = 0;
#line 2855
    return;
  } else {

  }
#line 2857
  if (ldv_timer_2_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_1) {
#line 2858
    ldv_timer_2_1 = 0;
#line 2859
    return;
  } else {

  }
#line 2861
  if (ldv_timer_2_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_2) {
#line 2862
    ldv_timer_2_2 = 0;
#line 2863
    return;
  } else {

  }
#line 2865
  if (ldv_timer_2_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_3) {
#line 2866
    ldv_timer_2_3 = 0;
#line 2867
    return;
  } else {

  }
#line 2869
  return;
}
}
#line 2873 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int reg_timer_3(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 2874
  if ((unsigned long )function == (unsigned long )(& rtw_scan_timeout_handler23a)) {
#line 2875
    activate_suitable_timer_3(timer, data);
  } else {

  }
#line 2876
  return (0);
}
}
#line 2880 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void disable_suitable_timer_5(struct timer_list *timer ) 
{ 


  {
#line 2881
  if (ldv_timer_5_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_0) {
#line 2882
    ldv_timer_5_0 = 0;
#line 2883
    return;
  } else {

  }
#line 2885
  if (ldv_timer_5_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_1) {
#line 2886
    ldv_timer_5_1 = 0;
#line 2887
    return;
  } else {

  }
#line 2889
  if (ldv_timer_5_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_2) {
#line 2890
    ldv_timer_5_2 = 0;
#line 2891
    return;
  } else {

  }
#line 2893
  if (ldv_timer_5_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_3) {
#line 2894
    ldv_timer_5_3 = 0;
#line 2895
    return;
  } else {

  }
#line 2897
  return;
}
}
#line 2901 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 2902
  if (ldv_timer_4_0 == 0 || ldv_timer_4_0 == 2) {
#line 2903
    ldv_timer_list_4_0 = timer;
#line 2904
    ldv_timer_list_4_0->data = data;
#line 2905
    ldv_timer_4_0 = 1;
#line 2906
    return;
  } else {

  }
#line 2908
  if (ldv_timer_4_1 == 0 || ldv_timer_4_1 == 2) {
#line 2909
    ldv_timer_list_4_1 = timer;
#line 2910
    ldv_timer_list_4_1->data = data;
#line 2911
    ldv_timer_4_1 = 1;
#line 2912
    return;
  } else {

  }
#line 2914
  if (ldv_timer_4_2 == 0 || ldv_timer_4_2 == 2) {
#line 2915
    ldv_timer_list_4_2 = timer;
#line 2916
    ldv_timer_list_4_2->data = data;
#line 2917
    ldv_timer_4_2 = 1;
#line 2918
    return;
  } else {

  }
#line 2920
  if (ldv_timer_4_3 == 0 || ldv_timer_4_3 == 2) {
#line 2921
    ldv_timer_list_4_3 = timer;
#line 2922
    ldv_timer_list_4_3->data = data;
#line 2923
    ldv_timer_4_3 = 1;
#line 2924
    return;
  } else {

  }
#line 2926
  return;
}
}
#line 2930 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void ldv_timer_2(int state , struct timer_list *timer ) 
{ 


  {
#line 2931
  LDV_IN_INTERRUPT = 2;
#line 2932
  rtw23a_join_to_handler(timer->data);
#line 2933
  LDV_IN_INTERRUPT = 1;
#line 2934
  return;
}
}
#line 2937 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void choose_timer_2(void) 
{ 
  int tmp ;

  {
#line 2938
  tmp = __VERIFIER_nondet_int();
#line 2938
  switch (tmp) {
  case 0: ;
#line 2940
  if (ldv_timer_2_0 == 1) {
#line 2941
    ldv_timer_2_0 = 2;
#line 2942
    ldv_timer_2(ldv_timer_2_0, ldv_timer_list_2_0);
  } else {

  }
#line 2945
  goto ldv_54984;
  case 1: ;
#line 2947
  if (ldv_timer_2_1 == 1) {
#line 2948
    ldv_timer_2_1 = 2;
#line 2949
    ldv_timer_2(ldv_timer_2_1, ldv_timer_list_2_1);
  } else {

  }
#line 2952
  goto ldv_54984;
  case 2: ;
#line 2954
  if (ldv_timer_2_2 == 1) {
#line 2955
    ldv_timer_2_2 = 2;
#line 2956
    ldv_timer_2(ldv_timer_2_2, ldv_timer_list_2_2);
  } else {

  }
#line 2959
  goto ldv_54984;
  case 3: ;
#line 2961
  if (ldv_timer_2_3 == 1) {
#line 2962
    ldv_timer_2_3 = 2;
#line 2963
    ldv_timer_2(ldv_timer_2_3, ldv_timer_list_2_3);
  } else {

  }
#line 2966
  goto ldv_54984;
  default: 
#line 2967
  ldv_stop();
  }
  ldv_54984: ;
#line 2969
  return;
}
}
#line 2973 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int reg_timer_2(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 2974
  if ((unsigned long )function == (unsigned long )(& rtw23a_join_to_handler)) {
#line 2975
    activate_suitable_timer_2(timer, data);
  } else {

  }
#line 2976
  return (0);
}
}
#line 2980 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void choose_timer_3(void) 
{ 
  int tmp ;

  {
#line 2981
  tmp = __VERIFIER_nondet_int();
#line 2981
  switch (tmp) {
  case 0: ;
#line 2983
  if (ldv_timer_3_0 == 1) {
#line 2984
    ldv_timer_3_0 = 2;
#line 2985
    ldv_timer_3(ldv_timer_3_0, ldv_timer_list_3_0);
  } else {

  }
#line 2988
  goto ldv_54999;
  case 1: ;
#line 2990
  if (ldv_timer_3_1 == 1) {
#line 2991
    ldv_timer_3_1 = 2;
#line 2992
    ldv_timer_3(ldv_timer_3_1, ldv_timer_list_3_1);
  } else {

  }
#line 2995
  goto ldv_54999;
  case 2: ;
#line 2997
  if (ldv_timer_3_2 == 1) {
#line 2998
    ldv_timer_3_2 = 2;
#line 2999
    ldv_timer_3(ldv_timer_3_2, ldv_timer_list_3_2);
  } else {

  }
#line 3002
  goto ldv_54999;
  case 3: ;
#line 3004
  if (ldv_timer_3_3 == 1) {
#line 3005
    ldv_timer_3_3 = 2;
#line 3006
    ldv_timer_3(ldv_timer_3_3, ldv_timer_list_3_3);
  } else {

  }
#line 3009
  goto ldv_54999;
  default: 
#line 3010
  ldv_stop();
  }
  ldv_54999: ;
#line 3012
  return;
}
}
#line 3016 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void timer_init_3(void) 
{ 


  {
#line 3017
  ldv_timer_3_0 = 0;
#line 3018
  ldv_timer_3_1 = 0;
#line 3019
  ldv_timer_3_2 = 0;
#line 3020
  ldv_timer_3_3 = 0;
#line 3021
  return;
}
}
#line 3024 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void choose_timer_4(void) 
{ 
  int tmp ;

  {
#line 3025
  tmp = __VERIFIER_nondet_int();
#line 3025
  switch (tmp) {
  case 0: ;
#line 3027
  if (ldv_timer_4_0 == 1) {
#line 3028
    ldv_timer_4_0 = 2;
#line 3029
    ldv_timer_4(ldv_timer_4_0, ldv_timer_list_4_0);
  } else {

  }
#line 3032
  goto ldv_55011;
  case 1: ;
#line 3034
  if (ldv_timer_4_1 == 1) {
#line 3035
    ldv_timer_4_1 = 2;
#line 3036
    ldv_timer_4(ldv_timer_4_1, ldv_timer_list_4_1);
  } else {

  }
#line 3039
  goto ldv_55011;
  case 2: ;
#line 3041
  if (ldv_timer_4_2 == 1) {
#line 3042
    ldv_timer_4_2 = 2;
#line 3043
    ldv_timer_4(ldv_timer_4_2, ldv_timer_list_4_2);
  } else {

  }
#line 3046
  goto ldv_55011;
  case 3: ;
#line 3048
  if (ldv_timer_4_3 == 1) {
#line 3049
    ldv_timer_4_3 = 2;
#line 3050
    ldv_timer_4(ldv_timer_4_3, ldv_timer_list_4_3);
  } else {

  }
#line 3053
  goto ldv_55011;
  default: 
#line 3054
  ldv_stop();
  }
  ldv_55011: ;
#line 3056
  return;
}
}
#line 3060 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void disable_suitable_timer_4(struct timer_list *timer ) 
{ 


  {
#line 3061
  if (ldv_timer_4_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_0) {
#line 3062
    ldv_timer_4_0 = 0;
#line 3063
    return;
  } else {

  }
#line 3065
  if (ldv_timer_4_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_1) {
#line 3066
    ldv_timer_4_1 = 0;
#line 3067
    return;
  } else {

  }
#line 3069
  if (ldv_timer_4_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_2) {
#line 3070
    ldv_timer_4_2 = 0;
#line 3071
    return;
  } else {

  }
#line 3073
  if (ldv_timer_4_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_3) {
#line 3074
    ldv_timer_4_3 = 0;
#line 3075
    return;
  } else {

  }
#line 3077
  return;
}
}
#line 3081 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 3082
  if ((unsigned long )function == (unsigned long )(& rtw_dynamic_check_timer_handler)) {
#line 3083
    activate_suitable_timer_4(timer, data);
  } else {

  }
#line 3084
  return (0);
}
}
#line 3088 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 3089
  if ((unsigned long )ldv_timer_list_3_0 == (unsigned long )timer) {
#line 3090
    if (ldv_timer_3_0 == 2 || pending_flag != 0) {
#line 3091
      ldv_timer_list_3_0 = timer;
#line 3092
      ldv_timer_list_3_0->data = data;
#line 3093
      ldv_timer_3_0 = 1;
    } else {

    }
#line 3095
    return;
  } else {

  }
#line 3098
  if ((unsigned long )ldv_timer_list_3_1 == (unsigned long )timer) {
#line 3099
    if (ldv_timer_3_1 == 2 || pending_flag != 0) {
#line 3100
      ldv_timer_list_3_1 = timer;
#line 3101
      ldv_timer_list_3_1->data = data;
#line 3102
      ldv_timer_3_1 = 1;
    } else {

    }
#line 3104
    return;
  } else {

  }
#line 3107
  if ((unsigned long )ldv_timer_list_3_2 == (unsigned long )timer) {
#line 3108
    if (ldv_timer_3_2 == 2 || pending_flag != 0) {
#line 3109
      ldv_timer_list_3_2 = timer;
#line 3110
      ldv_timer_list_3_2->data = data;
#line 3111
      ldv_timer_3_2 = 1;
    } else {

    }
#line 3113
    return;
  } else {

  }
#line 3116
  if ((unsigned long )ldv_timer_list_3_3 == (unsigned long )timer) {
#line 3117
    if (ldv_timer_3_3 == 2 || pending_flag != 0) {
#line 3118
      ldv_timer_list_3_3 = timer;
#line 3119
      ldv_timer_list_3_3->data = data;
#line 3120
      ldv_timer_3_3 = 1;
    } else {

    }
#line 3122
    return;
  } else {

  }
#line 3124
  activate_suitable_timer_3(timer, data);
#line 3125
  return;
}
}
#line 3128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 3129
  if ((unsigned long )ldv_timer_list_5_0 == (unsigned long )timer) {
#line 3130
    if (ldv_timer_5_0 == 2 || pending_flag != 0) {
#line 3131
      ldv_timer_list_5_0 = timer;
#line 3132
      ldv_timer_list_5_0->data = data;
#line 3133
      ldv_timer_5_0 = 1;
    } else {

    }
#line 3135
    return;
  } else {

  }
#line 3138
  if ((unsigned long )ldv_timer_list_5_1 == (unsigned long )timer) {
#line 3139
    if (ldv_timer_5_1 == 2 || pending_flag != 0) {
#line 3140
      ldv_timer_list_5_1 = timer;
#line 3141
      ldv_timer_list_5_1->data = data;
#line 3142
      ldv_timer_5_1 = 1;
    } else {

    }
#line 3144
    return;
  } else {

  }
#line 3147
  if ((unsigned long )ldv_timer_list_5_2 == (unsigned long )timer) {
#line 3148
    if (ldv_timer_5_2 == 2 || pending_flag != 0) {
#line 3149
      ldv_timer_list_5_2 = timer;
#line 3150
      ldv_timer_list_5_2->data = data;
#line 3151
      ldv_timer_5_2 = 1;
    } else {

    }
#line 3153
    return;
  } else {

  }
#line 3156
  if ((unsigned long )ldv_timer_list_5_3 == (unsigned long )timer) {
#line 3157
    if (ldv_timer_5_3 == 2 || pending_flag != 0) {
#line 3158
      ldv_timer_list_5_3 = timer;
#line 3159
      ldv_timer_list_5_3->data = data;
#line 3160
      ldv_timer_5_3 = 1;
    } else {

    }
#line 3162
    return;
  } else {

  }
#line 3164
  activate_suitable_timer_5(timer, data);
#line 3165
  return;
}
}
#line 3168 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 3169
  if ((unsigned long )function == (unsigned long )(& rtw_set_scan_deny_timer_hdl)) {
#line 3170
    activate_suitable_timer_5(timer, data);
  } else {

  }
#line 3171
  return (0);
}
}
#line 3175 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void ldv_timer_4(int state , struct timer_list *timer ) 
{ 


  {
#line 3176
  LDV_IN_INTERRUPT = 2;
#line 3177
  rtw_dynamic_check_timer_handler(timer->data);
#line 3178
  LDV_IN_INTERRUPT = 1;
#line 3179
  return;
}
}
#line 3182 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 3183
  if (ldv_timer_5_0 == 0 || ldv_timer_5_0 == 2) {
#line 3184
    ldv_timer_list_5_0 = timer;
#line 3185
    ldv_timer_list_5_0->data = data;
#line 3186
    ldv_timer_5_0 = 1;
#line 3187
    return;
  } else {

  }
#line 3189
  if (ldv_timer_5_1 == 0 || ldv_timer_5_1 == 2) {
#line 3190
    ldv_timer_list_5_1 = timer;
#line 3191
    ldv_timer_list_5_1->data = data;
#line 3192
    ldv_timer_5_1 = 1;
#line 3193
    return;
  } else {

  }
#line 3195
  if (ldv_timer_5_2 == 0 || ldv_timer_5_2 == 2) {
#line 3196
    ldv_timer_list_5_2 = timer;
#line 3197
    ldv_timer_list_5_2->data = data;
#line 3198
    ldv_timer_5_2 = 1;
#line 3199
    return;
  } else {

  }
#line 3201
  if (ldv_timer_5_3 == 0 || ldv_timer_5_3 == 2) {
#line 3202
    ldv_timer_list_5_3 = timer;
#line 3203
    ldv_timer_list_5_3->data = data;
#line 3204
    ldv_timer_5_3 = 1;
#line 3205
    return;
  } else {

  }
#line 3207
  return;
}
}
#line 3211 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void activate_suitable_timer_2(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 3212
  if (ldv_timer_2_0 == 0 || ldv_timer_2_0 == 2) {
#line 3213
    ldv_timer_list_2_0 = timer;
#line 3214
    ldv_timer_list_2_0->data = data;
#line 3215
    ldv_timer_2_0 = 1;
#line 3216
    return;
  } else {

  }
#line 3218
  if (ldv_timer_2_1 == 0 || ldv_timer_2_1 == 2) {
#line 3219
    ldv_timer_list_2_1 = timer;
#line 3220
    ldv_timer_list_2_1->data = data;
#line 3221
    ldv_timer_2_1 = 1;
#line 3222
    return;
  } else {

  }
#line 3224
  if (ldv_timer_2_2 == 0 || ldv_timer_2_2 == 2) {
#line 3225
    ldv_timer_list_2_2 = timer;
#line 3226
    ldv_timer_list_2_2->data = data;
#line 3227
    ldv_timer_2_2 = 1;
#line 3228
    return;
  } else {

  }
#line 3230
  if (ldv_timer_2_3 == 0 || ldv_timer_2_3 == 2) {
#line 3231
    ldv_timer_list_2_3 = timer;
#line 3232
    ldv_timer_list_2_3->data = data;
#line 3233
    ldv_timer_2_3 = 1;
#line 3234
    return;
  } else {

  }
#line 3236
  return;
}
}
#line 3240 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void ldv_timer_3(int state , struct timer_list *timer ) 
{ 


  {
#line 3241
  LDV_IN_INTERRUPT = 2;
#line 3242
  rtw_scan_timeout_handler23a(timer->data);
#line 3243
  LDV_IN_INTERRUPT = 1;
#line 3244
  return;
}
}
#line 3373 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
void *ldv_kmem_cache_alloc_452(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 3376
  ldv_check_alloc_flags(flags);
#line 3378
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 3379
  return ((void *)0);
}
}
#line 3417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_pskb_expand_head_458(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 3420
  ldv_check_alloc_flags(flags);
#line 3422
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 3422
  return (tmp);
}
}
#line 3433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct sk_buff *ldv_skb_clone_460(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3436
  ldv_check_alloc_flags(flags);
#line 3438
  tmp = skb_clone(ldv_func_arg1, flags);
#line 3438
  return (tmp);
}
}
#line 3449 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct sk_buff *ldv_skb_copy_462(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3452
  ldv_check_alloc_flags(flags);
#line 3454
  tmp = skb_copy(ldv_func_arg1, flags);
#line 3454
  return (tmp);
}
}
#line 3457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_463(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3460
  ldv_check_alloc_flags(flags);
#line 3462
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 3462
  return (tmp);
}
}
#line 3465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_464(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3468
  ldv_check_alloc_flags(flags);
#line 3470
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 3470
  return (tmp);
}
}
#line 3473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_465(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3476
  ldv_check_alloc_flags(flags);
#line 3478
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 3478
  return (tmp);
}
}
#line 3481 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_pskb_expand_head_466(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 3484
  ldv_check_alloc_flags(flags);
#line 3486
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 3486
  return (tmp);
}
}
#line 3489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_pskb_expand_head_467(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 3492
  ldv_check_alloc_flags(flags);
#line 3494
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 3494
  return (tmp);
}
}
#line 3497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
struct sk_buff *ldv_skb_clone_468(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3500
  ldv_check_alloc_flags(flags);
#line 3502
  tmp = skb_clone(ldv_func_arg1, flags);
#line 3502
  return (tmp);
}
}
#line 3505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_del_timer_sync_469(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 3509
  tmp = del_timer_sync(ldv_func_arg1);
#line 3509
  ldv_func_res = tmp;
#line 3511
  disable_suitable_timer_6(ldv_func_arg1);
#line 3513
  return (ldv_func_res);
}
}
#line 3516 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_470(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 3520
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3520
  ldv_func_res = tmp;
#line 3522
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3524
  return (ldv_func_res);
}
}
#line 3527 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_471(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 3531
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3531
  ldv_func_res = tmp;
#line 3533
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3535
  return (ldv_func_res);
}
}
#line 3538 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_472(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 3542
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3542
  ldv_func_res = tmp;
#line 3544
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3546
  return (ldv_func_res);
}
}
#line 3549 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_473(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 3553
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3553
  ldv_func_res = tmp;
#line 3555
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3557
  return (ldv_func_res);
}
}
#line 3560 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_474(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 3564
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3564
  ldv_func_res = tmp;
#line 3566
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3568
  return (ldv_func_res);
}
}
#line 3571 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_del_timer_sync_475(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 3575
  tmp = del_timer_sync(ldv_func_arg1);
#line 3575
  ldv_func_res = tmp;
#line 3577
  disable_suitable_timer_6(ldv_func_arg1);
#line 3579
  return (ldv_func_res);
}
}
#line 3582 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_476(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 3586
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3586
  ldv_func_res = tmp;
#line 3588
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3590
  return (ldv_func_res);
}
}
#line 3593 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_477(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 3597
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3597
  ldv_func_res = tmp;
#line 3599
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3601
  return (ldv_func_res);
}
}
#line 3604 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_478(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 3608
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3608
  ldv_func_res = tmp;
#line 3610
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3612
  return (ldv_func_res);
}
}
#line 3615 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme.o.c.prepared"
int ldv_mod_timer_479(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 3619
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3619
  ldv_func_res = tmp;
#line 3621
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3623
  return (ldv_func_res);
}
}
#line 47 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __le64_to_cpup(__le64 const   *p ) 
{ 


  {
#line 49
  return ((__u64 )*p);
}
}
#line 388 "include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 15 "./arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5626;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5626;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5626;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5626;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5626: ;
#line 157
  return (__ret + i);
}
}
#line 43 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 372 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_508(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 374
  _raw_spin_unlock_irqrestore(& lock->ldv_6347.rlock, flags);
#line 375
  return;
}
}
#line 372
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 139 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 175
extern void mutex_unlock(struct mutex * ) ;
#line 179 "include/linux/timer.h"
int ldv_mod_timer_535(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 183
int ldv_mod_timer_536(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 187
int ldv_mod_timer_538(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 191
int ldv_mod_timer_539(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 195
int ldv_mod_timer_540(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 199
int ldv_mod_timer_542(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 203
int ldv_mod_timer_544(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 207
int ldv_mod_timer_546(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 211
int ldv_mod_timer_547(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 215
int ldv_mod_timer_552(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 219
int ldv_mod_timer_553(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 248
int ldv_del_timer_sync_533(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_534(struct timer_list *ldv_func_arg1 ) ;
#line 256
int ldv_del_timer_sync_537(struct timer_list *ldv_func_arg1 ) ;
#line 260
int ldv_del_timer_sync_541(struct timer_list *ldv_func_arg1 ) ;
#line 264
int ldv_del_timer_sync_543(struct timer_list *ldv_func_arg1 ) ;
#line 268
int ldv_del_timer_sync_545(struct timer_list *ldv_func_arg1 ) ;
#line 272
int ldv_del_timer_sync_548(struct timer_list *ldv_func_arg1 ) ;
#line 276
int ldv_del_timer_sync_549(struct timer_list *ldv_func_arg1 ) ;
#line 280
int ldv_del_timer_sync_550(struct timer_list *ldv_func_arg1 ) ;
#line 284
int ldv_del_timer_sync_551(struct timer_list *ldv_func_arg1 ) ;
#line 315 "include/linux/slab.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 319
void *ldv_kmem_cache_alloc_516(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445 "include/linux/slab.h"
__inline static void *ldv_kmalloc_512(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 462
  tmp___2 = __kmalloc(size, flags);
#line 462
  return (tmp___2);
}
}
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
struct timer_list *ldv_timer_list_7_1 ;
#line 27
struct timer_list *ldv_timer_list_8_1 ;
#line 35
int ldv_timer_6_2 ;
#line 43
int ldv_timer_6_0 ;
#line 49
struct timer_list *ldv_timer_list_6_3 ;
#line 51
int ldv_timer_8_2 ;
#line 52
struct timer_list *ldv_timer_list_6_2 ;
#line 57
struct timer_list *ldv_timer_list_7_3 ;
#line 64
struct timer_list *ldv_timer_list_6_0 ;
#line 66
struct timer_list *ldv_timer_list_8_3 ;
#line 67
int ldv_timer_7_1 ;
#line 73
struct timer_list *ldv_timer_list_7_0 ;
#line 83
int ldv_timer_8_3 ;
#line 85
int ldv_timer_7_3 ;
#line 97
struct timer_list *ldv_timer_list_7_2 ;
#line 101
struct timer_list *ldv_timer_list_6_1 ;
#line 102
int ldv_timer_7_0 ;
#line 107
int ldv_timer_6_3 ;
#line 108
int ldv_timer_8_0 ;
#line 117
int ldv_timer_8_1 ;
#line 125
int ldv_timer_7_2 ;
#line 127
struct timer_list *ldv_timer_list_8_0 ;
#line 130
int ldv_timer_6_1 ;
#line 135
struct timer_list *ldv_timer_list_8_2 ;
#line 137
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) ;
#line 138
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 145
void disable_suitable_timer_8(struct timer_list *timer ) ;
#line 153
void timer_init_6(void) ;
#line 156
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 157
void ldv_timer_7(int state , struct timer_list *timer ) ;
#line 176
void choose_timer_8(void) ;
#line 177
void disable_suitable_timer_7(struct timer_list *timer ) ;
#line 180
int reg_timer_8(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 183
void choose_timer_6(void) ;
#line 190
void ldv_timer_6(int state , struct timer_list *timer ) ;
#line 191
void timer_init_7(void) ;
#line 200
void ldv_timer_8(int state , struct timer_list *timer ) ;
#line 206
void choose_timer_7(void) ;
#line 207
void timer_init_8(void) ;
#line 208
void activate_suitable_timer_8(struct timer_list *timer , unsigned long data ) ;
#line 214
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 217
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data ) ;
#line 2212 "include/linux/sched.h"
extern void yield(void) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_524(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_532(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_526(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_522(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_530(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_531(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_527(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_528(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_529(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 17 "include/linux/unaligned/access_ok.h"
__inline static u64 get_unaligned_le64(void const   *p ) 
{ 
  __u64 tmp ;

  {
#line 19
  tmp = __le64_to_cpup((__le64 const   *)p);
#line 19
  return (tmp);
}
}
#line 37 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_le16(u16 val , void *p ) 
{ 


  {
#line 39
  *((__le16 *)p) = val;
#line 40
  return;
}
}
#line 131 "include/linux/etherdevice.h"
__inline static bool is_broadcast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 133
  return ((unsigned int )(((int )((unsigned short )*((u16 const   *)addr)) & (int )((unsigned short )*((u16 const   *)addr + 2U))) & (int )((unsigned short )*((u16 const   *)addr + 4U))) == 65535U);
}
}
#line 284 "include/linux/ieee80211.h"
__inline static int ieee80211_has_retry(__le16 fc ) 
{ 


  {
#line 286
  return (((int )fc & 2048) != 0);
}
}
#line 329 "include/linux/ieee80211.h"
__inline static int ieee80211_is_mgmt(__le16 fc ) 
{ 


  {
#line 331
  return (((int )fc & 12) == 0);
}
}
#line 387 "include/linux/ieee80211.h"
__inline static int ieee80211_is_assoc_req(__le16 fc ) 
{ 


  {
#line 389
  return (((int )fc & 252) == 0);
}
}
#line 427 "include/linux/ieee80211.h"
__inline static int ieee80211_is_probe_req(__le16 fc ) 
{ 


  {
#line 429
  return (((int )fc & 252) == 64);
}
}
#line 437 "include/linux/ieee80211.h"
__inline static int ieee80211_is_probe_resp(__le16 fc ) 
{ 


  {
#line 439
  return (((int )fc & 252) == 80);
}
}
#line 447 "include/linux/ieee80211.h"
__inline static int ieee80211_is_beacon(__le16 fc ) 
{ 


  {
#line 449
  return (((int )fc & 252) == 128);
}
}
#line 3109 "include/net/cfg80211.h"
__inline static void *wiphy_priv___0(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
#line 3111
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
#line 3111
  if (tmp != 0L) {
#line 3111
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3111), "i" (12UL));
    ldv_45997: ;
#line 3111
    goto ldv_45997;
  } else {

  }
#line 3112
  return ((void *)(& wiphy->priv));
}
}
#line 3341 "include/net/cfg80211.h"
__inline static void *wdev_priv___0(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 3343
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
#line 3343
  if (tmp != 0L) {
#line 3343
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3343), "i" (12UL));
    ldv_46077: ;
#line 3343
    goto ldv_46077;
  } else {

  }
#line 3344
  tmp___0 = wiphy_priv___0(wdev->wiphy);
#line 3344
  return (tmp___0);
}
}
#line 418 "drivers/staging/rtl8723au/include/ieee80211.h"
extern u8 hal_ch_offset_to_secondary_ch_offset23a(u8  ) ;
#line 419
extern u8 *rtw_set_ie23a_ch_switch(u8 * , u32 * , u8  , u8  , u8  ) ;
#line 420
extern u8 *rtw_set_ie23a_secondary_ch_offset(u8 * , u32 * , u8  ) ;
#line 196 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void rtw_sctx_init23a(struct submit_ctx *sctx , int timeout_ms ) ;
#line 197
int rtw_sctx_wait23a(struct submit_ctx *sctx ) ;
#line 342
struct xmit_buf *rtw_alloc_xmitbuf23a_ext(struct xmit_priv *pxmitpriv ) ;
#line 347
s32 rtw_free_xmitbuf23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) ;
#line 353
struct xmit_frame *rtw_alloc_xmitframe23a_ext(struct xmit_priv *pxmitpriv ) ;
#line 355
s32 rtw_free_xmitframe23a(struct xmit_priv *pxmitpriv , struct xmit_frame *pxmitframe ) ;
#line 393
int rtw_ack_tx_wait23a(struct xmit_priv *pxmitpriv , u32 timeout_ms ) ;
#line 307 "drivers/staging/rtl8723au/include/rtw_recv.h"
void mgt_dispatcher23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 113 "drivers/staging/rtl8723au/include/hal_intf.h"
void hw_var_set_correct_tsf(struct rtw_adapter *padapter ) ;
#line 114
void hw_var_set_mlme_disconnect(struct rtw_adapter *padapter ) ;
#line 115
void hw_var_set_opmode(struct rtw_adapter *padapter , u8 mode ) ;
#line 117
void hw_var_set_bssid(struct rtw_adapter *padapter , u8 *val ) ;
#line 118
void hw_var_set_mlme_join(struct rtw_adapter *padapter , u8 type ) ;
#line 163 "drivers/staging/rtl8723au/include/hal_com.h"
void HalSetBrateCfg23a(struct rtw_adapter *padapter , u8 *mBratesOS ) ;
#line 176
void rtl8723a_set_bcn_func(struct rtw_adapter *padapter , u8 val ) ;
#line 178
void rtl8723a_mlme_sitesurvey(struct rtw_adapter *padapter , u8 flag ) ;
#line 179
void rtl8723a_on_rcr_am(struct rtw_adapter *padapter ) ;
#line 183
void rtl8723a_set_sec_cfg(struct rtw_adapter *padapter , u8 sec ) ;
#line 186
void rtl8723a_cam_write(struct rtw_adapter *padapter , u8 entry , u16 ctrl , u8 const   *mac ,
                        u8 const   *key ) ;
#line 190
void rtl8723a_bcn_valid(struct rtw_adapter *padapter ) ;
#line 191
bool rtl8723a_get_bcn_valid(struct rtw_adapter *padapter ) ;
#line 192
void rtl8723a_set_beacon_interval(struct rtw_adapter *padapter , u16 interval ) ;
#line 201
void rtl8723a_set_initial_gain(struct rtw_adapter *padapter , u32 rx_gain ) ;
#line 204
void rtl8723a_odm_support_ability_backup(struct rtw_adapter *padapter ) ;
#line 205
void rtl8723a_odm_support_ability_restore(struct rtw_adapter *padapter ) ;
#line 206
void rtl8723a_odm_support_ability_set(struct rtw_adapter *padapter , u32 val ) ;
#line 207
void rtl8723a_odm_support_ability_clr(struct rtw_adapter *padapter , u32 val ) ;
#line 324 "drivers/staging/rtl8723au/include/rtw_security.h"
void rtw_wep_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 92 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
unsigned char WMM_OUI23A[4U] ;
#line 93
unsigned char WPS_OUI23A[4U] ;
#line 94
unsigned char WFD_OUI23A[4U] ;
#line 95
unsigned char P2P_OUI23A[4U] ;
#line 97
unsigned char WMM_INFO_OUI23A[6U] ;
#line 98
unsigned char WMM_PARA_OUI23A[6U] ;
#line 381
int rtw_ch_set_search_ch23a(struct rt_channel_info *ch_set , u32 const   ch ) ;
#line 459
int init_mlme_ext_priv23a(struct rtw_adapter *padapter ) ;
#line 460
int init_hw_mlme_ext23a(struct rtw_adapter *padapter ) ;
#line 461
void free_mlme_ext_priv23a(struct mlme_ext_priv *pmlmeext ) ;
#line 462
void init_mlme_ext_timer23a(struct rtw_adapter *padapter ) ;
#line 463
void init_addba_retry_timer23a(struct sta_info *psta ) ;
#line 464
struct xmit_frame *alloc_mgtxmitframe23a(struct xmit_priv *pxmitpriv ) ;
#line 469
void get_rate_set23a(struct rtw_adapter *padapter , unsigned char *pbssrate , int *bssrate_len ) ;
#line 471
void UpdateBrateTbl23a(struct rtw_adapter *Adapter , u8 *mBratesOS ) ;
#line 472
void Update23aTblForSoftAP(u8 *bssrateset , u32 bssratelen ) ;
#line 474
void Set_MSR23a(struct rtw_adapter *padapter , u8 type ) ;
#line 476
extern u8 rtw_get_oper_ch23a(struct rtw_adapter * ) ;
#line 483
void set_channel_bwmode23a(struct rtw_adapter *padapter , unsigned char channel ,
                           unsigned char channel_offset , unsigned short bwmode ) ;
#line 485
void SelectChannel23a(struct rtw_adapter *padapter , unsigned char channel ) ;
#line 487
unsigned int decide_wait_for_beacon_timeout23a(unsigned int bcn_interval ) ;
#line 493
int allocate_fw_sta_entry23a(struct rtw_adapter *padapter ) ;
#line 494
void flush_all_cam_entry23a(struct rtw_adapter *padapter ) ;
#line 496
bool IsLegal5GChannel(struct rtw_adapter *Adapter , u8 channel ) ;
#line 498
int collect_bss_info23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ,
                        struct wlan_bssid_ex *bssid ) ;
#line 504
extern u8 *get_my_bssid23a(struct wlan_bssid_ex * ) ;
#line 505
u16 get_beacon_interval23a(struct wlan_bssid_ex *bss ) ;
#line 507
bool is_client_associated_to_ap23a(struct rtw_adapter *padapter ) ;
#line 508
bool is_client_associated_to_ibss23a(struct rtw_adapter *padapter ) ;
#line 509
bool is_IBSS_empty23a(struct rtw_adapter *padapter ) ;
#line 513
int WMM_param_handler23a(struct rtw_adapter *padapter , u8 *p ) ;
#line 514
void WMMOnAssocRsp23a(struct rtw_adapter *padapter ) ;
#line 516
void HT_caps_handler23a(struct rtw_adapter *padapter , u8 *p ) ;
#line 517
void HT_info_handler23a(struct rtw_adapter *padapter , u8 *p ) ;
#line 518
void HTOnAssocRsp23a(struct rtw_adapter *padapter ) ;
#line 520
void ERP_IE_handler23a(struct rtw_adapter *padapter , u8 *p ) ;
#line 521
void VCS_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 523
void update_beacon23a_info(struct rtw_adapter *padapter , u8 *pframe , uint pkt_len ,
                           struct sta_info *psta ) ;
#line 525
int rtw_check_bcn_info23a(struct rtw_adapter *Adapter , struct ieee80211_mgmt *mgmt ,
                          u32 pkt_len ) ;
#line 527
void update_IOT_info23a(struct rtw_adapter *padapter ) ;
#line 528
void update_capinfo23a(struct rtw_adapter *Adapter , u16 updateCap ) ;
#line 529
void update_wireless_mode23a(struct rtw_adapter *padapter ) ;
#line 530
void update_tx_basic_rate23a(struct rtw_adapter *padapter , u8 wirelessmode ) ;
#line 531
void update_bmc_sta_support_rate23a(struct rtw_adapter *padapter , u32 mac_id ) ;
#line 532
int update_sta_support_rate23a(struct rtw_adapter *padapter , u8 *pvar_ie , uint var_ie_len ,
                               int cam_idx ) ;
#line 540
void Update_RA_Entry23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 541
void set_sta_rate23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 543
int receive_disconnect23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                          unsigned short reason ) ;
#line 547
int support_short_GI23a(struct rtw_adapter *padapter , struct HT_caps_element *pHT_caps ) ;
#line 549
bool is_ap_in_tkip23a(struct rtw_adapter *padapter ) ;
#line 553
void report_join_res23a(struct rtw_adapter *padapter , int res ) ;
#line 554
void report_survey_event23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 556
void report_surveydone_event23a(struct rtw_adapter *padapter ) ;
#line 557
void report_del_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             unsigned short reason ) ;
#line 559
void report_add_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             int cam_idx ) ;
#line 562
int set_tx_beacon_cmd23a(struct rtw_adapter *padapter ) ;
#line 565
void update_mgnt_tx_rate23a(struct rtw_adapter *padapter , u8 rate ) ;
#line 566
void update_mgntframe_attrib23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) ;
#line 568
void dump_mgntframe23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
#line 570
s32 dump_mgntframe23a_and_wait(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ,
                               int timeout_ms ) ;
#line 572
s32 dump_mgntframe23a_and_wait_ack23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
#line 575
void issue_beacon23a(struct rtw_adapter *padapter , int timeout_ms ) ;
#line 576
int issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                      int try_cnt , int wait_ms ) ;
#line 578
int issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , u16 tid ,
                          int try_cnt , int wait_ms ) ;
#line 580
int issue_deauth23a(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ) ;
#line 582
void issue_action_spct_ch_switch23a(struct rtw_adapter *padapter , u8 *ra , u8 new_ch ,
                                    u8 ch_offset ) ;
#line 584
void issue_action_BA23a(struct rtw_adapter *padapter , unsigned char const   *raddr ,
                        unsigned char action , unsigned short status ) ;
#line 587
int send_delba23a(struct rtw_adapter *padapter , u8 initiator , u8 *addr ) ;
#line 588
int send_beacon23a(struct rtw_adapter *padapter ) ;
#line 607
void process_addba_req23a(struct rtw_adapter *padapter , u8 *paddba_req , u8 *addr ) ;
#line 26 "drivers/staging/rtl8723au/include/rtw_ap.h"
void init_mlme_ap_info23a(struct rtw_adapter *padapter ) ;
#line 41
void associated_clients_update23a(struct rtw_adapter *padapter , u8 updated ) ;
#line 42
void bss_cap_update_on_sta_join23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 44
void sta_info_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 46
u8 ap_free_sta23a(struct rtw_adapter *padapter , struct sta_info *psta , bool active ,
                  u16 reason ) ;
#line 58 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter , u8 *pmgmt_frame ,
                                     uint frame_len ) ;
#line 64
void rtw_cfg80211_rx_action(struct rtw_adapter *adapter , u8 *frame , uint frame_len ,
                            char const   *msg ) ;
#line 219 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
int rtl8723au_hal_xmitframe_enqueue(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 223
int rtl8723au_mgnt_xmit(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) ;
#line 23 "drivers/staging/rtl8723au/include/rtl8723a_sreset.h"
void rtl8723a_sreset_linked_status_check(struct rtw_adapter *padapter ) ;
#line 545 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_SetBeaconRelatedRegisters(struct rtw_adapter *padapter ) ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAssocReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 246
static int OnAssocRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 247
static int OnProbeReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 248
static int OnProbeRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 249
static int DoReserved23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 250
static int OnBeacon23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 251
static int OnAtim23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 252
static int OnDisassoc23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 253
static int OnAuth23aClient23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 254
static int OnDeAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 255
static int OnAction23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 257
static int on_action_spct23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 258
static int OnAction23a_qos(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 259
static int OnAction23a_dls(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 260
static int OnAction23a_back23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 261
static int on_action_public23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 262
static int OnAction23a_ht(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 263
static int OnAction23a_wmm(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 264
static int OnAction23a_p2p(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 266
static void issue_assocreq(struct rtw_adapter *padapter ) ;
#line 267
__inline static void issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                    u8 *da ) ;
#line 269
static int issue_probereq_ex(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                             u8 *da , int try_cnt , int wait_ms ) ;
#line 272
static void issue_probersp(struct rtw_adapter *padapter , unsigned char *da , u8 is_valid_p2p_probereq ) ;
#line 274
static void issue_auth(struct rtw_adapter *padapter , struct sta_info *psta , unsigned short status ) ;
#line 276
static int issue_deauth_ex(struct rtw_adapter *padapter , u8 *da , unsigned short reason ,
                           int try_cnt , int wait_ms ) ;
#line 278
static void start_clnt_assoc(struct rtw_adapter *padapter ) ;
#line 279
static void start_clnt_auth(struct rtw_adapter *padapter ) ;
#line 280
static void start_clnt_join(struct rtw_adapter *padapter ) ;
#line 281
static void start_create_ibss(struct rtw_adapter *padapter ) ;
#line 284
static int OnAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 285
static void issue_assocrsp(struct rtw_adapter *padapter , unsigned short status ,
                           struct sta_info *pstat , u16 pkt_type ) ;
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static struct mlme_handler mlme_sta_tbl[14U]  = 
#line 289
  {      {(char *)"OnAssocReq23a", & OnAssocReq23a}, 
        {(char *)"OnAssocRsp23a", & OnAssocRsp23a}, 
        {(char *)"OnReAssocReq", & OnAssocReq23a}, 
        {(char *)"OnReAssocRsp", & OnAssocRsp23a}, 
        {(char *)"OnProbeReq23a", & OnProbeReq23a}, 
        {(char *)"OnProbeRsp23a", & OnProbeRsp23a}, 
        {(char *)"DoReserved23a", & DoReserved23a}, 
        {(char *)"DoReserved23a", & DoReserved23a}, 
        {(char *)"OnBeacon23a", & OnBeacon23a}, 
        {(char *)"OnATIM", & OnAtim23a}, 
        {(char *)"OnDisassoc23a", & OnDisassoc23a}, 
        {(char *)"OnAuth23a", & OnAuth23aClient23a}, 
        {(char *)"OnDeAuth23a", & OnDeAuth23a}, 
        {(char *)"OnAction23a", & OnAction23a}};
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static struct action_handler OnAction23a_tbl[9U]  = 
#line 310
  {      {0U, (char *)"ACTION_SPECTRUM_MGMT", & on_action_spct23a}, 
        {1U, (char *)"ACTION_QOS", & OnAction23a_qos}, 
        {2U, (char *)"ACTION_DLS", & OnAction23a_dls}, 
        {3U, (char *)"ACTION_BACK", & OnAction23a_back23a}, 
        {4U, (char *)"ACTION_PUBLIC", & on_action_public23a}, 
        {7U, (char *)"ACTION_HT", & OnAction23a_ht}, 
        {8U, (char *)"ACTION_SA_QUERY", & DoReserved23a}, 
        {17U, (char *)"ACTION_WMM", & OnAction23a_wmm}, 
        {127U, (char *)"ACTION_P2P", & OnAction23a_p2p}};
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static u8 null_addr[6U]  = {      0U,      0U,      0U,      0U, 
        0U,      0U};
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
unsigned char WMM_OUI23A[4U]  = {      0U,      80U,      242U,      2U};
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
unsigned char WPS_OUI23A[4U]  = {      0U,      80U,      242U,      4U};
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
unsigned char P2P_OUI23A[4U]  = {      80U,      111U,      154U,      9U};
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
unsigned char WFD_OUI23A[4U]  = {      80U,      111U,      154U,      10U};
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
unsigned char WMM_INFO_OUI23A[6U]  = {      0U,      80U,      242U,      2U, 
        0U,      1U};
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
unsigned char WMM_PARA_OUI23A[6U]  = {      0U,      80U,      242U,      2U, 
        1U,      1U};
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static unsigned char REALTEK_96B_IE[6U]  = {      0U,      224U,      76U,      2U, 
        1U,      32U};
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
unsigned char MCS_rate_2R23A[16U]  = 
#line 340
  {      255U,      255U,      0U,      0U, 
        1U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U};
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
unsigned char MCS_rate_1R23A[16U]  = 
#line 342
  {      255U,      0U,      0U,      0U, 
        1U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U};
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static struct rt_channel_plan_2g RTW_ChannelPlan2G[6U]  = {      {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U}, 13U}, 
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U}, 13U}, 
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U}, 11U}, 
        {{1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U, 11U, 12U, 13U, 14U}, 14U}, 
        {{10U, 11U, 12U, 13U}, 4U}, 
        {{(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, 0U}};
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static struct rt_channel_plan_5g RTW_ChannelPlan5G[20U]  = 
#line 358
  {      {{(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}, 0U}, 
        {{36U,
       40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U, 124U,
       128U, 132U, 136U, 140U}, 19U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U, 149U, 153U, 157U, 161U, 165U}, 24U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 149U, 153U, 157U, 161U, 165U}, 22U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U, 149U, 153U, 157U, 161U, 165U}, 24U}, 
        {{36U, 40U, 44U, 48U, 149U, 153U, 157U, 161U, 165U}, 9U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 149U, 153U, 157U, 161U, 165U}, 13U}, 
        {{36U,
       40U, 44U, 48U, 52U, 56U, 60U, 64U, 149U, 153U, 157U, 161U}, 12U}, 
        {{149U, 153U, 157U, 161U, 165U}, 5U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U}, 8U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 136U,
       140U, 149U, 153U, 157U, 161U, 165U}, 20U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 149U, 153U, 157U, 161U, 165U}, 20U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 120U,
       124U, 128U, 132U, 136U, 140U}, 19U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U}, 8U}, 
        {{100U, 104U, 108U, 112U, 116U, 120U, 124U, 128U, 132U, 136U, 140U}, 11U}, 
        {{56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 136U, 140U, 149U, 153U, 157U,
       161U, 165U}, 15U}, 
        {{56U, 60U, 64U, 149U, 153U, 157U, 161U, 165U}, 8U}, 
        {{36U, 40U, 44U, 48U, 52U, 56U, 60U, 64U, 100U, 104U, 108U, 112U, 116U, 132U,
       136U, 140U, 149U, 153U, 157U, 161U, 165U}, 21U}, 
        {{36U, 40U, 44U, 48U}, 4U}, 
        {{36U, 40U, 44U, 48U, 149U, 153U, 157U, 161U}, 8U}};
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static struct rt_channel_plan_map RTW_ChannelPlanMap[66U]  = 
#line 383
  {      {2U, 17U}, 
        {2U, 10U}, 
        {1U, 1U}, 
        {1U, 0U}, 
        {1U, 0U}, 
        {3U, 0U}, 
        {3U, 0U}, 
        {1U, 9U}, 
        {3U, 9U}, 
        {3U, 0U}, 
        {0U, 0U}, 
        {2U, 15U}, 
        {1U, 8U}, 
        {2U, 6U}, 
        {2U, 11U}, 
        {2U, 9U}, 
        {1U, 1U}, 
        {2U, 5U}, 
        {1U, 18U}, 
        {0U, 4U}, 
        {2U, 16U}, 
        {0U, 18U}, 
        {0U, 19U}, 
        {3U, 18U}, 
        {5U, 8U}, 
        {2U, 8U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {5U, 4U}, 
        {0U, 0U}, 
        {1U, 0U}, 
        {2U, 0U}, 
        {3U, 0U}, 
        {4U, 0U}, 
        {2U, 4U}, 
        {0U, 1U}, 
        {3U, 12U}, 
        {0U, 11U}, 
        {0U, 5U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 6U}, 
        {0U, 7U}, 
        {0U, 8U}, 
        {0U, 9U}, 
        {2U, 10U}, 
        {0U, 2U}, 
        {0U, 3U}, 
        {3U, 13U}, 
        {3U, 14U}, 
        {2U, 15U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {0U, 0U}, 
        {2U, 16U}, 
        {3U, 0U}};
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static struct rt_channel_plan_map RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE  =    {3U, 2U};
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void dummy_event_callback(struct rtw_adapter *adapter , u8 const   *pbuf ) 
{ 


  {
#line 458
  return;
}
}
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static struct fwevent wlanevents[25U]  = 
#line 460
  {      {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, & rtw_survey_event_cb23a}, 
        {4U, & rtw_surveydone_event_callback23a}, 
        {0U, & rtw23a_joinbss_event_cb}, 
        {12U, & rtw_stassoc_event_callback23a}, 
        {12U, & rtw_stadel_event_callback23a}, 
        {0U, & dummy_event_callback}, 
        {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}, 
        {0U, & dummy_event_callback}, 
        {0U, (void (*)(struct rtw_adapter * , u8 const   * ))0}};
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void rtw_correct_TSF(struct rtw_adapter *padapter ) 
{ 


  {
#line 493
  hw_var_set_correct_tsf(padapter);
#line 494
  return;
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void rtw_update_TSF(struct mlme_ext_priv *pmlmeext , struct ieee80211_mgmt *mgmt ) 
{ 


  {
#line 499
  pmlmeext->TSFValue = get_unaligned_le64((void const   *)(& mgmt->u.beacon.timestamp));
#line 500
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int rtw_ch_set_search_ch23a(struct rt_channel_info *ch_set , u32 const   ch ) 
{ 
  int i ;

  {
#line 512
  i = 0;
#line 512
  goto ldv_54463;
  ldv_54462: ;
#line 513
  if ((unsigned int )(ch_set + (unsigned long )i)->ChannelNum == (unsigned int )ch) {
#line 514
    goto ldv_54461;
  } else {

  }
#line 512
  i = i + 1;
  ldv_54463: ;
#line 512
  if ((unsigned int )(ch_set + (unsigned long )i)->ChannelNum != 0U) {
#line 514
    goto ldv_54462;
  } else {

  }
  ldv_54461: ;
#line 517
  if ((int )(ch_set + (unsigned long )i)->ChannelNum <= i) {
#line 518
    return (-1);
  } else {

  }
#line 519
  return (i);
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int init_hw_mlme_ext23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 530
  pmlmeext = & padapter->mlmeextpriv;
#line 532
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 534
  return (1);
}
}
#line 537 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void init_mlme_ext_priv23a_value(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char mixed_datarate[13U] ;
  unsigned char mixed_basicrate[13U] ;
  unsigned int tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 539
  pmlmeext = & padapter->mlmeextpriv;
#line 540
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 541
  mixed_datarate[0] = 0U;
#line 541
  mixed_datarate[1] = 1U;
#line 541
  mixed_datarate[2] = 2U;
#line 541
  mixed_datarate[3] = 3U;
#line 541
  mixed_datarate[4] = 4U;
#line 541
  mixed_datarate[5] = 5U;
#line 541
  mixed_datarate[6] = 6U;
#line 541
  mixed_datarate[7] = 7U;
#line 541
  mixed_datarate[8] = 8U;
#line 541
  mixed_datarate[9] = 9U;
#line 541
  mixed_datarate[10] = 10U;
#line 541
  mixed_datarate[11] = 11U;
#line 541
  mixed_datarate[12] = 255U;
#line 545
  mixed_basicrate[0] = 0U;
#line 545
  mixed_basicrate[1] = 1U;
#line 545
  mixed_basicrate[2] = 2U;
#line 545
  mixed_basicrate[3] = 3U;
#line 545
  mixed_basicrate[4] = 4U;
#line 545
  mixed_basicrate[5] = 6U;
#line 545
  mixed_basicrate[6] = 8U;
#line 545
  mixed_basicrate[7] = 255U;
#line 545
  tmp = 8U;
#line 545
  while (1) {
#line 545
    if (tmp >= 13U) {
#line 545
      break;
    } else {

    }
#line 545
    mixed_basicrate[tmp] = (unsigned char)0;
#line 545
    tmp = tmp + 1U;
  }
#line 549
  atomic_set(& pmlmeext->event_seq, 0);
#line 551
  pmlmeext->mgnt_seq = 0U;
#line 553
  pmlmeext->cur_channel = padapter->registrypriv.channel;
#line 554
  pmlmeext->cur_bwmode = 0U;
#line 555
  pmlmeext->cur_ch_offset = 0U;
#line 557
  pmlmeext->retry = 0U;
#line 559
  pmlmeext->cur_wireless_mode = padapter->registrypriv.wireless_mode;
#line 561
  __len = 13UL;
#line 561
  if (__len > 63UL) {
#line 561
    __ret = __memcpy((void *)(& pmlmeext->datarate), (void const   *)(& mixed_datarate),
                     __len);
  } else {
#line 561
    __ret = __builtin_memcpy((void *)(& pmlmeext->datarate), (void const   *)(& mixed_datarate),
                             __len);
  }
#line 562
  __len___0 = 13UL;
#line 562
  if (__len___0 > 63UL) {
#line 562
    __ret___0 = __memcpy((void *)(& pmlmeext->basicrate), (void const   *)(& mixed_basicrate),
                         __len___0);
  } else {
#line 562
    __ret___0 = __builtin_memcpy((void *)(& pmlmeext->basicrate), (void const   *)(& mixed_basicrate),
                                 __len___0);
  }
#line 564
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
#line 565
    pmlmeext->tx_rate = 12U;
  } else {
#line 567
    pmlmeext->tx_rate = 2U;
  }
#line 569
  pmlmeext->sitesurvey_res.state = 0;
#line 570
  pmlmeext->sitesurvey_res.channel_idx = 0;
#line 571
  pmlmeext->sitesurvey_res.bss_cnt = 0;
#line 572
  pmlmeext->scan_abort = 0U;
#line 574
  pmlmeinfo->state = 0U;
#line 575
  pmlmeinfo->reauth_count = 0U;
#line 576
  pmlmeinfo->reassoc_count = 0U;
#line 577
  pmlmeinfo->link_count = 0U;
#line 578
  pmlmeinfo->auth_seq = 0U;
#line 579
  pmlmeinfo->auth_algo = 0U;
#line 580
  pmlmeinfo->key_index = 0U;
#line 581
  pmlmeinfo->iv = 0U;
#line 583
  pmlmeinfo->enc_algo = 0U;
#line 584
  pmlmeinfo->authModeToggle = 0U;
#line 586
  memset((void *)(& pmlmeinfo->chg_txt), 0, 128UL);
#line 588
  pmlmeinfo->slotTime = 9U;
#line 589
  pmlmeinfo->preamble_mode = 2U;
#line 591
  pmlmeinfo->dialogToken = 0U;
#line 593
  pmlmeext->action_public_rxseq = 65535U;
#line 594
  pmlmeext->action_public_dialog_token = 255U;
#line 595
  return;
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int has_channel(struct rt_channel_info *channel_set , u8 chanset_size , u8 chan ) 
{ 
  int i ;

  {
#line 601
  i = 0;
#line 601
  goto ldv_54488;
  ldv_54487: ;
#line 602
  if ((int )(channel_set + (unsigned long )i)->ChannelNum == (int )chan) {
#line 603
    return (1);
  } else {

  }
#line 601
  i = i + 1;
  ldv_54488: ;
#line 601
  if ((int )chanset_size > i) {
#line 603
    goto ldv_54487;
  } else {

  }

#line 606
  return (0);
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void init_channel_list(struct rtw_adapter *padapter , struct rt_channel_info *channel_set ,
                              u8 chanset_size , struct p2p_channels *channel_list ) 
{ 
  struct p2p_oper_class_map op_class[10U] ;
  int cla ;
  int op ;
  u8 ch ;
  struct p2p_oper_class_map *o ;
  struct p2p_reg_class *reg ;
  int tmp ;

  {
#line 614
  op_class[0].mode = 0;
#line 614
  op_class[0].op_class = 81U;
#line 614
  op_class[0].min_chan = 1U;
#line 614
  op_class[0].max_chan = 13U;
#line 614
  op_class[0].inc = 1U;
#line 614
  op_class[0].bw = 0;
#line 614
  op_class[1].mode = 0;
#line 614
  op_class[1].op_class = 82U;
#line 614
  op_class[1].min_chan = 14U;
#line 614
  op_class[1].max_chan = 14U;
#line 614
  op_class[1].inc = 1U;
#line 614
  op_class[1].bw = 0;
#line 614
  op_class[2].mode = 1;
#line 614
  op_class[2].op_class = 115U;
#line 614
  op_class[2].min_chan = 36U;
#line 614
  op_class[2].max_chan = 48U;
#line 614
  op_class[2].inc = 4U;
#line 614
  op_class[2].bw = 0;
#line 614
  op_class[3].mode = 1;
#line 614
  op_class[3].op_class = 116U;
#line 614
  op_class[3].min_chan = 36U;
#line 614
  op_class[3].max_chan = 44U;
#line 614
  op_class[3].inc = 8U;
#line 614
  op_class[3].bw = 1;
#line 614
  op_class[4].mode = 1;
#line 614
  op_class[4].op_class = 117U;
#line 614
  op_class[4].min_chan = 40U;
#line 614
  op_class[4].max_chan = 48U;
#line 614
  op_class[4].inc = 8U;
#line 614
  op_class[4].bw = 2;
#line 614
  op_class[5].mode = 1;
#line 614
  op_class[5].op_class = 124U;
#line 614
  op_class[5].min_chan = 149U;
#line 614
  op_class[5].max_chan = 161U;
#line 614
  op_class[5].inc = 4U;
#line 614
  op_class[5].bw = 0;
#line 614
  op_class[6].mode = 1;
#line 614
  op_class[6].op_class = 125U;
#line 614
  op_class[6].min_chan = 149U;
#line 614
  op_class[6].max_chan = 169U;
#line 614
  op_class[6].inc = 4U;
#line 614
  op_class[6].bw = 0;
#line 614
  op_class[7].mode = 1;
#line 614
  op_class[7].op_class = 126U;
#line 614
  op_class[7].min_chan = 149U;
#line 614
  op_class[7].max_chan = 157U;
#line 614
  op_class[7].inc = 8U;
#line 614
  op_class[7].bw = 1;
#line 614
  op_class[8].mode = 1;
#line 614
  op_class[8].op_class = 127U;
#line 614
  op_class[8].min_chan = 153U;
#line 614
  op_class[8].max_chan = 161U;
#line 614
  op_class[8].inc = 8U;
#line 614
  op_class[8].bw = 2;
#line 614
  op_class[9].mode = 4294967295L;
#line 614
  op_class[9].op_class = 0U;
#line 614
  op_class[9].min_chan = 0U;
#line 614
  op_class[9].max_chan = 0U;
#line 614
  op_class[9].inc = 0U;
#line 614
  op_class[9].bw = 0;
#line 629
  cla = 0;
#line 631
  op = 0;
#line 631
  goto ldv_54507;
  ldv_54506: 
#line 633
  o = (struct p2p_oper_class_map *)(& op_class) + (unsigned long )op;
#line 634
  reg = (struct p2p_reg_class *)0;
#line 636
  ch = o->min_chan;
#line 636
  goto ldv_54504;
  ldv_54503: 
#line 637
  tmp = has_channel(channel_set, (int )chanset_size, (int )ch);
#line 637
  if (tmp == 0) {
#line 638
    goto ldv_54502;
  } else {

  }
#line 640
  if ((unsigned int )padapter->registrypriv.ht_enable == 0U && (unsigned int )o->inc == 8U) {
#line 642
    goto ldv_54502;
  } else {

  }
#line 644
  if (((unsigned long )padapter->registrypriv.cbw40_enable & 2UL) == 0UL && ((unsigned int )o->bw == 2U || (unsigned int )o->bw == 1U)) {
#line 646
    goto ldv_54502;
  } else {

  }
#line 648
  if ((unsigned long )reg == (unsigned long )((struct p2p_reg_class *)0)) {
#line 649
    reg = (struct p2p_reg_class *)(& channel_list->reg_class) + (unsigned long )cla;
#line 650
    cla = cla + 1;
#line 651
    reg->reg_class = o->op_class;
#line 652
    reg->channels = 0UL;
  } else {

  }
#line 654
  reg->channel[reg->channels] = ch;
#line 655
  reg->channels = reg->channels + 1UL;
  ldv_54502: 
#line 636
  ch = (int )o->inc + (int )ch;
  ldv_54504: ;
#line 636
  if ((int )o->max_chan >= (int )ch) {
#line 638
    goto ldv_54503;
  } else {

  }
#line 631
  op = op + 1;
  ldv_54507: ;
#line 631
  if ((unsigned int )op_class[op].op_class != 0U) {
#line 633
    goto ldv_54506;
  } else {

  }
#line 658
  channel_list->reg_classes = (size_t )cla;
#line 659
  return;
}
}
#line 661 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static u8 init_channel_set(struct rtw_adapter *padapter , u8 cplan , struct rt_channel_info *c_set ) 
{ 
  u8 i ;
  u8 ch_size ;
  u8 b5GBand ;
  u8 b2_4GBand ;
  u8 Index2G ;
  u8 Index5G ;

  {
#line 664
  ch_size = 0U;
#line 665
  b5GBand = 0U;
#line 665
  b2_4GBand = 0U;
#line 666
  Index2G = 0U;
#line 666
  Index5G = 0U;
#line 668
  memset((void *)c_set, 0, 304UL);
#line 670
  if ((unsigned int )cplan > 65U && (unsigned int )cplan != 127U) {
#line 672
    if (GlobalDebugLevel23A > 3U) {
#line 672
      printk("\016RTL8723AU: ChannelPlan ID %x error !!!!!\n", (int )cplan);
    } else {

    }
#line 673
    return (ch_size);
  } else {

  }
#line 676
  if (((int )padapter->registrypriv.wireless_mode & 2) != 0) {
#line 677
    b2_4GBand = 1U;
#line 678
    if ((unsigned int )cplan == 127U) {
#line 679
      Index2G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index2G;
    } else {
#line 681
      Index2G = RTW_ChannelPlanMap[(int )cplan].Index2G;
    }
  } else {

  }
#line 684
  if (((int )padapter->registrypriv.wireless_mode & 4) != 0) {
#line 685
    b5GBand = 1U;
#line 686
    if ((unsigned int )cplan == 127U) {
#line 687
      Index5G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index5G;
    } else {
#line 689
      Index5G = RTW_ChannelPlanMap[(int )cplan].Index5G;
    }
  } else {

  }
#line 692
  if ((unsigned int )b2_4GBand != 0U) {
#line 693
    i = 0U;
#line 693
    goto ldv_54521;
    ldv_54520: 
#line 694
    (c_set + (unsigned long )ch_size)->ChannelNum = RTW_ChannelPlan2G[(int )Index2G].Channel[(int )i];
#line 697
    if ((unsigned int )cplan == 9U || (unsigned int )cplan == 65U) {
#line 700
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum != 0U && (unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 11U) {
#line 702
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      } else
#line 703
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum > 11U && (unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 14U) {
#line 705
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      } else {

      }
    } else
#line 706
    if (((unsigned int )cplan == 10U || (unsigned int )cplan == 19U) || (unsigned int )Index2G == 0U) {
#line 710
      if ((unsigned int )(c_set + (unsigned long )ch_size)->ChannelNum <= 11U) {
#line 711
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      } else {
#line 713
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      }
    } else {
#line 715
      (c_set + (unsigned long )ch_size)->ScanType = 1;
    }
#line 717
    ch_size = (u8 )((int )ch_size + 1);
#line 693
    i = (u8 )((int )i + 1);
    ldv_54521: ;
#line 693
    if ((int )RTW_ChannelPlan2G[(int )Index2G].Len > (int )i) {
#line 695
      goto ldv_54520;
    } else {

    }

  } else {

  }
#line 721
  if ((unsigned int )b5GBand != 0U) {
#line 722
    i = 0U;
#line 722
    goto ldv_54525;
    ldv_54524: ;
#line 723
    if ((unsigned int )RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i] <= 48U || (unsigned int )RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i] > 148U) {
#line 725
      (c_set + (unsigned long )ch_size)->ChannelNum = RTW_ChannelPlan5G[(int )Index5G].Channel[(int )i];
#line 727
      if ((unsigned int )cplan == 19U) {
#line 729
        (c_set + (unsigned long )ch_size)->ScanType = 0;
      } else {
#line 732
        (c_set + (unsigned long )ch_size)->ScanType = 1;
      }
#line 734
      if (GlobalDebugLevel23A > 3U) {
#line 734
        printk("\016RTL8723AU: %s(): channel_set[%d].ChannelNum = %d\n", "init_channel_set",
               (int )ch_size, (int )(c_set + (unsigned long )ch_size)->ChannelNum);
      } else {

      }
#line 737
      ch_size = (u8 )((int )ch_size + 1);
    } else {

    }
#line 722
    i = (u8 )((int )i + 1);
    ldv_54525: ;
#line 722
    if ((int )RTW_ChannelPlan5G[(int )Index5G].Len > (int )i) {
#line 724
      goto ldv_54524;
    } else {

    }

  } else {

  }
#line 742
  return (ch_size);
}
}
#line 745 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int init_mlme_ext_priv23a(struct rtw_adapter *padapter ) 
{ 
  int res ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 747
  res = 1;
#line 748
  pregistrypriv = & padapter->registrypriv;
#line 749
  pmlmeext = & padapter->mlmeextpriv;
#line 750
  pmlmepriv = & padapter->mlmepriv;
#line 751
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 753
  pmlmeext->padapter = padapter;
#line 755
  init_mlme_ext_priv23a_value(padapter);
#line 756
  pmlmeinfo->bAcceptAddbaReq = pregistrypriv->bAcceptAddbaReq;
#line 758
  init_mlme_ext_timer23a(padapter);
#line 761
  init_mlme_ap_info23a(padapter);
#line 764
  pmlmeext->max_chan_nums = init_channel_set(padapter, (int )pmlmepriv->ChannelPlan,
                                             (struct rt_channel_info *)(& pmlmeext->channel_set));
#line 767
  init_channel_list(padapter, (struct rt_channel_info *)(& pmlmeext->channel_set),
                    (int )pmlmeext->max_chan_nums, & pmlmeext->channel_list);
#line 770
  pmlmeext->chan_scan_time = 100U;
#line 771
  pmlmeext->mlmeext_init = 1U;
#line 773
  pmlmeext->active_keep_alive_check = 1U;
#line 774
  return (res);
}
}
#line 777 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void free_mlme_ext_priv23a(struct mlme_ext_priv *pmlmeext ) 
{ 
  struct rtw_adapter *padapter ;

  {
#line 779
  padapter = pmlmeext->padapter;
#line 781
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 782
    return;
  } else {

  }
#line 784
  if (padapter->bDriverStopped == 1) {
#line 785
    ldv_del_timer_sync_533(& pmlmeext->survey_timer);
#line 786
    ldv_del_timer_sync_534(& pmlmeext->link_timer);
  } else {

  }
#line 788
  return;
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void _mgt_dispatcher23a(struct rtw_adapter *padapter , struct mlme_handler *ptable ,
                               struct recv_frame *precv_frame ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 795
  skb = precv_frame->pkt;
#line 796
  hdr = (struct ieee80211_hdr *)skb->data;
#line 798
  if ((unsigned long )ptable->func != (unsigned long )((int (*)(struct rtw_adapter * ,
                                                                struct recv_frame * ))0)) {
#line 801
    tmp = myid(& padapter->eeprompriv);
#line 801
    tmp___0 = ether_addr_equal((u8 const   *)(& hdr->addr1), (u8 const   *)tmp);
#line 801
    if (tmp___0) {
#line 801
      tmp___1 = 0;
    } else {
#line 801
      tmp___1 = 1;
    }
#line 801
    if (tmp___1) {
#line 801
      tmp___2 = is_broadcast_ether_addr((u8 const   *)(& hdr->addr1));
#line 801
      if (tmp___2) {
#line 801
        tmp___3 = 0;
      } else {
#line 801
        tmp___3 = 1;
      }
#line 801
      if (tmp___3) {
#line 803
        return;
      } else {

      }
    } else {

    }
#line 805
    (*(ptable->func))(padapter, precv_frame);
  } else {

  }
#line 807
  return;
}
}
#line 809 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void mgt_dispatcher23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct mlme_handler *ptable ;
  struct mlme_priv *pmlmepriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct sta_info *psta ;
  u16 stype ;
  int index ;
  int tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;

  {
#line 814
  pmlmepriv = & padapter->mlmepriv;
#line 816
  skb = precv_frame->pkt;
#line 817
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 822
  tmp = ieee80211_is_mgmt((int )mgmt->frame_control);
#line 822
  if (tmp == 0) {
#line 823
    return;
  } else {

  }
#line 827
  tmp___0 = myid(& padapter->eeprompriv);
#line 827
  tmp___1 = ether_addr_equal((u8 const   *)(& mgmt->da), (u8 const   *)tmp___0);
#line 827
  if (tmp___1) {
#line 827
    tmp___2 = 0;
  } else {
#line 827
    tmp___2 = 1;
  }
#line 827
  if (tmp___2) {
#line 827
    tmp___3 = is_broadcast_ether_addr((u8 const   *)(& mgmt->da));
#line 827
    if (tmp___3) {
#line 827
      tmp___4 = 0;
    } else {
#line 827
      tmp___4 = 1;
    }
#line 827
    if (tmp___4) {
#line 829
      return;
    } else {

    }
  } else {

  }
#line 831
  ptable = (struct mlme_handler *)(& mlme_sta_tbl);
#line 833
  stype = (unsigned int )mgmt->frame_control & 240U;
#line 834
  index = (int )stype >> 4;
#line 836
  if (index > 13) {
#line 837
    if (GlobalDebugLevel23A > 3U) {
#line 837
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 837
      printk("\016Currently we do not support reserved sub-fr-type =%d\n", index);
    } else {

    }
#line 840
    return;
  } else {

  }
#line 842
  ptable = ptable + (unsigned long )index;
#line 844
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& mgmt->sa));
#line 846
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 847
    tmp___5 = ieee80211_has_retry((int )mgmt->frame_control);
#line 847
    if (tmp___5 != 0) {
#line 848
      if ((int )precv_frame->attrib.seq_num == (int )psta->RxMgmtFrameSeqNum) {
#line 851
        if (GlobalDebugLevel23A > 3U) {
#line 851
          printk("\016RTL8723AU: Drop duplicate management frame with seq_num = %d.\n",
                 (int )precv_frame->attrib.seq_num);
        } else {

        }
#line 854
        return;
      } else {

      }
    } else {

    }
#line 857
    psta->RxMgmtFrameSeqNum = precv_frame->attrib.seq_num;
  } else {

  }
#line 861
  switch ((int )stype) {
  case 176: 
#line 864
  tmp___6 = check_fwstate(pmlmepriv, 16);
#line 864
  if ((int )tmp___6) {
#line 865
    ptable->func = & OnAuth23a;
  } else {
#line 867
    ptable->func = & OnAuth23aClient23a;
  }
  case 0: ;
  case 32: 
#line 871
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
#line 872
  goto ldv_54560;
  case 64: 
#line 874
  tmp___7 = check_fwstate(pmlmepriv, 16);
#line 874
  if ((int )tmp___7) {
#line 875
    _mgt_dispatcher23a(padapter, ptable, precv_frame);
  } else {
#line 877
    _mgt_dispatcher23a(padapter, ptable, precv_frame);
  }
#line 878
  goto ldv_54560;
  case 128: 
#line 880
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
#line 881
  goto ldv_54560;
  case 208: 
#line 884
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
#line 885
  goto ldv_54560;
  default: 
#line 887
  _mgt_dispatcher23a(padapter, ptable, precv_frame);
#line 888
  goto ldv_54560;
  }
  ldv_54560: ;
#line 894
  return;
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnProbeReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u8 const   *ie ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  int len ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
#line 905
  pmlmepriv = & padapter->mlmepriv;
#line 906
  pmlmeext = & padapter->mlmeextpriv;
#line 907
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 908
  cur = & pmlmeinfo->network;
#line 909
  skb = precv_frame->pkt;
#line 910
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 911
  len = (int )skb->len;
#line 913
  tmp = check_fwstate(pmlmepriv, 8);
#line 913
  if ((int )tmp) {
#line 914
    return (1);
  } else {

  }
#line 916
  tmp___0 = check_fwstate(pmlmepriv, 1);
#line 916
  if (tmp___0) {
#line 916
    tmp___1 = 0;
  } else {
#line 916
    tmp___1 = 1;
  }
#line 916
  if (tmp___1) {
#line 916
    tmp___2 = check_fwstate(pmlmepriv, 80);
#line 916
    if (tmp___2) {
#line 916
      tmp___3 = 0;
    } else {
#line 916
      tmp___3 = 1;
    }
#line 916
    if (tmp___3) {
#line 919
      return (1);
    } else {

    }
  } else {

  }
#line 921
  tmp___4 = ieee80211_is_probe_req((int )mgmt->frame_control);
#line 921
  tmp___5 = ldv__builtin_expect(tmp___4 == 0, 0L);
#line 921
  if (tmp___5 != 0L) {
#line 922
    printk("\f%s: Received non probe request frame\n", "OnProbeReq23a");
#line 924
    return (0);
  } else {

  }
#line 927
  len = (int )((unsigned int )len - 24U);
#line 929
  ie = cfg80211_find_ie(0, (u8 const   *)(& mgmt->u.probe_req.variable), len);
#line 932
  if ((unsigned long )ie == (unsigned long )((u8 const   *)0U)) {
#line 933
    goto out;
  } else {

  }
#line 935
  if ((unsigned int )((unsigned char )*(ie + 1UL)) != 0U) {
#line 935
    tmp___6 = memcmp((void const   *)ie + 2U, (void const   *)(& cur->Ssid.ssid),
                     (size_t )cur->Ssid.ssid_len);
#line 935
    if (tmp___6 != 0) {
#line 937
      return (1);
    } else {
#line 935
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 935
  if ((unsigned int )((unsigned char )*(ie + 1UL)) == 0U && (unsigned int )pmlmeinfo->hidden_ssid_mode != 0U) {
#line 937
    return (1);
  } else {

  }
#line 940
  tmp___7 = check_fwstate(pmlmepriv, 1);
#line 940
  if ((int )tmp___7 && pmlmepriv->cur_network.join_res != 0) {
#line 942
    issue_probersp(padapter, (unsigned char *)(& mgmt->sa), 0);
  } else {

  }
  out: ;
#line 945
  return (1);
}
}
#line 949 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnProbeRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 951
  pmlmeext = & padapter->mlmeextpriv;
#line 953
  if (pmlmeext->sitesurvey_res.state == 3) {
#line 954
    report_survey_event23a(padapter, precv_frame);
#line 955
    return (1);
  } else {

  }
#line 958
  return (1);
}
}
#line 962 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnBeacon23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  int cam_idx ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *pframe ;
  int pkt_len ;
  struct wlan_bssid_ex *pbss ;
  int ret ;
  u8 *p ;
  u8 *pie ;
  int pie_len ;
  u32 ielen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 966
  pmlmeext = & padapter->mlmeextpriv;
#line 967
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 968
  pmlmepriv = & padapter->mlmepriv;
#line 969
  pstapriv = & padapter->stapriv;
#line 970
  skb = precv_frame->pkt;
#line 971
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 972
  pframe = skb->data;
#line 973
  pkt_len = (int )skb->len;
#line 975
  ret = 1;
#line 978
  ielen = 0U;
#line 980
  pie = (u8 *)(& mgmt->u.beacon.variable);
#line 981
  pie_len = (int )((unsigned int )pkt_len - 36U);
#line 982
  p = rtw_get_ie23a(pie, 50, (int *)(& ielen), pie_len);
#line 983
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ielen != 0U) {
#line 984
    if ((unsigned int )*(p + (unsigned long )(ielen + 1U)) == 45U && (unsigned int )*(p + (unsigned long )(ielen + 2U)) != 45U) {
#line 989
      if (GlobalDebugLevel23A > 3U) {
#line 989
        printk("\016RTL8723AU: [WIFIDBG] Error in ESR IE is detected in Beacon of BSSID: %pM. Fix the length of ESR IE to avoid failed Beacon parsing.\n",
               (u8 *)(& mgmt->bssid));
      } else {

      }
#line 993
      *(p + 1UL) = (unsigned int )((u8 )ielen) - 1U;
    } else {

    }
  } else {

  }
#line 997
  if (pmlmeext->sitesurvey_res.state == 3) {
#line 998
    report_survey_event23a(padapter, precv_frame);
#line 999
    return (1);
  } else {

  }
#line 1002
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 1002
  tmp___0 = ether_addr_equal((u8 const   *)(& mgmt->bssid), (u8 const   *)tmp);
#line 1002
  if (tmp___0) {
#line 1002
    tmp___1 = 0;
  } else {
#line 1002
    tmp___1 = 1;
  }
#line 1002
  if (tmp___1) {
#line 1004
    goto out;
  } else {

  }
#line 1006
  if ((pmlmeinfo->state & 256U) != 0U) {
#line 1009
    tmp___2 = kmalloc(863UL, 32U);
#line 1009
    pbss = (struct wlan_bssid_ex *)tmp___2;
#line 1011
    if ((unsigned long )pbss != (unsigned long )((struct wlan_bssid_ex *)0)) {
#line 1012
      tmp___3 = collect_bss_info23a(padapter, precv_frame, pbss);
#line 1012
      if (tmp___3 == 1) {
#line 1014
        update_network23a(& pmlmepriv->cur_network.network, pbss, padapter, 1);
#line 1017
        rtw_get_bcn_info23a(& pmlmepriv->cur_network);
      } else {

      }
#line 1019
      kfree((void const   *)pbss);
    } else {

    }
#line 1023
    pmlmeinfo->assoc_AP_vendor = check_assoc_AP23a((u8 *)(& mgmt->u.beacon), (uint )pkt_len - 24U);
#line 1028
    rtw_update_TSF(pmlmeext, mgmt);
#line 1031
    start_clnt_auth(padapter);
#line 1033
    return (1);
  } else {

  }
#line 1036
  if ((pmlmeinfo->state & 3U) == 2U && (pmlmeinfo->state & 16384U) != 0U) {
#line 1038
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 1039
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1040
      ret = rtw_check_bcn_info23a(padapter, mgmt, (u32 )pkt_len);
#line 1041
      if (ret == 0) {
#line 1042
        if (GlobalDebugLevel23A != 0U) {
#line 1042
          printk("\016RTL8723AU: OLD_ERROR ap has changed, disconnect now\n");
        } else {

        }
#line 1044
        receive_disconnect23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress),
                              65535);
#line 1045
        return (1);
      } else {

      }
#line 1050
      if ((((psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) & 15ULL) == 0ULL) {
#line 1052
        update_beacon23a_info(padapter, pframe, (uint )pkt_len, psta);
      } else {

      }
    } else {

    }
  } else
#line 1056
  if ((pmlmeinfo->state & 3U) == 1U) {
#line 1057
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 1058
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1062
      if ((((psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) & 15ULL) == 0ULL) {
#line 1064
        update_beacon23a_info(padapter, pframe, (uint )pkt_len, psta);
      } else {

      }
    } else {
#line 1069
      cam_idx = allocate_fw_sta_entry23a(padapter);
#line 1070
      if (cam_idx == 32) {
#line 1071
        goto out;
      } else {

      }
#line 1074
      tmp___4 = update_sta_support_rate23a(padapter, pie, (uint )pie_len, cam_idx);
#line 1074
      if (tmp___4 == 0) {
#line 1076
        pmlmeinfo->FW_sta_info[cam_idx].status = 0U;
#line 1077
        goto out;
      } else {

      }
#line 1081
      rtw_update_TSF(pmlmeext, mgmt);
#line 1084
      report_add_sta_event23a(padapter, (unsigned char *)(& mgmt->sa), cam_idx);
    }
  } else {

  }
  out: ;
#line 1091
  return (1);
}
}
#line 1096 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sta_info stat ;
  struct sta_info *pstat ;
  struct sta_priv *pstapriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *pframe ;
  u8 const   *p ;
  unsigned char *sa ;
  u16 auth_mode ;
  u16 seq ;
  u16 algorithm ;
  int status ;
  int len ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __len ;
  void *__ret ;

  {
#line 1099
  pstat = (struct sta_info *)0;
#line 1100
  pstapriv = & padapter->stapriv;
#line 1101
  psecuritypriv = & padapter->securitypriv;
#line 1102
  pmlmeext = & padapter->mlmeextpriv;
#line 1103
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1104
  skb = precv_frame->pkt;
#line 1105
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 1110
  len = (int )skb->len;
#line 1112
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 1113
    return (0);
  } else {

  }
#line 1115
  if (GlobalDebugLevel23A > 3U) {
#line 1115
    printk("\016RTL8723AU: +OnAuth23a\n");
  } else {

  }
#line 1117
  sa = (unsigned char *)(& mgmt->sa);
#line 1119
  auth_mode = (u16 )psecuritypriv->dot11AuthAlgrthm;
#line 1121
  pframe = (u8 *)(& mgmt->u.auth.variable);
#line 1122
  len = (int )(skb->len - 30U);
#line 1124
  seq = mgmt->u.auth.auth_transaction;
#line 1125
  algorithm = mgmt->u.auth.auth_alg;
#line 1127
  if (GlobalDebugLevel23A > 3U) {
#line 1127
    printk("\016RTL8723AU: auth alg =%x, seq =%X\n", (int )algorithm, (int )seq);
  } else {

  }
#line 1129
  if (((unsigned int )auth_mode == 2U && psecuritypriv->dot11PrivacyAlgrthm != 1027073U) && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
#line 1132
    auth_mode = 0U;
  } else {

  }
#line 1136
  if (((unsigned int )algorithm != 0U && (unsigned int )auth_mode == 0U) || ((unsigned int )algorithm == 0U && (unsigned int )auth_mode == 1U)) {
#line 1138
    if (GlobalDebugLevel23A > 3U) {
#line 1138
      printk("\016RTL8723AU: auth rejected due to bad alg [alg =%d, auth_mib =%d] %02X%02X%02X%02X%02X%02X\n",
             (int )algorithm, (int )auth_mode, (int )*sa, (int )*(sa + 1UL), (int )*(sa + 2UL),
             (int )*(sa + 3UL), (int )*(sa + 4UL), (int )*(sa + 5UL));
    } else {

    }
#line 1143
    status = 13;
#line 1145
    goto auth_fail;
  } else {

  }
#line 1148
  tmp = rtw_access_ctrl23a(padapter, sa);
#line 1148
  if (tmp) {
#line 1148
    tmp___0 = 0;
  } else {
#line 1148
    tmp___0 = 1;
  }
#line 1148
  if (tmp___0) {
#line 1149
    status = 17;
#line 1150
    goto auth_fail;
  } else {

  }
#line 1153
  pstat = rtw_get_stainfo23a(pstapriv, (u8 const   *)sa);
#line 1154
  if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
#line 1156
    if (GlobalDebugLevel23A > 3U) {
#line 1156
      printk("\016RTL8723AU: going to alloc stainfo for sa =%02x:%02x:%02x:%02x:%02x:%02x\n",
             (int )*sa, (int )*(sa + 1UL), (int )*(sa + 2UL), (int )*(sa + 3UL), (int )*(sa + 4UL),
             (int )*(sa + 5UL));
    } else {

    }
#line 1158
    pstat = rtw_alloc_stainfo23a(pstapriv, sa, 32U);
#line 1159
    if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
#line 1160
      if (GlobalDebugLevel23A > 3U) {
#line 1160
        printk("\016RTL8723AU:  Exceed the upper limit of supported clients...\n");
      } else {

      }
#line 1162
      status = 17;
#line 1163
      goto auth_fail;
    } else {

    }
#line 1166
    pstat->state = 256U;
#line 1167
    pstat->auth_seq = 0U;
  } else {
#line 1172
    spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1173
    tmp___1 = list_empty((struct list_head  const  *)(& pstat->asoc_list));
#line 1173
    if (tmp___1 == 0) {
#line 1174
      list_del_init(& pstat->asoc_list);
#line 1175
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
    } else {

    }
#line 1180
    spin_unlock_bh(& pstapriv->asoc_list_lock);
  }
#line 1187
  spin_lock_bh(& pstapriv->auth_list_lock);
#line 1188
  tmp___2 = list_empty((struct list_head  const  *)(& pstat->auth_list));
#line 1188
  if (tmp___2 != 0) {
#line 1189
    list_add_tail(& pstat->auth_list, & pstapriv->auth_list);
#line 1190
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt + 1);
  } else {

  }
#line 1192
  spin_unlock_bh(& pstapriv->auth_list_lock);
#line 1194
  if (pstat->auth_seq == 0U) {
#line 1195
    pstat->expire_to = pstapriv->auth_to;
  } else {

  }
#line 1197
  if (pstat->auth_seq + 1U != (unsigned int )seq) {
#line 1198
    if (GlobalDebugLevel23A > 3U) {
#line 1198
      printk("\016RTL8723AU: (1)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
             (int )seq, pstat->auth_seq + 1U);
    } else {

    }
#line 1200
    status = 14;
#line 1201
    goto auth_fail;
  } else {

  }
#line 1204
  if ((unsigned int )algorithm == 0U && ((unsigned int )auth_mode == 0U || (unsigned int )auth_mode == 2U)) {
#line 1205
    if ((unsigned int )seq == 1U) {
#line 1206
      pstat->state = pstat->state & 4294967039U;
#line 1207
      pstat->state = pstat->state | 1024U;
#line 1208
      pstat->expire_to = pstapriv->assoc_to;
#line 1209
      pstat->authalg = (unsigned int )algorithm;
    } else {
#line 1211
      if (GlobalDebugLevel23A > 3U) {
#line 1211
        printk("\016RTL8723AU: (2)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
               (int )seq, pstat->auth_seq + 1U);
      } else {

      }
#line 1214
      status = 14;
#line 1215
      goto auth_fail;
    }
  } else
#line 1218
  if ((unsigned int )seq == 1U) {
#line 1220
    pstat->state = pstat->state & 4294967039U;
#line 1221
    pstat->state = pstat->state | 512U;
#line 1222
    pstat->authalg = (unsigned int )algorithm;
#line 1223
    pstat->auth_seq = 2U;
  } else
#line 1224
  if ((unsigned int )seq == 3U) {
#line 1226
    if (GlobalDebugLevel23A > 3U) {
#line 1226
      printk("\016RTL8723AU: checking for challenging txt...\n");
    } else {

    }
#line 1228
    p = cfg80211_find_ie(16, (u8 const   *)pframe, len);
#line 1229
    if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
#line 1230
      if (GlobalDebugLevel23A > 3U) {
#line 1230
        printk("\016RTL8723AU: auth rejected because challenge failure!(1)\n");
      } else {

      }
#line 1232
      status = 15;
#line 1233
      goto auth_fail;
    } else {

    }
#line 1236
    tmp___3 = memcmp((void const   *)p + 2U, (void const   *)(& pstat->chg_txt), 128UL);
#line 1236
    if (tmp___3 == 0) {
#line 1237
      pstat->state = pstat->state & 4294966783U;
#line 1238
      pstat->state = pstat->state | 1024U;
#line 1240
      pstat->expire_to = pstapriv->assoc_to;
    } else {
#line 1242
      if (GlobalDebugLevel23A > 3U) {
#line 1242
        printk("\016RTL8723AU: auth rejected because challenge failure!\n");
      } else {

      }
#line 1244
      status = 15;
#line 1245
      goto auth_fail;
    }
  } else {
#line 1248
    if (GlobalDebugLevel23A > 3U) {
#line 1248
      printk("\016RTL8723AU: (3)auth rejected because out of seq [rx_seq =%d, exp_seq =%d]!\n",
             (int )seq, pstat->auth_seq + 1U);
    } else {

    }
#line 1251
    status = 14;
#line 1252
    goto auth_fail;
  }
#line 1257
  pstat->auth_seq = (unsigned int )((int )seq + 1);
#line 1259
  issue_auth(padapter, pstat, 0);
#line 1261
  if ((pstat->state & 1024U) != 0U) {
#line 1262
    pstat->auth_seq = 0U;
  } else {

  }
#line 1264
  return (1);
  auth_fail: ;
#line 1268
  if ((unsigned long )pstat != (unsigned long )((struct sta_info *)0)) {
#line 1269
    rtw_free_stainfo23a(padapter, pstat);
  } else {

  }
#line 1271
  pstat = & stat;
#line 1272
  memset((void *)pstat, 0, 5656UL);
#line 1273
  pstat->auth_seq = 2U;
#line 1274
  __len = 6UL;
#line 1274
  if (__len > 63UL) {
#line 1274
    __ret = __memcpy((void *)(& pstat->hwaddr), (void const   *)sa, __len);
  } else {
#line 1274
    __ret = __builtin_memcpy((void *)(& pstat->hwaddr), (void const   *)sa, __len);
  }
#line 1276
  issue_auth(padapter, pstat, (int )((unsigned short )status));
#line 1278
  return (0);
}
}
#line 1283 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAuth23aClient23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned int seq ;
  unsigned int status ;
  unsigned int algthm ;
  unsigned int go2asoc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 const   *p ;
  u8 *pie ;
  int plen ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  size_t __len ;
  void *__ret ;
  unsigned long tmp___3 ;

  {
#line 1286
  go2asoc = 0U;
#line 1287
  pmlmeext = & padapter->mlmeextpriv;
#line 1288
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1289
  skb = precv_frame->pkt;
#line 1290
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 1293
  plen = (int )skb->len;
#line 1295
  if (GlobalDebugLevel23A > 3U) {
#line 1295
    printk("\016RTL8723AU: %s\n", "OnAuth23aClient23a");
  } else {

  }
#line 1298
  tmp = myid(& padapter->eeprompriv);
#line 1298
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& mgmt->da));
#line 1298
  if (tmp___0) {
#line 1298
    tmp___1 = 0;
  } else {
#line 1298
    tmp___1 = 1;
  }
#line 1298
  if (tmp___1) {
#line 1299
    return (1);
  } else {

  }
#line 1301
  if ((pmlmeinfo->state & 512U) == 0U) {
#line 1302
    return (1);
  } else {

  }
#line 1304
  pie = (u8 *)(& mgmt->u.auth.variable);
#line 1305
  plen = (int )((unsigned int )plen - 30U);
#line 1307
  algthm = (unsigned int )mgmt->u.auth.auth_alg;
#line 1308
  seq = (unsigned int )mgmt->u.auth.auth_transaction;
#line 1309
  status = (unsigned int )mgmt->u.auth.status_code;
#line 1311
  if (status != 0U) {
#line 1312
    if (GlobalDebugLevel23A > 3U) {
#line 1312
      printk("\016RTL8723AU: clnt auth fail, status: %d\n", status);
    } else {

    }
#line 1314
    if (status == 13U) {
#line 1315
      if (pmlmeinfo->auth_algo == 1U) {
#line 1316
        pmlmeinfo->auth_algo = 0U;
      } else {
#line 1318
        pmlmeinfo->auth_algo = 1U;
      }
    } else {

    }
#line 1322
    tmp___2 = msecs_to_jiffies(1U);
#line 1322
    ldv_mod_timer_535(& pmlmeext->link_timer, tmp___2 + (unsigned long )jiffies);
#line 1323
    goto authclnt_fail;
  } else {

  }
#line 1326
  if (seq == 2U) {
#line 1327
    if (pmlmeinfo->auth_algo == 1U) {
#line 1329
      p = cfg80211_find_ie(16, (u8 const   *)pie, plen);
#line 1331
      if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 1333
        goto authclnt_fail;
      } else {

      }
#line 1336
      __len = (size_t )*(p + 1UL);
#line 1336
      __ret = __builtin_memcpy((void *)(& pmlmeinfo->chg_txt), (void const   *)p + 2U,
                               __len);
#line 1337
      pmlmeinfo->auth_seq = 3U;
#line 1338
      issue_auth(padapter, (struct sta_info *)0, 0);
#line 1339
      tmp___3 = msecs_to_jiffies(300U);
#line 1339
      ldv_mod_timer_536(& pmlmeext->link_timer, tmp___3 + (unsigned long )jiffies);
#line 1341
      return (1);
    } else {
#line 1344
      go2asoc = 1U;
    }
  } else
#line 1346
  if (seq == 4U) {
#line 1347
    if (pmlmeinfo->auth_algo == 1U) {
#line 1348
      go2asoc = 1U;
    } else {
#line 1350
      goto authclnt_fail;
    }
  } else {
#line 1355
    goto authclnt_fail;
  }
#line 1358
  if (go2asoc != 0U) {
#line 1359
    if (GlobalDebugLevel23A != 0U) {
#line 1359
      printk("\016RTL8723AU: OLD_ERROR auth success, start assoc\n");
    } else {

    }
#line 1360
    start_clnt_assoc(padapter);
#line 1361
    return (1);
  } else {

  }
  authclnt_fail: ;
#line 1368
  return (0);
}
}
#line 1372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int rtw_validate_vendor_specific_ies(u8 const   *pos , int elen ) 
{ 
  unsigned int oui ;

  {
#line 1379
  if (elen <= 3) {
#line 1380
    if (GlobalDebugLevel23A > 3U) {
#line 1380
      printk("\016RTL8723AU: short vendor specific information element ignored (len =%i)\n",
             elen);
    } else {

    }
#line 1382
    return (-22);
  } else {

  }
#line 1385
  oui = (((unsigned int )*pos << 16) | ((unsigned int )*(pos + 1UL) << 8)) | (unsigned int )*(pos + 2UL);
#line 1386
  switch (oui) {
  case 20722U: ;
#line 1390
  switch ((int )*(pos + 3UL)) {
  case 1: ;
#line 1394
  goto ldv_54656;
  case 2: ;
#line 1396
  if (elen <= 4) {
#line 1397
    if (GlobalDebugLevel23A > 3U) {
#line 1397
      printk("\016RTL8723AU: short WME information element ignored (len =%i)\n", elen);
    } else {

    }
#line 1399
    return (-22);
  } else {

  }
#line 1401
  switch ((int )*(pos + 4UL)) {
  case 0: ;
  case 1: ;
#line 1404
  goto ldv_54660;
  case 2: ;
#line 1406
  goto ldv_54660;
  default: ;
#line 1408
  if (GlobalDebugLevel23A > 3U) {
#line 1408
    printk("\016RTL8723AU: unknown WME information element ignored (subtype =%d len =%i)\n",
           (int )*(pos + 4UL), elen);
  } else {

  }
#line 1411
  return (-22);
  }
  ldv_54660: ;
#line 1413
  goto ldv_54656;
  case 4: ;
#line 1416
  goto ldv_54656;
  default: ;
#line 1418
  if (GlobalDebugLevel23A > 3U) {
#line 1418
    printk("\016RTL8723AU: Unknown Microsoft information element ignored (type =%d len =%i)\n",
           (int )*(pos + 3UL), elen);
  } else {

  }
#line 1421
  return (-22);
  }
  ldv_54656: ;
#line 1423
  goto ldv_54665;
  case 36940U: ;
#line 1426
  switch ((int )*(pos + 3UL)) {
  case 51: ;
#line 1428
  goto ldv_54668;
  default: ;
#line 1430
  if (GlobalDebugLevel23A > 3U) {
#line 1430
    printk("\016RTL8723AU: Unknown Broadcom information element ignored (type =%d len =%i)\n",
           (int )*(pos + 3UL), elen);
  } else {

  }
#line 1432
  return (-22);
  }
  ldv_54668: ;
#line 1434
  goto ldv_54665;
  default: ;
#line 1437
  if (GlobalDebugLevel23A > 3U) {
#line 1437
    printk("\016RTL8723AU: unknown vendor specific information element ignored (vendor OUI %02x:%02x:%02x len =%i)\n",
           (int )*pos, (int )*(pos + 1UL), (int )*(pos + 2UL), elen);
  } else {

  }
#line 1440
  return (-22);
  }
  ldv_54665: ;
#line 1443
  return (0);
}
}
#line 1446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int rtw_validate_frame_ies(u8 const   *start , uint len ) 
{ 
  u8 const   *pos ;
  int left ;
  int unknown ;
  u8 id ;
  u8 elen ;
  u8 const   *tmp ;
  u8 const   *tmp___0 ;
  int tmp___1 ;

  {
#line 1448
  pos = start;
#line 1449
  left = (int )len;
#line 1450
  unknown = 0;
#line 1452
  goto ldv_54703;
  ldv_54702: 
#line 1455
  tmp = pos;
#line 1455
  pos = pos + 1;
#line 1455
  id = *tmp;
#line 1456
  tmp___0 = pos;
#line 1456
  pos = pos + 1;
#line 1456
  elen = *tmp___0;
#line 1457
  left = left + -2;
#line 1459
  if ((int )elen > left) {
#line 1460
    if (GlobalDebugLevel23A > 3U) {
#line 1460
      printk("\016RTL8723AU: %s: IEEE 802.11 failed (id =%d elen =%d left =%i)\n",
             "rtw_validate_frame_ies", (int )id, (int )elen, left);
    } else {

    }
#line 1462
    return (-22);
  } else {

  }
#line 1465
  switch ((int )id) {
  case 0: ;
  case 1: ;
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: ;
  case 6: ;
  case 16: ;
  case 42: ;
  case 50: ;
  case 221: 
#line 1477
  tmp___1 = rtw_validate_vendor_specific_ies(pos, (int )elen);
#line 1477
  if (tmp___1 != 0) {
#line 1478
    unknown = unknown + 1;
  } else {

  }
#line 1479
  goto ldv_54692;
  case 48: ;
  case 33: ;
  case 36: ;
  case 54: ;
  case 55: ;
  case 56: ;
  case 45: ;
  case 61: ;
  default: 
#line 1489
  unknown = unknown + 1;
#line 1490
  if (GlobalDebugLevel23A > 3U) {
#line 1490
    printk("\016RTL8723AU: %s IEEE 802.11 ignored unknown element (id =%d elen =%d)\n",
           "rtw_validate_frame_ies", (int )id, (int )elen);
  } else {

  }
#line 1492
  goto ldv_54692;
  }
  ldv_54692: 
#line 1495
  left = left - (int )elen;
#line 1496
  pos = pos + (unsigned long )elen;
  ldv_54703: ;
#line 1452
  if (left > 1) {
#line 1454
    goto ldv_54702;
  } else {

  }

#line 1499
  if (left != 0) {
#line 1500
    return (-22);
  } else {

  }
#line 1502
  return (0);
}
}
#line 1507 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAssocReq23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u16 capab_info ;
  u16 listen_interval ;
  struct sta_info *pstat ;
  unsigned char reassoc ;
  unsigned char WMM_IE[6U] ;
  int i ;
  int wpa_ie_len ;
  int left ;
  unsigned char supportRate[16U] ;
  int supportRateNum ;
  unsigned short status ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 const   *pos ;
  u8 const   *p ;
  u8 const   *wpa_ie ;
  u8 const   *wps_ie ;
  u8 *pframe ;
  uint pkt_len ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  int group_cipher ;
  int pairwise_cipher ;
  u8 selected_registrar ;
  int copy_len ;
  size_t __len___2 ;
  void *__ret___2 ;
  u8 const   *end ;
  int tmp___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1513
  WMM_IE[0] = 0U;
#line 1513
  WMM_IE[1] = 80U;
#line 1513
  WMM_IE[2] = 242U;
#line 1513
  WMM_IE[3] = 2U;
#line 1513
  WMM_IE[4] = 0U;
#line 1513
  WMM_IE[5] = 1U;
#line 1517
  status = 0U;
#line 1518
  pmlmepriv = & padapter->mlmepriv;
#line 1519
  psecuritypriv = & padapter->securitypriv;
#line 1520
  pmlmeext = & padapter->mlmeextpriv;
#line 1521
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1522
  cur = & pmlmeinfo->network;
#line 1523
  pstapriv = & padapter->stapriv;
#line 1524
  skb = precv_frame->pkt;
#line 1525
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 1527
  pframe = skb->data;
#line 1528
  pkt_len = skb->len;
#line 1531
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 1532
    return (0);
  } else {

  }
#line 1534
  left = (int )(pkt_len - 24U);
#line 1535
  tmp = ieee80211_is_assoc_req((int )mgmt->frame_control);
#line 1535
  if (tmp != 0) {
#line 1536
    reassoc = 0U;
#line 1537
    pos = (u8 const   *)(& mgmt->u.assoc_req.variable);
#line 1538
    left = (int )((unsigned int )left - 28U);
  } else {
#line 1540
    reassoc = 1U;
#line 1541
    pos = (u8 const   *)(& mgmt->u.reassoc_req.variable);
#line 1542
    left = (int )((unsigned int )left - 34U);
  }
#line 1545
  if (left < 0) {
#line 1546
    if (GlobalDebugLevel23A > 3U) {
#line 1546
      printk("\016RTL8723AU: handle_assoc(reassoc =%d) - too short payload (len =%lu)\n",
             (int )reassoc, (unsigned long )pkt_len);
    } else {

    }
#line 1548
    return (0);
  } else {

  }
#line 1551
  pstat = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 1552
  if ((unsigned long )pstat == (unsigned long )((struct sta_info *)0)) {
#line 1553
    status = 6U;
#line 1554
    goto asoc_class2_error;
  } else {

  }
#line 1559
  capab_info = get_unaligned_le16((void const   *)(& mgmt->u.assoc_req.capab_info));
#line 1560
  listen_interval = get_unaligned_le16((void const   *)(& mgmt->u.assoc_req.listen_interval));
#line 1563
  if (GlobalDebugLevel23A > 3U) {
#line 1563
    printk("\016RTL8723AU: %s\n", "OnAssocReq23a");
  } else {

  }
#line 1566
  if ((pstat->state & 1024U) == 0U) {
#line 1567
    if ((pstat->state & 16384U) == 0U) {
#line 1568
      status = 6U;
#line 1569
      goto asoc_class2_error;
    } else {
#line 1571
      pstat->state = pstat->state & 4294950911U;
#line 1572
      pstat->state = pstat->state | 8192U;
    }
  } else {
#line 1575
    pstat->state = pstat->state & 4294966271U;
#line 1576
    pstat->state = pstat->state | 8192U;
  }
#line 1579
  pstat->capability = capab_info;
#line 1583
  tmp___0 = rtw_validate_frame_ies(pos, (uint )left);
#line 1583
  if (tmp___0 != 0) {
#line 1584
    if (GlobalDebugLevel23A > 3U) {
#line 1584
      printk("\016RTL8723AU: STA %02x:%02x:%02x:%02x:%02x:%02x sent invalid association request\n",
             (int )*((u8 *)(& pstat->hwaddr)), (int )*((u8 *)(& pstat->hwaddr) + 1UL),
             (int )*((u8 *)(& pstat->hwaddr) + 2UL), (int )*((u8 *)(& pstat->hwaddr) + 3UL),
             (int )*((u8 *)(& pstat->hwaddr) + 4UL), (int )*((u8 *)(& pstat->hwaddr) + 5UL));
    } else {

    }
#line 1586
    status = 1U;
#line 1587
    goto OnAssocReq23aFail;
  } else {

  }
#line 1592
  p = cfg80211_find_ie(0, pos, left);
#line 1593
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
#line 1595
    if (GlobalDebugLevel23A > 3U) {
#line 1595
      printk("\016RTL8723AU: STA %02x:%02x:%02x:%02x:%02x:%02x sent invalid association request lacking an SSID\n",
             (int )*((u8 *)(& pstat->hwaddr)), (int )*((u8 *)(& pstat->hwaddr) + 1UL),
             (int )*((u8 *)(& pstat->hwaddr) + 2UL), (int )*((u8 *)(& pstat->hwaddr) + 3UL),
             (int )*((u8 *)(& pstat->hwaddr) + 4UL), (int )*((u8 *)(& pstat->hwaddr) + 5UL));
    } else {

    }
#line 1597
    status = 1U;
#line 1598
    goto OnAssocReq23aFail;
  } else {
#line 1601
    tmp___1 = memcmp((void const   *)p + 2U, (void const   *)(& cur->Ssid.ssid), (size_t )cur->Ssid.ssid_len);
#line 1601
    if (tmp___1 != 0) {
#line 1602
      status = 1U;
    } else {

    }
#line 1604
    if ((int )((unsigned char )*(p + 1UL)) != (int )cur->Ssid.ssid_len) {
#line 1605
      status = 1U;
    } else {

    }
  }
#line 1608
  if ((unsigned int )status != 0U) {
#line 1609
    goto OnAssocReq23aFail;
  } else {

  }
#line 1612
  p = cfg80211_find_ie(1, pos, left);
#line 1613
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 1614
    if (GlobalDebugLevel23A > 3U) {
#line 1614
      printk("\016RTL8723AU: Rx a sta assoc-req which supported rate is empty!\n");
    } else {

    }
#line 1620
    status = 1U;
#line 1621
    goto OnAssocReq23aFail;
  } else {
#line 1623
    __len = (size_t )*(p + 1UL);
#line 1623
    __ret = __builtin_memcpy((void *)(& supportRate), (void const   *)p + 2U, __len);
#line 1624
    supportRateNum = (int )*(p + 1UL);
#line 1626
    p = cfg80211_find_ie(50, pos, left);
#line 1627
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 1628
      if ((unsigned int )supportRateNum <= 16U) {
#line 1629
        __len___0 = (size_t )*(p + 1UL);
#line 1629
        __ret___0 = __builtin_memcpy((void *)(& supportRate) + (unsigned long )supportRateNum,
                                     (void const   *)p + 2U, __len___0);
#line 1630
        supportRateNum = (int )*(p + 1UL) + supportRateNum;
      } else {

      }
    } else {

    }
  }
#line 1639
  pstat->bssratelen = (u32 )supportRateNum;
#line 1640
  __len___1 = (size_t )supportRateNum;
#line 1640
  __ret___1 = __builtin_memcpy((void *)(& pstat->bssrateset), (void const   *)(& supportRate),
                               __len___1);
#line 1641
  Update23aTblForSoftAP((u8 *)(& pstat->bssrateset), pstat->bssratelen);
#line 1644
  pstat->dot8021xalg = 0;
#line 1645
  pstat->wpa_psk = 0;
#line 1646
  pstat->wpa_group_cipher = 0;
#line 1647
  pstat->wpa2_group_cipher = 0;
#line 1648
  pstat->wpa_pairwise_cipher = 0;
#line 1649
  pstat->wpa2_pairwise_cipher = 0;
#line 1650
  memset((void *)(& pstat->wpa_ie), 0, 32UL);
#line 1652
  wpa_ie = cfg80211_find_ie(48, pos, left);
#line 1653
  if ((unsigned long )wpa_ie == (unsigned long )((u8 const   *)0U)) {
#line 1654
    wpa_ie = cfg80211_find_vendor_ie(20722U, 1, pos, left);
  } else {

  }
#line 1657
  if ((unsigned long )wpa_ie != (unsigned long )((u8 const   *)0U)) {
#line 1658
    group_cipher = 0;
#line 1658
    pairwise_cipher = 0;
#line 1660
    wpa_ie_len = (int )*(wpa_ie + 1UL);
#line 1661
    if (((unsigned long )psecuritypriv->wpa_psk & 2UL) != 0UL) {
#line 1662
      r = rtw_parse_wpa2_ie23a(wpa_ie, wpa_ie_len + 2, & group_cipher, & pairwise_cipher,
                               (int *)0);
#line 1665
      if (r == 1) {
#line 1666
        pstat->dot8021xalg = 1;
#line 1667
        pstat->wpa_psk = pstat->wpa_psk | 2;
#line 1669
        pstat->wpa2_group_cipher = (int )(psecuritypriv->wpa2_group_cipher & (unsigned int )group_cipher);
#line 1671
        pstat->wpa2_pairwise_cipher = (int )(psecuritypriv->wpa2_pairwise_cipher & (unsigned int )pairwise_cipher);
      } else {
#line 1674
        status = 40U;
      }
    } else
#line 1675
    if ((int )psecuritypriv->wpa_psk & 1) {
#line 1676
      r = rtw_parse_wpa_ie23a(wpa_ie, wpa_ie_len + 2, & group_cipher, & pairwise_cipher,
                              (int *)0);
#line 1679
      if (r == 1) {
#line 1680
        pstat->dot8021xalg = 1;
#line 1681
        pstat->wpa_psk = pstat->wpa_psk | 1;
#line 1683
        pstat->wpa_group_cipher = (int )(psecuritypriv->wpa_group_cipher & (unsigned int )group_cipher);
#line 1685
        pstat->wpa_pairwise_cipher = (int )(psecuritypriv->wpa_pairwise_cipher & (unsigned int )pairwise_cipher);
      } else {
#line 1688
        status = 40U;
      }
    } else {
#line 1690
      wpa_ie = (u8 const   *)0U;
#line 1691
      wpa_ie_len = 0;
    }
#line 1693
    if ((unsigned long )wpa_ie != (unsigned long )((u8 const   *)0U) && (unsigned int )status == 0U) {
#line 1694
      if (pstat->wpa_group_cipher == 0) {
#line 1695
        status = 41U;
      } else {

      }
#line 1697
      if (pstat->wpa_pairwise_cipher == 0) {
#line 1698
        status = 42U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1702
  if ((unsigned int )status != 0U) {
#line 1703
    goto OnAssocReq23aFail;
  } else {

  }
#line 1705
  pstat->flags = pstat->flags & -12289;
#line 1707
  wps_ie = cfg80211_find_vendor_ie(20722U, 4, pos, left);
#line 1711
  if ((unsigned long )wpa_ie == (unsigned long )((u8 const   *)0U)) {
#line 1712
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U)) {
#line 1713
      if (GlobalDebugLevel23A > 3U) {
#line 1713
        printk("\016RTL8723AU: STA included WPS IE in (Re)Association Request - assume WPS is used\n");
      } else {

      }
#line 1715
      pstat->flags = pstat->flags | 4096;
    } else {
#line 1717
      if (GlobalDebugLevel23A > 3U) {
#line 1717
        printk("\016RTL8723AU: STA did not include WPA/RSN IE in (Re)Association Request - possible WPS use\n");
      } else {

      }
#line 1719
      pstat->flags = pstat->flags | 8192;
    }
#line 1725
    if (psecuritypriv->wpa_psk != 0U && ((unsigned long )pstat->flags & 12288UL) != 0UL) {
#line 1727
      if ((unsigned long )pmlmepriv->wps_beacon_ie != (unsigned long )((u8 *)0U)) {
#line 1728
        selected_registrar = 0U;
#line 1730
        rtw_get_wps_attr_content23a(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len,
                                    4161, & selected_registrar, (uint *)0U);
#line 1736
        if ((unsigned int )selected_registrar == 0U) {
#line 1737
          if (GlobalDebugLevel23A > 3U) {
#line 1737
            printk("\016RTL8723AU: selected_registrar is false,or AP is not ready to do WPS\n");
          } else {

          }
#line 1741
          status = 17U;
#line 1742
          goto OnAssocReq23aFail;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {
#line 1749
    if (psecuritypriv->wpa_psk == 0U) {
#line 1750
      if (GlobalDebugLevel23A > 3U) {
#line 1750
        printk("\016RTL8723AU: STA %02x:%02x:%02x:%02x:%02x:%02x: WPA/RSN IE in association request, but AP don\'t support WPA/RSN\n",
               (int )*((u8 *)(& pstat->hwaddr)), (int )*((u8 *)(& pstat->hwaddr) + 1UL),
               (int )*((u8 *)(& pstat->hwaddr) + 2UL), (int )*((u8 *)(& pstat->hwaddr) + 3UL),
               (int )*((u8 *)(& pstat->hwaddr) + 4UL), (int )*((u8 *)(& pstat->hwaddr) + 5UL));
      } else {

      }
#line 1754
      status = 40U;
#line 1756
      goto OnAssocReq23aFail;
    } else {

    }
#line 1759
    if ((unsigned long )wps_ie != (unsigned long )((u8 const   *)0U)) {
#line 1760
      if (GlobalDebugLevel23A > 3U) {
#line 1760
        printk("\016RTL8723AU: STA included WPS IE in (Re)Association Request - WPS is used\n");
      } else {

      }
#line 1762
      pstat->flags = pstat->flags | 4096;
#line 1763
      copy_len = 0;
    } else {
#line 1765
      copy_len = (int )(32U < (unsigned int )(wpa_ie_len + 2) ? 32U : (unsigned int )(wpa_ie_len + 2));
    }
#line 1769
    if (copy_len > 0) {
#line 1770
      __len___2 = (size_t )copy_len;
#line 1770
      __ret___2 = __builtin_memcpy((void *)(& pstat->wpa_ie), (void const   *)wpa_ie + 0xfffffffffffffffeUL,
                                   __len___2);
    } else {

    }
  }
#line 1774
  pstat->flags = pstat->flags & -513;
#line 1775
  pstat->qos_option = 0U;
#line 1776
  pstat->qos_info = 0U;
#line 1777
  pstat->has_legacy_ac = 1U;
#line 1778
  pstat->uapsd_vo = 0U;
#line 1779
  pstat->uapsd_vi = 0U;
#line 1780
  pstat->uapsd_be = 0U;
#line 1781
  pstat->uapsd_bk = 0U;
#line 1782
  if (pmlmepriv->qos_option != 0U) {
#line 1783
    end = pos + (unsigned long )left;
#line 1784
    p = pos;
    ldv_54756: 
#line 1787
    left = (int )((unsigned int )((long )end) - (unsigned int )((long )p));
#line 1788
    p = cfg80211_find_ie(221, p, left);
#line 1789
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 1790
      tmp___2 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_IE), 6UL);
#line 1790
      if (tmp___2 == 0) {
#line 1791
        pstat->flags = pstat->flags | 512;
#line 1793
        pstat->qos_option = 1U;
#line 1794
        pstat->qos_info = *(p + 8UL);
#line 1796
        pstat->max_sp_len = (unsigned int )((u8 )((int )pstat->qos_info >> 5)) & 3U;
#line 1799
        if (((int )pstat->qos_info & 15) != 15) {
#line 1800
          pstat->has_legacy_ac = 1U;
        } else {
#line 1802
          pstat->has_legacy_ac = 0U;
        }
#line 1804
        if (((int )pstat->qos_info & 15) != 0) {
#line 1805
          if ((int )pstat->qos_info & 1) {
#line 1806
            pstat->uapsd_vo = 3U;
          } else {
#line 1808
            pstat->uapsd_vo = 0U;
          }
#line 1810
          if (((unsigned long )pstat->qos_info & 2UL) != 0UL) {
#line 1811
            pstat->uapsd_vi = 3U;
          } else {
#line 1813
            pstat->uapsd_vi = 0U;
          }
#line 1815
          if (((unsigned long )pstat->qos_info & 4UL) != 0UL) {
#line 1816
            pstat->uapsd_bk = 3U;
          } else {
#line 1818
            pstat->uapsd_bk = 0U;
          }
#line 1820
          if (((unsigned long )pstat->qos_info & 8UL) != 0UL) {
#line 1821
            pstat->uapsd_be = 3U;
          } else {
#line 1823
            pstat->uapsd_be = 0U;
          }
        } else {

        }
#line 1827
        goto ldv_54755;
      } else {

      }
    } else {
#line 1830
      goto ldv_54755;
    }
#line 1832
    p = p + ((unsigned long )*(p + 1UL) + 2UL);
#line 1833
    goto ldv_54756;
    ldv_54755: ;
  } else {

  }
#line 1837
  memset((void *)(& pstat->htpriv.ht_cap), 0, 26UL);
#line 1838
  p = cfg80211_find_ie(45, pos, left);
#line 1840
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) > 25U) {
#line 1841
    pstat->flags = pstat->flags | 2048;
#line 1843
    pstat->flags = pstat->flags | 512;
#line 1845
    __len___3 = 26UL;
#line 1845
    if (__len___3 > 63UL) {
#line 1845
      __ret___3 = __memcpy((void *)(& pstat->htpriv.ht_cap), (void const   *)p + 2U,
                           __len___3);
    } else {
#line 1845
      __ret___3 = __builtin_memcpy((void *)(& pstat->htpriv.ht_cap), (void const   *)p + 2U,
                                   __len___3);
    }
  } else {
#line 1848
    pstat->flags = pstat->flags & -2049;
  }
#line 1850
  if (pmlmepriv->htpriv.ht_option == 0U && ((unsigned long )pstat->flags & 2048UL) != 0UL) {
#line 1851
    status = 1U;
#line 1852
    goto OnAssocReq23aFail;
  } else {

  }
#line 1855
  if (((unsigned long )pstat->flags & 2048UL) != 0UL && (((unsigned long )pstat->wpa2_pairwise_cipher & 8UL) != 0UL || ((unsigned long )pstat->wpa_pairwise_cipher & 8UL) != 0UL)) {
#line 1858
    if (GlobalDebugLevel23A > 3U) {
#line 1858
      printk("\016RTL8723AU: HT: %02x:%02x:%02x:%02x:%02x:%02x tried to use TKIP with HT association\n",
             (int )*((u8 *)(& pstat->hwaddr)), (int )*((u8 *)(& pstat->hwaddr) + 1UL),
             (int )*((u8 *)(& pstat->hwaddr) + 2UL), (int )*((u8 *)(& pstat->hwaddr) + 3UL),
             (int )*((u8 *)(& pstat->hwaddr) + 4UL), (int )*((u8 *)(& pstat->hwaddr) + 5UL));
    } else {

    }
  } else {

  }
#line 1865
  pstat->flags = (int )((unsigned int )pstat->flags | 2147483648U);
#line 1866
  i = 0;
#line 1866
  goto ldv_54762;
  ldv_54761: ;
#line 1867
  if (((int )pstat->bssrateset[i] & 127) > 22) {
#line 1868
    pstat->flags = pstat->flags & 2147483647;
#line 1869
    goto ldv_54760;
  } else {

  }
#line 1866
  i = i + 1;
  ldv_54762: ;
#line 1866
  if ((u32 )i < pstat->bssratelen) {
#line 1868
    goto ldv_54761;
  } else {

  }
  ldv_54760: ;
#line 1873
  if (((int )pstat->capability & 32) != 0) {
#line 1874
    pstat->flags = pstat->flags | 128;
  } else {
#line 1876
    pstat->flags = pstat->flags & -129;
  }
#line 1878
  if ((unsigned int )status != 0U) {
#line 1879
    goto OnAssocReq23aFail;
  } else {

  }
#line 1888
  if (pstat->aid != 0U) {
#line 1889
    if (GlobalDebugLevel23A > 3U) {
#line 1889
      printk("\016RTL8723AU:   old AID %d\n", pstat->aid);
    } else {

    }
  } else {
#line 1891
    pstat->aid = 1U;
#line 1891
    goto ldv_54765;
    ldv_54764: ;
#line 1892
    if ((unsigned long )pstapriv->sta_aid[pstat->aid - 1U] == (unsigned long )((struct sta_info *)0)) {
#line 1893
      goto ldv_54763;
    } else {

    }
#line 1891
    pstat->aid = pstat->aid + 1U;
    ldv_54765: ;
#line 1891
    if (pstat->aid <= 32U) {
#line 1893
      goto ldv_54764;
    } else {

    }
    ldv_54763: ;
#line 1895
    if (pstat->aid > 32U) {
#line 1896
      pstat->aid = 32U;
    } else {

    }
#line 1897
    if (pstat->aid > (uint )pstapriv->max_num_sta) {
#line 1899
      pstat->aid = 0U;
#line 1901
      if (GlobalDebugLevel23A > 3U) {
#line 1901
        printk("\016RTL8723AU:   no room for more AIDs\n");
      } else {

      }
#line 1903
      status = 17U;
#line 1905
      goto OnAssocReq23aFail;
    } else {
#line 1907
      pstapriv->sta_aid[pstat->aid - 1U] = pstat;
#line 1908
      if (GlobalDebugLevel23A > 3U) {
#line 1908
        printk("\016RTL8723AU: allocate new AID = (%d)\n", pstat->aid);
      } else {

      }
    }
  }
#line 1912
  pstat->state = pstat->state & 4294959103U;
#line 1913
  pstat->state = pstat->state | 16384U;
#line 1915
  spin_lock_bh(& pstapriv->auth_list_lock);
#line 1916
  tmp___3 = list_empty((struct list_head  const  *)(& pstat->auth_list));
#line 1916
  if (tmp___3 == 0) {
#line 1917
    list_del_init(& pstat->auth_list);
#line 1918
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
  } else {

  }
#line 1920
  spin_unlock_bh(& pstapriv->auth_list_lock);
#line 1922
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1923
  tmp___4 = list_empty((struct list_head  const  *)(& pstat->asoc_list));
#line 1923
  if (tmp___4 != 0) {
#line 1924
    pstat->expire_to = pstapriv->expire_to;
#line 1925
    list_add_tail(& pstat->asoc_list, & pstapriv->asoc_list);
#line 1926
    pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt + 1);
  } else {

  }
#line 1928
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 1931
  if (((unsigned long )pstat != (unsigned long )((struct sta_info *)0) && (pstat->state & 16384U) != 0U) && (unsigned int )status == 0U) {
#line 1935
    bss_cap_update_on_sta_join23a(padapter, pstat);
#line 1936
    sta_info_update23a(padapter, pstat);
#line 1939
    tmp___5 = ieee80211_is_assoc_req((int )mgmt->frame_control);
#line 1939
    if (tmp___5 != 0) {
#line 1940
      issue_assocrsp(padapter, (int )status, pstat, 16);
    } else {
#line 1943
      issue_assocrsp(padapter, (int )status, pstat, 48);
    }
#line 1947
    if (GlobalDebugLevel23A > 3U) {
#line 1947
      printk("\016RTL8723AU: indicate_sta_join_event to upper layer - hostapd\n");
    } else {

    }
#line 1948
    rtw_cfg80211_indicate_sta_assoc(padapter, pframe, pkt_len);
#line 1951
    report_add_sta_event23a(padapter, (unsigned char *)(& pstat->hwaddr), (int )pstat->aid);
  } else {

  }
#line 1955
  return (1);
  asoc_class2_error: 
#line 1960
  issue_deauth23a(padapter, (unsigned char *)(& mgmt->sa), (int )status);
#line 1962
  return (0);
  OnAssocReq23aFail: 
#line 1967
  pstat->aid = 0U;
#line 1968
  tmp___6 = ieee80211_is_assoc_req((int )mgmt->frame_control);
#line 1968
  if (tmp___6 != 0) {
#line 1969
    issue_assocrsp(padapter, (int )status, pstat, 16);
  } else {
#line 1972
    issue_assocrsp(padapter, (int )status, pstat, 48);
  }
#line 1978
  return (0);
}
}
#line 1982 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAssocRsp23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *pmgmt ;
  int res ;
  int i ;
  unsigned short status ;
  u8 *p ;
  u8 *pframe ;
  int pkt_len ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u16 tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t __len ;
  void *__ret ;

  {
#line 1984
  pmlmepriv = & padapter->mlmepriv;
#line 1985
  pmlmeext = & padapter->mlmeextpriv;
#line 1986
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1987
  skb = precv_frame->pkt;
#line 1988
  pmgmt = (struct ieee80211_mgmt *)skb->data;
#line 1992
  pframe = skb->data;
#line 1993
  pkt_len = (int )skb->len;
#line 1995
  if (GlobalDebugLevel23A > 3U) {
#line 1995
    printk("\016RTL8723AU: %s\n", "OnAssocRsp23a");
  } else {

  }
#line 1998
  tmp = myid(& padapter->eeprompriv);
#line 1998
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& pmgmt->da));
#line 1998
  if (tmp___0) {
#line 1998
    tmp___1 = 0;
  } else {
#line 1998
    tmp___1 = 1;
  }
#line 1998
  if (tmp___1) {
#line 1999
    return (1);
  } else {

  }
#line 2001
  if ((pmlmeinfo->state & 9216U) == 0U) {
#line 2002
    return (1);
  } else {

  }
#line 2004
  if ((pmlmeinfo->state & 16384U) != 0U) {
#line 2005
    return (1);
  } else {

  }
#line 2007
  ldv_del_timer_sync_537(& pmlmeext->link_timer);
#line 2010
  status = pmgmt->u.assoc_resp.status_code;
#line 2011
  if ((unsigned int )status != 0U) {
#line 2012
    if (GlobalDebugLevel23A > 3U) {
#line 2012
      printk("\016RTL8723AU: assoc reject, status code: %d\n", (int )status);
    } else {

    }
#line 2013
    pmlmeinfo->state = 0U;
#line 2014
    res = -4;
#line 2015
    goto report_assoc_result;
  } else {

  }
#line 2019
  pmlmeinfo->capability = pmgmt->u.assoc_resp.capab_info;
#line 2022
  pmlmeinfo->slotTime = ((unsigned long )pmlmeinfo->capability & 1024UL) != 0UL ? 9U : 20U;
#line 2025
  tmp___2 = (unsigned int )pmgmt->u.assoc_resp.aid & 16383U;
#line 2025
  pmlmeinfo->aid = tmp___2;
#line 2025
  res = (int )tmp___2;
#line 2030
  i = 30;
#line 2030
  goto ldv_54790;
  ldv_54789: 
#line 2032
  p = pframe + (unsigned long )i;
#line 2034
  switch ((int )*p) {
  case 221: 
#line 2037
  tmp___3 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_PARA_OUI23A), 6UL);
#line 2037
  if (tmp___3 == 0) {
#line 2038
    WMM_param_handler23a(padapter, p);
  } else {

  }
#line 2039
  goto ldv_54784;
  case 45: 
#line 2042
  HT_caps_handler23a(padapter, p);
#line 2043
  goto ldv_54784;
  case 61: 
#line 2046
  HT_info_handler23a(padapter, p);
#line 2047
  goto ldv_54784;
  case 42: 
#line 2050
  ERP_IE_handler23a(padapter, p);
  default: ;
#line 2053
  goto ldv_54784;
  }
  ldv_54784: 
#line 2056
  i = ((int )*(p + 1UL) + 2) + i;
  ldv_54790: ;
#line 2030
  if (i < pkt_len) {
#line 2033
    goto ldv_54789;
  } else {

  }
#line 2059
  pmlmeinfo->state = pmlmeinfo->state & 4294959103U;
#line 2060
  pmlmeinfo->state = pmlmeinfo->state | 16384U;
#line 2063
  UpdateBrateTbl23a(padapter, (u8 *)(& pmlmeinfo->network.SupportedRates));
  report_assoc_result: 
#line 2066
  pmlmepriv->assoc_rsp_len = 0U;
#line 2067
  if (res > 0) {
#line 2068
    kfree((void const   *)pmlmepriv->assoc_rsp);
#line 2069
    tmp___4 = kmalloc((size_t )pkt_len, 32U);
#line 2069
    pmlmepriv->assoc_rsp = (u8 *)tmp___4;
#line 2070
    if ((unsigned long )pmlmepriv->assoc_rsp != (unsigned long )((u8 *)0U)) {
#line 2071
      __len = (size_t )pkt_len;
#line 2071
      __ret = __builtin_memcpy((void *)pmlmepriv->assoc_rsp, (void const   *)pframe,
                               __len);
#line 2072
      pmlmepriv->assoc_rsp_len = (u32 )pkt_len;
    } else {

    }
  } else {
#line 2075
    kfree((void const   *)pmlmepriv->assoc_rsp);
  }
#line 2077
  report_join_res23a(padapter, res);
#line 2079
  return (1);
}
}
#line 2083 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnDeAuth23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned short reason ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 updated ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 2086
  pmlmepriv = & padapter->mlmepriv;
#line 2087
  pmlmeext = & padapter->mlmeextpriv;
#line 2088
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2089
  skb = precv_frame->pkt;
#line 2090
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 2092
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 2092
  tmp___0 = ether_addr_equal((u8 const   *)(& mgmt->bssid), (u8 const   *)tmp);
#line 2092
  if (tmp___0) {
#line 2092
    tmp___1 = 0;
  } else {
#line 2092
    tmp___1 = 1;
  }
#line 2092
  if (tmp___1) {
#line 2094
    return (1);
  } else {

  }
#line 2096
  reason = mgmt->u.deauth.reason_code;
#line 2098
  if (GlobalDebugLevel23A > 3U) {
#line 2098
    printk("\016RTL8723AU: %s Reason code(%d)\n", "OnDeAuth23a", (int )reason);
  } else {

  }
#line 2101
  tmp___3 = check_fwstate(pmlmepriv, 16);
#line 2101
  if ((int )tmp___3) {
#line 2103
    pstapriv = & padapter->stapriv;
#line 2105
    if (GlobalDebugLevel23A != 0U) {
#line 2105
      printk("\016RTL8723AU: OLD_ERROR ap recv deauth reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->sa));
    } else {

    }
#line 2108
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 2109
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 2110
      updated = 0U;
#line 2112
      spin_lock_bh(& pstapriv->asoc_list_lock);
#line 2113
      tmp___2 = list_empty((struct list_head  const  *)(& psta->asoc_list));
#line 2113
      if (tmp___2 == 0) {
#line 2114
        list_del_init(& psta->asoc_list);
#line 2115
        pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 2116
        updated = ap_free_sta23a(padapter, psta, 0, (int )reason);
      } else {

      }
#line 2119
      spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 2121
      associated_clients_update23a(padapter, (int )updated);
    } else {

    }
#line 2124
    return (1);
  } else {
#line 2128
    if (GlobalDebugLevel23A != 0U) {
#line 2128
      printk("\016RTL8723AU: OLD_ERROR sta recv deauth reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->bssid));
    } else {

    }
#line 2131
    receive_disconnect23a(padapter, (unsigned char *)(& mgmt->bssid), (int )reason);
  }
#line 2133
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
#line 2135
  return (1);
}
}
#line 2139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnDisassoc23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned short reason ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 updated ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 2142
  pmlmepriv = & padapter->mlmepriv;
#line 2143
  pmlmeext = & padapter->mlmeextpriv;
#line 2144
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2145
  skb = precv_frame->pkt;
#line 2146
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 2148
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 2148
  tmp___0 = ether_addr_equal((u8 const   *)(& mgmt->bssid), (u8 const   *)tmp);
#line 2148
  if (tmp___0) {
#line 2148
    tmp___1 = 0;
  } else {
#line 2148
    tmp___1 = 1;
  }
#line 2148
  if (tmp___1) {
#line 2150
    return (1);
  } else {

  }
#line 2152
  reason = mgmt->u.disassoc.reason_code;
#line 2154
  if (GlobalDebugLevel23A > 3U) {
#line 2154
    printk("\016RTL8723AU: %s Reason code(%d)\n", "OnDisassoc23a", (int )reason);
  } else {

  }
#line 2157
  tmp___3 = check_fwstate(pmlmepriv, 16);
#line 2157
  if ((int )tmp___3) {
#line 2159
    pstapriv = & padapter->stapriv;
#line 2161
    if (GlobalDebugLevel23A != 0U) {
#line 2161
      printk("\016RTL8723AU: OLD_ERROR ap recv disassoc reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->sa));
    } else {

    }
#line 2164
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& mgmt->sa));
#line 2165
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 2166
      updated = 0U;
#line 2168
      spin_lock_bh(& pstapriv->asoc_list_lock);
#line 2169
      tmp___2 = list_empty((struct list_head  const  *)(& psta->asoc_list));
#line 2169
      if (tmp___2 == 0) {
#line 2170
        list_del_init(& psta->asoc_list);
#line 2171
        pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 2172
        updated = ap_free_sta23a(padapter, psta, 0, (int )reason);
      } else {

      }
#line 2175
      spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 2177
      associated_clients_update23a(padapter, (int )updated);
    } else {

    }
#line 2180
    return (1);
  } else {
#line 2184
    if (GlobalDebugLevel23A != 0U) {
#line 2184
      printk("\016RTL8723AU: OLD_ERROR ap recv disassoc reason code(%d) sta:%pM\n", (int )reason,
             (u8 *)(& mgmt->bssid));
    } else {

    }
#line 2187
    receive_disconnect23a(padapter, (unsigned char *)(& mgmt->bssid), (int )reason);
  }
#line 2189
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
#line 2190
  return (1);
}
}
#line 2194 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAtim23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2196
  if (GlobalDebugLevel23A > 3U) {
#line 2196
    printk("\016RTL8723AU: %s\n", "OnAtim23a");
  } else {

  }
#line 2197
  return (1);
}
}
#line 2201 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int on_action_spct23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2203
  return (0);
}
}
#line 2207 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAction23a_qos(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2209
  return (1);
}
}
#line 2213 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAction23a_dls(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2215
  return (1);
}
}
#line 2218 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAction23a_back23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u8 *addr ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  unsigned char category ;
  unsigned char action ;
  unsigned short tid ;
  unsigned short status ;
  unsigned short capab ;
  unsigned short params ;
  unsigned short reason_code ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  struct sta_priv *pstapriv ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 2222
  psta = (struct sta_info *)0;
#line 2225
  reason_code = 0U;
#line 2226
  pmlmeext = & padapter->mlmeextpriv;
#line 2227
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2228
  skb = precv_frame->pkt;
#line 2229
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 2230
  pstapriv = & padapter->stapriv;
#line 2233
  tmp = myid(& padapter->eeprompriv);
#line 2233
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& mgmt->da));
#line 2233
  if (tmp___0) {
#line 2233
    tmp___1 = 0;
  } else {
#line 2233
    tmp___1 = 1;
  }
#line 2233
  if (tmp___1) {
#line 2234
    return (1);
  } else {

  }
#line 2236
  if (GlobalDebugLevel23A > 3U) {
#line 2236
    printk("\016RTL8723AU: %s\n", "OnAction23a_back23a");
  } else {

  }
#line 2238
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 2239
    if ((pmlmeinfo->state & 16384U) == 0U) {
#line 2240
      return (1);
    } else {

    }
  } else {

  }
#line 2242
  addr = (u8 *)(& mgmt->sa);
#line 2243
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)addr);
#line 2245
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 2246
    return (1);
  } else {

  }
#line 2248
  category = mgmt->u.action.category;
#line 2249
  if ((unsigned int )category == 3U) {
#line 2250
    if ((unsigned int )pmlmeinfo->HT_enable == 0U) {
#line 2251
      return (1);
    } else {

    }
#line 2254
    action = mgmt->u.action.u.wme_action.action_code;
#line 2255
    if (GlobalDebugLevel23A > 3U) {
#line 2255
      printk("\016RTL8723AU: %s, action =%d\n", "OnAction23a_back23a", (int )action);
    } else {

    }
#line 2256
    switch ((int )action) {
    case 0: 
#line 2258
    __len = 7UL;
#line 2258
    if (__len > 63UL) {
#line 2258
      __ret = __memcpy((void *)(& pmlmeinfo->ADDBA_req), (void const   *)(& mgmt->u.action.u.addba_req.dialog_token),
                       __len);
    } else {
#line 2258
      __ret = __builtin_memcpy((void *)(& pmlmeinfo->ADDBA_req), (void const   *)(& mgmt->u.action.u.addba_req.dialog_token),
                               __len);
    }
#line 2261
    process_addba_req23a(padapter, (u8 *)(& pmlmeinfo->ADDBA_req), addr);
#line 2263
    if ((int )pmlmeinfo->bAcceptAddbaReq) {
#line 2264
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 1, 0);
    } else {
#line 2268
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 1, 37);
    }
#line 2271
    goto ldv_54864;
    case 1: 
#line 2273
    status = get_unaligned_le16((void const   *)(& mgmt->u.action.u.addba_resp.status));
#line 2275
    capab = get_unaligned_le16((void const   *)(& mgmt->u.action.u.addba_resp.capab));
#line 2277
    tid = (unsigned short )(((int )capab & 60) >> 2);
#line 2278
    if ((unsigned int )status == 0U) {
#line 2279
      if (GlobalDebugLevel23A > 3U) {
#line 2279
        printk("\016RTL8723AU: agg_enable for TID =%d\n", (int )tid);
      } else {

      }
#line 2280
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap | (int )((u16 )(1UL << (int )tid));
#line 2281
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    } else {
#line 2283
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    }
#line 2284
    goto ldv_54864;
    case 2: 
#line 2287
    params = get_unaligned_le16((void const   *)(& mgmt->u.action.u.delba.params));
#line 2289
    tid = (int )params >> 12;
#line 2291
    if (((int )params & 2048) != 0) {
#line 2292
      preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )tid;
#line 2293
      preorder_ctrl->enable = 0U;
#line 2294
      preorder_ctrl->indicate_seq = 65535U;
    } else {
#line 2296
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
#line 2297
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    }
#line 2299
    reason_code = get_unaligned_le16((void const   *)(& mgmt->u.action.u.delba.reason_code));
#line 2303
    goto ldv_54864;
    default: ;
#line 2305
    goto ldv_54864;
    }
    ldv_54864: ;
  } else {

  }
#line 2308
  return (1);
}
}
#line 2311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int rtw_action_public_decache(struct recv_frame *recv_frame , s32 token ) 
{ 
  struct rtw_adapter *adapter ;
  struct mlme_ext_priv *mlmeext ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u16 seq_ctrl ;
  int tmp ;

  {
#line 2313
  adapter = recv_frame->adapter;
#line 2314
  mlmeext = & adapter->mlmeextpriv;
#line 2315
  skb = recv_frame->pkt;
#line 2316
  hdr = (struct ieee80211_hdr *)skb->data;
#line 2319
  seq_ctrl = (u16 )((int )((short )((int )recv_frame->attrib.seq_num << 4)) | ((int )((short )recv_frame->attrib.frag_num) & 15));
#line 2322
  tmp = ieee80211_has_retry((int )hdr->frame_control);
#line 2322
  if (tmp != 0) {
#line 2323
    if (token >= 0) {
#line 2324
      if ((int )mlmeext->action_public_rxseq == (int )seq_ctrl && (int )mlmeext->action_public_dialog_token == token) {
#line 2326
        if (GlobalDebugLevel23A > 3U) {
#line 2326
          printk("\016RTL8723AU: %s(%s): seq_ctrl = 0x%x, rxseq = 0x%x, token:%d\n",
                 "rtw_action_public_decache", (char *)(& (adapter->pnetdev)->name),
                 (int )seq_ctrl, (int )mlmeext->action_public_rxseq, token);
        } else {

        }
#line 2330
        return (0);
      } else {

      }
    } else
#line 2333
    if ((int )mlmeext->action_public_rxseq == (int )seq_ctrl) {
#line 2334
      if (GlobalDebugLevel23A > 3U) {
#line 2334
        printk("\016RTL8723AU: %s(%s): seq_ctrl = 0x%x, rxseq = 0x%x\n", "rtw_action_public_decache",
               (char *)(& (adapter->pnetdev)->name), (int )seq_ctrl, (int )mlmeext->action_public_rxseq);
      } else {

      }
#line 2338
      return (0);
    } else {

    }
  } else {

  }
#line 2343
  mlmeext->action_public_rxseq = seq_ctrl;
#line 2345
  if (token >= 0) {
#line 2346
    mlmeext->action_public_dialog_token = (u8 )token;
  } else {

  }
#line 2348
  return (1);
}
}
#line 2351 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int on_action_public23a_p2p(struct recv_frame *precv_frame ) 
{ 
  struct sk_buff *skb ;
  u8 *pframe ;
  u8 *frame_body ;
  u8 dialogToken ;
  int tmp ;

  {
#line 2353
  skb = precv_frame->pkt;
#line 2354
  pframe = skb->data;
#line 2356
  dialogToken = 0U;
#line 2358
  frame_body = pframe + 24U;
#line 2361
  dialogToken = *(frame_body + 7UL);
#line 2363
  tmp = rtw_action_public_decache(precv_frame, (s32 )dialogToken);
#line 2363
  if (tmp == 0) {
#line 2364
    return (0);
  } else {

  }
#line 2366
  return (1);
}
}
#line 2369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int on_action_public23a_vendor(struct recv_frame *precv_frame ) 
{ 
  unsigned int ret ;
  struct sk_buff *skb ;
  u8 *pframe ;
  u8 *frame_body ;
  int tmp ;
  int tmp___0 ;

  {
#line 2371
  ret = 0U;
#line 2372
  skb = precv_frame->pkt;
#line 2373
  pframe = skb->data;
#line 2374
  frame_body = pframe + 24UL;
#line 2376
  tmp___0 = memcmp((void const   *)frame_body + 2U, (void const   *)(& P2P_OUI23A),
                   4UL);
#line 2376
  if (tmp___0 == 0) {
#line 2377
    tmp = on_action_public23a_p2p(precv_frame);
#line 2377
    ret = (unsigned int )tmp;
  } else {

  }
#line 2380
  return ((int )ret);
}
}
#line 2384 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static unsigned int on_action_public23a_default(struct recv_frame *precv_frame , u8 action ) 
{ 
  unsigned int ret ;
  struct sk_buff *skb ;
  u8 *pframe ;
  uint frame_len ;
  u8 *frame_body ;
  u8 token ;
  struct rtw_adapter *adapter ;
  int cnt ;
  char msg[64U] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 2386
  ret = 0U;
#line 2387
  skb = precv_frame->pkt;
#line 2388
  pframe = skb->data;
#line 2389
  frame_len = skb->len;
#line 2390
  frame_body = pframe + 24UL;
#line 2392
  adapter = precv_frame->adapter;
#line 2393
  cnt = 0;
#line 2396
  token = *(frame_body + 2UL);
#line 2398
  tmp = rtw_action_public_decache(precv_frame, (s32 )token);
#line 2398
  if (tmp == 0) {
#line 2399
    goto exit;
  } else {

  }
#line 2401
  tmp___0 = action_public_str23a((int )action);
#line 2401
  tmp___1 = sprintf((char *)(& msg) + (unsigned long )cnt, "%s(token:%u)", tmp___0,
                    (int )token);
#line 2401
  cnt = tmp___1 + cnt;
#line 2403
  rtw_cfg80211_rx_action(adapter, pframe, frame_len, (char const   *)(& msg));
#line 2405
  ret = 1U;
  exit: ;
#line 2408
  return (ret);
}
}
#line 2411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int on_action_public23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  int ret ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 *pframe ;
  u8 *frame_body ;
  u8 category ;
  u8 action ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 2414
  ret = 0;
#line 2415
  skb = precv_frame->pkt;
#line 2416
  hdr = (struct ieee80211_hdr *)skb->data;
#line 2417
  pframe = skb->data;
#line 2418
  frame_body = pframe + 24UL;
#line 2422
  tmp = myid(& padapter->eeprompriv);
#line 2422
  tmp___0 = ether_addr_equal((u8 const   *)tmp, (u8 const   *)(& hdr->addr1));
#line 2422
  if (tmp___0) {
#line 2422
    tmp___1 = 0;
  } else {
#line 2422
    tmp___1 = 1;
  }
#line 2422
  if (tmp___1) {
#line 2423
    goto exit;
  } else {

  }
#line 2425
  category = *frame_body;
#line 2426
  if ((unsigned int )category != 4U) {
#line 2427
    goto exit;
  } else {

  }
#line 2429
  action = *(frame_body + 1UL);
#line 2430
  switch ((int )action) {
  case 9: 
#line 2432
  ret = on_action_public23a_vendor(precv_frame);
#line 2433
  goto ldv_54919;
  default: 
#line 2435
  tmp___2 = on_action_public23a_default(precv_frame, (int )action);
#line 2435
  ret = (int )tmp___2;
#line 2436
  goto ldv_54919;
  }
  ldv_54919: ;
  exit: ;
#line 2440
  return (ret);
}
}
#line 2444 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAction23a_ht(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2446
  return (1);
}
}
#line 2450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAction23a_wmm(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2452
  return (1);
}
}
#line 2456 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAction23a_p2p(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2458
  return (1);
}
}
#line 2462 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int OnAction23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  int i ;
  u8 category ;
  struct action_handler *ptable ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;

  {
#line 2467
  skb = precv_frame->pkt;
#line 2468
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 2470
  category = mgmt->u.action.category;
#line 2472
  i = 0;
#line 2472
  goto ldv_54943;
  ldv_54942: 
#line 2474
  ptable = (struct action_handler *)(& OnAction23a_tbl) + (unsigned long )i;
#line 2476
  if ((unsigned int )category == ptable->num) {
#line 2477
    (*(ptable->func))(padapter, precv_frame);
  } else {

  }
#line 2473
  i = i + 1;
  ldv_54943: ;
#line 2472
  if ((unsigned int )i <= 8U) {
#line 2475
    goto ldv_54942;
  } else {

  }

#line 2480
  return (1);
}
}
#line 2483 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int DoReserved23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 


  {
#line 2486
  return (1);
}
}
#line 2489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
struct xmit_frame *alloc_mgtxmitframe23a(struct xmit_priv *pxmitpriv ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct xmit_buf *pxmitbuf ;

  {
#line 2494
  pmgntframe = rtw_alloc_xmitframe23a_ext(pxmitpriv);
#line 2496
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2497
    if (GlobalDebugLevel23A > 3U) {
#line 2497
      printk("\016RTL8723AU: %s(%s): alloc xmitframe fail\n", "alloc_mgtxmitframe23a",
             (char *)(& ((pxmitpriv->adapter)->pnetdev)->name));
    } else {

    }
#line 2499
    goto exit;
  } else {

  }
#line 2502
  pxmitbuf = rtw_alloc_xmitbuf23a_ext(pxmitpriv);
#line 2503
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 2504
    if (GlobalDebugLevel23A > 3U) {
#line 2504
      printk("\016RTL8723AU: %s(%s): alloc xmitbuf fail\n", "alloc_mgtxmitframe23a",
             (char *)(& ((pxmitpriv->adapter)->pnetdev)->name));
    } else {

    }
#line 2506
    rtw_free_xmitframe23a(pxmitpriv, pmgntframe);
#line 2507
    pmgntframe = (struct xmit_frame *)0;
#line 2508
    goto exit;
  } else {

  }
#line 2511
  pmgntframe->frame_tag = 3;
#line 2512
  pmgntframe->pxmitbuf = pxmitbuf;
#line 2513
  pmgntframe->buf_addr = pxmitbuf->pbuf;
#line 2514
  pxmitbuf->priv_data = (void *)pmgntframe;
  exit: ;
#line 2517
  return (pmgntframe);
}
}
#line 2526 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void update_mgnt_tx_rate23a(struct rtw_adapter *padapter , u8 rate ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 2528
  pmlmeext = & padapter->mlmeextpriv;
#line 2530
  pmlmeext->tx_rate = rate;
#line 2531
  if (GlobalDebugLevel23A > 3U) {
#line 2531
    printk("\016RTL8723AU: %s(): rate = %x\n", "update_mgnt_tx_rate23a", (int )rate);
  } else {

  }
#line 2532
  return;
}
}
#line 2534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void update_mgntframe_attrib23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 2537
  pmlmeext = & padapter->mlmeextpriv;
#line 2539
  memset((void *)pattrib, 0, 112UL);
#line 2541
  pattrib->hdrlen = 24U;
#line 2542
  pattrib->nr_frags = 1U;
#line 2543
  pattrib->priority = 7U;
#line 2544
  pattrib->mac_id = 0U;
#line 2545
  pattrib->qsel = 18U;
#line 2547
  pattrib->pktlen = 0U;
#line 2549
  if ((int )pmlmeext->cur_wireless_mode & 1) {
#line 2550
    pattrib->raid = 6U;
  } else {
#line 2552
    pattrib->raid = 5U;
  }
#line 2554
  pattrib->encrypt = 0U;
#line 2555
  pattrib->bswenc = 0U;
#line 2557
  pattrib->qos_en = 0U;
#line 2558
  pattrib->ht_en = 0U;
#line 2559
  pattrib->bwmode = 0U;
#line 2560
  pattrib->ch_offset = 0U;
#line 2561
  pattrib->sgi = 0U;
#line 2563
  pattrib->seqnum = pmlmeext->mgnt_seq;
#line 2565
  pattrib->retry_ctrl = 1U;
#line 2566
  return;
}
}
#line 2568 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void dump_mgntframe23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) 
{ 


  {
#line 2571
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
#line 2573
    return;
  } else {

  }
#line 2575
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 2576
  return;
}
}
#line 2578 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
s32 dump_mgntframe23a_and_wait(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ,
                               int timeout_ms ) 
{ 
  int ret ;
  unsigned long irqL ;
  struct xmit_priv *pxmitpriv ;
  struct xmit_buf *pxmitbuf ;
  struct submit_ctx sctx ;

  {
#line 2581
  ret = 0;
#line 2583
  pxmitpriv = & padapter->xmitpriv;
#line 2584
  pxmitbuf = pmgntframe->pxmitbuf;
#line 2587
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
#line 2589
    return (ret);
  } else {

  }
#line 2591
  rtw_sctx_init23a(& sctx, timeout_ms);
#line 2592
  pxmitbuf->sctx = & sctx;
#line 2594
  ret = rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 2596
  if (ret == 1) {
#line 2597
    ret = rtw_sctx_wait23a(& sctx);
  } else {

  }
#line 2599
  ldv_spin_lock();
#line 2600
  pxmitbuf->sctx = (struct submit_ctx *)0;
#line 2601
  spin_unlock_irqrestore(& pxmitpriv->lock_sctx, irqL);
#line 2603
  return (ret);
}
}
#line 2606 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
s32 dump_mgntframe23a_and_wait_ack23a(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) 
{ 
  int ret ;
  u32 timeout_ms ;
  struct xmit_priv *pxmitpriv ;
  int tmp ;

  {
#line 2609
  ret = 0;
#line 2610
  timeout_ms = 500U;
#line 2611
  pxmitpriv = & padapter->xmitpriv;
#line 2613
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
#line 2615
    return (0);
  } else {

  }
#line 2617
  mutex_lock_nested(& pxmitpriv->ack_tx_mutex, 0U);
#line 2618
  pxmitpriv->ack_tx = 1;
#line 2620
  pmgntframe->ack_report = 1U;
#line 2621
  tmp = rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 2621
  if (tmp == 1) {
#line 2622
    ret = rtw_ack_tx_wait23a(pxmitpriv, timeout_ms);
  } else {

  }
#line 2624
  pxmitpriv->ack_tx = 0;
#line 2625
  mutex_unlock(& pxmitpriv->ack_tx_mutex);
#line 2627
  return (ret);
}
}
#line 2630 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int update_hidden_ssid(u8 *ies , u32 ies_len , u8 hidden_ssid_mode ) 
{ 
  u8 *ssid_ie ;
  int ssid_len_ori ;
  int len_diff ;
  u8 *next_ie ;
  u32 remain_len ;
  size_t __len ;
  void *__ret ;

  {
#line 2634
  len_diff = 0;
#line 2638
  ssid_ie = rtw_get_ie23a(ies, 0, & ssid_len_ori, (int )ies_len);
#line 2643
  if ((unsigned long )ssid_ie != (unsigned long )((u8 *)0U) && ssid_len_ori > 0) {
#line 2644
    switch ((int )hidden_ssid_mode) {
    case 1: 
#line 2647
    next_ie = ssid_ie + ((unsigned long )ssid_len_ori + 2UL);
#line 2648
    remain_len = 0U;
#line 2650
    remain_len = ((u32 )((long )ies) - (u32 )((long )next_ie)) + ies_len;
#line 2652
    *(ssid_ie + 1UL) = 0U;
#line 2653
    __len = (size_t )remain_len;
#line 2653
    __ret = __builtin_memcpy((void *)ssid_ie + 2U, (void const   *)next_ie, __len);
#line 2654
    len_diff = len_diff - ssid_len_ori;
#line 2656
    goto ldv_55002;
    case 2: 
#line 2658
    memset((void *)ssid_ie + 2U, 0, (size_t )ssid_len_ori);
#line 2659
    goto ldv_55002;
    default: ;
#line 2661
    goto ldv_55002;
    }
    ldv_55002: ;
  } else {

  }
#line 2665
  return (len_diff);
}
}
#line 2668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void issue_beacon23a(struct rtw_adapter *padapter , int timeout_ms ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned int rate_len ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 bc_addr[6U] ;
  u8 *wps_ie ;
  u32 wps_ielen ;
  u8 sr ;
  int len_diff ;
  u8 *tmp ;
  u8 *tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  __le16 *tmp___1 ;
  __le16 *tmp___2 ;
  size_t __len___1 ;
  void *__ret___1 ;
  __le16 *tmp___3 ;
  __le16 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u8 erpinfo ;
  u32 ATIMWindow ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;

  {
#line 2675
  pxmitpriv = & padapter->xmitpriv;
#line 2676
  pmlmepriv = & padapter->mlmepriv;
#line 2677
  pmlmeext = & padapter->mlmeextpriv;
#line 2678
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2679
  cur_network = & pmlmeinfo->network;
#line 2680
  bc_addr[0] = 255U;
#line 2680
  bc_addr[1] = 255U;
#line 2680
  bc_addr[2] = 255U;
#line 2680
  bc_addr[3] = 255U;
#line 2680
  bc_addr[4] = 255U;
#line 2680
  bc_addr[5] = 255U;
#line 2683
  sr = 0U;
#line 2688
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2689
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2690
    if (GlobalDebugLevel23A > 3U) {
#line 2690
      printk("\016RTL8723AU: %s, alloc mgnt frame fail\n", "issue_beacon23a");
    } else {

    }
#line 2691
    return;
  } else {

  }
#line 2694
  spin_lock_bh(& pmlmepriv->bcn_update_lock);
#line 2698
  pattrib = & pmgntframe->attrib;
#line 2699
  update_mgntframe_attrib23a(padapter, pattrib);
#line 2700
  pattrib->qsel = 16U;
#line 2702
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2704
  pframe = pmgntframe->buf_addr + 40U;
#line 2705
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 2707
  pwlanhdr->frame_control = 128U;
#line 2709
  pwlanhdr->seq_ctrl = 0U;
#line 2711
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& bc_addr));
#line 2712
  tmp = myid(& padapter->eeprompriv);
#line 2712
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 2713
  tmp___0 = get_my_bssid23a(cur_network);
#line 2713
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 2715
  pframe = pframe + 24UL;
#line 2716
  pattrib->pktlen = 24U;
#line 2718
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 2720
    __len = (size_t )cur_network->IELength;
#line 2720
    __ret = __builtin_memcpy((void *)pframe, (void const   *)(& cur_network->IEs),
                             __len);
#line 2721
    len_diff = update_hidden_ssid(pframe + 12U, cur_network->IELength - 12U, (int )pmlmeinfo->hidden_ssid_mode);
#line 2725
    pframe = pframe + (unsigned long )(cur_network->IELength + (u32 )len_diff);
#line 2726
    pattrib->pktlen = pattrib->pktlen + (cur_network->IELength + (u32 )len_diff);
#line 2728
    wps_ie = rtw_get_wps_ie23a(pmgntframe->buf_addr + 76U, pattrib->pktlen - 36U,
                               (u8 *)0U, & wps_ielen);
#line 2734
    if ((unsigned long )wps_ie != (unsigned long )((u8 *)0U) && wps_ielen != 0U) {
#line 2735
      rtw_get_wps_attr_content23a(wps_ie, wps_ielen, 4161, & sr, (uint *)0U);
    } else {

    }
#line 2739
    if ((unsigned int )sr != 0U) {
#line 2740
      set_fwstate(pmlmepriv, 256);
    } else {
#line 2742
      _clr_fwstate_(pmlmepriv, 256);
    }
#line 2744
    goto _issue_bcn;
  } else {

  }
#line 2750
  pframe = pframe + 8UL;
#line 2751
  pattrib->pktlen = pattrib->pktlen + 8U;
#line 2755
  __len___0 = 2UL;
#line 2755
  if (__len___0 > 63UL) {
#line 2755
    tmp___1 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
#line 2755
    __ret___0 = __memcpy((void *)pframe, (void const   *)tmp___1, __len___0);
  } else {
#line 2755
    tmp___2 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
#line 2755
    __ret___0 = __builtin_memcpy((void *)pframe, (void const   *)tmp___2, __len___0);
  }
#line 2758
  pframe = pframe + 2UL;
#line 2759
  pattrib->pktlen = pattrib->pktlen + 2U;
#line 2763
  __len___1 = 2UL;
#line 2763
  if (__len___1 > 63UL) {
#line 2763
    tmp___3 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
#line 2763
    __ret___1 = __memcpy((void *)pframe, (void const   *)tmp___3, __len___1);
  } else {
#line 2763
    tmp___4 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
#line 2763
    __ret___1 = __builtin_memcpy((void *)pframe, (void const   *)tmp___4, __len___1);
  }
#line 2766
  pframe = pframe + 2UL;
#line 2767
  pattrib->pktlen = pattrib->pktlen + 2U;
#line 2770
  tmp___5 = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const   *)(& cur_network->Ssid.ssid),
                          & pattrib->pktlen);
#line 2770
  pframe = tmp___5;
#line 2775
  rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 2776
  tmp___6 = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const   *)(& cur_network->SupportedRates),
                          & pattrib->pktlen);
#line 2776
  pframe = tmp___6;
#line 2781
  tmp___7 = rtw_set_ie23a(pframe, 3, 1U, (u8 const   *)(& cur_network->DSConfig),
                          & pattrib->pktlen);
#line 2781
  pframe = tmp___7;
#line 2786
  erpinfo = 0U;
#line 2790
  ATIMWindow = 0U;
#line 2791
  tmp___8 = rtw_set_ie23a(pframe, 6, 2U, (u8 const   *)(& ATIMWindow), & pattrib->pktlen);
#line 2791
  pframe = tmp___8;
#line 2796
  tmp___9 = rtw_set_ie23a(pframe, 42, 1U, (u8 const   *)(& erpinfo), & pattrib->pktlen);
#line 2796
  pframe = tmp___9;
#line 2801
  if (rate_len > 8U) {
#line 2802
    tmp___10 = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const   *)(& cur_network->SupportedRates) + 8U,
                             & pattrib->pktlen);
#line 2802
    pframe = tmp___10;
  } else {

  }
  _issue_bcn: 
#line 2812
  pmlmepriv->update_bcn = 0U;
#line 2814
  spin_unlock_bh(& pmlmepriv->bcn_update_lock);
#line 2817
  if (pattrib->pktlen + 32U > 512U) {
#line 2818
    if (GlobalDebugLevel23A > 3U) {
#line 2818
      printk("\016RTL8723AU: beacon frame too large\n");
    } else {

    }
#line 2819
    return;
  } else {

  }
#line 2822
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 2825
  if (timeout_ms > 0) {
#line 2826
    dump_mgntframe23a_and_wait(padapter, pmgntframe, timeout_ms);
  } else {
#line 2828
    dump_mgntframe23a(padapter, pmgntframe);
  }
#line 2829
  return;
}
}
#line 2831 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void issue_probersp(struct rtw_adapter *padapter , unsigned char *da , u8 is_valid_p2p_probereq ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned char *mac ;
  unsigned char *bssid ;
  struct xmit_priv *pxmitpriv ;
  u8 *pwps_ie ;
  uint wps_ielen ;
  u8 *ssid_ie ;
  int ssid_ielen ;
  int ssid_ielen_diff ;
  u8 buf[768U] ;
  u8 *ies ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  unsigned int rate_len ;
  u8 *tmp ;
  uint wps_offset ;
  uint remainder_ielen ;
  u8 *premainder_ie ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  uint remainder_ielen___0 ;
  u8 *remainder_ie ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  size_t __len___5 ;
  void *__ret___5 ;
  size_t __len___6 ;
  void *__ret___6 ;
  __le16 *tmp___0 ;
  __le16 *tmp___1 ;
  size_t __len___7 ;
  void *__ret___7 ;
  __le16 *tmp___2 ;
  __le16 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 erpinfo ;
  u32 ATIMWindow ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;

  {
#line 2839
  pxmitpriv = & padapter->xmitpriv;
#line 2848
  pmlmepriv = & padapter->mlmepriv;
#line 2850
  pmlmeext = & padapter->mlmeextpriv;
#line 2851
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2852
  cur_network = & pmlmeinfo->network;
#line 2857
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2858
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2859
    if (GlobalDebugLevel23A > 3U) {
#line 2859
      printk("\016RTL8723AU: %s, alloc mgnt frame fail\n", "issue_probersp");
    } else {

    }
#line 2860
    return;
  } else {

  }
#line 2864
  pattrib = & pmgntframe->attrib;
#line 2865
  update_mgntframe_attrib23a(padapter, pattrib);
#line 2867
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2869
  pframe = pmgntframe->buf_addr + 40U;
#line 2870
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 2872
  tmp = myid(& padapter->eeprompriv);
#line 2872
  mac = tmp;
#line 2873
  bssid = (unsigned char *)(& cur_network->MacAddress);
#line 2875
  pwlanhdr->frame_control = 80U;
#line 2878
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
#line 2879
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)mac);
#line 2880
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)bssid);
#line 2882
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 2884
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 2886
  pattrib->hdrlen = 24U;
#line 2887
  pattrib->pktlen = (u32 )pattrib->hdrlen;
#line 2888
  pframe = pframe + (unsigned long )pattrib->hdrlen;
#line 2890
  if (cur_network->IELength > 768U) {
#line 2891
    return;
  } else {

  }
#line 2894
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 2895
    pwps_ie = rtw_get_wps_ie23a((u8 *)(& cur_network->IEs) + 12UL, cur_network->IELength - 12U,
                                (u8 *)0U, & wps_ielen);
#line 2902
    if (((unsigned long )pmlmepriv->wps_probe_resp_ie != (unsigned long )((u8 *)0U) && (unsigned long )pwps_ie != (unsigned long )((u8 *)0U)) && wps_ielen != 0U) {
#line 2906
      wps_offset = (unsigned int )((long )pwps_ie) - (unsigned int )((long )(& cur_network->IEs));
#line 2908
      premainder_ie = pwps_ie + (unsigned long )wps_ielen;
#line 2910
      remainder_ielen = (cur_network->IELength - wps_offset) - wps_ielen;
#line 2913
      __len = (size_t )wps_offset;
#line 2913
      __ret = __builtin_memcpy((void *)pframe, (void const   *)(& cur_network->IEs),
                               __len);
#line 2914
      pframe = pframe + (unsigned long )wps_offset;
#line 2915
      pattrib->pktlen = pattrib->pktlen + wps_offset;
#line 2918
      wps_ielen = (unsigned int )*(pmlmepriv->wps_probe_resp_ie + 1UL);
#line 2919
      if ((wps_offset + wps_ielen) + 2U <= 768U) {
#line 2920
        __len___0 = (size_t )(wps_ielen + 2U);
#line 2920
        __ret___0 = __builtin_memcpy((void *)pframe, (void const   *)pmlmepriv->wps_probe_resp_ie,
                                     __len___0);
#line 2922
        pframe = pframe + (unsigned long )(wps_ielen + 2U);
#line 2923
        pattrib->pktlen = (pattrib->pktlen + wps_ielen) + 2U;
      } else {

      }
#line 2926
      if (((wps_offset + wps_ielen) + remainder_ielen) + 2U <= 768U) {
#line 2928
        __len___1 = (size_t )remainder_ielen;
#line 2928
        __ret___1 = __builtin_memcpy((void *)pframe, (void const   *)premainder_ie,
                                     __len___1);
#line 2929
        pframe = pframe + (unsigned long )remainder_ielen;
#line 2930
        pattrib->pktlen = pattrib->pktlen + remainder_ielen;
      } else {

      }
    } else {
#line 2933
      __len___2 = (size_t )cur_network->IELength;
#line 2933
      __ret___2 = __builtin_memcpy((void *)pframe, (void const   *)(& cur_network->IEs),
                                   __len___2);
#line 2934
      pframe = pframe + (unsigned long )cur_network->IELength;
#line 2935
      pattrib->pktlen = pattrib->pktlen + cur_network->IELength;
    }
#line 2939
    ies = pmgntframe->buf_addr + 64U;
#line 2942
    ssid_ie = rtw_get_ie23a(ies + 12UL, 0, & ssid_ielen, (int )(((unsigned int )((long )pframe) - (unsigned int )((long )ies)) + 4294967284U));
#line 2946
    ssid_ielen_diff = (int )cur_network->Ssid.ssid_len - ssid_ielen;
#line 2948
    if ((unsigned long )ssid_ie != (unsigned long )((u8 *)0U) && (unsigned int )cur_network->Ssid.ssid_len != 0U) {
#line 2951
      remainder_ie = ssid_ie + 2UL;
#line 2952
      remainder_ielen___0 = (uint )((long )pframe) - (uint )((long )remainder_ie);
#line 2954
      if (GlobalDebugLevel23A > 4U) {
#line 2954
        printk("\016RTL8723AU: OLD_ERROR %s(%s): remainder_ielen > MAX_IE_SZ\n", "issue_probersp",
               (char *)(& (padapter->pnetdev)->name));
      } else {

      }
#line 2957
      if (remainder_ielen___0 > 768U) {
#line 2958
        remainder_ielen___0 = 768U;
      } else {

      }
#line 2960
      __len___3 = (size_t )remainder_ielen___0;
#line 2960
      __ret___3 = __builtin_memcpy((void *)(& buf), (void const   *)remainder_ie,
                                   __len___3);
#line 2961
      __len___4 = (size_t )remainder_ielen___0;
#line 2961
      __ret___4 = __builtin_memcpy((void *)remainder_ie + (unsigned long )ssid_ielen_diff,
                                   (void const   *)(& buf), __len___4);
#line 2963
      *(ssid_ie + 1UL) = cur_network->Ssid.ssid_len;
#line 2964
      __len___5 = (size_t )cur_network->Ssid.ssid_len;
#line 2964
      __ret___5 = __builtin_memcpy((void *)ssid_ie + 2U, (void const   *)(& cur_network->Ssid.ssid),
                                   __len___5);
#line 2967
      pframe = pframe + (unsigned long )ssid_ielen_diff;
#line 2968
      pattrib->pktlen = pattrib->pktlen + (u32 )ssid_ielen_diff;
    } else {

    }
  } else {
#line 2975
    pframe = pframe + 8UL;
#line 2976
    pattrib->pktlen = pattrib->pktlen + 8U;
#line 2980
    __len___6 = 2UL;
#line 2980
    if (__len___6 > 63UL) {
#line 2980
      tmp___0 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
#line 2980
      __ret___6 = __memcpy((void *)pframe, (void const   *)tmp___0, __len___6);
    } else {
#line 2980
      tmp___1 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
#line 2980
      __ret___6 = __builtin_memcpy((void *)pframe, (void const   *)tmp___1, __len___6);
    }
#line 2983
    pframe = pframe + 2UL;
#line 2984
    pattrib->pktlen = pattrib->pktlen + 2U;
#line 2988
    __len___7 = 2UL;
#line 2988
    if (__len___7 > 63UL) {
#line 2988
      tmp___2 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
#line 2988
      __ret___7 = __memcpy((void *)pframe, (void const   *)tmp___2, __len___7);
    } else {
#line 2988
      tmp___3 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
#line 2988
      __ret___7 = __builtin_memcpy((void *)pframe, (void const   *)tmp___3, __len___7);
    }
#line 2991
    pframe = pframe + 2UL;
#line 2992
    pattrib->pktlen = pattrib->pktlen + 2U;
#line 2997
    tmp___4 = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const   *)(& cur_network->Ssid.ssid),
                            & pattrib->pktlen);
#line 2997
    pframe = tmp___4;
#line 3003
    rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 3004
    tmp___5 = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const   *)(& cur_network->SupportedRates),
                            & pattrib->pktlen);
#line 3004
    pframe = tmp___5;
#line 3010
    tmp___6 = rtw_set_ie23a(pframe, 3, 1U, (u8 const   *)(& cur_network->DSConfig),
                            & pattrib->pktlen);
#line 3010
    pframe = tmp___6;
#line 3014
    if ((pmlmeinfo->state & 3U) == 1U) {
#line 3015
      erpinfo = 0U;
#line 3019
      ATIMWindow = 0U;
#line 3020
      tmp___7 = rtw_set_ie23a(pframe, 6, 2U, (u8 const   *)(& ATIMWindow), & pattrib->pktlen);
#line 3020
      pframe = tmp___7;
#line 3025
      tmp___8 = rtw_set_ie23a(pframe, 42, 1U, (u8 const   *)(& erpinfo), & pattrib->pktlen);
#line 3025
      pframe = tmp___8;
    } else {

    }
#line 3030
    if (rate_len > 8U) {
#line 3031
      tmp___9 = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const   *)(& cur_network->SupportedRates) + 8U,
                              & pattrib->pktlen);
#line 3031
      pframe = tmp___9;
    } else {

    }
  }
#line 3039
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3041
  dump_mgntframe23a(padapter, pmgntframe);
#line 3043
  return;
}
}
#line 3046 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int _issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                           u8 *da , int wait_ack ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned char *mac ;
  unsigned char bssrate[13U] ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int bssrate_len ;
  u8 bc_addr[6U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  size_t __len ;
  void *__ret ;

  {
#line 3049
  ret = 0;
#line 3056
  pxmitpriv = & padapter->xmitpriv;
#line 3057
  pmlmepriv = & padapter->mlmepriv;
#line 3058
  pmlmeext = & padapter->mlmeextpriv;
#line 3059
  bssrate_len = 0;
#line 3060
  bc_addr[0] = 255U;
#line 3060
  bc_addr[1] = 255U;
#line 3060
  bc_addr[2] = 255U;
#line 3060
  bc_addr[3] = 255U;
#line 3060
  bc_addr[4] = 255U;
#line 3060
  bc_addr[5] = 255U;
#line 3062
  if (GlobalDebugLevel23A > 5U) {
#line 3062
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
#line 3062
    printk("\016+%s\n", "_issue_probereq");
  } else {

  }
#line 3065
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3066
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3067
    goto exit;
  } else {

  }
#line 3070
  pattrib = & pmgntframe->attrib;
#line 3071
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3073
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3075
  pframe = pmgntframe->buf_addr + 40U;
#line 3076
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 3078
  tmp = myid(& padapter->eeprompriv);
#line 3078
  mac = tmp;
#line 3080
  pwlanhdr->frame_control = 64U;
#line 3083
  if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
#line 3085
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
#line 3086
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)da);
  } else {
#line 3089
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& bc_addr));
#line 3090
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& bc_addr));
  }
#line 3093
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)mac);
#line 3095
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3098
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3100
  pframe = pframe + 24UL;
#line 3101
  pattrib->pktlen = 24U;
#line 3103
  if ((unsigned long )pssid != (unsigned long )((struct cfg80211_ssid *)0)) {
#line 3104
    tmp___0 = rtw_set_ie23a(pframe, 0, (uint )pssid->ssid_len, (u8 const   *)(& pssid->ssid),
                            & pattrib->pktlen);
#line 3104
    pframe = tmp___0;
  } else {
#line 3107
    tmp___1 = rtw_set_ie23a(pframe, 0, 0U, (u8 const   *)0U, & pattrib->pktlen);
#line 3107
    pframe = tmp___1;
  }
#line 3110
  get_rate_set23a(padapter, (unsigned char *)(& bssrate), & bssrate_len);
#line 3112
  if (bssrate_len > 8) {
#line 3113
    tmp___2 = rtw_set_ie23a(pframe, 1, 8U, (u8 const   *)(& bssrate), & pattrib->pktlen);
#line 3113
    pframe = tmp___2;
#line 3115
    tmp___3 = rtw_set_ie23a(pframe, 50, (uint )(bssrate_len + -8), (u8 const   *)(& bssrate) + 8U,
                            & pattrib->pktlen);
#line 3115
    pframe = tmp___3;
  } else {
#line 3119
    tmp___4 = rtw_set_ie23a(pframe, 1, (uint )bssrate_len, (u8 const   *)(& bssrate),
                            & pattrib->pktlen);
#line 3119
    pframe = tmp___4;
  }
#line 3124
  if (pmlmepriv->wps_probe_req_ie_len != 0U && (unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
#line 3125
    __len = (size_t )pmlmepriv->wps_probe_req_ie_len;
#line 3125
    __ret = __builtin_memcpy((void *)pframe, (void const   *)pmlmepriv->wps_probe_req_ie,
                             __len);
#line 3127
    pframe = pframe + (unsigned long )pmlmepriv->wps_probe_req_ie_len;
#line 3128
    pattrib->pktlen = pattrib->pktlen + pmlmepriv->wps_probe_req_ie_len;
  } else {

  }
#line 3131
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3133
  if (GlobalDebugLevel23A > 5U) {
#line 3133
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
#line 3133
    printk("\016issuing probe_req, tx_len =%d\n", pattrib->last_txcmdsz);
  } else {

  }
#line 3136
  if (wait_ack != 0) {
#line 3137
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
#line 3139
    dump_mgntframe23a(padapter, pmgntframe);
#line 3140
    ret = 1;
  }
  exit: ;
#line 3144
  return (ret);
}
}
#line 3147 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
__inline static void issue_probereq(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                                    u8 *da ) 
{ 


  {
#line 3150
  _issue_probereq(padapter, pssid, da, 0);
#line 3151
  return;
}
}
#line 3153 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int issue_probereq_ex(struct rtw_adapter *padapter , struct cfg80211_ssid *pssid ,
                             u8 *da , int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  unsigned int tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u8 tmp___2 ;

  {
#line 3158
  i = 0;
#line 3159
  start = jiffies;
  ldv_55135: 
#line 3162
  ret = _issue_probereq(padapter, pssid, da, wait_ms > 0);
#line 3165
  i = i + 1;
#line 3167
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 3168
    goto ldv_55134;
  } else {

  }
#line 3170
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
#line 3171
    msleep((unsigned int )wait_ms);
  } else {

  }
#line 3173
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
#line 3175
    goto ldv_55135;
  } else {

  }
  ldv_55134: ;
#line 3175
  if (ret != 0) {
#line 3176
    ret = 1;
#line 3177
    goto exit;
  } else {

  }
#line 3180
  if (try_cnt != 0 && wait_ms != 0) {
#line 3181
    if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
#line 3182
      if (GlobalDebugLevel23A > 3U) {
#line 3182
        tmp = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3182
        tmp___0 = rtw_get_oper_ch23a(padapter);
#line 3182
        printk("\016RTL8723AU: %s(%s): to %02x:%02x:%02x:%02x:%02x:%02x, ch:%u%s, %d/%d in %u ms\n",
               "issue_probereq_ex", (char *)(& (padapter->pnetdev)->name), (int )*da,
               (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
               (int )*(da + 5UL), (int )tmp___0, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp);
      } else {

      }
    } else
#line 3189
    if (GlobalDebugLevel23A > 3U) {
#line 3189
      tmp___1 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3189
      tmp___2 = rtw_get_oper_ch23a(padapter);
#line 3189
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_probereq_ex",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___2, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___1);
    } else {

    }
  } else {

  }
  exit: ;
#line 3196
  return (ret);
}
}
#line 3200 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void issue_auth(struct rtw_adapter *padapter , struct sta_info *psta , unsigned short status ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned int val32 ;
  unsigned short val16 ;
  int use_shared_key ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u32 tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  u8 *tmp___11 ;
  u8 *tmp___12 ;
  u8 *tmp___13 ;

  {
#line 3209
  use_shared_key = 0;
#line 3210
  pxmitpriv = & padapter->xmitpriv;
#line 3211
  pmlmeext = & padapter->mlmeextpriv;
#line 3212
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3214
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3215
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3216
    return;
  } else {

  }
#line 3219
  pattrib = & pmgntframe->attrib;
#line 3220
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3222
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3224
  pframe = pmgntframe->buf_addr + 40U;
#line 3225
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 3227
  pwlanhdr->frame_control = 176U;
#line 3229
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3231
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3233
  pframe = pframe + 24UL;
#line 3234
  pattrib->pktlen = 24U;
#line 3236
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 3239
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& psta->hwaddr));
#line 3240
    tmp = myid(& padapter->eeprompriv);
#line 3240
    ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 3241
    tmp___0 = myid(& padapter->eeprompriv);
#line 3241
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 3244
    val16 = (unsigned short )psta->authalg;
#line 3246
    if ((unsigned int )status != 0U) {
#line 3247
      val16 = 0U;
    } else {

    }
#line 3249
    if ((unsigned int )val16 != 0U) {
#line 3250
      val16 = val16;
#line 3251
      use_shared_key = 1;
    } else {

    }
#line 3254
    tmp___1 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
#line 3254
    pframe = tmp___1;
#line 3259
    val16 = (unsigned short )psta->auth_seq;
#line 3260
    val16 = val16;
#line 3261
    tmp___2 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
#line 3261
    pframe = tmp___2;
#line 3266
    val16 = status;
#line 3267
    val16 = val16;
#line 3268
    tmp___3 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
#line 3268
    pframe = tmp___3;
#line 3273
    if ((psta->auth_seq == 2U && (psta->state & 512U) != 0U) && use_shared_key == 1) {
#line 3275
      tmp___4 = rtw_set_ie23a(pframe, 16, 128U, (u8 const   *)(& psta->chg_txt), & pattrib->pktlen);
#line 3275
      pframe = tmp___4;
    } else {

    }
  } else {
#line 3279
    tmp___5 = get_my_bssid23a(& pmlmeinfo->network);
#line 3279
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)tmp___5);
#line 3281
    tmp___6 = myid(& padapter->eeprompriv);
#line 3281
    ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp___6);
#line 3282
    tmp___7 = get_my_bssid23a(& pmlmeinfo->network);
#line 3282
    ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___7);
#line 3287
    val16 = pmlmeinfo->auth_algo == 1U;
#line 3288
    if ((unsigned int )val16 != 0U) {
#line 3289
      val16 = val16;
#line 3290
      use_shared_key = 1;
    } else {

    }
#line 3297
    if ((pmlmeinfo->auth_seq == 3U && (pmlmeinfo->state & 512U) != 0U) && use_shared_key == 1) {
#line 3302
      tmp___8 = pmlmeinfo->iv;
#line 3302
      pmlmeinfo->iv = pmlmeinfo->iv + 1U;
#line 3302
      val32 = tmp___8 | (pmlmeinfo->key_index << 30);
#line 3304
      val32 = val32;
#line 3305
      tmp___9 = rtw_set_fixed_ie23a(pframe, 4U, (unsigned char *)(& val32), & pattrib->pktlen);
#line 3305
      pframe = tmp___9;
#line 3309
      pattrib->iv_len = 4U;
    } else {

    }
#line 3312
    tmp___10 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
#line 3312
    pframe = tmp___10;
#line 3317
    val16 = (unsigned short )pmlmeinfo->auth_seq;
#line 3318
    val16 = val16;
#line 3319
    tmp___11 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
#line 3319
    pframe = tmp___11;
#line 3324
    val16 = status;
#line 3325
    val16 = val16;
#line 3326
    tmp___12 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val16), & pattrib->pktlen);
#line 3326
    pframe = tmp___12;
#line 3331
    if ((pmlmeinfo->auth_seq == 3U && (pmlmeinfo->state & 512U) != 0U) && use_shared_key == 1) {
#line 3334
      tmp___13 = rtw_set_ie23a(pframe, 16, 128U, (u8 const   *)(& pmlmeinfo->chg_txt),
                               & pattrib->pktlen);
#line 3334
      pframe = tmp___13;
#line 3338
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 16384U);
#line 3341
      pattrib->hdrlen = 24U;
#line 3343
      pattrib->encrypt = 1027073U;
#line 3345
      pattrib->icv_len = 4U;
#line 3347
      pattrib->pktlen = pattrib->pktlen + (u32 )pattrib->icv_len;
    } else {

    }
  }
#line 3351
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3353
  rtw_wep_encrypt23a(padapter, pmgntframe);
#line 3354
  if (GlobalDebugLevel23A > 3U) {
#line 3354
    printk("\016RTL8723AU: %s\n", "issue_auth");
  } else {

  }
#line 3355
  dump_mgntframe23a(padapter, pmgntframe);
#line 3357
  return;
}
}
#line 3361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void issue_assocrsp(struct rtw_adapter *padapter , unsigned short status ,
                           struct sta_info *pstat , u16 pkt_type ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  unsigned short val ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  u8 const   *p ;
  u8 *ie ;
  u8 *tmp ;
  u8 *tmp___0 ;
  __le16 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  unsigned char WMM_PARA_IE[6U] ;
  int ie_len ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___8 ;
  u8 *tmp___9 ;
  size_t __len___2 ;
  void *__ret___2 ;

  {
#line 3369
  pxmitpriv = & padapter->xmitpriv;
#line 3370
  pmlmepriv = & padapter->mlmepriv;
#line 3371
  pmlmeext = & padapter->mlmeextpriv;
#line 3372
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3373
  pnetwork = & pmlmeinfo->network;
#line 3375
  ie = (u8 *)(& pnetwork->IEs);
#line 3377
  if (GlobalDebugLevel23A > 3U) {
#line 3377
    printk("\016RTL8723AU: %s\n", "issue_assocrsp");
  } else {

  }
#line 3379
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3380
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3381
    return;
  } else {

  }
#line 3384
  pattrib = & pmgntframe->attrib;
#line 3385
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3387
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3389
  pframe = pmgntframe->buf_addr + 40U;
#line 3390
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 3392
  pwlanhdr->frame_control = pkt_type;
#line 3394
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& pstat->hwaddr));
#line 3395
  tmp = myid(& padapter->eeprompriv);
#line 3395
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 3396
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 3396
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 3398
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3401
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3403
  pattrib->hdrlen = 24U;
#line 3404
  pattrib->pktlen = pattrib->pktlen + (u32 )pattrib->hdrlen;
#line 3405
  pframe = pframe + (unsigned long )pattrib->hdrlen;
#line 3408
  tmp___1 = rtw_get_capability23a_from_ie(ie);
#line 3408
  val = *tmp___1;
#line 3410
  tmp___2 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val), & pattrib->pktlen);
#line 3410
  pframe = tmp___2;
#line 3413
  status = status;
#line 3414
  tmp___3 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& status), & pattrib->pktlen);
#line 3414
  pframe = tmp___3;
#line 3418
  val = (unsigned int )((unsigned short )pstat->aid) | 49152U;
#line 3419
  tmp___4 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& val), & pattrib->pktlen);
#line 3419
  pframe = tmp___4;
#line 3422
  if (pstat->bssratelen <= 8U) {
#line 3423
    tmp___5 = rtw_set_ie23a(pframe, 1, pstat->bssratelen, (u8 const   *)(& pstat->bssrateset),
                            & pattrib->pktlen);
#line 3423
    pframe = tmp___5;
  } else {
#line 3427
    tmp___6 = rtw_set_ie23a(pframe, 1, 8U, (u8 const   *)(& pstat->bssrateset), & pattrib->pktlen);
#line 3427
    pframe = tmp___6;
#line 3429
    tmp___7 = rtw_set_ie23a(pframe, 50, pstat->bssratelen - 8U, (u8 const   *)(& pstat->bssrateset) + 8U,
                            & pattrib->pktlen);
#line 3429
    pframe = tmp___7;
  }
#line 3434
  if (((unsigned long )pstat->flags & 2048UL) != 0UL && pmlmepriv->htpriv.ht_option != 0U) {
#line 3437
    p = cfg80211_find_ie(45, (u8 const   *)ie + 12U, (int )(pnetwork->IELength - 12U));
#line 3440
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 3441
      __len = (size_t )((int )*(p + 1UL) + 2);
#line 3441
      __ret = __builtin_memcpy((void *)pframe, (void const   *)p, __len);
#line 3442
      pframe = pframe + ((unsigned long )*(p + 1UL) + 2UL);
#line 3443
      pattrib->pktlen = (pattrib->pktlen + (u32 )*(p + 1UL)) + 2U;
    } else {

    }
#line 3448
    p = cfg80211_find_ie(61, (u8 const   *)ie + 12U, (int )(pnetwork->IELength - 12U));
#line 3451
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 3452
      __len___0 = (size_t )((int )*(p + 1UL) + 2);
#line 3452
      __ret___0 = __builtin_memcpy((void *)pframe, (void const   *)p, __len___0);
#line 3453
      pframe = pframe + ((unsigned long )*(p + 1UL) + 2UL);
#line 3454
      pattrib->pktlen = (pattrib->pktlen + (u32 )*(p + 1UL)) + 2U;
    } else {

    }
  } else {

  }
#line 3459
  if (((unsigned long )pstat->flags & 512UL) != 0UL && pmlmepriv->qos_option != 0U) {
#line 3460
    WMM_PARA_IE[0] = 0U;
#line 3460
    WMM_PARA_IE[1] = 80U;
#line 3460
    WMM_PARA_IE[2] = 242U;
#line 3460
    WMM_PARA_IE[3] = 2U;
#line 3460
    WMM_PARA_IE[4] = 1U;
#line 3460
    WMM_PARA_IE[5] = 1U;
#line 3462
    ie_len = 0;
#line 3464
    p = (u8 const   *)ie + 12U;
    ldv_55185: 
#line 3465
    p = cfg80211_find_ie(221, p, (int )((pnetwork->IELength - (u32 )ie_len) - 14U));
#line 3468
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 3469
      ie_len = (int )*(p + 1UL);
    } else {
#line 3471
      ie_len = 0;
    }
#line 3472
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 3472
      tmp___8 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_PARA_IE), 6UL);
#line 3472
      if (tmp___8 == 0) {
#line 3473
        __len___1 = (size_t )(ie_len + 2);
#line 3473
        __ret___1 = __builtin_memcpy((void *)pframe, (void const   *)p, __len___1);
#line 3474
        pframe = pframe + ((unsigned long )ie_len + 2UL);
#line 3475
        pattrib->pktlen = (pattrib->pktlen + (u32 )ie_len) + 2U;
#line 3477
        goto ldv_55184;
      } else {

      }
    } else {

    }
#line 3480
    if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || ie_len == 0) {
#line 3481
      goto ldv_55184;
    } else {

    }
#line 3464
    p = p + ((unsigned long )ie_len + 2UL);
#line 3482
    goto ldv_55185;
    ldv_55184: ;
  } else {

  }
#line 3485
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 1U) {
#line 3486
    tmp___9 = rtw_set_ie23a(pframe, 221, 6U, (u8 const   *)(& REALTEK_96B_IE), & pattrib->pktlen);
#line 3486
    pframe = tmp___9;
  } else {

  }
#line 3491
  if ((unsigned long )pmlmepriv->wps_assoc_resp_ie != (unsigned long )((u8 *)0U) && pmlmepriv->wps_assoc_resp_ie_len != 0U) {
#line 3493
    __len___2 = (size_t )pmlmepriv->wps_assoc_resp_ie_len;
#line 3493
    __ret___2 = __builtin_memcpy((void *)pframe, (void const   *)pmlmepriv->wps_assoc_resp_ie,
                                 __len___2);
#line 3496
    pframe = pframe + (unsigned long )pmlmepriv->wps_assoc_resp_ie_len;
#line 3497
    pattrib->pktlen = pattrib->pktlen + pmlmepriv->wps_assoc_resp_ie_len;
  } else {

  }
#line 3500
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3502
  dump_mgntframe23a(padapter, pmgntframe);
#line 3503
  return;
}
}
#line 3506 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void issue_assocreq(struct rtw_adapter *padapter ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  u8 const   *p ;
  struct ieee80211_hdr *pwlanhdr ;
  unsigned int i ;
  unsigned int j ;
  unsigned int index ;
  unsigned char rf_type ;
  unsigned char bssrate[13U] ;
  unsigned char sta_bssrate[13U] ;
  struct registry_priv *pregpriv ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bssrate_len ;
  int sta_bssrate_len ;
  int pie_len ;
  int bcn_fixed_size ;
  u8 *pie ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  size_t __len ;
  void *__ret ;
  __le16 *tmp___2 ;
  __le16 *tmp___3 ;
  u8 *tmp___4 ;
  unsigned int tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  bool tmp___10 ;
  bool tmp___11 ;
  u8 *tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  u8 plen ;
  int tmp___15 ;
  u8 *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  u8 *tmp___20 ;
  void *tmp___21 ;
  size_t __len___3 ;
  void *__ret___3 ;

  {
#line 3508
  ret = 0;
#line 3514
  index = 0U;
#line 3516
  pregpriv = & padapter->registrypriv;
#line 3517
  pxmitpriv = & padapter->xmitpriv;
#line 3518
  pmlmepriv = & padapter->mlmepriv;
#line 3519
  pmlmeext = & padapter->mlmeextpriv;
#line 3520
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3521
  bssrate_len = 0;
#line 3521
  sta_bssrate_len = 0;
#line 3524
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3525
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3526
    goto exit;
  } else {

  }
#line 3529
  pattrib = & pmgntframe->attrib;
#line 3530
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3532
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3534
  pframe = pmgntframe->buf_addr + 40U;
#line 3535
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 3537
  pwlanhdr->frame_control = 0U;
#line 3540
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 3540
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)tmp);
#line 3541
  tmp___0 = myid(& padapter->eeprompriv);
#line 3541
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp___0);
#line 3542
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
#line 3542
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___1);
#line 3544
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3546
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3548
  pframe = pframe + 24UL;
#line 3549
  pattrib->pktlen = 24U;
#line 3552
  __len = 2UL;
#line 3552
  if (__len > 63UL) {
#line 3552
    tmp___2 = rtw_get_capability23a_from_ie((u8 *)(& pmlmeinfo->network.IEs));
#line 3552
    __ret = __memcpy((void *)pframe, (void const   *)tmp___2, __len);
  } else {
#line 3552
    tmp___3 = rtw_get_capability23a_from_ie((u8 *)(& pmlmeinfo->network.IEs));
#line 3552
    __ret = __builtin_memcpy((void *)pframe, (void const   *)tmp___3, __len);
  }
#line 3555
  pframe = pframe + 2UL;
#line 3556
  pattrib->pktlen = pattrib->pktlen + 2U;
#line 3560
  put_unaligned_le16(3, (void *)pframe);
#line 3561
  pframe = pframe + 2UL;
#line 3562
  pattrib->pktlen = pattrib->pktlen + 2U;
#line 3565
  tmp___4 = rtw_set_ie23a(pframe, 0, (uint )pmlmeinfo->network.Ssid.ssid_len, (u8 const   *)(& pmlmeinfo->network.Ssid.ssid),
                          & pattrib->pktlen);
#line 3565
  pframe = tmp___4;
#line 3571
  get_rate_set23a(padapter, (unsigned char *)(& sta_bssrate), & sta_bssrate_len);
#line 3575
  if ((unsigned int )pmlmeext->cur_channel == 14U) {
#line 3576
    sta_bssrate_len = 4;
  } else {

  }
#line 3582
  i = 0U;
#line 3582
  goto ldv_55220;
  ldv_55219: ;
#line 3583
  if ((unsigned int )pmlmeinfo->network.SupportedRates[i] == 0U) {
#line 3584
    goto ldv_55218;
  } else {

  }
#line 3585
  if (GlobalDebugLevel23A > 3U) {
#line 3585
    printk("\016RTL8723AU: network.SupportedRates[%d]=%02X\n", i, (int )pmlmeinfo->network.SupportedRates[i]);
  } else {

  }
#line 3582
  i = i + 1U;
  ldv_55220: ;
#line 3582
  if (i <= 15U) {
#line 3584
    goto ldv_55219;
  } else {

  }
  ldv_55218: 
#line 3589
  i = 0U;
#line 3589
  goto ldv_55227;
  ldv_55226: ;
#line 3590
  if ((unsigned int )pmlmeinfo->network.SupportedRates[i] == 0U) {
#line 3591
    goto ldv_55221;
  } else {

  }
#line 3595
  j = 0U;
#line 3595
  goto ldv_55224;
  ldv_55223: ;
#line 3598
  if (((unsigned int )pmlmeinfo->network.SupportedRates[i] | 128U) == ((unsigned int )sta_bssrate[j] | 128U)) {
#line 3602
    goto ldv_55222;
  } else {

  }
#line 3595
  j = j + 1U;
  ldv_55224: ;
#line 3595
  if ((unsigned int )sta_bssrate_len > j) {
#line 3597
    goto ldv_55223;
  } else {

  }
  ldv_55222: ;
#line 3606
  if ((unsigned int )sta_bssrate_len == j) {
#line 3608
    if (GlobalDebugLevel23A > 3U) {
#line 3608
      printk("\016RTL8723AU: %s(): the rate[%d]=%02X is not supported by STA!\n",
             "issue_assocreq", i, (int )pmlmeinfo->network.SupportedRates[i]);
    } else {

    }
  } else {
#line 3613
    tmp___5 = index;
#line 3613
    index = index + 1U;
#line 3613
    bssrate[tmp___5] = pmlmeinfo->network.SupportedRates[i];
  }
#line 3589
  i = i + 1U;
  ldv_55227: ;
#line 3589
  if (i <= 15U) {
#line 3591
    goto ldv_55226;
  } else {

  }
  ldv_55221: 
#line 3617
  bssrate_len = (int )index;
#line 3618
  if (GlobalDebugLevel23A > 3U) {
#line 3618
    printk("\016RTL8723AU: bssrate_len = %d\n", bssrate_len);
  } else {

  }
#line 3620
  if (bssrate_len == 0) {
#line 3621
    rtw_free_xmitbuf23a(pxmitpriv, pmgntframe->pxmitbuf);
#line 3622
    rtw_free_xmitframe23a(pxmitpriv, pmgntframe);
#line 3623
    goto exit;
  } else {

  }
#line 3626
  if (bssrate_len > 8) {
#line 3627
    tmp___6 = rtw_set_ie23a(pframe, 1, 8U, (u8 const   *)(& bssrate), & pattrib->pktlen);
#line 3627
    pframe = tmp___6;
#line 3629
    tmp___7 = rtw_set_ie23a(pframe, 50, (uint )(bssrate_len + -8), (u8 const   *)(& bssrate) + 8U,
                            & pattrib->pktlen);
#line 3629
    pframe = tmp___7;
  } else {
#line 3633
    tmp___8 = rtw_set_ie23a(pframe, 1, (uint )bssrate_len, (u8 const   *)(& bssrate),
                            & pattrib->pktlen);
#line 3633
    pframe = tmp___8;
  }
#line 3637
  bcn_fixed_size = 12;
#line 3640
  pie = (u8 *)(& pmlmeinfo->network.IEs) + (unsigned long )bcn_fixed_size;
#line 3641
  pie_len = (int )(pmlmeinfo->network.IELength - (u32 )bcn_fixed_size);
#line 3643
  p = cfg80211_find_ie(48, (u8 const   *)pie, pie_len);
#line 3644
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 3645
    tmp___9 = rtw_set_ie23a(pframe, 48, (uint )*(p + 1UL), p + 2UL, & pattrib->pktlen);
#line 3645
    pframe = tmp___9;
  } else {

  }
#line 3649
  if (padapter->mlmepriv.htpriv.ht_option == 1U) {
#line 3650
    p = cfg80211_find_ie(45, (u8 const   *)pie, pie_len);
#line 3652
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 3652
      tmp___13 = is_ap_in_tkip23a(padapter);
#line 3652
      if (tmp___13) {
#line 3652
        tmp___14 = 0;
      } else {
#line 3652
        tmp___14 = 1;
      }
#line 3652
      if (tmp___14) {
#line 3653
        __len___0 = 32UL;
#line 3653
        if (__len___0 > 63UL) {
#line 3653
          __ret___0 = __memcpy((void *)(& pmlmeinfo->HT_caps), (void const   *)p + 2U,
                               __len___0);
        } else {
#line 3653
          __ret___0 = __builtin_memcpy((void *)(& pmlmeinfo->HT_caps), (void const   *)p + 2U,
                                       __len___0);
        }
#line 3657
        if ((unsigned int )pregpriv->cbw40_enable == 0U) {
#line 3658
          pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 65469U;
        } else {
#line 3660
          pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info | 2U;
        }
#line 3664
        pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info | 12U;
#line 3667
        rf_type = rtl8723a_get_rf_type(padapter);
#line 3669
        switch ((int )rf_type) {
        case 3: ;
#line 3672
        if ((unsigned int )pregpriv->rx_stbc != 0U) {
#line 3673
          pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info | 256U;
        } else {

        }
#line 3675
        __len___1 = 16UL;
#line 3675
        if (__len___1 > 63UL) {
#line 3675
          __ret___1 = __memcpy((void *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate),
                               (void const   *)(& MCS_rate_1R23A), __len___1);
        } else {
#line 3675
          __ret___1 = __builtin_memcpy((void *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate),
                                       (void const   *)(& MCS_rate_1R23A), __len___1);
        }
#line 3676
        goto ldv_55235;
        case 2: ;
        case 0: ;
        default: ;
#line 3682
        if ((((unsigned int )pregpriv->rx_stbc == 3U || (((int )pmlmeext->cur_wireless_mode & 8) != 0 && (unsigned int )pregpriv->rx_stbc == 1U)) || (((int )pmlmeext->cur_wireless_mode & 16) != 0 && (unsigned int )pregpriv->rx_stbc == 2U)) || (unsigned int )pregpriv->wifi_spec == 1U) {
#line 3692
          if (GlobalDebugLevel23A > 3U) {
#line 3692
            printk("\016RTL8723AU: declare supporting RX STBC\n");
          } else {

          }
#line 3694
          pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info | 512U;
        } else {

        }
#line 3696
        __len___2 = 16UL;
#line 3696
        if (__len___2 > 63UL) {
#line 3696
          __ret___2 = __memcpy((void *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate),
                               (void const   *)(& MCS_rate_2R23A), __len___2);
        } else {
#line 3696
          __ret___2 = __builtin_memcpy((void *)(& pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate),
                                       (void const   *)(& MCS_rate_2R23A), __len___2);
        }
#line 3697
        goto ldv_55235;
        }
        ldv_55235: 
#line 3699
        pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info;
#line 3702
        tmp___10 = rtl8723a_BT_coexist(padapter);
#line 3702
        if ((int )tmp___10) {
#line 3702
          tmp___11 = rtl8723a_BT_using_antenna_1(padapter);
#line 3702
          if ((int )tmp___11) {
#line 3705
            pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 252U;
          } else {

          }
        } else {

        }
#line 3709
        tmp___12 = rtw_set_ie23a(pframe, 45, (uint )*(p + 1UL), (u8 const   *)(& pmlmeinfo->HT_caps),
                                 & pattrib->pktlen);
#line 3709
        pframe = tmp___12;
      } else {

      }
    } else {

    }
  } else {

  }
#line 3716
  i = (unsigned int )bcn_fixed_size;
#line 3716
  goto ldv_55247;
  ldv_55246: 
#line 3717
  p = (u8 const   *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
#line 3719
  switch ((int )*p) {
  case 221: 
#line 3721
  tmp___17 = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                    4UL);
#line 3721
  if (tmp___17 == 0) {
#line 3721
    goto _L;
  } else {
#line 3721
    tmp___18 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_OUI23A), 4UL);
#line 3721
    if (tmp___18 == 0) {
#line 3721
      goto _L;
    } else {
#line 3721
      tmp___19 = memcmp((void const   *)p + 2U, (void const   *)(& WPS_OUI23A), 4UL);
#line 3721
      if (tmp___19 == 0) {
        _L: /* CIL Label */ 
#line 3724
        plen = *(p + 1UL);
#line 3725
        if ((unsigned int )padapter->registrypriv.wifi_spec == 0U) {
#line 3730
          tmp___15 = memcmp((void const   *)p + 2U, (void const   *)(& WPS_OUI23A),
                            4UL);
#line 3730
          if (tmp___15 == 0) {
#line 3731
            plen = 14U;
          } else {

          }
        } else {

        }
#line 3733
        tmp___16 = rtw_set_ie23a(pframe, 221, (uint )plen, p + 2UL, & pattrib->pktlen);
#line 3733
        pframe = tmp___16;
      } else {

      }
    }
  }
#line 3738
  goto ldv_55244;
  default: ;
#line 3741
  goto ldv_55244;
  }
  ldv_55244: 
#line 3744
  i = ((unsigned int )*(p + 1UL) + i) + 2U;
  ldv_55247: ;
#line 3716
  if (pmlmeinfo->network.IELength > i) {
#line 3718
    goto ldv_55246;
  } else {

  }

#line 3747
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 1U) {
#line 3748
    tmp___20 = rtw_set_ie23a(pframe, 221, 6U, (u8 const   *)(& REALTEK_96B_IE), & pattrib->pktlen);
#line 3748
    pframe = tmp___20;
  } else {

  }
#line 3751
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3752
  dump_mgntframe23a(padapter, pmgntframe);
#line 3754
  ret = 1;
  exit: 
#line 3757
  pmlmepriv->assoc_req_len = 0U;
#line 3758
  if (ret == 1) {
#line 3759
    kfree((void const   *)pmlmepriv->assoc_req);
#line 3760
    tmp___21 = kmalloc((size_t )pattrib->pktlen, 32U);
#line 3760
    pmlmepriv->assoc_req = (u8 *)tmp___21;
#line 3761
    if ((unsigned long )pmlmepriv->assoc_req != (unsigned long )((u8 *)0U)) {
#line 3762
      __len___3 = (size_t )pattrib->pktlen;
#line 3762
      __ret___3 = __builtin_memcpy((void *)pmlmepriv->assoc_req, (void const   *)pwlanhdr,
                                   __len___3);
#line 3763
      pmlmepriv->assoc_req_len = pattrib->pktlen;
    } else {

    }
  } else {
#line 3766
    kfree((void const   *)pmlmepriv->assoc_req);
  }
#line 3768
  return;
}
}
#line 3772 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int _issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                              int wait_ack ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
#line 3775
  ret = 0;
#line 3786
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 3787
    goto exit;
  } else {

  }
#line 3789
  pxmitpriv = & padapter->xmitpriv;
#line 3790
  pmlmeext = & padapter->mlmeextpriv;
#line 3791
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3793
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3794
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3795
    goto exit;
  } else {

  }
#line 3798
  pattrib = & pmgntframe->attrib;
#line 3799
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3800
  pattrib->retry_ctrl = 0U;
#line 3802
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3804
  pframe = pmgntframe->buf_addr + 40U;
#line 3805
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 3807
  pwlanhdr->frame_control = 72U;
#line 3810
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 3811
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  } else
#line 3812
  if ((pmlmeinfo->state & 3U) == 2U) {
#line 3813
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  } else {

  }
#line 3815
  if (power_mode != 0U) {
#line 3816
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  } else {

  }
#line 3818
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
#line 3819
  tmp = myid(& padapter->eeprompriv);
#line 3819
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 3820
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 3820
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 3822
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3824
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3826
  pframe = pframe + 24UL;
#line 3827
  pattrib->pktlen = 24U;
#line 3829
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3831
  if (wait_ack != 0) {
#line 3832
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
#line 3834
    dump_mgntframe23a(padapter, pmgntframe);
#line 3835
    ret = 1;
  }
  exit: ;
#line 3839
  return (ret);
}
}
#line 3844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int issue_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , unsigned int power_mode ,
                      int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  unsigned int tmp___0 ;
  u8 tmp___1 ;
  unsigned int tmp___2 ;
  u8 tmp___3 ;

  {
#line 3848
  i = 0;
#line 3849
  start = jiffies;
#line 3850
  pmlmeext = & padapter->mlmeextpriv;
#line 3851
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3854
  if ((unsigned long )da == (unsigned long )((unsigned char *)0U)) {
#line 3855
    tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 3855
    da = tmp;
  } else {

  }
  ldv_55280: 
#line 3858
  ret = _issue_nulldata23a(padapter, da, power_mode, wait_ms > 0);
#line 3861
  i = i + 1;
#line 3863
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 3864
    goto ldv_55279;
  } else {

  }
#line 3866
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
#line 3867
    msleep((unsigned int )wait_ms);
  } else {

  }
#line 3869
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
#line 3871
    goto ldv_55280;
  } else {

  }
  ldv_55279: ;
#line 3871
  if (ret != 0) {
#line 3872
    ret = 1;
#line 3873
    goto exit;
  } else {

  }
#line 3876
  if (try_cnt != 0 && wait_ms != 0) {
#line 3877
    if ((unsigned long )da != (unsigned long )((unsigned char *)0U)) {
#line 3878
      if (GlobalDebugLevel23A > 3U) {
#line 3878
        tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3878
        tmp___1 = rtw_get_oper_ch23a(padapter);
#line 3878
        printk("\016RTL8723AU: %s(%s): to %02x:%02x:%02x:%02x:%02x:%02x, ch:%u%s, %d/%d in %u ms\n",
               "issue_nulldata23a", (char *)(& (padapter->pnetdev)->name), (int )*da,
               (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
               (int )*(da + 5UL), (int )tmp___1, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp___0);
      } else {

      }
    } else
#line 3885
    if (GlobalDebugLevel23A > 3U) {
#line 3885
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3885
      tmp___3 = rtw_get_oper_ch23a(padapter);
#line 3885
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_nulldata23a",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___3, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___2);
    } else {

    }
  } else {

  }
  exit: ;
#line 3892
  return (ret);
}
}
#line 3896 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int _issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da ,
                                  u16 tid , int wait_ack ) 
{ 
  int ret ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_qos_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
#line 3899
  ret = 0;
#line 3904
  pxmitpriv = & padapter->xmitpriv;
#line 3905
  pmlmeext = & padapter->mlmeextpriv;
#line 3906
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3908
  if (GlobalDebugLevel23A > 3U) {
#line 3908
    printk("\016RTL8723AU: %s\n", "_issue_qos_nulldata23a");
  } else {

  }
#line 3910
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3911
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3912
    goto exit;
  } else {

  }
#line 3915
  pattrib = & pmgntframe->attrib;
#line 3916
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3918
  pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 2U;
#line 3919
  pattrib->qos_en = 1U;
#line 3920
  pattrib->eosp = 1U;
#line 3921
  pattrib->ack_policy = 0U;
#line 3922
  pattrib->mdata = 0U;
#line 3924
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3926
  pframe = pmgntframe->buf_addr + 40U;
#line 3927
  pwlanhdr = (struct ieee80211_qos_hdr *)pframe;
#line 3929
  pwlanhdr->frame_control = 200U;
#line 3932
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 3933
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
  } else
#line 3934
  if ((pmlmeinfo->state & 3U) == 2U) {
#line 3935
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
  } else {

  }
#line 3937
  if ((unsigned int )pattrib->mdata != 0U) {
#line 3938
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 8192U);
  } else {

  }
#line 3940
  pwlanhdr->qos_ctrl = (unsigned int )tid & 15U;
#line 3941
  pwlanhdr->qos_ctrl = (__le16 )((int )((short )pwlanhdr->qos_ctrl) | ((int )((short )((int )pattrib->ack_policy << 5)) & 96));
#line 3943
  if ((unsigned int )pattrib->eosp != 0U) {
#line 3944
    pwlanhdr->qos_ctrl = (__le16 )((unsigned int )pwlanhdr->qos_ctrl | 16U);
  } else {

  }
#line 3946
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
#line 3947
  tmp = myid(& padapter->eeprompriv);
#line 3947
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 3948
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 3948
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 3950
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 3952
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3954
  pframe = pframe + 26UL;
#line 3955
  pattrib->pktlen = 26U;
#line 3957
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3959
  if (wait_ack != 0) {
#line 3960
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
#line 3962
    dump_mgntframe23a(padapter, pmgntframe);
#line 3963
    ret = 1;
  }
  exit: ;
#line 3967
  return (ret);
}
}
#line 3972 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int issue_qos_nulldata23a(struct rtw_adapter *padapter , unsigned char *da , u16 tid ,
                          int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  unsigned int tmp___0 ;
  u8 tmp___1 ;
  unsigned int tmp___2 ;
  u8 tmp___3 ;

  {
#line 3976
  i = 0;
#line 3977
  start = jiffies;
#line 3978
  pmlmeext = & padapter->mlmeextpriv;
#line 3979
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 3982
  if ((unsigned long )da == (unsigned long )((unsigned char *)0U)) {
#line 3983
    tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 3983
    da = tmp;
  } else {

  }
  ldv_55312: 
#line 3986
  ret = _issue_qos_nulldata23a(padapter, da, (int )tid, wait_ms > 0);
#line 3989
  i = i + 1;
#line 3991
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 3992
    goto ldv_55311;
  } else {

  }
#line 3994
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
#line 3995
    msleep((unsigned int )wait_ms);
  } else {

  }
#line 3996
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
#line 3998
    goto ldv_55312;
  } else {

  }
  ldv_55311: ;
#line 3998
  if (ret != 0) {
#line 3999
    ret = 1;
#line 4000
    goto exit;
  } else {

  }
#line 4003
  if (try_cnt != 0 && wait_ms != 0) {
#line 4004
    if ((unsigned long )da != (unsigned long )((unsigned char *)0U)) {
#line 4005
      if (GlobalDebugLevel23A > 3U) {
#line 4005
        tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 4005
        tmp___1 = rtw_get_oper_ch23a(padapter);
#line 4005
        printk("\016RTL8723AU: %s(%s): to %02x:%02x:%02x:%02x:%02x:%02x, ch:%u%s, %d/%d in %u ms\n",
               "issue_qos_nulldata23a", (char *)(& (padapter->pnetdev)->name), (int )*da,
               (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
               (int )*(da + 5UL), (int )tmp___1, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp___0);
      } else {

      }
    } else
#line 4012
    if (GlobalDebugLevel23A > 3U) {
#line 4012
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 4012
      tmp___3 = rtw_get_oper_ch23a(padapter);
#line 4012
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_qos_nulldata23a",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___3, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___2);
    } else {

    }
  } else {

  }
  exit: ;
#line 4019
  return (ret);
}
}
#line 4022 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int _issue_deauth(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ,
                         u8 wait_ack ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int ret ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;

  {
#line 4029
  pxmitpriv = & padapter->xmitpriv;
#line 4030
  pmlmeext = & padapter->mlmeextpriv;
#line 4031
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4032
  ret = 0;
#line 4036
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 4037
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 4038
    goto exit;
  } else {

  }
#line 4041
  pattrib = & pmgntframe->attrib;
#line 4042
  update_mgntframe_attrib23a(padapter, pattrib);
#line 4043
  pattrib->retry_ctrl = 0U;
#line 4045
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 4047
  pframe = pmgntframe->buf_addr + 40U;
#line 4048
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 4050
  pwlanhdr->frame_control = 192U;
#line 4053
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)da);
#line 4054
  tmp = myid(& padapter->eeprompriv);
#line 4054
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 4055
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 4055
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 4057
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 4059
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 4061
  pframe = pframe + 24UL;
#line 4062
  pattrib->pktlen = 24U;
#line 4064
  reason = reason;
#line 4065
  tmp___1 = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& reason), & pattrib->pktlen);
#line 4065
  pframe = tmp___1;
#line 4069
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 4071
  if ((unsigned int )wait_ack != 0U) {
#line 4072
    ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
  } else {
#line 4074
    dump_mgntframe23a(padapter, pmgntframe);
#line 4075
    ret = 1;
  }
  exit: ;
#line 4079
  return (ret);
}
}
#line 4082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int issue_deauth23a(struct rtw_adapter *padapter , unsigned char *da , unsigned short reason ) 
{ 
  int tmp ;

  {
#line 4085
  if (GlobalDebugLevel23A > 3U) {
#line 4085
    printk("\016RTL8723AU: %s to %02x:%02x:%02x:%02x:%02x:%02x\n", "issue_deauth23a",
           (int )*da, (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
           (int )*(da + 5UL));
  } else {

  }
#line 4086
  tmp = _issue_deauth(padapter, da, (int )reason, 0);
#line 4086
  return (tmp);
}
}
#line 4089 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int issue_deauth_ex(struct rtw_adapter *padapter , u8 *da , unsigned short reason ,
                           int try_cnt , int wait_ms ) 
{ 
  int ret ;
  int i ;
  unsigned long start ;
  unsigned int tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u8 tmp___2 ;

  {
#line 4093
  i = 0;
#line 4094
  start = jiffies;
  ldv_55347: 
#line 4097
  ret = _issue_deauth(padapter, da, (int )reason, wait_ms > 0);
#line 4100
  i = i + 1;
#line 4102
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 4103
    goto ldv_55346;
  } else {

  }
#line 4105
  if ((i < try_cnt && wait_ms > 0) && ret == 0) {
#line 4106
    msleep((unsigned int )wait_ms);
  } else {

  }
#line 4108
  if (i < try_cnt && (ret == 0 || wait_ms == 0)) {
#line 4110
    goto ldv_55347;
  } else {

  }
  ldv_55346: ;
#line 4110
  if (ret != 0) {
#line 4111
    ret = 1;
#line 4112
    goto exit;
  } else {

  }
#line 4115
  if (try_cnt != 0 && wait_ms != 0) {
#line 4116
    if ((unsigned long )da != (unsigned long )((u8 *)0U)) {
#line 4117
      if (GlobalDebugLevel23A > 3U) {
#line 4117
        tmp = jiffies_to_msecs((unsigned long )jiffies - start);
#line 4117
        tmp___0 = rtw_get_oper_ch23a(padapter);
#line 4117
        printk("\016RTL8723AU: %s(%s): to %02x:%02x:%02x:%02x:%02x:%02x, ch:%u%s, %d/%d in %u ms\n",
               "issue_deauth_ex", (char *)(& (padapter->pnetdev)->name), (int )*da,
               (int )*(da + 1UL), (int )*(da + 2UL), (int )*(da + 3UL), (int )*(da + 4UL),
               (int )*(da + 5UL), (int )tmp___0, ret == 1 ? (char *)", acked" : (char *)"",
               i, try_cnt, tmp);
      } else {

      }
    } else
#line 4124
    if (GlobalDebugLevel23A > 3U) {
#line 4124
      tmp___1 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 4124
      tmp___2 = rtw_get_oper_ch23a(padapter);
#line 4124
      printk("\016RTL8723AU: %s(%s):, ch:%u%s, %d/%d in %u ms\n", "issue_deauth_ex",
             (char *)(& (padapter->pnetdev)->name), (int )tmp___2, ret == 1 ? (char *)", acked" : (char *)"",
             i, try_cnt, tmp___1);
    } else {

    }
  } else {

  }
  exit: ;
#line 4131
  return (ret);
}
}
#line 4134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void issue_action_spct_ch_switch23a(struct rtw_adapter *padapter , u8 *ra , u8 new_ch ,
                                    u8 ch_offset ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u8 category ;
  u8 action ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 tmp___3 ;
  u8 *tmp___4 ;

  {
#line 4141
  pxmitpriv = & padapter->xmitpriv;
#line 4142
  pmlmeext = & padapter->mlmeextpriv;
#line 4145
  if (GlobalDebugLevel23A > 3U) {
#line 4145
    printk("\016RTL8723AU: %s(%s): ra =%02x:%02x:%02x:%02x:%02x:%02x, ch:%u, offset:%u\n",
           "issue_action_spct_ch_switch23a", (char *)(& (padapter->pnetdev)->name),
           (int )*ra, (int )*(ra + 1UL), (int )*(ra + 2UL), (int )*(ra + 3UL), (int )*(ra + 4UL),
           (int )*(ra + 5UL), (int )new_ch, (int )ch_offset);
  } else {

  }
#line 4148
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 4149
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 4150
    return;
  } else {

  }
#line 4153
  pattrib = & pmgntframe->attrib;
#line 4154
  update_mgntframe_attrib23a(padapter, pattrib);
#line 4156
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 4158
  pframe = pmgntframe->buf_addr + 40U;
#line 4159
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 4161
  pwlanhdr->frame_control = 208U;
#line 4164
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)ra);
#line 4165
  tmp = myid(& padapter->eeprompriv);
#line 4165
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 4166
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)ra);
#line 4168
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 4170
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 4172
  pframe = pframe + 24UL;
#line 4173
  pattrib->pktlen = 24U;
#line 4176
  category = 0U;
#line 4177
  action = 4U;
#line 4179
  tmp___0 = rtw_set_fixed_ie23a(pframe, 1U, & category, & pattrib->pktlen);
#line 4179
  pframe = tmp___0;
#line 4180
  tmp___1 = rtw_set_fixed_ie23a(pframe, 1U, & action, & pattrib->pktlen);
#line 4180
  pframe = tmp___1;
#line 4182
  tmp___2 = rtw_set_ie23a_ch_switch(pframe, & pattrib->pktlen, 0, (int )new_ch, 0);
#line 4182
  pframe = tmp___2;
#line 4184
  tmp___3 = hal_ch_offset_to_secondary_ch_offset23a((int )ch_offset);
#line 4184
  tmp___4 = rtw_set_ie23a_secondary_ch_offset(pframe, & pattrib->pktlen, (int )tmp___3);
#line 4184
  pframe = tmp___4;
#line 4187
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 4189
  dump_mgntframe23a(padapter, pmgntframe);
#line 4190
  return;
}
}
#line 4192 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void issue_action_BA23a(struct rtw_adapter *padapter , unsigned char const   *raddr ,
                        unsigned char action , unsigned short status ) 
{ 
  u8 category ;
  u16 start_seq ;
  u16 BA_para_set ;
  u16 reason_code ;
  u16 BA_timeout_value ;
  u16 BA_starting_seqctrl ;
  int max_rx_ampdu_factor ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  u8 *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct registry_priv *pregpriv ;
  u8 tendaAPMac[3U] ;
  u8 *tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 4196
  category = 3U;
#line 4207
  pxmitpriv = & padapter->xmitpriv;
#line 4208
  pmlmeext = & padapter->mlmeextpriv;
#line 4209
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4211
  pstapriv = & padapter->stapriv;
#line 4212
  pregpriv = & padapter->registrypriv;
#line 4213
  tendaAPMac[0] = 200U;
#line 4213
  tendaAPMac[1] = 58U;
#line 4213
  tendaAPMac[2] = 53U;
#line 4215
  if (GlobalDebugLevel23A > 3U) {
#line 4215
    printk("\016RTL8723AU: %s, category =%d, action =%d, status =%d\n", "issue_action_BA23a",
           (int )category, (int )action, (int )status);
  } else {

  }
#line 4218
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 4219
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 4220
    return;
  } else {

  }
#line 4223
  pattrib = & pmgntframe->attrib;
#line 4224
  update_mgntframe_attrib23a(padapter, pattrib);
#line 4226
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 4228
  pframe = pmgntframe->buf_addr + 40UL;
#line 4229
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 4231
  pwlanhdr->frame_control = 208U;
#line 4235
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), raddr);
#line 4236
  tmp = myid(& padapter->eeprompriv);
#line 4236
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp);
#line 4237
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 4237
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 4239
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 4241
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 4243
  pframe = pframe + 24UL;
#line 4244
  pattrib->pktlen = 24U;
#line 4246
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & category, & pattrib->pktlen);
#line 4247
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & action, & pattrib->pktlen);
#line 4249
  status = status;
#line 4251
  if ((unsigned int )category != 3U) {
#line 4252
    goto out;
  } else {

  }
#line 4254
  switch ((int )action) {
  case 0: ;
  ldv_55392: 
#line 4258
  pmlmeinfo->dialogToken = (u8 )((int )pmlmeinfo->dialogToken + 1);
#line 4259
  if ((unsigned int )pmlmeinfo->dialogToken == 0U) {
#line 4261
    goto ldv_55392;
  } else {

  }
#line 4260
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & pmlmeinfo->dialogToken, & pattrib->pktlen);
#line 4263
  tmp___1 = rtl8723a_BT_coexist(padapter);
#line 4263
  if ((int )tmp___1) {
#line 4263
    tmp___2 = rtl8723a_BT_using_antenna_1(padapter);
#line 4263
    if ((int )tmp___2) {
#line 4263
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor != 1U) {
#line 4268
        BA_para_set = 0U;
#line 4270
        BA_para_set = (u16 )((unsigned int )BA_para_set | 2U);
#line 4273
        BA_para_set = (u16 )(((int )((short )((int )status << 2)) & 60) | (int )((short )BA_para_set));
#line 4276
        BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
      } else {
#line 4263
        tmp___3 = memcmp((void const   *)raddr, (void const   *)(& tendaAPMac), 3UL);
#line 4263
        if (tmp___3 != 0) {
#line 4268
          BA_para_set = 0U;
#line 4270
          BA_para_set = (u16 )((unsigned int )BA_para_set | 2U);
#line 4273
          BA_para_set = (u16 )(((int )((short )((int )status << 2)) & 60) | (int )((short )BA_para_set));
#line 4276
          BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
        } else {
#line 4280
          BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
        }
      }
    } else {
#line 4280
      BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
    }
  } else {
#line 4280
    BA_para_set = (u16 )((int )((short )(((int )status & 15) << 2)) | 4098);
  }
#line 4282
  BA_para_set = BA_para_set;
#line 4283
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_para_set), & pattrib->pktlen);
#line 4287
  BA_timeout_value = 5000U;
#line 4288
  BA_timeout_value = BA_timeout_value;
#line 4289
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_timeout_value),
                               & pattrib->pktlen);
#line 4295
  psta = rtw_get_stainfo23a(pstapriv, raddr);
#line 4295
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 4296
    start_seq = ((unsigned int )psta->sta_xmitpriv.txseq_tid[(int )status & 7] & 4095U) + 1U;
#line 4298
    if (GlobalDebugLevel23A > 3U) {
#line 4298
      printk("\016RTL8723AU: BA_starting_seqctrl = %d for TID =%d\n", (int )start_seq,
             (int )status & 7);
    } else {

    }
#line 4301
    psta->BA_starting_seqctrl[(int )status & 7] = start_seq;
#line 4303
    BA_starting_seqctrl = (int )start_seq << 4U;
  } else {

  }
#line 4306
  BA_starting_seqctrl = BA_starting_seqctrl;
#line 4307
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_starting_seqctrl),
                               & pattrib->pktlen);
#line 4308
  goto ldv_55394;
  case 1: 
#line 4311
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & pmlmeinfo->ADDBA_req.dialog_token, & pattrib->pktlen);
#line 4312
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& status), & pattrib->pktlen);
#line 4315
  GetHalDefVar8192CUsb(padapter, 11, (void *)(& max_rx_ampdu_factor));
#line 4317
  if (max_rx_ampdu_factor == 3) {
#line 4318
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 4096);
  } else
#line 4319
  if (max_rx_ampdu_factor == 2) {
#line 4320
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 2048);
  } else
#line 4321
  if (max_rx_ampdu_factor == 1) {
#line 4322
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 1024);
  } else
#line 4323
  if (max_rx_ampdu_factor == 0) {
#line 4324
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 512);
  } else {
#line 4326
    BA_para_set = (u16 )(((int )((short )pmlmeinfo->ADDBA_req.BA_para_set) & 63) | 4096);
  }
#line 4328
  tmp___4 = rtl8723a_BT_coexist(padapter);
#line 4328
  if ((int )tmp___4) {
#line 4328
    tmp___5 = rtl8723a_BT_using_antenna_1(padapter);
#line 4328
    if ((int )tmp___5) {
#line 4328
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor != 1U) {
#line 4333
        BA_para_set = (unsigned int )BA_para_set & 63U;
#line 4334
        BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
      } else {
#line 4328
        tmp___6 = memcmp((void const   *)raddr, (void const   *)(& tendaAPMac), 3UL);
#line 4328
        if (tmp___6 != 0) {
#line 4333
          BA_para_set = (unsigned int )BA_para_set & 63U;
#line 4334
          BA_para_set = (u16 )((unsigned int )BA_para_set | 512U);
        } else {

        }
      }
    } else {

    }
  } else {

  }
#line 4338
  if ((unsigned int )pregpriv->ampdu_amsdu == 0U) {
#line 4339
    BA_para_set = (unsigned int )BA_para_set & 65534U;
  } else
#line 4340
  if ((unsigned int )pregpriv->ampdu_amsdu == 1U) {
#line 4341
    BA_para_set = (unsigned int )BA_para_set | 1U;
  } else {
#line 4343
    BA_para_set = BA_para_set;
  }
#line 4345
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_para_set), & pattrib->pktlen);
#line 4348
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& pmlmeinfo->ADDBA_req.BA_timeout_value),
                               & pattrib->pktlen);
#line 4349
  goto ldv_55394;
  case 2: 
#line 4351
  BA_para_set = (unsigned int )((u16 )((int )status << 3)) & 255U;
#line 4352
  BA_para_set = BA_para_set;
#line 4353
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& BA_para_set), & pattrib->pktlen);
#line 4357
  reason_code = 37U;
#line 4359
  reason_code = reason_code;
#line 4360
  pframe = rtw_set_fixed_ie23a(pframe, 2U, (unsigned char *)(& reason_code), & pattrib->pktlen);
#line 4363
  goto ldv_55394;
  default: ;
#line 4365
  goto ldv_55394;
  }
  ldv_55394: ;
  out: 
#line 4369
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 4371
  dump_mgntframe23a(padapter, pmgntframe);
#line 4372
  return;
}
}
#line 4374 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void issue_action_BSSCoexistPacket(struct rtw_adapter *padapter ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  unsigned char category ;
  unsigned char action ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  u8 *pframe ;
  struct ieee80211_hdr *pwlanhdr ;
  struct wlan_network *pnetwork ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct rtw_queue *queue ;
  u8 InfoContent[16U] ;
  unsigned int tmp ;
  u8 ICS[8U][15U] ;
  int i ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 iedata ;
  u8 const   *p ;
  struct wlan_bssid_ex *pbss_network ;
  struct list_head  const  *__mptr ;
  int j ;
  int k ;

  {
#line 4383
  pxmitpriv = & padapter->xmitpriv;
#line 4384
  pmlmepriv = & padapter->mlmepriv;
#line 4385
  pmlmeext = & padapter->mlmeextpriv;
#line 4386
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4387
  queue = & pmlmepriv->scanned_queue;
#line 4388
  InfoContent[0] = 0U;
#line 4388
  tmp = 1U;
#line 4388
  while (1) {
#line 4388
    if (tmp >= 16U) {
#line 4388
      break;
    } else {

    }
#line 4388
    InfoContent[tmp] = (unsigned char)0;
#line 4388
    tmp = tmp + 1U;
  }
#line 4392
  if (pmlmepriv->num_FortyMHzIntolerant == 0 || pmlmepriv->num_sta_no_ht == 0) {
#line 4394
    return;
  } else {

  }
#line 4396
  if ((unsigned int )pmlmeinfo->bwmode_updated != 0U) {
#line 4397
    return;
  } else {

  }
#line 4399
  if (GlobalDebugLevel23A > 3U) {
#line 4399
    printk("\016RTL8723AU: %s\n", "issue_action_BSSCoexistPacket");
  } else {

  }
#line 4401
  category = 4U;
#line 4402
  action = 0U;
#line 4404
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 4405
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 4406
    return;
  } else {

  }
#line 4409
  pattrib = & pmgntframe->attrib;
#line 4410
  update_mgntframe_attrib23a(padapter, pattrib);
#line 4412
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 4414
  pframe = pmgntframe->buf_addr + 40UL;
#line 4415
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 4417
  pwlanhdr->frame_control = 208U;
#line 4420
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 4420
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)tmp___0);
#line 4421
  tmp___1 = myid(& padapter->eeprompriv);
#line 4421
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp___1);
#line 4422
  tmp___2 = get_my_bssid23a(& pmlmeinfo->network);
#line 4422
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___2);
#line 4424
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 4426
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 4428
  pframe = pframe + 24UL;
#line 4429
  pattrib->pktlen = 24U;
#line 4431
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & category, & pattrib->pktlen);
#line 4432
  pframe = rtw_set_fixed_ie23a(pframe, 1U, & action, & pattrib->pktlen);
#line 4434
  if (pmlmepriv->num_FortyMHzIntolerant > 0) {
#line 4435
    iedata = 4U;
#line 4437
    pframe = rtw_set_ie23a(pframe, 72, 1U, (u8 const   *)(& iedata), & pattrib->pktlen);
  } else {

  }
#line 4441
  if (pmlmepriv->num_sta_no_ht <= 0) {
#line 4442
    goto out;
  } else {

  }
#line 4444
  memset((void *)(& ICS), 0, 120UL);
#line 4446
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 4448
  phead = get_list_head(queue);
#line 4449
  plist = phead->next;
#line 4451
  plist = phead->next;
#line 4451
  ptmp = plist->next;
#line 4451
  goto ldv_55428;
  ldv_55427: 
#line 4455
  __mptr = (struct list_head  const  *)plist;
#line 4455
  pnetwork = (struct wlan_network *)__mptr;
#line 4457
  pbss_network = & pnetwork->network;
#line 4459
  p = cfg80211_find_ie(45, (u8 const   *)(& pbss_network->IEs) + 12U, (int )(pbss_network->IELength - 12U));
#line 4462
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(p + 1UL)) == 0U) {
#line 4463
    if (pbss_network->DSConfig == 0U || pbss_network->DSConfig > 14U) {
#line 4465
      goto ldv_55426;
    } else {

    }
#line 4467
    ICS[0][pbss_network->DSConfig] = 1U;
#line 4469
    if ((unsigned int )ICS[0][0] == 0U) {
#line 4470
      ICS[0][0] = 1U;
    } else {

    }
  } else {

  }
  ldv_55426: 
#line 4451
  plist = ptmp;
#line 4451
  ptmp = plist->next;
  ldv_55428: ;
#line 4451
  if ((unsigned long )plist != (unsigned long )phead) {
#line 4453
    goto ldv_55427;
  } else {

  }
#line 4475
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 4477
  i = 0;
#line 4477
  goto ldv_55436;
  ldv_55435: ;
#line 4478
  if ((unsigned int )ICS[i][0] == 1U) {
#line 4479
    k = 0;
#line 4481
    InfoContent[k] = (u8 )i;
#line 4483
    k = k + 1;
#line 4485
    j = 1;
#line 4485
    goto ldv_55433;
    ldv_55432: ;
#line 4486
    if ((unsigned int )ICS[i][j] == 1U) {
#line 4487
      if (k <= 15) {
#line 4489
        InfoContent[k] = (u8 )j;
#line 4490
        k = k + 1;
      } else {

      }
    } else {

    }
#line 4485
    j = j + 1;
    ldv_55433: ;
#line 4485
    if (j <= 14) {
#line 4487
      goto ldv_55432;
    } else {

    }
#line 4495
    pframe = rtw_set_ie23a(pframe, 73, (uint )k, (u8 const   *)(& InfoContent), & pattrib->pktlen);
  } else {

  }
#line 4477
  i = i + 1;
  ldv_55436: ;
#line 4477
  if (i <= 7) {
#line 4479
    goto ldv_55435;
  } else {

  }

  out: 
#line 4502
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 4504
  dump_mgntframe23a(padapter, pmgntframe);
#line 4505
  return;
}
}
#line 4507 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int send_delba23a(struct rtw_adapter *padapter , u8 initiator , u8 *addr ) 
{ 
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u16 tid ;

  {
#line 4509
  pstapriv = & padapter->stapriv;
#line 4510
  psta = (struct sta_info *)0;
#line 4512
  pmlmeext = & padapter->mlmeextpriv;
#line 4513
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4516
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 4517
    if ((pmlmeinfo->state & 16384U) == 0U) {
#line 4518
      return (1);
    } else {

    }
  } else {

  }
#line 4520
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)addr);
#line 4521
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 4522
    return (1);
  } else {

  }
#line 4524
  if ((unsigned int )initiator == 0U) {
#line 4525
    tid = 0U;
#line 4525
    goto ldv_55449;
    ldv_55448: ;
#line 4526
    if ((unsigned int )psta->recvreorder_ctrl[(int )tid].enable == 1U) {
#line 4527
      if (GlobalDebugLevel23A > 3U) {
#line 4527
        printk("\016RTL8723AU: rx agg disable tid(%d)\n", (int )tid);
      } else {

      }
#line 4528
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 2, (int )((unsigned short )((int )((short )((int )tid << 1)) | (int )((short )initiator))) & 31);
#line 4529
      psta->recvreorder_ctrl[(int )tid].enable = 0U;
#line 4530
      psta->recvreorder_ctrl[(int )tid].indicate_seq = 65535U;
    } else {

    }
#line 4525
    tid = (u16 )((int )tid + 1);
    ldv_55449: ;
#line 4525
    if ((unsigned int )tid <= 15U) {
#line 4527
      goto ldv_55448;
    } else {

    }

  } else
#line 4533
  if ((unsigned int )initiator == 1U) {
#line 4534
    tid = 0U;
#line 4534
    goto ldv_55452;
    ldv_55451: ;
#line 4535
    if ((int )((unsigned long )psta->htpriv.agg_enable_bitmap >> (int )tid) & 1) {
#line 4536
      if (GlobalDebugLevel23A > 3U) {
#line 4536
        printk("\016RTL8723AU: tx agg disable tid(%d)\n", (int )tid);
      } else {

      }
#line 4537
      issue_action_BA23a(padapter, (unsigned char const   *)addr, 2, (int )((unsigned short )((int )((short )((int )tid << 1)) | (int )((short )initiator))) & 31);
#line 4538
      psta->htpriv.agg_enable_bitmap = (int )psta->htpriv.agg_enable_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
#line 4539
      psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )tid)));
    } else {

    }
#line 4534
    tid = (u16 )((int )tid + 1);
    ldv_55452: ;
#line 4534
    if ((unsigned int )tid <= 15U) {
#line 4536
      goto ldv_55451;
    } else {

    }

  } else {

  }
#line 4544
  return (1);
}
}
#line 4547 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int send_beacon23a(struct rtw_adapter *padapter ) 
{ 
  bool bxmitok ;
  int issue ;
  int poll ;
  unsigned long start ;
  unsigned int passing_time ;

  {
#line 4550
  issue = 0;
#line 4551
  poll = 0;
#line 4552
  start = jiffies;
#line 4555
  rtl8723a_bcn_valid(padapter);
  ldv_55464: 
#line 4557
  issue_beacon23a(padapter, 100);
#line 4558
  issue = issue + 1;
  ldv_55462: 
#line 4560
  yield();
#line 4561
  bxmitok = rtl8723a_get_bcn_valid(padapter);
#line 4562
  poll = poll + 1;
#line 4565
  if (((poll % 10 != 0 && ! bxmitok) && padapter->bSurpriseRemoved == 0) && padapter->bDriverStopped == 0) {
#line 4567
    goto ldv_55462;
  } else {

  }

#line 4568
  if (((! bxmitok && issue <= 99) && padapter->bSurpriseRemoved == 0) && padapter->bDriverStopped == 0) {
#line 4570
    goto ldv_55464;
  } else {

  }

#line 4570
  if (padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) {
#line 4571
    return (0);
  } else {

  }
#line 4573
  passing_time = jiffies_to_msecs((unsigned long )jiffies - start);
#line 4575
  if (! bxmitok) {
#line 4576
    if (GlobalDebugLevel23A > 3U) {
#line 4576
      printk("\016RTL8723AU: %s fail! %u ms\n", "send_beacon23a", passing_time);
    } else {

    }
#line 4577
    return (0);
  } else {
#line 4580
    if (passing_time > 100U || issue > 3) {
#line 4581
      if (GlobalDebugLevel23A > 3U) {
#line 4581
        printk("\016RTL8723AU: %s success, issue:%d, poll:%d, %u ms\n", "send_beacon23a",
               issue, poll, passing_time);
      } else {

      }
    } else {

    }
#line 4583
    return (1);
  }
}
}
#line 4593 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
bool IsLegal5GChannel(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  int i ;
  u8 Channel_5G[45U] ;

  {
#line 4596
  i = 0;
#line 4597
  Channel_5G[0] = 36U;
#line 4597
  Channel_5G[1] = 38U;
#line 4597
  Channel_5G[2] = 40U;
#line 4597
  Channel_5G[3] = 42U;
#line 4597
  Channel_5G[4] = 44U;
#line 4597
  Channel_5G[5] = 46U;
#line 4597
  Channel_5G[6] = 48U;
#line 4597
  Channel_5G[7] = 50U;
#line 4597
  Channel_5G[8] = 52U;
#line 4597
  Channel_5G[9] = 54U;
#line 4597
  Channel_5G[10] = 56U;
#line 4597
  Channel_5G[11] = 58U;
#line 4597
  Channel_5G[12] = 60U;
#line 4597
  Channel_5G[13] = 62U;
#line 4597
  Channel_5G[14] = 64U;
#line 4597
  Channel_5G[15] = 100U;
#line 4597
  Channel_5G[16] = 102U;
#line 4597
  Channel_5G[17] = 104U;
#line 4597
  Channel_5G[18] = 106U;
#line 4597
  Channel_5G[19] = 108U;
#line 4597
  Channel_5G[20] = 110U;
#line 4597
  Channel_5G[21] = 112U;
#line 4597
  Channel_5G[22] = 114U;
#line 4597
  Channel_5G[23] = 116U;
#line 4597
  Channel_5G[24] = 118U;
#line 4597
  Channel_5G[25] = 120U;
#line 4597
  Channel_5G[26] = 122U;
#line 4597
  Channel_5G[27] = 124U;
#line 4597
  Channel_5G[28] = 126U;
#line 4597
  Channel_5G[29] = 128U;
#line 4597
  Channel_5G[30] = 130U;
#line 4597
  Channel_5G[31] = 132U;
#line 4597
  Channel_5G[32] = 134U;
#line 4597
  Channel_5G[33] = 136U;
#line 4597
  Channel_5G[34] = 138U;
#line 4597
  Channel_5G[35] = 140U;
#line 4597
  Channel_5G[36] = 149U;
#line 4597
  Channel_5G[37] = 151U;
#line 4597
  Channel_5G[38] = 153U;
#line 4597
  Channel_5G[39] = 155U;
#line 4597
  Channel_5G[40] = 157U;
#line 4597
  Channel_5G[41] = 159U;
#line 4597
  Channel_5G[42] = 161U;
#line 4597
  Channel_5G[43] = 163U;
#line 4597
  Channel_5G[44] = 165U;
#line 4601
  i = 0;
#line 4601
  goto ldv_55474;
  ldv_55473: ;
#line 4602
  if ((int )Channel_5G[i] == (int )channel) {
#line 4603
    return (1);
  } else {

  }
#line 4601
  i = i + 1;
  ldv_55474: ;
#line 4601
  if ((unsigned int )i <= 44U) {
#line 4603
    goto ldv_55473;
  } else {

  }

#line 4604
  return (0);
}
}
#line 4607 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void rtw_site_survey(struct rtw_adapter *padapter ) 
{ 
  unsigned char survey_channel ;
  enum rt_scan_type ScanType ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct rtw_ieee80211_channel *ch ;
  int i ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
#line 4609
  survey_channel = 0U;
#line 4610
  ScanType = 0;
#line 4611
  pmlmeext = & padapter->mlmeextpriv;
#line 4612
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4615
  if (pmlmeext->sitesurvey_res.channel_idx < (int )pmlmeext->sitesurvey_res.ch_num) {
#line 4617
    ch = (struct rtw_ieee80211_channel *)(& pmlmeext->sitesurvey_res.ch) + (unsigned long )pmlmeext->sitesurvey_res.channel_idx;
#line 4618
    survey_channel = (unsigned char )ch->hw_value;
#line 4619
    ScanType = (ch->flags & 2U) == 0U;
  } else {

  }
#line 4623
  if ((unsigned int )survey_channel != 0U) {
#line 4625
    if (pmlmeext->sitesurvey_res.channel_idx == 0) {
#line 4626
      set_channel_bwmode23a(padapter, (int )survey_channel, 0, 0);
    } else {
#line 4630
      SelectChannel23a(padapter, (int )survey_channel);
    }
#line 4632
    if ((unsigned int )ScanType == 1U) {
#line 4635
      i = 0;
#line 4635
      goto ldv_55486;
      ldv_55485: ;
#line 4636
      if ((unsigned int )pmlmeext->sitesurvey_res.ssid[i].ssid_len != 0U) {
#line 4638
        issue_probereq(padapter, (struct cfg80211_ssid *)(& pmlmeext->sitesurvey_res.ssid) + (unsigned long )i,
                       (u8 *)0U);
#line 4640
        issue_probereq(padapter, (struct cfg80211_ssid *)(& pmlmeext->sitesurvey_res.ssid) + (unsigned long )i,
                       (u8 *)0U);
      } else {

      }
#line 4635
      i = i + 1;
      ldv_55486: ;
#line 4635
      if (i <= 8) {
#line 4637
        goto ldv_55485;
      } else {

      }

#line 4644
      if (pmlmeext->sitesurvey_res.scan_mode == 1) {
#line 4646
        issue_probereq(padapter, (struct cfg80211_ssid *)0, (u8 *)0U);
#line 4648
        issue_probereq(padapter, (struct cfg80211_ssid *)0, (u8 *)0U);
      } else {

      }
    } else {

    }
#line 4652
    tmp = msecs_to_jiffies((unsigned int const   )pmlmeext->chan_scan_time);
#line 4652
    ldv_mod_timer_538(& pmlmeext->survey_timer, tmp + (unsigned long )jiffies);
  } else {
#line 4655
    pmlmeext->sitesurvey_res.state = 4;
#line 4659
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
#line 4667
    Set_MSR23a(padapter, (int )((u8 )pmlmeinfo->state) & 3);
#line 4670
    rtl8723a_set_initial_gain(padapter, 255U);
#line 4672
    rtl8723a_odm_support_ability_restore(padapter);
#line 4674
    tmp___0 = is_client_associated_to_ap23a(padapter);
#line 4674
    if ((int )tmp___0) {
#line 4675
      issue_nulldata23a(padapter, (unsigned char *)0U, 0U, 3, 500);
    } else {

    }
#line 4677
    rtl8723a_mlme_sitesurvey(padapter, 0);
#line 4679
    report_surveydone_event23a(padapter);
#line 4681
    pmlmeext->chan_scan_time = 100U;
#line 4682
    pmlmeext->sitesurvey_res.state = 0;
#line 4684
    issue_action_BSSCoexistPacket(padapter);
#line 4685
    issue_action_BSSCoexistPacket(padapter);
#line 4686
    issue_action_BSSCoexistPacket(padapter);
  }
#line 4689
  return;
}
}
#line 4693 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int collect_bss_info23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ,
                        struct wlan_bssid_ex *bssid ) 
{ 
  int i ;
  u8 const   *p ;
  struct sk_buff *skb ;
  struct ieee80211_mgmt *mgmt ;
  unsigned int length ;
  u8 ie_offset ;
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u16 capab_info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  struct HT_info_element *HT_info ;
  u8 tmp___2 ;
  int tmp___3 ;
  __le16 *tmp___4 ;
  struct mlme_priv *pmlmepriv ;
  struct HT_caps_element *pHT_caps ;
  u8 tmp___5 ;

  {
#line 4699
  skb = precv_frame->pkt;
#line 4700
  mgmt = (struct ieee80211_mgmt *)skb->data;
#line 4703
  pregistrypriv = & padapter->registrypriv;
#line 4704
  pmlmeext = & padapter->mlmeextpriv;
#line 4705
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4708
  length = skb->len - 24U;
#line 4710
  if (length > 768U) {
#line 4712
    return (0);
  } else {

  }
#line 4715
  memset((void *)bssid, 0, 863UL);
#line 4717
  tmp___1 = ieee80211_is_beacon((int )mgmt->frame_control);
#line 4717
  if (tmp___1 != 0) {
#line 4718
    bssid->reserved = 1U;
#line 4719
    ie_offset = 36U;
#line 4720
    capab_info = mgmt->u.beacon.capab_info;
  } else {
#line 4721
    tmp___0 = ieee80211_is_probe_req((int )mgmt->frame_control);
#line 4721
    if (tmp___0 != 0) {
#line 4722
      ie_offset = 24U;
#line 4724
      bssid->reserved = 2U;
#line 4725
      capab_info = 0U;
    } else {
#line 4726
      tmp = ieee80211_is_probe_resp((int )mgmt->frame_control);
#line 4726
      if (tmp != 0) {
#line 4727
        ie_offset = 36U;
#line 4729
        bssid->reserved = 3U;
#line 4730
        capab_info = mgmt->u.probe_resp.capab_info;
      } else {
#line 4732
        bssid->reserved = 0U;
#line 4733
        ie_offset = 36U;
#line 4734
        capab_info = mgmt->u.beacon.capab_info;
      }
    }
  }
#line 4736
  ie_offset = (unsigned int )ie_offset - 24U;
#line 4738
  bssid->Length = length + 95U;
#line 4741
  bssid->IELength = length;
#line 4742
  __len = (size_t )bssid->IELength;
#line 4742
  __ret = __builtin_memcpy((void *)(& bssid->IEs), (void const   *)(& mgmt->u), __len);
#line 4746
  bssid->Rssi = (long )precv_frame->attrib.phy_info.RecvSignalPower;
#line 4747
  bssid->PhyInfo.SignalQuality = precv_frame->attrib.phy_info.SignalQuality;
#line 4749
  bssid->PhyInfo.SignalStrength = precv_frame->attrib.phy_info.SignalStrength;
#line 4753
  p = cfg80211_find_ie(0, (u8 const   *)(& bssid->IEs) + (unsigned long )ie_offset,
                       (int )(bssid->IELength - (u32 )ie_offset));
#line 4756
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 4757
    if (GlobalDebugLevel23A > 3U) {
#line 4757
      printk("\016RTL8723AU: marc: cannot find SSID for survey event\n");
    } else {

    }
#line 4758
    return (0);
  } else {

  }
#line 4761
  if ((unsigned int )((unsigned char )*(p + 1UL)) > 32U) {
#line 4762
    if (GlobalDebugLevel23A > 3U) {
#line 4762
      printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info23a",
             4763, (int )*(p + 1UL));
    } else {

    }
#line 4764
    return (0);
  } else {

  }
#line 4766
  __len___0 = (size_t )*(p + 1UL);
#line 4766
  __ret___0 = __builtin_memcpy((void *)(& bssid->Ssid.ssid), (void const   *)p + 2U,
                               __len___0);
#line 4767
  bssid->Ssid.ssid_len = *(p + 1UL);
#line 4769
  memset((void *)(& bssid->SupportedRates), 0, 16UL);
#line 4772
  i = 0;
#line 4773
  p = cfg80211_find_ie(1, (u8 const   *)(& bssid->IEs) + (unsigned long )ie_offset,
                       (int )(bssid->IELength - (u32 )ie_offset));
#line 4775
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 4776
    if ((unsigned int )((unsigned char )*(p + 1UL)) > 16U) {
#line 4777
      if (GlobalDebugLevel23A > 3U) {
#line 4777
        printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info23a",
               4778, (int )*(p + 1UL));
      } else {

      }
#line 4779
      return (0);
    } else {

    }
#line 4781
    __len___1 = (size_t )*(p + 1UL);
#line 4781
    __ret___1 = __builtin_memcpy((void *)(& bssid->SupportedRates), (void const   *)p + 2U,
                                 __len___1);
#line 4782
    i = (int )*(p + 1UL);
  } else {

  }
#line 4785
  p = cfg80211_find_ie(50, (u8 const   *)(& bssid->IEs) + (unsigned long )ie_offset,
                       (int )(bssid->IELength - (u32 )ie_offset));
#line 4787
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 4788
    if ((int )*(p + 1UL) > 16 - i) {
#line 4789
      if (GlobalDebugLevel23A > 3U) {
#line 4789
        printk("\016RTL8723AU: %s()-%d: IE too long (%d) for survey event\n", "collect_bss_info23a",
               4790, (int )*(p + 1UL));
      } else {

      }
#line 4791
      return (0);
    } else {

    }
#line 4793
    __len___2 = (size_t )*(p + 1UL);
#line 4793
    __ret___2 = __builtin_memcpy((void *)(& bssid->SupportedRates) + (unsigned long )i,
                                 (void const   *)p + 2U, __len___2);
  } else {

  }
#line 4796
  if (bssid->IELength <= 11U) {
#line 4797
    return (0);
  } else {

  }
#line 4800
  p = cfg80211_find_ie(3, (u8 const   *)(& bssid->IEs) + (unsigned long )ie_offset,
                       (int )(bssid->IELength - (u32 )ie_offset));
#line 4803
  bssid->DSConfig = 0U;
#line 4805
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 4806
    bssid->DSConfig = (u32 )*(p + 2UL);
  } else {
#line 4809
    p = cfg80211_find_ie(61, (u8 const   *)(& bssid->IEs) + (unsigned long )ie_offset,
                         (int )(bssid->IELength - (u32 )ie_offset));
#line 4812
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 4813
      HT_info = (struct HT_info_element *)p + 2U;
#line 4815
      bssid->DSConfig = (u32 )HT_info->primary_channel;
    } else {
#line 4817
      tmp___2 = rtw_get_oper_ch23a(padapter);
#line 4817
      bssid->DSConfig = (u32 )tmp___2;
    }
  }
#line 4820
  tmp___3 = ieee80211_is_probe_req((int )mgmt->frame_control);
#line 4820
  if (tmp___3 != 0) {
#line 4822
    bssid->ifmode = 2;
#line 4823
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const   *)(& mgmt->sa));
#line 4824
    bssid->Privacy = 1U;
#line 4825
    return (1);
  } else {

  }
#line 4828
  tmp___4 = rtw_get_beacon_interval23a_from_ie((u8 *)(& bssid->IEs));
#line 4828
  bssid->BeaconPeriod = get_unaligned_le16((void const   *)tmp___4);
#line 4831
  if ((int )capab_info & 1) {
#line 4832
    bssid->ifmode = 2;
#line 4833
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const   *)(& mgmt->sa));
  } else {
#line 4835
    bssid->ifmode = 1;
#line 4836
    ether_addr_copy((u8 *)(& bssid->MacAddress), (u8 const   *)(& mgmt->bssid));
  }
#line 4839
  if (((unsigned long )capab_info & 16UL) != 0UL) {
#line 4840
    bssid->Privacy = 1U;
  } else {
#line 4842
    bssid->Privacy = 0U;
  }
#line 4844
  bssid->ATIMWindow = 0U;
#line 4847
  if ((unsigned int )pregistrypriv->wifi_spec == 1U && (unsigned int )pmlmeinfo->bwmode_updated == 0U) {
#line 4849
    pmlmepriv = & padapter->mlmepriv;
#line 4851
    p = cfg80211_find_ie(45, (u8 const   *)(& bssid->IEs) + (unsigned long )ie_offset,
                         (int )(bssid->IELength - (u32 )ie_offset));
#line 4854
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 4856
      pHT_caps = (struct HT_caps_element *)p + 2U;
#line 4858
      if (((unsigned long )pHT_caps->u.HT_cap_element.HT_caps_info & 16384UL) != 0UL) {
#line 4859
        pmlmepriv->num_FortyMHzIntolerant = pmlmepriv->num_FortyMHzIntolerant + 1;
      } else {

      }
    } else {
#line 4861
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht + 1;
    }
  } else {

  }
#line 4866
  tmp___5 = rtw_get_oper_ch23a(padapter);
#line 4866
  if (bssid->DSConfig != (u32 )tmp___5) {
#line 4867
    bssid->PhyInfo.SignalQuality = 101U;
  } else {

  }
#line 4869
  return (1);
}
}
#line 4872 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void start_create_ibss(struct rtw_adapter *padapter ) 
{ 
  unsigned short caps ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  int tmp ;

  {
#line 4875
  pmlmeext = & padapter->mlmeextpriv;
#line 4876
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4877
  pnetwork = & pmlmeinfo->network;
#line 4878
  pmlmeext->cur_channel = (unsigned char )pnetwork->DSConfig;
#line 4879
  pmlmeinfo->bcn_interval = get_beacon_interval23a(pnetwork);
#line 4882
  update_wireless_mode23a(padapter);
#line 4885
  caps = rtw_get_capability23a(pnetwork);
#line 4886
  update_capinfo23a(padapter, (int )caps);
#line 4887
  if (((int )caps & 2) != 0) {
#line 4888
    rtl8723a_set_sec_cfg(padapter, 207);
#line 4892
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, 0, 0);
#line 4894
    rtl8723a_SetBeaconRelatedRegisters(padapter);
#line 4897
    pmlmeinfo->state = 1U;
#line 4898
    Set_MSR23a(padapter, (int )((u8 )pmlmeinfo->state) & 3);
#line 4901
    tmp = send_beacon23a(padapter);
#line 4901
    if (tmp == 0) {
#line 4903
      if (GlobalDebugLevel23A > 3U) {
#line 4903
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 4903
        printk("\016issuing beacon frame fail....\n");
      } else {

      }
#line 4905
      report_join_res23a(padapter, -1);
#line 4906
      pmlmeinfo->state = 0U;
    } else {
#line 4910
      hw_var_set_bssid(padapter, (u8 *)(& padapter->registrypriv.dev_network.MacAddress));
#line 4911
      hw_var_set_mlme_join(padapter, 0);
#line 4913
      report_join_res23a(padapter, 1);
#line 4914
      pmlmeinfo->state = pmlmeinfo->state | 16384U;
    }
  } else {
#line 4919
    if (GlobalDebugLevel23A > 3U) {
#line 4919
      printk("\016RTL8723AU: %s: invalid cap:%x\n", "start_create_ibss", (int )caps);
    } else {

    }
#line 4920
    return;
  }
#line 4922
  return;
}
}
#line 4924 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void start_clnt_join(struct rtw_adapter *padapter ) 
{ 
  unsigned short caps ;
  u8 val8 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  int beacon_timeout ;
  unsigned int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 4928
  pmlmeext = & padapter->mlmeextpriv;
#line 4929
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4930
  pnetwork = & pmlmeinfo->network;
#line 4933
  pmlmeext->cur_channel = (unsigned char )pnetwork->DSConfig;
#line 4934
  pmlmeinfo->bcn_interval = get_beacon_interval23a(pnetwork);
#line 4937
  update_wireless_mode23a(padapter);
#line 4940
  caps = rtw_get_capability23a(pnetwork);
#line 4941
  update_capinfo23a(padapter, (int )caps);
#line 4942
  if ((int )caps & 1) {
#line 4944
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
#line 4946
    Set_MSR23a(padapter, 2);
#line 4948
    val8 = pmlmeinfo->auth_algo == 2U ? 204U : 207U;
#line 4951
    rtl8723a_set_sec_cfg(padapter, (int )val8);
#line 4958
    tmp = decide_wait_for_beacon_timeout23a((unsigned int )pmlmeinfo->bcn_interval);
#line 4958
    beacon_timeout = (int )tmp;
#line 4959
    tmp___0 = msecs_to_jiffies((unsigned int const   )beacon_timeout);
#line 4959
    ldv_mod_timer_539(& pmlmeext->link_timer, tmp___0 + (unsigned long )jiffies);
#line 4960
    tmp___1 = msecs_to_jiffies((unsigned int const   )(beacon_timeout + 2400));
#line 4960
    ldv_mod_timer_540(& padapter->mlmepriv.assoc_timer, tmp___1 + (unsigned long )jiffies);
#line 4962
    pmlmeinfo->state = 258U;
  } else
#line 4963
  if (((int )caps & 2) != 0) {
#line 4964
    Set_MSR23a(padapter, 1);
#line 4966
    rtl8723a_set_sec_cfg(padapter, 207);
#line 4969
    set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                          (int )pmlmeext->cur_bwmode);
#line 4971
    rtl8723a_SetBeaconRelatedRegisters(padapter);
#line 4973
    pmlmeinfo->state = 1U;
#line 4975
    report_join_res23a(padapter, 1);
  } else {
#line 4980
    return;
  }
#line 4981
  return;
}
}
#line 4984 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void start_clnt_auth(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;

  {
#line 4986
  pmlmeext = & padapter->mlmeextpriv;
#line 4987
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 4989
  ldv_del_timer_sync_541(& pmlmeext->link_timer);
#line 4991
  pmlmeinfo->state = pmlmeinfo->state & 4294967039U;
#line 4992
  pmlmeinfo->state = pmlmeinfo->state | 512U;
#line 4994
  pmlmeinfo->auth_seq = 1U;
#line 4995
  pmlmeinfo->reauth_count = 0U;
#line 4996
  pmlmeinfo->reassoc_count = 0U;
#line 4997
  pmlmeinfo->link_count = 0U;
#line 4998
  pmlmeext->retry = 0U;
#line 5005
  issue_deauth23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress), 3);
#line 5007
  if (GlobalDebugLevel23A != 0U) {
#line 5007
    printk("\016RTL8723AU: OLD_ERROR start auth\n");
  } else {

  }
#line 5008
  issue_auth(padapter, (struct sta_info *)0, 0);
#line 5010
  tmp = msecs_to_jiffies(300U);
#line 5010
  ldv_mod_timer_542(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
#line 5011
  return;
}
}
#line 5013 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void start_clnt_assoc(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;

  {
#line 5015
  pmlmeext = & padapter->mlmeextpriv;
#line 5016
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5018
  ldv_del_timer_sync_543(& pmlmeext->link_timer);
#line 5020
  pmlmeinfo->state = pmlmeinfo->state & 4294966527U;
#line 5021
  pmlmeinfo->state = pmlmeinfo->state | 9216U;
#line 5023
  issue_assocreq(padapter);
#line 5025
  tmp = msecs_to_jiffies(300U);
#line 5025
  ldv_mod_timer_544(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
#line 5026
  return;
}
}
#line 5028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int receive_disconnect23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                          unsigned short reason ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 5031
  pmlmeext = & padapter->mlmeextpriv;
#line 5032
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5035
  tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 5035
  tmp___0 = ether_addr_equal((u8 const   *)MacAddr, (u8 const   *)tmp);
#line 5035
  if (tmp___0) {
#line 5035
    tmp___1 = 0;
  } else {
#line 5035
    tmp___1 = 1;
  }
#line 5035
  if (tmp___1) {
#line 5036
    return (1);
  } else {

  }
#line 5038
  if (GlobalDebugLevel23A > 3U) {
#line 5038
    printk("\016RTL8723AU: %s\n", "receive_disconnect23a");
  } else {

  }
#line 5040
  if ((pmlmeinfo->state & 3U) == 2U) {
#line 5042
    if ((pmlmeinfo->state & 16384U) != 0U) {
#line 5044
      pmlmeinfo->state = 0U;
#line 5045
      report_del_sta_event23a(padapter, MacAddr, (int )reason);
    } else
#line 5048
    if ((pmlmeinfo->state & 9984U) != 0U) {
#line 5050
      pmlmeinfo->state = 0U;
#line 5051
      report_join_res23a(padapter, -2);
    } else {

    }
  } else {

  }
#line 5055
  return (1);
}
}
#line 5058 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void process_80211d(struct rtw_adapter *padapter , struct wlan_bssid_ex *bssid ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct rt_channel_info *chplan_new ;
  u8 channel ;
  u8 i ;
  u8 const   *ie ;
  u8 const   *p ;
  struct rt_channel_plan chplan_ap ;
  struct rt_channel_info chplan_sta[38U] ;
  u8 country[4U] ;
  u8 fcn ;
  u8 noc ;
  u8 j ;
  u8 k ;
  size_t __len ;
  void *__ret ;
  u8 const   *tmp ;
  u8 const   *tmp___0 ;
  u8 tmp___1 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 5067
  pregistrypriv = & padapter->registrypriv;
#line 5068
  pmlmeext = & padapter->mlmeextpriv;
#line 5071
  if ((unsigned int )pregistrypriv->enable80211d != 0U && (unsigned int )pmlmeext->update_channel_plan_by_ap_done == 0U) {
#line 5081
    ie = cfg80211_find_ie(7, (u8 const   *)(& bssid->IEs) + 12U, (int )(bssid->IELength - 12U));
#line 5084
    if ((unsigned long )ie == (unsigned long )((u8 const   *)0U) || (unsigned int )((unsigned char )*(ie + 1UL)) <= 5U) {
#line 5085
      return;
    } else {

    }
#line 5087
    p = ie + 2UL;
#line 5088
    ie = ie + (unsigned long )*(ie + 1UL);
#line 5089
    ie = ie + 2UL;
#line 5091
    __len = 3UL;
#line 5091
    if (__len > 63UL) {
#line 5091
      __ret = __memcpy((void *)(& country), (void const   *)p, __len);
    } else {
#line 5091
      __ret = __builtin_memcpy((void *)(& country), (void const   *)p, __len);
    }
#line 5092
    country[3] = 0U;
#line 5094
    p = p + 3UL;
#line 5095
    if (GlobalDebugLevel23A > 5U) {
#line 5095
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
#line 5095
      printk("\016%s: 802.11d country =%s\n", "process_80211d", (u8 *)(& country));
    } else {

    }
#line 5098
    i = 0U;
#line 5099
    goto ldv_55580;
    ldv_55579: 
#line 5100
    tmp = p;
#line 5100
    p = p + 1;
#line 5100
    fcn = *tmp;
#line 5101
    tmp___0 = p;
#line 5101
    p = p + 1;
#line 5101
    noc = *tmp___0;
#line 5102
    p = p + 1;
#line 5104
    j = 0U;
#line 5104
    goto ldv_55577;
    ldv_55576: ;
#line 5105
    if ((unsigned int )fcn <= 14U) {
#line 5106
      channel = (int )fcn + (int )j;
    } else {
#line 5108
      channel = (unsigned int )j * 4U + (unsigned int )fcn;
    }
#line 5110
    tmp___1 = i;
#line 5110
    i = (u8 )((int )i + 1);
#line 5110
    chplan_ap.Channel[(int )tmp___1] = channel;
#line 5104
    j = (u8 )((int )j + 1);
    ldv_55577: ;
#line 5104
    if ((int )j < (int )noc) {
#line 5106
      goto ldv_55576;
    } else {

    }

    ldv_55580: ;
#line 5099
    if ((long )ie - (long )p > 2L) {
#line 5101
      goto ldv_55579;
    } else {

    }
#line 5113
    chplan_ap.Len = i;
#line 5115
    __len___0 = 304UL;
#line 5115
    if (__len___0 > 63UL) {
#line 5115
      __ret___0 = __memcpy((void *)(& chplan_sta), (void const   *)(& pmlmeext->channel_set),
                           __len___0);
    } else {
#line 5115
      __ret___0 = __builtin_memcpy((void *)(& chplan_sta), (void const   *)(& pmlmeext->channel_set),
                                   __len___0);
    }
#line 5116
    memset((void *)(& pmlmeext->channel_set), 0, 304UL);
#line 5117
    chplan_new = (struct rt_channel_info *)(& pmlmeext->channel_set);
#line 5119
    k = 0U;
#line 5119
    j = k;
#line 5119
    i = j;
#line 5120
    if (((int )pregistrypriv->wireless_mode & 2) != 0) {
      ldv_55586: ;
#line 5122
      if (((unsigned int )i == 38U || (unsigned int )chplan_sta[(int )i].ChannelNum == 0U) || (unsigned int )chplan_sta[(int )i].ChannelNum > 14U) {
#line 5125
        goto ldv_55585;
      } else {

      }
#line 5127
      if ((int )chplan_ap.Len == (int )j || (unsigned int )chplan_ap.Channel[(int )j] > 14U) {
#line 5129
        goto ldv_55585;
      } else {

      }
#line 5131
      if ((int )chplan_sta[(int )i].ChannelNum == (int )chplan_ap.Channel[(int )j]) {
#line 5133
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 5135
        (chplan_new + (unsigned long )k)->ScanType = 1;
#line 5136
        i = (u8 )((int )i + 1);
#line 5137
        j = (u8 )((int )j + 1);
#line 5138
        k = (u8 )((int )k + 1);
      } else
#line 5139
      if ((int )chplan_sta[(int )i].ChannelNum < (int )chplan_ap.Channel[(int )j]) {
#line 5141
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 5143
        (chplan_new + (unsigned long )k)->ScanType = 0;
#line 5145
        i = (u8 )((int )i + 1);
#line 5146
        k = (u8 )((int )k + 1);
      } else
#line 5147
      if ((int )chplan_sta[(int )i].ChannelNum > (int )chplan_ap.Channel[(int )j]) {
#line 5149
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 5151
        (chplan_new + (unsigned long )k)->ScanType = 1;
#line 5153
        j = (u8 )((int )j + 1);
#line 5154
        k = (u8 )((int )k + 1);
      } else {

      }
#line 5156
      goto ldv_55586;
      ldv_55585: ;
#line 5159
      goto ldv_55588;
      ldv_55587: 
#line 5162
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 5164
      (chplan_new + (unsigned long )k)->ScanType = 0;
#line 5165
      i = (u8 )((int )i + 1);
#line 5166
      k = (u8 )((int )k + 1);
      ldv_55588: ;
#line 5159
      if (((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) && (unsigned int )chplan_sta[(int )i].ChannelNum <= 14U) {
#line 5163
        goto ldv_55587;
      } else {

      }

#line 5170
      goto ldv_55591;
      ldv_55590: 
#line 5171
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 5172
      (chplan_new + (unsigned long )k)->ScanType = 1;
#line 5173
      j = (u8 )((int )j + 1);
#line 5174
      k = (u8 )((int )k + 1);
      ldv_55591: ;
#line 5170
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] <= 14U) {
#line 5172
        goto ldv_55590;
      } else {

      }

    } else {
#line 5178
      goto ldv_55594;
      ldv_55593: 
#line 5181
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 5183
      (chplan_new + (unsigned long )k)->ScanType = chplan_sta[(int )i].ScanType;
#line 5184
      i = (u8 )((int )i + 1);
#line 5185
      k = (u8 )((int )k + 1);
      ldv_55594: ;
#line 5178
      if (((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) && (unsigned int )chplan_sta[(int )i].ChannelNum <= 14U) {
#line 5182
        goto ldv_55593;
      } else {

      }

#line 5189
      goto ldv_55597;
      ldv_55596: 
#line 5190
      j = (u8 )((int )j + 1);
      ldv_55597: ;
#line 5189
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] <= 14U) {
#line 5191
        goto ldv_55596;
      } else {

      }

    }
#line 5193
    if (((int )pregistrypriv->wireless_mode & 4) != 0) {
      ldv_55600: ;
#line 5195
      if ((unsigned int )i == 38U || (unsigned int )chplan_sta[(int )i].ChannelNum == 0U) {
#line 5197
        goto ldv_55599;
      } else {

      }
#line 5199
      if ((int )chplan_ap.Len == (int )j || (unsigned int )chplan_ap.Channel[(int )j] == 0U) {
#line 5201
        goto ldv_55599;
      } else {

      }
#line 5203
      if ((int )chplan_sta[(int )i].ChannelNum == (int )chplan_ap.Channel[(int )j]) {
#line 5205
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 5207
        (chplan_new + (unsigned long )k)->ScanType = 1;
#line 5208
        i = (u8 )((int )i + 1);
#line 5209
        j = (u8 )((int )j + 1);
#line 5210
        k = (u8 )((int )k + 1);
      } else
#line 5211
      if ((int )chplan_sta[(int )i].ChannelNum < (int )chplan_ap.Channel[(int )j]) {
#line 5213
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 5215
        (chplan_new + (unsigned long )k)->ScanType = 0;
#line 5216
        i = (u8 )((int )i + 1);
#line 5217
        k = (u8 )((int )k + 1);
      } else
#line 5218
      if ((int )chplan_sta[(int )i].ChannelNum > (int )chplan_ap.Channel[(int )j]) {
#line 5220
        (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 5222
        (chplan_new + (unsigned long )k)->ScanType = 1;
#line 5223
        j = (u8 )((int )j + 1);
#line 5224
        k = (u8 )((int )k + 1);
      } else {

      }
#line 5226
      goto ldv_55600;
      ldv_55599: ;
#line 5229
      goto ldv_55602;
      ldv_55601: 
#line 5231
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 5233
      (chplan_new + (unsigned long )k)->ScanType = 0;
#line 5234
      i = (u8 )((int )i + 1);
#line 5235
      k = (u8 )((int )k + 1);
      ldv_55602: ;
#line 5229
      if ((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) {
#line 5232
        goto ldv_55601;
      } else {

      }

#line 5239
      goto ldv_55605;
      ldv_55604: 
#line 5240
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_ap.Channel[(int )j];
#line 5241
      (chplan_new + (unsigned long )k)->ScanType = 1;
#line 5242
      j = (u8 )((int )j + 1);
#line 5243
      k = (u8 )((int )k + 1);
      ldv_55605: ;
#line 5239
      if ((int )chplan_ap.Len > (int )j && (unsigned int )chplan_ap.Channel[(int )j] != 0U) {
#line 5241
        goto ldv_55604;
      } else {

      }

    } else {
#line 5247
      goto ldv_55608;
      ldv_55607: 
#line 5249
      (chplan_new + (unsigned long )k)->ChannelNum = chplan_sta[(int )i].ChannelNum;
#line 5251
      (chplan_new + (unsigned long )k)->ScanType = chplan_sta[(int )i].ScanType;
#line 5252
      i = (u8 )((int )i + 1);
#line 5253
      k = (u8 )((int )k + 1);
      ldv_55608: ;
#line 5247
      if ((unsigned int )i <= 37U && (unsigned int )chplan_sta[(int )i].ChannelNum != 0U) {
#line 5250
        goto ldv_55607;
      } else {

      }

    }
#line 5256
    pmlmeext->update_channel_plan_by_ap_done = 1U;
  } else {

  }
#line 5260
  channel = (u8 )bssid->DSConfig;
#line 5261
  chplan_new = (struct rt_channel_info *)(& pmlmeext->channel_set);
#line 5262
  i = 0U;
#line 5263
  goto ldv_55612;
  ldv_55611: ;
#line 5264
  if ((int )(chplan_new + (unsigned long )i)->ChannelNum == (int )channel) {
#line 5265
    if ((unsigned int )(chplan_new + (unsigned long )i)->ScanType == 0U) {
#line 5268
      if ((unsigned int )channel > 51U && (unsigned int )channel <= 144U) {
#line 5269
        goto ldv_55610;
      } else {

      }
#line 5271
      (chplan_new + (unsigned long )i)->ScanType = 1;
#line 5272
      if (GlobalDebugLevel23A > 5U) {
#line 5272
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 6);
#line 5272
        printk("\016%s: change channel %d scan type from passive to active\n", "process_80211d",
               (int )channel);
      } else {

      }
    } else {

    }
#line 5277
    goto ldv_55610;
  } else {

  }
#line 5279
  i = (u8 )((int )i + 1);
  ldv_55612: ;
#line 5263
  if ((unsigned int )i <= 37U && (unsigned int )(chplan_new + (unsigned long )i)->ChannelNum != 0U) {
#line 5265
    goto ldv_55611;
  } else {

  }
  ldv_55610: ;
#line 5270
  return;
}
}
#line 5289 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void report_survey_event23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct survey_event *psurvey_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 5299
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 5300
    return;
  } else {

  }
#line 5302
  pmlmeext = & padapter->mlmeextpriv;
#line 5303
  pcmdpriv = & padapter->cmdpriv;
#line 5305
  tmp = kzalloc(128UL, 32U);
#line 5305
  pcmd_obj = (struct cmd_obj *)tmp;
#line 5307
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 5308
    return;
  } else {

  }
#line 5310
  cmdsz = 871U;
#line 5311
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 5311
  pevtcmd = (u8 *)tmp___0;
#line 5312
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 5313
    kfree((void const   *)pcmd_obj);
#line 5314
    return;
  } else {

  }
#line 5317
  pcmd_obj->cmdcode = 56U;
#line 5318
  pcmd_obj->cmdsz = cmdsz;
#line 5319
  pcmd_obj->parmbuf = pevtcmd;
#line 5321
  pcmd_obj->rsp = (u8 *)0U;
#line 5322
  pcmd_obj->rspsz = 0U;
#line 5324
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 5325
  pc2h_evt_hdr->len = 863U;
#line 5326
  pc2h_evt_hdr->ID = 8U;
#line 5327
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 5327
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 5329
  psurvey_evt = (struct survey_event *)pevtcmd + 8U;
#line 5331
  tmp___2 = collect_bss_info23a(padapter, precv_frame, & psurvey_evt->bss);
#line 5331
  if (tmp___2 == 0) {
#line 5332
    kfree((void const   *)pcmd_obj);
#line 5333
    kfree((void const   *)pevtcmd);
#line 5334
    return;
  } else {

  }
#line 5337
  process_80211d(padapter, & psurvey_evt->bss);
#line 5339
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 5341
  pmlmeext->sitesurvey_res.bss_cnt = pmlmeext->sitesurvey_res.bss_cnt + 1;
#line 5343
  return;
}
}
#line 5346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void report_surveydone_event23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct surveydone_event *psurveydone_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 5353
  pmlmeext = & padapter->mlmeextpriv;
#line 5354
  pcmdpriv = & padapter->cmdpriv;
#line 5356
  tmp = kzalloc(128UL, 32U);
#line 5356
  pcmd_obj = (struct cmd_obj *)tmp;
#line 5358
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 5359
    return;
  } else {

  }
#line 5361
  cmdsz = 12U;
#line 5362
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 5362
  pevtcmd = (u8 *)tmp___0;
#line 5363
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 5364
    kfree((void const   *)pcmd_obj);
#line 5365
    return;
  } else {

  }
#line 5368
  pcmd_obj->cmdcode = 56U;
#line 5369
  pcmd_obj->cmdsz = cmdsz;
#line 5370
  pcmd_obj->parmbuf = pevtcmd;
#line 5372
  pcmd_obj->rsp = (u8 *)0U;
#line 5373
  pcmd_obj->rspsz = 0U;
#line 5375
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 5376
  pc2h_evt_hdr->len = 4U;
#line 5377
  pc2h_evt_hdr->ID = 9U;
#line 5378
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 5378
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 5380
  psurveydone_evt = (struct surveydone_event *)pevtcmd + 8U;
#line 5381
  psurveydone_evt->bss_cnt = (unsigned int )pmlmeext->sitesurvey_res.bss_cnt;
#line 5383
  if (GlobalDebugLevel23A > 3U) {
#line 5383
    printk("\016RTL8723AU: survey done event(%x)\n", psurveydone_evt->bss_cnt);
  } else {

  }
#line 5385
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 5387
  return;
}
}
#line 5390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void report_join_res23a(struct rtw_adapter *padapter , int res ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct joinbss_event *pjoinbss_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  int tmp___2 ;

  {
#line 5397
  pmlmeext = & padapter->mlmeextpriv;
#line 5398
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5399
  pcmdpriv = & padapter->cmdpriv;
#line 5401
  tmp = kzalloc(128UL, 32U);
#line 5401
  pcmd_obj = (struct cmd_obj *)tmp;
#line 5403
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 5404
    return;
  } else {

  }
#line 5406
  cmdsz = 936U;
#line 5407
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 5407
  pevtcmd = (u8 *)tmp___0;
#line 5408
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 5409
    kfree((void const   *)pcmd_obj);
#line 5410
    return;
  } else {

  }
#line 5413
  pcmd_obj->cmdcode = 56U;
#line 5414
  pcmd_obj->cmdsz = cmdsz;
#line 5415
  pcmd_obj->parmbuf = pevtcmd;
#line 5417
  pcmd_obj->rsp = (u8 *)0U;
#line 5418
  pcmd_obj->rspsz = 0U;
#line 5420
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 5421
  pc2h_evt_hdr->len = 928U;
#line 5422
  pc2h_evt_hdr->ID = 10U;
#line 5423
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 5423
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 5425
  pjoinbss_evt = (struct joinbss_event *)pevtcmd + 8U;
#line 5426
  __len = 863UL;
#line 5426
  if (__len > 63UL) {
#line 5426
    __ret = __memcpy((void *)(& pjoinbss_evt->network.network), (void const   *)(& pmlmeinfo->network),
                     __len);
  } else {
#line 5426
    __ret = __builtin_memcpy((void *)(& pjoinbss_evt->network.network), (void const   *)(& pmlmeinfo->network),
                             __len);
  }
#line 5428
  tmp___2 = res;
#line 5428
  pjoinbss_evt->network.aid = tmp___2;
#line 5428
  pjoinbss_evt->network.join_res = tmp___2;
#line 5430
  if (GlobalDebugLevel23A > 3U) {
#line 5430
    printk("\016RTL8723AU: report_join_res23a(%d)\n", res);
  } else {

  }
#line 5432
  rtw_joinbss_event_prehandle23a(padapter, (u8 *)(& pjoinbss_evt->network));
#line 5434
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 5436
  return;
}
}
#line 5439 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void report_del_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             unsigned short reason ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct sta_info *psta ;
  int mac_id ;
  struct stadel_event *pdel_sta_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 5448
  pmlmeext = & padapter->mlmeextpriv;
#line 5449
  pcmdpriv = & padapter->cmdpriv;
#line 5451
  tmp = kzalloc(128UL, 32U);
#line 5451
  pcmd_obj = (struct cmd_obj *)tmp;
#line 5453
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 5454
    return;
  } else {

  }
#line 5456
  cmdsz = 20U;
#line 5457
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 5457
  pevtcmd = (u8 *)tmp___0;
#line 5458
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 5459
    kfree((void const   *)pcmd_obj);
#line 5460
    return;
  } else {

  }
#line 5463
  pcmd_obj->cmdcode = 56U;
#line 5464
  pcmd_obj->cmdsz = cmdsz;
#line 5465
  pcmd_obj->parmbuf = pevtcmd;
#line 5467
  pcmd_obj->rsp = (u8 *)0U;
#line 5468
  pcmd_obj->rspsz = 0U;
#line 5470
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 5471
  pc2h_evt_hdr->len = 12U;
#line 5472
  pc2h_evt_hdr->ID = 12U;
#line 5473
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 5473
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 5475
  pdel_sta_evt = (struct stadel_event *)pevtcmd + 8U;
#line 5476
  ether_addr_copy((u8 *)(& pdel_sta_evt->macaddr), (u8 const   *)MacAddr);
#line 5477
  __len = 2UL;
#line 5477
  if (__len > 63UL) {
#line 5477
    __ret = __memcpy((void *)(& pdel_sta_evt->rsvd), (void const   *)(& reason), __len);
  } else {
#line 5477
    __ret = __builtin_memcpy((void *)(& pdel_sta_evt->rsvd), (void const   *)(& reason),
                             __len);
  }
#line 5480
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)MacAddr);
#line 5481
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 5482
    mac_id = (int )psta->mac_id;
  } else {
#line 5484
    mac_id = -1;
  }
#line 5486
  pdel_sta_evt->mac_id = mac_id;
#line 5488
  if (GlobalDebugLevel23A > 3U) {
#line 5488
    printk("\016RTL8723AU: report_del_sta_event23a: delete STA, mac_id =%d\n", mac_id);
  } else {

  }
#line 5490
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 5492
  return;
}
}
#line 5495 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void report_add_sta_event23a(struct rtw_adapter *padapter , unsigned char *MacAddr ,
                             int cam_idx ) 
{ 
  struct cmd_obj *pcmd_obj ;
  u8 *pevtcmd ;
  u32 cmdsz ;
  struct stassoc_event *padd_sta_evt ;
  struct C2HEvent_Header *pc2h_evt_hdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct cmd_priv *pcmdpriv ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 5502
  pmlmeext = & padapter->mlmeextpriv;
#line 5503
  pcmdpriv = & padapter->cmdpriv;
#line 5505
  tmp = kzalloc(128UL, 32U);
#line 5505
  pcmd_obj = (struct cmd_obj *)tmp;
#line 5507
  if ((unsigned long )pcmd_obj == (unsigned long )((struct cmd_obj *)0)) {
#line 5508
    return;
  } else {

  }
#line 5510
  cmdsz = 20U;
#line 5511
  tmp___0 = kzalloc((size_t )cmdsz, 32U);
#line 5511
  pevtcmd = (u8 *)tmp___0;
#line 5512
  if ((unsigned long )pevtcmd == (unsigned long )((u8 *)0U)) {
#line 5513
    kfree((void const   *)pcmd_obj);
#line 5514
    return;
  } else {

  }
#line 5517
  pcmd_obj->cmdcode = 56U;
#line 5518
  pcmd_obj->cmdsz = cmdsz;
#line 5519
  pcmd_obj->parmbuf = pevtcmd;
#line 5521
  pcmd_obj->rsp = (u8 *)0U;
#line 5522
  pcmd_obj->rspsz = 0U;
#line 5524
  pc2h_evt_hdr = (struct C2HEvent_Header *)pevtcmd;
#line 5525
  pc2h_evt_hdr->len = 12U;
#line 5526
  pc2h_evt_hdr->ID = 11U;
#line 5527
  tmp___1 = atomic_add_return(1, & pmlmeext->event_seq);
#line 5527
  pc2h_evt_hdr->seq = (unsigned char )tmp___1;
#line 5529
  padd_sta_evt = (struct stassoc_event *)pevtcmd + 8U;
#line 5530
  ether_addr_copy((u8 *)(& padd_sta_evt->macaddr), (u8 const   *)MacAddr);
#line 5531
  padd_sta_evt->cam_id = cam_idx;
#line 5533
  if (GlobalDebugLevel23A > 3U) {
#line 5533
    printk("\016RTL8723AU: report_add_sta_event23a: add STA\n");
  } else {

  }
#line 5535
  rtw_enqueue_cmd23a(pcmdpriv, pcmd_obj);
#line 5537
  return;
}
}
#line 5547 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void update_sta_info23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;

  {
#line 5549
  pmlmepriv = & padapter->mlmepriv;
#line 5550
  pmlmeext = & padapter->mlmeextpriv;
#line 5551
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5554
  VCS_update23a(padapter, psta);
#line 5557
  if (pmlmepriv->htpriv.ht_option != 0U) {
#line 5559
    psta->htpriv.ht_option = 1U;
#line 5561
    psta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;
#line 5563
    tmp = support_short_GI23a(padapter, & pmlmeinfo->HT_caps);
#line 5563
    if (tmp != 0) {
#line 5564
      psta->htpriv.sgi = 1U;
    } else {

    }
#line 5566
    psta->qos_option = 1U;
  } else {
#line 5571
    psta->htpriv.ht_option = 0U;
#line 5573
    psta->htpriv.ampdu_enable = 0U;
#line 5575
    psta->htpriv.sgi = 0U;
#line 5576
    psta->qos_option = 0U;
  }
#line 5579
  psta->htpriv.bwmode = pmlmeext->cur_bwmode;
#line 5580
  psta->htpriv.ch_offset = pmlmeext->cur_ch_offset;
#line 5582
  psta->htpriv.agg_enable_bitmap = 0U;
#line 5583
  psta->htpriv.candidate_tid_bitmap = 0U;
#line 5586
  if (pmlmepriv->qos_option != 0U) {
#line 5587
    psta->qos_option = 1U;
  } else {

  }
#line 5589
  psta->state = 1U;
#line 5590
  return;
}
}
#line 5592 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void mlmeext_joinbss_event_callback23a(struct rtw_adapter *padapter , int join_res ) 
{ 
  struct sta_info *psta ;
  struct sta_info *psta_bmc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_priv *pstapriv ;

  {
#line 5595
  pmlmeext = & padapter->mlmeextpriv;
#line 5596
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5597
  cur_network = & pmlmeinfo->network;
#line 5598
  pstapriv = & padapter->stapriv;
#line 5600
  if (join_res < 0) {
#line 5601
    hw_var_set_mlme_join(padapter, 1);
#line 5602
    hw_var_set_bssid(padapter, (u8 *)(& null_addr));
#line 5605
    update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
#line 5608
    goto exit_mlmeext_joinbss_event_callback23a;
  } else {

  }
#line 5611
  if ((pmlmeinfo->state & 3U) == 1U) {
#line 5614
    psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 5615
    if ((unsigned long )psta_bmc != (unsigned long )((struct sta_info *)0)) {
#line 5617
      pmlmeinfo->FW_sta_info[psta_bmc->mac_id].psta = psta_bmc;
#line 5618
      update_bmc_sta_support_rate23a(padapter, psta_bmc->mac_id);
#line 5619
      Update_RA_Entry23a(padapter, psta_bmc);
    } else {

    }
  } else {

  }
#line 5624
  rtl8723a_odm_support_ability_set(padapter, 268435455U);
#line 5627
  update_IOT_info23a(padapter);
#line 5629
  HalSetBrateCfg23a(padapter, (u8 *)(& cur_network->SupportedRates));
#line 5632
  rtl8723a_set_beacon_interval(padapter, (int )pmlmeinfo->bcn_interval);
#line 5635
  update_capinfo23a(padapter, (int )pmlmeinfo->capability);
#line 5638
  WMMOnAssocRsp23a(padapter);
#line 5641
  HTOnAssocRsp23a(padapter);
#line 5644
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 5646
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
#line 5647
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 5649
    pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
#line 5653
    psta->wireless_mode = pmlmeext->cur_wireless_mode;
#line 5656
    set_sta_rate23a(padapter, psta);
  } else {

  }
#line 5659
  hw_var_set_mlme_join(padapter, 2);
#line 5661
  if ((pmlmeinfo->state & 3U) == 2U) {
#line 5663
    rtw_correct_TSF(padapter);
  } else {

  }
#line 5668
  rtw_lps_ctrl_wk_cmd23a(padapter, 2, 0);
  exit_mlmeext_joinbss_event_callback23a: ;
#line 5671
  if (GlobalDebugLevel23A > 3U) {
#line 5671
    printk("\016RTL8723AU: =>%s\n", "mlmeext_joinbss_event_callback23a");
  } else {

  }
#line 5672
  return;
}
}
#line 5674 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void mlmeext_sta_add_event_callback23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;

  {
#line 5676
  pmlmeext = & padapter->mlmeextpriv;
#line 5677
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5679
  if (GlobalDebugLevel23A > 3U) {
#line 5679
    printk("\016RTL8723AU: %s\n", "mlmeext_sta_add_event_callback23a");
  } else {

  }
#line 5681
  if ((pmlmeinfo->state & 3U) == 1U) {
#line 5683
    if ((pmlmeinfo->state & 16384U) != 0U) {

    } else {
#line 5688
      rtw_correct_TSF(padapter);
#line 5691
      tmp = send_beacon23a(padapter);
#line 5691
      if (tmp != 1) {
#line 5692
        pmlmeinfo->FW_sta_info[psta->mac_id].status = 0U;
#line 5694
        pmlmeinfo->state = pmlmeinfo->state ^ 1U;
#line 5696
        return;
      } else {

      }
#line 5699
      pmlmeinfo->state = pmlmeinfo->state | 16384U;
    }
#line 5701
    hw_var_set_mlme_join(padapter, 2);
  } else {

  }
#line 5704
  pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
#line 5707
  Update_RA_Entry23a(padapter, psta);
#line 5710
  update_sta_info23a(padapter, psta);
#line 5711
  return;
}
}
#line 5713 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void mlmeext_sta_del_event_callback23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 5715
  pmlmeext = & padapter->mlmeextpriv;
#line 5716
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5718
  tmp = is_client_associated_to_ap23a(padapter);
#line 5718
  if ((int )tmp) {
#line 5718
    goto _L;
  } else {
#line 5718
    tmp___0 = is_IBSS_empty23a(padapter);
#line 5718
    if ((int )tmp___0) {
      _L: /* CIL Label */ 
#line 5722
      hw_var_set_mlme_disconnect(padapter);
#line 5723
      hw_var_set_bssid(padapter, (u8 *)(& null_addr));
#line 5726
      update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
#line 5730
      pmlmeext->cur_bwmode = 0U;
#line 5731
      pmlmeext->cur_ch_offset = 0U;
#line 5733
      set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                            (int )pmlmeext->cur_bwmode);
#line 5737
      flush_all_cam_entry23a(padapter);
#line 5739
      pmlmeinfo->state = 0U;
#line 5742
      Set_MSR23a(padapter, 2);
#line 5744
      ldv_del_timer_sync_545(& pmlmeext->link_timer);
    } else {

    }
  }
#line 5746
  return;
}
}
#line 5748 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static u8 chk_ap_is_alive(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 ret ;

  {
#line 5750
  ret = 0U;
#line 5752
  if ((psta->sta_stats.rx_data_pkts == psta->sta_stats.last_rx_data_pkts && psta->sta_stats.rx_beacon_pkts == psta->sta_stats.last_rx_beacon_pkts) && psta->sta_stats.rx_probersp_pkts == psta->sta_stats.last_rx_probersp_pkts) {
#line 5755
    ret = 0U;
  } else {
#line 5757
    ret = 1U;
  }
#line 5759
  psta->sta_stats.last_rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts;
#line 5759
  psta->sta_stats.last_rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts;
#line 5759
  psta->sta_stats.last_rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts;
#line 5759
  psta->sta_stats.last_rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts;
#line 5759
  psta->sta_stats.last_rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts;
#line 5759
  psta->sta_stats.last_rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts;
#line 5759
  psta->sta_stats.last_rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts;
#line 5759
  psta->sta_stats.last_rx_data_pkts = psta->sta_stats.rx_data_pkts;
#line 5760
  return (ret);
}
}
#line 5763 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void linked_status_chk23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct sta_info *psta ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_priv *pstapriv ;
  int tx_chk ;
  int rx_chk ;
  int rx_chk_limit ;
  bool is_p2p_enable ;
  u8 tmp ;
  u8 backup_oper_channel ;
  u8 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
#line 5767
  pxmitpriv = & padapter->xmitpriv;
#line 5768
  pmlmeext = & padapter->mlmeextpriv;
#line 5769
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5770
  pstapriv = & padapter->stapriv;
#line 5772
  rtl8723a_sreset_linked_status_check(padapter);
#line 5774
  tmp___4 = is_client_associated_to_ap23a(padapter);
#line 5774
  if ((int )tmp___4) {
#line 5777
    tx_chk = 1;
#line 5777
    rx_chk = 1;
#line 5780
    rx_chk_limit = 4;
#line 5782
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pmlmeinfo->network.MacAddress));
#line 5784
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 5785
      is_p2p_enable = 0;
#line 5787
      tmp = chk_ap_is_alive(padapter, psta);
#line 5787
      if ((unsigned int )tmp == 0U) {
#line 5788
        rx_chk = 0;
      } else {

      }
#line 5790
      if (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts) {
#line 5791
        tx_chk = 0;
      } else {

      }
#line 5793
      if ((unsigned int )pmlmeext->active_keep_alive_check != 0U && (rx_chk == 0 || tx_chk == 0)) {
#line 5795
        backup_oper_channel = 0U;
#line 5799
        tmp___0 = rtw_get_oper_ch23a(padapter);
#line 5799
        if ((int )tmp___0 != (int )pmlmeext->cur_channel) {
#line 5801
          backup_oper_channel = rtw_get_oper_ch23a(padapter);
#line 5803
          SelectChannel23a(padapter, (int )pmlmeext->cur_channel);
        } else {

        }
#line 5807
        if (rx_chk != 1) {
#line 5808
          issue_probereq_ex(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& psta->hwaddr),
                            3, 1);
        } else {

        }
#line 5810
        if (tx_chk != 1) {
#line 5810
          tmp___1 = pmlmeinfo->link_count;
#line 5810
          pmlmeinfo->link_count = pmlmeinfo->link_count + 1U;
#line 5810
          if (tmp___1 == 15U) {
#line 5810
            goto _L;
          } else {
#line 5810
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 5810
        if (rx_chk != 1) {
          _L: /* CIL Label */ 
#line 5813
          tx_chk = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr),
                                     0U, 3, 1);
#line 5819
          if (tx_chk == 1 && ! is_p2p_enable) {
#line 5821
            rx_chk = 1;
          } else {

          }
        } else {

        }
#line 5825
        if ((unsigned int )backup_oper_channel != 0U) {
#line 5826
          SelectChannel23a(padapter, (int )backup_oper_channel);
        } else {

        }
      } else {
#line 5829
        if (rx_chk != 1) {
#line 5830
          if (pmlmeext->retry == 0U) {
#line 5831
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
#line 5832
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
#line 5833
            issue_probereq(padapter, & pmlmeinfo->network.Ssid, (u8 *)(& pmlmeinfo->network.MacAddress));
          } else {

          }
        } else {

        }
#line 5837
        if (tx_chk != 1) {
#line 5837
          tmp___2 = pmlmeinfo->link_count;
#line 5837
          pmlmeinfo->link_count = pmlmeinfo->link_count + 1U;
#line 5837
          if (tmp___2 == 15U) {
#line 5839
            tx_chk = issue_nulldata23a(padapter, (unsigned char *)0U, 0U, 1, 0);
          } else {

          }
        } else {

        }
      }
#line 5844
      if (rx_chk == 0) {
#line 5845
        pmlmeext->retry = pmlmeext->retry + 1U;
#line 5846
        if (pmlmeext->retry > (u32 )rx_chk_limit) {
#line 5847
          if (GlobalDebugLevel23A != 0U) {
#line 5847
            printk("\016RTL8723AU: OLD_ERROR %s(%s): disconnect or roaming\n", "linked_status_chk23a",
                   (char *)(& (padapter->pnetdev)->name));
          } else {

          }
#line 5851
          receive_disconnect23a(padapter, (unsigned char *)(& pmlmeinfo->network.MacAddress),
                                65535);
#line 5853
          return;
        } else {

        }
      } else {
#line 5856
        pmlmeext->retry = 0U;
      }
#line 5858
      if (tx_chk == 0) {
#line 5859
        pmlmeinfo->link_count = pmlmeinfo->link_count & 15U;
      } else {
#line 5861
        pxmitpriv->last_tx_pkts = pxmitpriv->tx_pkts;
#line 5862
        pmlmeinfo->link_count = 0U;
      }
    } else {

    }
  } else {
#line 5866
    tmp___3 = is_client_associated_to_ibss23a(padapter);
#line 5866
    if ((int )tmp___3) {
#line 5869
      i = 2U;
#line 5869
      goto ldv_55731;
      ldv_55730: ;
#line 5870
      if (pmlmeinfo->FW_sta_info[i].status == 1U) {
#line 5871
        psta = pmlmeinfo->FW_sta_info[i].psta;
#line 5873
        if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 5874
          goto ldv_55729;
        } else {

        }
#line 5876
        if ((u64 )pmlmeinfo->FW_sta_info[i].rx_pkt == (psta->sta_stats.rx_mgnt_pkts + psta->sta_stats.rx_ctrl_pkts) + psta->sta_stats.rx_data_pkts) {
#line 5879
          if (pmlmeinfo->FW_sta_info[i].retry <= 2U) {
#line 5880
            pmlmeinfo->FW_sta_info[i].retry = pmlmeinfo->FW_sta_info[i].retry + 1U;
          } else {
#line 5882
            pmlmeinfo->FW_sta_info[i].retry = 0U;
#line 5883
            pmlmeinfo->FW_sta_info[i].status = 0U;
#line 5884
            report_del_sta_event23a(padapter, (unsigned char *)(& psta->hwaddr), 65535);
          }
        } else {
#line 5889
          pmlmeinfo->FW_sta_info[i].retry = 0U;
#line 5890
          pmlmeinfo->FW_sta_info[i].rx_pkt = ((unsigned int )psta->sta_stats.rx_mgnt_pkts + (unsigned int )psta->sta_stats.rx_ctrl_pkts) + (unsigned int )psta->sta_stats.rx_data_pkts;
        }
      } else {

      }
      ldv_55729: 
#line 5869
      i = i + 1U;
      ldv_55731: ;
#line 5869
      if (i <= 31U) {
#line 5871
        goto ldv_55730;
      } else {

      }

    } else {

    }
  }
#line 5877
  return;
}
}
#line 5898 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void survey_timer_hdl(unsigned long data ) 
{ 
  struct rtw_adapter *padapter ;
  struct cmd_obj *ph2c ;
  struct sitesurvey_parm *psurveyPara ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_ext_priv *pmlmeext ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 5900
  padapter = (struct rtw_adapter *)data;
#line 5903
  pcmdpriv = & padapter->cmdpriv;
#line 5904
  pmlmeext = & padapter->mlmeextpriv;
#line 5907
  if (pmlmeext->sitesurvey_res.state > 1) {
#line 5908
    if (pmlmeext->sitesurvey_res.state == 3) {
#line 5909
      pmlmeext->sitesurvey_res.channel_idx = pmlmeext->sitesurvey_res.channel_idx + 1;
    } else {

    }
#line 5911
    if ((unsigned int )pmlmeext->scan_abort == 1U) {
#line 5912
      pmlmeext->sitesurvey_res.channel_idx = (int )pmlmeext->sitesurvey_res.ch_num;
#line 5914
      if (GlobalDebugLevel23A > 3U) {
#line 5914
        printk("\016RTL8723AU: %s idx:%d\n", "survey_timer_hdl", pmlmeext->sitesurvey_res.channel_idx);
      } else {

      }
#line 5917
      pmlmeext->scan_abort = 0U;
    } else {

    }
#line 5920
    tmp = kzalloc(128UL, 32U);
#line 5920
    ph2c = (struct cmd_obj *)tmp;
#line 5922
    if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 5923
      goto exit_survey_timer_hdl;
    } else {

    }
#line 5925
    tmp___0 = kzalloc(712UL, 32U);
#line 5925
    psurveyPara = (struct sitesurvey_parm *)tmp___0;
#line 5927
    if ((unsigned long )psurveyPara == (unsigned long )((struct sitesurvey_parm *)0)) {
#line 5928
      kfree((void const   *)ph2c);
#line 5929
      goto exit_survey_timer_hdl;
    } else {

    }
#line 5932
    ph2c->cmdcode = 18U;
#line 5932
    ph2c->parmbuf = (u8 *)psurveyPara;
#line 5932
    ph2c->cmdsz = 712U;
#line 5932
    ph2c->rsp = (u8 *)0U;
#line 5932
    ph2c->rspsz = 0U;
#line 5934
    rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  } else {

  }
  exit_survey_timer_hdl: ;
#line 5938
  return;
}
}
#line 5941 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void link_timer_hdl(unsigned long data ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 5943
  padapter = (struct rtw_adapter *)data;
#line 5947
  pmlmeext = & padapter->mlmeextpriv;
#line 5948
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 5951
  if ((pmlmeinfo->state & 256U) != 0U) {
#line 5952
    if (GlobalDebugLevel23A > 3U) {
#line 5952
      printk("\016RTL8723AU: link_timer_hdl:no beacon while connecting\n");
    } else {

    }
#line 5953
    pmlmeinfo->state = 0U;
#line 5954
    report_join_res23a(padapter, -3);
  } else
#line 5955
  if ((pmlmeinfo->state & 512U) != 0U) {
#line 5957
    pmlmeinfo->reauth_count = pmlmeinfo->reauth_count + 1U;
#line 5957
    if (pmlmeinfo->reauth_count > 4U) {
#line 5960
      pmlmeinfo->state = 0U;
#line 5961
      report_join_res23a(padapter, -1);
#line 5962
      return;
    } else {

    }
#line 5971
    if (GlobalDebugLevel23A > 3U) {
#line 5971
      printk("\016RTL8723AU: link_timer_hdl: auth timeout and try again\n");
    } else {

    }
#line 5972
    pmlmeinfo->auth_seq = 1U;
#line 5973
    issue_auth(padapter, (struct sta_info *)0, 0);
#line 5974
    tmp = msecs_to_jiffies(300U);
#line 5974
    ldv_mod_timer_546(& pmlmeext->link_timer, tmp + (unsigned long )jiffies);
  } else
#line 5975
  if ((pmlmeinfo->state & 8192U) != 0U) {
#line 5977
    pmlmeinfo->reassoc_count = pmlmeinfo->reassoc_count + 1U;
#line 5977
    if (pmlmeinfo->reassoc_count > 4U) {
#line 5978
      pmlmeinfo->state = 0U;
#line 5979
      report_join_res23a(padapter, -2);
#line 5980
      return;
    } else {

    }
#line 5983
    if (GlobalDebugLevel23A > 3U) {
#line 5983
      printk("\016RTL8723AU: link_timer_hdl: assoc timeout and try again\n");
    } else {

    }
#line 5984
    issue_assocreq(padapter);
#line 5985
    tmp___0 = msecs_to_jiffies(300U);
#line 5985
    ldv_mod_timer_547(& pmlmeext->link_timer, tmp___0 + (unsigned long )jiffies);
  } else {

  }
#line 5988
  return;
}
}
#line 5991 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static void addba_timer_hdl(unsigned long data ) 
{ 
  struct sta_info *psta ;
  struct ht_priv *phtpriv ;

  {
#line 5993
  psta = (struct sta_info *)data;
#line 5996
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 5997
    return;
  } else {

  }
#line 5999
  phtpriv = & psta->htpriv;
#line 6001
  if (phtpriv->ht_option == 1U && phtpriv->ampdu_enable == 1U) {
#line 6002
    if ((unsigned int )phtpriv->candidate_tid_bitmap != 0U) {
#line 6003
      phtpriv->candidate_tid_bitmap = 0U;
    } else {

    }
  } else {

  }
#line 6004
  return;
}
}
#line 6007 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void init_addba_retry_timer23a(struct sta_info *psta ) 
{ 


  {
#line 6009
  reg_timer_6(& psta->addba_retry_timer, & addba_timer_hdl, (unsigned long )psta);
#line 6010
  return;
}
}
#line 6013 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void init_mlme_ext_timer23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;

  {
#line 6015
  pmlmeext = & padapter->mlmeextpriv;
#line 6017
  reg_timer_6(& pmlmeext->survey_timer, & survey_timer_hdl, (unsigned long )padapter);
#line 6020
  reg_timer_6(& pmlmeext->link_timer, & link_timer_hdl, (unsigned long )padapter);
#line 6021
  return;
}
}
#line 6024 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int NULL_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
#line 6026
  return (0);
}
}
#line 6029 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int setopmode_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  enum nl80211_iftype type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct setopmode_parm  const  *psetop ;

  {
#line 6032
  pmlmeext = & padapter->mlmeextpriv;
#line 6033
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6034
  psetop = (struct setopmode_parm  const  *)pbuf;
#line 6036
  switch ((unsigned int )psetop->mode) {
  case 9U: ;
  case 3U: 
#line 6039
  pmlmeinfo->state = 3U;
#line 6040
  type = 3;
#line 6041
  goto ldv_55775;
  case 8U: ;
  case 2U: 
#line 6045
  pmlmeinfo->state = pmlmeinfo->state & 4294967292U;
#line 6047
  pmlmeinfo->state = pmlmeinfo->state | 2U;
#line 6048
  type = 2;
#line 6049
  goto ldv_55775;
  case 1U: 
#line 6051
  type = 1;
#line 6052
  goto ldv_55775;
  default: 
#line 6054
  type = 0;
#line 6055
  goto ldv_55775;
  }
  ldv_55775: 
#line 6058
  hw_var_set_opmode(padapter, (int )((u8 )type));
#line 6061
  return (0);
}
}
#line 6064 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int createbss_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_bssid_ex  const  *pparm ;
  size_t __len ;
  void *__ret ;

  {
#line 6066
  pmlmeext = & padapter->mlmeextpriv;
#line 6067
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6068
  pnetwork = & pmlmeinfo->network;
#line 6069
  pparm = (struct wlan_bssid_ex  const  *)pbuf;
#line 6072
  if ((unsigned int )pparm->ifmode == 3U || (unsigned int )pparm->ifmode == 9U) {
#line 6075
    if (pmlmeinfo->state == 3U) {
#line 6077
      return (0);
    } else {

    }
  } else {

  }
#line 6083
  if ((unsigned int )pparm->ifmode == 1U) {
#line 6084
    rtw_joinbss_reset23a(padapter);
#line 6086
    pmlmeext->cur_bwmode = 0U;
#line 6087
    pmlmeext->cur_ch_offset = 0U;
#line 6088
    pmlmeinfo->ERP_enable = 0U;
#line 6089
    pmlmeinfo->WMM_enable = 0U;
#line 6090
    pmlmeinfo->HT_enable = 0U;
#line 6091
    pmlmeinfo->HT_caps_enable = 0U;
#line 6092
    pmlmeinfo->HT_info_enable = 0U;
#line 6095
    rtl8723a_odm_support_ability_backup(padapter);
#line 6097
    rtl8723a_odm_support_ability_clr(padapter, 0U);
#line 6101
    ldv_del_timer_sync_548(& pmlmeext->link_timer);
#line 6104
    flush_all_cam_entry23a(padapter);
#line 6106
    if ((unsigned int )pparm->IELength > 768U) {
#line 6107
      return (4);
    } else {

    }
#line 6109
    __len = 863UL;
#line 6109
    if (__len > 63UL) {
#line 6109
      __ret = __memcpy((void *)pnetwork, (void const   *)pparm, __len);
    } else {
#line 6109
      __ret = __builtin_memcpy((void *)pnetwork, (void const   *)pparm, __len);
    }
#line 6111
    start_create_ibss(padapter);
  } else {

  }
#line 6114
  return (0);
}
}
#line 6117 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int join_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  struct wlan_bssid_ex  const  *pparm ;
  struct HT_info_element *pht_info ;
  u32 i ;
  int bcn_fixed_size ;
  u8 *p ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 6119
  pregpriv = & padapter->registrypriv;
#line 6120
  pmlmeext = & padapter->mlmeextpriv;
#line 6121
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6122
  pnetwork = & pmlmeinfo->network;
#line 6123
  pparm = (struct wlan_bssid_ex  const  *)pbuf;
#line 6132
  if ((pmlmeinfo->state & 16384U) != 0U) {
#line 6133
    if ((pmlmeinfo->state & 2U) != 0U) {
#line 6134
      issue_deauth_ex(padapter, (u8 *)(& pnetwork->MacAddress), 3, 5, 100);
    } else {

    }
#line 6137
    pmlmeinfo->state = 0U;
#line 6140
    flush_all_cam_entry23a(padapter);
#line 6142
    ldv_del_timer_sync_549(& pmlmeext->link_timer);
#line 6146
    Set_MSR23a(padapter, 2);
#line 6148
    hw_var_set_mlme_disconnect(padapter);
  } else {

  }
#line 6151
  rtw_joinbss_reset23a(padapter);
#line 6153
  pmlmeext->cur_bwmode = 0U;
#line 6154
  pmlmeext->cur_ch_offset = 0U;
#line 6155
  pmlmeinfo->ERP_enable = 0U;
#line 6156
  pmlmeinfo->WMM_enable = 0U;
#line 6157
  pmlmeinfo->HT_enable = 0U;
#line 6158
  pmlmeinfo->HT_caps_enable = 0U;
#line 6159
  pmlmeinfo->HT_info_enable = 0U;
#line 6160
  pmlmeinfo->bwmode_updated = 0U;
#line 6163
  if ((unsigned int )pparm->IELength > 768U) {
#line 6164
    return (4);
  } else {

  }
#line 6166
  __len = 863UL;
#line 6166
  if (__len > 63UL) {
#line 6166
    __ret = __memcpy((void *)pnetwork, (void const   *)pbuf, __len);
  } else {
#line 6166
    __ret = __builtin_memcpy((void *)pnetwork, (void const   *)pbuf, __len);
  }
#line 6172
  bcn_fixed_size = 12;
#line 6175
  i = (u32 )bcn_fixed_size;
#line 6175
  goto ldv_55817;
  ldv_55816: 
#line 6176
  p = (u8 *)(& pnetwork->IEs) + (unsigned long )i;
#line 6178
  switch ((int )*p) {
  case 221: 
#line 6180
  tmp = memcmp((void const   *)p + 2U, (void const   *)(& WMM_OUI23A), 4UL);
#line 6180
  if (tmp == 0) {
#line 6181
    pmlmeinfo->WMM_enable = 1U;
  } else {

  }
#line 6182
  goto ldv_55808;
  case 45: 
#line 6185
  pmlmeinfo->HT_caps_enable = 1U;
#line 6186
  goto ldv_55808;
  case 61: 
#line 6189
  pmlmeinfo->HT_info_enable = 1U;
#line 6193
  pht_info = (struct HT_info_element *)p + 2U;
#line 6195
  if ((unsigned int )pregpriv->cbw40_enable != 0U && ((unsigned long )pht_info->infos[0] & 4UL) != 0UL) {
#line 6198
    pmlmeext->cur_bwmode = 1U;
#line 6199
    switch ((int )pht_info->infos[0] & 3) {
    case 1: 
#line 6202
    pmlmeext->cur_ch_offset = 1U;
#line 6204
    goto ldv_55812;
    case 3: 
#line 6207
    pmlmeext->cur_ch_offset = 2U;
#line 6209
    goto ldv_55812;
    default: 
#line 6212
    pmlmeext->cur_ch_offset = 0U;
#line 6214
    goto ldv_55812;
    }
    ldv_55812: ;
#line 6217
    if (GlobalDebugLevel23A > 3U) {
#line 6217
      printk("\016RTL8723AU: set ch/bw before connected\n");
    } else {

    }
  } else {

  }
#line 6219
  goto ldv_55808;
  default: ;
#line 6222
  goto ldv_55808;
  }
  ldv_55808: 
#line 6225
  i = ((u32 )*(p + 1UL) + i) + 2U;
  ldv_55817: ;
#line 6175
  if (pnetwork->IELength > i) {
#line 6177
    goto ldv_55816;
  } else {

  }
#line 6228
  hw_var_set_bssid(padapter, (u8 *)(& pmlmeinfo->network.MacAddress));
#line 6229
  hw_var_set_mlme_join(padapter, 0);
#line 6232
  ldv_del_timer_sync_550(& pmlmeext->link_timer);
#line 6234
  start_clnt_join(padapter);
#line 6236
  return (0);
}
}
#line 6239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int disconnect_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct disconnect_parm  const  *param ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  bool tmp ;

  {
#line 6241
  param = (struct disconnect_parm  const  *)pbuf;
#line 6242
  pmlmeext = & padapter->mlmeextpriv;
#line 6243
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6244
  pnetwork = & pmlmeinfo->network;
#line 6246
  tmp = is_client_associated_to_ap23a(padapter);
#line 6246
  if ((int )tmp) {
#line 6247
    issue_deauth_ex(padapter, (u8 *)(& pnetwork->MacAddress), 3, (int )((unsigned int )param->deauth_timeout_ms / 100U),
                    100);
  } else {

  }
#line 6256
  hw_var_set_mlme_disconnect(padapter);
#line 6257
  hw_var_set_bssid(padapter, (u8 *)(& null_addr));
#line 6260
  update_tx_basic_rate23a(padapter, (int )padapter->registrypriv.wireless_mode);
#line 6262
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
#line 6264
    rtl8723a_set_bcn_func(padapter, 0);
  } else {

  }
#line 6267
  Set_MSR23a(padapter, 2);
#line 6269
  pmlmeinfo->state = 0U;
#line 6272
  pmlmeext->cur_bwmode = 0U;
#line 6273
  pmlmeext->cur_ch_offset = 0U;
#line 6275
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 6278
  flush_all_cam_entry23a(padapter);
#line 6280
  ldv_del_timer_sync_551(& pmlmeext->link_timer);
#line 6282
  rtw_free_uc_swdec_pending_queue23a(padapter);
#line 6284
  return (0);
}
}
#line 6288 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
static int rtw_scan_ch_decision(struct rtw_adapter *padapter , struct rtw_ieee80211_channel *out ,
                                u32 out_num , struct rtw_ieee80211_channel  const  *in ,
                                u32 in_num ) 
{ 
  int i ;
  int j ;
  int scan_ch_num ;
  int set_idx ;
  struct mlme_ext_priv *pmlmeext ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 6293
  scan_ch_num = 0;
#line 6295
  pmlmeext = & padapter->mlmeextpriv;
#line 6298
  memset((void *)out, 0, (unsigned long )out_num * 8UL);
#line 6301
  j = 0;
#line 6302
  i = 0;
#line 6302
  goto ldv_55844;
  ldv_55843: ;
#line 6303
  if ((unsigned int )((unsigned short )(in + (unsigned long )i)->hw_value) != 0U && ((unsigned int )(in + (unsigned long )i)->flags & 1U) == 0U) {
#line 6303
    set_idx = rtw_ch_set_search_ch23a((struct rt_channel_info *)(& pmlmeext->channel_set),
                                      (u32 const   )(in + (unsigned long )i)->hw_value);
#line 6303
    if (set_idx >= 0) {
#line 6307
      __len = 8UL;
#line 6307
      if (__len > 63UL) {
#line 6307
        __ret = __memcpy((void *)out + (unsigned long )j, (void const   *)in + (unsigned long )i,
                         __len);
      } else {
#line 6307
        __ret = __builtin_memcpy((void *)out + (unsigned long )j, (void const   *)in + (unsigned long )i,
                                 __len);
      }
#line 6310
      if ((unsigned int )pmlmeext->channel_set[set_idx].ScanType == 0U) {
#line 6312
        (out + (unsigned long )j)->flags = (out + (unsigned long )j)->flags & 2U;
      } else {

      }
#line 6314
      j = j + 1;
    } else {

    }
  } else {

  }
#line 6316
  if ((u32 )j >= out_num) {
#line 6317
    goto ldv_55842;
  } else {

  }
#line 6302
  i = i + 1;
  ldv_55844: ;
#line 6302
  if ((u32 )i < in_num) {
#line 6304
    goto ldv_55843;
  } else {

  }
  ldv_55842: ;
#line 6321
  if (j == 0) {
#line 6322
    i = 0;
#line 6322
    goto ldv_55846;
    ldv_55845: 
#line 6323
    (out + (unsigned long )i)->hw_value = (u16 )pmlmeext->channel_set[i].ChannelNum;
#line 6325
    if ((unsigned int )pmlmeext->channel_set[i].ScanType == 0U) {
#line 6326
      (out + (unsigned long )i)->flags = (out + (unsigned long )i)->flags & 2U;
    } else {

    }
#line 6328
    j = j + 1;
#line 6322
    i = i + 1;
    ldv_55846: ;
#line 6322
    if ((int )pmlmeext->max_chan_nums > i) {
#line 6324
      goto ldv_55845;
    } else {

    }

  } else {

  }
#line 6332
  if (padapter->setband == 2U) {
#line 6333
    i = 0;
#line 6333
    goto ldv_55849;
    ldv_55848: ;
#line 6334
    if ((unsigned int )(out + (unsigned long )i)->hw_value > 35U) {
#line 6335
      memset((void *)out + (unsigned long )i, 0, 8UL);
    } else {
#line 6338
      scan_ch_num = scan_ch_num + 1;
    }
#line 6333
    i = i + 1;
    ldv_55849: ;
#line 6333
    if (i < j) {
#line 6335
      goto ldv_55848;
    } else {

    }
#line 6340
    j = scan_ch_num;
  } else
#line 6341
  if (padapter->setband == 1U) {
#line 6342
    i = 0;
#line 6342
    goto ldv_55855;
    ldv_55854: ;
#line 6343
    if ((unsigned int )(out + (unsigned long )i)->hw_value > 35U) {
#line 6344
      __len___0 = 8UL;
#line 6344
      if (__len___0 > 63UL) {
#line 6344
        tmp = scan_ch_num;
#line 6344
        scan_ch_num = scan_ch_num + 1;
#line 6344
        __ret___0 = __memcpy((void *)out + (unsigned long )tmp, (void const   *)out + (unsigned long )i,
                             __len___0);
      } else {
#line 6344
        tmp___0 = scan_ch_num;
#line 6344
        scan_ch_num = scan_ch_num + 1;
#line 6344
        __ret___0 = __builtin_memcpy((void *)out + (unsigned long )tmp___0, (void const   *)out + (unsigned long )i,
                                     __len___0);
      }
    } else {

    }
#line 6342
    i = i + 1;
    ldv_55855: ;
#line 6342
    if (i < j) {
#line 6344
      goto ldv_55854;
    } else {

    }
#line 6348
    j = scan_ch_num;
  } else {

  }
#line 6352
  return (j);
}
}
#line 6355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int sitesurvey_cmd_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct sitesurvey_parm  const  *pparm ;
  u8 bdelayscan ;
  u32 initialgain ;
  u32 i ;
  size_t __len ;
  void *__ret ;
  int tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  unsigned long tmp___2 ;
  void *tmp___3 ;

  {
#line 6357
  pmlmeext = & padapter->mlmeextpriv;
#line 6358
  pparm = (struct sitesurvey_parm  const  *)pbuf;
#line 6359
  bdelayscan = 0U;
#line 6363
  if (pmlmeext->sitesurvey_res.state == 0) {
#line 6364
    pmlmeext->sitesurvey_res.state = 1;
#line 6365
    pmlmeext->sitesurvey_res.bss_cnt = 0;
#line 6366
    pmlmeext->sitesurvey_res.channel_idx = 0;
#line 6368
    i = 0U;
#line 6368
    goto ldv_55870;
    ldv_55869: ;
#line 6369
    if ((unsigned int )((unsigned char )pparm->ssid[i].ssid_len) != 0U) {
#line 6370
      __len = 32UL;
#line 6370
      if (__len > 63UL) {
#line 6370
        __ret = __memcpy((void *)(& pmlmeext->sitesurvey_res.ssid[i].ssid), (void const   *)(& pparm->ssid[i].ssid),
                         __len);
      } else {
#line 6370
        __ret = __builtin_memcpy((void *)(& pmlmeext->sitesurvey_res.ssid[i].ssid),
                                 (void const   *)(& pparm->ssid[i].ssid), __len);
      }
#line 6372
      pmlmeext->sitesurvey_res.ssid[i].ssid_len = pparm->ssid[i].ssid_len;
    } else {
#line 6375
      pmlmeext->sitesurvey_res.ssid[i].ssid_len = 0U;
    }
#line 6368
    i = i + 1U;
    ldv_55870: ;
#line 6368
    if (i <= 8U) {
#line 6370
      goto ldv_55869;
    } else {

    }
#line 6379
    tmp = rtw_scan_ch_decision(padapter, (struct rtw_ieee80211_channel *)(& pmlmeext->sitesurvey_res.ch),
                               51U, (struct rtw_ieee80211_channel  const  *)(& pparm->ch),
                               (u32 )pparm->ch_num);
#line 6379
    pmlmeext->sitesurvey_res.ch_num = (u8 )tmp;
#line 6385
    pmlmeext->sitesurvey_res.scan_mode = pparm->scan_mode;
#line 6388
    tmp___1 = is_client_associated_to_ap23a(padapter);
#line 6388
    if ((int )tmp___1) {
#line 6389
      pmlmeext->sitesurvey_res.state = 2;
#line 6393
      tmp___0 = rtw_get_oper_ch23a(padapter);
#line 6393
      if ((int )tmp___0 != (int )pmlmeext->cur_channel) {
#line 6395
        SelectChannel23a(padapter, (int )pmlmeext->cur_channel);
      } else {

      }
#line 6398
      issue_nulldata23a(padapter, (unsigned char *)0U, 1U, 3, 500);
#line 6400
      bdelayscan = 1U;
    } else {

    }
#line 6403
    if ((unsigned int )bdelayscan != 0U) {
#line 6405
      tmp___2 = msecs_to_jiffies(50U);
#line 6405
      ldv_mod_timer_552(& pmlmeext->survey_timer, tmp___2 + (unsigned long )jiffies);
#line 6406
      return (0);
    } else {

    }
  } else {

  }
#line 6410
  if (pmlmeext->sitesurvey_res.state == 1 || pmlmeext->sitesurvey_res.state == 2) {
#line 6413
    rtl8723a_odm_support_ability_backup(padapter);
#line 6414
    rtl8723a_odm_support_ability_clr(padapter, 0U);
#line 6419
    tmp___3 = wdev_priv___0(padapter->rtw_wdev);
#line 6419
    if ((unsigned int )((struct rtw_wdev_priv *)tmp___3)->p2p_enabled == 1U) {
#line 6420
      initialgain = 48U;
    } else {
#line 6422
      initialgain = 30U;
    }
#line 6424
    rtl8723a_set_initial_gain(padapter, initialgain);
#line 6427
    Set_MSR23a(padapter, 0);
#line 6429
    rtl8723a_mlme_sitesurvey(padapter, 1);
#line 6431
    pmlmeext->sitesurvey_res.state = 3;
  } else {

  }
#line 6434
  rtw_site_survey(padapter);
#line 6436
  return (0);
}
}
#line 6439 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int setauth_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct setauth_parm  const  *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 6441
  pparm = (struct setauth_parm  const  *)pbuf;
#line 6442
  pmlmeext = & padapter->mlmeextpriv;
#line 6443
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6445
  if ((unsigned int )((unsigned char )pparm->mode) <= 3U) {
#line 6446
    pmlmeinfo->auth_algo = (u32 )pparm->mode;
  } else {

  }
#line 6448
  return (0);
}
}
#line 6451 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int setkey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  unsigned short ctrl ;
  struct setkey_parm  const  *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char null_sta[6U] ;

  {
#line 6454
  pparm = (struct setkey_parm  const  *)pbuf;
#line 6455
  pmlmeext = & padapter->mlmeextpriv;
#line 6456
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6457
  null_sta[0] = 0U;
#line 6457
  null_sta[1] = 0U;
#line 6457
  null_sta[2] = 0U;
#line 6457
  null_sta[3] = 0U;
#line 6457
  null_sta[4] = 0U;
#line 6457
  null_sta[5] = 0U;
#line 6460
  if ((unsigned int )((unsigned char )pparm->set_tx) != 0U) {
#line 6461
    pmlmeinfo->key_index = (u32 )pparm->keyid;
  } else {

  }
#line 6464
  ctrl = (unsigned int )(((int )((unsigned short )pparm->algorithm) << 2U) | (int )((unsigned short )pparm->keyid)) | 32768U;
#line 6466
  if (GlobalDebugLevel23A != 0U) {
#line 6466
    printk("\016RTL8723AU: OLD_ERROR set group key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) keyid:%d\n",
           pparm->algorithm, (int )pparm->keyid);
  } else {

  }
#line 6469
  rtl8723a_cam_write(padapter, (int )pparm->keyid, (int )ctrl, (u8 const   *)(& null_sta),
                     (u8 const   *)(& pparm->key));
#line 6472
  rtl8723a_on_rcr_am(padapter);
#line 6474
  return (0);
}
}
#line 6477 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int set_stakey_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  u16 ctrl ;
  u8 cam_id ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct set_stakey_parm  const  *pparm ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;

  {
#line 6479
  ctrl = 0U;
#line 6481
  pmlmeext = & padapter->mlmeextpriv;
#line 6482
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6483
  pparm = (struct set_stakey_parm  const  *)pbuf;
#line 6498
  cam_id = 4U;
#line 6500
  if (GlobalDebugLevel23A != 0U) {
#line 6500
    printk("\016RTL8723AU: OLD_ERROR set pairwise key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) camid:%d\n",
           pparm->algorithm, (int )cam_id);
  } else {

  }
#line 6503
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 6505
    pstapriv = & padapter->stapriv;
#line 6507
    if ((unsigned int )pparm->algorithm == 0U) {
#line 6508
      clear_cam_entry23a(padapter, (int )pparm->id);
#line 6509
      return (1);
    } else {

    }
#line 6512
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pparm->addr));
#line 6513
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 6514
      ctrl = (unsigned int )((int )((u16 )pparm->algorithm) << 2U) | 32768U;
#line 6516
      if (GlobalDebugLevel23A > 3U) {
#line 6516
        printk("\016RTL8723AU: r871x_set_stakey_hdl23a(): enc_algorithm =%d\n", pparm->algorithm);
      } else {

      }
#line 6519
      if (psta->mac_id == 0U || psta->mac_id > 28U) {
#line 6520
        if (GlobalDebugLevel23A > 3U) {
#line 6520
          printk("\016RTL8723AU: r871x_set_stakey_hdl23a():set_stakey failed, mac_id(aid) =%d\n",
                 psta->mac_id);
        } else {

        }
#line 6523
        return (5);
      } else {

      }
#line 6528
      cam_id = (unsigned int )((u8 )psta->mac_id) + 3U;
#line 6530
      if (GlobalDebugLevel23A > 3U) {
#line 6530
        printk("\016RTL8723AU: Write CAM, mac_addr =%x:%x:%x:%x:%x:%x, cam_entry =%d\n",
               (int )pparm->addr[0], (int )pparm->addr[1], (int )pparm->addr[2], (int )pparm->addr[3],
               (int )pparm->addr[4], (int )pparm->addr[5], (int )cam_id);
      } else {

      }
#line 6536
      rtl8723a_cam_write(padapter, (int )cam_id, (int )ctrl, (u8 const   *)(& pparm->addr),
                         (u8 const   *)(& pparm->key));
#line 6539
      return (1);
    } else {
#line 6541
      if (GlobalDebugLevel23A > 3U) {
#line 6541
        printk("\016RTL8723AU: r871x_set_stakey_hdl23a(): sta has been free\n");
      } else {

      }
#line 6543
      return (5);
    }
  } else {

  }
#line 6549
  if ((unsigned int )pparm->algorithm == 0U) {
#line 6550
    clear_cam_entry23a(padapter, (int )pparm->id);
#line 6551
    return (0);
  } else {

  }
#line 6554
  ctrl = (unsigned int )((int )((u16 )pparm->algorithm) << 2U) | 32768U;
#line 6556
  rtl8723a_cam_write(padapter, (int )cam_id, (int )ctrl, (u8 const   *)(& pparm->addr),
                     (u8 const   *)(& pparm->key));
#line 6558
  pmlmeinfo->enc_algo = pparm->algorithm;
#line 6560
  return (0);
}
}
#line 6563 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int add_ba_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct addBaReq_parm  const  *pparm ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct sta_info *psta ;
  unsigned long tmp ;

  {
#line 6565
  pparm = (struct addBaReq_parm  const  *)pbuf;
#line 6566
  pmlmeext = & padapter->mlmeextpriv;
#line 6567
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6570
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pparm->addr));
#line 6572
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 6573
    return (0);
  } else {

  }
#line 6575
  if (((pmlmeinfo->state & 16384U) != 0U && (unsigned int )pmlmeinfo->HT_enable != 0U) || (pmlmeinfo->state & 3U) == 3U) {
#line 6578
    issue_action_BA23a(padapter, (unsigned char const   *)(& pparm->addr), 0, (int )((unsigned short )pparm->tid));
#line 6580
    tmp = msecs_to_jiffies(2000U);
#line 6580
    ldv_mod_timer_553(& psta->addba_retry_timer, tmp + (unsigned long )jiffies);
  } else {
#line 6583
    psta->htpriv.candidate_tid_bitmap = (int )psta->htpriv.candidate_tid_bitmap & ~ ((int )((u16 )(1UL << (int )pparm->tid)));
  }
#line 6585
  return (0);
}
}
#line 6588 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int set_tx_beacon_cmd23a(struct rtw_adapter *padapter ) 
{ 
  struct cmd_obj *ph2c ;
  struct Tx_Beacon_param *ptxBeacon_parm ;
  struct cmd_priv *pcmdpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 res ;
  int len_diff ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;

  {
#line 6592
  pcmdpriv = & padapter->cmdpriv;
#line 6593
  pmlmeext = & padapter->mlmeextpriv;
#line 6594
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6595
  res = 1U;
#line 6596
  len_diff = 0;
#line 6598
  tmp = kzalloc(128UL, 32U);
#line 6598
  ph2c = (struct cmd_obj *)tmp;
#line 6599
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 6600
    res = 0U;
#line 6601
    goto exit;
  } else {

  }
#line 6604
  tmp___0 = kzalloc(863UL, 32U);
#line 6604
  ptxBeacon_parm = (struct Tx_Beacon_param *)tmp___0;
#line 6606
  if ((unsigned long )ptxBeacon_parm == (unsigned long )((struct Tx_Beacon_param *)0)) {
#line 6607
    kfree((void const   *)ph2c);
#line 6608
    res = 0U;
#line 6609
    goto exit;
  } else {

  }
#line 6612
  __len = 863UL;
#line 6612
  if (__len > 63UL) {
#line 6612
    __ret = __memcpy((void *)(& ptxBeacon_parm->network), (void const   *)(& pmlmeinfo->network),
                     __len);
  } else {
#line 6612
    __ret = __builtin_memcpy((void *)(& ptxBeacon_parm->network), (void const   *)(& pmlmeinfo->network),
                             __len);
  }
#line 6615
  len_diff = update_hidden_ssid((u8 *)(& ptxBeacon_parm->network.IEs) + 12UL, ptxBeacon_parm->network.IELength - 12U,
                                (int )pmlmeinfo->hidden_ssid_mode);
#line 6619
  ptxBeacon_parm->network.IELength = ptxBeacon_parm->network.IELength + (u32 )len_diff;
#line 6621
  ph2c->cmdcode = 55U;
#line 6621
  ph2c->parmbuf = (u8 *)ptxBeacon_parm;
#line 6621
  ph2c->cmdsz = 863U;
#line 6621
  ph2c->rsp = (u8 *)0U;
#line 6621
  ph2c->rspsz = 0U;
#line 6624
  tmp___1 = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
#line 6624
  res = (u8 )tmp___1;
  exit: ;
#line 6627
  return ((int )res);
}
}
#line 6630 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int mlme_evt_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  u8 evt_code ;
  u8 evt_seq ;
  u16 evt_sz ;
  struct C2HEvent_Header  const  *c2h ;
  void (*event_callback)(struct rtw_adapter * , u8 const   * ) ;

  {
#line 6637
  c2h = (struct C2HEvent_Header  const  *)pbuf;
#line 6638
  evt_sz = c2h->len;
#line 6639
  evt_seq = c2h->seq;
#line 6640
  evt_code = c2h->ID;
#line 6643
  if ((unsigned int )evt_code > 24U) {
#line 6644
    if (GlobalDebugLevel23A > 3U) {
#line 6644
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 6644
      printk("\016\nEvent Code(%d) mismatch!\n", (int )evt_code);
    } else {

    }
#line 6646
    goto _abort_event_;
  } else {

  }
#line 6650
  if (wlanevents[(int )evt_code].parmsize != 0U && wlanevents[(int )evt_code].parmsize != (u32 )evt_sz) {
#line 6652
    if (GlobalDebugLevel23A > 3U) {
#line 6652
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 128U, 4);
#line 6652
      printk("\016\nEvent(%d) Parm Size mismatch (%d vs %d)!\n", (int )evt_code, wlanevents[(int )evt_code].parmsize,
             (int )evt_sz);
    } else {

    }
#line 6655
    goto _abort_event_;
  } else {

  }
#line 6658
  event_callback = wlanevents[(int )evt_code].event_callback;
#line 6659
  (*event_callback)(padapter, pbuf + 8UL);
  _abort_event_: ;
#line 6663
  return (0);
}
}
#line 6666 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int h2c_msg_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
#line 6668
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 6669
    return (4);
  } else {

  }
#line 6671
  return (0);
}
}
#line 6674 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int tx_beacon_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct sta_info *psta_bmc ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct xmit_priv *pxmitpriv ;
  struct sta_priv *pstapriv ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 6676
  tmp = send_beacon23a(padapter);
#line 6676
  if (tmp == 0) {
#line 6677
    if (GlobalDebugLevel23A > 3U) {
#line 6677
      printk("\016RTL8723AU: issue_beacon23a, fail!\n");
    } else {

    }
#line 6678
    return (4);
  } else {
#line 6685
    pxmitpriv = & padapter->xmitpriv;
#line 6686
    pstapriv = & padapter->stapriv;
#line 6689
    psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 6690
    if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
#line 6691
      return (0);
    } else {

    }
#line 6693
    if ((int )pstapriv->tim_bitmap & 1 && psta_bmc->sleepq_len != 0U) {
#line 6694
      msleep(10U);
#line 6696
      spin_lock_bh(& pxmitpriv->lock);
#line 6698
      phead = get_list_head(& psta_bmc->sleep_q);
#line 6700
      plist = phead->next;
#line 6700
      ptmp = plist->next;
#line 6700
      goto ldv_55951;
      ldv_55950: 
#line 6701
      __mptr = (struct list_head  const  *)plist;
#line 6701
      pxmitframe = (struct xmit_frame *)__mptr;
#line 6705
      list_del_init(& pxmitframe->list);
#line 6707
      psta_bmc->sleepq_len = psta_bmc->sleepq_len - 1U;
#line 6708
      if (psta_bmc->sleepq_len != 0U) {
#line 6709
        pxmitframe->attrib.mdata = 1U;
      } else {
#line 6711
        pxmitframe->attrib.mdata = 0U;
      }
#line 6713
      pxmitframe->attrib.triggered = 1U;
#line 6715
      pxmitframe->attrib.qsel = 17U;
#line 6717
      rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 6700
      plist = ptmp;
#line 6700
      ptmp = plist->next;
      ldv_55951: ;
#line 6700
      if ((unsigned long )plist != (unsigned long )phead) {
#line 6702
        goto ldv_55950;
      } else {

      }
#line 6722
      spin_unlock_bh(& pxmitpriv->lock);
    } else {

    }
  }
#line 6727
  return (0);
}
}
#line 6730 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int set_ch_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct set_ch_parm  const  *set_ch_parm ;
  struct mlme_ext_priv *pmlmeext ;

  {
#line 6733
  pmlmeext = & padapter->mlmeextpriv;
#line 6735
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 6736
    return (4);
  } else {

  }
#line 6738
  set_ch_parm = (struct set_ch_parm  const  *)pbuf;
#line 6740
  if (GlobalDebugLevel23A > 3U) {
#line 6740
    printk("\016RTL8723AU: %s(%s): ch:%u, bw:%u, ch_offset:%u\n", "set_ch_hdl23a",
           (char *)(& (padapter->pnetdev)->name), (int )set_ch_parm->ch, (int )set_ch_parm->bw,
           (int )set_ch_parm->ch_offset);
  } else {

  }
#line 6744
  pmlmeext->cur_channel = set_ch_parm->ch;
#line 6745
  pmlmeext->cur_ch_offset = set_ch_parm->ch_offset;
#line 6746
  pmlmeext->cur_bwmode = set_ch_parm->bw;
#line 6748
  set_channel_bwmode23a(padapter, (int )set_ch_parm->ch, (int )set_ch_parm->ch_offset,
                        (int )set_ch_parm->bw);
#line 6751
  return (0);
}
}
#line 6754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int set_chplan_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct SetChannelPlan_param  const  *setChannelPlan_param ;
  struct mlme_ext_priv *pmlmeext ;

  {
#line 6757
  pmlmeext = & padapter->mlmeextpriv;
#line 6759
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 6760
    return (4);
  } else {

  }
#line 6762
  setChannelPlan_param = (struct SetChannelPlan_param  const  *)pbuf;
#line 6764
  pmlmeext->max_chan_nums = init_channel_set(padapter, (int )setChannelPlan_param->channel_plan,
                                             (struct rt_channel_info *)(& pmlmeext->channel_set));
#line 6767
  init_channel_list(padapter, (struct rt_channel_info *)(& pmlmeext->channel_set),
                    (int )pmlmeext->max_chan_nums, & pmlmeext->channel_list);
#line 6770
  return (0);
}
}
#line 6773 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int led_blink_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 
  struct LedBlink_param *ledBlink_param ;

  {
#line 6777
  if ((unsigned long )pbuf == (unsigned long )((u8 const   *)0U)) {
#line 6778
    return (4);
  } else {

  }
#line 6780
  ledBlink_param = (struct LedBlink_param *)pbuf;
#line 6782
  return (0);
}
}
#line 6785 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int set_csa_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
#line 6787
  return (5);
}
}
#line 6806 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int tdls_hdl23a(struct rtw_adapter *padapter , u8 const   *pbuf ) 
{ 


  {
#line 6808
  return (5);
}
}
#line 6812 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 6813
  if (ldv_timer_6_0 == 0 || ldv_timer_6_0 == 2) {
#line 6814
    ldv_timer_list_6_0 = timer;
#line 6815
    ldv_timer_list_6_0->data = data;
#line 6816
    ldv_timer_6_0 = 1;
#line 6817
    return;
  } else {

  }
#line 6819
  if (ldv_timer_6_1 == 0 || ldv_timer_6_1 == 2) {
#line 6820
    ldv_timer_list_6_1 = timer;
#line 6821
    ldv_timer_list_6_1->data = data;
#line 6822
    ldv_timer_6_1 = 1;
#line 6823
    return;
  } else {

  }
#line 6825
  if (ldv_timer_6_2 == 0 || ldv_timer_6_2 == 2) {
#line 6826
    ldv_timer_list_6_2 = timer;
#line 6827
    ldv_timer_list_6_2->data = data;
#line 6828
    ldv_timer_6_2 = 1;
#line 6829
    return;
  } else {

  }
#line 6831
  if (ldv_timer_6_3 == 0 || ldv_timer_6_3 == 2) {
#line 6832
    ldv_timer_list_6_3 = timer;
#line 6833
    ldv_timer_list_6_3->data = data;
#line 6834
    ldv_timer_6_3 = 1;
#line 6835
    return;
  } else {

  }
#line 6837
  return;
}
}
#line 6841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int reg_timer_7(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 6842
  if ((unsigned long )function == (unsigned long )(& survey_timer_hdl)) {
#line 6843
    activate_suitable_timer_7(timer, data);
  } else {

  }
#line 6844
  return (0);
}
}
#line 6848 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void disable_suitable_timer_8(struct timer_list *timer ) 
{ 


  {
#line 6849
  if (ldv_timer_8_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_0) {
#line 6850
    ldv_timer_8_0 = 0;
#line 6851
    return;
  } else {

  }
#line 6853
  if (ldv_timer_8_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_1) {
#line 6854
    ldv_timer_8_1 = 0;
#line 6855
    return;
  } else {

  }
#line 6857
  if (ldv_timer_8_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_2) {
#line 6858
    ldv_timer_8_2 = 0;
#line 6859
    return;
  } else {

  }
#line 6861
  if (ldv_timer_8_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_8_3) {
#line 6862
    ldv_timer_8_3 = 0;
#line 6863
    return;
  } else {

  }
#line 6865
  return;
}
}
#line 6869 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void timer_init_6(void) 
{ 


  {
#line 6870
  ldv_timer_6_0 = 0;
#line 6871
  ldv_timer_6_1 = 0;
#line 6872
  ldv_timer_6_2 = 0;
#line 6873
  ldv_timer_6_3 = 0;
#line 6874
  return;
}
}
#line 6877 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_pending_timer_8(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 6878
  if ((unsigned long )ldv_timer_list_8_0 == (unsigned long )timer) {
#line 6879
    if (ldv_timer_8_0 == 2 || pending_flag != 0) {
#line 6880
      ldv_timer_list_8_0 = timer;
#line 6881
      ldv_timer_list_8_0->data = data;
#line 6882
      ldv_timer_8_0 = 1;
    } else {

    }
#line 6884
    return;
  } else {

  }
#line 6887
  if ((unsigned long )ldv_timer_list_8_1 == (unsigned long )timer) {
#line 6888
    if (ldv_timer_8_1 == 2 || pending_flag != 0) {
#line 6889
      ldv_timer_list_8_1 = timer;
#line 6890
      ldv_timer_list_8_1->data = data;
#line 6891
      ldv_timer_8_1 = 1;
    } else {

    }
#line 6893
    return;
  } else {

  }
#line 6896
  if ((unsigned long )ldv_timer_list_8_2 == (unsigned long )timer) {
#line 6897
    if (ldv_timer_8_2 == 2 || pending_flag != 0) {
#line 6898
      ldv_timer_list_8_2 = timer;
#line 6899
      ldv_timer_list_8_2->data = data;
#line 6900
      ldv_timer_8_2 = 1;
    } else {

    }
#line 6902
    return;
  } else {

  }
#line 6905
  if ((unsigned long )ldv_timer_list_8_3 == (unsigned long )timer) {
#line 6906
    if (ldv_timer_8_3 == 2 || pending_flag != 0) {
#line 6907
      ldv_timer_list_8_3 = timer;
#line 6908
      ldv_timer_list_8_3->data = data;
#line 6909
      ldv_timer_8_3 = 1;
    } else {

    }
#line 6911
    return;
  } else {

  }
#line 6913
  activate_suitable_timer_8(timer, data);
#line 6914
  return;
}
}
#line 6917 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void ldv_timer_7(int state , struct timer_list *timer ) 
{ 


  {
#line 6918
  LDV_IN_INTERRUPT = 2;
#line 6919
  survey_timer_hdl(timer->data);
#line 6920
  LDV_IN_INTERRUPT = 1;
#line 6921
  return;
}
}
#line 6924 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void disable_suitable_timer_6(struct timer_list *timer ) 
{ 


  {
#line 6925
  if (ldv_timer_6_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_0) {
#line 6926
    ldv_timer_6_0 = 0;
#line 6927
    return;
  } else {

  }
#line 6929
  if (ldv_timer_6_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_1) {
#line 6930
    ldv_timer_6_1 = 0;
#line 6931
    return;
  } else {

  }
#line 6933
  if (ldv_timer_6_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_2) {
#line 6934
    ldv_timer_6_2 = 0;
#line 6935
    return;
  } else {

  }
#line 6937
  if (ldv_timer_6_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_3) {
#line 6938
    ldv_timer_6_3 = 0;
#line 6939
    return;
  } else {

  }
#line 6941
  return;
}
}
#line 6945 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 6946
  if ((unsigned long )ldv_timer_list_6_0 == (unsigned long )timer) {
#line 6947
    if (ldv_timer_6_0 == 2 || pending_flag != 0) {
#line 6948
      ldv_timer_list_6_0 = timer;
#line 6949
      ldv_timer_list_6_0->data = data;
#line 6950
      ldv_timer_6_0 = 1;
    } else {

    }
#line 6952
    return;
  } else {

  }
#line 6955
  if ((unsigned long )ldv_timer_list_6_1 == (unsigned long )timer) {
#line 6956
    if (ldv_timer_6_1 == 2 || pending_flag != 0) {
#line 6957
      ldv_timer_list_6_1 = timer;
#line 6958
      ldv_timer_list_6_1->data = data;
#line 6959
      ldv_timer_6_1 = 1;
    } else {

    }
#line 6961
    return;
  } else {

  }
#line 6964
  if ((unsigned long )ldv_timer_list_6_2 == (unsigned long )timer) {
#line 6965
    if (ldv_timer_6_2 == 2 || pending_flag != 0) {
#line 6966
      ldv_timer_list_6_2 = timer;
#line 6967
      ldv_timer_list_6_2->data = data;
#line 6968
      ldv_timer_6_2 = 1;
    } else {

    }
#line 6970
    return;
  } else {

  }
#line 6973
  if ((unsigned long )ldv_timer_list_6_3 == (unsigned long )timer) {
#line 6974
    if (ldv_timer_6_3 == 2 || pending_flag != 0) {
#line 6975
      ldv_timer_list_6_3 = timer;
#line 6976
      ldv_timer_list_6_3->data = data;
#line 6977
      ldv_timer_6_3 = 1;
    } else {

    }
#line 6979
    return;
  } else {

  }
#line 6981
  activate_suitable_timer_6(timer, data);
#line 6982
  return;
}
}
#line 6985 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void choose_timer_8(void) 
{ 
  int tmp ;

  {
#line 6986
  tmp = __VERIFIER_nondet_int();
#line 6986
  switch (tmp) {
  case 0: ;
#line 6988
  if (ldv_timer_8_0 == 1) {
#line 6989
    ldv_timer_8_0 = 2;
#line 6990
    ldv_timer_8(ldv_timer_8_0, ldv_timer_list_8_0);
  } else {

  }
#line 6993
  goto ldv_56016;
  case 1: ;
#line 6995
  if (ldv_timer_8_1 == 1) {
#line 6996
    ldv_timer_8_1 = 2;
#line 6997
    ldv_timer_8(ldv_timer_8_1, ldv_timer_list_8_1);
  } else {

  }
#line 7000
  goto ldv_56016;
  case 2: ;
#line 7002
  if (ldv_timer_8_2 == 1) {
#line 7003
    ldv_timer_8_2 = 2;
#line 7004
    ldv_timer_8(ldv_timer_8_2, ldv_timer_list_8_2);
  } else {

  }
#line 7007
  goto ldv_56016;
  case 3: ;
#line 7009
  if (ldv_timer_8_3 == 1) {
#line 7010
    ldv_timer_8_3 = 2;
#line 7011
    ldv_timer_8(ldv_timer_8_3, ldv_timer_list_8_3);
  } else {

  }
#line 7014
  goto ldv_56016;
  default: 
#line 7015
  ldv_stop();
  }
  ldv_56016: ;
#line 7017
  return;
}
}
#line 7021 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void disable_suitable_timer_7(struct timer_list *timer ) 
{ 


  {
#line 7022
  if (ldv_timer_7_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_0) {
#line 7023
    ldv_timer_7_0 = 0;
#line 7024
    return;
  } else {

  }
#line 7026
  if (ldv_timer_7_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_1) {
#line 7027
    ldv_timer_7_1 = 0;
#line 7028
    return;
  } else {

  }
#line 7030
  if (ldv_timer_7_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_2) {
#line 7031
    ldv_timer_7_2 = 0;
#line 7032
    return;
  } else {

  }
#line 7034
  if (ldv_timer_7_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_7_3) {
#line 7035
    ldv_timer_7_3 = 0;
#line 7036
    return;
  } else {

  }
#line 7038
  return;
}
}
#line 7042 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int reg_timer_8(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 7043
  if ((unsigned long )function == (unsigned long )(& link_timer_hdl)) {
#line 7044
    activate_suitable_timer_8(timer, data);
  } else {

  }
#line 7045
  return (0);
}
}
#line 7049 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void choose_timer_6(void) 
{ 
  int tmp ;

  {
#line 7050
  tmp = __VERIFIER_nondet_int();
#line 7050
  switch (tmp) {
  case 0: ;
#line 7052
  if (ldv_timer_6_0 == 1) {
#line 7053
    ldv_timer_6_0 = 2;
#line 7054
    ldv_timer_6(ldv_timer_6_0, ldv_timer_list_6_0);
  } else {

  }
#line 7057
  goto ldv_56034;
  case 1: ;
#line 7059
  if (ldv_timer_6_1 == 1) {
#line 7060
    ldv_timer_6_1 = 2;
#line 7061
    ldv_timer_6(ldv_timer_6_1, ldv_timer_list_6_1);
  } else {

  }
#line 7064
  goto ldv_56034;
  case 2: ;
#line 7066
  if (ldv_timer_6_2 == 1) {
#line 7067
    ldv_timer_6_2 = 2;
#line 7068
    ldv_timer_6(ldv_timer_6_2, ldv_timer_list_6_2);
  } else {

  }
#line 7071
  goto ldv_56034;
  case 3: ;
#line 7073
  if (ldv_timer_6_3 == 1) {
#line 7074
    ldv_timer_6_3 = 2;
#line 7075
    ldv_timer_6(ldv_timer_6_3, ldv_timer_list_6_3);
  } else {

  }
#line 7078
  goto ldv_56034;
  default: 
#line 7079
  ldv_stop();
  }
  ldv_56034: ;
#line 7081
  return;
}
}
#line 7085 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 7086
  if ((unsigned long )function == (unsigned long )(& addba_timer_hdl)) {
#line 7087
    activate_suitable_timer_6(timer, data);
  } else {

  }
#line 7088
  return (0);
}
}
#line 7092 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void ldv_timer_6(int state , struct timer_list *timer ) 
{ 


  {
#line 7093
  LDV_IN_INTERRUPT = 2;
#line 7094
  addba_timer_hdl(timer->data);
#line 7095
  LDV_IN_INTERRUPT = 1;
#line 7096
  return;
}
}
#line 7099 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void timer_init_7(void) 
{ 


  {
#line 7100
  ldv_timer_7_0 = 0;
#line 7101
  ldv_timer_7_1 = 0;
#line 7102
  ldv_timer_7_2 = 0;
#line 7103
  ldv_timer_7_3 = 0;
#line 7104
  return;
}
}
#line 7107 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void ldv_timer_8(int state , struct timer_list *timer ) 
{ 


  {
#line 7108
  LDV_IN_INTERRUPT = 2;
#line 7109
  link_timer_hdl(timer->data);
#line 7110
  LDV_IN_INTERRUPT = 1;
#line 7111
  return;
}
}
#line 7114 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void choose_timer_7(void) 
{ 
  int tmp ;

  {
#line 7115
  tmp = __VERIFIER_nondet_int();
#line 7115
  switch (tmp) {
  case 0: ;
#line 7117
  if (ldv_timer_7_0 == 1) {
#line 7118
    ldv_timer_7_0 = 2;
#line 7119
    ldv_timer_7(ldv_timer_7_0, ldv_timer_list_7_0);
  } else {

  }
#line 7122
  goto ldv_56060;
  case 1: ;
#line 7124
  if (ldv_timer_7_1 == 1) {
#line 7125
    ldv_timer_7_1 = 2;
#line 7126
    ldv_timer_7(ldv_timer_7_1, ldv_timer_list_7_1);
  } else {

  }
#line 7129
  goto ldv_56060;
  case 2: ;
#line 7131
  if (ldv_timer_7_2 == 1) {
#line 7132
    ldv_timer_7_2 = 2;
#line 7133
    ldv_timer_7(ldv_timer_7_2, ldv_timer_list_7_2);
  } else {

  }
#line 7136
  goto ldv_56060;
  case 3: ;
#line 7138
  if (ldv_timer_7_3 == 1) {
#line 7139
    ldv_timer_7_3 = 2;
#line 7140
    ldv_timer_7(ldv_timer_7_3, ldv_timer_list_7_3);
  } else {

  }
#line 7143
  goto ldv_56060;
  default: 
#line 7144
  ldv_stop();
  }
  ldv_56060: ;
#line 7146
  return;
}
}
#line 7150 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void timer_init_8(void) 
{ 


  {
#line 7151
  ldv_timer_8_0 = 0;
#line 7152
  ldv_timer_8_1 = 0;
#line 7153
  ldv_timer_8_2 = 0;
#line 7154
  ldv_timer_8_3 = 0;
#line 7155
  return;
}
}
#line 7158 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_suitable_timer_8(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 7159
  if (ldv_timer_8_0 == 0 || ldv_timer_8_0 == 2) {
#line 7160
    ldv_timer_list_8_0 = timer;
#line 7161
    ldv_timer_list_8_0->data = data;
#line 7162
    ldv_timer_8_0 = 1;
#line 7163
    return;
  } else {

  }
#line 7165
  if (ldv_timer_8_1 == 0 || ldv_timer_8_1 == 2) {
#line 7166
    ldv_timer_list_8_1 = timer;
#line 7167
    ldv_timer_list_8_1->data = data;
#line 7168
    ldv_timer_8_1 = 1;
#line 7169
    return;
  } else {

  }
#line 7171
  if (ldv_timer_8_2 == 0 || ldv_timer_8_2 == 2) {
#line 7172
    ldv_timer_list_8_2 = timer;
#line 7173
    ldv_timer_list_8_2->data = data;
#line 7174
    ldv_timer_8_2 = 1;
#line 7175
    return;
  } else {

  }
#line 7177
  if (ldv_timer_8_3 == 0 || ldv_timer_8_3 == 2) {
#line 7178
    ldv_timer_list_8_3 = timer;
#line 7179
    ldv_timer_list_8_3->data = data;
#line 7180
    ldv_timer_8_3 = 1;
#line 7181
    return;
  } else {

  }
#line 7183
  return;
}
}
#line 7187 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 7188
  if ((unsigned long )ldv_timer_list_7_0 == (unsigned long )timer) {
#line 7189
    if (ldv_timer_7_0 == 2 || pending_flag != 0) {
#line 7190
      ldv_timer_list_7_0 = timer;
#line 7191
      ldv_timer_list_7_0->data = data;
#line 7192
      ldv_timer_7_0 = 1;
    } else {

    }
#line 7194
    return;
  } else {

  }
#line 7197
  if ((unsigned long )ldv_timer_list_7_1 == (unsigned long )timer) {
#line 7198
    if (ldv_timer_7_1 == 2 || pending_flag != 0) {
#line 7199
      ldv_timer_list_7_1 = timer;
#line 7200
      ldv_timer_list_7_1->data = data;
#line 7201
      ldv_timer_7_1 = 1;
    } else {

    }
#line 7203
    return;
  } else {

  }
#line 7206
  if ((unsigned long )ldv_timer_list_7_2 == (unsigned long )timer) {
#line 7207
    if (ldv_timer_7_2 == 2 || pending_flag != 0) {
#line 7208
      ldv_timer_list_7_2 = timer;
#line 7209
      ldv_timer_list_7_2->data = data;
#line 7210
      ldv_timer_7_2 = 1;
    } else {

    }
#line 7212
    return;
  } else {

  }
#line 7215
  if ((unsigned long )ldv_timer_list_7_3 == (unsigned long )timer) {
#line 7216
    if (ldv_timer_7_3 == 2 || pending_flag != 0) {
#line 7217
      ldv_timer_list_7_3 = timer;
#line 7218
      ldv_timer_list_7_3->data = data;
#line 7219
      ldv_timer_7_3 = 1;
    } else {

    }
#line 7221
    return;
  } else {

  }
#line 7223
  activate_suitable_timer_7(timer, data);
#line 7224
  return;
}
}
#line 7227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void activate_suitable_timer_7(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 7228
  if (ldv_timer_7_0 == 0 || ldv_timer_7_0 == 2) {
#line 7229
    ldv_timer_list_7_0 = timer;
#line 7230
    ldv_timer_list_7_0->data = data;
#line 7231
    ldv_timer_7_0 = 1;
#line 7232
    return;
  } else {

  }
#line 7234
  if (ldv_timer_7_1 == 0 || ldv_timer_7_1 == 2) {
#line 7235
    ldv_timer_list_7_1 = timer;
#line 7236
    ldv_timer_list_7_1->data = data;
#line 7237
    ldv_timer_7_1 = 1;
#line 7238
    return;
  } else {

  }
#line 7240
  if (ldv_timer_7_2 == 0 || ldv_timer_7_2 == 2) {
#line 7241
    ldv_timer_list_7_2 = timer;
#line 7242
    ldv_timer_list_7_2->data = data;
#line 7243
    ldv_timer_7_2 = 1;
#line 7244
    return;
  } else {

  }
#line 7246
  if (ldv_timer_7_3 == 0 || ldv_timer_7_3 == 2) {
#line 7247
    ldv_timer_list_7_3 = timer;
#line 7248
    ldv_timer_list_7_3->data = data;
#line 7249
    ldv_timer_7_3 = 1;
#line 7250
    return;
  } else {

  }
#line 7252
  return;
}
}
#line 7314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 7317
  ldv_spin_unlock();
#line 7319
  ldv_spin_unlock_irqrestore_508(lock, flags);
#line 7320
  return;
}
}
#line 7352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 


  {
#line 7355
  ldv_check_alloc_flags(flags);
#line 7357
  ldv_kmalloc_512(size, flags);
#line 7358
  return ((void *)0);
}
}
#line 7382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
void *ldv_kmem_cache_alloc_516(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 7385
  ldv_check_alloc_flags(flags);
#line 7387
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 7388
  return ((void *)0);
}
}
#line 7426 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_pskb_expand_head_522(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 7429
  ldv_check_alloc_flags(flags);
#line 7431
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 7431
  return (tmp);
}
}
#line 7442 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
struct sk_buff *ldv_skb_clone_524(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 7445
  ldv_check_alloc_flags(flags);
#line 7447
  tmp = skb_clone(ldv_func_arg1, flags);
#line 7447
  return (tmp);
}
}
#line 7458 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
struct sk_buff *ldv_skb_copy_526(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 7461
  ldv_check_alloc_flags(flags);
#line 7463
  tmp = skb_copy(ldv_func_arg1, flags);
#line 7463
  return (tmp);
}
}
#line 7466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_527(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 7469
  ldv_check_alloc_flags(flags);
#line 7471
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 7471
  return (tmp);
}
}
#line 7474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_528(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 7477
  ldv_check_alloc_flags(flags);
#line 7479
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 7479
  return (tmp);
}
}
#line 7482 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_529(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 7485
  ldv_check_alloc_flags(flags);
#line 7487
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 7487
  return (tmp);
}
}
#line 7490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_pskb_expand_head_530(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 7493
  ldv_check_alloc_flags(flags);
#line 7495
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 7495
  return (tmp);
}
}
#line 7498 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_pskb_expand_head_531(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 7501
  ldv_check_alloc_flags(flags);
#line 7503
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 7503
  return (tmp);
}
}
#line 7506 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
struct sk_buff *ldv_skb_clone_532(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 7509
  ldv_check_alloc_flags(flags);
#line 7511
  tmp = skb_clone(ldv_func_arg1, flags);
#line 7511
  return (tmp);
}
}
#line 7514 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_533(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 7518
  tmp = del_timer_sync(ldv_func_arg1);
#line 7518
  ldv_func_res = tmp;
#line 7520
  disable_suitable_timer_6(ldv_func_arg1);
#line 7522
  return (ldv_func_res);
}
}
#line 7525 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_534(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 7529
  tmp = del_timer_sync(ldv_func_arg1);
#line 7529
  ldv_func_res = tmp;
#line 7531
  disable_suitable_timer_6(ldv_func_arg1);
#line 7533
  return (ldv_func_res);
}
}
#line 7536 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_535(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 7540
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7540
  ldv_func_res = tmp;
#line 7542
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7544
  return (ldv_func_res);
}
}
#line 7547 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_536(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 7551
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7551
  ldv_func_res = tmp;
#line 7553
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7555
  return (ldv_func_res);
}
}
#line 7558 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_537(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 7562
  tmp = del_timer_sync(ldv_func_arg1);
#line 7562
  ldv_func_res = tmp;
#line 7564
  disable_suitable_timer_6(ldv_func_arg1);
#line 7566
  return (ldv_func_res);
}
}
#line 7569 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_538(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 7573
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7573
  ldv_func_res = tmp;
#line 7575
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7577
  return (ldv_func_res);
}
}
#line 7580 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_539(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 7584
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7584
  ldv_func_res = tmp;
#line 7586
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7588
  return (ldv_func_res);
}
}
#line 7591 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_540(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 7595
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7595
  ldv_func_res = tmp;
#line 7597
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7599
  return (ldv_func_res);
}
}
#line 7602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_541(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 7606
  tmp = del_timer_sync(ldv_func_arg1);
#line 7606
  ldv_func_res = tmp;
#line 7608
  disable_suitable_timer_6(ldv_func_arg1);
#line 7610
  return (ldv_func_res);
}
}
#line 7613 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_542(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 7617
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7617
  ldv_func_res = tmp;
#line 7619
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7621
  return (ldv_func_res);
}
}
#line 7624 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_543(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 7628
  tmp = del_timer_sync(ldv_func_arg1);
#line 7628
  ldv_func_res = tmp;
#line 7630
  disable_suitable_timer_6(ldv_func_arg1);
#line 7632
  return (ldv_func_res);
}
}
#line 7635 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_544(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 7639
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7639
  ldv_func_res = tmp;
#line 7641
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7643
  return (ldv_func_res);
}
}
#line 7646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_545(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 7650
  tmp = del_timer_sync(ldv_func_arg1);
#line 7650
  ldv_func_res = tmp;
#line 7652
  disable_suitable_timer_6(ldv_func_arg1);
#line 7654
  return (ldv_func_res);
}
}
#line 7657 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_546(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
#line 7661
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7661
  ldv_func_res = tmp;
#line 7663
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7665
  return (ldv_func_res);
}
}
#line 7668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_547(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
#line 7672
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7672
  ldv_func_res = tmp;
#line 7674
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7676
  return (ldv_func_res);
}
}
#line 7679 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_548(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
#line 7683
  tmp = del_timer_sync(ldv_func_arg1);
#line 7683
  ldv_func_res = tmp;
#line 7685
  disable_suitable_timer_6(ldv_func_arg1);
#line 7687
  return (ldv_func_res);
}
}
#line 7690 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_549(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;

  {
#line 7694
  tmp = del_timer_sync(ldv_func_arg1);
#line 7694
  ldv_func_res = tmp;
#line 7696
  disable_suitable_timer_6(ldv_func_arg1);
#line 7698
  return (ldv_func_res);
}
}
#line 7701 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_550(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___19 ldv_func_res ;
  int tmp ;

  {
#line 7705
  tmp = del_timer_sync(ldv_func_arg1);
#line 7705
  ldv_func_res = tmp;
#line 7707
  disable_suitable_timer_6(ldv_func_arg1);
#line 7709
  return (ldv_func_res);
}
}
#line 7712 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_del_timer_sync_551(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___20 ldv_func_res ;
  int tmp ;

  {
#line 7716
  tmp = del_timer_sync(ldv_func_arg1);
#line 7716
  ldv_func_res = tmp;
#line 7718
  disable_suitable_timer_6(ldv_func_arg1);
#line 7720
  return (ldv_func_res);
}
}
#line 7723 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_552(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___21 ldv_func_res ;
  int tmp ;

  {
#line 7727
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7727
  ldv_func_res = tmp;
#line 7729
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7731
  return (ldv_func_res);
}
}
#line 7734 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_mlme_ext.o.c.prepared"
int ldv_mod_timer_553(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___22 ldv_func_res ;
  int tmp ;

  {
#line 7738
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 7738
  ldv_func_res = tmp;
#line 7740
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 7742
  return (ldv_func_res);
}
}
#line 179 "include/linux/timer.h"
int ldv_mod_timer_617(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_600(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
struct timer_list *ldv_timer_list_9_3 ;
#line 33
int ldv_timer_9_1 ;
#line 38
int ldv_timer_9_0 ;
#line 40
int ldv_timer_9_3 ;
#line 53
struct timer_list *ldv_timer_list_9_2 ;
#line 54
int ldv_timer_9_2 ;
#line 82
struct timer_list *ldv_timer_list_9_0 ;
#line 136
struct timer_list *ldv_timer_list_9_1 ;
#line 141
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 154
void ldv_timer_9(int state , struct timer_list *timer ) ;
#line 163
void timer_init_9(void) ;
#line 172
void activate_suitable_timer_9(struct timer_list *timer , unsigned long data ) ;
#line 178
int reg_timer_9(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 182
void disable_suitable_timer_9(struct timer_list *timer ) ;
#line 194
void choose_timer_9(void) ;
#line 32 "include/linux/semaphore.h"
__inline static void sema_init(struct semaphore *sem , int val ) 
{ 
  struct lock_class_key __key ;
  struct semaphore __constr_expr_0 ;

  {
#line 35
  __constr_expr_0.lock.raw_lock.ldv_1458.head_tail = 0U;
#line 35
  __constr_expr_0.lock.magic = 3735899821U;
#line 35
  __constr_expr_0.lock.owner_cpu = 4294967295U;
#line 35
  __constr_expr_0.lock.owner = (void *)-1;
#line 35
  __constr_expr_0.lock.dep_map.key = 0;
#line 35
  __constr_expr_0.lock.dep_map.class_cache[0] = 0;
#line 35
  __constr_expr_0.lock.dep_map.class_cache[1] = 0;
#line 35
  __constr_expr_0.lock.dep_map.name = "(*sem).lock";
#line 35
  __constr_expr_0.lock.dep_map.cpu = 0;
#line 35
  __constr_expr_0.lock.dep_map.ip = 0UL;
#line 35
  __constr_expr_0.count = (unsigned int )val;
#line 35
  __constr_expr_0.wait_list.next = & sem->wait_list;
#line 35
  __constr_expr_0.wait_list.prev = & sem->wait_list;
#line 35
  *sem = __constr_expr_0;
#line 36
  lockdep_init_map(& sem->lock.dep_map, "semaphore->lock", & __key, 0);
#line 37
  return;
}
}
#line 39
extern void down(struct semaphore * ) ;
#line 44
extern void up(struct semaphore * ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_608(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_616(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_610(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_606(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_614(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_615(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_611(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_612(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_613(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 209 "drivers/staging/rtl8723au/include/hal_com.h"
void rtl8723a_set_rpwm(struct rtw_adapter *padapter , u8 val ) ;
#line 211
bool rtl8723a_get_fwlps_rf_on(struct rtw_adapter *padapter ) ;
#line 233 "drivers/staging/rtl8723au/include/rtw_pwrctrl.h"
void rtw_init_pwrctrl_priv23a(struct rtw_adapter *padapter ) ;
#line 234
void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter ) ;
#line 236
void rtw_set_ps_mode23a(struct rtw_adapter *padapter , u8 ps_mode , u8 smart_ps ,
                        u8 bcn_ant_mode ) ;
#line 238
void rtw_set_rpwm23a(struct rtw_adapter *padapter , u8 pslv ) ;
#line 239
void LeaveAllPowerSaveMode23a(struct rtw_adapter *Adapter ) ;
#line 240
void ips_enter23a(struct rtw_adapter *padapter ) ;
#line 241
int ips_leave23a(struct rtw_adapter *padapter ) ;
#line 245
enum rt_rf_power_state RfOnOffDetect23a(struct rtw_adapter *pAdapter ) ;
#line 247
s32 LPS_RF_ON_check23a(struct rtw_adapter *padapter , u32 delay_ms ) ;
#line 252
int _rtw_pwr_wakeup23a(struct rtw_adapter *padapter , u32 ips_deffer_ms , char const   *caller ) ;
#line 258
int rtw_pm_set_ips23a(struct rtw_adapter *padapter , u8 mode ) ;
#line 259
int rtw_pm_set_lps23a(struct rtw_adapter *padapter , u8 mode ) ;
#line 22 "drivers/staging/rtl8723au/include/osdep_intf.h"
int rtw_hw_suspend23a(struct rtw_adapter *padapter ) ;
#line 23
int rtw_hw_resume23a(struct rtw_adapter *padapter ) ;
#line 38
int rtw_ips_pwr_up23a(struct rtw_adapter *padapter ) ;
#line 39
void rtw_ips_pwr_down23a(struct rtw_adapter *padapter ) ;
#line 67 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
extern bool rtw_cfg80211_pwr_mgmt(struct rtw_adapter * ) ;
#line 145 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
void rtl8723a_set_FwPwrMode_cmd(struct rtw_adapter *padapter , u8 Mode ) ;
#line 32 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
void rtl8723a_BT_disable_coexist(struct rtw_adapter *padapter ) ;
#line 51 "drivers/staging/rtl8723au/include/rtw_sreset.h"
bool rtw_sreset_inprogress(struct rtw_adapter *padapter ) ;
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void ips_enter23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;

  {
#line 246
  pwrpriv = & padapter->pwrctrlpriv;
#line 248
  down(& pwrpriv->lock);
#line 250
  pwrpriv->bips_processing = 1U;
#line 253
  pwrpriv->ips_mode = pwrpriv->ips_mode_req;
#line 255
  pwrpriv->ips_enter23a_cnts = pwrpriv->ips_enter23a_cnts + 1U;
#line 256
  if (GlobalDebugLevel23A > 3U) {
#line 256
    printk("\016RTL8723AU: ==>ips_enter23a cnts:%d\n", pwrpriv->ips_enter23a_cnts);
  } else {

  }
#line 257
  rtl8723a_BT_disable_coexist(padapter);
#line 259
  if ((unsigned int )pwrpriv->change_rfpwrstate == 2U) {
#line 260
    pwrpriv->bpower_saving = 1U;
#line 261
    if (GlobalDebugLevel23A != 0U) {
#line 261
      printk("\016RTL8723AU: OLD_ERROR nolinked power save enter\n");
    } else {

    }
#line 263
    if ((unsigned int )pwrpriv->ips_mode == 2U) {
#line 264
      pwrpriv->bkeepfwalive = 1U;
    } else {

    }
#line 266
    rtw_ips_pwr_down23a(padapter);
#line 267
    pwrpriv->rf_pwrstate = 2;
  } else {

  }
#line 269
  pwrpriv->bips_processing = 0U;
#line 271
  up(& pwrpriv->lock);
#line 272
  return;
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int ips_leave23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  int result ;
  int keyid ;
  u32 tmp ;

  {
#line 276
  pwrpriv = & padapter->pwrctrlpriv;
#line 277
  psecuritypriv = & padapter->securitypriv;
#line 278
  pmlmepriv = & padapter->mlmepriv;
#line 279
  result = 1;
#line 282
  down(& pwrpriv->lock);
#line 284
  if ((unsigned int )pwrpriv->rf_pwrstate == 2U && pwrpriv->bips_processing == 0U) {
#line 285
    pwrpriv->bips_processing = 1U;
#line 286
    pwrpriv->change_rfpwrstate = 0;
#line 287
    pwrpriv->ips_leave23a_cnts = pwrpriv->ips_leave23a_cnts + 1U;
#line 288
    if (GlobalDebugLevel23A > 3U) {
#line 288
      printk("\016RTL8723AU: ==>ips_leave23a cnts:%d\n", pwrpriv->ips_leave23a_cnts);
    } else {

    }
#line 291
    result = rtw_ips_pwr_up23a(padapter);
#line 292
    if (result == 1) {
#line 293
      pwrpriv->rf_pwrstate = 0;
    } else {

    }
#line 295
    if (GlobalDebugLevel23A != 0U) {
#line 295
      printk("\016RTL8723AU: OLD_ERROR nolinked power save leave\n");
    } else {

    }
#line 297
    if (psecuritypriv->dot11PrivacyAlgrthm == 1027073U || psecuritypriv->dot11PrivacyAlgrthm == 1027077U) {
#line 301
      if (GlobalDebugLevel23A > 3U) {
#line 301
        printk("\016RTL8723AU: ==>%s, channel(%d), processing(%x)\n", "ips_leave23a",
               (int )padapter->mlmeextpriv.cur_channel, pwrpriv->bips_processing);
      } else {

      }
#line 304
      set_channel_bwmode23a(padapter, (int )padapter->mlmeextpriv.cur_channel, 0,
                            0);
#line 308
      keyid = 0;
#line 308
      goto ldv_54263;
      ldv_54262: ;
#line 309
      if ((int )((unsigned long )pmlmepriv->key_mask >> keyid) & 1) {
#line 310
        if ((u32 )keyid == psecuritypriv->dot11PrivacyKeyIndex) {
#line 312
          result = rtw_set_key23a(padapter, psecuritypriv, keyid, 1);
        } else {
#line 314
          result = rtw_set_key23a(padapter, psecuritypriv, keyid, 0);
        }
      } else {

      }
#line 308
      keyid = keyid + 1;
      ldv_54263: ;
#line 308
      if (keyid <= 3) {
#line 310
        goto ldv_54262;
      } else {

      }

    } else {

    }
#line 319
    if (GlobalDebugLevel23A > 3U) {
#line 319
      tmp = rtl8723au_read32(padapter, 76U);
#line 319
      printk("\016RTL8723AU: ==> ips_leave23a.....LED(0x%08x)...\n", tmp);
    } else {

    }
#line 321
    pwrpriv->bips_processing = 0U;
#line 323
    pwrpriv->bkeepfwalive = 0U;
#line 324
    pwrpriv->bpower_saving = 0U;
  } else {

  }
#line 327
  up(& pwrpriv->lock);
#line 329
  return (result);
}
}
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
static bool rtw_pwr_unassociated_idle(struct rtw_adapter *adapter ) 
{ 
  struct rtw_adapter *buddy ;
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmit_priv ;
  bool ret ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  struct mlme_priv *b_pmlmepriv ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;

  {
#line 335
  buddy = adapter->pbuddy_adapter;
#line 336
  pmlmepriv = & adapter->mlmepriv;
#line 337
  pxmit_priv = & adapter->xmitpriv;
#line 339
  ret = 0;
#line 341
  if ((long )(adapter->pwrctrlpriv.ips_deny_time - (unsigned long )jiffies) >= 0L) {
#line 342
    goto exit;
  } else {

  }
#line 344
  tmp = check_fwstate(pmlmepriv, 2049);
#line 344
  if ((int )tmp) {
#line 348
    goto exit;
  } else {
#line 344
    tmp___0 = check_fwstate(pmlmepriv, 384);
#line 344
    if ((int )tmp___0) {
#line 348
      goto exit;
    } else {
#line 344
      tmp___1 = check_fwstate(pmlmepriv, 16);
#line 344
      if ((int )tmp___1) {
#line 348
        goto exit;
      } else {
#line 344
        tmp___2 = check_fwstate(pmlmepriv, 96);
#line 344
        if ((int )tmp___2) {
#line 348
          goto exit;
        } else {

        }
      }
    }
  }
#line 352
  if ((unsigned long )buddy != (unsigned long )((struct rtw_adapter *)0)) {
#line 353
    b_pmlmepriv = & buddy->mlmepriv;
#line 355
    tmp___3 = check_fwstate(b_pmlmepriv, 2049);
#line 355
    if ((int )tmp___3) {
#line 362
      goto exit;
    } else {
#line 355
      tmp___4 = check_fwstate(b_pmlmepriv, 384);
#line 355
      if ((int )tmp___4) {
#line 362
        goto exit;
      } else {
#line 355
        tmp___5 = check_fwstate(b_pmlmepriv, 16);
#line 355
        if ((int )tmp___5) {
#line 362
          goto exit;
        } else {
#line 355
          tmp___6 = check_fwstate(b_pmlmepriv, 96);
#line 355
          if ((int )tmp___6) {
#line 362
            goto exit;
          } else {

          }
        }
      }
    }
  } else {

  }
#line 366
  if (pxmit_priv->free_xmitbuf_cnt != 4U || pxmit_priv->free_xmit_extbuf_cnt != 32U) {
#line 368
    if (GlobalDebugLevel23A != 0U) {
#line 368
      printk("\016RTL8723AU: OLD_ERROR There are some pkts to transmit\n");
    } else {

    }
#line 370
    if (GlobalDebugLevel23A > 6U) {
#line 370
      printk("\016RTL8723AU: OLD_ERROR free_xmitbuf_cnt: %d, free_xmit_extbuf_cnt: %d\n",
             pxmit_priv->free_xmitbuf_cnt, pxmit_priv->free_xmit_extbuf_cnt);
    } else {

    }
#line 374
    goto exit;
  } else {

  }
#line 377
  ret = 1;
  exit: ;
#line 380
  return (ret);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void rtw_ps_processor23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  enum rt_rf_power_state rfpwrstate ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 385
  pwrpriv = & padapter->pwrctrlpriv;
#line 386
  pmlmepriv = & padapter->mlmepriv;
#line 389
  pwrpriv->ps_processing = 1U;
#line 391
  if (pwrpriv->bips_processing == 1U) {
#line 392
    goto exit;
  } else {

  }
#line 394
  if ((unsigned int )padapter->pwrctrlpriv.bHWPwrPindetect != 0U) {
#line 395
    rfpwrstate = RfOnOffDetect23a(padapter);
#line 396
    if (GlobalDebugLevel23A > 3U) {
#line 396
      printk("\016RTL8723AU: @@@@- #2  %s ==> rfstate:%s\n", "rtw_ps_processor23a",
             (unsigned int )rfpwrstate == 0U ? (char *)"rf_on" : (char *)"rf_off");
    } else {

    }
#line 399
    if ((unsigned int )pwrpriv->rf_pwrstate != (unsigned int )rfpwrstate) {
#line 400
      if ((unsigned int )rfpwrstate == 2U) {
#line 401
        pwrpriv->change_rfpwrstate = 2;
#line 402
        pwrpriv->brfoffbyhw = 1U;
#line 403
        padapter->bCardDisableWOHSM = 1;
#line 404
        rtw_hw_suspend23a(padapter);
      } else {
#line 406
        pwrpriv->change_rfpwrstate = 0;
#line 407
        rtw_hw_resume23a(padapter);
      }
#line 409
      if (GlobalDebugLevel23A > 3U) {
#line 409
        printk("\016RTL8723AU: current rf_pwrstate(%s)\n", (unsigned int )pwrpriv->rf_pwrstate == 2U ? (char *)"rf_off" : (char *)"rf_on");
      } else {

      }
    } else {

    }
#line 413
    pwrpriv->pwr_state_check_cnts = (u8 )((int )pwrpriv->pwr_state_check_cnts + 1);
  } else {

  }
#line 416
  if ((unsigned int )pwrpriv->ips_mode_req == 0U) {
#line 417
    goto exit;
  } else {

  }
#line 419
  tmp = rtw_pwr_unassociated_idle(padapter);
#line 419
  if (tmp) {
#line 419
    tmp___0 = 0;
  } else {
#line 419
    tmp___0 = 1;
  }
#line 419
  if (tmp___0) {
#line 420
    goto exit;
  } else {

  }
#line 422
  if ((unsigned int )pwrpriv->rf_pwrstate == 0U && ((unsigned int )pwrpriv->pwr_state_check_cnts & 3U) == 0U) {
#line 424
    if (GlobalDebugLevel23A > 3U) {
#line 424
      tmp___1 = get_fwstate(pmlmepriv);
#line 424
      printk("\016RTL8723AU: ==>%s .fw_state(%x)\n", "rtw_ps_processor23a", tmp___1);
    } else {

    }
#line 426
    pwrpriv->change_rfpwrstate = 2;
#line 427
    ips_enter23a(padapter);
  } else {

  }
  exit: 
#line 430
  tmp___2 = msecs_to_jiffies((unsigned int const   )padapter->pwrctrlpriv.pwr_state_check_interval);
#line 430
  ldv_mod_timer_617(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp___2 + (unsigned long )jiffies);
#line 431
  pwrpriv->ps_processing = 0U;
#line 432
  return;
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
static void pwr_state_check_handler(unsigned long data ) 
{ 
  struct rtw_adapter *padapter ;

  {
#line 437
  padapter = (struct rtw_adapter *)data;
#line 438
  rtw_ps_cmd23a(padapter);
#line 439
  return;
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void rtw_set_rpwm23a(struct rtw_adapter *padapter , u8 pslv ) 
{ 
  u8 rpwm ;
  struct pwrctrl_priv *pwrpriv ;

  {
#line 451
  pwrpriv = & padapter->pwrctrlpriv;
#line 453
  pslv = (unsigned int )pslv & 15U;
#line 455
  if ((unsigned int )pwrpriv->btcoex_rfon != 0U) {
#line 456
    if ((unsigned int )pslv <= 11U) {
#line 457
      pslv = 4U;
    } else {

    }
  } else {

  }
#line 460
  if ((int )((unsigned char )pwrpriv->rpwm) == (int )pslv) {
#line 461
    if (GlobalDebugLevel23A > 3U) {
#line 461
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
#line 461
      printk("\016%s: Already set rpwm[0x%02X], new = 0x%02X!\n", "rtw_set_rpwm23a",
             (int )pwrpriv->rpwm, (int )pslv);
    } else {

    }
#line 464
    return;
  } else {

  }
#line 467
  if (padapter->bSurpriseRemoved == 1 || (unsigned int )padapter->hw_init_completed == 0U) {
#line 469
    if (GlobalDebugLevel23A > 3U) {
#line 469
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
#line 469
      printk("\016%s: SurpriseRemoved(%d) hw_init_completed(%d)\n", "rtw_set_rpwm23a",
             padapter->bSurpriseRemoved, (int )padapter->hw_init_completed);
    } else {

    }
#line 474
    pwrpriv->cpwm = 12U;
#line 476
    return;
  } else {

  }
#line 479
  if (padapter->bDriverStopped == 1) {
#line 480
    if (GlobalDebugLevel23A > 3U) {
#line 480
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
#line 480
      printk("\016%s: change power state(0x%02X) when DriverStopped\n", "rtw_set_rpwm23a",
             (int )pslv);
    } else {

    }
#line 484
    if ((unsigned int )pslv <= 1U) {
#line 485
      if (GlobalDebugLevel23A > 3U) {
#line 485
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
#line 485
        printk("\016%s: Reject to enter PS_STATE(0x%02X) lower than S2 when DriverStopped!!\n",
               "rtw_set_rpwm23a", (int )pslv);
      } else {

      }
#line 489
      return;
    } else {

    }
  } else {

  }
#line 493
  rpwm = (u8 )((int )((unsigned char )pwrpriv->tog) | (int )pslv);
#line 494
  if (GlobalDebugLevel23A > 5U) {
#line 494
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 6);
#line 494
    printk("\016rtw_set_rpwm23a: rpwm = 0x%02x cpwm = 0x%02x\n", (int )rpwm, (int )pwrpriv->cpwm);
  } else {

  }
#line 498
  pwrpriv->rpwm = pslv;
#line 500
  rtl8723a_set_rpwm(padapter, (int )rpwm);
#line 502
  pwrpriv->tog = (unsigned int )pwrpriv->tog + 128U;
#line 503
  pwrpriv->cpwm = pslv;
#line 504
  return;
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
static bool PS_RDY_CHECK(struct rtw_adapter *padapter ) 
{ 
  unsigned long delta_time ;
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 509
  pwrpriv = & padapter->pwrctrlpriv;
#line 510
  pmlmepriv = & padapter->mlmepriv;
#line 512
  delta_time = (unsigned long )jiffies - pwrpriv->DelayLPSLastTimeStamp;
#line 514
  if (delta_time <= 249UL) {
#line 515
    return (0);
  } else {

  }
#line 517
  tmp = check_fwstate(pmlmepriv, 1);
#line 517
  if (tmp) {
#line 517
    tmp___0 = 0;
  } else {
#line 517
    tmp___0 = 1;
  }
#line 517
  if (tmp___0) {
#line 522
    return (0);
  } else {
#line 517
    tmp___1 = check_fwstate(pmlmepriv, 2048);
#line 517
    if ((int )tmp___1) {
#line 522
      return (0);
    } else {
#line 517
      tmp___2 = check_fwstate(pmlmepriv, 16);
#line 517
      if ((int )tmp___2) {
#line 522
        return (0);
      } else {
#line 517
        tmp___3 = check_fwstate(pmlmepriv, 64);
#line 517
        if ((int )tmp___3) {
#line 522
          return (0);
        } else {
#line 517
          tmp___4 = check_fwstate(pmlmepriv, 32);
#line 517
          if ((int )tmp___4) {
#line 522
            return (0);
          } else {

          }
        }
      }
    }
  }
#line 523
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 524
    return (0);
  } else {

  }
#line 525
  if (padapter->securitypriv.dot11AuthAlgrthm == 2U && (unsigned int )*((unsigned char *)padapter + 11436UL) == 0U) {
#line 527
    if (GlobalDebugLevel23A > 3U) {
#line 527
      printk("\016RTL8723AU: Group handshake still in progress !!!\n");
    } else {

    }
#line 528
    return (0);
  } else {

  }
#line 530
  tmp___5 = rtw_cfg80211_pwr_mgmt(padapter);
#line 530
  if (tmp___5) {
#line 530
    tmp___6 = 0;
  } else {
#line 530
    tmp___6 = 1;
  }
#line 530
  if (tmp___6) {
#line 531
    return (0);
  } else {

  }
#line 533
  return (1);
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void rtw_set_ps_mode23a(struct rtw_adapter *padapter , u8 ps_mode , u8 smart_ps ,
                        u8 bcn_ant_mode ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 539
  pwrpriv = & padapter->pwrctrlpriv;
#line 541
  if (GlobalDebugLevel23A > 5U) {
#line 541
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 6);
#line 541
    printk("\016%s: PowerMode =%d Smart_PS =%d\n", "rtw_set_ps_mode23a", (int )ps_mode,
           (int )smart_ps);
  } else {

  }
#line 545
  if ((unsigned int )ps_mode > 10U) {
#line 546
    if (GlobalDebugLevel23A > 3U) {
#line 546
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 524288U, 4);
#line 546
      printk("\016ps_mode:%d error\n", (int )ps_mode);
    } else {

    }
#line 548
    return;
  } else {

  }
#line 551
  if ((int )pwrpriv->pwr_mode == (int )ps_mode) {
#line 552
    if ((unsigned int )ps_mode == 0U) {
#line 553
      return;
    } else {

    }
#line 555
    if ((int )pwrpriv->smart_ps == (int )smart_ps && (int )pwrpriv->bcn_ant_mode == (int )bcn_ant_mode) {
#line 557
      return;
    } else {

    }
  } else {

  }
#line 560
  if ((unsigned int )ps_mode == 0U) {
#line 561
    if (GlobalDebugLevel23A > 3U) {
#line 561
      printk("\016RTL8723AU: rtw_set_ps_mode23a: Leave 802.11 power save\n");
    } else {

    }
#line 563
    pwrpriv->pwr_mode = ps_mode;
#line 564
    rtw_set_rpwm23a(padapter, 12);
#line 565
    rtl8723a_set_FwPwrMode_cmd(padapter, (int )ps_mode);
#line 566
    pwrpriv->bFwCurrentInPSMode = 0U;
  } else {
#line 568
    tmp = PS_RDY_CHECK(padapter);
#line 568
    if ((int )tmp) {
#line 568
      goto _L;
    } else {
#line 568
      tmp___0 = rtl8723a_BT_using_antenna_1(padapter);
#line 568
      if ((int )tmp___0) {
        _L: /* CIL Label */ 
#line 570
        if (GlobalDebugLevel23A > 3U) {
#line 570
          printk("\016RTL8723AU: %s: Enter 802.11 power save\n", "rtw_set_ps_mode23a");
        } else {

        }
#line 572
        pwrpriv->bFwCurrentInPSMode = 1U;
#line 573
        pwrpriv->pwr_mode = ps_mode;
#line 574
        pwrpriv->smart_ps = smart_ps;
#line 575
        pwrpriv->bcn_ant_mode = bcn_ant_mode;
#line 576
        rtl8723a_set_FwPwrMode_cmd(padapter, (int )ps_mode);
#line 578
        rtw_set_rpwm23a(padapter, 2);
      } else {

      }
    }
  }
#line 580
  return;
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
s32 LPS_RF_ON_check23a(struct rtw_adapter *padapter , u32 delay_ms ) 
{ 
  unsigned long start_time ;
  unsigned long end_time ;
  u8 bAwake ;
  s32 err ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
#line 592
  bAwake = 0U;
#line 593
  err = 0;
#line 595
  start_time = jiffies;
#line 596
  tmp = msecs_to_jiffies(delay_ms);
#line 596
  end_time = tmp + start_time;
  ldv_54329: 
#line 600
  tmp___0 = rtl8723a_get_fwlps_rf_on(padapter);
#line 600
  bAwake = (u8 )tmp___0;
#line 601
  if ((unsigned int )bAwake == 1U) {
#line 602
    goto ldv_54321;
  } else {

  }
#line 604
  if (padapter->bSurpriseRemoved == 1) {
#line 605
    err = -2;
#line 606
    if (GlobalDebugLevel23A > 3U) {
#line 606
      printk("\016RTL8723AU: %s: device surprise removed!!\n", "LPS_RF_ON_check23a");
    } else {

    }
#line 607
    goto ldv_54321;
  } else {

  }
#line 610
  if ((long )(end_time - (unsigned long )jiffies) < 0L) {
#line 611
    err = -1;
#line 612
    if (GlobalDebugLevel23A > 3U) {
#line 612
      printk("\016RTL8723AU: %s: Wait for FW LPS leave more than %u ms!\n", "LPS_RF_ON_check23a",
             delay_ms);
    } else {

    }
#line 614
    goto ldv_54321;
  } else {

  }
#line 616
  __const_udelay(429500UL);
#line 617
  goto ldv_54329;
  ldv_54321: ;
#line 619
  return (err);
}
}
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void LPS_Enter23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  bool tmp ;
  int tmp___0 ;

  {
#line 626
  pwrpriv = & padapter->pwrctrlpriv;
#line 628
  tmp = PS_RDY_CHECK(padapter);
#line 628
  if (tmp) {
#line 628
    tmp___0 = 0;
  } else {
#line 628
    tmp___0 = 1;
  }
#line 628
  if (tmp___0) {
#line 629
    return;
  } else {

  }
#line 631
  if ((unsigned int )pwrpriv->bLeisurePs != 0U) {
#line 633
    if ((unsigned int )pwrpriv->LpsIdleCount > 1U) {
#line 634
      if ((unsigned int )pwrpriv->pwr_mode == 0U) {
#line 635
        pwrpriv->bpower_saving = 1U;
#line 636
        if (GlobalDebugLevel23A > 3U) {
#line 636
          printk("\016RTL8723AU: %s smart_ps:%d\n", "LPS_Enter23a", (int )pwrpriv->smart_ps);
        } else {

        }
#line 639
        rtw_set_ps_mode23a(padapter, (int )pwrpriv->power_mgnt, (int )pwrpriv->smart_ps,
                           0);
      } else {

      }
    } else {
#line 644
      pwrpriv->LpsIdleCount = (u8 )((int )pwrpriv->LpsIdleCount + 1);
    }
  } else {

  }
#line 645
  return;
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void LPS_Leave23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;

  {
#line 654
  pwrpriv = & padapter->pwrctrlpriv;
#line 656
  if ((unsigned int )pwrpriv->bLeisurePs != 0U) {
#line 657
    if ((unsigned int )pwrpriv->pwr_mode != 0U) {
#line 658
      rtw_set_ps_mode23a(padapter, 0, 0, 0);
#line 660
      if ((unsigned int )pwrpriv->pwr_mode == 0U) {
#line 661
        LPS_RF_ON_check23a(padapter, 100U);
      } else {

      }
    } else {

    }
  } else {

  }
#line 666
  pwrpriv->bpower_saving = 0U;
#line 667
  return;
}
}
#line 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void LeaveAllPowerSaveMode23a(struct rtw_adapter *Adapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  u8 enqueue ;
  bool tmp ;

  {
#line 673
  pmlmepriv = & Adapter->mlmepriv;
#line 674
  enqueue = 0U;
#line 677
  tmp = check_fwstate(pmlmepriv, 1);
#line 677
  if ((int )tmp) {
#line 678
    rtw_lps_ctrl_wk_cmd23a(Adapter, 5, (int )enqueue);
  } else {

  }
#line 679
  return;
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void rtw_init_pwrctrl_priv23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrctrlpriv ;

  {
#line 683
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 685
  sema_init(& pwrctrlpriv->lock, 1);
#line 686
  pwrctrlpriv->rf_pwrstate = 0;
#line 687
  pwrctrlpriv->ips_enter23a_cnts = 0U;
#line 688
  pwrctrlpriv->ips_leave23a_cnts = 0U;
#line 689
  pwrctrlpriv->bips_processing = 0U;
#line 691
  pwrctrlpriv->ips_mode = padapter->registrypriv.ips_mode;
#line 692
  pwrctrlpriv->ips_mode_req = padapter->registrypriv.ips_mode;
#line 694
  pwrctrlpriv->pwr_state_check_interval = 2000;
#line 695
  pwrctrlpriv->pwr_state_check_cnts = 0U;
#line 696
  pwrctrlpriv->bInSuspend = 0U;
#line 697
  pwrctrlpriv->bkeepfwalive = 0U;
#line 699
  pwrctrlpriv->LpsIdleCount = 0U;
#line 702
  pwrctrlpriv->power_mgnt = padapter->registrypriv.power_mgnt;
#line 703
  pwrctrlpriv->bLeisurePs = (unsigned int )pwrctrlpriv->power_mgnt != 0U;
#line 706
  pwrctrlpriv->bFwCurrentInPSMode = 0U;
#line 708
  pwrctrlpriv->rpwm = 0U;
#line 709
  pwrctrlpriv->cpwm = 12U;
#line 711
  pwrctrlpriv->pwr_mode = 0U;
#line 712
  pwrctrlpriv->smart_ps = padapter->registrypriv.smart_ps;
#line 713
  pwrctrlpriv->bcn_ant_mode = 0U;
#line 715
  pwrctrlpriv->tog = 128U;
#line 717
  pwrctrlpriv->btcoex_rfon = 0U;
#line 719
  reg_timer_6(& pwrctrlpriv->pwr_state_check_timer, & pwr_state_check_handler, (unsigned long )padapter);
#line 720
  return;
}
}
#line 723 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter ) 
{ 


  {
#line 725
  return;
}
}
#line 740 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int _rtw_pwr_wakeup23a(struct rtw_adapter *padapter , u32 ips_deffer_ms , char const   *caller ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct mlme_priv *pmlmepriv ;
  int ret ;
  unsigned long start ;
  unsigned long new_deny_time ;
  unsigned long tmp ;
  unsigned int tmp___0 ;
  bool tmp___1 ;
  unsigned int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  unsigned int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  unsigned long tmp___8 ;

  {
#line 742
  pwrpriv = & padapter->pwrctrlpriv;
#line 743
  pmlmepriv = & padapter->mlmepriv;
#line 744
  ret = 1;
#line 745
  start = jiffies;
#line 748
  tmp = msecs_to_jiffies(ips_deffer_ms);
#line 748
  new_deny_time = tmp + (unsigned long )jiffies;
#line 750
  if ((long )(pwrpriv->ips_deny_time - new_deny_time) < 0L) {
#line 751
    pwrpriv->ips_deny_time = new_deny_time;
  } else {

  }
#line 753
  if ((unsigned int )pwrpriv->ps_processing != 0U) {
#line 754
    if (GlobalDebugLevel23A > 3U) {
#line 754
      printk("\016RTL8723AU: %s wait ps_processing...\n", "_rtw_pwr_wakeup23a");
    } else {

    }
#line 755
    goto ldv_54374;
    ldv_54373: 
#line 757
    msleep(10U);
    ldv_54374: ;
#line 755
    if ((unsigned int )pwrpriv->ps_processing != 0U) {
#line 755
      tmp___0 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 755
      if (tmp___0 <= 3000U) {
#line 758
        goto ldv_54373;
      } else {
#line 761
        goto ldv_54375;
      }
    } else {

    }
    ldv_54375: ;
#line 758
    if ((unsigned int )pwrpriv->ps_processing != 0U) {
#line 759
      if (GlobalDebugLevel23A > 3U) {
#line 759
        printk("\016RTL8723AU: %s wait ps_processing timeout\n", "_rtw_pwr_wakeup23a");
      } else {

      }
    } else
#line 761
    if (GlobalDebugLevel23A > 3U) {
#line 761
      printk("\016RTL8723AU: %s wait ps_processing done\n", "_rtw_pwr_wakeup23a");
    } else {

    }
  } else {

  }
#line 764
  tmp___4 = rtw_sreset_inprogress(padapter);
#line 764
  if ((int )tmp___4) {
#line 765
    if (GlobalDebugLevel23A > 3U) {
#line 765
      printk("\016RTL8723AU: %s wait sreset_inprogress...\n", "_rtw_pwr_wakeup23a");
    } else {

    }
#line 766
    goto ldv_54377;
    ldv_54376: 
#line 768
    msleep(10U);
    ldv_54377: 
#line 766
    tmp___1 = rtw_sreset_inprogress(padapter);
#line 766
    if ((int )tmp___1) {
#line 766
      tmp___2 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 766
      if (tmp___2 <= 4000U) {
#line 769
        goto ldv_54376;
      } else {
#line 772
        goto ldv_54378;
      }
    } else {

    }
    ldv_54378: 
#line 769
    tmp___3 = rtw_sreset_inprogress(padapter);
#line 769
    if ((int )tmp___3) {
#line 770
      if (GlobalDebugLevel23A > 3U) {
#line 770
        printk("\016RTL8723AU: %s wait sreset_inprogress timeout\n", "_rtw_pwr_wakeup23a");
      } else {

      }
    } else
#line 773
    if (GlobalDebugLevel23A > 3U) {
#line 773
      printk("\016RTL8723AU: %s wait sreset_inprogress done\n", "_rtw_pwr_wakeup23a");
    } else {

    }
  } else {

  }
#line 776
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 777
    if (GlobalDebugLevel23A > 3U) {
#line 777
      printk("\016RTL8723AU: %s wait bInSuspend...\n", "_rtw_pwr_wakeup23a");
    } else {

    }
#line 778
    goto ldv_54380;
    ldv_54379: 
#line 780
    msleep(10U);
    ldv_54380: ;
#line 778
    if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 778
      tmp___5 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 778
      if (tmp___5 <= 3000U) {
#line 781
        goto ldv_54379;
      } else {
#line 784
        goto ldv_54381;
      }
    } else {

    }
    ldv_54381: ;
#line 782
    if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 783
      if (GlobalDebugLevel23A > 3U) {
#line 783
        printk("\016RTL8723AU: %s wait bInSuspend timeout\n", "_rtw_pwr_wakeup23a");
      } else {

      }
    } else
#line 785
    if (GlobalDebugLevel23A > 3U) {
#line 785
      printk("\016RTL8723AU: %s wait bInSuspend done\n", "_rtw_pwr_wakeup23a");
    } else {

    }
  } else {

  }
#line 789
  if ((unsigned int )pwrpriv->bInSuspend != 0U) {
#line 790
    ret = 0;
#line 791
    goto exit;
  } else {

  }
#line 795
  tmp___6 = check_fwstate(pmlmepriv, 1);
#line 795
  if ((int )tmp___6) {
#line 796
    ret = 1;
#line 797
    goto exit;
  } else {

  }
#line 800
  if ((unsigned int )pwrpriv->rf_pwrstate == 2U) {
#line 801
    if (GlobalDebugLevel23A > 3U) {
#line 801
      printk("\016RTL8723AU: %s call ips_leave23a....\n", "_rtw_pwr_wakeup23a");
    } else {

    }
#line 802
    tmp___7 = ips_leave23a(padapter);
#line 802
    if (tmp___7 == 0) {
#line 803
      if (GlobalDebugLevel23A > 3U) {
#line 803
        printk("\016RTL8723AU: ======> ips_leave23a fail.............\n");
      } else {

      }
#line 804
      ret = 0;
#line 805
      goto exit;
    } else {

    }
  } else {

  }
#line 810
  if ((padapter->bDriverStopped != 0 || padapter->bup == 0) || (unsigned int )padapter->hw_init_completed == 0U) {
#line 812
    if (GlobalDebugLevel23A > 3U) {
#line 812
      printk("\016RTL8723AU: %s: bDriverStopped =%d, bup =%d, hw_init_completed =%u\n",
             caller, padapter->bDriverStopped, padapter->bup, (int )padapter->hw_init_completed);
    } else {

    }
#line 815
    ret = 0;
#line 816
    goto exit;
  } else {

  }
  exit: 
#line 820
  tmp___8 = msecs_to_jiffies(ips_deffer_ms);
#line 820
  new_deny_time = tmp___8 + (unsigned long )jiffies;
#line 821
  if ((long )(pwrpriv->ips_deny_time - new_deny_time) < 0L) {
#line 822
    pwrpriv->ips_deny_time = new_deny_time;
  } else {

  }
#line 823
  return (ret);
}
}
#line 826 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int rtw_pm_set_lps23a(struct rtw_adapter *padapter , u8 mode ) 
{ 
  int ret ;
  struct pwrctrl_priv *pwrctrlpriv ;

  {
#line 828
  ret = 0;
#line 829
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 831
  if ((unsigned int )mode <= 10U) {
#line 832
    if ((int )pwrctrlpriv->power_mgnt != (int )mode) {
#line 833
      if ((unsigned int )mode == 0U) {
#line 834
        LeaveAllPowerSaveMode23a(padapter);
      } else {
#line 836
        pwrctrlpriv->LpsIdleCount = 2U;
      }
#line 837
      pwrctrlpriv->power_mgnt = mode;
#line 838
      pwrctrlpriv->bLeisurePs = (unsigned int )pwrctrlpriv->power_mgnt != 0U;
    } else {

    }
  } else {
#line 843
    ret = -22;
  }
#line 845
  return (ret);
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int rtw_pm_set_ips23a(struct rtw_adapter *padapter , u8 mode ) 
{ 
  struct pwrctrl_priv *pwrctrlpriv ;
  int tmp ;

  {
#line 850
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 852
  if ((unsigned int )mode == 1U || (unsigned int )mode == 2U) {
#line 853
    pwrctrlpriv->ips_mode_req = mode;
#line 854
    if (GlobalDebugLevel23A > 3U) {
#line 854
      printk("\016RTL8723AU: %s %s\n", "rtw_pm_set_ips23a", (unsigned int )mode == 1U ? (char *)"IPS_NORMAL" : (char *)"IPS_LEVEL_2");
    } else {

    }
#line 856
    return (0);
  } else
#line 857
  if ((unsigned int )mode == 0U) {
#line 858
    pwrctrlpriv->ips_mode_req = mode;
#line 859
    if (GlobalDebugLevel23A > 3U) {
#line 859
      printk("\016RTL8723AU: %s %s\n", "rtw_pm_set_ips23a", (char *)"IPS_NONE");
    } else {

    }
#line 860
    if (padapter->bSurpriseRemoved == 0) {
#line 860
      tmp = _rtw_pwr_wakeup23a(padapter, 2000U, "rtw_pm_set_ips23a");
#line 860
      if (tmp == 0) {
#line 862
        return (-14);
      } else {

      }
    } else {

    }
  } else {
#line 864
    return (-22);
  }
#line 866
  return (0);
}
}
#line 870 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void activate_pending_timer_9(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 871
  if ((unsigned long )ldv_timer_list_9_0 == (unsigned long )timer) {
#line 872
    if (ldv_timer_9_0 == 2 || pending_flag != 0) {
#line 873
      ldv_timer_list_9_0 = timer;
#line 874
      ldv_timer_list_9_0->data = data;
#line 875
      ldv_timer_9_0 = 1;
    } else {

    }
#line 877
    return;
  } else {

  }
#line 880
  if ((unsigned long )ldv_timer_list_9_1 == (unsigned long )timer) {
#line 881
    if (ldv_timer_9_1 == 2 || pending_flag != 0) {
#line 882
      ldv_timer_list_9_1 = timer;
#line 883
      ldv_timer_list_9_1->data = data;
#line 884
      ldv_timer_9_1 = 1;
    } else {

    }
#line 886
    return;
  } else {

  }
#line 889
  if ((unsigned long )ldv_timer_list_9_2 == (unsigned long )timer) {
#line 890
    if (ldv_timer_9_2 == 2 || pending_flag != 0) {
#line 891
      ldv_timer_list_9_2 = timer;
#line 892
      ldv_timer_list_9_2->data = data;
#line 893
      ldv_timer_9_2 = 1;
    } else {

    }
#line 895
    return;
  } else {

  }
#line 898
  if ((unsigned long )ldv_timer_list_9_3 == (unsigned long )timer) {
#line 899
    if (ldv_timer_9_3 == 2 || pending_flag != 0) {
#line 900
      ldv_timer_list_9_3 = timer;
#line 901
      ldv_timer_list_9_3->data = data;
#line 902
      ldv_timer_9_3 = 1;
    } else {

    }
#line 904
    return;
  } else {

  }
#line 906
  activate_suitable_timer_9(timer, data);
#line 907
  return;
}
}
#line 910 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void ldv_timer_9(int state , struct timer_list *timer ) 
{ 


  {
#line 911
  LDV_IN_INTERRUPT = 2;
#line 912
  pwr_state_check_handler(timer->data);
#line 913
  LDV_IN_INTERRUPT = 1;
#line 914
  return;
}
}
#line 917 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void timer_init_9(void) 
{ 


  {
#line 918
  ldv_timer_9_0 = 0;
#line 919
  ldv_timer_9_1 = 0;
#line 920
  ldv_timer_9_2 = 0;
#line 921
  ldv_timer_9_3 = 0;
#line 922
  return;
}
}
#line 925 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void activate_suitable_timer_9(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 926
  if (ldv_timer_9_0 == 0 || ldv_timer_9_0 == 2) {
#line 927
    ldv_timer_list_9_0 = timer;
#line 928
    ldv_timer_list_9_0->data = data;
#line 929
    ldv_timer_9_0 = 1;
#line 930
    return;
  } else {

  }
#line 932
  if (ldv_timer_9_1 == 0 || ldv_timer_9_1 == 2) {
#line 933
    ldv_timer_list_9_1 = timer;
#line 934
    ldv_timer_list_9_1->data = data;
#line 935
    ldv_timer_9_1 = 1;
#line 936
    return;
  } else {

  }
#line 938
  if (ldv_timer_9_2 == 0 || ldv_timer_9_2 == 2) {
#line 939
    ldv_timer_list_9_2 = timer;
#line 940
    ldv_timer_list_9_2->data = data;
#line 941
    ldv_timer_9_2 = 1;
#line 942
    return;
  } else {

  }
#line 944
  if (ldv_timer_9_3 == 0 || ldv_timer_9_3 == 2) {
#line 945
    ldv_timer_list_9_3 = timer;
#line 946
    ldv_timer_list_9_3->data = data;
#line 947
    ldv_timer_9_3 = 1;
#line 948
    return;
  } else {

  }
#line 950
  return;
}
}
#line 954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int reg_timer_9(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 955
  if ((unsigned long )function == (unsigned long )(& pwr_state_check_handler)) {
#line 956
    activate_suitable_timer_9(timer, data);
  } else {

  }
#line 957
  return (0);
}
}
#line 961 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void disable_suitable_timer_9(struct timer_list *timer ) 
{ 


  {
#line 962
  if (ldv_timer_9_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_0) {
#line 963
    ldv_timer_9_0 = 0;
#line 964
    return;
  } else {

  }
#line 966
  if (ldv_timer_9_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_1) {
#line 967
    ldv_timer_9_1 = 0;
#line 968
    return;
  } else {

  }
#line 970
  if (ldv_timer_9_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_2) {
#line 971
    ldv_timer_9_2 = 0;
#line 972
    return;
  } else {

  }
#line 974
  if (ldv_timer_9_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_9_3) {
#line 975
    ldv_timer_9_3 = 0;
#line 976
    return;
  } else {

  }
#line 978
  return;
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void choose_timer_9(void) 
{ 
  int tmp ;

  {
#line 983
  tmp = __VERIFIER_nondet_int();
#line 983
  switch (tmp) {
  case 0: ;
#line 985
  if (ldv_timer_9_0 == 1) {
#line 986
    ldv_timer_9_0 = 2;
#line 987
    ldv_timer_9(ldv_timer_9_0, ldv_timer_list_9_0);
  } else {

  }
#line 990
  goto ldv_54430;
  case 1: ;
#line 992
  if (ldv_timer_9_1 == 1) {
#line 993
    ldv_timer_9_1 = 2;
#line 994
    ldv_timer_9(ldv_timer_9_1, ldv_timer_list_9_1);
  } else {

  }
#line 997
  goto ldv_54430;
  case 2: ;
#line 999
  if (ldv_timer_9_2 == 1) {
#line 1000
    ldv_timer_9_2 = 2;
#line 1001
    ldv_timer_9(ldv_timer_9_2, ldv_timer_list_9_2);
  } else {

  }
#line 1004
  goto ldv_54430;
  case 3: ;
#line 1006
  if (ldv_timer_9_3 == 1) {
#line 1007
    ldv_timer_9_3 = 2;
#line 1008
    ldv_timer_9(ldv_timer_9_3, ldv_timer_list_9_3);
  } else {

  }
#line 1011
  goto ldv_54430;
  default: 
#line 1012
  ldv_stop();
  }
  ldv_54430: ;
#line 1014
  return;
}
}
#line 1144 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
void *ldv_kmem_cache_alloc_600(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1147
  ldv_check_alloc_flags(flags);
#line 1149
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1150
  return ((void *)0);
}
}
#line 1188 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int ldv_pskb_expand_head_606(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1191
  ldv_check_alloc_flags(flags);
#line 1193
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1193
  return (tmp);
}
}
#line 1204 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
struct sk_buff *ldv_skb_clone_608(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1207
  ldv_check_alloc_flags(flags);
#line 1209
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1209
  return (tmp);
}
}
#line 1220 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
struct sk_buff *ldv_skb_copy_610(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1223
  ldv_check_alloc_flags(flags);
#line 1225
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1225
  return (tmp);
}
}
#line 1228 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_611(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1231
  ldv_check_alloc_flags(flags);
#line 1233
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1233
  return (tmp);
}
}
#line 1236 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_612(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1239
  ldv_check_alloc_flags(flags);
#line 1241
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1241
  return (tmp);
}
}
#line 1244 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_613(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1247
  ldv_check_alloc_flags(flags);
#line 1249
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1249
  return (tmp);
}
}
#line 1252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int ldv_pskb_expand_head_614(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1255
  ldv_check_alloc_flags(flags);
#line 1257
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1257
  return (tmp);
}
}
#line 1260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int ldv_pskb_expand_head_615(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1263
  ldv_check_alloc_flags(flags);
#line 1265
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1265
  return (tmp);
}
}
#line 1268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
struct sk_buff *ldv_skb_clone_616(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1271
  ldv_check_alloc_flags(flags);
#line 1273
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1273
  return (tmp);
}
}
#line 1276 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_pwrctrl.o.c.prepared"
int ldv_mod_timer_617(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 1280
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1280
  ldv_func_res = tmp;
#line 1282
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 1284
  return (ldv_func_res);
}
}
#line 60 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 62
  __list_add(new, head, head->next);
#line 63
  return;
}
}
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 301 "include/linux/spinlock.h"
__inline static void ldv_spin_lock_629(spinlock_t *lock ) 
{ 


  {
#line 303
  _raw_spin_lock(& lock->ldv_6347.rlock);
#line 304
  return;
}
}
#line 301
__inline static void spin_lock(spinlock_t *lock ) ;
#line 310
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 345 "include/linux/spinlock.h"
__inline static void ldv_spin_unlock_633(spinlock_t *lock ) 
{ 


  {
#line 347
  _raw_spin_unlock(& lock->ldv_6347.rlock);
#line 348
  return;
}
}
#line 345
__inline static void spin_unlock(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 372
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 179 "include/linux/timer.h"
int ldv_mod_timer_661(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 183
int ldv_mod_timer_662(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 187
int ldv_mod_timer_664(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 191
int ldv_mod_timer_665(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 248
int ldv_del_timer_sync_663(struct timer_list *ldv_func_arg1 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_644(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct timer_list *ldv_timer_list_10_2 ;
#line 48
struct timer_list *ldv_timer_list_10_0 ;
#line 68
int ldv_timer_10_2 ;
#line 75
struct timer_list *ldv_timer_list_10_1 ;
#line 109
int ldv_timer_10_0 ;
#line 121
int ldv_timer_10_1 ;
#line 128
struct timer_list *ldv_timer_list_10_3 ;
#line 134
int ldv_timer_10_3 ;
#line 146
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 148
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 168
void ldv_timer_10(int state , struct timer_list *timer ) ;
#line 173
void disable_suitable_timer_10(struct timer_list *timer ) ;
#line 189
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data ) ;
#line 196
void timer_init_10(void) ;
#line 209
void choose_timer_10(void) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_652(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_660(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_654(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_650(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_658(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_659(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 904 "include/linux/skbuff.h"
__inline static int skb_queue_empty(struct sk_buff_head  const  *list ) 
{ 


  {
#line 906
  return ((unsigned long )((struct sk_buff  const  *)list->next) == (unsigned long )((struct sk_buff  const  *)list));
}
}
#line 1136 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_peek(struct sk_buff_head  const  *list_ ) 
{ 
  struct sk_buff *skb ;

  {
#line 1138
  skb = list_->next;
#line 1140
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)list_)) {
#line 1141
    skb = (struct sk_buff *)0;
  } else {

  }
#line 1142
  return (skb);
}
}
#line 1204 "include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1206
  tmp = (struct sk_buff *)list;
#line 1206
  list->next = tmp;
#line 1206
  list->prev = tmp;
#line 1207
  list->qlen = 0U;
#line 1208
  return;
}
}
#line 1393 "include/linux/skbuff.h"
__inline static void __skb_unlink(struct sk_buff *skb , struct sk_buff_head *list ) 
{ 
  struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *tmp ;

  {
#line 1397
  list->qlen = list->qlen - 1U;
#line 1398
  next = skb->next;
#line 1399
  prev = skb->prev;
#line 1400
  tmp = (struct sk_buff *)0;
#line 1400
  skb->prev = tmp;
#line 1400
  skb->next = tmp;
#line 1401
  next->prev = prev;
#line 1402
  prev->next = next;
#line 1403
  return;
}
}
#line 1414 "include/linux/skbuff.h"
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
#line 1416
  tmp = skb_peek((struct sk_buff_head  const  *)list);
#line 1416
  skb = tmp;
#line 1417
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 1418
    __skb_unlink(skb, list);
  } else {

  }
#line 1419
  return (skb);
}
}
#line 1527 "include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 1529
  return ((unsigned char *)skb->head + (unsigned long )skb->tail);
}
}
#line 1565
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
#line 1583
extern unsigned char *skb_pull(struct sk_buff * , unsigned int  ) ;
#line 1929
extern void skb_trim(struct sk_buff * , unsigned int  ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_655(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_656(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_657(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2555 "include/linux/netdevice.h"
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason  ) ;
#line 2586 "include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 


  {
#line 2588
  __dev_kfree_skb_any(skb, 1);
#line 2589
  return;
}
}
#line 2596
extern int netif_rx(struct sk_buff * ) ;
#line 32 "include/linux/etherdevice.h"
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
#line 247 "include/linux/ieee80211.h"
__inline static int ieee80211_has_tods(__le16 fc ) 
{ 


  {
#line 249
  return (((int )fc & 256) != 0);
}
}
#line 256 "include/linux/ieee80211.h"
__inline static int ieee80211_has_fromds(__le16 fc ) 
{ 


  {
#line 258
  return (((int )fc & 512) != 0);
}
}
#line 265 "include/linux/ieee80211.h"
__inline static int ieee80211_has_a4(__le16 fc ) 
{ 
  __le16 tmp ;

  {
#line 267
  tmp = 768U;
#line 268
  return (((int )fc & (int )tmp) == (int )tmp);
}
}
#line 275 "include/linux/ieee80211.h"
__inline static int ieee80211_has_morefrags(__le16 fc ) 
{ 


  {
#line 277
  return (((int )fc & 1024) != 0);
}
}
#line 293 "include/linux/ieee80211.h"
__inline static int ieee80211_has_pm(__le16 fc ) 
{ 


  {
#line 295
  return (((int )fc & 4096) != 0);
}
}
#line 302 "include/linux/ieee80211.h"
__inline static int ieee80211_has_moredata(__le16 fc ) 
{ 


  {
#line 304
  return (((int )fc & 8192) != 0);
}
}
#line 311 "include/linux/ieee80211.h"
__inline static int ieee80211_has_protected(__le16 fc ) 
{ 


  {
#line 313
  return (((int )fc & 16384) != 0);
}
}
#line 320 "include/linux/ieee80211.h"
__inline static int ieee80211_has_order(__le16 fc ) 
{ 


  {
#line 322
  return ((int )((short )fc) < 0);
}
}
#line 339 "include/linux/ieee80211.h"
__inline static int ieee80211_is_ctl(__le16 fc ) 
{ 


  {
#line 341
  return (((int )fc & 12) == 4);
}
}
#line 349 "include/linux/ieee80211.h"
__inline static int ieee80211_is_data(__le16 fc ) 
{ 


  {
#line 351
  return (((int )fc & 12) == 8);
}
}
#line 359 "include/linux/ieee80211.h"
__inline static int ieee80211_is_data_qos(__le16 fc ) 
{ 


  {
#line 365
  return (((int )fc & 140) == 136);
}
}
#line 527 "include/linux/ieee80211.h"
__inline static int ieee80211_is_pspoll(__le16 fc ) 
{ 


  {
#line 529
  return (((int )fc & 252) == 164);
}
}
#line 587 "include/linux/ieee80211.h"
__inline static int ieee80211_is_nullfunc(__le16 fc ) 
{ 


  {
#line 589
  return (((int )fc & 252) == 72);
}
}
#line 2210 "include/linux/ieee80211.h"
__inline static u8 *ieee80211_get_qos_ctl(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;

  {
#line 2212
  tmp = ieee80211_has_a4((int )hdr->frame_control);
#line 2212
  if (tmp != 0) {
#line 2213
    return ((u8 *)hdr + 30UL);
  } else {
#line 2215
    return ((u8 *)hdr + 24UL);
  }
}
}
#line 2228 "include/linux/ieee80211.h"
__inline static u8 *ieee80211_get_SA(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2230
  tmp = ieee80211_has_a4((int )hdr->frame_control);
#line 2230
  if (tmp != 0) {
#line 2231
    return ((u8 *)(& hdr->addr4));
  } else {

  }
#line 2232
  tmp___0 = ieee80211_has_fromds((int )hdr->frame_control);
#line 2232
  if (tmp___0 != 0) {
#line 2233
    return ((u8 *)(& hdr->addr3));
  } else {

  }
#line 2234
  return ((u8 *)(& hdr->addr2));
}
}
#line 2247 "include/linux/ieee80211.h"
__inline static u8 *ieee80211_get_DA(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;

  {
#line 2249
  tmp = ieee80211_has_tods((int )hdr->frame_control);
#line 2249
  if (tmp != 0) {
#line 2250
    return ((u8 *)(& hdr->addr3));
  } else {
#line 2252
    return ((u8 *)(& hdr->addr1));
  }
}
}
#line 3498 "include/net/cfg80211.h"
extern unsigned char const   rfc1042_header[6U] ;
#line 3499
extern unsigned char const   bridge_tunnel_header[6U] ;
#line 3577
extern void ieee80211_amsdu_to_8023s(struct sk_buff * , struct sk_buff_head * , u8 const   * ,
                                     enum nl80211_iftype  , unsigned int const    ,
                                     bool  ) ;
#line 68 "drivers/staging/rtl8723au/include/osdep_service.h"
__inline static u32 CHKBIT(u32 x ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 70
  __ret_warn_on = x > 31U;
#line 70
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 70
  if (tmp != 0L) {
#line 70
    warn_slowpath_null("drivers/staging/rtl8723au/include/osdep_service.h", 70);
  } else {

  }
#line 70
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (x > 31U) {
#line 72
    return (0U);
  } else {

  }
#line 73
  return ((u32 )(1UL << (int )x));
}
}
#line 386 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void stop_sta_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 387
void wakeup_sta_to_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 388
void xmit_delivery_enabled_frames23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 278 "drivers/staging/rtl8723au/include/rtw_recv.h"
struct recv_frame *rtw_alloc_recvframe23a(struct rtw_queue *pfree_recv_queue ) ;
#line 279
int rtw_free_recvframe23a(struct recv_frame *precvframe ) ;
#line 281
int rtw_enqueue_recvframe23a(struct recv_frame *precvframe , struct rtw_queue *queue ) ;
#line 285
int rtw_enqueue_recvbuf23a_to_head(struct recv_buf *precvbuf , struct rtw_queue *queue ) ;
#line 286
int rtw_enqueue_recvbuf23a(struct recv_buf *precvbuf , struct rtw_queue *queue ) ;
#line 287
struct recv_buf *rtw_dequeue_recvbuf23a(struct rtw_queue *queue ) ;
#line 289
void rtw_reordering_ctrl_timeout_handler23a(unsigned long pcontext ) ;
#line 305
void _rtw_init_sta_recv_priv23a(struct sta_recv_priv *psta_recvpriv ) ;
#line 317 "drivers/staging/rtl8723au/include/rtw_security.h"
void rtw_seccalctkipmic23a(u8 *key , u8 *header , u8 *data , u32 data_len , u8 *mic_code ,
                           u8 pri ) ;
#line 326
int rtw_aes_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
#line 328
int rtw_tkip_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
#line 330
void rtw_wep_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) ;
#line 249 "drivers/staging/rtl8723au/include/rtw_mlme.h"
__inline static u8 *get_bssid(struct mlme_priv *pmlmepriv ) 
{ 


  {
#line 252
  return ((u8 *)(& pmlmepriv->cur_network.network.MacAddress));
}
}
#line 21 "drivers/staging/rtl8723au/include/recv_osdep.h"
int _rtw_init_recv_priv23a(struct recv_priv *precvpriv , struct rtw_adapter *padapter ) ;
#line 22
void _rtw_free_recv_priv23a(struct recv_priv *precvpriv ) ;
#line 24
int rtw_recv_entry23a(struct recv_frame *rframe ) ;
#line 25
int rtw_recv_indicatepkt23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 27
void rtw_handle_tkip_mic_err23a(struct rtw_adapter *padapter , u8 bgroup ) ;
#line 63 "drivers/staging/rtl8723au/include/rtl8723a_recv.h"
int rtl8723au_init_recv_priv(struct rtw_adapter *padapter ) ;
#line 64
void rtl8723au_free_recv_priv(struct rtw_adapter *padapter ) ;
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void rtw_signal_stat_timer_hdl23a(unsigned long data ) ;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void _rtw_init_sta_recv_priv23a(struct sta_recv_priv *psta_recvpriv ) 
{ 
  struct lock_class_key __key ;

  {
#line 253
  spinlock_check(& psta_recvpriv->lock);
#line 253
  __raw_spin_lock_init(& psta_recvpriv->lock.ldv_6347.rlock, "&(&psta_recvpriv->lock)->rlock",
                       & __key);
#line 258
  _rtw_init_queue23a(& psta_recvpriv->defrag_q);
#line 259
  return;
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int _rtw_init_recv_priv23a(struct recv_priv *precvpriv , struct rtw_adapter *padapter ) 
{ 
  struct recv_frame *precvframe ;
  int i ;
  int res ;
  struct lock_class_key __key ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 268
  res = 1;
#line 270
  spinlock_check(& precvpriv->lock);
#line 270
  __raw_spin_lock_init(& precvpriv->lock.ldv_6347.rlock, "&(&precvpriv->lock)->rlock",
                       & __key);
#line 272
  _rtw_init_queue23a(& precvpriv->free_recv_queue);
#line 273
  _rtw_init_queue23a(& precvpriv->recv_pending_queue);
#line 274
  _rtw_init_queue23a(& precvpriv->uc_swdec_pending_queue);
#line 276
  precvpriv->adapter = padapter;
#line 278
  i = 0;
#line 278
  goto ldv_51704;
  ldv_51703: 
#line 279
  tmp = kzalloc(144UL, 208U);
#line 279
  precvframe = (struct recv_frame *)tmp;
#line 280
  if ((unsigned long )precvframe == (unsigned long )((struct recv_frame *)0)) {
#line 281
    goto ldv_51702;
  } else {

  }
#line 282
  INIT_LIST_HEAD(& precvframe->list);
#line 284
  list_add_tail(& precvframe->list, & precvpriv->free_recv_queue.queue);
#line 287
  precvframe->adapter = padapter;
#line 288
  precvframe = precvframe + 1;
#line 278
  i = i + 1;
  ldv_51704: ;
#line 278
  if (i <= 255) {
#line 280
    goto ldv_51703;
  } else {

  }
  ldv_51702: 
#line 291
  precvpriv->free_recvframe_cnt = i;
#line 292
  precvpriv->rx_pending_cnt = 1U;
#line 294
  res = rtl8723au_init_recv_priv(padapter);
#line 296
  reg_timer_6(& precvpriv->signal_stat_timer, & rtw_signal_stat_timer_hdl23a, (unsigned long )padapter);
#line 299
  precvpriv->signal_stat_sampling_interval = 1000U;
#line 301
  tmp___0 = msecs_to_jiffies(precvpriv->signal_stat_sampling_interval);
#line 301
  ldv_mod_timer_661(& precvpriv->signal_stat_timer, tmp___0 + (unsigned long )jiffies);
#line 303
  return (res);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void _rtw_free_recv_priv23a(struct recv_priv *precvpriv ) 
{ 
  struct rtw_adapter *padapter ;
  struct recv_frame *precvframe ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;

  {
#line 308
  padapter = precvpriv->adapter;
#line 312
  rtw_free_uc_swdec_pending_queue23a(padapter);
#line 314
  plist = precvpriv->free_recv_queue.queue.next;
#line 314
  ptmp = plist->next;
#line 314
  goto ldv_51715;
  ldv_51714: 
#line 315
  __mptr = (struct list_head  const  *)plist;
#line 315
  precvframe = (struct recv_frame *)__mptr;
#line 316
  list_del_init(& precvframe->list);
#line 317
  kfree((void const   *)precvframe);
#line 314
  plist = ptmp;
#line 314
  ptmp = plist->next;
  ldv_51715: ;
#line 314
  if ((unsigned long )(& precvpriv->free_recv_queue.queue) != (unsigned long )plist) {
#line 316
    goto ldv_51714;
  } else {

  }
#line 320
  rtl8723au_free_recv_priv(padapter);
#line 321
  return;
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct recv_frame *rtw_alloc_recvframe23a(struct rtw_queue *pfree_recv_queue ) 
{ 
  struct recv_frame *pframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 330
  spin_lock_bh(& pfree_recv_queue->lock);
#line 332
  tmp = list_empty((struct list_head  const  *)(& pfree_recv_queue->queue));
#line 332
  if (tmp != 0) {
#line 333
    pframe = (struct recv_frame *)0;
  } else {
#line 335
    phead = get_list_head(pfree_recv_queue);
#line 337
    plist = phead->next;
#line 339
    __mptr = (struct list_head  const  *)plist;
#line 339
    pframe = (struct recv_frame *)__mptr;
#line 341
    list_del_init(& pframe->list);
#line 342
    padapter = pframe->adapter;
#line 343
    if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 344
      precvpriv = & padapter->recvpriv;
#line 345
      if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )pfree_recv_queue) {
#line 346
        precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt - 1;
      } else {

      }
    } else {

    }
  }
#line 350
  spin_unlock_bh(& pfree_recv_queue->lock);
#line 352
  return (pframe);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int rtw_free_recvframe23a(struct recv_frame *precvframe ) 
{ 
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *pfree_recv_queue ;
  struct list_head *tmp ;

  {
#line 357
  padapter = precvframe->adapter;
#line 358
  precvpriv = & padapter->recvpriv;
#line 361
  if ((unsigned long )precvframe->pkt != (unsigned long )((struct sk_buff *)0)) {
#line 362
    dev_kfree_skb_any(precvframe->pkt);
#line 363
    precvframe->pkt = (struct sk_buff *)0;
  } else {

  }
#line 366
  pfree_recv_queue = & precvpriv->free_recv_queue;
#line 367
  spin_lock_bh(& pfree_recv_queue->lock);
#line 369
  list_del_init(& precvframe->list);
#line 371
  tmp = get_list_head(pfree_recv_queue);
#line 371
  list_add_tail(& precvframe->list, tmp);
#line 373
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 374
    if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )pfree_recv_queue) {
#line 375
      precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt + 1;
    } else {

    }
  } else {

  }
#line 378
  spin_unlock_bh(& pfree_recv_queue->lock);
#line 382
  return (1);
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int rtw_enqueue_recvframe23a(struct recv_frame *precvframe , struct rtw_queue *queue ) 
{ 
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct list_head *tmp ;

  {
#line 387
  padapter = precvframe->adapter;
#line 388
  precvpriv = & padapter->recvpriv;
#line 390
  spin_lock_bh(& queue->lock);
#line 392
  list_del_init(& precvframe->list);
#line 394
  tmp = get_list_head(queue);
#line 394
  list_add_tail(& precvframe->list, tmp);
#line 396
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 397
    if ((unsigned long )(& precvpriv->free_recv_queue) == (unsigned long )queue) {
#line 398
      precvpriv->free_recvframe_cnt = precvpriv->free_recvframe_cnt + 1;
    } else {

    }
  } else {

  }
#line 401
  spin_unlock_bh(& queue->lock);
#line 403
  return (1);
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static void rtw_free_recvframe23a_queue(struct rtw_queue *pframequeue ) 
{ 
  struct recv_frame *hdr ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;

  {
#line 419
  spin_lock(& pframequeue->lock);
#line 421
  phead = get_list_head(pframequeue);
#line 422
  plist = phead->next;
#line 424
  plist = phead->next;
#line 424
  ptmp = plist->next;
#line 424
  goto ldv_51749;
  ldv_51748: 
#line 425
  __mptr = (struct list_head  const  *)plist;
#line 425
  hdr = (struct recv_frame *)__mptr;
#line 426
  rtw_free_recvframe23a(hdr);
#line 424
  plist = ptmp;
#line 424
  ptmp = plist->next;
  ldv_51749: ;
#line 424
  if ((unsigned long )plist != (unsigned long )phead) {
#line 426
    goto ldv_51748;
  } else {

  }
#line 429
  spin_unlock(& pframequeue->lock);
#line 430
  return;
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
u32 rtw_free_uc_swdec_pending_queue23a(struct rtw_adapter *adapter ) 
{ 
  u32 cnt ;
  struct recv_frame *pending_frame ;

  {
#line 434
  cnt = 0U;
#line 436
  goto ldv_51758;
  ldv_51757: 
#line 437
  rtw_free_recvframe23a(pending_frame);
#line 438
  if (GlobalDebugLevel23A > 3U) {
#line 438
    printk("\016RTL8723AU: %s: dequeue uc_swdec_pending_queue\n", "rtw_free_uc_swdec_pending_queue23a");
  } else {

  }
#line 439
  cnt = cnt + 1U;
  ldv_51758: 
#line 436
  pending_frame = rtw_alloc_recvframe23a(& adapter->recvpriv.uc_swdec_pending_queue);
#line 436
  if ((unsigned long )pending_frame != (unsigned long )((struct recv_frame *)0)) {
#line 438
    goto ldv_51757;
  } else {

  }

#line 442
  return (cnt);
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int rtw_enqueue_recvbuf23a_to_head(struct recv_buf *precvbuf , struct rtw_queue *queue ) 
{ 
  struct list_head *tmp ;

  {
#line 447
  spin_lock_bh(& queue->lock);
#line 449
  list_del_init(& precvbuf->list);
#line 450
  tmp = get_list_head(queue);
#line 450
  list_add(& precvbuf->list, tmp);
#line 452
  spin_unlock_bh(& queue->lock);
#line 454
  return (1);
}
}
#line 457 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int rtw_enqueue_recvbuf23a(struct recv_buf *precvbuf , struct rtw_queue *queue ) 
{ 
  unsigned long irqL ;
  struct list_head *tmp ;

  {
#line 460
  ldv_spin_lock();
#line 462
  list_del_init(& precvbuf->list);
#line 464
  tmp = get_list_head(queue);
#line 464
  list_add_tail(& precvbuf->list, tmp);
#line 465
  spin_unlock_irqrestore(& queue->lock, irqL);
#line 466
  return (1);
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct recv_buf *rtw_dequeue_recvbuf23a(struct rtw_queue *queue ) 
{ 
  unsigned long irqL ;
  struct recv_buf *precvbuf ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 475
  ldv_spin_lock();
#line 477
  tmp = list_empty((struct list_head  const  *)(& queue->queue));
#line 477
  if (tmp != 0) {
#line 478
    precvbuf = (struct recv_buf *)0;
  } else {
#line 480
    phead = get_list_head(queue);
#line 482
    plist = phead->next;
#line 484
    __mptr = (struct list_head  const  *)plist;
#line 484
    precvbuf = (struct recv_buf *)__mptr;
#line 486
    list_del_init(& precvbuf->list);
  }
#line 489
  spin_unlock_irqrestore(& queue->lock, irqL);
#line 491
  return (precvbuf);
}
}
#line 494
int recvframe_chkmic(struct rtw_adapter *adapter , struct recv_frame *precvframe ) ;
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int recvframe_chkmic(struct rtw_adapter *adapter , struct recv_frame *precvframe ) 
{ 
  int i ;
  int res ;
  u32 datalen ;
  u8 miccode[8U] ;
  u8 bmic_err ;
  u8 brpt_micerror ;
  u8 *pframe ;
  u8 *payload ;
  u8 *pframemic ;
  u8 *mickey ;
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;
  int i___0 ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 499
  res = 1;
#line 502
  bmic_err = 0U;
#line 502
  brpt_micerror = 1U;
#line 507
  prxattrib = & precvframe->attrib;
#line 508
  psecuritypriv = & adapter->securitypriv;
#line 510
  pmlmeext = & adapter->mlmeextpriv;
#line 511
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 514
  stainfo = rtw_get_stainfo23a(& adapter->stapriv, (u8 const   *)(& prxattrib->ta));
#line 516
  if (prxattrib->encrypt == 1027074U) {
#line 517
    if (GlobalDebugLevel23A > 6U) {
#line 517
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 517
      printk("\016\n recvframe_chkmic:prxattrib->encrypt == WLAN_CIPHER_SUITE_TKIP\n");
    } else {

    }
#line 519
    if (GlobalDebugLevel23A > 6U) {
#line 519
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 519
      printk("\016\n recvframe_chkmic:da = 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
             (int )prxattrib->ra[0], (int )prxattrib->ra[1], (int )prxattrib->ra[2],
             (int )prxattrib->ra[3], (int )prxattrib->ra[4], (int )prxattrib->ra[5]);
    } else {

    }
#line 526
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
#line 527
      tmp = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 527
      if ((int )tmp) {
#line 528
        mickey = (u8 *)(& psecuritypriv->dot118021XGrprxmickey[(int )prxattrib->key_index].skey);
#line 530
        if (GlobalDebugLevel23A > 6U) {
#line 530
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 530
          printk("\016\n recvframe_chkmic: bcmc key\n");
        } else {

        }
#line 533
        if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
#line 534
          res = 0;
#line 535
          if (GlobalDebugLevel23A > 3U) {
#line 535
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 535
            printk("\016\n recvframe_chkmic:didn\'t install group key!!!!!!\n");
          } else {

          }
#line 539
          if (GlobalDebugLevel23A > 3U) {
#line 539
            printk("\016RTL8723AU: \n recvframe_chkmic:didn\'t install group key!!!!!!\n");
          } else {

          }
#line 541
          goto exit;
        } else {

        }
      } else {
#line 544
        mickey = (u8 *)(& stainfo->dot11tkiprxmickey.skey);
#line 545
        if (GlobalDebugLevel23A > 3U) {
#line 545
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 545
          printk("\016\n recvframe_chkmic: unicast key\n");
        } else {

        }
      }
#line 551
      datalen = ((((precvframe->pkt)->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len) - (unsigned int )prxattrib->icv_len) - 8U;
#line 553
      pframe = (precvframe->pkt)->data;
#line 554
      payload = pframe + ((unsigned long )prxattrib->hdrlen + (unsigned long )prxattrib->iv_len);
#line 557
      if (GlobalDebugLevel23A > 6U) {
#line 557
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 557
        printk("\016\n prxattrib->iv_len =%d prxattrib->icv_len =%d\n", (int )prxattrib->iv_len,
               (int )prxattrib->icv_len);
      } else {

      }
#line 563
      rtw_seccalctkipmic23a(mickey, pframe, payload, datalen, (u8 *)(& miccode), (int )prxattrib->priority);
#line 567
      pframemic = payload + (unsigned long )datalen;
#line 569
      bmic_err = 0U;
#line 571
      i = 0;
#line 571
      goto ldv_51802;
      ldv_51801: ;
#line 572
      if ((int )miccode[i] != (int )*(pframemic + (unsigned long )i)) {
#line 573
        if (GlobalDebugLevel23A > 3U) {
#line 573
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 573
          printk("\016recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x) ",
                 i, (int )miccode[i], i, (int )*(pframemic + (unsigned long )i));
        } else {

        }
#line 579
        bmic_err = 1U;
      } else {

      }
#line 571
      i = i + 1;
      ldv_51802: ;
#line 571
      if (i <= 7) {
#line 573
        goto ldv_51801;
      } else {

      }

#line 583
      if ((unsigned int )bmic_err == 1U) {
#line 585
        if (GlobalDebugLevel23A > 3U) {
#line 585
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 585
          printk("\016\n *(pframemic-8)-*(pframemic-1) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                 (int )*(pframemic + 0xfffffffffffffff8UL), (int )*(pframemic + 0xfffffffffffffff9UL),
                 (int )*(pframemic + 0xfffffffffffffffaUL), (int )*(pframemic + 0xfffffffffffffffbUL),
                 (int )*(pframemic + 0xfffffffffffffffcUL), (int )*(pframemic + 0xfffffffffffffffdUL),
                 (int )*(pframemic + 0xfffffffffffffffeUL), (int )*(pframemic + 0xffffffffffffffffUL));
        } else {

        }
#line 593
        if (GlobalDebugLevel23A > 3U) {
#line 593
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 593
          printk("\016\n *(pframemic-16)-*(pframemic-9) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
                 (int )*(pframemic + 0xfffffffffffffff0UL), (int )*(pframemic + 0xfffffffffffffff1UL),
                 (int )*(pframemic + 0xfffffffffffffff2UL), (int )*(pframemic + 0xfffffffffffffff3UL),
                 (int )*(pframemic + 0xfffffffffffffff4UL), (int )*(pframemic + 0xfffffffffffffff5UL),
                 (int )*(pframemic + 0xfffffffffffffff6UL), (int )*(pframemic + 0xfffffffffffffff7UL));
        } else {

        }
#line 602
        if (GlobalDebugLevel23A > 3U) {
#line 602
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 602
          printk("\016\n ====== demp packet (len =%d) ======\n", (precvframe->pkt)->len);
        } else {

        }
#line 605
        i___0 = 0;
#line 605
        goto ldv_51806;
        ldv_51805: ;
#line 606
        if (GlobalDebugLevel23A > 3U) {
#line 606
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 606
          printk("px%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x", (int )*((precvframe->pkt)->data + (unsigned long )i___0),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 1UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 2UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 3UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 4UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 5UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 6UL)),
                 (int )*((precvframe->pkt)->data + ((unsigned long )i___0 + 7UL)));
        } else {

        }
#line 605
        i___0 = i___0 + 8;
        ldv_51806: ;
#line 605
        if ((unsigned int )i___0 < (precvframe->pkt)->len) {
#line 607
          goto ldv_51805;
        } else {

        }

#line 616
        if (GlobalDebugLevel23A > 3U) {
#line 616
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 616
          printk("\016\n ====== demp packet end [len =%d]======\n", (precvframe->pkt)->len);
        } else {

        }
#line 619
        if (GlobalDebugLevel23A > 3U) {
#line 619
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 619
          printk("\016\n hrdlen =%d,\n", (int )prxattrib->hdrlen);
        } else {

        }
#line 623
        if (GlobalDebugLevel23A > 3U) {
#line 623
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 623
          printk("\016ra = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x psecuritypriv->binstallGrpkey =%d ",
                 (int )prxattrib->ra[0], (int )prxattrib->ra[1], (int )prxattrib->ra[2],
                 (int )prxattrib->ra[3], (int )prxattrib->ra[4], (int )prxattrib->ra[5],
                 (int )psecuritypriv->binstallGrpkey);
        } else {

        }
#line 636
        tmp___0 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 636
        if ((int )tmp___0 && (u32 )prxattrib->key_index != pmlmeinfo->key_index) {
#line 639
          brpt_micerror = 0U;
        } else {

        }
#line 641
        if ((unsigned int )prxattrib->bdecrypted == 1U && (unsigned int )brpt_micerror == 1U) {
#line 643
          tmp___1 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 643
          rtw_handle_tkip_mic_err23a(adapter, (int )tmp___1);
#line 644
          if (GlobalDebugLevel23A > 3U) {
#line 644
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 644
            printk("\016 mic error :prxattrib->bdecrypted =%d ", (int )prxattrib->bdecrypted);
          } else {

          }
#line 645
          if (GlobalDebugLevel23A > 3U) {
#line 645
            printk("\016RTL8723AU:  mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
        } else {
#line 649
          if (GlobalDebugLevel23A > 3U) {
#line 649
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 649
            printk("\016 mic error :prxattrib->bdecrypted =%d ", (int )prxattrib->bdecrypted);
          } else {

          }
#line 654
          if (GlobalDebugLevel23A > 3U) {
#line 654
            printk("\016RTL8723AU:  mic error :prxattrib->bdecrypted =%d\n", (int )prxattrib->bdecrypted);
          } else {

          }
        }
#line 659
        res = 0;
      } else
#line 662
      if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
#line 662
        tmp___2 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 662
        if ((int )tmp___2) {
#line 664
          psecuritypriv->bcheck_grpkey = 1U;
#line 665
          if (GlobalDebugLevel23A > 3U) {
#line 665
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 665
            printk("\016psecuritypriv->bcheck_grpkey = true");
          } else {

          }
        } else {

        }
      } else {

      }
    } else
#line 672
    if (GlobalDebugLevel23A > 3U) {
#line 672
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 672
      printk("\016recvframe_chkmic: rtw_get_stainfo23a ==NULL!!!\n");
    } else {

    }
#line 677
    skb_trim(precvframe->pkt, (precvframe->pkt)->len - 8U);
  } else {

  }
  exit: ;
#line 684
  return (res);
}
}
#line 688
struct recv_frame *decryptor(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct recv_frame *decryptor(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct recv_frame *return_packet ;
  int res ;
  u8 *iv ;

  {
#line 693
  prxattrib = & precv_frame->attrib;
#line 694
  psecuritypriv = & padapter->securitypriv;
#line 695
  return_packet = precv_frame;
#line 696
  res = 1;
#line 698
  if (GlobalDebugLevel23A > 6U) {
#line 698
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 698
    printk("\016prxstat->decrypted =%x prxattrib->encrypt = 0x%03x\n", (int )prxattrib->bdecrypted,
           prxattrib->encrypt);
  } else {

  }
#line 702
  if (prxattrib->encrypt != 0U) {
#line 703
    iv = (precv_frame->pkt)->data + (unsigned long )prxattrib->hdrlen;
#line 704
    prxattrib->key_index = (u8 )((int )*(iv + 3UL) >> 6);
#line 706
    if ((unsigned int )prxattrib->key_index > 4U) {
#line 707
      if (GlobalDebugLevel23A > 3U) {
#line 707
        printk("\016RTL8723AU: prxattrib->key_index(%d) > WEP_KEYS\n", (int )prxattrib->key_index);
      } else {

      }
#line 710
      switch (prxattrib->encrypt) {
      case 1027073U: ;
      case 1027077U: 
#line 713
      prxattrib->key_index = (u8 )psecuritypriv->dot11PrivacyKeyIndex;
#line 715
      goto ldv_51822;
      case 1027074U: ;
      case 1027076U: ;
      default: 
#line 719
      prxattrib->key_index = (u8 )psecuritypriv->dot118021XGrpKeyid;
#line 721
      goto ldv_51822;
      }
      ldv_51822: ;
    } else {

    }
  } else {

  }
#line 726
  if (prxattrib->encrypt != 0U && (unsigned int )prxattrib->bdecrypted == 0U) {
#line 727
    psecuritypriv->hw_decrypted = 0U;
#line 728
    switch (prxattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
#line 731
    rtw_wep_decrypt23a(padapter, precv_frame);
#line 732
    goto ldv_51828;
    case 1027074U: 
#line 734
    res = rtw_tkip_decrypt23a(padapter, precv_frame);
#line 735
    goto ldv_51828;
    case 1027076U: 
#line 737
    res = rtw_aes_decrypt23a(padapter, precv_frame);
#line 738
    goto ldv_51828;
    default: ;
#line 740
    goto ldv_51828;
    }
    ldv_51828: ;
  } else
#line 742
  if (((unsigned int )prxattrib->bdecrypted == 1U && prxattrib->encrypt != 0U) && ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) != 0U || prxattrib->encrypt != 1027074U)) {
#line 745
    psecuritypriv->hw_decrypted = 1U;
  } else {

  }
#line 748
  if (res == 0) {
#line 749
    rtw_free_recvframe23a(return_packet);
#line 750
    return_packet = (struct recv_frame *)0;
  } else {

  }
#line 755
  return (return_packet);
}
}
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static struct recv_frame *portctrl(struct rtw_adapter *adapter , struct recv_frame *precv_frame ) 
{ 
  u8 *psta_addr ;
  u8 *ptr ;
  uint auth_alg ;
  struct recv_frame *pfhdr ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct recv_frame *prtnframe ;
  u16 ether_type ;
  u16 eapol_type ;
  struct rx_pkt_attrib *pattrib ;

  {
#line 769
  eapol_type = 34958U;
#line 772
  pstapriv = & adapter->stapriv;
#line 774
  auth_alg = adapter->securitypriv.dot11AuthAlgrthm;
#line 776
  pfhdr = precv_frame;
#line 777
  pattrib = & pfhdr->attrib;
#line 778
  psta_addr = (u8 *)(& pattrib->ta);
#line 779
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)psta_addr);
#line 781
  if (GlobalDebugLevel23A > 6U) {
#line 781
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 781
    printk("\016########portctrl:adapter->securitypriv.dot11AuthAlgrthm =%d\n", adapter->securitypriv.dot11AuthAlgrthm);
  } else {

  }
#line 785
  if (auth_alg == 2U) {
#line 787
    ptr = (pfhdr->pkt)->data + (unsigned long )pfhdr->attrib.hdrlen;
#line 789
    ether_type = (u16 )((int )((short )((int )*(ptr + 6UL) << 8)) | (int )((short )*(ptr + 7UL)));
#line 791
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0) && psta->ieee8021x_blocked != 0U) {
#line 794
      if (GlobalDebugLevel23A > 6U) {
#line 794
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 794
        printk("\016########portctrl:psta->ieee8021x_blocked ==1\n");
      } else {

      }
#line 798
      if ((int )ether_type == (int )eapol_type) {
#line 799
        prtnframe = precv_frame;
      } else {
#line 802
        rtw_free_recvframe23a(precv_frame);
#line 803
        prtnframe = (struct recv_frame *)0;
      }
    } else {
#line 808
      if (GlobalDebugLevel23A > 6U) {
#line 808
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 808
        printk("\016########portctrl:psta->ieee8021x_blocked ==0\n");
      } else {

      }
#line 811
      if (GlobalDebugLevel23A > 6U) {
#line 811
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 811
        printk("\016portctrl:precv_frame->hdr.attrib.privacy =%x\n", (int )precv_frame->attrib.privacy);
      } else {

      }
#line 815
      if ((unsigned int )pattrib->bdecrypted == 0U) {
#line 816
        if (GlobalDebugLevel23A > 6U) {
#line 816
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 816
          printk("\016portctrl:prxstat->decrypted =%x\n", (int )pattrib->bdecrypted);
        } else {

        }
      } else {

      }
#line 821
      prtnframe = precv_frame;
#line 823
      if ((int )ether_type == (int )eapol_type) {
#line 824
        if (GlobalDebugLevel23A > 5U) {
#line 824
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 824
          printk("\016########portctrl:ether_type == 0x888e\n");
        } else {

        }
#line 829
        prtnframe = precv_frame;
      } else
#line 831
      if (GlobalDebugLevel23A > 6U) {
#line 831
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 831
        printk("\016########portctrl:ether_type = 0x%04x\n", (int )ether_type);
      } else {

      }
    }
  } else {
#line 837
    prtnframe = precv_frame;
  }
#line 840
  return (prtnframe);
}
}
#line 843
int recv_decache(struct recv_frame *precv_frame , u8 bretry , struct stainfo_rxcache *prxcache ) ;
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int recv_decache(struct recv_frame *precv_frame , u8 bretry , struct stainfo_rxcache *prxcache ) 
{ 
  int tid ;
  u16 seq_ctrl ;

  {
#line 848
  tid = (int )precv_frame->attrib.priority;
#line 850
  seq_ctrl = (u16 )((int )((short )((int )precv_frame->attrib.seq_num << 4)) | ((int )((short )precv_frame->attrib.frag_num) & 15));
#line 855
  if (tid > 15) {
#line 856
    if (GlobalDebugLevel23A > 5U) {
#line 856
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 856
      printk("\016recv_decache, (tid>15)! seq_ctrl = 0x%x, tid = 0x%x\n", (int )seq_ctrl,
             tid);
    } else {

    }
#line 860
    return (0);
  } else {

  }
#line 864
  if ((int )prxcache->tid_rxseq[tid] == (int )seq_ctrl) {
#line 865
    if (GlobalDebugLevel23A > 5U) {
#line 865
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 865
      printk("\016recv_decache, seq_ctrl = 0x%x, tid = 0x%x, tid_rxseq = 0x%x\n",
             (int )seq_ctrl, tid, (int )prxcache->tid_rxseq[tid]);
    } else {

    }
#line 870
    return (0);
  } else {

  }
#line 874
  prxcache->tid_rxseq[tid] = seq_ctrl;
#line 878
  return (1);
}
}
#line 881
void process23a_pwrbit_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 883 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void process23a_pwrbit_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  unsigned char pwrbit ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  int tmp ;

  {
#line 888
  skb = precv_frame->pkt;
#line 889
  hdr = (struct ieee80211_hdr *)skb->data;
#line 890
  pattrib = & precv_frame->attrib;
#line 891
  pstapriv = & padapter->stapriv;
#line 892
  psta = (struct sta_info *)0;
#line 894
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->src));
#line 896
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 897
    tmp = ieee80211_has_pm((int )hdr->frame_control);
#line 897
    pwrbit = (unsigned char )tmp;
#line 899
    if ((unsigned int )pwrbit != 0U) {
#line 900
      if ((psta->state & 4U) == 0U) {
#line 901
        stop_sta_xmit23a(padapter, psta);
      } else {

      }
    } else
#line 903
    if ((psta->state & 4U) != 0U) {
#line 904
      wakeup_sta_to_xmit23a(padapter, psta);
    } else {

    }
  } else {

  }
#line 906
  return;
}
}
#line 911
void process_wmmps_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 913 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void process_wmmps_data(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  u8 wmmps_ac ;

  {
#line 917
  pattrib = & precv_frame->attrib;
#line 918
  pstapriv = & padapter->stapriv;
#line 919
  psta = (struct sta_info *)0;
#line 921
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->src));
#line 923
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 924
    return;
  } else {

  }
#line 927
  if (psta->qos_option == 0U) {
#line 928
    return;
  } else {

  }
#line 930
  if (((int )psta->qos_info & 15) == 0) {
#line 931
    return;
  } else {

  }
#line 933
  if ((psta->state & 4U) != 0U) {
#line 934
    wmmps_ac = 0U;
#line 936
    switch ((int )pattrib->priority) {
    case 1: ;
    case 2: 
#line 939
    wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
#line 940
    goto ldv_51883;
    case 4: ;
    case 5: 
#line 943
    wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
#line 944
    goto ldv_51883;
    case 6: ;
    case 7: 
#line 947
    wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
#line 948
    goto ldv_51883;
    case 0: ;
    case 3: ;
    default: 
#line 952
    wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
#line 953
    goto ldv_51883;
    }
    ldv_51883: ;
#line 956
    if ((unsigned int )wmmps_ac != 0U) {
#line 957
      if (psta->sleepq_ac_len != 0U) {
#line 959
        xmit_delivery_enabled_frames23a(padapter, psta);
      } else {
#line 962
        issue_qos_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), (int )pattrib->priority,
                              0, 0);
      }
    } else {

    }
  } else {

  }
#line 965
  return;
}
}
#line 972 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static void count_rx_stats(struct rtw_adapter *padapter , struct recv_frame *prframe ,
                           struct sta_info *sta ) 
{ 
  int sz ;
  struct sta_info *psta ;
  struct stainfo_stats *pstats ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_priv *precvpriv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 976
  psta = (struct sta_info *)0;
#line 977
  pstats = (struct stainfo_stats *)0;
#line 978
  pattrib = & prframe->attrib;
#line 979
  precvpriv = & padapter->recvpriv;
#line 981
  sz = (int )(prframe->pkt)->len;
#line 982
  precvpriv->rx_bytes = precvpriv->rx_bytes + (u64 )sz;
#line 984
  padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod = padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod + 1U;
#line 986
  tmp = is_broadcast_ether_addr((u8 const   *)(& pattrib->dst));
#line 986
  if (tmp) {
#line 986
    tmp___0 = 0;
  } else {
#line 986
    tmp___0 = 1;
  }
#line 986
  if (tmp___0) {
#line 986
    tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
#line 986
    if (tmp___1) {
#line 986
      tmp___2 = 0;
    } else {
#line 986
      tmp___2 = 1;
    }
#line 986
    if (tmp___2) {
#line 988
      padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod = padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod + 1U;
    } else {

    }
  } else {

  }
#line 990
  if ((unsigned long )sta != (unsigned long )((struct sta_info *)0)) {
#line 991
    psta = sta;
  } else {
#line 993
    psta = prframe->psta;
  }
#line 995
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 996
    pstats = & psta->sta_stats;
#line 998
    pstats->rx_data_pkts = pstats->rx_data_pkts + 1ULL;
#line 999
    pstats->rx_bytes = pstats->rx_bytes + (u64 )sz;
  } else {

  }
#line 1001
  return;
}
}
#line 1003 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static int sta2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                              struct sta_info **psta ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int ret ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  u8 *mybssid ;
  u8 *tmp ;
  u8 *myhwaddr ;
  u8 *tmp___0 ;
  u8 *sta_addr ;
  int bmcast ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  int tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  bool tmp___18 ;
  bool tmp___19 ;

  {
#line 1007
  skb = precv_frame->pkt;
#line 1008
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1009
  ret = 1;
#line 1010
  pattrib = & precv_frame->attrib;
#line 1011
  pstapriv = & adapter->stapriv;
#line 1012
  pmlmepriv = & adapter->mlmepriv;
#line 1013
  tmp = get_bssid(pmlmepriv);
#line 1013
  mybssid = tmp;
#line 1014
  tmp___0 = myid(& adapter->eeprompriv);
#line 1014
  myhwaddr = tmp___0;
#line 1015
  sta_addr = (u8 *)0U;
#line 1016
  tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
#line 1016
  bmcast = (int )tmp___1;
#line 1020
  tmp___18 = check_fwstate(pmlmepriv, 32);
#line 1020
  if ((int )tmp___18) {
#line 1020
    goto _L;
  } else {
#line 1020
    tmp___19 = check_fwstate(pmlmepriv, 64);
#line 1020
    if ((int )tmp___19) {
      _L: /* CIL Label */ 
#line 1024
      tmp___2 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->src));
#line 1024
      if ((int )tmp___2) {
#line 1025
        if (GlobalDebugLevel23A > 3U) {
#line 1025
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1025
          printk("\016 SA == myself\n");
        } else {

        }
#line 1027
        ret = 0;
#line 1028
        goto exit;
      } else {

      }
#line 1031
      tmp___3 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->dst));
#line 1031
      if (tmp___3) {
#line 1031
        tmp___4 = 0;
      } else {
#line 1031
        tmp___4 = 1;
      }
#line 1031
      if (tmp___4 && bmcast == 0) {
#line 1032
        ret = 0;
#line 1033
        goto exit;
      } else {

      }
#line 1036
      tmp___5 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)"");
#line 1036
      if ((int )tmp___5) {
#line 1039
        ret = 0;
#line 1040
        goto exit;
      } else {
#line 1036
        tmp___6 = ether_addr_equal((u8 const   *)mybssid, (u8 const   *)"");
#line 1036
        if ((int )tmp___6) {
#line 1039
          ret = 0;
#line 1040
          goto exit;
        } else {
#line 1036
          tmp___7 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)mybssid);
#line 1036
          if (tmp___7) {
#line 1036
            tmp___8 = 0;
          } else {
#line 1036
            tmp___8 = 1;
          }
#line 1036
          if (tmp___8) {
#line 1039
            ret = 0;
#line 1040
            goto exit;
          } else {

          }
        }
      }
#line 1043
      sta_addr = (u8 *)(& pattrib->src);
    } else {
#line 1044
      tmp___17 = check_fwstate(pmlmepriv, 8);
#line 1044
      if ((int )tmp___17) {
#line 1047
        tmp___9 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)(& pattrib->src));
#line 1047
        if (tmp___9) {
#line 1047
          tmp___10 = 0;
        } else {
#line 1047
          tmp___10 = 1;
        }
#line 1047
        if (tmp___10) {
#line 1048
          if (GlobalDebugLevel23A > 3U) {
#line 1048
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1048
            printk("\016bssid != TA under STATION_MODE; drop pkt\n");
          } else {

          }
#line 1051
          ret = 0;
#line 1052
          goto exit;
        } else {

        }
#line 1055
        sta_addr = (u8 *)(& pattrib->bssid);
      } else {
#line 1057
        tmp___16 = check_fwstate(pmlmepriv, 16);
#line 1057
        if ((int )tmp___16) {
#line 1058
          if (bmcast != 0) {
#line 1060
            tmp___11 = is_multicast_ether_addr((u8 const   *)(& pattrib->bssid));
#line 1060
            if (tmp___11) {
#line 1060
              tmp___12 = 0;
            } else {
#line 1060
              tmp___12 = 1;
            }
#line 1060
            if (tmp___12) {
#line 1061
              ret = 0;
#line 1062
              goto exit;
            } else {

            }
          } else {
#line 1067
            tmp___13 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)(& pattrib->dst));
#line 1067
            if (tmp___13) {
#line 1067
              tmp___14 = 0;
            } else {
#line 1067
              tmp___14 = 1;
            }
#line 1067
            if (tmp___14) {
#line 1068
              ret = 0;
#line 1069
              goto exit;
            } else {

            }
#line 1072
            sta_addr = (u8 *)(& pattrib->src);
          }
        } else {
#line 1074
          tmp___15 = check_fwstate(pmlmepriv, 65536);
#line 1074
          if ((int )tmp___15) {
#line 1075
            ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)(& hdr->addr1));
#line 1076
            ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)(& hdr->addr2));
#line 1077
            ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr3));
#line 1078
            ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 1079
            ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
#line 1081
            sta_addr = mybssid;
          } else {
#line 1083
            ret = 0;
          }
        }
      }
    }
  }
#line 1086
  if (bmcast != 0) {
#line 1087
    *psta = rtw_get_bcmc_stainfo23a(adapter);
  } else {
#line 1089
    *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)sta_addr);
  }
#line 1091
  if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 1092
    if (GlobalDebugLevel23A > 3U) {
#line 1092
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1092
      printk("\016can\'t get psta under sta2sta_data_frame ; drop pkt\n");
    } else {

    }
#line 1093
    ret = 0;
#line 1094
    goto exit;
  } else {

  }
  exit: ;
#line 1099
  return (ret);
}
}
#line 1102
int ap2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) ;
#line 1105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ap2sta_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  int ret ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  u8 *mybssid ;
  u8 *tmp ;
  u8 *myhwaddr ;
  u8 *tmp___0 ;
  int bmcast ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  bool tmp___16 ;

  {
#line 1109
  skb = precv_frame->pkt;
#line 1110
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1111
  pattrib = & precv_frame->attrib;
#line 1112
  ret = 1;
#line 1113
  pstapriv = & adapter->stapriv;
#line 1114
  pmlmepriv = & adapter->mlmepriv;
#line 1115
  tmp = get_bssid(pmlmepriv);
#line 1115
  mybssid = tmp;
#line 1116
  tmp___0 = myid(& adapter->eeprompriv);
#line 1116
  myhwaddr = tmp___0;
#line 1117
  tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
#line 1117
  bmcast = (int )tmp___1;
#line 1121
  tmp___14 = check_fwstate(pmlmepriv, 8);
#line 1121
  if ((int )tmp___14) {
#line 1121
    tmp___15 = check_fwstate(pmlmepriv, 1);
#line 1121
    if ((int )tmp___15) {
#line 1121
      goto _L___2;
    } else {
#line 1121
      tmp___16 = check_fwstate(pmlmepriv, 128);
#line 1121
      if ((int )tmp___16) {
        _L___2: /* CIL Label */ 
#line 1126
        tmp___2 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->src));
#line 1126
        if ((int )tmp___2) {
#line 1127
          if (GlobalDebugLevel23A > 3U) {
#line 1127
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1127
            printk("\016 SA == myself\n");
          } else {

          }
#line 1129
          ret = 0;
#line 1130
          goto exit;
        } else {

        }
#line 1134
        tmp___3 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->dst));
#line 1134
        if (tmp___3) {
#line 1134
          tmp___4 = 0;
        } else {
#line 1134
          tmp___4 = 1;
        }
#line 1134
        if (tmp___4 && bmcast == 0) {
#line 1135
          if (GlobalDebugLevel23A > 6U) {
#line 1135
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1135
            printk("\016 ap2sta_data_frame:  compare DA fail; DA =%02x:%02x:%02x:%02x:%02x:%02x\n",
                   (int )*((u8 *)(& pattrib->dst)), (int )*((u8 *)(& pattrib->dst) + 1UL),
                   (int )*((u8 *)(& pattrib->dst) + 2UL), (int )*((u8 *)(& pattrib->dst) + 3UL),
                   (int )*((u8 *)(& pattrib->dst) + 4UL), (int )*((u8 *)(& pattrib->dst) + 5UL));
          } else {

          }
#line 1138
          ret = 0;
#line 1139
          goto exit;
        } else {

        }
#line 1143
        tmp___5 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)"");
#line 1143
        if ((int )tmp___5) {
#line 1143
          goto _L;
        } else {
#line 1143
          tmp___6 = ether_addr_equal((u8 const   *)mybssid, (u8 const   *)"");
#line 1143
          if ((int )tmp___6) {
#line 1143
            goto _L;
          } else {
#line 1143
            tmp___7 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)mybssid);
#line 1143
            if (tmp___7) {
#line 1143
              tmp___8 = 0;
            } else {
#line 1143
              tmp___8 = 1;
            }
#line 1143
            if (tmp___8) {
              _L: /* CIL Label */ 
#line 1146
              if (GlobalDebugLevel23A > 6U) {
#line 1146
                printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1146
                printk("\016 ap2sta_data_frame:  compare BSSID fail ; BSSID =%02x:%02x:%02x:%02x:%02x:%02x\n",
                       (int )*((u8 *)(& pattrib->bssid)), (int )*((u8 *)(& pattrib->bssid) + 1UL),
                       (int )*((u8 *)(& pattrib->bssid) + 2UL), (int )*((u8 *)(& pattrib->bssid) + 3UL),
                       (int )*((u8 *)(& pattrib->bssid) + 4UL), (int )*((u8 *)(& pattrib->bssid) + 5UL));
              } else {

              }
#line 1149
              if (GlobalDebugLevel23A > 6U) {
#line 1149
                printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1149
                printk("\016mybssid =%02x:%02x:%02x:%02x:%02x:%02x\n", (int )*mybssid,
                       (int )*(mybssid + 1UL), (int )*(mybssid + 2UL), (int )*(mybssid + 3UL),
                       (int )*(mybssid + 4UL), (int )*(mybssid + 5UL));
              } else {

              }
#line 1152
              if (bmcast == 0) {
#line 1153
                if (GlobalDebugLevel23A > 3U) {
#line 1153
                  printk("\016RTL8723AU: issue_deauth23a to the nonassociated ap =%02x:%02x:%02x:%02x:%02x:%02x for the reason(7)\n",
                         (int )*((u8 *)(& pattrib->bssid)), (int )*((u8 *)(& pattrib->bssid) + 1UL),
                         (int )*((u8 *)(& pattrib->bssid) + 2UL), (int )*((u8 *)(& pattrib->bssid) + 3UL),
                         (int )*((u8 *)(& pattrib->bssid) + 4UL), (int )*((u8 *)(& pattrib->bssid) + 5UL));
                } else {

                }
#line 1156
                issue_deauth23a(adapter, (unsigned char *)(& pattrib->bssid), 7);
              } else {

              }
#line 1160
              ret = 0;
#line 1161
              goto exit;
            } else {

            }
          }
        }
#line 1164
        if (bmcast != 0) {
#line 1165
          *psta = rtw_get_bcmc_stainfo23a(adapter);
        } else {
#line 1168
          *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->bssid));
        }
#line 1170
        if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 1171
          if (GlobalDebugLevel23A > 3U) {
#line 1171
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1171
            printk("\016ap2sta: can\'t get psta under STATION_MODE ; drop pkt\n");
          } else {

          }
#line 1174
          ret = 0;
#line 1175
          goto exit;
        } else {

        }
#line 1178
        tmp___9 = ieee80211_is_nullfunc((int )hdr->frame_control);
#line 1178
        if (tmp___9 != 0) {
#line 1181
          count_rx_stats(adapter, precv_frame, *psta);
#line 1182
          ret = 2;
#line 1183
          goto exit;
        } else {

        }
      } else {
#line 1121
        goto _L___1;
      }
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1186
    tmp___12 = check_fwstate(pmlmepriv, 65536);
#line 1186
    if ((int )tmp___12) {
#line 1186
      tmp___13 = check_fwstate(pmlmepriv, 1);
#line 1186
      if ((int )tmp___13) {
#line 1188
        ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)(& hdr->addr1));
#line 1189
        ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)(& hdr->addr2));
#line 1190
        ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr3));
#line 1191
        ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 1192
        ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
#line 1195
        ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)mybssid);
#line 1198
        *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->bssid));
#line 1199
        if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 1200
          if (GlobalDebugLevel23A > 3U) {
#line 1200
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1200
            printk("\016can\'t get psta under MP_MODE ; drop pkt\n");
          } else {

          }
#line 1202
          ret = 0;
#line 1203
          goto exit;
        } else {

        }
      } else {
#line 1186
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1205
      tmp___11 = check_fwstate(pmlmepriv, 16);
#line 1205
      if ((int )tmp___11) {
#line 1207
        ret = 2;
#line 1208
        goto exit;
      } else {
#line 1210
        tmp___10 = ether_addr_equal((u8 const   *)myhwaddr, (u8 const   *)(& pattrib->dst));
#line 1210
        if ((int )tmp___10 && bmcast == 0) {
#line 1211
          *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->bssid));
#line 1212
          if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 1213
            if (GlobalDebugLevel23A > 3U) {
#line 1213
              printk("\016RTL8723AU: issue_deauth23a to the ap =%02x:%02x:%02x:%02x:%02x:%02x for the reason(7)\n",
                     (int )*((u8 *)(& pattrib->bssid)), (int )*((u8 *)(& pattrib->bssid) + 1UL),
                     (int )*((u8 *)(& pattrib->bssid) + 2UL), (int )*((u8 *)(& pattrib->bssid) + 3UL),
                     (int )*((u8 *)(& pattrib->bssid) + 4UL), (int )*((u8 *)(& pattrib->bssid) + 5UL));
            } else {

            }
#line 1217
            issue_deauth23a(adapter, (unsigned char *)(& pattrib->bssid), 7);
          } else {

          }
        } else {

        }
#line 1222
        ret = 0;
      }
    }
  }
  exit: ;
#line 1229
  return (ret);
}
}
#line 1232
int sta2ap_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) ;
#line 1235 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int sta2ap_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ,
                      struct sta_info **psta ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  unsigned char *mybssid ;
  u8 *tmp ;
  int ret ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u8 *myhwaddr ;
  u8 *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
#line 1239
  skb = precv_frame->pkt;
#line 1240
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1241
  pattrib = & precv_frame->attrib;
#line 1242
  pstapriv = & adapter->stapriv;
#line 1243
  pmlmepriv = & adapter->mlmepriv;
#line 1244
  tmp = get_bssid(pmlmepriv);
#line 1244
  mybssid = tmp;
#line 1245
  ret = 1;
#line 1249
  tmp___7 = check_fwstate(pmlmepriv, 16);
#line 1249
  if ((int )tmp___7) {
#line 1251
    tmp___0 = ether_addr_equal((u8 const   *)(& pattrib->bssid), (u8 const   *)mybssid);
#line 1251
    if (tmp___0) {
#line 1251
      tmp___1 = 0;
    } else {
#line 1251
      tmp___1 = 1;
    }
#line 1251
    if (tmp___1) {
#line 1252
      ret = 0;
#line 1253
      goto exit;
    } else {

    }
#line 1256
    *psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->src));
#line 1257
    if ((unsigned long )*psta == (unsigned long )((struct sta_info *)0)) {
#line 1258
      if (GlobalDebugLevel23A > 3U) {
#line 1258
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1258
        printk("\016can\'t get psta under AP_MODE; drop pkt\n");
      } else {

      }
#line 1260
      if (GlobalDebugLevel23A > 3U) {
#line 1260
        printk("\016RTL8723AU: issue_deauth23a to sta =%02x:%02x:%02x:%02x:%02x:%02x for the reason(7)\n",
               (int )*((u8 *)(& pattrib->src)), (int )*((u8 *)(& pattrib->src) + 1UL),
               (int )*((u8 *)(& pattrib->src) + 2UL), (int )*((u8 *)(& pattrib->src) + 3UL),
               (int )*((u8 *)(& pattrib->src) + 4UL), (int )*((u8 *)(& pattrib->src) + 5UL));
      } else {

      }
#line 1264
      issue_deauth23a(adapter, (unsigned char *)(& pattrib->src), 7);
#line 1267
      ret = 2;
#line 1268
      goto exit;
    } else {

    }
#line 1271
    process23a_pwrbit_data(adapter, precv_frame);
#line 1275
    tmp___2 = ieee80211_is_data_qos((int )hdr->frame_control);
#line 1275
    if (tmp___2 != 0) {
#line 1276
      process_wmmps_data(adapter, precv_frame);
    } else {

    }
#line 1278
    tmp___3 = ieee80211_is_nullfunc((int )hdr->frame_control);
#line 1278
    if (tmp___3 != 0) {
#line 1281
      count_rx_stats(adapter, precv_frame, *psta);
#line 1282
      ret = 2;
#line 1283
      goto exit;
    } else {

    }
  } else {
#line 1286
    tmp___4 = myid(& adapter->eeprompriv);
#line 1286
    myhwaddr = tmp___4;
#line 1287
    tmp___5 = ether_addr_equal((u8 const   *)(& pattrib->ra), (u8 const   *)myhwaddr);
#line 1287
    if (tmp___5) {
#line 1287
      tmp___6 = 0;
    } else {
#line 1287
      tmp___6 = 1;
    }
#line 1287
    if (tmp___6) {
#line 1288
      ret = 2;
#line 1289
      goto exit;
    } else {

    }
#line 1291
    if (GlobalDebugLevel23A > 3U) {
#line 1291
      printk("\016RTL8723AU: issue_deauth23a to sta =%02x:%02x:%02x:%02x:%02x:%02x for the reason(7)\n",
             (int )*((u8 *)(& pattrib->src)), (int )*((u8 *)(& pattrib->src) + 1UL),
             (int )*((u8 *)(& pattrib->src) + 2UL), (int )*((u8 *)(& pattrib->src) + 3UL),
             (int )*((u8 *)(& pattrib->src) + 4UL), (int )*((u8 *)(& pattrib->src) + 5UL));
    } else {

    }
#line 1293
    issue_deauth23a(adapter, (unsigned char *)(& pattrib->src), 7);
#line 1295
    ret = 2;
#line 1296
    goto exit;
  }
  exit: ;
#line 1303
  return (ret);
}
}
#line 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static int validate_recv_ctrl_frame(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  u8 *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct ieee80211_pspoll *psp ;
  u16 aid ;
  u8 wmmps_ac ;
  struct sta_info *psta ;
  struct list_head *xmitframe_plist ;
  struct list_head *xmitframe_phead ;
  struct xmit_frame *pxmitframe ;
  struct xmit_priv *pxmitpriv ;
  struct list_head  const  *__mptr ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  int tmp___6 ;
  u32 tmp___7 ;
  int tmp___8 ;

  {
#line 1310
  pattrib = & precv_frame->attrib;
#line 1311
  pstapriv = & padapter->stapriv;
#line 1312
  skb = precv_frame->pkt;
#line 1313
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1315
  tmp = ieee80211_is_ctl((int )hdr->frame_control);
#line 1315
  if (tmp == 0) {
#line 1316
    return (0);
  } else {

  }
#line 1319
  tmp___0 = myid(& padapter->eeprompriv);
#line 1319
  tmp___1 = ether_addr_equal((u8 const   *)(& hdr->addr1), (u8 const   *)tmp___0);
#line 1319
  if (tmp___1) {
#line 1319
    tmp___2 = 0;
  } else {
#line 1319
    tmp___2 = 1;
  }
#line 1319
  if (tmp___2) {
#line 1320
    return (0);
  } else {

  }
#line 1323
  tmp___8 = ieee80211_is_pspoll((int )hdr->frame_control);
#line 1323
  if (tmp___8 != 0) {
#line 1324
    psp = (struct ieee80211_pspoll *)hdr;
#line 1326
    wmmps_ac = 0U;
#line 1327
    psta = (struct sta_info *)0;
#line 1329
    aid = (unsigned int )psp->aid & 16383U;
#line 1330
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& hdr->addr2));
#line 1332
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0) || psta->aid != (uint )aid) {
#line 1333
      return (0);
    } else {

    }
#line 1336
    psta->sta_stats.rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts + 1ULL;
#line 1338
    switch ((int )pattrib->priority) {
    case 1: ;
    case 2: 
#line 1341
    wmmps_ac = (unsigned int )psta->uapsd_bk & 1U;
#line 1342
    goto ldv_51968;
    case 4: ;
    case 5: 
#line 1345
    wmmps_ac = (unsigned int )psta->uapsd_vi & 1U;
#line 1346
    goto ldv_51968;
    case 6: ;
    case 7: 
#line 1349
    wmmps_ac = (unsigned int )psta->uapsd_vo & 1U;
#line 1350
    goto ldv_51968;
    case 0: ;
    case 3: ;
    default: 
#line 1354
    wmmps_ac = (unsigned int )psta->uapsd_be & 1U;
#line 1355
    goto ldv_51968;
    }
    ldv_51968: ;
#line 1358
    if ((unsigned int )wmmps_ac != 0U) {
#line 1359
      return (0);
    } else {

    }
#line 1361
    if ((psta->state & 1024U) != 0U) {
#line 1362
      if (GlobalDebugLevel23A > 3U) {
#line 1362
        printk("\016RTL8723AU: %s alive check-rx ps-poll\n", "validate_recv_ctrl_frame");
      } else {

      }
#line 1363
      psta->expire_to = pstapriv->expire_to;
#line 1364
      psta->state = psta->state ^ 1024U;
    } else {

    }
#line 1367
    if ((psta->state & 4U) != 0U) {
#line 1367
      tmp___7 = CHKBIT(psta->aid);
#line 1367
      if (((u32 )pstapriv->sta_dz_bitmap & tmp___7) != 0U) {
#line 1371
        pxmitpriv = & padapter->xmitpriv;
#line 1373
        spin_lock_bh(& pxmitpriv->lock);
#line 1375
        xmitframe_phead = get_list_head(& psta->sleep_q);
#line 1376
        xmitframe_plist = xmitframe_phead->next;
#line 1378
        tmp___6 = list_empty((struct list_head  const  *)xmitframe_phead);
#line 1378
        if (tmp___6 == 0) {
#line 1379
          __mptr = (struct list_head  const  *)xmitframe_plist;
#line 1379
          pxmitframe = (struct xmit_frame *)__mptr;
#line 1383
          xmitframe_plist = xmitframe_plist->next;
#line 1385
          list_del_init(& pxmitframe->list);
#line 1387
          psta->sleepq_len = psta->sleepq_len - 1U;
#line 1389
          if (psta->sleepq_len != 0U) {
#line 1390
            pxmitframe->attrib.mdata = 1U;
          } else {
#line 1392
            pxmitframe->attrib.mdata = 0U;
          }
#line 1394
          pxmitframe->attrib.triggered = 1U;
#line 1398
          rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 1401
          if (psta->sleepq_len == 0U) {
#line 1402
            tmp___3 = CHKBIT(psta->aid);
#line 1402
            pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___3));
#line 1408
            update_beacon23a(padapter, 5, (u8 *)0U, 0);
          } else {

          }
#line 1413
          spin_unlock_bh(& pxmitpriv->lock);
        } else {
#line 1417
          spin_unlock_bh(& pxmitpriv->lock);
#line 1420
          tmp___5 = CHKBIT(psta->aid);
#line 1420
          if (((u32 )pstapriv->tim_bitmap & tmp___5) != 0U) {
#line 1421
            if (psta->sleepq_len == 0U) {
#line 1422
              if (GlobalDebugLevel23A > 3U) {
#line 1422
                printk("\016RTL8723AU: no buffered packets to xmit\n");
              } else {

              }
#line 1426
              issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 0,
                                0);
            } else {
#line 1430
              if (GlobalDebugLevel23A > 3U) {
#line 1430
                printk("\016RTL8723AU: error!psta->sleepq_len =%d\n", psta->sleepq_len);
              } else {

              }
#line 1433
              psta->sleepq_len = 0U;
            }
#line 1436
            tmp___4 = CHKBIT(psta->aid);
#line 1436
            pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___4));
#line 1440
            update_beacon23a(padapter, 5, (u8 *)0U, 0);
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 1448
  return (0);
}
}
#line 1451
struct recv_frame *recvframe_chk_defrag23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) ;
#line 1453 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static int validate_recv_mgnt_frame(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct sta_info *psta ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1461
  if (GlobalDebugLevel23A > 6U) {
#line 1461
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1461
    printk("\016+validate_recv_mgnt_frame\n");
  } else {

  }
#line 1464
  precv_frame = recvframe_chk_defrag23a(padapter, precv_frame);
#line 1465
  if ((unsigned long )precv_frame == (unsigned long )((struct recv_frame *)0)) {
#line 1466
    if (GlobalDebugLevel23A > 5U) {
#line 1466
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 1466
      printk("\016%s: fragment packet\n", "validate_recv_mgnt_frame");
    } else {

    }
#line 1468
    return (1);
  } else {

  }
#line 1471
  skb = precv_frame->pkt;
#line 1472
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1475
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& hdr->addr2));
#line 1476
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1477
    psta->sta_stats.rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts + 1ULL;
#line 1479
    tmp___4 = ieee80211_is_beacon((int )hdr->frame_control);
#line 1479
    if (tmp___4 != 0) {
#line 1480
      psta->sta_stats.rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts + 1ULL;
    } else {
#line 1481
      tmp___3 = ieee80211_is_probe_req((int )hdr->frame_control);
#line 1481
      if (tmp___3 != 0) {
#line 1482
        psta->sta_stats.rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts + 1ULL;
      } else {
#line 1483
        tmp___2 = ieee80211_is_probe_resp((int )hdr->frame_control);
#line 1483
        if (tmp___2 != 0) {
#line 1484
          tmp___1 = ether_addr_equal((u8 const   *)(& padapter->eeprompriv.mac_addr),
                                     (u8 const   *)(& hdr->addr1));
#line 1484
          if ((int )tmp___1) {
#line 1486
            psta->sta_stats.rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts + 1ULL;
          } else {
#line 1487
            tmp = is_broadcast_ether_addr((u8 const   *)(& hdr->addr1));
#line 1487
            if ((int )tmp) {
#line 1489
              psta->sta_stats.rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts + 1ULL;
            } else {
#line 1487
              tmp___0 = is_multicast_ether_addr((u8 const   *)(& hdr->addr1));
#line 1487
              if ((int )tmp___0) {
#line 1489
                psta->sta_stats.rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts + 1ULL;
              } else {
#line 1491
                psta->sta_stats.rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts + 1ULL;
              }
            }
          }
        } else {

        }
      }
    }
  } else {

  }
#line 1495
  mgt_dispatcher23a(padapter, precv_frame);
#line 1497
  return (1);
}
}
#line 1500 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static int validate_recv_data_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ) 
{ 
  u8 bretry ;
  u8 *psa ;
  u8 *pda ;
  struct sta_info *psta ;
  struct rx_pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  int ret ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  int tmp___0 ;
  __le16 *qptr ;
  u8 *tmp___1 ;
  u16 qos_ctrl ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
#line 1505
  psta = (struct sta_info *)0;
#line 1506
  pattrib = & precv_frame->attrib;
#line 1507
  psecuritypriv = & adapter->securitypriv;
#line 1508
  ret = 1;
#line 1509
  skb = precv_frame->pkt;
#line 1510
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1514
  tmp = ieee80211_has_retry((int )hdr->frame_control);
#line 1514
  bretry = (u8 )tmp;
#line 1515
  pda = ieee80211_get_DA(hdr);
#line 1516
  psa = ieee80211_get_SA(hdr);
#line 1518
  ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)pda);
#line 1519
  ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)psa);
#line 1521
  switch ((int )hdr->frame_control & 768) {
  case 0: 
#line 1524
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr3));
#line 1525
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)pda);
#line 1526
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)psa);
#line 1527
  ret = sta2sta_data_frame(adapter, precv_frame, & psta);
#line 1528
  goto ldv_52008;
  case 512: 
#line 1531
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr2));
#line 1532
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)pda);
#line 1533
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& hdr->addr2));
#line 1534
  ret = ap2sta_data_frame(adapter, precv_frame, & psta);
#line 1535
  goto ldv_52008;
  case 256: 
#line 1538
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr1));
#line 1539
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& hdr->addr1));
#line 1540
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)psa);
#line 1541
  ret = sta2ap_data_frame(adapter, precv_frame, & psta);
#line 1542
  goto ldv_52008;
  case 768: 
#line 1549
  ether_addr_copy((u8 *)(& pattrib->bssid), (u8 const   *)(& hdr->addr1));
#line 1550
  ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& hdr->addr1));
#line 1551
  ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& hdr->addr2));
#line 1552
  ret = 0;
#line 1553
  if (GlobalDebugLevel23A > 3U) {
#line 1553
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1553
    printk("\016 case 3\n");
  } else {

  }
#line 1554
  goto ldv_52008;
  }
  ldv_52008: ;
#line 1557
  if (ret == 0 || ret == 2) {
#line 1558
    goto exit;
  } else {

  }
#line 1560
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1561
    if (GlobalDebugLevel23A > 3U) {
#line 1561
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1561
      printk("\016 after to_fr_ds_chk; psta == NULL\n");
    } else {

    }
#line 1563
    ret = 0;
#line 1564
    goto exit;
  } else {

  }
#line 1569
  precv_frame->psta = psta;
#line 1571
  pattrib->hdrlen = 24U;
#line 1572
  tmp___0 = ieee80211_has_a4((int )hdr->frame_control);
#line 1572
  if (tmp___0 != 0) {
#line 1573
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 6U;
  } else {

  }
#line 1576
  if ((unsigned int )pattrib->qos == 1U) {
#line 1577
    tmp___1 = ieee80211_get_qos_ctl(hdr);
#line 1577
    qptr = (__le16 *)tmp___1;
#line 1578
    qos_ctrl = *qptr;
#line 1580
    pattrib->priority = (unsigned int )((u8 )qos_ctrl) & 15U;
#line 1581
    pattrib->ack_policy = (unsigned int )((u8 )((int )qos_ctrl >> 5)) & 3U;
#line 1582
    pattrib->amsdu = (u8 )(((int )qos_ctrl & 128) >> 7);
#line 1584
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 2U;
#line 1586
    if ((unsigned int )pattrib->priority != 0U && (unsigned int )pattrib->priority != 3U) {
#line 1587
      adapter->recvpriv.bIsAnyNonBEPkts = 1U;
    } else {

    }
  } else {
#line 1590
    pattrib->priority = 0U;
#line 1591
    pattrib->ack_policy = 0U;
#line 1592
    pattrib->amsdu = 0U;
  }
#line 1595
  if ((unsigned int )pattrib->order != 0U) {
#line 1596
    pattrib->hdrlen = (unsigned int )pattrib->hdrlen + 4U;
  } else {

  }
#line 1599
  precv_frame->preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )pattrib->priority;
#line 1602
  tmp___2 = recv_decache(precv_frame, (int )bretry, & psta->sta_recvpriv.rxcache);
#line 1602
  if (tmp___2 == 0) {
#line 1604
    if (GlobalDebugLevel23A > 3U) {
#line 1604
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1604
      printk("\016decache : drop pkt\n");
    } else {

    }
#line 1606
    ret = 0;
#line 1607
    goto exit;
  } else {

  }
#line 1610
  if ((unsigned int )pattrib->privacy != 0U) {
#line 1611
    if (GlobalDebugLevel23A > 6U) {
#line 1611
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1611
      printk("\016validate_recv_data_frame:pattrib->privacy =%x\n", (int )pattrib->privacy);
    } else {

    }
#line 1614
    if (GlobalDebugLevel23A > 6U) {
#line 1614
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1614
      tmp___3 = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1614
      printk("\016\n ^^^^^^^^^^^is_multicast_ether_addr(pattrib->ra(0x%02x)) =%d^^^^^^^^^^^^^^^6\n",
             (int )pattrib->ra[0], (int )tmp___3);
    } else {

    }
#line 1620
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
#line 1620
    pattrib->encrypt = psecuritypriv->dot11PrivacyAlgrthm;
#line 1620
    goto ldv_52018;
    case 2U: 
#line 1620
    tmp___4 = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1620
    if ((int )tmp___4) {
#line 1620
      pattrib->encrypt = psecuritypriv->dot118021XGrpPrivacy;
    } else {
#line 1620
      pattrib->encrypt = psta->dot118021XPrivacy;
    }
#line 1620
    goto ldv_52018;
    }
    ldv_52018: ;
#line 1623
    if (GlobalDebugLevel23A > 6U) {
#line 1623
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1623
      printk("\016\n pattrib->encrypt =%d\n", pattrib->encrypt);
    } else {

    }
#line 1626
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
#line 1630
    pattrib->iv_len = 4U;
#line 1631
    pattrib->icv_len = 4U;
#line 1632
    goto ldv_52022;
    case 1027074U: 
#line 1634
    pattrib->iv_len = 8U;
#line 1635
    pattrib->icv_len = 4U;
#line 1636
    goto ldv_52022;
    case 1027076U: 
#line 1638
    pattrib->iv_len = 8U;
#line 1639
    pattrib->icv_len = 8U;
#line 1640
    goto ldv_52022;
    default: 
#line 1642
    pattrib->iv_len = 0U;
#line 1643
    pattrib->icv_len = 0U;
#line 1644
    goto ldv_52022;
    }
    ldv_52022: ;
  } else {
#line 1647
    pattrib->encrypt = 0U;
#line 1648
    pattrib->iv_len = 0U;
#line 1649
    pattrib->icv_len = 0U;
  }
  exit: ;
#line 1656
  return (ret);
}
}
#line 1659 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static void dump_rx_pkt(struct sk_buff *skb , u16 type , int level ) 
{ 
  int i ;
  u8 *ptr ;

  {
#line 1664
  if ((level == 1 || (level == 2 && (unsigned int )type == 0U)) || (level == 3 && (unsigned int )type == 8U)) {
#line 1668
    ptr = skb->data;
#line 1670
    if (GlobalDebugLevel23A > 3U) {
#line 1670
      printk("\016RTL8723AU: #############################\n");
    } else {

    }
#line 1672
    i = 0;
#line 1672
    goto ldv_52034;
    ldv_52033: ;
#line 1673
    if (GlobalDebugLevel23A > 3U) {
#line 1673
      printk("\016RTL8723AU: %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", (int )*(ptr + (unsigned long )i),
             (int )*(ptr + ((unsigned long )i + 1UL)), (int )*(ptr + ((unsigned long )i + 2UL)),
             (int )*(ptr + ((unsigned long )i + 3UL)), (int )*(ptr + ((unsigned long )i + 4UL)),
             (int )*(ptr + ((unsigned long )i + 5UL)), (int )*(ptr + ((unsigned long )i + 6UL)),
             (int )*(ptr + ((unsigned long )i + 7UL)));
    } else {

    }
#line 1672
    i = i + 8;
    ldv_52034: ;
#line 1672
    if (i <= 63) {
#line 1674
      goto ldv_52033;
    } else {

    }

#line 1678
    if (GlobalDebugLevel23A > 3U) {
#line 1678
      printk("\016RTL8723AU: #############################\n");
    } else {

    }
  } else {

  }
#line 1680
  return;
}
}
#line 1682 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static int validate_recv_frame(struct rtw_adapter *adapter , struct recv_frame *precv_frame ) 
{ 
  u8 type ;
  u8 subtype ;
  int retval ;
  struct rx_pkt_attrib *pattrib ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  u8 ver ;
  u8 bDumpRxPkt ;
  u16 seq_ctrl ;
  u16 fctl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  struct recv_priv *precvpriv ;

  {
#line 1690
  retval = 1;
#line 1691
  pattrib = & precv_frame->attrib;
#line 1692
  skb = precv_frame->pkt;
#line 1693
  hdr = (struct ieee80211_hdr *)skb->data;
#line 1698
  fctl = hdr->frame_control;
#line 1699
  ver = (unsigned int )((u8 )fctl) & 3U;
#line 1700
  type = (unsigned int )((u8 )fctl) & 12U;
#line 1701
  subtype = (unsigned int )((u8 )fctl) & 240U;
#line 1704
  if ((unsigned int )ver != 0U) {
#line 1705
    if (GlobalDebugLevel23A > 3U) {
#line 1705
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1705
      printk("\016validate_recv_data_frame fail! (ver!= 0)\n");
    } else {

    }
#line 1707
    retval = 0;
#line 1708
    goto exit;
  } else {

  }
#line 1711
  seq_ctrl = hdr->seq_ctrl;
#line 1712
  pattrib->frag_num = (unsigned int )((u8 )seq_ctrl) & 15U;
#line 1713
  pattrib->seq_num = (u16 )((int )seq_ctrl >> 4);
#line 1715
  tmp = ieee80211_has_pm((int )hdr->frame_control);
#line 1715
  pattrib->pw_save = (u8 )tmp;
#line 1716
  tmp___0 = ieee80211_has_morefrags((int )hdr->frame_control);
#line 1716
  pattrib->mfrag = (u8 )tmp___0;
#line 1717
  tmp___1 = ieee80211_has_moredata((int )hdr->frame_control);
#line 1717
  pattrib->mdata = (u8 )tmp___1;
#line 1718
  tmp___2 = ieee80211_has_protected((int )hdr->frame_control);
#line 1718
  pattrib->privacy = (u8 )tmp___2;
#line 1719
  tmp___3 = ieee80211_has_order((int )hdr->frame_control);
#line 1719
  pattrib->order = (u8 )tmp___3;
#line 1721
  GetHalDefVar8192CUsb(adapter, 6, (void *)(& bDumpRxPkt));
#line 1723
  tmp___4 = ldv__builtin_expect((unsigned int )bDumpRxPkt == 1U, 0L);
#line 1723
  if (tmp___4 != 0L) {
#line 1724
    dump_rx_pkt(skb, (int )type, (int )bDumpRxPkt);
  } else {

  }
#line 1726
  switch ((int )type) {
  case 0: 
#line 1729
  retval = validate_recv_mgnt_frame(adapter, precv_frame);
#line 1730
  if (retval == 0) {
#line 1731
    if (GlobalDebugLevel23A > 3U) {
#line 1731
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1731
      printk("\016validate_recv_mgnt_frame fail\n");
    } else {

    }
  } else {

  }
#line 1734
  retval = 0;
#line 1735
  goto ldv_52052;
  case 4: 
#line 1737
  retval = validate_recv_ctrl_frame(adapter, precv_frame);
#line 1738
  if (retval == 0) {
#line 1739
    if (GlobalDebugLevel23A > 3U) {
#line 1739
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1739
      printk("\016validate_recv_ctrl_frame fail\n");
    } else {

    }
  } else {

  }
#line 1742
  retval = 0;
#line 1743
  goto ldv_52052;
  case 8: 
#line 1746
  pattrib->qos = (int )((signed char )subtype) < 0;
#line 1747
  retval = validate_recv_data_frame(adapter, precv_frame);
#line 1748
  if (retval == 0) {
#line 1749
    precvpriv = & adapter->recvpriv;
#line 1751
    precvpriv->rx_drop = precvpriv->rx_drop + 1ULL;
  } else {

  }
#line 1753
  goto ldv_52052;
  default: ;
#line 1755
  if (GlobalDebugLevel23A > 3U) {
#line 1755
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1755
    printk("\016validate_recv_data_frame fail! type = 0x%x\n", (int )type);
  } else {

  }
#line 1757
  retval = 0;
#line 1758
  goto ldv_52052;
  }
  ldv_52052: ;
  exit: ;
#line 1762
  return (retval);
}
}
#line 1767 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static int wlanhdr_to_ethhdr(struct recv_frame *precvframe ) 
{ 
  u16 eth_type ;
  u16 len ;
  u16 hdrlen ;
  u8 bsnaphdr ;
  u8 *psnap ;
  int ret ;
  struct rtw_adapter *adapter ;
  struct mlme_priv *pmlmepriv ;
  struct sk_buff *skb ;
  u8 *ptr ;
  struct rx_pkt_attrib *pattrib ;
  bool tmp ;
  bool tmp___0 ;
  unsigned char *tmp___1 ;
  size_t __len ;
  void *__ret ;
  unsigned char *tmp___2 ;
  bool tmp___3 ;
  __u16 tmp___4 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1773
  ret = 1;
#line 1774
  adapter = precvframe->adapter;
#line 1775
  pmlmepriv = & adapter->mlmepriv;
#line 1777
  skb = precvframe->pkt;
#line 1779
  pattrib = & precvframe->attrib;
#line 1783
  ptr = skb->data;
#line 1784
  hdrlen = (u16 )pattrib->hdrlen;
#line 1785
  psnap = ptr + (unsigned long )hdrlen;
#line 1786
  eth_type = (u16 )((int )((short )((int )*(psnap + 6UL) << 8)) | (int )((short )*(psnap + 7UL)));
#line 1789
  tmp = ether_addr_equal((u8 const   *)psnap, (u8 const   *)(& rfc1042_header));
#line 1789
  if (((int )tmp && (unsigned int )eth_type != 33011U) && (unsigned int )eth_type != 33079U) {
#line 1794
    bsnaphdr = 1U;
#line 1795
    hdrlen = (unsigned int )hdrlen + 6U;
  } else {
#line 1789
    tmp___0 = ether_addr_equal((u8 const   *)psnap, (u8 const   *)(& bridge_tunnel_header));
#line 1789
    if ((int )tmp___0) {
#line 1794
      bsnaphdr = 1U;
#line 1795
      hdrlen = (unsigned int )hdrlen + 6U;
    } else {
#line 1798
      bsnaphdr = 0U;
#line 1799
      eth_type = (u16 )((int )((short )((int )*psnap << 8)) | (int )((short )*(psnap + 1UL)));
    }
  }
#line 1802
  len = (int )((u16 )skb->len) - (int )hdrlen;
#line 1804
  if (GlobalDebugLevel23A > 6U) {
#line 1804
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1804
    printk("\016\n === pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n", (int )pattrib->hdrlen,
           (int )pattrib->iv_len);
  } else {

  }
#line 1808
  pattrib->eth_type = eth_type;
#line 1809
  tmp___3 = check_fwstate(pmlmepriv, 65536);
#line 1809
  if ((int )tmp___3) {
#line 1810
    ptr = ptr + (unsigned long )hdrlen;
#line 1811
    *ptr = 135U;
#line 1812
    *(ptr + 1UL) = 18U;
#line 1814
    eth_type = 34578U;
#line 1817
    tmp___1 = skb_pull(skb, (unsigned int )hdrlen - 36U);
#line 1817
    ptr = tmp___1;
#line 1818
    __len = 24UL;
#line 1818
    if (__len > 63UL) {
#line 1818
      __ret = __memcpy((void *)ptr, (void const   *)skb->head, __len);
    } else {
#line 1818
      __ret = __builtin_memcpy((void *)ptr, (void const   *)skb->head, __len);
    }
#line 1819
    ptr = ptr + 24UL;
  } else {
#line 1821
    tmp___2 = skb_pull(skb, ((unsigned int )hdrlen + ((unsigned int )bsnaphdr != 0U ? 2U : 0U)) - 14U);
#line 1821
    ptr = tmp___2;
  }
#line 1825
  ether_addr_copy(ptr, (u8 const   *)(& pattrib->dst));
#line 1826
  ether_addr_copy(ptr + 6UL, (u8 const   *)(& pattrib->src));
#line 1828
  if ((unsigned int )bsnaphdr == 0U) {
#line 1829
    tmp___4 = __fswab16((int )len);
#line 1829
    len = tmp___4;
#line 1830
    __len___0 = 2UL;
#line 1830
    if (__len___0 > 63UL) {
#line 1830
      __ret___0 = __memcpy((void *)ptr + 12U, (void const   *)(& len), __len___0);
    } else {
#line 1830
      __ret___0 = __builtin_memcpy((void *)ptr + 12U, (void const   *)(& len), __len___0);
    }
  } else {

  }
#line 1834
  return (ret);
}
}
#line 1838
struct recv_frame *recvframe_defrag(struct rtw_adapter *adapter , struct rtw_queue *defrag_q ) ;
#line 1840 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct recv_frame *recvframe_defrag(struct rtw_adapter *adapter , struct rtw_queue *defrag_q ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  u8 *data ;
  u8 wlanhdr_offset ;
  u8 curfragnum ;
  struct recv_frame *pnfhdr ;
  struct recv_frame *prframe ;
  struct recv_frame *pnextrframe ;
  struct rtw_queue *pfree_recv_queue ;
  struct sk_buff *skb ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  size_t __len ;
  void *__ret ;
  unsigned char *tmp___0 ;

  {
#line 1853
  curfragnum = 0U;
#line 1854
  pfree_recv_queue = & adapter->recvpriv.free_recv_queue;
#line 1856
  phead = get_list_head(defrag_q);
#line 1857
  plist = phead->next;
#line 1858
  __mptr = (struct list_head  const  *)plist;
#line 1858
  prframe = (struct recv_frame *)__mptr;
#line 1859
  list_del_init(& prframe->list);
#line 1860
  skb = prframe->pkt;
#line 1862
  if ((int )prframe->attrib.frag_num != (int )curfragnum) {
#line 1865
    rtw_free_recvframe23a(prframe);
#line 1866
    rtw_free_recvframe23a_queue(defrag_q);
#line 1868
    return ((struct recv_frame *)0);
  } else {

  }
#line 1871
  curfragnum = (u8 )((int )curfragnum + 1);
#line 1873
  phead = get_list_head(defrag_q);
#line 1875
  data = (prframe->pkt)->data;
#line 1877
  plist = phead->next;
#line 1877
  ptmp = plist->next;
#line 1877
  goto ldv_52103;
  ldv_52102: 
#line 1878
  __mptr___0 = (struct list_head  const  *)plist;
#line 1878
  pnfhdr = (struct recv_frame *)__mptr___0;
#line 1879
  pnextrframe = pnfhdr;
#line 1882
  if ((int )pnfhdr->attrib.frag_num != (int )curfragnum) {
#line 1886
    rtw_free_recvframe23a(prframe);
#line 1887
    rtw_free_recvframe23a_queue(defrag_q);
#line 1888
    return ((struct recv_frame *)0);
  } else {

  }
#line 1891
  curfragnum = (u8 )((int )curfragnum + 1);
#line 1897
  wlanhdr_offset = (int )pnfhdr->attrib.hdrlen + (int )pnfhdr->attrib.iv_len;
#line 1899
  skb_pull(pnfhdr->pkt, (unsigned int )wlanhdr_offset);
#line 1904
  skb_trim(skb, skb->len - (unsigned int )prframe->attrib.icv_len);
#line 1906
  __len = (size_t )(pnfhdr->pkt)->len;
#line 1906
  tmp___0 = skb_tail_pointer((struct sk_buff  const  *)skb);
#line 1906
  __ret = __builtin_memcpy((void *)tmp___0, (void const   *)(pnfhdr->pkt)->data, __len);
#line 1909
  skb_put(skb, (pnfhdr->pkt)->len);
#line 1911
  prframe->attrib.icv_len = pnfhdr->attrib.icv_len;
#line 1877
  plist = ptmp;
#line 1877
  ptmp = plist->next;
  ldv_52103: ;
#line 1877
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1879
    goto ldv_52102;
  } else {

  }
#line 1915
  rtw_free_recvframe23a_queue(defrag_q);
#line 1917
  if (GlobalDebugLevel23A > 6U) {
#line 1917
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1917
    printk("\016Performance defrag!!!!!\n");
  } else {

  }
#line 1922
  return (prframe);
}
}
#line 1926 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct recv_frame *recvframe_chk_defrag23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  u8 ismfrag ;
  u8 fragnum ;
  u8 *psta_addr ;
  struct recv_frame *pfhdr ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct list_head *phead ;
  struct recv_frame *prtnframe ;
  struct rtw_queue *pfree_recv_queue ;
  struct rtw_queue *pdefrag_q ;
  struct ieee80211_hdr *hdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1936
  prtnframe = (struct recv_frame *)0;
#line 1941
  pstapriv = & padapter->stapriv;
#line 1943
  pfhdr = precv_frame;
#line 1945
  pfree_recv_queue = & padapter->recvpriv.free_recv_queue;
#line 1948
  ismfrag = pfhdr->attrib.mfrag;
#line 1949
  fragnum = pfhdr->attrib.frag_num;
#line 1951
  psta_addr = (u8 *)(& pfhdr->attrib.ta);
#line 1952
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)psta_addr);
#line 1953
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1954
    hdr = (struct ieee80211_hdr *)(pfhdr->pkt)->data;
#line 1956
    tmp = ieee80211_is_data((int )hdr->frame_control);
#line 1956
    if (tmp == 0) {
#line 1957
      psta = rtw_get_bcmc_stainfo23a(padapter);
#line 1958
      pdefrag_q = & psta->sta_recvpriv.defrag_q;
    } else {
#line 1960
      pdefrag_q = (struct rtw_queue *)0;
    }
  } else {
#line 1962
    pdefrag_q = & psta->sta_recvpriv.defrag_q;
  }
#line 1964
  if ((unsigned int )ismfrag == 0U && (unsigned int )fragnum == 0U) {
#line 1965
    prtnframe = precv_frame;
  } else {

  }
#line 1968
  if ((unsigned int )ismfrag == 1U) {
#line 1971
    if ((unsigned long )pdefrag_q != (unsigned long )((struct rtw_queue *)0)) {
#line 1972
      if ((unsigned int )fragnum == 0U) {
#line 1974
        tmp___0 = list_empty((struct list_head  const  *)(& pdefrag_q->queue));
#line 1974
        if (tmp___0 == 0) {
#line 1976
          rtw_free_recvframe23a_queue(pdefrag_q);
        } else {

        }
      } else {

      }
#line 1984
      phead = get_list_head(pdefrag_q);
#line 1985
      list_add_tail(& pfhdr->list, phead);
#line 1988
      if (GlobalDebugLevel23A > 6U) {
#line 1988
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 1988
        printk("\016Enqueuq: ismfrag = %d, fragnum = %d\n", (int )ismfrag, (int )fragnum);
      } else {

      }
#line 1992
      prtnframe = (struct recv_frame *)0;
    } else {
#line 1997
      rtw_free_recvframe23a(precv_frame);
#line 1998
      prtnframe = (struct recv_frame *)0;
#line 1999
      if (GlobalDebugLevel23A > 3U) {
#line 1999
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 1999
        printk("\016Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",
               (int )ismfrag, (int )fragnum);
      } else {

      }
    }
  } else {

  }
#line 2005
  if ((unsigned int )ismfrag == 0U && (unsigned int )fragnum != 0U) {
#line 2008
    if ((unsigned long )pdefrag_q != (unsigned long )((struct rtw_queue *)0)) {
#line 2010
      phead = get_list_head(pdefrag_q);
#line 2011
      list_add_tail(& pfhdr->list, phead);
#line 2015
      if (GlobalDebugLevel23A > 6U) {
#line 2015
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 2015
        printk("\016defrag: ismfrag = %d, fragnum = %d\n", (int )ismfrag, (int )fragnum);
      } else {

      }
#line 2018
      precv_frame = recvframe_defrag(padapter, pdefrag_q);
#line 2019
      prtnframe = precv_frame;
    } else {
#line 2023
      rtw_free_recvframe23a(precv_frame);
#line 2024
      prtnframe = (struct recv_frame *)0;
#line 2025
      if (GlobalDebugLevel23A > 3U) {
#line 2025
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 2025
        printk("\016Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",
               (int )ismfrag, (int )fragnum);
      } else {

      }
    }
  } else {

  }
#line 2032
  if ((unsigned long )prtnframe != (unsigned long )((struct recv_frame *)0) && (unsigned int )prtnframe->attrib.privacy != 0U) {
#line 2034
    tmp___1 = recvframe_chkmic(padapter, prtnframe);
#line 2034
    if (tmp___1 == 0) {
#line 2035
      if (GlobalDebugLevel23A > 3U) {
#line 2035
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 2035
        printk("\016recvframe_chkmic(padapter,  prtnframe) ==_FAIL\n");
      } else {

      }
#line 2038
      rtw_free_recvframe23a(prtnframe);
#line 2039
      prtnframe = (struct recv_frame *)0;
    } else {

    }
  } else {

  }
#line 2045
  return (prtnframe);
}
}
#line 2048
int amsdu_to_msdu(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
#line 2049 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int amsdu_to_msdu(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct sk_buff *skb ;
  struct sk_buff *sub_skb ;
  struct sk_buff_head skb_list ;
  int tmp ;

  {
#line 2055
  pattrib = & prframe->attrib;
#line 2057
  skb = prframe->pkt;
#line 2058
  skb_pull(skb, (unsigned int )prframe->attrib.hdrlen);
#line 2059
  __skb_queue_head_init(& skb_list);
#line 2061
  ieee80211_amsdu_to_8023s(skb, & skb_list, (u8 const   *)0U, 0, 0U, 0);
#line 2063
  goto ldv_52132;
  ldv_52131: 
#line 2064
  sub_skb = __skb_dequeue(& skb_list);
#line 2066
  sub_skb->protocol = eth_type_trans(sub_skb, padapter->pnetdev);
#line 2067
  sub_skb->dev = padapter->pnetdev;
#line 2069
  sub_skb->ip_summed = 0U;
#line 2071
  netif_rx(sub_skb);
  ldv_52132: 
#line 2063
  tmp = skb_queue_empty((struct sk_buff_head  const  *)(& skb_list));
#line 2063
  if (tmp == 0) {
#line 2065
    goto ldv_52131;
  } else {

  }
#line 2074
  prframe->pkt = (struct sk_buff *)0;
#line 2075
  rtw_free_recvframe23a(prframe);
#line 2076
  return (1);
}
}
#line 2079
int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl , u16 seq_num ) ;
#line 2080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl , u16 seq_num ) 
{ 
  u8 wsize ;
  u16 wend ;

  {
#line 2082
  wsize = preorder_ctrl->wsize_b;
#line 2083
  wend = (unsigned int )((u16 )((unsigned int )((int )preorder_ctrl->indicate_seq + (int )((unsigned short )wsize)) + 65535U)) & 4095U;
#line 2086
  if ((unsigned int )preorder_ctrl->indicate_seq == 65535U) {
#line 2087
    preorder_ctrl->indicate_seq = seq_num;
  } else {

  }
#line 2090
  if ((((int )seq_num - (int )preorder_ctrl->indicate_seq) & 2048) != 0) {
#line 2091
    return (0);
  } else {

  }
#line 2098
  if ((int )preorder_ctrl->indicate_seq == (int )seq_num) {
#line 2099
    preorder_ctrl->indicate_seq = (unsigned int )((u16 )((unsigned int )preorder_ctrl->indicate_seq + 1U)) & 4095U;
  } else
#line 2101
  if ((((int )wend - (int )seq_num) & 2048) != 0) {
#line 2103
    if ((int )seq_num >= (int )wsize + -1) {
#line 2104
      preorder_ctrl->indicate_seq = (unsigned int )((int )seq_num - (int )((u16 )wsize)) + 1U;
    } else {
#line 2106
      preorder_ctrl->indicate_seq = (unsigned int )((int )seq_num - (int )((u16 )wsize)) + 4097U;
    }
  } else {

  }
#line 2108
  return (1);
}
}
#line 2111 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static int enqueue_reorder_recvframe23a(struct recv_reorder_ctrl *preorder_ctrl ,
                                        struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct rtw_queue *ppending_recvframe_queue ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct recv_frame *hdr ;
  struct rx_pkt_attrib *pnextattrib ;
  struct list_head  const  *__mptr ;

  {
#line 2114
  pattrib = & prframe->attrib;
#line 2120
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 2126
  phead = get_list_head(ppending_recvframe_queue);
#line 2128
  plist = phead->next;
#line 2128
  ptmp = plist->next;
#line 2128
  goto ldv_52159;
  ldv_52158: 
#line 2129
  __mptr = (struct list_head  const  *)plist;
#line 2129
  hdr = (struct recv_frame *)__mptr;
#line 2130
  pnextattrib = & hdr->attrib;
#line 2132
  if ((((int )pnextattrib->seq_num - (int )pattrib->seq_num) & 2048) != 0) {
#line 2133
    goto ldv_52156;
  } else
#line 2134
  if ((int )pnextattrib->seq_num == (int )pattrib->seq_num) {
#line 2139
    return (0);
  } else {
#line 2141
    goto ldv_52157;
  }
  ldv_52156: 
#line 2128
  plist = ptmp;
#line 2128
  ptmp = plist->next;
  ldv_52159: ;
#line 2128
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2130
    goto ldv_52158;
  } else {

  }
  ldv_52157: 
#line 2150
  list_del_init(& prframe->list);
#line 2152
  list_add_tail(& prframe->list, plist);
#line 2158
  return (1);
}
}
#line 2161
int recv_indicatepkts_in_order(struct rtw_adapter *padapter , struct recv_reorder_ctrl *preorder_ctrl ,
                               int bforced ) ;
#line 2164 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int recv_indicatepkts_in_order(struct rtw_adapter *padapter , struct recv_reorder_ctrl *preorder_ctrl ,
                               int bforced ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct recv_frame *prframe ;
  struct rx_pkt_attrib *pattrib ;
  int bPktInBuf ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *ppending_recvframe_queue ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2173
  bPktInBuf = 0;
#line 2177
  precvpriv = & padapter->recvpriv;
#line 2178
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 2184
  phead = get_list_head(ppending_recvframe_queue);
#line 2185
  plist = phead->next;
#line 2188
  if (bforced != 0) {
#line 2189
    tmp = list_empty((struct list_head  const  *)phead);
#line 2189
    if (tmp != 0) {
#line 2192
      return (1);
    } else {

    }
#line 2195
    __mptr = (struct list_head  const  *)plist;
#line 2195
    prframe = (struct recv_frame *)__mptr;
#line 2196
    pattrib = & prframe->attrib;
#line 2197
    preorder_ctrl->indicate_seq = pattrib->seq_num;
  } else {

  }
#line 2202
  goto ldv_52182;
  ldv_52181: 
#line 2204
  __mptr___0 = (struct list_head  const  *)plist;
#line 2204
  prframe = (struct recv_frame *)__mptr___0;
#line 2205
  pattrib = & prframe->attrib;
#line 2207
  if ((((int )preorder_ctrl->indicate_seq - (int )pattrib->seq_num) & 2048) == 0) {
#line 2208
    if (GlobalDebugLevel23A > 5U) {
#line 2208
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 2208
      printk("\016recv_indicatepkts_in_order: indicate =%d seq =%d amsdu =%d\n", (int )preorder_ctrl->indicate_seq,
             (int )pattrib->seq_num, (int )pattrib->amsdu);
    } else {

    }
#line 2214
    plist = plist->next;
#line 2215
    list_del_init(& prframe->list);
#line 2217
    if ((int )preorder_ctrl->indicate_seq == (int )pattrib->seq_num) {
#line 2219
      preorder_ctrl->indicate_seq = (unsigned int )((u16 )((unsigned int )preorder_ctrl->indicate_seq + 1U)) & 4095U;
    } else {

    }
#line 2223
    if ((unsigned int )pattrib->amsdu == 0U) {
#line 2224
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
#line 2226
        rtw_recv_indicatepkt23a(padapter, prframe);
      } else {

      }
    } else {
#line 2229
      tmp___0 = amsdu_to_msdu(padapter, prframe);
#line 2229
      if (tmp___0 != 1) {
#line 2231
        rtw_free_recvframe23a(prframe);
      } else {

      }
    }
#line 2235
    bPktInBuf = 0;
  } else {
#line 2238
    bPktInBuf = 1;
#line 2239
    goto ldv_52180;
  }
  ldv_52182: 
#line 2202
  tmp___1 = list_empty((struct list_head  const  *)phead);
#line 2202
  if (tmp___1 == 0) {
#line 2204
    goto ldv_52181;
  } else {

  }
  ldv_52180: ;
#line 2248
  return (bPktInBuf);
}
}
#line 2251
int recv_indicatepkt_reorder(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
#line 2253 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int recv_indicatepkt_reorder(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  int retval ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct rtw_queue *ppending_recvframe_queue ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
#line 2256
  retval = 1;
#line 2261
  pattrib = & prframe->attrib;
#line 2262
  preorder_ctrl = prframe->preorder_ctrl;
#line 2263
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 2265
  if ((unsigned int )pattrib->amsdu == 0U) {
#line 2267
    wlanhdr_to_ethhdr(prframe);
#line 2269
    if (((unsigned int )pattrib->qos != 1U || (unsigned int )pattrib->eth_type == 2054U) || (unsigned int )pattrib->ack_policy != 0U) {
#line 2271
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
#line 2273
        if (GlobalDebugLevel23A > 5U) {
#line 2273
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 2273
          printk("\016@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n");
        } else {

        }
#line 2277
        rtw_recv_indicatepkt23a(padapter, prframe);
#line 2278
        return (1);
      } else {

      }
#line 2281
      return (0);
    } else {

    }
#line 2284
    if ((unsigned int )preorder_ctrl->enable == 0U) {
#line 2286
      preorder_ctrl->indicate_seq = pattrib->seq_num;
#line 2287
      rtw_recv_indicatepkt23a(padapter, prframe);
#line 2289
      preorder_ctrl->indicate_seq = (u16 )(((int )preorder_ctrl->indicate_seq + 1) % 4096);
#line 2291
      return (1);
    } else {

    }
  } else
#line 2295
  if ((unsigned int )preorder_ctrl->enable == 0U) {
#line 2296
    preorder_ctrl->indicate_seq = pattrib->seq_num;
#line 2297
    retval = amsdu_to_msdu(padapter, prframe);
#line 2299
    preorder_ctrl->indicate_seq = (u16 )(((int )preorder_ctrl->indicate_seq + 1) % 4096);
#line 2301
    return (retval);
  } else {

  }
#line 2305
  spin_lock_bh(& ppending_recvframe_queue->lock);
#line 2307
  if (GlobalDebugLevel23A > 5U) {
#line 2307
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 2307
    printk("\016recv_indicatepkt_reorder: indicate =%d seq =%d\n", (int )preorder_ctrl->indicate_seq,
           (int )pattrib->seq_num);
  } else {

  }
#line 2312
  tmp = check_indicate_seq(preorder_ctrl, (int )pattrib->seq_num);
#line 2312
  if (tmp == 0) {
#line 2313
    goto _err_exit;
  } else {

  }
#line 2317
  tmp___0 = enqueue_reorder_recvframe23a(preorder_ctrl, prframe);
#line 2317
  if (tmp___0 == 0) {
#line 2318
    goto _err_exit;
  } else {

  }
#line 2334
  tmp___2 = recv_indicatepkts_in_order(padapter, preorder_ctrl, 0);
#line 2334
  if (tmp___2 == 1) {
#line 2335
    tmp___1 = msecs_to_jiffies(50U);
#line 2335
    ldv_mod_timer_662(& preorder_ctrl->reordering_ctrl_timer, tmp___1 + (unsigned long )jiffies);
#line 2337
    spin_unlock_bh(& ppending_recvframe_queue->lock);
  } else {
#line 2339
    spin_unlock_bh(& ppending_recvframe_queue->lock);
#line 2340
    ldv_del_timer_sync_663(& preorder_ctrl->reordering_ctrl_timer);
  }
#line 2342
  return (1);
  _err_exit: 
#line 2346
  spin_unlock_bh(& ppending_recvframe_queue->lock);
#line 2347
  return (0);
}
}
#line 2350 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void rtw_reordering_ctrl_timeout_handler23a(unsigned long pcontext ) 
{ 
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct rtw_adapter *padapter ;
  struct rtw_queue *ppending_recvframe_queue ;
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 2356
  preorder_ctrl = (struct recv_reorder_ctrl *)pcontext;
#line 2357
  padapter = preorder_ctrl->padapter;
#line 2358
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 2360
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 2361
    return;
  } else {

  }
#line 2366
  spin_lock_bh(& ppending_recvframe_queue->lock);
#line 2368
  tmp___0 = recv_indicatepkts_in_order(padapter, preorder_ctrl, 1);
#line 2368
  if (tmp___0 == 1) {
#line 2369
    tmp = msecs_to_jiffies(50U);
#line 2369
    ldv_mod_timer_664(& preorder_ctrl->reordering_ctrl_timer, tmp + (unsigned long )jiffies);
  } else {

  }
#line 2373
  spin_unlock_bh(& ppending_recvframe_queue->lock);
#line 2374
  return;
}
}
#line 2376
int process_recv_indicatepkts(struct rtw_adapter *padapter , struct recv_frame *prframe ) ;
#line 2378 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int process_recv_indicatepkts(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  int retval ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  int tmp ;

  {
#line 2381
  retval = 1;
#line 2384
  pmlmepriv = & padapter->mlmepriv;
#line 2385
  phtpriv = & pmlmepriv->htpriv;
#line 2387
  if (phtpriv->ht_option == 1U) {
#line 2391
    tmp = recv_indicatepkt_reorder(padapter, prframe);
#line 2391
    if (tmp != 1) {
#line 2392
      if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
#line 2394
        retval = 0;
#line 2395
        return (retval);
      } else {

      }
    } else {

    }
  } else {
#line 2400
    retval = wlanhdr_to_ethhdr(prframe);
#line 2401
    if (retval != 1) {
#line 2402
      if (GlobalDebugLevel23A > 3U) {
#line 2402
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 2402
        printk("\016wlanhdr_to_ethhdr: drop pkt\n");
      } else {

      }
#line 2404
      return (retval);
    } else {

    }
#line 2407
    if (padapter->bDriverStopped == 0 && padapter->bSurpriseRemoved == 0) {
#line 2410
      if (GlobalDebugLevel23A > 5U) {
#line 2410
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 2410
        printk("\016@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n");
      } else {

      }
#line 2413
      rtw_recv_indicatepkt23a(padapter, prframe);
    } else {
#line 2415
      if (GlobalDebugLevel23A > 5U) {
#line 2415
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 2415
        printk("\016@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n");
      } else {

      }
#line 2419
      if (GlobalDebugLevel23A > 5U) {
#line 2419
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 6);
#line 2419
        printk("\016recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped,
               padapter->bSurpriseRemoved);
      } else {

      }
#line 2424
      retval = 0;
#line 2425
      return (retval);
    }
  }
#line 2430
  return (retval);
}
}
#line 2433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static int recv_func_prehandle(struct rtw_adapter *padapter , struct recv_frame *rframe ) 
{ 
  int ret ;

  {
#line 2436
  ret = 1;
#line 2439
  ret = validate_recv_frame(padapter, rframe);
#line 2440
  if (ret != 1) {
#line 2441
    if (GlobalDebugLevel23A > 6U) {
#line 2441
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 2441
      printk("\016recv_func: validate_recv_frame fail! drop pkt\n");
    } else {

    }
#line 2443
    rtw_free_recvframe23a(rframe);
#line 2444
    goto exit;
  } else {

  }
  exit: ;
#line 2448
  return (ret);
}
}
#line 2451 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
static int recv_func_posthandle(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  int ret ;
  struct recv_frame *orig_prframe ;
  struct recv_priv *precvpriv ;

  {
#line 2454
  ret = 1;
#line 2455
  orig_prframe = prframe;
#line 2456
  precvpriv = & padapter->recvpriv;
#line 2461
  prframe = decryptor(padapter, prframe);
#line 2462
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
#line 2463
    if (GlobalDebugLevel23A > 3U) {
#line 2463
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 2463
      printk("\016decryptor: drop pkt\n");
    } else {

    }
#line 2465
    ret = 0;
#line 2466
    goto _recv_data_drop;
  } else {

  }
#line 2469
  prframe = recvframe_chk_defrag23a(padapter, prframe);
#line 2470
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
#line 2471
    if (GlobalDebugLevel23A > 3U) {
#line 2471
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 2471
      printk("\016recvframe_chk_defrag23a: drop pkt\n");
    } else {

    }
#line 2473
    goto _recv_data_drop;
  } else {

  }
#line 2479
  if ((unsigned int )prframe->attrib.iv_len != 0U) {
#line 2480
    skb_pull(prframe->pkt, (unsigned int )prframe->attrib.iv_len);
  } else {

  }
#line 2483
  if ((unsigned int )prframe->attrib.icv_len != 0U) {
#line 2484
    skb_trim(prframe->pkt, (prframe->pkt)->len - (unsigned int )prframe->attrib.icv_len);
  } else {

  }
#line 2488
  prframe = portctrl(padapter, prframe);
#line 2489
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0)) {
#line 2490
    if (GlobalDebugLevel23A > 3U) {
#line 2490
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 2490
      printk("\016portctrl: drop pkt\n");
    } else {

    }
#line 2492
    ret = 0;
#line 2493
    goto _recv_data_drop;
  } else {

  }
#line 2496
  count_rx_stats(padapter, prframe, (struct sta_info *)0);
#line 2498
  ret = process_recv_indicatepkts(padapter, prframe);
#line 2499
  if (ret != 1) {
#line 2500
    if (GlobalDebugLevel23A > 3U) {
#line 2500
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 2500
      printk("\016recv_func: process_recv_indicatepkts fail!\n");
    } else {

    }
#line 2502
    rtw_free_recvframe23a(orig_prframe);
#line 2503
    goto _recv_data_drop;
  } else {

  }
#line 2505
  return (ret);
  _recv_data_drop: 
#line 2508
  precvpriv->rx_drop = precvpriv->rx_drop + 1ULL;
#line 2509
  return (ret);
}
}
#line 2512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int rtw_recv_entry23a(struct recv_frame *rframe ) 
{ 
  int ret ;
  int r ;
  struct rtw_adapter *padapter ;
  struct rx_pkt_attrib *prxattrib ;
  struct recv_priv *recvpriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *mlmepriv ;
  struct recv_frame *pending_frame ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 2515
  padapter = rframe->adapter;
#line 2516
  prxattrib = & rframe->attrib;
#line 2517
  recvpriv = & padapter->recvpriv;
#line 2518
  psecuritypriv = & padapter->securitypriv;
#line 2519
  mlmepriv = & padapter->mlmepriv;
#line 2522
  tmp = check_fwstate(mlmepriv, 8);
#line 2522
  if ((int )tmp && (unsigned int )*((unsigned char *)psecuritypriv + 836UL) != 0U) {
#line 2526
    goto ldv_52238;
    ldv_52237: 
#line 2527
    r = recv_func_posthandle(padapter, pending_frame);
#line 2528
    if (r == 1) {
#line 2529
      if (GlobalDebugLevel23A > 3U) {
#line 2529
        printk("\016RTL8723AU: %s: dequeue uc_swdec_pending_queue\n", "rtw_recv_entry23a");
      } else {

      }
    } else {

    }
    ldv_52238: 
#line 2526
    pending_frame = rtw_alloc_recvframe23a(& padapter->recvpriv.uc_swdec_pending_queue);
#line 2526
    if ((unsigned long )pending_frame != (unsigned long )((struct recv_frame *)0)) {
#line 2528
      goto ldv_52237;
    } else {

    }

  } else {

  }
#line 2533
  ret = recv_func_prehandle(padapter, rframe);
#line 2535
  if (ret == 1) {
#line 2537
    tmp___0 = check_fwstate(mlmepriv, 8);
#line 2537
    if ((int )tmp___0) {
#line 2537
      tmp___1 = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 2537
      if (tmp___1) {
#line 2537
        tmp___2 = 0;
      } else {
#line 2537
        tmp___2 = 1;
      }
#line 2537
      if (tmp___2) {
#line 2537
        if (prxattrib->encrypt != 0U) {
#line 2537
          if ((unsigned int )prxattrib->bdecrypted == 0U) {
#line 2537
            if (psecuritypriv->dot11PrivacyAlgrthm != 1027073U && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
#line 2537
              if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
#line 2543
                rtw_enqueue_recvframe23a(rframe, & padapter->recvpriv.uc_swdec_pending_queue);
#line 2544
                if (GlobalDebugLevel23A > 3U) {
#line 2544
                  printk("\016RTL8723AU: %s: no key, enqueue uc_swdec_pending_queue\n",
                         "rtw_recv_entry23a");
                } else {

                }
#line 2545
                goto exit;
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 2548
    ret = recv_func_posthandle(padapter, rframe);
#line 2550
    recvpriv->rx_pkts = recvpriv->rx_pkts + 1ULL;
  } else {

  }
  exit: ;
#line 2554
  return (ret);
}
}
#line 2557 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void rtw_signal_stat_timer_hdl23a(unsigned long data ) 
{ 
  struct rtw_adapter *adapter ;
  struct recv_priv *recvpriv ;
  u32 tmp_s ;
  u32 tmp_q ;
  u8 avg_signal_strength ;
  u8 avg_signal_qual ;
  u32 num_signal_strength ;
  u32 num_signal_qual ;
  u8 _alpha ;
  s32 tmp ;
  s32 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 2559
  adapter = (struct rtw_adapter *)data;
#line 2560
  recvpriv = & adapter->recvpriv;
#line 2563
  avg_signal_strength = 0U;
#line 2564
  avg_signal_qual = 0U;
#line 2565
  num_signal_strength = 0U;
#line 2566
  num_signal_qual = 0U;
#line 2567
  _alpha = 3U;
#line 2570
  if ((unsigned int )adapter->recvpriv.is_signal_dbg != 0U) {
#line 2573
    adapter->recvpriv.signal_strength = adapter->recvpriv.signal_strength_dbg;
#line 2575
    tmp = translate_percentage_to_dbm((u32 )adapter->recvpriv.signal_strength_dbg);
#line 2575
    adapter->recvpriv.rssi = (signed char )tmp;
  } else {
#line 2578
    if ((unsigned int )recvpriv->signal_strength_data.update_req == 0U) {
#line 2580
      avg_signal_strength = recvpriv->signal_strength_data.avg_val;
#line 2582
      num_signal_strength = recvpriv->signal_strength_data.total_num;
#line 2586
      recvpriv->signal_strength_data.update_req = 1U;
    } else {

    }
#line 2589
    if ((unsigned int )recvpriv->signal_qual_data.update_req == 0U) {
#line 2591
      avg_signal_qual = recvpriv->signal_qual_data.avg_val;
#line 2592
      num_signal_qual = recvpriv->signal_qual_data.total_num;
#line 2595
      recvpriv->signal_qual_data.update_req = 1U;
    } else {

    }
#line 2599
    tmp___1 = check_fwstate(& adapter->mlmepriv, 2048);
#line 2599
    if (tmp___1) {
#line 2599
      tmp___2 = 0;
    } else {
#line 2599
      tmp___2 = 1;
    }
#line 2599
    if (tmp___2) {
#line 2600
      tmp_s = (u32 )((int )avg_signal_strength + ((int )_alpha + -1) * (int )recvpriv->signal_strength);
#line 2602
      if (tmp_s % (u32 )_alpha != 0U) {
#line 2603
        tmp_s = tmp_s / (u32 )_alpha + 1U;
      } else {
#line 2605
        tmp_s = tmp_s / (u32 )_alpha;
      }
#line 2606
      if (tmp_s > 100U) {
#line 2607
        tmp_s = 100U;
      } else {

      }
#line 2609
      tmp_q = (u32 )((int )avg_signal_qual + ((int )_alpha + -1) * (int )recvpriv->signal_qual);
#line 2611
      if (tmp_q % (u32 )_alpha != 0U) {
#line 2612
        tmp_q = tmp_q / (u32 )_alpha + 1U;
      } else {
#line 2614
        tmp_q = tmp_q / (u32 )_alpha;
      }
#line 2615
      if (tmp_q > 100U) {
#line 2616
        tmp_q = 100U;
      } else {

      }
#line 2618
      recvpriv->signal_strength = (u8 )tmp_s;
#line 2619
      tmp___0 = translate_percentage_to_dbm(tmp_s);
#line 2619
      recvpriv->rssi = (signed char )tmp___0;
#line 2620
      recvpriv->signal_qual = (u8 )tmp_q;
#line 2622
      if (GlobalDebugLevel23A > 3U) {
#line 2622
        printk("\016RTL8723AU: %s signal_strength:%3u, rssi:%3d, signal_qual:%3u, num_signal_strength:%u, num_signal_qual:%u\n",
               "rtw_signal_stat_timer_hdl23a", (int )recvpriv->signal_strength, (int )recvpriv->rssi,
               (int )recvpriv->signal_qual, num_signal_strength, num_signal_qual);
      } else {

      }
    } else {

    }
  }
#line 2631
  tmp___3 = msecs_to_jiffies(recvpriv->signal_stat_sampling_interval);
#line 2631
  ldv_mod_timer_665(& recvpriv->signal_stat_timer, tmp___3 + (unsigned long )jiffies);
#line 2632
  return;
}
}
#line 2635 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void activate_pending_timer_10(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 2636
  if ((unsigned long )ldv_timer_list_10_0 == (unsigned long )timer) {
#line 2637
    if (ldv_timer_10_0 == 2 || pending_flag != 0) {
#line 2638
      ldv_timer_list_10_0 = timer;
#line 2639
      ldv_timer_list_10_0->data = data;
#line 2640
      ldv_timer_10_0 = 1;
    } else {

    }
#line 2642
    return;
  } else {

  }
#line 2645
  if ((unsigned long )ldv_timer_list_10_1 == (unsigned long )timer) {
#line 2646
    if (ldv_timer_10_1 == 2 || pending_flag != 0) {
#line 2647
      ldv_timer_list_10_1 = timer;
#line 2648
      ldv_timer_list_10_1->data = data;
#line 2649
      ldv_timer_10_1 = 1;
    } else {

    }
#line 2651
    return;
  } else {

  }
#line 2654
  if ((unsigned long )ldv_timer_list_10_2 == (unsigned long )timer) {
#line 2655
    if (ldv_timer_10_2 == 2 || pending_flag != 0) {
#line 2656
      ldv_timer_list_10_2 = timer;
#line 2657
      ldv_timer_list_10_2->data = data;
#line 2658
      ldv_timer_10_2 = 1;
    } else {

    }
#line 2660
    return;
  } else {

  }
#line 2663
  if ((unsigned long )ldv_timer_list_10_3 == (unsigned long )timer) {
#line 2664
    if (ldv_timer_10_3 == 2 || pending_flag != 0) {
#line 2665
      ldv_timer_list_10_3 = timer;
#line 2666
      ldv_timer_list_10_3->data = data;
#line 2667
      ldv_timer_10_3 = 1;
    } else {

    }
#line 2669
    return;
  } else {

  }
#line 2671
  activate_suitable_timer_10(timer, data);
#line 2672
  return;
}
}
#line 2675 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int reg_timer_10(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 2676
  if ((unsigned long )function == (unsigned long )(& rtw_signal_stat_timer_hdl23a)) {
#line 2677
    activate_suitable_timer_10(timer, data);
  } else {

  }
#line 2678
  return (0);
}
}
#line 2682 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void ldv_timer_10(int state , struct timer_list *timer ) 
{ 


  {
#line 2683
  LDV_IN_INTERRUPT = 2;
#line 2684
  rtw_signal_stat_timer_hdl23a(timer->data);
#line 2685
  LDV_IN_INTERRUPT = 1;
#line 2686
  return;
}
}
#line 2689 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void disable_suitable_timer_10(struct timer_list *timer ) 
{ 


  {
#line 2690
  if (ldv_timer_10_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_0) {
#line 2691
    ldv_timer_10_0 = 0;
#line 2692
    return;
  } else {

  }
#line 2694
  if (ldv_timer_10_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_1) {
#line 2695
    ldv_timer_10_1 = 0;
#line 2696
    return;
  } else {

  }
#line 2698
  if (ldv_timer_10_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_2) {
#line 2699
    ldv_timer_10_2 = 0;
#line 2700
    return;
  } else {

  }
#line 2702
  if (ldv_timer_10_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_10_3) {
#line 2703
    ldv_timer_10_3 = 0;
#line 2704
    return;
  } else {

  }
#line 2706
  return;
}
}
#line 2710 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void activate_suitable_timer_10(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 2711
  if (ldv_timer_10_0 == 0 || ldv_timer_10_0 == 2) {
#line 2712
    ldv_timer_list_10_0 = timer;
#line 2713
    ldv_timer_list_10_0->data = data;
#line 2714
    ldv_timer_10_0 = 1;
#line 2715
    return;
  } else {

  }
#line 2717
  if (ldv_timer_10_1 == 0 || ldv_timer_10_1 == 2) {
#line 2718
    ldv_timer_list_10_1 = timer;
#line 2719
    ldv_timer_list_10_1->data = data;
#line 2720
    ldv_timer_10_1 = 1;
#line 2721
    return;
  } else {

  }
#line 2723
  if (ldv_timer_10_2 == 0 || ldv_timer_10_2 == 2) {
#line 2724
    ldv_timer_list_10_2 = timer;
#line 2725
    ldv_timer_list_10_2->data = data;
#line 2726
    ldv_timer_10_2 = 1;
#line 2727
    return;
  } else {

  }
#line 2729
  if (ldv_timer_10_3 == 0 || ldv_timer_10_3 == 2) {
#line 2730
    ldv_timer_list_10_3 = timer;
#line 2731
    ldv_timer_list_10_3->data = data;
#line 2732
    ldv_timer_10_3 = 1;
#line 2733
    return;
  } else {

  }
#line 2735
  return;
}
}
#line 2739 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void timer_init_10(void) 
{ 


  {
#line 2740
  ldv_timer_10_0 = 0;
#line 2741
  ldv_timer_10_1 = 0;
#line 2742
  ldv_timer_10_2 = 0;
#line 2743
  ldv_timer_10_3 = 0;
#line 2744
  return;
}
}
#line 2747 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void choose_timer_10(void) 
{ 
  int tmp ;

  {
#line 2748
  tmp = __VERIFIER_nondet_int();
#line 2748
  switch (tmp) {
  case 0: ;
#line 2750
  if (ldv_timer_10_0 == 1) {
#line 2751
    ldv_timer_10_0 = 2;
#line 2752
    ldv_timer_10(ldv_timer_10_0, ldv_timer_list_10_0);
  } else {

  }
#line 2755
  goto ldv_52283;
  case 1: ;
#line 2757
  if (ldv_timer_10_1 == 1) {
#line 2758
    ldv_timer_10_1 = 2;
#line 2759
    ldv_timer_10(ldv_timer_10_1, ldv_timer_list_10_1);
  } else {

  }
#line 2762
  goto ldv_52283;
  case 2: ;
#line 2764
  if (ldv_timer_10_2 == 1) {
#line 2765
    ldv_timer_10_2 = 2;
#line 2766
    ldv_timer_10(ldv_timer_10_2, ldv_timer_list_10_2);
  } else {

  }
#line 2769
  goto ldv_52283;
  case 3: ;
#line 2771
  if (ldv_timer_10_3 == 1) {
#line 2772
    ldv_timer_10_3 = 2;
#line 2773
    ldv_timer_10(ldv_timer_10_3, ldv_timer_list_10_3);
  } else {

  }
#line 2776
  goto ldv_52283;
  default: 
#line 2777
  ldv_stop();
  }
  ldv_52283: ;
#line 2779
  return;
}
}
#line 2782 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 2785
  ldv_spin_lock();
#line 2787
  ldv_spin_lock_629(lock);
#line 2788
  return;
}
}
#line 2817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 2820
  ldv_spin_unlock();
#line 2822
  ldv_spin_unlock_633(lock);
#line 2823
  return;
}
}
#line 2909 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
void *ldv_kmem_cache_alloc_644(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2912
  ldv_check_alloc_flags(flags);
#line 2914
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2915
  return ((void *)0);
}
}
#line 2953 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_pskb_expand_head_650(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2956
  ldv_check_alloc_flags(flags);
#line 2958
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2958
  return (tmp);
}
}
#line 2969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct sk_buff *ldv_skb_clone_652(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2972
  ldv_check_alloc_flags(flags);
#line 2974
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2974
  return (tmp);
}
}
#line 2985 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct sk_buff *ldv_skb_copy_654(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2988
  ldv_check_alloc_flags(flags);
#line 2990
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2990
  return (tmp);
}
}
#line 2993 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_655(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2996
  ldv_check_alloc_flags(flags);
#line 2998
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2998
  return (tmp);
}
}
#line 3001 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_656(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3004
  ldv_check_alloc_flags(flags);
#line 3006
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 3006
  return (tmp);
}
}
#line 3009 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_657(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3012
  ldv_check_alloc_flags(flags);
#line 3014
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 3014
  return (tmp);
}
}
#line 3017 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_pskb_expand_head_658(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 3020
  ldv_check_alloc_flags(flags);
#line 3022
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 3022
  return (tmp);
}
}
#line 3025 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_pskb_expand_head_659(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 3028
  ldv_check_alloc_flags(flags);
#line 3030
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 3030
  return (tmp);
}
}
#line 3033 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
struct sk_buff *ldv_skb_clone_660(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3036
  ldv_check_alloc_flags(flags);
#line 3038
  tmp = skb_clone(ldv_func_arg1, flags);
#line 3038
  return (tmp);
}
}
#line 3041 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_mod_timer_661(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 3045
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3045
  ldv_func_res = tmp;
#line 3047
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3049
  return (ldv_func_res);
}
}
#line 3052 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_mod_timer_662(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 3056
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3056
  ldv_func_res = tmp;
#line 3058
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3060
  return (ldv_func_res);
}
}
#line 3063 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_del_timer_sync_663(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 3067
  tmp = del_timer_sync(ldv_func_arg1);
#line 3067
  ldv_func_res = tmp;
#line 3069
  disable_suitable_timer_6(ldv_func_arg1);
#line 3071
  return (ldv_func_res);
}
}
#line 3074 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_mod_timer_664(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 3078
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3078
  ldv_func_res = tmp;
#line 3080
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3082
  return (ldv_func_res);
}
}
#line 3085 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_recv.o.c.prepared"
int ldv_mod_timer_665(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 3089
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 3089
  ldv_func_res = tmp;
#line 3091
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 3093
  return (ldv_func_res);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_696(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_704(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_712(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_706(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_702(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_710(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_711(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_707(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_708(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_709(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 312 "drivers/staging/rtl8723au/include/rtw_security.h"
void rtw_secmicsetkey23a(struct mic_data *pmicdata , u8 *key ) ;
#line 313
void rtw_secmicappend23abyte23a(struct mic_data *pmicdata , u8 b ) ;
#line 314
void rtw_secmicappend23a(struct mic_data *pmicdata , u8 *src , u32 nbytes ) ;
#line 315
void rtw_secgetmic23a(struct mic_data *pmicdata , u8 *dst ) ;
#line 320
int rtw_aes_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 322
int rtw_tkip_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 332
void rtw_use_tkipkey_handler23a(void *FunctionContext ) ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void arcfour_init(struct arc4context *parc4ctx , u8 *key , u32 key_len ) 
{ 
  u32 t ;
  u32 u ;
  u32 keyindex ;
  u32 stateindex ;
  u8 *state ;
  u32 counter ;

  {
#line 259
  state = (u8 *)(& parc4ctx->state);
#line 260
  parc4ctx->x = 0U;
#line 261
  parc4ctx->y = 0U;
#line 262
  counter = 0U;
#line 262
  goto ldv_51423;
  ldv_51422: 
#line 263
  *(state + (unsigned long )counter) = (unsigned char )counter;
#line 262
  counter = counter + 1U;
  ldv_51423: ;
#line 262
  if (counter <= 255U) {
#line 264
    goto ldv_51422;
  } else {

  }
#line 264
  keyindex = 0U;
#line 265
  stateindex = 0U;
#line 266
  counter = 0U;
#line 266
  goto ldv_51426;
  ldv_51425: 
#line 268
  t = (u32 )*(state + (unsigned long )counter);
#line 269
  stateindex = (((u32 )*(key + (unsigned long )keyindex) + stateindex) + t) & 255U;
#line 270
  u = (u32 )*(state + (unsigned long )stateindex);
#line 271
  *(state + (unsigned long )stateindex) = (unsigned char )t;
#line 272
  *(state + (unsigned long )counter) = (unsigned char )u;
#line 273
  keyindex = keyindex + 1U;
#line 273
  if (keyindex >= key_len) {
#line 274
    keyindex = 0U;
  } else {

  }
#line 266
  counter = counter + 1U;
  ldv_51426: ;
#line 266
  if (counter <= 255U) {
#line 268
    goto ldv_51425;
  } else {

  }

#line 273
  return;
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static u32 arcfour_byte(struct arc4context *parc4ctx ) 
{ 
  u32 x ;
  u32 y ;
  u32 sx ;
  u32 sy ;
  u8 *state ;

  {
#line 285
  state = (u8 *)(& parc4ctx->state);
#line 286
  x = (parc4ctx->x + 1U) & 255U;
#line 287
  sx = (u32 )*(state + (unsigned long )x);
#line 288
  y = (parc4ctx->y + sx) & 255U;
#line 289
  sy = (u32 )*(state + (unsigned long )y);
#line 290
  parc4ctx->x = x;
#line 291
  parc4ctx->y = y;
#line 292
  *(state + (unsigned long )y) = (unsigned char )sx;
#line 293
  *(state + (unsigned long )x) = (unsigned char )sy;
#line 295
  return ((u32 )*(state + ((unsigned long )(sx + sy) & 255UL)));
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void arcfour_encrypt(struct arc4context *parc4ctx , u8 *dest , u8 *src , u32 len ) 
{ 
  u32 i ;
  u32 tmp ;

  {
#line 305
  i = 0U;
#line 305
  goto ldv_51444;
  ldv_51443: 
#line 306
  tmp = arcfour_byte(parc4ctx);
#line 306
  *(dest + (unsigned long )i) = (u8 )((int )*(src + (unsigned long )i) ^ (int )((unsigned char )tmp));
#line 305
  i = i + 1U;
  ldv_51444: ;
#line 305
  if (i < len) {
#line 307
    goto ldv_51443;
  } else {

  }

#line 312
  return;
}
}
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static int bcrc32initialized  =    0;
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static u32 crc32_table[256U]  ;
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static u8 crc32_reverseBit(u8 data ) 
{ 
  u8 retval ;

  {
#line 315
  retval = (u8 )((((((((int )((signed char )((int )data << 7)) | ((int )((signed char )((int )data << 5)) & 64)) | ((int )((signed char )((int )data << 3)) & 32)) | ((int )((signed char )((int )data << 1)) & 16)) | ((int )((signed char )((int )data >> 1)) & 8)) | ((int )((signed char )((int )data >> 3)) & 4)) | ((int )((signed char )((int )data >> 5)) & 2)) | (int )((signed char )((int )data >> 7)));
#line 319
  return (retval);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void crc32_init(void) 
{ 
  int i ;
  int j ;
  u32 c ;
  u8 *p ;
  u8 *p1 ;
  u8 k ;

  {
#line 325
  if (bcrc32initialized == 1) {
#line 326
    return;
  } else {
#line 330
    p = (u8 *)(& c);
#line 333
    c = 305397760U;
#line 335
    i = 0;
#line 335
    goto ldv_51465;
    ldv_51464: 
#line 337
    k = crc32_reverseBit((int )((unsigned char )i));
#line 338
    c = (unsigned int )k << 24;
#line 338
    j = 8;
#line 338
    goto ldv_51462;
    ldv_51461: 
#line 339
    c = (int )c < 0 ? (c << 1) ^ 79764919U : c << 1;
#line 338
    j = j - 1;
    ldv_51462: ;
#line 338
    if (j > 0) {
#line 340
      goto ldv_51461;
    } else {

    }
#line 341
    p1 = (u8 *)(& crc32_table) + (unsigned long )i;
#line 343
    *p1 = crc32_reverseBit((int )*(p + 3UL));
#line 344
    *(p1 + 1UL) = crc32_reverseBit((int )*(p + 2UL));
#line 345
    *(p1 + 2UL) = crc32_reverseBit((int )*(p + 1UL));
#line 346
    *(p1 + 3UL) = crc32_reverseBit((int )*p);
#line 335
    i = i + 1;
    ldv_51465: ;
#line 335
    if (i <= 255) {
#line 337
      goto ldv_51464;
    } else {

    }
#line 348
    bcrc32initialized = 1;
  }
#line 350
  return;
}
}
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static u32 getcrc32(u8 *buf , int len ) 
{ 
  u8 *p ;
  u32 crc ;

  {
#line 357
  if (bcrc32initialized == 0) {
#line 357
    crc32_init();
  } else {

  }
#line 359
  crc = 4294967295U;
#line 361
  p = buf;
#line 361
  goto ldv_51474;
  ldv_51473: 
#line 362
  crc = crc32_table[((u32 )*p ^ crc) & 255U] ^ (crc >> 8);
#line 361
  p = p + 1;
#line 361
  len = len - 1;
  ldv_51474: ;
#line 361
  if (len > 0) {
#line 363
    goto ldv_51473;
  } else {

  }

#line 364
  return (~ crc);
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void rtw_wep_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  unsigned char crc[4U] ;
  struct arc4context mycontext ;
  int curfragnum ;
  int length ;
  int index ;
  u32 keylength ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 wepkey[16U] ;
  u8 hw_hdr_offset ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 378
  hw_hdr_offset = 0U;
#line 379
  pattrib = & pxmitframe->attrib;
#line 380
  psecuritypriv = & padapter->securitypriv;
#line 381
  pxmitpriv = & padapter->xmitpriv;
#line 383
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
#line 384
    return;
  } else {

  }
#line 386
  hw_hdr_offset = 40U;
#line 388
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
#line 391
  if (pattrib->encrypt != 1027073U && pattrib->encrypt != 1027077U) {
#line 393
    return;
  } else {

  }
#line 395
  index = (int )psecuritypriv->dot11PrivacyKeyIndex;
#line 396
  keylength = (u32 )psecuritypriv->wep_key[index].keylen;
#line 398
  curfragnum = 0;
#line 398
  goto ldv_51501;
  ldv_51500: 
#line 399
  iv = pframe + (unsigned long )pattrib->hdrlen;
#line 400
  __len = 3UL;
#line 400
  if (__len > 63UL) {
#line 400
    __ret = __memcpy((void *)(& wepkey), (void const   *)iv, __len);
  } else {
#line 400
    __ret = __builtin_memcpy((void *)(& wepkey), (void const   *)iv, __len);
  }
#line 401
  __len___0 = (size_t )keylength;
#line 401
  __ret___0 = __builtin_memcpy((void *)(& wepkey) + 3U, (void const   *)(& psecuritypriv->wep_key[index].key),
                               __len___0);
#line 403
  payload = pframe + ((unsigned long )pattrib->iv_len + (unsigned long )pattrib->hdrlen);
#line 405
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
#line 407
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
#line 410
    *((u32 *)(& crc)) = getcrc32(payload, length);
#line 412
    arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
#line 413
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 414
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
  } else {
#line 416
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
#line 418
    *((u32 *)(& crc)) = getcrc32(payload, length);
#line 419
    arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
#line 420
    arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 421
    arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                    4U);
#line 423
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
#line 424
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
#line 398
  curfragnum = curfragnum + 1;
  ldv_51501: ;
#line 398
  if ((int )pattrib->nr_frags > curfragnum) {
#line 400
    goto ldv_51500;
  } else {

  }

#line 405
  return;
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void rtw_wep_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) 
{ 
  u8 crc[4U] ;
  struct arc4context mycontext ;
  int length ;
  u32 keylength ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 wepkey[16U] ;
  u8 keyindex ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 440
  prxattrib = & precvframe->attrib;
#line 441
  psecuritypriv = & padapter->securitypriv;
#line 442
  skb = precvframe->pkt;
#line 444
  pframe = skb->data;
#line 447
  if (prxattrib->encrypt != 1027073U && prxattrib->encrypt != 1027077U) {
#line 449
    return;
  } else {

  }
#line 451
  iv = pframe + (unsigned long )prxattrib->hdrlen;
#line 453
  keyindex = prxattrib->key_index;
#line 454
  keylength = (u32 )psecuritypriv->wep_key[(int )keyindex].keylen;
#line 455
  __len = 3UL;
#line 455
  if (__len > 63UL) {
#line 455
    __ret = __memcpy((void *)(& wepkey), (void const   *)iv, __len);
  } else {
#line 455
    __ret = __builtin_memcpy((void *)(& wepkey), (void const   *)iv, __len);
  }
#line 457
  __len___0 = (size_t )keylength;
#line 457
  __ret___0 = __builtin_memcpy((void *)(& wepkey) + 3U, (void const   *)(& psecuritypriv->wep_key[(int )keyindex].key),
                               __len___0);
#line 458
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
#line 460
  payload = pframe + ((unsigned long )prxattrib->iv_len + (unsigned long )prxattrib->hdrlen);
#line 463
  arcfour_init(& mycontext, (u8 *)(& wepkey), keylength + 3U);
#line 464
  arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 467
  *((u32 *)(& crc)) = getcrc32(payload, length + -4);
#line 469
  if ((((int )crc[3] != (int )*(payload + ((unsigned long )length + 0xffffffffffffffffUL)) || (int )crc[2] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffeUL))) || (int )crc[1] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffdUL))) || (int )crc[0] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffcUL))) {
#line 471
    if (GlobalDebugLevel23A > 3U) {
#line 471
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 471
      printk("\016rtw_wep_decrypt23a:icv error crc[3](%x)!= payload[length-1](%x) || crc[2](%x)!= payload[length-2](%x) || crc[1](%x)!= payload[length-3](%x) || crc[0](%x)!= payload[length-4](%x)\n",
             (int )crc[3], (int )*(payload + ((unsigned long )length + 0xffffffffffffffffUL)),
             (int )crc[2], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffeUL)),
             (int )crc[1], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffdUL)),
             (int )crc[0], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffcUL)));
    } else {

    }
  } else {

  }
#line 482
  return;
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static u32 secmicgetuint32(u8 *p ) 
{ 
  s32 i ;
  u32 res ;
  u8 *tmp ;

  {
#line 491
  res = 0U;
#line 493
  i = 0;
#line 493
  goto ldv_51531;
  ldv_51530: 
#line 495
  tmp = p;
#line 495
  p = p + 1;
#line 495
  res = ((unsigned int )*tmp << i * 8) | res;
#line 493
  i = i + 1;
  ldv_51531: ;
#line 493
  if (i <= 3) {
#line 495
    goto ldv_51530;
  } else {

  }

#line 498
  return (res);
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void secmicputuint32(u8 *p , u32 val ) 
{ 
  long i ;
  u8 *tmp ;

  {
#line 506
  i = 0L;
#line 506
  goto ldv_51539;
  ldv_51538: 
#line 508
  tmp = p;
#line 508
  p = p + 1;
#line 508
  *tmp = (unsigned char )val;
#line 509
  val = val >> 8;
#line 506
  i = i + 1L;
  ldv_51539: ;
#line 506
  if (i <= 3L) {
#line 508
    goto ldv_51538;
  } else {

  }

#line 513
  return;
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void secmicclear(struct mic_data *pmicdata ) 
{ 


  {
#line 518
  pmicdata->L = pmicdata->K0;
#line 519
  pmicdata->R = pmicdata->K1;
#line 520
  pmicdata->nBytesInM = 0U;
#line 521
  pmicdata->M = 0U;
#line 522
  return;
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void rtw_secmicsetkey23a(struct mic_data *pmicdata , u8 *key ) 
{ 


  {
#line 529
  pmicdata->K0 = secmicgetuint32(key);
#line 530
  pmicdata->K1 = secmicgetuint32(key + 4UL);
#line 532
  secmicclear(pmicdata);
#line 533
  return;
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void rtw_secmicappend23abyte23a(struct mic_data *pmicdata , u8 b ) 
{ 


  {
#line 540
  pmicdata->M = pmicdata->M | (u32 )((unsigned long )b << (int )(pmicdata->nBytesInM * 8U));
#line 541
  pmicdata->nBytesInM = pmicdata->nBytesInM + 1U;
#line 543
  if (pmicdata->nBytesInM > 3U) {
#line 545
    pmicdata->L = pmicdata->L ^ pmicdata->M;
#line 546
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 15) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 15UL)));
#line 547
    pmicdata->L = pmicdata->L + pmicdata->R;
#line 548
    pmicdata->R = pmicdata->R ^ (((pmicdata->L & 4278255360U) >> 8) | ((pmicdata->L & 16711935U) << 8));
#line 549
    pmicdata->L = pmicdata->L + pmicdata->R;
#line 550
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 29) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 29UL)));
#line 551
    pmicdata->L = pmicdata->L + pmicdata->R;
#line 552
    pmicdata->R = pmicdata->R ^ ((pmicdata->L >> 2) | (pmicdata->L << (8UL * sizeof(pmicdata->L) - 2UL)));
#line 553
    pmicdata->L = pmicdata->L + pmicdata->R;
#line 555
    pmicdata->M = 0U;
#line 556
    pmicdata->nBytesInM = 0U;
  } else {

  }
#line 558
  return;
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void rtw_secmicappend23a(struct mic_data *pmicdata , u8 *src , u32 nbytes ) 
{ 
  u8 *tmp ;

  {
#line 565
  goto ldv_51558;
  ldv_51557: 
#line 567
  tmp = src;
#line 567
  src = src + 1;
#line 567
  rtw_secmicappend23abyte23a(pmicdata, (int )*tmp);
#line 568
  nbytes = nbytes - 1U;
  ldv_51558: ;
#line 565
  if (nbytes != 0U) {
#line 567
    goto ldv_51557;
  } else {

  }

#line 572
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void rtw_secgetmic23a(struct mic_data *pmicdata , u8 *dst ) 
{ 


  {
#line 577
  rtw_secmicappend23abyte23a(pmicdata, 90);
#line 578
  rtw_secmicappend23abyte23a(pmicdata, 0);
#line 579
  rtw_secmicappend23abyte23a(pmicdata, 0);
#line 580
  rtw_secmicappend23abyte23a(pmicdata, 0);
#line 581
  rtw_secmicappend23abyte23a(pmicdata, 0);
#line 583
  goto ldv_51565;
  ldv_51564: 
#line 585
  rtw_secmicappend23abyte23a(pmicdata, 0);
  ldv_51565: ;
#line 583
  if (pmicdata->nBytesInM != 0U) {
#line 585
    goto ldv_51564;
  } else {

  }
#line 588
  secmicputuint32(dst, pmicdata->L);
#line 589
  secmicputuint32(dst + 4UL, pmicdata->R);
#line 591
  secmicclear(pmicdata);
#line 592
  return;
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void rtw_seccalctkipmic23a(u8 *key , u8 *header , u8 *data , u32 data_len , u8 *mic_code ,
                           u8 pri ) 
{ 
  struct mic_data micdata ;
  u8 priority[4U] ;

  {
#line 599
  priority[0] = 0U;
#line 599
  priority[1] = 0U;
#line 599
  priority[2] = 0U;
#line 599
  priority[3] = 0U;
#line 601
  rtw_secmicsetkey23a(& micdata, key);
#line 602
  priority[0] = pri;
#line 605
  if ((int )*(header + 1UL) & 1) {
#line 606
    rtw_secmicappend23a(& micdata, header + 16UL, 6U);
#line 607
    if (((int )*(header + 1UL) & 2) != 0) {
#line 608
      rtw_secmicappend23a(& micdata, header + 24UL, 6U);
    } else {
#line 610
      rtw_secmicappend23a(& micdata, header + 10UL, 6U);
    }
  } else {
#line 613
    rtw_secmicappend23a(& micdata, header + 4UL, 6U);
#line 614
    if (((int )*(header + 1UL) & 2) != 0) {
#line 615
      rtw_secmicappend23a(& micdata, header + 16UL, 6U);
    } else {
#line 617
      rtw_secmicappend23a(& micdata, header + 10UL, 6U);
    }
  }
#line 620
  rtw_secmicappend23a(& micdata, (u8 *)(& priority), 4U);
#line 622
  rtw_secmicappend23a(& micdata, data, data_len);
#line 624
  rtw_secgetmic23a(& micdata, mic_code);
#line 625
  return;
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static unsigned short const   Sbox1[2U][256U]  = { {        50853U,        63620U,        61081U,        63117U, 
            65293U,        54973U,        57009U,        37204U, 
            24656U,        515U,        52905U,        22141U, 
            59161U,        46434U,        19942U,        60570U, 
            36677U,        8093U,        35136U,        64135U, 
            61205U,        45803U,        36553U,        64267U, 
            16876U,        45927U,        24573U,        17898U, 
            9151U,        21495U,        58518U,        39771U, 
            30146U,        57628U,        15790U,        19562U, 
            27738U,        32321U,        62722U,        33615U, 
            26716U,        20980U,        53556U,        63752U, 
            58003U,        43891U,        25171U,        10815U, 
            2060U,        38226U,        18021U,        40286U, 
            12328U,        14241U,        2575U,        12213U, 
            3593U,        9270U,        7067U,        57149U, 
            52518U,        20073U,        32717U,        60063U, 
            4635U,        7582U,        22644U,        13358U, 
            13869U,        56498U,        46318U,        23547U, 
            42230U,        30285U,        46945U,        32206U, 
            21115U,        56638U,        24177U,        5015U, 
            42741U,        47464U,        0U,        49452U, 
            16480U,        58143U,        31176U,        46829U, 
            54462U,        36166U,        26585U,        29259U, 
            38110U,        39124U,        45288U,        34122U, 
            47979U,        50474U,        20453U,        60694U, 
            34501U,        39639U,        26197U,        4500U, 
            35535U,        59664U,        1030U,        65153U, 
            41200U,        30788U,        9658U,        19427U, 
            41715U,        24062U,        32960U,        1418U, 
            16301U,        8636U,        28744U,        61700U, 
            25567U,        30657U,        44917U,        16995U, 
            8240U,        58650U,        64782U,        49005U, 
            33100U,        6164U,        9781U,        49967U, 
            48865U,        13730U,        35020U,        11833U, 
            37719U,        22002U,        64642U,        31303U, 
            51372U,        47847U,        12843U,        59029U, 
            49312U,        6552U,        40657U,        41855U, 
            17510U,        21630U,        15275U,        2947U, 
            36042U,        50985U,        27603U,        10300U, 
            42873U,        48354U,        5661U,        44406U, 
            56123U,        25686U,        29774U,        5150U, 
            37595U,        3082U,        18540U,        47332U, 
            40797U,        48494U,        17391U,        50342U, 
            14760U,        12708U,        54071U,        62091U, 
            54578U,        35651U,        28249U,        55991U, 
            396U,        45412U,        40146U,        18912U, 
            55476U,        44282U,        62215U,        53029U, 
            51887U,        62606U,        18409U,        4120U, 
            28629U,        61576U,        19055U,        23666U, 
            14372U,        22513U,        29639U,        38737U, 
            52003U,        41340U,        59548U,        15905U, 
            38621U,        25052U,        3462U,        3973U, 
            57488U,        31810U,        29124U,        52394U, 
            37080U,        1541U,        63233U,        7186U, 
            49827U,        27231U,        44793U,        27088U, 
            6033U,        39256U,        14887U,        10169U, 
            55608U,        60179U,        11187U,        8755U, 
            53947U,        43376U,        1929U,        13223U, 
            11702U,        15394U,        5522U,        51488U, 
            34633U,        43775U,        20600U,        42362U, 
            911U,        23032U,        2432U,        6679U, 
            26074U,        55089U,        33990U,        53432U, 
            33475U,        10672U,        23159U,        7697U, 
            31691U,        43260U,        28118U,        11322U}, 
   {        42438U,        34040U,        39406U,        36342U, 
            3583U,        48598U,        45534U,        21649U, 
            20576U,        770U,        43470U,        32086U, 
            6631U,        25269U,        58957U,        39660U, 
            17807U,        40223U,        16521U,        34810U, 
            5615U,        60338U,        51598U,        3067U, 
            60481U,        26547U,        64863U,        59973U, 
            48931U,        63315U,        38628U,        23451U, 
            49781U,        7393U,        44605U,        27212U, 
            23148U,        16766U,        757U,        20355U, 
            23656U,        62545U,        13521U,        2297U, 
            37858U,        29611U,        21346U,        16170U, 
            3080U,        21141U,        25926U,        24221U, 
            10288U,        41271U,        3850U,        46383U, 
            2318U,        13860U,        39707U,        15839U, 
            9933U,        26958U,        52607U,        40938U, 
            6930U,        40477U,        29784U,        11828U, 
            11574U,        45788U,        61108U,        64347U, 
            63140U,        19830U,        25015U,        52861U, 
            31570U,        16093U,        29022U,        38675U, 
            62886U,        26809U,        0U,        11457U, 
            24640U,        8163U,        51321U,        60854U, 
            48852U,        18061U,        55655U,        19314U, 
            56980U,        54424U,        59568U,        19077U, 
            27579U,        10949U,        58703U,        5869U, 
            50566U,        55194U,        21862U,        37905U, 
            53130U,        4329U,        1540U,        33278U, 
            61600U,        17528U,        47653U,        58187U, 
            62370U,        65117U,        49280U,        35333U, 
            44351U,        48161U,        18544U,        1265U, 
            57187U,        49527U,        30127U,        25410U, 
            12320U,        6885U,        3837U,        28095U, 
            19585U,        5144U,        13606U,        12227U, 
            57790U,        41525U,        52360U,        14638U, 
            22419U,        62037U,        33532U,        18298U, 
            44232U,        59322U,        11058U,        38374U, 
            41152U,        38937U,        53662U,        32675U, 
            26180U,        32340U,        43835U,        33547U, 
            51852U,        10695U,        54123U,        15400U, 
            31143U,        58044U,        7446U,        30381U, 
            15323U,        22116U,        20084U,        7700U, 
            56210U,        2572U,        27720U,        58552U, 
            23967U,        28349U,        61251U,        42692U, 
            43065U,        42033U,        14291U,        35826U, 
            13013U,        17291U,        22894U,        47066U, 
            35841U,        25777U,        53916U,        57417U, 
            46296U,        64172U,        2035U,        9679U, 
            45002U,        36596U,        59719U,        6160U, 
            54639U,        35056U,        28490U,        29276U, 
            9272U,        61783U,        51059U,        20887U, 
            9163U,        31905U,        40168U,        8510U, 
            56726U,        56417U,        34317U,        34063U, 
            37088U,        17020U,        50289U,        43724U, 
            55440U,        1286U,        503U,        4636U, 
            41922U,        24426U,        63918U,        53353U, 
            37143U,        22681U,        10042U,        47399U, 
            14553U,        5099U,        45867U,        13090U, 
            48082U,        28841U,        35079U,        42803U, 
            46637U,        8764U,        37397U,        8393U, 
            18823U,        65450U,        30800U,        31397U, 
            36611U,        63577U,        32777U,        5914U, 
            55909U,        12759U,        50820U,        47312U, 
            50050U,        45097U,        30554U,        4382U, 
            52091U,        64680U,        54893U,        14892U}};
#line 739 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void phase1(u16 *p1k , u8 const   *tk , u8 const   *ta , u32 iv32 ) 
{ 
  int i ;

  {
#line 744
  *p1k = (unsigned short )iv32;
#line 745
  *(p1k + 1UL) = (unsigned short )(iv32 >> 16);
#line 746
  *(p1k + 2UL) = (u16 )((int )((short )*ta) ^ (int )((short )((int )*(ta + 1UL) << 8)));
#line 747
  *(p1k + 3UL) = (u16 )((int )((short )*(ta + 2UL)) ^ (int )((short )((int )*(ta + 3UL) << 8)));
#line 748
  *(p1k + 4UL) = (u16 )((int )((short )*(ta + 4UL)) ^ (int )((short )((int )*(ta + 5UL) << 8)));
#line 752
  i = 0;
#line 752
  goto ldv_51586;
  ldv_51585: 
#line 754
  *p1k = (int )*p1k + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 4UL)) ^ ((int )((signed char )*(tk + (unsigned long )((i & 1) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 4UL) ^ ((int )*(tk + (unsigned long )((i & 1) * 2)) ^ ((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8))) >> 8))])));
#line 755
  *(p1k + 1UL) = (int )*(p1k + 1UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*p1k) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 2) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 2) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*p1k ^ ((int )*(tk + (unsigned long )(((i & 1) + 2) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 2) * 2) + 1UL)) << 8))) >> 8))])));
#line 756
  *(p1k + 2UL) = (int )*(p1k + 2UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 1UL)) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 4) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 4) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 1UL) ^ ((int )*(tk + (unsigned long )(((i & 1) + 4) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 4) * 2) + 1UL)) << 8))) >> 8))])));
#line 757
  *(p1k + 3UL) = (int )*(p1k + 3UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 2UL)) ^ ((int )((signed char )*(tk + (unsigned long )(((i & 1) + 6) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )(((i & 1) + 6) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 2UL) ^ ((int )*(tk + (unsigned long )(((i & 1) + 6) * 2)) ^ ((int )*(tk + ((unsigned long )(((i & 1) + 6) * 2) + 1UL)) << 8))) >> 8))])));
#line 758
  *(p1k + 4UL) = (int )*(p1k + 4UL) + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )*(p1k + 3UL)) ^ ((int )((signed char )*(tk + (unsigned long )((i & 1) * 2))) ^ (int )((signed char )((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )*(p1k + 3UL) ^ ((int )*(tk + (unsigned long )((i & 1) * 2)) ^ ((int )*(tk + ((unsigned long )((i & 1) * 2) + 1UL)) << 8))) >> 8))])));
#line 759
  *(p1k + 4UL) = (int )*(p1k + 4UL) + (int )((u16 )i);
#line 752
  i = i + 1;
  ldv_51586: ;
#line 752
  if (i <= 7) {
#line 754
    goto ldv_51585;
  } else {

  }

#line 759
  return;
}
}
#line 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void phase2(u8 *rc4key , u8 const   *tk , u16 const   *p1k , u16 iv16 ) 
{ 
  int i ;
  u16 PPK[6U] ;

  {
#line 793
  i = 0;
#line 793
  goto ldv_51597;
  ldv_51596: 
#line 793
  PPK[i] = *(p1k + (unsigned long )i);
#line 793
  i = i + 1;
  ldv_51597: ;
#line 793
  if (i <= 4) {
#line 795
    goto ldv_51596;
  } else {

  }
#line 794
  PPK[5] = (int )((u16 )*(p1k + 4UL)) + (int )iv16;
#line 797
  PPK[0] = (int )PPK[0] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[5]) ^ ((int )((signed char )*tk) ^ (int )((signed char )((int )*(tk + 1UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[5] ^ ((int )*tk ^ ((int )*(tk + 1UL) << 8))) >> 8))])));
#line 798
  PPK[1] = (int )PPK[1] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[0]) ^ ((int )((signed char )*(tk + 2UL)) ^ (int )((signed char )((int )*(tk + 3UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[0] ^ ((int )*(tk + 2UL) ^ ((int )*(tk + 3UL) << 8))) >> 8))])));
#line 799
  PPK[2] = (int )PPK[2] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[1]) ^ ((int )((signed char )*(tk + 4UL)) ^ (int )((signed char )((int )*(tk + 5UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[1] ^ ((int )*(tk + 4UL) ^ ((int )*(tk + 5UL) << 8))) >> 8))])));
#line 800
  PPK[3] = (int )PPK[3] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[2]) ^ ((int )((signed char )*(tk + 6UL)) ^ (int )((signed char )((int )*(tk + 7UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[2] ^ ((int )*(tk + 6UL) ^ ((int )*(tk + 7UL) << 8))) >> 8))])));
#line 801
  PPK[4] = (int )PPK[4] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[3]) ^ ((int )((signed char )*(tk + 8UL)) ^ (int )((signed char )((int )*(tk + 9UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[3] ^ ((int )*(tk + 8UL) ^ ((int )*(tk + 9UL) << 8))) >> 8))])));
#line 802
  PPK[5] = (int )PPK[5] + (int )((u16 )((int )((unsigned short )Sbox1[0][(int )((unsigned char )((int )((signed char )PPK[4]) ^ ((int )((signed char )*(tk + 10UL)) ^ (int )((signed char )((int )*(tk + 11UL) << 8)))))]) ^ (int )((unsigned short )Sbox1[1][(int )((unsigned char )(((int )PPK[4] ^ ((int )*(tk + 10UL) ^ ((int )*(tk + 11UL) << 8))) >> 8))])));
#line 805
  PPK[0] = (int )PPK[0] + (int )((u16 )(((int )((short )(((int )PPK[5] ^ ((int )*(tk + 12UL) ^ ((int )*(tk + 13UL) << 8))) >> 1)) & 32767) ^ (int )((short )(((int )PPK[5] ^ ((int )*(tk + 12UL) ^ ((int )*(tk + 13UL) << 8))) << 15))));
#line 806
  PPK[1] = (int )PPK[1] + (int )((u16 )(((int )((short )(((int )PPK[0] ^ ((int )*(tk + 14UL) ^ ((int )*(tk + 15UL) << 8))) >> 1)) & 32767) ^ (int )((short )(((int )PPK[0] ^ ((int )*(tk + 14UL) ^ ((int )*(tk + 15UL) << 8))) << 15))));
#line 807
  PPK[2] = (int )PPK[2] + (int )((u16 )((int )((short )((int )PPK[1] >> 1)) ^ (int )((short )((int )PPK[1] << 15))));
#line 808
  PPK[3] = (int )PPK[3] + (int )((u16 )((int )((short )((int )PPK[2] >> 1)) ^ (int )((short )((int )PPK[2] << 15))));
#line 809
  PPK[4] = (int )PPK[4] + (int )((u16 )((int )((short )((int )PPK[3] >> 1)) ^ (int )((short )((int )PPK[3] << 15))));
#line 810
  PPK[5] = (int )PPK[5] + (int )((u16 )((int )((short )((int )PPK[4] >> 1)) ^ (int )((short )((int )PPK[4] << 15))));
#line 817
  *rc4key = (unsigned char )((int )iv16 >> 8);
#line 818
  *(rc4key + 1UL) = ((unsigned int )((u8 )((int )iv16 >> 8)) & 95U) | 32U;
#line 819
  *(rc4key + 2UL) = (unsigned char )iv16;
#line 820
  *(rc4key + 3UL) = (unsigned char )(((int )PPK[5] ^ ((int )*tk ^ ((int )*(tk + 1UL) << 8))) >> 1);
#line 823
  i = 0;
#line 823
  goto ldv_51600;
  ldv_51599: 
#line 825
  *(rc4key + (unsigned long )((i + 2) * 2)) = (unsigned char )PPK[i];
#line 826
  *(rc4key + (unsigned long )(i * 2 + 5)) = (unsigned char )((int )PPK[i] >> 8);
#line 823
  i = i + 1;
  ldv_51600: ;
#line 823
  if (i <= 5) {
#line 825
    goto ldv_51599;
  } else {

  }

#line 830
  return;
}
}
#line 832 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
int rtw_tkip_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  u16 pnl ;
  u32 pnh ;
  u8 rc4key[16U] ;
  u8 ttkey[16U] ;
  u8 crc[4U] ;
  u8 hw_hdr_offset ;
  struct arc4context mycontext ;
  int curfragnum ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 *prwskey ;
  union pn48 dot11txpn ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  bool tmp ;

  {
#line 840
  hw_hdr_offset = 0U;
#line 847
  pattrib = & pxmitframe->attrib;
#line 848
  psecuritypriv = & padapter->securitypriv;
#line 849
  pxmitpriv = & padapter->xmitpriv;
#line 850
  res = 1;
#line 852
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
#line 853
    return (0);
  } else {

  }
#line 855
  hw_hdr_offset = 40U;
#line 857
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
#line 859
  if (pattrib->encrypt == 1027074U) {
#line 860
    if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 861
      stainfo = pattrib->psta;
    } else {
#line 863
      if (GlobalDebugLevel23A > 3U) {
#line 863
        printk("\016RTL8723AU: %s, call rtw_get_stainfo()\n", "rtw_tkip_encrypt23a");
      } else {

      }
#line 864
      stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
    }
#line 868
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
#line 870
      if ((stainfo->state & 1U) == 0U) {
#line 872
        if (GlobalDebugLevel23A > 3U) {
#line 872
          printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_tkip_encrypt23a",
                 stainfo->state);
        } else {

        }
#line 873
        return (0);
      } else {

      }
#line 876
      if (GlobalDebugLevel23A > 3U) {
#line 876
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 876
        printk("\016rtw_tkip_encrypt23a: stainfo!= NULL!!!\n");
      } else {

      }
#line 878
      tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 878
      if ((int )tmp) {
#line 879
        prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey);
      } else {
#line 881
        prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
      }
#line 883
      prwskeylen = 16U;
#line 885
      curfragnum = 0;
#line 885
      goto ldv_51628;
      ldv_51627: 
#line 886
      iv = pframe + (unsigned long )pattrib->hdrlen;
#line 887
      payload = pframe + ((unsigned long )pattrib->iv_len + (unsigned long )pattrib->hdrlen);
#line 889
      dot11txpn._byte_.TSC0 = *(iv + 2UL);
#line 889
      dot11txpn._byte_.TSC1 = *iv;
#line 889
      dot11txpn._byte_.TSC2 = *(iv + 4UL);
#line 889
      dot11txpn._byte_.TSC3 = *(iv + 5UL);
#line 889
      dot11txpn._byte_.TSC4 = *(iv + 6UL);
#line 889
      dot11txpn._byte_.TSC5 = *(iv + 7UL);
#line 891
      pnl = (unsigned short )dot11txpn.val;
#line 892
      pnh = (unsigned int )(dot11txpn.val >> 16);
#line 894
      phase1((u16 *)(& ttkey), (u8 const   *)prwskey, (u8 const   *)(& pattrib->ta),
             pnh);
#line 896
      phase2((u8 *)(& rc4key), (u8 const   *)prwskey, (u16 const   *)(& ttkey), (int )pnl);
#line 898
      if (curfragnum + 1 == (int )pattrib->nr_frags) {
#line 899
        length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
#line 900
        if (GlobalDebugLevel23A > 6U) {
#line 900
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 7);
#line 900
          printk("\016pattrib->iv_len =%x, pattrib->icv_len =%x\n", (int )pattrib->iv_len,
                 (int )pattrib->icv_len);
        } else {

        }
#line 901
        *((u32 *)(& crc)) = getcrc32(payload, length);
#line 903
        arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
#line 904
        arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 905
        arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                        4U);
      } else {
#line 909
        length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
#line 910
        *((u32 *)(& crc)) = getcrc32(payload, length);
#line 911
        arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
#line 912
        arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 913
        arcfour_encrypt(& mycontext, payload + (unsigned long )length, (u8 *)(& crc),
                        4U);
#line 915
        pframe = pframe + (unsigned long )pxmitpriv->frag_len;
#line 916
        pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
      }
#line 885
      curfragnum = curfragnum + 1;
      ldv_51628: ;
#line 885
      if ((int )pattrib->nr_frags > curfragnum) {
#line 887
        goto ldv_51627;
      } else {

      }

    } else {
#line 922
      if (GlobalDebugLevel23A > 3U) {
#line 922
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 922
        printk("\016rtw_tkip_encrypt23a: stainfo == NULL!!!\n");
      } else {

      }
#line 923
      if (GlobalDebugLevel23A > 3U) {
#line 923
        printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_tkip_encrypt23a");
      } else {

      }
#line 924
      res = 0;
    }
  } else {

  }
#line 929
  return (res);
}
}
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
int rtw_tkip_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) 
{ 
  u16 pnl ;
  u32 pnh ;
  u8 rc4key[16U] ;
  u8 ttkey[16U] ;
  u8 crc[4U] ;
  struct arc4context mycontext ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *payload ;
  u8 *iv ;
  u8 *prwskey ;
  union pn48 dot11txpn ;
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  int res ;
  bool tmp ;

  {
#line 947
  prxattrib = & precvframe->attrib;
#line 948
  psecuritypriv = & padapter->securitypriv;
#line 949
  skb = precvframe->pkt;
#line 950
  res = 1;
#line 952
  pframe = skb->data;
#line 955
  if (prxattrib->encrypt == 1027074U) {
#line 957
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& prxattrib->ta));
#line 959
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
#line 961
      tmp = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 961
      if ((int )tmp) {
#line 962
        if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
#line 963
          res = 0;
#line 964
          if (GlobalDebugLevel23A > 3U) {
#line 964
            printk("\016RTL8723AU: %s:rx bc/mc packets, but didn\'t install group key!!!!!!!!!!\n",
                   "rtw_tkip_decrypt23a");
          } else {

          }
#line 965
          goto exit;
        } else {

        }
#line 967
        prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[(int )prxattrib->key_index].skey);
#line 968
        prwskeylen = 16U;
      } else {
#line 970
        if (GlobalDebugLevel23A > 3U) {
#line 970
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 970
          printk("\016rtw_tkip_decrypt23a: stainfo!= NULL!!!\n");
        } else {

        }
#line 971
        prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
#line 972
        prwskeylen = 16U;
      }
#line 975
      iv = pframe + (unsigned long )prxattrib->hdrlen;
#line 976
      payload = pframe + ((unsigned long )prxattrib->iv_len + (unsigned long )prxattrib->hdrlen);
#line 977
      length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
#line 979
      dot11txpn._byte_.TSC0 = *(iv + 2UL);
#line 979
      dot11txpn._byte_.TSC1 = *iv;
#line 979
      dot11txpn._byte_.TSC2 = *(iv + 4UL);
#line 979
      dot11txpn._byte_.TSC3 = *(iv + 5UL);
#line 979
      dot11txpn._byte_.TSC4 = *(iv + 6UL);
#line 979
      dot11txpn._byte_.TSC5 = *(iv + 7UL);
#line 981
      pnl = (unsigned short )dot11txpn.val;
#line 982
      pnh = (unsigned int )(dot11txpn.val >> 16);
#line 984
      phase1((u16 *)(& ttkey), (u8 const   *)prwskey, (u8 const   *)(& prxattrib->ta),
             pnh);
#line 985
      phase2((u8 *)(& rc4key), (u8 const   *)prwskey, (u16 const   *)(& ttkey), (int )pnl);
#line 988
      arcfour_init(& mycontext, (u8 *)(& rc4key), 16U);
#line 989
      arcfour_encrypt(& mycontext, payload, payload, (u32 )length);
#line 991
      *((u32 *)(& crc)) = getcrc32(payload, length + -4);
#line 993
      if ((((int )crc[3] != (int )*(payload + ((unsigned long )length + 0xffffffffffffffffUL)) || (int )crc[2] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffeUL))) || (int )crc[1] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffdUL))) || (int )crc[0] != (int )*(payload + ((unsigned long )length + 0xfffffffffffffffcUL))) {
#line 995
        if (GlobalDebugLevel23A > 3U) {
#line 995
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 995
          printk("\016rtw_wep_decrypt23a:icv error crc[3](%x)!= payload[length-1](%x) || crc[2](%x)!= payload[length-2](%x) || crc[1](%x)!= payload[length-3](%x) || crc[0](%x)!= payload[length-4](%x)\n",
                 (int )crc[3], (int )*(payload + ((unsigned long )length + 0xffffffffffffffffUL)),
                 (int )crc[2], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffeUL)),
                 (int )crc[1], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffdUL)),
                 (int )crc[0], (int )*(payload + ((unsigned long )length + 0xfffffffffffffffcUL)));
        } else {

        }
#line 997
        res = 0;
      } else {

      }
    } else {
#line 1000
      if (GlobalDebugLevel23A > 3U) {
#line 1000
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 1000
        printk("\016rtw_tkip_decrypt23a: stainfo == NULL!!!\n");
      } else {

      }
#line 1001
      res = 0;
    }
  } else {

  }
  exit: ;
#line 1005
  return (res);
}
}
#line 1015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static u8 sbox_table[256U]  = 
#line 1015
  {      99U,      124U,      119U,      123U, 
        242U,      107U,      111U,      197U, 
        48U,      1U,      103U,      43U, 
        254U,      215U,      171U,      118U, 
        202U,      130U,      201U,      125U, 
        250U,      89U,      71U,      240U, 
        173U,      212U,      162U,      175U, 
        156U,      164U,      114U,      192U, 
        183U,      253U,      147U,      38U, 
        54U,      63U,      247U,      204U, 
        52U,      165U,      229U,      241U, 
        113U,      216U,      49U,      21U, 
        4U,      199U,      35U,      195U, 
        24U,      150U,      5U,      154U, 
        7U,      18U,      128U,      226U, 
        235U,      39U,      178U,      117U, 
        9U,      131U,      44U,      26U, 
        27U,      110U,      90U,      160U, 
        82U,      59U,      214U,      179U, 
        41U,      227U,      47U,      132U, 
        83U,      209U,      0U,      237U, 
        32U,      252U,      177U,      91U, 
        106U,      203U,      190U,      57U, 
        74U,      76U,      88U,      207U, 
        208U,      239U,      170U,      251U, 
        67U,      77U,      51U,      133U, 
        69U,      249U,      2U,      127U, 
        80U,      60U,      159U,      168U, 
        81U,      163U,      64U,      143U, 
        146U,      157U,      56U,      245U, 
        188U,      182U,      218U,      33U, 
        16U,      255U,      243U,      210U, 
        205U,      12U,      19U,      236U, 
        95U,      151U,      68U,      23U, 
        196U,      167U,      126U,      61U, 
        100U,      93U,      25U,      115U, 
        96U,      129U,      79U,      220U, 
        34U,      42U,      144U,      136U, 
        70U,      238U,      184U,      20U, 
        222U,      94U,      11U,      219U, 
        224U,      50U,      58U,      10U, 
        73U,      6U,      36U,      92U, 
        194U,      211U,      172U,      98U, 
        145U,      149U,      228U,      121U, 
        231U,      200U,      55U,      109U, 
        141U,      213U,      78U,      169U, 
        108U,      86U,      244U,      234U, 
        101U,      122U,      174U,      8U, 
        186U,      120U,      37U,      46U, 
        28U,      166U,      180U,      198U, 
        232U,      221U,      116U,      31U, 
        75U,      189U,      139U,      138U, 
        112U,      62U,      181U,      102U, 
        72U,      3U,      246U,      14U, 
        97U,      53U,      87U,      185U, 
        134U,      193U,      29U,      158U, 
        225U,      248U,      152U,      17U, 
        105U,      217U,      142U,      148U, 
        155U,      30U,      135U,      233U, 
        206U,      85U,      40U,      223U, 
        140U,      161U,      137U,      13U, 
        191U,      230U,      66U,      104U, 
        65U,      153U,      45U,      15U, 
        176U,      84U,      187U,      22U};
#line 1054
static void construct_mic_header2(u8 *mic_header2 , u8 *mpdu , int a4_exists , int qc_exists ) ;
#line 1057 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void xor_128(u8 *a , u8 *b , u8 *out ) 
{ 
  int i ;

  {
#line 1061
  i = 0;
#line 1061
  goto ldv_51667;
  ldv_51666: 
#line 1062
  *(out + (unsigned long )i) = (u8 )((int )*(a + (unsigned long )i) ^ (int )*(b + (unsigned long )i));
#line 1061
  i = i + 1;
  ldv_51667: ;
#line 1061
  if (i <= 15) {
#line 1063
    goto ldv_51666;
  } else {

  }

#line 1068
  return;
}
}
#line 1065 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void xor_32(u8 *a , u8 *b , u8 *out ) 
{ 
  int i ;

  {
#line 1069
  i = 0;
#line 1069
  goto ldv_51676;
  ldv_51675: 
#line 1070
  *(out + (unsigned long )i) = (u8 )((int )*(a + (unsigned long )i) ^ (int )*(b + (unsigned long )i));
#line 1069
  i = i + 1;
  ldv_51676: ;
#line 1069
  if (i <= 3) {
#line 1071
    goto ldv_51675;
  } else {

  }

#line 1076
  return;
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static u8 sbox(u8 a ) 
{ 


  {
#line 1075
  return (sbox_table[(int )a]);
}
}
#line 1078 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void next_key(u8 *key , int round ) 
{ 
  u8 rcon___0 ;
  u8 sbox_key[4U] ;
  u8 rcon_table[12U] ;

  {
#line 1082
  rcon_table[0] = 1U;
#line 1082
  rcon_table[1] = 2U;
#line 1082
  rcon_table[2] = 4U;
#line 1082
  rcon_table[3] = 8U;
#line 1082
  rcon_table[4] = 16U;
#line 1082
  rcon_table[5] = 32U;
#line 1082
  rcon_table[6] = 64U;
#line 1082
  rcon_table[7] = 128U;
#line 1082
  rcon_table[8] = 27U;
#line 1082
  rcon_table[9] = 54U;
#line 1082
  rcon_table[10] = 54U;
#line 1082
  rcon_table[11] = 54U;
#line 1088
  sbox_key[0] = sbox((int )*(key + 13UL));
#line 1089
  sbox_key[1] = sbox((int )*(key + 14UL));
#line 1090
  sbox_key[2] = sbox((int )*(key + 15UL));
#line 1091
  sbox_key[3] = sbox((int )*(key + 12UL));
#line 1093
  rcon___0 = rcon_table[round];
#line 1095
  xor_32(key, (u8 *)(& sbox_key), key);
#line 1096
  *key = (u8 )((int )*key ^ (int )rcon___0);
#line 1098
  xor_32(key + 4UL, key, key + 4UL);
#line 1099
  xor_32(key + 8UL, key + 4UL, key + 8UL);
#line 1100
  xor_32(key + 12UL, key + 8UL, key + 12UL);
#line 1101
  return;
}
}
#line 1104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void byte_sub(u8 *in , u8 *out ) 
{ 
  int i ;

  {
#line 1108
  i = 0;
#line 1108
  goto ldv_51694;
  ldv_51693: 
#line 1110
  *(out + (unsigned long )i) = sbox((int )*(in + (unsigned long )i));
#line 1108
  i = i + 1;
  ldv_51694: ;
#line 1108
  if (i <= 15) {
#line 1110
    goto ldv_51693;
  } else {

  }

#line 1115
  return;
}
}
#line 1115 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void shift_row(u8 *in , u8 *out ) 
{ 


  {
#line 1118
  *out = *in;
#line 1119
  *(out + 1UL) = *(in + 5UL);
#line 1120
  *(out + 2UL) = *(in + 10UL);
#line 1121
  *(out + 3UL) = *(in + 15UL);
#line 1122
  *(out + 4UL) = *(in + 4UL);
#line 1123
  *(out + 5UL) = *(in + 9UL);
#line 1124
  *(out + 6UL) = *(in + 14UL);
#line 1125
  *(out + 7UL) = *(in + 3UL);
#line 1126
  *(out + 8UL) = *(in + 8UL);
#line 1127
  *(out + 9UL) = *(in + 13UL);
#line 1128
  *(out + 10UL) = *(in + 2UL);
#line 1129
  *(out + 11UL) = *(in + 7UL);
#line 1130
  *(out + 12UL) = *(in + 12UL);
#line 1131
  *(out + 13UL) = *(in + 1UL);
#line 1132
  *(out + 14UL) = *(in + 6UL);
#line 1133
  *(out + 15UL) = *(in + 11UL);
#line 1134
  return;
}
}
#line 1137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void mix_column(u8 *in , u8 *out ) 
{ 
  int i ;
  u8 add1b[4U] ;
  u8 add1bf7[4U] ;
  u8 rotl[4U] ;
  u8 swap_halfs[4U] ;
  u8 andf7[4U] ;
  u8 rotr___0[4U] ;
  u8 temp[4U] ;
  u8 tempb[4U] ;

  {
#line 1149
  i = 0;
#line 1149
  goto ldv_51714;
  ldv_51713: ;
#line 1151
  if ((int )((signed char )*(in + (unsigned long )i)) < 0) {
#line 1152
    add1b[i] = 27U;
  } else {
#line 1154
    add1b[i] = 0U;
  }
#line 1149
  i = i + 1;
  ldv_51714: ;
#line 1149
  if (i <= 3) {
#line 1151
    goto ldv_51713;
  } else {

  }
#line 1157
  swap_halfs[0] = *(in + 2UL);
#line 1158
  swap_halfs[1] = *(in + 3UL);
#line 1159
  swap_halfs[2] = *in;
#line 1160
  swap_halfs[3] = *(in + 1UL);
#line 1162
  rotl[0] = *(in + 3UL);
#line 1163
  rotl[1] = *in;
#line 1164
  rotl[2] = *(in + 1UL);
#line 1165
  rotl[3] = *(in + 2UL);
#line 1167
  andf7[0] = (unsigned int )*in & 127U;
#line 1168
  andf7[1] = (unsigned int )*(in + 1UL) & 127U;
#line 1169
  andf7[2] = (unsigned int )*(in + 2UL) & 127U;
#line 1170
  andf7[3] = (unsigned int )*(in + 3UL) & 127U;
#line 1172
  i = 3;
#line 1172
  goto ldv_51717;
  ldv_51716: 
#line 1174
  andf7[i] = (int )andf7[i] << 1U;
#line 1175
  if ((int )((signed char )andf7[i + -1]) < 0) {
#line 1177
    andf7[i] = (u8 )((unsigned int )andf7[i] | 1U);
  } else {

  }
#line 1172
  i = i - 1;
  ldv_51717: ;
#line 1172
  if (i > 0) {
#line 1174
    goto ldv_51716;
  } else {

  }
#line 1180
  andf7[0] = (int )andf7[0] << 1U;
#line 1181
  andf7[0] = (unsigned int )andf7[0] & 254U;
#line 1183
  xor_32((u8 *)(& add1b), (u8 *)(& andf7), (u8 *)(& add1bf7));
#line 1185
  xor_32(in, (u8 *)(& add1bf7), (u8 *)(& rotr___0));
#line 1187
  temp[0] = rotr___0[0];
#line 1188
  rotr___0[0] = rotr___0[1];
#line 1189
  rotr___0[1] = rotr___0[2];
#line 1190
  rotr___0[2] = rotr___0[3];
#line 1191
  rotr___0[3] = temp[0];
#line 1193
  xor_32((u8 *)(& add1bf7), (u8 *)(& rotr___0), (u8 *)(& temp));
#line 1194
  xor_32((u8 *)(& swap_halfs), (u8 *)(& rotl), (u8 *)(& tempb));
#line 1195
  xor_32((u8 *)(& temp), (u8 *)(& tempb), out);
#line 1196
  return;
}
}
#line 1199 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void aes128k128d(u8 *key , u8 *data , u8 *ciphertext ) 
{ 
  int round ;
  int i ;
  u8 intermediatea[16U] ;
  u8 intermediateb[16U] ;
  u8 round_key[16U] ;

  {
#line 1207
  i = 0;
#line 1207
  goto ldv_51730;
  ldv_51729: 
#line 1207
  round_key[i] = *(key + (unsigned long )i);
#line 1207
  i = i + 1;
  ldv_51730: ;
#line 1207
  if (i <= 15) {
#line 1209
    goto ldv_51729;
  } else {

  }
#line 1209
  round = 0;
#line 1209
  goto ldv_51733;
  ldv_51732: ;
#line 1211
  if (round == 0) {
#line 1213
    xor_128((u8 *)(& round_key), data, ciphertext);
#line 1214
    next_key((u8 *)(& round_key), round);
  } else
#line 1216
  if (round == 10) {
#line 1218
    byte_sub(ciphertext, (u8 *)(& intermediatea));
#line 1219
    shift_row((u8 *)(& intermediatea), (u8 *)(& intermediateb));
#line 1220
    xor_128((u8 *)(& intermediateb), (u8 *)(& round_key), ciphertext);
  } else {
#line 1224
    byte_sub(ciphertext, (u8 *)(& intermediatea));
#line 1225
    shift_row((u8 *)(& intermediatea), (u8 *)(& intermediateb));
#line 1226
    mix_column((u8 *)(& intermediateb), (u8 *)(& intermediatea));
#line 1227
    mix_column((u8 *)(& intermediateb) + 4UL, (u8 *)(& intermediatea) + 4UL);
#line 1228
    mix_column((u8 *)(& intermediateb) + 8UL, (u8 *)(& intermediatea) + 8UL);
#line 1229
    mix_column((u8 *)(& intermediateb) + 12UL, (u8 *)(& intermediatea) + 12UL);
#line 1230
    xor_128((u8 *)(& intermediatea), (u8 *)(& round_key), ciphertext);
#line 1231
    next_key((u8 *)(& round_key), round);
  }
#line 1209
  round = round + 1;
  ldv_51733: ;
#line 1209
  if (round <= 10) {
#line 1211
    goto ldv_51732;
  } else {

  }

#line 1216
  return;
}
}
#line 1241 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void construct_mic_iv(u8 *mic_iv , int qc_exists , int a4_exists , u8 *mpdu ,
                             uint payload_length , u8 *pn_vector ) 
{ 
  int i ;

  {
#line 1246
  *mic_iv = 89U;
#line 1247
  if (qc_exists != 0 && a4_exists != 0) {
#line 1248
    *(mic_iv + 1UL) = (unsigned int )*(mpdu + 30UL) & 15U;
  } else {

  }
#line 1249
  if (qc_exists != 0 && a4_exists == 0) {
#line 1250
    *(mic_iv + 1UL) = (unsigned int )*(mpdu + 24UL) & 15U;
  } else {

  }
#line 1251
  if (qc_exists == 0) {
#line 1252
    *(mic_iv + 1UL) = 0U;
  } else {

  }
#line 1253
  i = 2;
#line 1253
  goto ldv_51745;
  ldv_51744: 
#line 1254
  *(mic_iv + (unsigned long )i) = *(mpdu + ((unsigned long )i + 8UL));
#line 1253
  i = i + 1;
  ldv_51745: ;
#line 1253
  if (i <= 7) {
#line 1255
    goto ldv_51744;
  } else {

  }
#line 1255
  i = 8;
#line 1255
  goto ldv_51748;
  ldv_51747: 
#line 1256
  *(mic_iv + (unsigned long )i) = *(pn_vector + (unsigned long )(13 - i));
#line 1255
  i = i + 1;
  ldv_51748: ;
#line 1255
  if (i <= 13) {
#line 1257
    goto ldv_51747;
  } else {

  }
#line 1257
  *(mic_iv + 14UL) = (unsigned char )(payload_length / 256U);
#line 1258
  *(mic_iv + 15UL) = (unsigned char )payload_length;
#line 1259
  return;
}
}
#line 1266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void construct_mic_header1(u8 *mic_header1 , int header_length , u8 *mpdu ) 
{ 


  {
#line 1268
  *mic_header1 = (unsigned char )((header_length + -2) / 256);
#line 1269
  *(mic_header1 + 1UL) = (unsigned char )((header_length + -2) % 256);
#line 1270
  *(mic_header1 + 2UL) = (unsigned int )*mpdu & 207U;
#line 1271
  *(mic_header1 + 3UL) = (unsigned int )*(mpdu + 1UL) & 199U;
#line 1272
  *(mic_header1 + 4UL) = *(mpdu + 4UL);
#line 1273
  *(mic_header1 + 5UL) = *(mpdu + 5UL);
#line 1274
  *(mic_header1 + 6UL) = *(mpdu + 6UL);
#line 1275
  *(mic_header1 + 7UL) = *(mpdu + 7UL);
#line 1276
  *(mic_header1 + 8UL) = *(mpdu + 8UL);
#line 1277
  *(mic_header1 + 9UL) = *(mpdu + 9UL);
#line 1278
  *(mic_header1 + 10UL) = *(mpdu + 10UL);
#line 1279
  *(mic_header1 + 11UL) = *(mpdu + 11UL);
#line 1280
  *(mic_header1 + 12UL) = *(mpdu + 12UL);
#line 1281
  *(mic_header1 + 13UL) = *(mpdu + 13UL);
#line 1282
  *(mic_header1 + 14UL) = *(mpdu + 14UL);
#line 1283
  *(mic_header1 + 15UL) = *(mpdu + 15UL);
#line 1284
  return;
}
}
#line 1292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void construct_mic_header2(u8 *mic_header2 , u8 *mpdu , int a4_exists , int qc_exists ) 
{ 
  int i ;

  {
#line 1301
  i = 0;
#line 1301
  goto ldv_51763;
  ldv_51762: 
#line 1301
  *(mic_header2 + (unsigned long )i) = 0U;
#line 1301
  i = i + 1;
  ldv_51763: ;
#line 1301
  if (i <= 15) {
#line 1303
    goto ldv_51762;
  } else {

  }
#line 1303
  *mic_header2 = *(mpdu + 16UL);
#line 1304
  *(mic_header2 + 1UL) = *(mpdu + 17UL);
#line 1305
  *(mic_header2 + 2UL) = *(mpdu + 18UL);
#line 1306
  *(mic_header2 + 3UL) = *(mpdu + 19UL);
#line 1307
  *(mic_header2 + 4UL) = *(mpdu + 20UL);
#line 1308
  *(mic_header2 + 5UL) = *(mpdu + 21UL);
#line 1310
  *(mic_header2 + 6UL) = 0U;
#line 1311
  *(mic_header2 + 7UL) = 0U;
#line 1313
  if (qc_exists == 0 && a4_exists != 0) {
#line 1315
    i = 0;
#line 1315
    goto ldv_51766;
    ldv_51765: 
#line 1315
    *(mic_header2 + (unsigned long )(i + 8)) = *(mpdu + (unsigned long )(i + 24));
#line 1315
    i = i + 1;
    ldv_51766: ;
#line 1315
    if (i <= 5) {
#line 1317
      goto ldv_51765;
    } else {

    }

  } else {

  }
#line 1319
  if (qc_exists != 0 && a4_exists == 0) {
#line 1321
    *(mic_header2 + 8UL) = (unsigned int )*(mpdu + 24UL) & 15U;
#line 1322
    *(mic_header2 + 9UL) = 0U;
  } else {

  }
#line 1325
  if (qc_exists != 0 && a4_exists != 0) {
#line 1327
    i = 0;
#line 1327
    goto ldv_51769;
    ldv_51768: 
#line 1327
    *(mic_header2 + (unsigned long )(i + 8)) = *(mpdu + (unsigned long )(i + 24));
#line 1327
    i = i + 1;
    ldv_51769: ;
#line 1327
    if (i <= 5) {
#line 1329
      goto ldv_51768;
    } else {

    }
#line 1329
    *(mic_header2 + 14UL) = (unsigned int )*(mpdu + 30UL) & 15U;
#line 1330
    *(mic_header2 + 15UL) = 0U;
  } else {

  }
#line 1332
  return;
}
}
#line 1340 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void construct_ctr_preload(u8 *ctr_preload , int a4_exists , int qc_exists ,
                                  u8 *mpdu , u8 *pn_vector , int c ) 
{ 
  int i ;

  {
#line 1343
  i = 0;
#line 1345
  i = 0;
#line 1345
  goto ldv_51781;
  ldv_51780: 
#line 1345
  *(ctr_preload + (unsigned long )i) = 0U;
#line 1345
  i = i + 1;
  ldv_51781: ;
#line 1345
  if (i <= 15) {
#line 1347
    goto ldv_51780;
  } else {

  }
#line 1346
  i = 0;
#line 1348
  *ctr_preload = 1U;
#line 1349
  if (qc_exists != 0 && a4_exists != 0) {
#line 1350
    *(ctr_preload + 1UL) = (unsigned int )*(mpdu + 30UL) & 15U;
  } else {

  }
#line 1351
  if (qc_exists != 0 && a4_exists == 0) {
#line 1352
    *(ctr_preload + 1UL) = (unsigned int )*(mpdu + 24UL) & 15U;
  } else {

  }
#line 1354
  i = 2;
#line 1354
  goto ldv_51784;
  ldv_51783: 
#line 1355
  *(ctr_preload + (unsigned long )i) = *(mpdu + ((unsigned long )i + 8UL));
#line 1354
  i = i + 1;
  ldv_51784: ;
#line 1354
  if (i <= 7) {
#line 1356
    goto ldv_51783;
  } else {

  }
#line 1356
  i = 8;
#line 1356
  goto ldv_51787;
  ldv_51786: 
#line 1357
  *(ctr_preload + (unsigned long )i) = *(pn_vector + (unsigned long )(13 - i));
#line 1356
  i = i + 1;
  ldv_51787: ;
#line 1356
  if (i <= 13) {
#line 1358
    goto ldv_51786;
  } else {

  }
#line 1358
  *(ctr_preload + 14UL) = (unsigned char )(c / 256);
#line 1359
  *(ctr_preload + 15UL) = (unsigned char )(c % 256);
#line 1360
  return;
}
}
#line 1367 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static void bitwise_xor(u8 *ina , u8 *inb___0 , u8 *out ) 
{ 
  int i ;

  {
#line 1371
  i = 0;
#line 1371
  goto ldv_51796;
  ldv_51795: 
#line 1372
  *(out + (unsigned long )i) = (u8 )((int )*(ina + (unsigned long )i) ^ (int )*(inb___0 + (unsigned long )i));
#line 1371
  i = i + 1;
  ldv_51796: ;
#line 1371
  if (i <= 15) {
#line 1373
    goto ldv_51795;
  } else {

  }

#line 1378
  return;
}
}
#line 1375 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static int aes_cipher(u8 *key , uint hdrlen , u8 *pframe , uint plen ) 
{ 
  uint qc_exists ;
  uint a4_exists ;
  uint i ;
  uint j ;
  uint payload_remainder ;
  uint num_blocks ;
  uint payload_index ;
  u8 pn_vector[6U] ;
  u8 mic_iv[16U] ;
  u8 mic_header1[16U] ;
  u8 mic_header2[16U] ;
  u8 ctr_preload[16U] ;
  u8 chain_buffer[16U] ;
  u8 aes_out[16U] ;
  u8 padded_buffer[16U] ;
  u8 mic[8U] ;
  struct ieee80211_hdr *hdr ;
  u16 frsubtype ;
  int tmp ;
  uint tmp___0 ;
  uint tmp___1 ;
  uint tmp___2 ;
  uint tmp___3 ;

  {
#line 1389
  hdr = (struct ieee80211_hdr *)pframe;
#line 1390
  frsubtype = (unsigned int )hdr->frame_control & 240U;
#line 1392
  memset((void *)(& mic_iv), 0, 16UL);
#line 1393
  memset((void *)(& mic_header1), 0, 16UL);
#line 1394
  memset((void *)(& mic_header2), 0, 16UL);
#line 1395
  memset((void *)(& ctr_preload), 0, 16UL);
#line 1396
  memset((void *)(& chain_buffer), 0, 16UL);
#line 1397
  memset((void *)(& aes_out), 0, 16UL);
#line 1398
  memset((void *)(& padded_buffer), 0, 16UL);
#line 1400
  if (hdrlen == 24U || hdrlen == 26U) {
#line 1402
    a4_exists = 0U;
  } else {
#line 1404
    a4_exists = 1U;
  }
#line 1406
  tmp = ieee80211_is_data((int )hdr->frame_control);
#line 1406
  if (tmp != 0) {
#line 1407
    if (((unsigned int )frsubtype == 16U || (unsigned int )frsubtype == 32U) || (unsigned int )frsubtype == 48U) {
#line 1410
      qc_exists = 1U;
#line 1411
      if (hdrlen != 26U) {
#line 1412
        hdrlen = hdrlen + 2U;
      } else {

      }
    } else
#line 1413
    if ((((unsigned int )frsubtype == 128U || (unsigned int )frsubtype == 144U) || (unsigned int )frsubtype == 160U) || (unsigned int )frsubtype == 176U) {
#line 1417
      if (hdrlen != 26U) {
#line 1418
        hdrlen = hdrlen + 2U;
      } else {

      }
#line 1419
      qc_exists = 1U;
    } else {
#line 1421
      qc_exists = 0U;
    }
  } else {
#line 1424
    qc_exists = 0U;
  }
#line 1426
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
#line 1427
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
#line 1428
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
#line 1429
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
#line 1430
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
#line 1431
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
#line 1433
  construct_mic_iv((u8 *)(& mic_iv), (int )qc_exists, (int )a4_exists, pframe, plen,
                   (u8 *)(& pn_vector));
#line 1435
  construct_mic_header1((u8 *)(& mic_header1), (int )hdrlen, pframe);
#line 1436
  construct_mic_header2((u8 *)(& mic_header2), pframe, (int )a4_exists, (int )qc_exists);
#line 1438
  payload_remainder = plen & 15U;
#line 1439
  num_blocks = plen / 16U;
#line 1442
  payload_index = hdrlen + 8U;
#line 1445
  aes128k128d(key, (u8 *)(& mic_iv), (u8 *)(& aes_out));
#line 1446
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header1), (u8 *)(& chain_buffer));
#line 1447
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1448
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header2), (u8 *)(& chain_buffer));
#line 1449
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1451
  i = 0U;
#line 1451
  goto ldv_51823;
  ldv_51822: 
#line 1452
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
#line 1454
  payload_index = payload_index + 16U;
#line 1455
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1451
  i = i + 1U;
  ldv_51823: ;
#line 1451
  if (i < num_blocks) {
#line 1453
    goto ldv_51822;
  } else {

  }

#line 1459
  if (payload_remainder != 0U) {
#line 1460
    j = 0U;
#line 1460
    goto ldv_51826;
    ldv_51825: 
#line 1461
    padded_buffer[j] = 0U;
#line 1460
    j = j + 1U;
    ldv_51826: ;
#line 1460
    if (j <= 15U) {
#line 1462
      goto ldv_51825;
    } else {

    }
#line 1462
    j = 0U;
#line 1462
    goto ldv_51829;
    ldv_51828: 
#line 1463
    tmp___0 = payload_index;
#line 1463
    payload_index = payload_index + 1U;
#line 1463
    padded_buffer[j] = *(pframe + (unsigned long )tmp___0);
#line 1462
    j = j + 1U;
    ldv_51829: ;
#line 1462
    if (j < payload_remainder) {
#line 1464
      goto ldv_51828;
    } else {

    }
#line 1464
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1465
    aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  } else {

  }
#line 1468
  j = 0U;
#line 1468
  goto ldv_51832;
  ldv_51831: 
#line 1469
  mic[j] = aes_out[j];
#line 1468
  j = j + 1U;
  ldv_51832: ;
#line 1468
  if (j <= 7U) {
#line 1470
    goto ldv_51831;
  } else {

  }
#line 1472
  j = 0U;
#line 1472
  goto ldv_51835;
  ldv_51834: 
#line 1473
  *(pframe + (unsigned long )(payload_index + j)) = mic[j];
#line 1472
  j = j + 1U;
  ldv_51835: ;
#line 1472
  if (j <= 7U) {
#line 1474
    goto ldv_51834;
  } else {

  }
#line 1475
  payload_index = hdrlen + 8U;
#line 1476
  i = 0U;
#line 1476
  goto ldv_51841;
  ldv_51840: 
#line 1477
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), (int )(i + 1U));
#line 1479
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1480
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
#line 1481
  j = 0U;
#line 1481
  goto ldv_51838;
  ldv_51837: 
#line 1482
  tmp___1 = payload_index;
#line 1482
  payload_index = payload_index + 1U;
#line 1482
  *(pframe + (unsigned long )tmp___1) = chain_buffer[j];
#line 1481
  j = j + 1U;
  ldv_51838: ;
#line 1481
  if (j <= 15U) {
#line 1483
    goto ldv_51837;
  } else {

  }
#line 1476
  i = i + 1U;
  ldv_51841: ;
#line 1476
  if (i < num_blocks) {
#line 1478
    goto ldv_51840;
  } else {

  }

#line 1485
  if (payload_remainder != 0U) {
#line 1489
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          pframe, (u8 *)(& pn_vector), (int )(num_blocks + 1U));
#line 1492
    j = 0U;
#line 1492
    goto ldv_51844;
    ldv_51843: 
#line 1493
    padded_buffer[j] = 0U;
#line 1492
    j = j + 1U;
    ldv_51844: ;
#line 1492
    if (j <= 15U) {
#line 1494
      goto ldv_51843;
    } else {

    }
#line 1494
    j = 0U;
#line 1494
    goto ldv_51847;
    ldv_51846: 
#line 1495
    padded_buffer[j] = *(pframe + (unsigned long )(payload_index + j));
#line 1494
    j = j + 1U;
    ldv_51847: ;
#line 1494
    if (j < payload_remainder) {
#line 1496
      goto ldv_51846;
    } else {

    }
#line 1496
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1497
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1498
    j = 0U;
#line 1498
    goto ldv_51850;
    ldv_51849: 
#line 1499
    tmp___2 = payload_index;
#line 1499
    payload_index = payload_index + 1U;
#line 1499
    *(pframe + (unsigned long )tmp___2) = chain_buffer[j];
#line 1498
    j = j + 1U;
    ldv_51850: ;
#line 1498
    if (j < payload_remainder) {
#line 1500
      goto ldv_51849;
    } else {

    }

  } else {

  }
#line 1503
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), 0);
#line 1506
  j = 0U;
#line 1506
  goto ldv_51853;
  ldv_51852: 
#line 1507
  padded_buffer[j] = 0U;
#line 1506
  j = j + 1U;
  ldv_51853: ;
#line 1506
  if (j <= 15U) {
#line 1508
    goto ldv_51852;
  } else {

  }
#line 1508
  j = 0U;
#line 1508
  goto ldv_51856;
  ldv_51855: 
#line 1509
  padded_buffer[j] = *(pframe + (unsigned long )(((j + hdrlen) + plen) + 8U));
#line 1508
  j = j + 1U;
  ldv_51856: ;
#line 1508
  if (j <= 7U) {
#line 1510
    goto ldv_51855;
  } else {

  }
#line 1511
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1512
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1513
  j = 0U;
#line 1513
  goto ldv_51859;
  ldv_51858: 
#line 1514
  tmp___3 = payload_index;
#line 1514
  payload_index = payload_index + 1U;
#line 1514
  *(pframe + (unsigned long )tmp___3) = chain_buffer[j];
#line 1513
  j = j + 1U;
  ldv_51859: ;
#line 1513
  if (j <= 7U) {
#line 1515
    goto ldv_51858;
  } else {

  }

#line 1516
  return (1);
}
}
#line 1519 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
int rtw_aes_encrypt23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int curfragnum ;
  int length ;
  u32 prwskeylen ;
  u8 *pframe ;
  u8 *prwskey ;
  u8 hw_hdr_offset ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  bool tmp ;

  {
#line 1526
  hw_hdr_offset = 0U;
#line 1528
  pattrib = & pxmitframe->attrib;
#line 1529
  psecuritypriv = & padapter->securitypriv;
#line 1530
  pxmitpriv = & padapter->xmitpriv;
#line 1531
  res = 1;
#line 1533
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
#line 1534
    return (0);
  } else {

  }
#line 1536
  hw_hdr_offset = 40U;
#line 1538
  pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
#line 1541
  if (pattrib->encrypt != 1027076U) {
#line 1542
    return (0);
  } else {

  }
#line 1544
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 1545
    stainfo = pattrib->psta;
  } else {
#line 1547
    if (GlobalDebugLevel23A > 3U) {
#line 1547
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_aes_encrypt23a");
    } else {

    }
#line 1548
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 1551
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
#line 1552
    if (GlobalDebugLevel23A > 3U) {
#line 1552
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 1552
      printk("\016rtw_aes_encrypt23a: stainfo == NULL!!!\n");
    } else {

    }
#line 1554
    if (GlobalDebugLevel23A > 3U) {
#line 1554
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_aes_encrypt23a");
    } else {

    }
#line 1555
    res = 0;
#line 1556
    goto out;
  } else {

  }
#line 1558
  if ((stainfo->state & 1U) == 0U) {
#line 1559
    if (GlobalDebugLevel23A > 3U) {
#line 1559
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_aes_encrypt23a",
             stainfo->state);
    } else {

    }
#line 1561
    return (0);
  } else {

  }
#line 1563
  if (GlobalDebugLevel23A > 3U) {
#line 1563
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 1563
    printk("\016rtw_aes_encrypt23a: stainfo!= NULL!!!\n");
  } else {

  }
#line 1566
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1566
  if ((int )tmp) {
#line 1567
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey);
  } else {
#line 1569
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
#line 1571
  prwskeylen = 16U;
#line 1573
  curfragnum = 0;
#line 1573
  goto ldv_51879;
  ldv_51878: ;
#line 1575
  if (curfragnum + 1 == (int )pattrib->nr_frags) {
#line 1576
    length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - (u32 )pattrib->icv_len);
#line 1580
    aes_cipher(prwskey, (uint )pattrib->hdrlen, pframe, (uint )length);
  } else {
#line 1582
    length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - (uint )pattrib->icv_len);
#line 1585
    aes_cipher(prwskey, (uint )pattrib->hdrlen, pframe, (uint )length);
#line 1586
    pframe = pframe + (unsigned long )pxmitpriv->frag_len;
#line 1587
    pframe = (u8 *)(((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL);
  }
#line 1573
  curfragnum = curfragnum + 1;
  ldv_51879: ;
#line 1573
  if ((int )pattrib->nr_frags > curfragnum) {
#line 1575
    goto ldv_51878;
  } else {

  }

  out: ;
#line 1591
  return (res);
}
}
#line 1594 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
static int aes_decipher(u8 *key , uint hdrlen , u8 *pframe , uint plen ) 
{ 
  u8 message[2048U] ;
  uint qc_exists ;
  uint a4_exists ;
  uint i ;
  uint j ;
  uint payload_remainder ;
  uint num_blocks ;
  uint payload_index ;
  int res ;
  u8 pn_vector[6U] ;
  u8 mic_iv[16U] ;
  u8 mic_header1[16U] ;
  u8 mic_header2[16U] ;
  u8 ctr_preload[16U] ;
  u8 chain_buffer[16U] ;
  u8 aes_out[16U] ;
  u8 padded_buffer[16U] ;
  u8 mic[8U] ;
  struct ieee80211_hdr *hdr ;
  u16 frsubtype ;
  int tmp ;
  uint tmp___0 ;
  uint tmp___1 ;
  size_t __len ;
  void *__ret ;
  uint tmp___2 ;
  uint tmp___3 ;
  uint tmp___4 ;
  uint tmp___5 ;

  {
#line 1600
  res = 1;
#line 1611
  hdr = (struct ieee80211_hdr *)pframe;
#line 1612
  frsubtype = (unsigned int )hdr->frame_control & 240U;
#line 1614
  memset((void *)(& mic_iv), 0, 16UL);
#line 1615
  memset((void *)(& mic_header1), 0, 16UL);
#line 1616
  memset((void *)(& mic_header2), 0, 16UL);
#line 1617
  memset((void *)(& ctr_preload), 0, 16UL);
#line 1618
  memset((void *)(& chain_buffer), 0, 16UL);
#line 1619
  memset((void *)(& aes_out), 0, 16UL);
#line 1620
  memset((void *)(& padded_buffer), 0, 16UL);
#line 1624
  num_blocks = (plen - 8U) / 16U;
#line 1626
  payload_remainder = (plen - 8U) & 15U;
#line 1628
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
#line 1629
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
#line 1630
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
#line 1631
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
#line 1632
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
#line 1633
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
#line 1635
  if (hdrlen == 24U || hdrlen == 26U) {
#line 1637
    a4_exists = 0U;
  } else {
#line 1639
    a4_exists = 1U;
  }
#line 1641
  tmp = ieee80211_is_data((int )hdr->frame_control);
#line 1641
  if (tmp != 0) {
#line 1642
    if (((unsigned int )frsubtype == 16U || (unsigned int )frsubtype == 32U) || (unsigned int )frsubtype == 48U) {
#line 1645
      qc_exists = 1U;
#line 1646
      if (hdrlen != 24U) {
#line 1647
        hdrlen = hdrlen + 2U;
      } else {

      }
    } else
#line 1648
    if ((((unsigned int )frsubtype == 128U || (unsigned int )frsubtype == 144U) || (unsigned int )frsubtype == 160U) || (unsigned int )frsubtype == 176U) {
#line 1652
      if (hdrlen != 24U) {
#line 1653
        hdrlen = hdrlen + 2U;
      } else {

      }
#line 1654
      qc_exists = 1U;
    } else {
#line 1656
      qc_exists = 0U;
    }
  } else {
#line 1659
    qc_exists = 0U;
  }
#line 1664
  payload_index = hdrlen + 8U;
#line 1666
  i = 0U;
#line 1666
  goto ldv_51911;
  ldv_51910: 
#line 1667
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, pframe,
                        (u8 *)(& pn_vector), (int )(i + 1U));
#line 1670
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1671
  bitwise_xor((u8 *)(& aes_out), pframe + (unsigned long )payload_index, (u8 *)(& chain_buffer));
#line 1673
  j = 0U;
#line 1673
  goto ldv_51908;
  ldv_51907: 
#line 1674
  tmp___0 = payload_index;
#line 1674
  payload_index = payload_index + 1U;
#line 1674
  *(pframe + (unsigned long )tmp___0) = chain_buffer[j];
#line 1673
  j = j + 1U;
  ldv_51908: ;
#line 1673
  if (j <= 15U) {
#line 1675
    goto ldv_51907;
  } else {

  }
#line 1666
  i = i + 1U;
  ldv_51911: ;
#line 1666
  if (i < num_blocks) {
#line 1668
    goto ldv_51910;
  } else {

  }

#line 1677
  if (payload_remainder != 0U) {
#line 1681
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          pframe, (u8 *)(& pn_vector), (int )(num_blocks + 1U));
#line 1684
    j = 0U;
#line 1684
    goto ldv_51914;
    ldv_51913: 
#line 1685
    padded_buffer[j] = 0U;
#line 1684
    j = j + 1U;
    ldv_51914: ;
#line 1684
    if (j <= 15U) {
#line 1686
      goto ldv_51913;
    } else {

    }
#line 1686
    j = 0U;
#line 1686
    goto ldv_51917;
    ldv_51916: 
#line 1687
    padded_buffer[j] = *(pframe + (unsigned long )(payload_index + j));
#line 1686
    j = j + 1U;
    ldv_51917: ;
#line 1686
    if (j < payload_remainder) {
#line 1688
      goto ldv_51916;
    } else {

    }
#line 1688
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1689
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1690
    j = 0U;
#line 1690
    goto ldv_51920;
    ldv_51919: 
#line 1691
    tmp___1 = payload_index;
#line 1691
    payload_index = payload_index + 1U;
#line 1691
    *(pframe + (unsigned long )tmp___1) = chain_buffer[j];
#line 1690
    j = j + 1U;
    ldv_51920: ;
#line 1690
    if (j < payload_remainder) {
#line 1692
      goto ldv_51919;
    } else {

    }

  } else {

  }
#line 1695
  if ((hdrlen + plen) + 8U <= 2048U) {
#line 1696
    __len = (size_t )((hdrlen + plen) + 8U);
#line 1696
    __ret = __builtin_memcpy((void *)(& message), (void const   *)pframe, __len);
  } else {

  }
#line 1698
  pn_vector[0] = *(pframe + (unsigned long )hdrlen);
#line 1699
  pn_vector[1] = *(pframe + (unsigned long )(hdrlen + 1U));
#line 1700
  pn_vector[2] = *(pframe + (unsigned long )(hdrlen + 4U));
#line 1701
  pn_vector[3] = *(pframe + (unsigned long )(hdrlen + 5U));
#line 1702
  pn_vector[4] = *(pframe + (unsigned long )(hdrlen + 6U));
#line 1703
  pn_vector[5] = *(pframe + (unsigned long )(hdrlen + 7U));
#line 1705
  construct_mic_iv((u8 *)(& mic_iv), (int )qc_exists, (int )a4_exists, (u8 *)(& message),
                   plen - 8U, (u8 *)(& pn_vector));
#line 1708
  construct_mic_header1((u8 *)(& mic_header1), (int )hdrlen, (u8 *)(& message));
#line 1709
  construct_mic_header2((u8 *)(& mic_header2), (u8 *)(& message), (int )a4_exists,
                        (int )qc_exists);
#line 1711
  payload_remainder = (plen - 8U) & 15U;
#line 1712
  num_blocks = (plen - 8U) / 16U;
#line 1715
  payload_index = hdrlen + 8U;
#line 1718
  aes128k128d(key, (u8 *)(& mic_iv), (u8 *)(& aes_out));
#line 1719
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header1), (u8 *)(& chain_buffer));
#line 1720
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1721
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& mic_header2), (u8 *)(& chain_buffer));
#line 1722
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1724
  i = 0U;
#line 1724
  goto ldv_51926;
  ldv_51925: 
#line 1725
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& message) + (unsigned long )payload_index,
              (u8 *)(& chain_buffer));
#line 1727
  payload_index = payload_index + 16U;
#line 1728
  aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
#line 1724
  i = i + 1U;
  ldv_51926: ;
#line 1724
  if (i < num_blocks) {
#line 1726
    goto ldv_51925;
  } else {

  }

#line 1732
  if (payload_remainder != 0U) {
#line 1733
    j = 0U;
#line 1733
    goto ldv_51929;
    ldv_51928: 
#line 1734
    padded_buffer[j] = 0U;
#line 1733
    j = j + 1U;
    ldv_51929: ;
#line 1733
    if (j <= 15U) {
#line 1735
      goto ldv_51928;
    } else {

    }
#line 1735
    j = 0U;
#line 1735
    goto ldv_51932;
    ldv_51931: 
#line 1736
    tmp___2 = payload_index;
#line 1736
    payload_index = payload_index + 1U;
#line 1736
    padded_buffer[j] = message[tmp___2];
#line 1735
    j = j + 1U;
    ldv_51932: ;
#line 1735
    if (j < payload_remainder) {
#line 1737
      goto ldv_51931;
    } else {

    }
#line 1737
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1738
    aes128k128d(key, (u8 *)(& chain_buffer), (u8 *)(& aes_out));
  } else {

  }
#line 1741
  j = 0U;
#line 1741
  goto ldv_51935;
  ldv_51934: 
#line 1742
  mic[j] = aes_out[j];
#line 1741
  j = j + 1U;
  ldv_51935: ;
#line 1741
  if (j <= 7U) {
#line 1743
    goto ldv_51934;
  } else {

  }
#line 1745
  j = 0U;
#line 1745
  goto ldv_51938;
  ldv_51937: 
#line 1746
  message[payload_index + j] = mic[j];
#line 1745
  j = j + 1U;
  ldv_51938: ;
#line 1745
  if (j <= 7U) {
#line 1747
    goto ldv_51937;
  } else {

  }
#line 1748
  payload_index = hdrlen + 8U;
#line 1749
  i = 0U;
#line 1749
  goto ldv_51944;
  ldv_51943: 
#line 1750
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, (u8 *)(& message),
                        (u8 *)(& pn_vector), (int )(i + 1U));
#line 1752
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1753
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& message) + (unsigned long )payload_index,
              (u8 *)(& chain_buffer));
#line 1754
  j = 0U;
#line 1754
  goto ldv_51941;
  ldv_51940: 
#line 1755
  tmp___3 = payload_index;
#line 1755
  payload_index = payload_index + 1U;
#line 1755
  message[tmp___3] = chain_buffer[j];
#line 1754
  j = j + 1U;
  ldv_51941: ;
#line 1754
  if (j <= 15U) {
#line 1756
    goto ldv_51940;
  } else {

  }
#line 1749
  i = i + 1U;
  ldv_51944: ;
#line 1749
  if (i < num_blocks) {
#line 1751
    goto ldv_51943;
  } else {

  }

#line 1758
  if (payload_remainder != 0U) {
#line 1762
    construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists,
                          (u8 *)(& message), (u8 *)(& pn_vector), (int )(num_blocks + 1U));
#line 1765
    j = 0U;
#line 1765
    goto ldv_51947;
    ldv_51946: 
#line 1766
    padded_buffer[j] = 0U;
#line 1765
    j = j + 1U;
    ldv_51947: ;
#line 1765
    if (j <= 15U) {
#line 1767
      goto ldv_51946;
    } else {

    }
#line 1767
    j = 0U;
#line 1767
    goto ldv_51950;
    ldv_51949: 
#line 1768
    padded_buffer[j] = message[payload_index + j];
#line 1767
    j = j + 1U;
    ldv_51950: ;
#line 1767
    if (j < payload_remainder) {
#line 1769
      goto ldv_51949;
    } else {

    }
#line 1769
    aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1770
    bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1771
    j = 0U;
#line 1771
    goto ldv_51953;
    ldv_51952: 
#line 1772
    tmp___4 = payload_index;
#line 1772
    payload_index = payload_index + 1U;
#line 1772
    message[tmp___4] = chain_buffer[j];
#line 1771
    j = j + 1U;
    ldv_51953: ;
#line 1771
    if (j < payload_remainder) {
#line 1773
      goto ldv_51952;
    } else {

    }

  } else {

  }
#line 1776
  construct_ctr_preload((u8 *)(& ctr_preload), (int )a4_exists, (int )qc_exists, (u8 *)(& message),
                        (u8 *)(& pn_vector), 0);
#line 1779
  j = 0U;
#line 1779
  goto ldv_51956;
  ldv_51955: 
#line 1780
  padded_buffer[j] = 0U;
#line 1779
  j = j + 1U;
  ldv_51956: ;
#line 1779
  if (j <= 15U) {
#line 1781
    goto ldv_51955;
  } else {

  }
#line 1781
  j = 0U;
#line 1781
  goto ldv_51959;
  ldv_51958: 
#line 1782
  padded_buffer[j] = message[(j + hdrlen) + plen];
#line 1781
  j = j + 1U;
  ldv_51959: ;
#line 1781
  if (j <= 7U) {
#line 1783
    goto ldv_51958;
  } else {

  }
#line 1784
  aes128k128d(key, (u8 *)(& ctr_preload), (u8 *)(& aes_out));
#line 1785
  bitwise_xor((u8 *)(& aes_out), (u8 *)(& padded_buffer), (u8 *)(& chain_buffer));
#line 1786
  j = 0U;
#line 1786
  goto ldv_51962;
  ldv_51961: 
#line 1787
  tmp___5 = payload_index;
#line 1787
  payload_index = payload_index + 1U;
#line 1787
  message[tmp___5] = chain_buffer[j];
#line 1786
  j = j + 1U;
  ldv_51962: ;
#line 1786
  if (j <= 7U) {
#line 1788
    goto ldv_51961;
  } else {

  }
#line 1790
  i = 0U;
#line 1790
  goto ldv_51965;
  ldv_51964: ;
#line 1791
  if ((int )*(pframe + (unsigned long )((hdrlen + plen) + i)) != (int )message[(hdrlen + plen) + i]) {
#line 1792
    if (GlobalDebugLevel23A > 3U) {
#line 1792
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 1792
      printk("\016aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x)\n",
             i, (int )*(pframe + (unsigned long )((hdrlen + plen) + i)), (int )message[(hdrlen + plen) + i]);
    } else {

    }
#line 1795
    if (GlobalDebugLevel23A > 3U) {
#line 1795
      printk("\016RTL8723AU: aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x)\n",
             i, (int )*(pframe + (unsigned long )((hdrlen + plen) + i)), (int )message[(hdrlen + plen) + i]);
    } else {

    }
#line 1797
    res = 0;
  } else {

  }
#line 1790
  i = i + 1U;
  ldv_51965: ;
#line 1790
  if (i <= 7U) {
#line 1792
    goto ldv_51964;
  } else {

  }

#line 1800
  return (res);
}
}
#line 1803 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
int rtw_aes_decrypt23a(struct rtw_adapter *padapter , struct recv_frame *precvframe ) 
{ 
  struct sta_info *stainfo ;
  struct rx_pkt_attrib *prxattrib ;
  struct security_priv *psecuritypriv ;
  struct sk_buff *skb ;
  int length ;
  u8 *pframe ;
  u8 *prwskey ;
  int res ;
  bool tmp ;

  {
#line 1807
  prxattrib = & precvframe->attrib;
#line 1808
  psecuritypriv = & padapter->securitypriv;
#line 1809
  skb = precvframe->pkt;
#line 1812
  res = 1;
#line 1814
  pframe = skb->data;
#line 1816
  if (prxattrib->encrypt != 1027076U) {
#line 1817
    return (0);
  } else {

  }
#line 1819
  stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& prxattrib->ta));
#line 1820
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
#line 1821
    if (GlobalDebugLevel23A > 3U) {
#line 1821
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 1821
      printk("\016rtw_aes_encrypt23a: stainfo == NULL!!!\n");
    } else {

    }
#line 1823
    res = 0;
#line 1824
    goto exit;
  } else {

  }
#line 1827
  if (GlobalDebugLevel23A > 3U) {
#line 1827
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 1827
    printk("\016rtw_aes_decrypt23a: stainfo!= NULL!!!\n");
  } else {

  }
#line 1830
  tmp = is_multicast_ether_addr((u8 const   *)(& prxattrib->ra));
#line 1830
  if ((int )tmp) {
#line 1833
    if ((unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
#line 1834
      res = 0;
#line 1835
      if (GlobalDebugLevel23A > 3U) {
#line 1835
        printk("\016RTL8723AU: %s:rx bc/mc packets, but didn\'t install group key!!!!!!!!!!\n",
               "rtw_aes_decrypt23a");
      } else {

      }
#line 1837
      goto exit;
    } else {

    }
#line 1839
    prwskey = (u8 *)(& psecuritypriv->dot118021XGrpKey[(int )prxattrib->key_index].skey);
#line 1840
    if (psecuritypriv->dot118021XGrpKeyid != (u32 )prxattrib->key_index) {
#line 1841
      if (GlobalDebugLevel23A > 3U) {
#line 1841
        printk("\016RTL8723AU: not match packet_index =%d, install_index =%d\n", (int )prxattrib->key_index,
               psecuritypriv->dot118021XGrpKeyid);
      } else {

      }
#line 1844
      res = 0;
#line 1845
      goto exit;
    } else {

    }
  } else {
#line 1848
    prwskey = (u8 *)(& stainfo->dot118021x_UncstKey.skey);
  }
#line 1851
  length = (int )((skb->len - (unsigned int )prxattrib->hdrlen) - (unsigned int )prxattrib->iv_len);
#line 1853
  res = aes_decipher(prwskey, (uint )prxattrib->hdrlen, pframe, (uint )length);
  exit: ;
#line 1855
  return (res);
}
}
#line 1858 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void rtw_use_tkipkey_handler23a(void *FunctionContext ) 
{ 
  struct rtw_adapter *padapter ;

  {
#line 1860
  padapter = (struct rtw_adapter *)FunctionContext;
#line 1862
  if (GlobalDebugLevel23A > 3U) {
#line 1862
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 1862
    printk("\016^^^rtw_use_tkipkey_handler23a ^^^\n");
  } else {

  }
#line 1863
  padapter->securitypriv.busetkipkey = 1U;
#line 1864
  if (GlobalDebugLevel23A > 3U) {
#line 1864
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 4);
#line 1864
    printk("\016^^^rtw_use_tkipkey_handler23a padapter->securitypriv.busetkipkey =%d^^^\n",
           (int )padapter->securitypriv.busetkipkey);
  } else {

  }
#line 1866
  return;
}
}
#line 1996 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
void *ldv_kmem_cache_alloc_696(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1999
  ldv_check_alloc_flags(flags);
#line 2001
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2002
  return ((void *)0);
}
}
#line 2040 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
int ldv_pskb_expand_head_702(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2043
  ldv_check_alloc_flags(flags);
#line 2045
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2045
  return (tmp);
}
}
#line 2056 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
struct sk_buff *ldv_skb_clone_704(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2059
  ldv_check_alloc_flags(flags);
#line 2061
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2061
  return (tmp);
}
}
#line 2072 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
struct sk_buff *ldv_skb_copy_706(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2075
  ldv_check_alloc_flags(flags);
#line 2077
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2077
  return (tmp);
}
}
#line 2080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_707(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2083
  ldv_check_alloc_flags(flags);
#line 2085
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2085
  return (tmp);
}
}
#line 2088 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_708(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2091
  ldv_check_alloc_flags(flags);
#line 2093
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2093
  return (tmp);
}
}
#line 2096 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_709(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2099
  ldv_check_alloc_flags(flags);
#line 2101
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2101
  return (tmp);
}
}
#line 2104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
int ldv_pskb_expand_head_710(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2107
  ldv_check_alloc_flags(flags);
#line 2109
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2109
  return (tmp);
}
}
#line 2112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
int ldv_pskb_expand_head_711(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2115
  ldv_check_alloc_flags(flags);
#line 2117
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2117
  return (tmp);
}
}
#line 2120 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_security.o.c.prepared"
struct sk_buff *ldv_skb_clone_712(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2123
  ldv_check_alloc_flags(flags);
#line 2125
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2125
  return (tmp);
}
}
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 120 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 179 "include/linux/timer.h"
int ldv_mod_timer_755(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_738(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_746(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_754(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_748(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_744(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_752(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_753(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_749(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_750(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_751(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 522 "include/linux/interrupt.h"
extern void __tasklet_hi_schedule(struct tasklet_struct * ) ;
#line 524 "include/linux/interrupt.h"
__inline static void tasklet_hi_schedule(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
#line 526
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
#line 526
  if (tmp == 0) {
#line 527
    __tasklet_hi_schedule(t);
  } else {

  }
#line 528
  return;
}
}
#line 570
extern void tasklet_kill(struct tasklet_struct * ) ;
#line 1621 "include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1624
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 2140
extern void __netif_schedule(struct Qdisc * ) ;
#line 2182 "include/linux/netdevice.h"
__inline static void netif_tx_wake_queue(struct netdev_queue *dev_queue ) 
{ 
  int tmp ;

  {
#line 2184
  tmp = test_and_clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2184
  if (tmp != 0) {
#line 2185
    __netif_schedule(dev_queue->qdisc);
  } else {

  }
#line 2186
  return;
}
}
#line 2200 "include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2204
  i = 0U;
#line 2204
  goto ldv_40894;
  ldv_40893: 
#line 2205
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2205
  txq = tmp;
#line 2206
  netif_tx_wake_queue(txq);
#line 2204
  i = i + 1U;
  ldv_40894: ;
#line 2204
  if (dev->num_tx_queues > i) {
#line 2206
    goto ldv_40893;
  } else {

  }

#line 2211
  return;
}
}
#line 2210 "include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
#line 2212
  __ret_warn_on = (unsigned long )dev_queue == (unsigned long )((struct netdev_queue *)0);
#line 2212
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2212
  if (tmp != 0L) {
#line 2212
    warn_slowpath_null("include/linux/netdevice.h", 2212);
  } else {

  }
#line 2212
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2212
  if (tmp___0 != 0L) {
#line 2213
    printk("\016netif_stop_queue() cannot be called before register_netdev()\n");
#line 2214
    return;
  } else {

  }
#line 2216
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2217
  return;
}
}
#line 2231 "include/linux/netdevice.h"
__inline static void netif_tx_stop_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2235
  i = 0U;
#line 2235
  goto ldv_40910;
  ldv_40909: 
#line 2236
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2236
  txq = tmp;
#line 2237
  netif_tx_stop_queue(txq);
#line 2235
  i = i + 1U;
  ldv_40910: ;
#line 2235
  if (dev->num_tx_queues > i) {
#line 2237
    goto ldv_40909;
  } else {

  }

#line 2242
  return;
}
}
#line 2241 "include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
#line 2243
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev_queue->state));
#line 2243
  return (tmp != 0);
}
}
#line 60 "drivers/staging/rtl8723au/include/osdep_service.h"
__inline static int rtw_netif_queue_stopped(struct net_device *pnetdev ) 
{ 
  struct netdev_queue *tmp ;
  bool tmp___0 ;
  struct netdev_queue *tmp___1 ;
  bool tmp___2 ;
  struct netdev_queue *tmp___3 ;
  bool tmp___4 ;
  struct netdev_queue *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;

  {
#line 62
  tmp = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 0U);
#line 62
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp);
#line 62
  if ((int )tmp___0) {
#line 62
    tmp___1 = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 1U);
#line 62
    tmp___2 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp___1);
#line 62
    if ((int )tmp___2) {
#line 62
      tmp___3 = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 2U);
#line 62
      tmp___4 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp___3);
#line 62
      if ((int )tmp___4) {
#line 62
        tmp___5 = netdev_get_tx_queue((struct net_device  const  *)pnetdev, 3U);
#line 62
        tmp___6 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp___5);
#line 62
        if ((int )tmp___6) {
#line 62
          tmp___7 = 1;
        } else {
#line 62
          tmp___7 = 0;
        }
      } else {
#line 62
        tmp___7 = 0;
      }
    } else {
#line 62
      tmp___7 = 0;
    }
  } else {
#line 62
    tmp___7 = 0;
  }
#line 62
  return (tmp___7);
}
}
#line 29 "drivers/staging/rtl8723au/include/osdep_intf.h"
void rtw_cancel_all_timer23a(struct rtw_adapter *padapter ) ;
#line 36 "drivers/staging/rtl8723au/include/rtw_ap.h"
void rtw_ap_restore_network(struct rtw_adapter *padapter ) ;
#line 48 "drivers/staging/rtl8723au/include/rtw_sreset.h"
void rtw_sreset_init(struct rtw_adapter *padapter ) ;
#line 49
void rtw_sreset_reset_value(struct rtw_adapter *padapter ) ;
#line 50
u8 rtw_sreset_get_wifi_status(struct rtw_adapter *padapter ) ;
#line 52
void sreset_set_wifi_error_status23a(struct rtw_adapter *padapter , u32 status ) ;
#line 53
void sreset_set_trigger_point(struct rtw_adapter *padapter , s32 tgp ) ;
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
void rtw_sreset_init(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  struct lock_class_key __key ;

  {
#line 239
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 240
  psrtpriv = & pHalData->srestpriv;
#line 242
  __mutex_init(& psrtpriv->silentreset_mutex, "&psrtpriv->silentreset_mutex", & __key);
#line 243
  psrtpriv->silent_reset_inprogress = 0U;
#line 244
  psrtpriv->Wifi_Error_Status = 0U;
#line 245
  psrtpriv->last_tx_time = 0UL;
#line 246
  psrtpriv->last_tx_complete_time = 0UL;
#line 247
  return;
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
void rtw_sreset_reset_value(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;

  {
#line 251
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 252
  psrtpriv = & pHalData->srestpriv;
#line 254
  psrtpriv->silent_reset_inprogress = 0U;
#line 255
  psrtpriv->Wifi_Error_Status = 0U;
#line 256
  psrtpriv->last_tx_time = 0UL;
#line 257
  psrtpriv->last_tx_complete_time = 0UL;
#line 258
  return;
}
}
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
u8 rtw_sreset_get_wifi_status(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  u8 status ;
  u32 val32 ;

  {
#line 262
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 263
  psrtpriv = & pHalData->srestpriv;
#line 264
  status = 0U;
#line 265
  val32 = 0U;
#line 267
  if ((unsigned int )psrtpriv->silent_reset_inprogress != 0U) {
#line 268
    return (status);
  } else {

  }
#line 269
  val32 = rtl8723au_read32(padapter, 528U);
#line 270
  if (val32 == 3941264106U) {
#line 271
    psrtpriv->Wifi_Error_Status = 64U;
  } else
#line 272
  if (val32 != 0U) {
#line 273
    if (GlobalDebugLevel23A > 3U) {
#line 273
      printk("\016RTL8723AU: txdmastatu(%x)\n", val32);
    } else {

    }
#line 274
    psrtpriv->Wifi_Error_Status = 8U;
  } else {

  }
#line 277
  if ((unsigned int )psrtpriv->Wifi_Error_Status != 0U) {
#line 278
    if (GlobalDebugLevel23A > 3U) {
#line 278
      printk("\016RTL8723AU: ==>%s error_status(0x%x)\n", "rtw_sreset_get_wifi_status",
             (int )psrtpriv->Wifi_Error_Status);
    } else {

    }
#line 279
    status = (unsigned int )psrtpriv->Wifi_Error_Status & 249U;
  } else {

  }
#line 281
  if (GlobalDebugLevel23A > 3U) {
#line 281
    printk("\016RTL8723AU: ==> %s wifi_status(0x%x)\n", "rtw_sreset_get_wifi_status",
           (int )status);
  } else {

  }
#line 284
  psrtpriv->Wifi_Error_Status = 0U;
#line 286
  return (status);
}
}
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
void sreset_set_wifi_error_status23a(struct rtw_adapter *padapter , u32 status ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 291
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 293
  pHalData->srestpriv.Wifi_Error_Status = (u8 )status;
#line 294
  return;
}
}
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
void sreset_set_trigger_point(struct rtw_adapter *padapter , s32 tgp ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 298
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 300
  pHalData->srestpriv.dbg_trigger_point = tgp;
#line 301
  return;
}
}
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
bool rtw_sreset_inprogress(struct rtw_adapter *padapter ) 
{ 
  struct rtw_adapter *primary_adapter ;
  struct hal_data_8723a *pHalData ;

  {
#line 305
  primary_adapter = (padapter->dvobj)->if1;
#line 306
  pHalData = (struct hal_data_8723a *)primary_adapter->HalData;
#line 308
  return ((unsigned int )pHalData->srestpriv.silent_reset_inprogress != 0U);
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
static void sreset_restore_security_station(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 val8 ;
  u8 *tmp ;

  {
#line 313
  mlmepriv = & padapter->mlmepriv;
#line 314
  pstapriv = & padapter->stapriv;
#line 316
  pmlmeinfo = & padapter->mlmeextpriv.mlmext_info;
#line 319
  if (pmlmeinfo->auth_algo == 2U) {
#line 320
    val8 = 204U;
  } else {
#line 322
    val8 = 207U;
  }
#line 324
  rtl8723a_set_sec_cfg(padapter, (int )val8);
#line 326
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 330
    tmp = get_bssid(mlmepriv);
#line 330
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)tmp);
#line 331
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {

    } else {
#line 335
      rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
#line 337
      rtw_set_key23a(padapter, & padapter->securitypriv, (int )padapter->securitypriv.dot118021XGrpKeyid,
                     0);
    }
  } else {

  }
#line 340
  return;
}
}
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
static void sreset_restore_network_station(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 threshold ;

  {
#line 344
  mlmepriv = & padapter->mlmepriv;
#line 345
  pmlmeext = & padapter->mlmeextpriv;
#line 346
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 349
  rtw_setopmode_cmd23a(padapter, 2);
#line 353
  if (mlmepriv->htpriv.ht_option != 0U) {
#line 354
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
#line 355
      threshold = 1U;
    } else {
#line 357
      threshold = 0U;
    }
  } else {
#line 359
    threshold = 1U;
  }
#line 361
  rtl8723a_set_rxdma_agg_pg_th(padapter, (int )threshold);
#line 363
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 366
  hw_var_set_bssid(padapter, (u8 *)(& pmlmeinfo->network.MacAddress));
#line 367
  hw_var_set_mlme_join(padapter, 0);
#line 369
  Set_MSR23a(padapter, (int )((u8 )pmlmeinfo->state) & 3);
#line 371
  mlmeext_joinbss_event_callback23a(padapter, 1);
#line 373
  rtl8723au_write8(padapter, 1244U, (int )((u8 )padapter->xmitpriv.nqos_ssn));
#line 375
  sreset_restore_security_station(padapter);
#line 376
  return;
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
static void sreset_restore_network_status(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;

  {
#line 380
  mlmepriv = & padapter->mlmepriv;
#line 382
  tmp___5 = check_fwstate(mlmepriv, 8);
#line 382
  if ((int )tmp___5) {
#line 383
    if (GlobalDebugLevel23A > 3U) {
#line 383
      tmp = get_fwstate(mlmepriv);
#line 383
      printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_STATION_STATE\n", "sreset_restore_network_status",
             (char *)(& (padapter->pnetdev)->name), tmp);
    } else {

    }
#line 386
    sreset_restore_network_station(padapter);
  } else {
#line 388
    tmp___4 = check_fwstate(mlmepriv, 16);
#line 388
    if ((int )tmp___4) {
#line 389
      if (GlobalDebugLevel23A > 3U) {
#line 389
        tmp___0 = get_fwstate(mlmepriv);
#line 389
        printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_AP_STATE\n", "sreset_restore_network_status",
               (char *)(& (padapter->pnetdev)->name), tmp___0);
      } else {

      }
#line 392
      rtw_ap_restore_network(padapter);
    } else {
#line 394
      tmp___3 = check_fwstate(mlmepriv, 32);
#line 394
      if ((int )tmp___3) {
#line 395
        if (GlobalDebugLevel23A > 3U) {
#line 395
          tmp___1 = get_fwstate(mlmepriv);
#line 395
          printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - WIFI_ADHOC_STATE\n", "sreset_restore_network_status",
                 (char *)(& (padapter->pnetdev)->name), tmp___1);
        } else {

        }
      } else
#line 399
      if (GlobalDebugLevel23A > 3U) {
#line 399
        tmp___2 = get_fwstate(mlmepriv);
#line 399
        printk("\016RTL8723AU: %s(%s): fwstate:0x%08x - ???\n", "sreset_restore_network_status",
               (char *)(& (padapter->pnetdev)->name), tmp___2);
      } else {

      }
    }
  }
#line 400
  return;
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
static void sreset_stop_adapter(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmitpriv ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 406
  pmlmepriv = & padapter->mlmepriv;
#line 407
  pxmitpriv = & padapter->xmitpriv;
#line 409
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 410
    return;
  } else {

  }
#line 412
  if (GlobalDebugLevel23A > 3U) {
#line 412
    printk("\016RTL8723AU: %s(%s)\n", "sreset_stop_adapter", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
#line 414
  tmp = rtw_netif_queue_stopped(padapter->pnetdev);
#line 414
  if (tmp == 0) {
#line 415
    netif_tx_stop_all_queues(padapter->pnetdev);
  } else {

  }
#line 417
  rtw_cancel_all_timer23a(padapter);
#line 420
  tasklet_kill(& pxmitpriv->xmit_tasklet);
#line 422
  tmp___0 = check_fwstate(pmlmepriv, 2048);
#line 422
  if ((int )tmp___0) {
#line 423
    rtw_scan_abort23a(padapter);
  } else {

  }
#line 425
  tmp___1 = check_fwstate(pmlmepriv, 128);
#line 425
  if ((int )tmp___1) {
#line 426
    rtw23a_join_to_handler((unsigned long )padapter);
  } else {

  }
#line 427
  return;
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
static void sreset_start_adapter(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct xmit_priv *pxmitpriv ;
  bool tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 431
  pmlmepriv = & padapter->mlmepriv;
#line 432
  pxmitpriv = & padapter->xmitpriv;
#line 434
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 435
    return;
  } else {

  }
#line 437
  if (GlobalDebugLevel23A > 3U) {
#line 437
    printk("\016RTL8723AU: %s(%s)\n", "sreset_start_adapter", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
#line 439
  tmp = check_fwstate(pmlmepriv, 1);
#line 439
  if ((int )tmp) {
#line 440
    sreset_restore_network_status(padapter);
  } else {

  }
#line 444
  tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
#line 446
  tmp___0 = msecs_to_jiffies(2000U);
#line 446
  ldv_mod_timer_755(& padapter->mlmepriv.dynamic_chk_timer, tmp___0 + (unsigned long )jiffies);
#line 449
  tmp___1 = rtw_netif_queue_stopped(padapter->pnetdev);
#line 449
  if (tmp___1 != 0) {
#line 450
    netif_tx_wake_all_queues(padapter->pnetdev);
  } else {

  }
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
void rtw_sreset_reset(struct rtw_adapter *active_adapter ) 
{ 
  struct rtw_adapter *padapter ;
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  struct pwrctrl_priv *pwrpriv ;
  unsigned long start ;
  unsigned int tmp ;

  {
#line 455
  padapter = (active_adapter->dvobj)->if1;
#line 456
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 457
  psrtpriv = & pHalData->srestpriv;
#line 458
  pwrpriv = & padapter->pwrctrlpriv;
#line 459
  start = jiffies;
#line 461
  if (GlobalDebugLevel23A > 3U) {
#line 461
    printk("\016RTL8723AU: %s\n", "rtw_sreset_reset");
  } else {

  }
#line 463
  psrtpriv->Wifi_Error_Status = 0U;
#line 465
  mutex_lock_nested(& psrtpriv->silentreset_mutex, 0U);
#line 466
  psrtpriv->silent_reset_inprogress = 1U;
#line 467
  pwrpriv->change_rfpwrstate = 2;
#line 469
  sreset_stop_adapter(padapter);
#line 471
  ips_enter23a(padapter);
#line 472
  ips_leave23a(padapter);
#line 474
  sreset_start_adapter(padapter);
#line 475
  psrtpriv->silent_reset_inprogress = 0U;
#line 476
  mutex_unlock(& psrtpriv->silentreset_mutex);
#line 478
  if (GlobalDebugLevel23A > 3U) {
#line 478
    tmp = jiffies_to_msecs((unsigned long )jiffies - start);
#line 478
    printk("\016RTL8723AU: %s done in %d ms\n", "rtw_sreset_reset", tmp);
  } else {

  }
#line 479
  return;
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
void *ldv_kmem_cache_alloc_738(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 612
  ldv_check_alloc_flags(flags);
#line 614
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 615
  return ((void *)0);
}
}
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
int ldv_pskb_expand_head_744(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 656
  ldv_check_alloc_flags(flags);
#line 658
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 658
  return (tmp);
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
struct sk_buff *ldv_skb_clone_746(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 672
  ldv_check_alloc_flags(flags);
#line 674
  tmp = skb_clone(ldv_func_arg1, flags);
#line 674
  return (tmp);
}
}
#line 685 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
struct sk_buff *ldv_skb_copy_748(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 688
  ldv_check_alloc_flags(flags);
#line 690
  tmp = skb_copy(ldv_func_arg1, flags);
#line 690
  return (tmp);
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_749(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 696
  ldv_check_alloc_flags(flags);
#line 698
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 698
  return (tmp);
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_750(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 704
  ldv_check_alloc_flags(flags);
#line 706
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 706
  return (tmp);
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_751(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 712
  ldv_check_alloc_flags(flags);
#line 714
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 714
  return (tmp);
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
int ldv_pskb_expand_head_752(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 720
  ldv_check_alloc_flags(flags);
#line 722
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 722
  return (tmp);
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
int ldv_pskb_expand_head_753(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 728
  ldv_check_alloc_flags(flags);
#line 730
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 730
  return (tmp);
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
struct sk_buff *ldv_skb_clone_754(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 736
  ldv_check_alloc_flags(flags);
#line 738
  tmp = skb_clone(ldv_func_arg1, flags);
#line 738
  return (tmp);
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sreset.o.c.prepared"
int ldv_mod_timer_755(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 745
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 745
  ldv_func_res = tmp;
#line 747
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 749
  return (ldv_func_res);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 248 "include/linux/timer.h"
int ldv_del_timer_sync_799(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_800(struct timer_list *ldv_func_arg1 ) ;
#line 256
int ldv_del_timer_sync_801(struct timer_list *ldv_func_arg1 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_782(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_790(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_798(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_792(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_788(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_796(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_797(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_793(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_794(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_795(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 357 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void rtw_free_xmitframe_queue23a(struct xmit_priv *pxmitpriv , struct rtw_queue *pframequeue ) ;
#line 371
void _rtw_init_sta_xmit_priv23a(struct sta_xmit_priv *psta_xmitpriv ) ;
#line 345 "drivers/staging/rtl8723au/include/sta_info.h"
__inline static u32 wifi_mac_hash(u8 const   *mac ) 
{ 
  u32 x ;

  {
#line 349
  x = (u32 )*mac;
#line 350
  x = (x << 2) ^ (u32 )*(mac + 1UL);
#line 351
  x = (x << 2) ^ (u32 )*(mac + 2UL);
#line 352
  x = (x << 2) ^ (u32 )*(mac + 3UL);
#line 353
  x = (x << 2) ^ (u32 )*(mac + 4UL);
#line 354
  x = (x << 2) ^ (u32 )*(mac + 5UL);
#line 356
  x = (x >> 8) ^ x;
#line 357
  x = x & 31U;
#line 359
  return (x);
}
}
#line 362
int _rtw_init_sta_priv23a(struct sta_priv *pstapriv ) ;
#line 363
int _rtw_free_sta_priv23a(struct sta_priv *pstapriv ) ;
#line 34 "drivers/staging/rtl8723au/include/recv_osdep.h"
void rtw_init_recv_timer23a(struct recv_reorder_ctrl *preorder_ctrl ) ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
static void _rtw_init_stainfo(struct sta_info *psta ) 
{ 
  struct lock_class_key __key ;

  {
#line 245
  memset((void *)psta, 0, 5656UL);
#line 246
  spinlock_check(& psta->lock);
#line 246
  __raw_spin_lock_init(& psta->lock.ldv_6347.rlock, "&(&psta->lock)->rlock", & __key);
#line 247
  INIT_LIST_HEAD(& psta->list);
#line 248
  INIT_LIST_HEAD(& psta->hash_list);
#line 249
  _rtw_init_queue23a(& psta->sleep_q);
#line 250
  psta->sleepq_len = 0U;
#line 251
  _rtw_init_sta_xmit_priv23a(& psta->sta_xmitpriv);
#line 252
  _rtw_init_sta_recv_priv23a(& psta->sta_recvpriv);
#line 254
  INIT_LIST_HEAD(& psta->asoc_list);
#line 255
  INIT_LIST_HEAD(& psta->auth_list);
#line 256
  psta->expire_to = 0U;
#line 257
  psta->flags = 0;
#line 258
  psta->capability = 0U;
#line 259
  psta->bpairwise_key_installed = 0U;
#line 260
  psta->nonerp_set = 0U;
#line 261
  psta->no_short_slot_time_set = 0U;
#line 262
  psta->no_short_preamble_set = 0U;
#line 263
  psta->no_ht_gf_set = 0U;
#line 264
  psta->no_ht_set = 0U;
#line 265
  psta->ht_20mhz_set = 0U;
#line 266
  psta->keep_alive_trycnt = 0U;
#line 267
  return;
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int _rtw_init_sta_priv23a(struct sta_priv *pstapriv ) 
{ 
  int i ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
#line 274
  spinlock_check(& pstapriv->sta_hash_lock);
#line 274
  __raw_spin_lock_init(& pstapriv->sta_hash_lock.ldv_6347.rlock, "&(&pstapriv->sta_hash_lock)->rlock",
                       & __key);
#line 275
  pstapriv->asoc_sta_count = 0;
#line 276
  i = 0;
#line 276
  goto ldv_54245;
  ldv_54244: 
#line 277
  INIT_LIST_HEAD((struct list_head *)(& pstapriv->sta_hash) + (unsigned long )i);
#line 276
  i = i + 1;
  ldv_54245: ;
#line 276
  if (i <= 31) {
#line 278
    goto ldv_54244;
  } else {

  }
#line 280
  pstapriv->sta_dz_bitmap = 0U;
#line 281
  pstapriv->tim_bitmap = 0U;
#line 282
  INIT_LIST_HEAD(& pstapriv->asoc_list);
#line 283
  INIT_LIST_HEAD(& pstapriv->auth_list);
#line 284
  spinlock_check(& pstapriv->asoc_list_lock);
#line 284
  __raw_spin_lock_init(& pstapriv->asoc_list_lock.ldv_6347.rlock, "&(&pstapriv->asoc_list_lock)->rlock",
                       & __key___0);
#line 285
  spinlock_check(& pstapriv->auth_list_lock);
#line 285
  __raw_spin_lock_init(& pstapriv->auth_list_lock.ldv_6347.rlock, "&(&pstapriv->auth_list_lock)->rlock",
                       & __key___1);
#line 286
  pstapriv->asoc_list_cnt = 0U;
#line 287
  pstapriv->auth_list_cnt = 0U;
#line 288
  pstapriv->auth_to = 3U;
#line 289
  pstapriv->assoc_to = 3U;
#line 292
  pstapriv->expire_to = 3U;
#line 293
  pstapriv->max_num_sta = 32U;
#line 295
  return (1);
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int _rtw_free_sta_priv23a(struct sta_priv *pstapriv ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  int index ;
  int i ;
  struct list_head  const  *__mptr ;

  {
#line 305
  if ((unsigned long )pstapriv != (unsigned long )((struct sta_priv *)0)) {
#line 307
    spin_lock_bh(& pstapriv->sta_hash_lock);
#line 308
    index = 0;
#line 308
    goto ldv_54268;
    ldv_54267: 
#line 309
    phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
#line 311
    plist = phead->next;
#line 311
    ptmp = plist->next;
#line 311
    goto ldv_54265;
    ldv_54264: 
#line 313
    __mptr = (struct list_head  const  *)plist;
#line 313
    psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
#line 315
    i = 0;
#line 315
    goto ldv_54262;
    ldv_54261: 
#line 316
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
#line 317
    ldv_del_timer_sync_799(& preorder_ctrl->reordering_ctrl_timer);
#line 315
    i = i + 1;
    ldv_54262: ;
#line 315
    if (i <= 15) {
#line 317
      goto ldv_54261;
    } else {

    }
#line 311
    plist = ptmp;
#line 311
    ptmp = plist->next;
    ldv_54265: ;
#line 311
    if ((unsigned long )plist != (unsigned long )phead) {
#line 313
      goto ldv_54264;
    } else {

    }
#line 308
    index = index + 1;
    ldv_54268: ;
#line 308
    if (index <= 31) {
#line 310
      goto ldv_54267;
    } else {

    }
#line 321
    spin_unlock_bh(& pstapriv->sta_hash_lock);
  } else {

  }
#line 324
  return (1);
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
struct sta_info *rtw_alloc_stainfo23a(struct sta_priv *pstapriv , u8 *hwaddr , gfp_t gfp ) 
{ 
  struct list_head *phash_list ;
  struct sta_info *psta ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  s32 index ;
  int i ;
  u16 wRxSeqInitialValue ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  u32 tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 334
  i = 0;
#line 335
  wRxSeqInitialValue = 65535U;
#line 337
  tmp = kmalloc(5656UL, gfp);
#line 337
  psta = (struct sta_info *)tmp;
#line 338
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 339
    return ((struct sta_info *)0);
  } else {

  }
#line 341
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 343
  _rtw_init_stainfo(psta);
#line 345
  psta->padapter = pstapriv->padapter;
#line 347
  __len = 6UL;
#line 347
  if (__len > 63UL) {
#line 347
    __ret = __memcpy((void *)(& psta->hwaddr), (void const   *)hwaddr, __len);
  } else {
#line 347
    __ret = __builtin_memcpy((void *)(& psta->hwaddr), (void const   *)hwaddr, __len);
  }
#line 349
  tmp___0 = wifi_mac_hash((u8 const   *)hwaddr);
#line 349
  index = (s32 )tmp___0;
#line 351
  if (GlobalDebugLevel23A > 6U) {
#line 351
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 7);
#line 351
    printk("\016rtw_alloc_stainfo23a: index  = %x", index);
  } else {

  }
#line 353
  if (index > 31) {
#line 354
    if (GlobalDebugLevel23A > 3U) {
#line 354
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 4);
#line 354
      printk("\016ERROR => rtw_alloc_stainfo23a: index >= NUM_STA");
    } else {

    }
#line 356
    psta = (struct sta_info *)0;
#line 357
    goto exit;
  } else {

  }
#line 359
  phash_list = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
#line 361
  list_add_tail(& psta->hash_list, phash_list);
#line 363
  pstapriv->asoc_sta_count = pstapriv->asoc_sta_count + 1;
#line 369
  i = 0;
#line 369
  goto ldv_54289;
  ldv_54288: 
#line 370
  __len___0 = 2UL;
#line 370
  if (__len___0 > 63UL) {
#line 370
    __ret___0 = __memcpy((void *)(& psta->sta_recvpriv.rxcache.tid_rxseq) + (unsigned long )i,
                         (void const   *)(& wRxSeqInitialValue), __len___0);
  } else {
#line 370
    __ret___0 = __builtin_memcpy((void *)(& psta->sta_recvpriv.rxcache.tid_rxseq) + (unsigned long )i,
                                 (void const   *)(& wRxSeqInitialValue), __len___0);
  }
#line 369
  i = i + 1;
  ldv_54289: ;
#line 369
  if (i <= 15) {
#line 371
    goto ldv_54288;
  } else {

  }

#line 372
  if (GlobalDebugLevel23A > 6U) {
#line 372
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 7);
#line 372
    printk("\016alloc number_%d stainfo  with hwaddr = %pM\n", pstapriv->asoc_sta_count,
           hwaddr);
  } else {

  }
#line 376
  init_addba_retry_timer23a(psta);
#line 379
  i = 0;
#line 379
  goto ldv_54292;
  ldv_54291: 
#line 380
  preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
#line 382
  preorder_ctrl->padapter = pstapriv->padapter;
#line 384
  preorder_ctrl->enable = 0U;
#line 386
  preorder_ctrl->indicate_seq = 65535U;
#line 387
  preorder_ctrl->wend_b = 65535U;
#line 389
  preorder_ctrl->wsize_b = 64U;
#line 391
  _rtw_init_queue23a(& preorder_ctrl->pending_recvframe_queue);
#line 393
  rtw_init_recv_timer23a(preorder_ctrl);
#line 379
  i = i + 1;
  ldv_54292: ;
#line 379
  if (i <= 15) {
#line 381
    goto ldv_54291;
  } else {

  }
#line 396
  psta->rssi_stat.UndecoratedSmoothedPWDB = -1;
#line 397
  psta->rssi_stat.UndecoratedSmoothedCCK = -1;
#line 400
  psta->RxMgmtFrameSeqNum = 65535U;
  exit: 
#line 402
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 403
  return (psta);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int rtw_free_stainfo23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_xmit_priv *pstaxmitpriv ;
  struct xmit_priv *pxmitpriv ;
  struct sta_priv *pstapriv ;
  struct hw_xmit *phwxmit ;
  int i ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct recv_frame *prframe ;
  struct rtw_queue *ppending_recvframe_queue ;
  struct list_head  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 411
  pxmitpriv = & padapter->xmitpriv;
#line 412
  pstapriv = & padapter->stapriv;
#line 416
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 417
    goto exit;
  } else {

  }
#line 419
  spin_lock_bh(& psta->lock);
#line 420
  psta->state = psta->state & 4294967294U;
#line 421
  spin_unlock_bh(& psta->lock);
#line 423
  pstaxmitpriv = & psta->sta_xmitpriv;
#line 425
  spin_lock_bh(& pxmitpriv->lock);
#line 427
  rtw_free_xmitframe_queue23a(pxmitpriv, & psta->sleep_q);
#line 428
  psta->sleepq_len = 0U;
#line 431
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->vo_q.sta_pending);
#line 432
  list_del_init(& pstaxmitpriv->vo_q.tx_pending);
#line 433
  phwxmit = pxmitpriv->hwxmits;
#line 434
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->vo_q.qcnt;
#line 435
  pstaxmitpriv->vo_q.qcnt = 0;
#line 438
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->vi_q.sta_pending);
#line 439
  list_del_init(& pstaxmitpriv->vi_q.tx_pending);
#line 440
  phwxmit = pxmitpriv->hwxmits + 1UL;
#line 441
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->vi_q.qcnt;
#line 442
  pstaxmitpriv->vi_q.qcnt = 0;
#line 445
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->be_q.sta_pending);
#line 446
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
#line 447
  phwxmit = pxmitpriv->hwxmits + 2UL;
#line 448
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->be_q.qcnt;
#line 449
  pstaxmitpriv->be_q.qcnt = 0;
#line 452
  rtw_free_xmitframe_queue23a(pxmitpriv, & pstaxmitpriv->bk_q.sta_pending);
#line 453
  list_del_init(& pstaxmitpriv->bk_q.tx_pending);
#line 454
  phwxmit = pxmitpriv->hwxmits + 3UL;
#line 455
  phwxmit->accnt = phwxmit->accnt - pstaxmitpriv->bk_q.qcnt;
#line 456
  pstaxmitpriv->bk_q.qcnt = 0;
#line 458
  spin_unlock_bh(& pxmitpriv->lock);
#line 460
  list_del_init(& psta->hash_list);
#line 461
  if (GlobalDebugLevel23A > 3U) {
#line 461
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 4);
#line 461
    printk("\016\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n",
           pstapriv->asoc_sta_count, (int )psta->hwaddr[0], (int )psta->hwaddr[1],
           (int )psta->hwaddr[2], (int )psta->hwaddr[3], (int )psta->hwaddr[4], (int )psta->hwaddr[5]);
  } else {

  }
#line 462
  pstapriv->asoc_sta_count = pstapriv->asoc_sta_count - 1;
#line 468
  ldv_del_timer_sync_800(& psta->addba_retry_timer);
#line 471
  i = 0;
#line 471
  goto ldv_54315;
  ldv_54314: 
#line 476
  preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )i;
#line 478
  ldv_del_timer_sync_801(& preorder_ctrl->reordering_ctrl_timer);
#line 480
  ppending_recvframe_queue = & preorder_ctrl->pending_recvframe_queue;
#line 482
  spin_lock_bh(& ppending_recvframe_queue->lock);
#line 483
  phead = get_list_head(ppending_recvframe_queue);
#line 484
  plist = phead->next;
#line 486
  goto ldv_54312;
  ldv_54311: 
#line 487
  __mptr = (struct list_head  const  *)plist;
#line 487
  prframe = (struct recv_frame *)__mptr;
#line 488
  plist = plist->next;
#line 489
  list_del_init(& prframe->list);
#line 490
  rtw_free_recvframe23a(prframe);
  ldv_54312: 
#line 486
  tmp = list_empty((struct list_head  const  *)phead);
#line 486
  if (tmp == 0) {
#line 488
    goto ldv_54311;
  } else {

  }
#line 492
  spin_unlock_bh(& ppending_recvframe_queue->lock);
#line 471
  i = i + 1;
  ldv_54315: ;
#line 471
  if (i <= 15) {
#line 473
    goto ldv_54314;
  } else {

  }

#line 494
  if ((psta->state & 16U) == 0U) {
#line 495
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 0);
  } else {

  }
#line 497
  spin_lock_bh(& pstapriv->auth_list_lock);
#line 498
  tmp___0 = list_empty((struct list_head  const  *)(& psta->auth_list));
#line 498
  if (tmp___0 == 0) {
#line 499
    list_del_init(& psta->auth_list);
#line 500
    pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
  } else {

  }
#line 502
  spin_unlock_bh(& pstapriv->auth_list_lock);
#line 504
  psta->expire_to = 0U;
#line 506
  psta->sleepq_ac_len = 0U;
#line 507
  psta->qos_info = 0U;
#line 509
  psta->max_sp_len = 0U;
#line 510
  psta->uapsd_bk = 0U;
#line 511
  psta->uapsd_be = 0U;
#line 512
  psta->uapsd_vi = 0U;
#line 513
  psta->uapsd_vo = 0U;
#line 515
  psta->has_legacy_ac = 0U;
#line 517
  tmp___1 = CHKBIT(psta->aid);
#line 517
  pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap & ~ ((int )((u16 )tmp___1));
#line 518
  tmp___2 = CHKBIT(psta->aid);
#line 518
  pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp___2));
#line 520
  if (psta->aid != 0U && (unsigned long )pstapriv->sta_aid[psta->aid - 1U] == (unsigned long )psta) {
#line 521
    pstapriv->sta_aid[psta->aid - 1U] = (struct sta_info *)0;
#line 522
    psta->aid = 0U;
  } else {

  }
#line 526
  kfree((void const   *)psta);
  exit: ;
#line 528
  return (1);
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
void rtw_free_all_stainfo23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct sta_info *pbcmc_stainfo ;
  struct sta_info *tmp ;
  s32 index ;
  struct list_head  const  *__mptr ;

  {
#line 536
  pstapriv = & padapter->stapriv;
#line 537
  tmp = rtw_get_bcmc_stainfo23a(padapter);
#line 537
  pbcmc_stainfo = tmp;
#line 540
  if (pstapriv->asoc_sta_count == 1) {
#line 541
    return;
  } else {

  }
#line 543
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 545
  index = 0;
#line 545
  goto ldv_54333;
  ldv_54332: 
#line 546
  phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
#line 548
  plist = phead->next;
#line 548
  ptmp = plist->next;
#line 548
  goto ldv_54330;
  ldv_54329: 
#line 549
  __mptr = (struct list_head  const  *)plist;
#line 549
  psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
#line 551
  if ((unsigned long )pbcmc_stainfo != (unsigned long )psta) {
#line 552
    rtw_free_stainfo23a(padapter, psta);
  } else {

  }
#line 548
  plist = ptmp;
#line 548
  ptmp = plist->next;
  ldv_54330: ;
#line 548
  if ((unsigned long )plist != (unsigned long )phead) {
#line 550
    goto ldv_54329;
  } else {

  }
#line 545
  index = index + 1;
  ldv_54333: ;
#line 545
  if (index <= 31) {
#line 547
    goto ldv_54332;
  } else {

  }
#line 555
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 556
  return;
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
struct sta_info *rtw_get_stainfo23a(struct sta_priv *pstapriv , u8 const   *hwaddr ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct sta_info *psta ;
  u32 index ;
  u8 const   *addr ;
  u8 bc_addr[6U] ;
  bool tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
#line 562
  psta = (struct sta_info *)0;
#line 565
  bc_addr[0] = 255U;
#line 565
  bc_addr[1] = 255U;
#line 565
  bc_addr[2] = 255U;
#line 565
  bc_addr[3] = 255U;
#line 565
  bc_addr[4] = 255U;
#line 565
  bc_addr[5] = 255U;
#line 567
  if ((unsigned long )hwaddr == (unsigned long )((u8 const   *)0U)) {
#line 568
    return ((struct sta_info *)0);
  } else {

  }
#line 570
  tmp = is_multicast_ether_addr(hwaddr);
#line 570
  if ((int )tmp) {
#line 571
    addr = (u8 const   *)(& bc_addr);
  } else {
#line 573
    addr = hwaddr;
  }
#line 575
  index = wifi_mac_hash(addr);
#line 577
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 579
  phead = (struct list_head *)(& pstapriv->sta_hash) + (unsigned long )index;
#line 581
  plist = phead->next;
#line 581
  goto ldv_54349;
  ldv_54348: 
#line 582
  __mptr = (struct list_head  const  *)plist;
#line 582
  psta = (struct sta_info *)__mptr + 0xffffffffffffffa8UL;
#line 584
  tmp___0 = memcmp((void const   *)(& psta->hwaddr), (void const   *)addr, 6UL);
#line 584
  if (tmp___0 == 0) {
#line 586
    goto ldv_54347;
  } else {

  }
#line 588
  psta = (struct sta_info *)0;
#line 581
  plist = plist->next;
  ldv_54349: ;
#line 581
  if ((unsigned long )plist != (unsigned long )phead) {
#line 583
    goto ldv_54348;
  } else {

  }
  ldv_54347: 
#line 590
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 591
  return (psta);
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int rtw_init_bcmc_stainfo23a(struct rtw_adapter *padapter ) 
{ 
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  int res ;
  unsigned char bcast_addr[6U] ;

  {
#line 596
  pstapriv = & padapter->stapriv;
#line 599
  res = 1;
#line 600
  bcast_addr[0] = 255U;
#line 600
  bcast_addr[1] = 255U;
#line 600
  bcast_addr[2] = 255U;
#line 600
  bcast_addr[3] = 255U;
#line 600
  bcast_addr[4] = 255U;
#line 600
  bcast_addr[5] = 255U;
#line 602
  psta = rtw_alloc_stainfo23a(pstapriv, (u8 *)(& bcast_addr), 208U);
#line 603
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 604
    res = 0;
#line 605
    if (GlobalDebugLevel23A > 3U) {
#line 605
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 64U, 4);
#line 605
      printk("\016rtw_alloc_stainfo23a fail");
    } else {

    }
#line 607
    return (res);
  } else {

  }
#line 610
  psta->mac_id = 1U;
#line 612
  ptxservq = & psta->sta_xmitpriv.be_q;
#line 613
  return (1);
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
struct sta_info *rtw_get_bcmc_stainfo23a(struct rtw_adapter *padapter ) 
{ 
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 bc_addr[6U] ;

  {
#line 619
  pstapriv = & padapter->stapriv;
#line 620
  bc_addr[0] = 255U;
#line 620
  bc_addr[1] = 255U;
#line 620
  bc_addr[2] = 255U;
#line 620
  bc_addr[3] = 255U;
#line 620
  bc_addr[4] = 255U;
#line 620
  bc_addr[5] = 255U;
#line 622
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& bc_addr));
#line 623
  return (psta);
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
bool rtw_access_ctrl23a(struct rtw_adapter *padapter , u8 *mac_addr ) 
{ 
  bool res ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_wlan_acl_node *paclnode ;
  bool match ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 628
  res = 1;
#line 632
  match = 0;
#line 633
  pstapriv = & padapter->stapriv;
#line 634
  pacl_list = & pstapriv->acl_list;
#line 635
  pacl_node_q = & pacl_list->acl_node_q;
#line 637
  spin_lock_bh(& pacl_node_q->lock);
#line 638
  phead = get_list_head(pacl_node_q);
#line 640
  plist = phead->next;
#line 640
  goto ldv_54380;
  ldv_54379: 
#line 641
  __mptr = (struct list_head  const  *)plist;
#line 641
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
#line 643
  tmp = memcmp((void const   *)(& paclnode->addr), (void const   *)mac_addr, 6UL);
#line 643
  if (tmp == 0) {
#line 644
    if ((unsigned int )paclnode->valid != 0U) {
#line 645
      match = 1;
#line 646
      goto ldv_54378;
    } else {

    }
  } else {

  }
#line 640
  plist = plist->next;
  ldv_54380: ;
#line 640
  if ((unsigned long )plist != (unsigned long )phead) {
#line 642
    goto ldv_54379;
  } else {

  }
  ldv_54378: 
#line 650
  spin_unlock_bh(& pacl_node_q->lock);
#line 652
  if (pacl_list->mode == 1) {
#line 653
    res = (int )match ? 0 : 1;
  } else
#line 654
  if (pacl_list->mode == 2) {
#line 655
    res = (int )match != 0;
  } else {
#line 657
    res = 1;
  }
#line 659
  return (res);
}
}
#line 789 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
void *ldv_kmem_cache_alloc_782(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 792
  ldv_check_alloc_flags(flags);
#line 794
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 795
  return ((void *)0);
}
}
#line 833 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int ldv_pskb_expand_head_788(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 836
  ldv_check_alloc_flags(flags);
#line 838
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 838
  return (tmp);
}
}
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
struct sk_buff *ldv_skb_clone_790(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 852
  ldv_check_alloc_flags(flags);
#line 854
  tmp = skb_clone(ldv_func_arg1, flags);
#line 854
  return (tmp);
}
}
#line 865 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
struct sk_buff *ldv_skb_copy_792(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 868
  ldv_check_alloc_flags(flags);
#line 870
  tmp = skb_copy(ldv_func_arg1, flags);
#line 870
  return (tmp);
}
}
#line 873 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_793(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 876
  ldv_check_alloc_flags(flags);
#line 878
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 878
  return (tmp);
}
}
#line 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_794(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 884
  ldv_check_alloc_flags(flags);
#line 886
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 886
  return (tmp);
}
}
#line 889 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_795(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 892
  ldv_check_alloc_flags(flags);
#line 894
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 894
  return (tmp);
}
}
#line 897 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int ldv_pskb_expand_head_796(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 900
  ldv_check_alloc_flags(flags);
#line 902
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 902
  return (tmp);
}
}
#line 905 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int ldv_pskb_expand_head_797(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 908
  ldv_check_alloc_flags(flags);
#line 910
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 910
  return (tmp);
}
}
#line 913 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
struct sk_buff *ldv_skb_clone_798(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 916
  ldv_check_alloc_flags(flags);
#line 918
  tmp = skb_clone(ldv_func_arg1, flags);
#line 918
  return (tmp);
}
}
#line 921 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int ldv_del_timer_sync_799(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 925
  tmp = del_timer_sync(ldv_func_arg1);
#line 925
  ldv_func_res = tmp;
#line 927
  disable_suitable_timer_6(ldv_func_arg1);
#line 929
  return (ldv_func_res);
}
}
#line 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int ldv_del_timer_sync_800(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 936
  tmp = del_timer_sync(ldv_func_arg1);
#line 936
  ldv_func_res = tmp;
#line 938
  disable_suitable_timer_6(ldv_func_arg1);
#line 940
  return (ldv_func_res);
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_sta_mgt.o.c.prepared"
int ldv_del_timer_sync_801(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 947
  tmp = del_timer_sync(ldv_func_arg1);
#line 947
  ldv_func_res = tmp;
#line 949
  disable_suitable_timer_6(ldv_func_arg1);
#line 951
  return (ldv_func_res);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 372
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 68 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/mutex-debug.h"
extern void mutex_destroy(struct mutex * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 95
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 106
extern void complete(struct completion * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_830(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_838(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_846(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_840(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_836(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_844(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_845(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_841(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_842(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_843(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 572 "include/linux/interrupt.h"
extern void tasklet_init(struct tasklet_struct * , void (*)(unsigned long  ) , unsigned long  ) ;
#line 198 "drivers/staging/rtl8723au/include/rtw_xmit.h"
void rtw23a_sctx_done_err(struct submit_ctx **sctx , int status ) ;
#line 199
void rtw_sctx_done23a(struct submit_ctx **sctx ) ;
#line 343
s32 rtw_free_xmitbuf_ext23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) ;
#line 346
struct xmit_buf *rtw_alloc_xmitbuf23a(struct xmit_priv *pxmitpriv ) ;
#line 349
void rtw_count_tx_stats23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ,
                           int sz ) ;
#line 352
s32 rtw_put_snap23a(u8 *data , u16 h_proto ) ;
#line 358
struct tx_servq *rtw_get_sta_pending23a(struct rtw_adapter *padapter , struct sta_info *psta ,
                                        int up___0 , u8 *ac ) ;
#line 360
s32 rtw_xmitframe_enqueue23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 362
struct xmit_frame *rtw_dequeue_xframe23a(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit_i ,
                                         int entry ) ;
#line 364
s32 rtw_xmit23a_classifier(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 366
u32 rtw_calculate_wlan_pkt_size_by_attribue23a(struct pkt_attrib *pattrib ) ;
#line 368
s32 rtw_xmitframe_coalesce23a(struct rtw_adapter *padapter , struct sk_buff *skb ,
                              struct xmit_frame *pxmitframe ) ;
#line 373
s32 rtw_txframes_pending23a(struct rtw_adapter *padapter ) ;
#line 374
s32 rtw_txframes_sta_ac_pending23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) ;
#line 376
void rtw_init_hwxmits23a(struct hw_xmit *phwxmit , int entry ) ;
#line 377
int _rtw_init_xmit_priv23a(struct xmit_priv *pxmitpriv , struct rtw_adapter *padapter ) ;
#line 379
void _rtw_free_xmit_priv23a(struct xmit_priv *pxmitpriv ) ;
#line 380
void rtw_alloc_hwxmits23a(struct rtw_adapter *padapter ) ;
#line 381
void rtw_free_hwxmits23a(struct rtw_adapter *padapter ) ;
#line 382
int rtw_xmit23a(struct rtw_adapter *padapter , struct sk_buff *skb ) ;
#line 384
int xmitframe_enqueue_for_sleeping_sta23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 391
u8 qos_acm23a(u8 acm_mask , u8 priority ) ;
#line 392
u32 rtw_get_ff_hwaddr23a(struct xmit_frame *pxmitframe ) ;
#line 394
void rtw_ack_tx_done23a(struct xmit_priv *pxmitpriv , int status ) ;
#line 28 "drivers/staging/rtl8723au/include/xmit_osdep.h"
int rtw_os_xmit_resource_alloc23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ,
                                  u32 alloc_sz ) ;
#line 30
void rtw_os_xmit_resource_free23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ) ;
#line 33
void rtw_os_pkt_complete23a(struct rtw_adapter *padapter , struct sk_buff *pkt ) ;
#line 34
void rtw_os_xmit_complete23a(struct rtw_adapter *padapter , struct xmit_frame *pxframe ) ;
#line 41 "drivers/staging/rtl8723au/include/usb_ops.h"
void rtl8723au_xmit_tasklet(void *priv ) ;
#line 222 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
bool rtl8723au_hal_xmit(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static u8 P802_1H_OUI[3U]  = {      0U,      0U,      248U};
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static u8 RFC1042_OUI[3U]  = {      0U,      0U,      0U};
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static void _init_txservq(struct tx_servq *ptxservq ) 
{ 


  {
#line 249
  INIT_LIST_HEAD(& ptxservq->tx_pending);
#line 250
  _rtw_init_queue23a(& ptxservq->sta_pending);
#line 251
  ptxservq->qcnt = 0;
#line 252
  return;
}
}
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void _rtw_init_sta_xmit_priv23a(struct sta_xmit_priv *psta_xmitpriv ) 
{ 
  struct lock_class_key __key ;

  {
#line 258
  spinlock_check(& psta_xmitpriv->lock);
#line 258
  __raw_spin_lock_init(& psta_xmitpriv->lock.ldv_6347.rlock, "&(&psta_xmitpriv->lock)->rlock",
                       & __key);
#line 263
  _init_txservq(& psta_xmitpriv->be_q);
#line 264
  _init_txservq(& psta_xmitpriv->bk_q);
#line 265
  _init_txservq(& psta_xmitpriv->vi_q);
#line 266
  _init_txservq(& psta_xmitpriv->vo_q);
#line 267
  INIT_LIST_HEAD(& psta_xmitpriv->legacy_dz);
#line 268
  INIT_LIST_HEAD(& psta_xmitpriv->apsd);
#line 269
  return;
}
}
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
int _rtw_init_xmit_priv23a(struct xmit_priv *pxmitpriv , struct rtw_adapter *padapter ) 
{ 
  int i ;
  struct xmit_buf *pxmitbuf ;
  struct xmit_frame *pxframe ;
  int res ;
  u32 max_xmit_extbuf_size ;
  u32 num_xmit_extbuf ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct lock_class_key __key___1 ;

  {
#line 278
  res = 1;
#line 279
  max_xmit_extbuf_size = 1536U;
#line 280
  num_xmit_extbuf = 32U;
#line 282
  spinlock_check(& pxmitpriv->lock);
#line 282
  __raw_spin_lock_init(& pxmitpriv->lock.ldv_6347.rlock, "&(&pxmitpriv->lock)->rlock",
                       & __key);
#line 283
  spinlock_check(& pxmitpriv->lock_sctx);
#line 283
  __raw_spin_lock_init(& pxmitpriv->lock_sctx.ldv_6347.rlock, "&(&pxmitpriv->lock_sctx)->rlock",
                       & __key___0);
#line 284
  sema_init(& pxmitpriv->xmit_sema, 0);
#line 285
  sema_init(& pxmitpriv->terminate_xmitthread_sema, 0);
#line 287
  pxmitpriv->adapter = padapter;
#line 289
  _rtw_init_queue23a(& pxmitpriv->be_pending);
#line 290
  _rtw_init_queue23a(& pxmitpriv->bk_pending);
#line 291
  _rtw_init_queue23a(& pxmitpriv->vi_pending);
#line 292
  _rtw_init_queue23a(& pxmitpriv->vo_pending);
#line 293
  _rtw_init_queue23a(& pxmitpriv->bm_pending);
#line 295
  _rtw_init_queue23a(& pxmitpriv->free_xmit_queue);
#line 297
  i = 0;
#line 297
  goto ldv_51630;
  ldv_51629: 
#line 298
  tmp = kzalloc(176UL, 208U);
#line 298
  pxframe = (struct xmit_frame *)tmp;
#line 299
  if ((unsigned long )pxframe == (unsigned long )((struct xmit_frame *)0)) {
#line 300
    goto ldv_51628;
  } else {

  }
#line 301
  INIT_LIST_HEAD(& pxframe->list);
#line 303
  pxframe->padapter = padapter;
#line 304
  pxframe->frame_tag = 0;
#line 306
  list_add_tail(& pxframe->list, & pxmitpriv->free_xmit_queue.queue);
#line 297
  i = i + 1;
  ldv_51630: ;
#line 297
  if (i <= 255) {
#line 299
    goto ldv_51629;
  } else {

  }
  ldv_51628: 
#line 310
  pxmitpriv->free_xmitframe_cnt = i;
#line 312
  pxmitpriv->frag_len = 2346U;
#line 315
  _rtw_init_queue23a(& pxmitpriv->free_xmitbuf_queue);
#line 316
  INIT_LIST_HEAD(& pxmitpriv->xmitbuf_list);
#line 317
  _rtw_init_queue23a(& pxmitpriv->pending_xmitbuf_queue);
#line 319
  i = 0;
#line 319
  goto ldv_51633;
  ldv_51632: 
#line 320
  tmp___0 = kzalloc(200UL, 208U);
#line 320
  pxmitbuf = (struct xmit_buf *)tmp___0;
#line 321
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 322
    goto fail;
  } else {

  }
#line 323
  INIT_LIST_HEAD(& pxmitbuf->list);
#line 324
  INIT_LIST_HEAD(& pxmitbuf->list2);
#line 326
  pxmitbuf->padapter = padapter;
#line 329
  res = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf, 2560U);
#line 331
  if (res == 0) {
#line 332
    goto fail;
  } else {

  }
#line 335
  list_add_tail(& pxmitbuf->list, & pxmitpriv->free_xmitbuf_queue.queue);
#line 337
  list_add_tail(& pxmitbuf->list2, & pxmitpriv->xmitbuf_list);
#line 319
  i = i + 1;
  ldv_51633: ;
#line 319
  if (i <= 3) {
#line 321
    goto ldv_51632;
  } else {

  }
#line 341
  pxmitpriv->free_xmitbuf_cnt = 4U;
#line 344
  _rtw_init_queue23a(& pxmitpriv->free_xframe_ext_queue);
#line 346
  i = 0;
#line 346
  goto ldv_51637;
  ldv_51636: 
#line 347
  tmp___1 = kzalloc(176UL, 208U);
#line 347
  pxframe = (struct xmit_frame *)tmp___1;
#line 348
  if ((unsigned long )pxframe == (unsigned long )((struct xmit_frame *)0)) {
#line 349
    goto ldv_51635;
  } else {

  }
#line 350
  INIT_LIST_HEAD(& pxframe->list);
#line 352
  pxframe->padapter = padapter;
#line 353
  pxframe->frame_tag = 0;
#line 355
  pxframe->pkt = (struct sk_buff *)0;
#line 357
  pxframe->buf_addr = (u8 *)0U;
#line 358
  pxframe->pxmitbuf = (struct xmit_buf *)0;
#line 360
  pxframe->ext_tag = 1U;
#line 362
  list_add_tail(& pxframe->list, & pxmitpriv->free_xframe_ext_queue.queue);
#line 346
  i = i + 1;
  ldv_51637: ;
#line 346
  if ((u32 )i < num_xmit_extbuf) {
#line 348
    goto ldv_51636;
  } else {

  }
  ldv_51635: 
#line 365
  pxmitpriv->free_xframe_ext_cnt = i;
#line 368
  _rtw_init_queue23a(& pxmitpriv->free_xmit_extbuf_queue);
#line 369
  INIT_LIST_HEAD(& pxmitpriv->xmitextbuf_list);
#line 371
  i = 0;
#line 371
  goto ldv_51640;
  ldv_51639: 
#line 372
  tmp___2 = kzalloc(200UL, 208U);
#line 372
  pxmitbuf = (struct xmit_buf *)tmp___2;
#line 373
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 374
    goto fail;
  } else {

  }
#line 375
  INIT_LIST_HEAD(& pxmitbuf->list);
#line 376
  INIT_LIST_HEAD(& pxmitbuf->list2);
#line 378
  pxmitbuf->padapter = padapter;
#line 381
  res = rtw_os_xmit_resource_alloc23a(padapter, pxmitbuf, max_xmit_extbuf_size + 512U);
#line 383
  if (res == 0) {
#line 384
    goto exit;
  } else {

  }
#line 387
  list_add_tail(& pxmitbuf->list, & pxmitpriv->free_xmit_extbuf_queue.queue);
#line 389
  list_add_tail(& pxmitbuf->list2, & pxmitpriv->xmitextbuf_list);
#line 371
  i = i + 1;
  ldv_51640: ;
#line 371
  if ((u32 )i < num_xmit_extbuf) {
#line 373
    goto ldv_51639;
  } else {

  }
#line 393
  pxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf;
#line 395
  rtw_alloc_hwxmits23a(padapter);
#line 396
  rtw_init_hwxmits23a(pxmitpriv->hwxmits, (int )pxmitpriv->hwxmit_entry);
#line 398
  i = 0;
#line 398
  goto ldv_51643;
  ldv_51642: 
#line 399
  pxmitpriv->wmm_para_seq[i] = (u8 )i;
#line 398
  i = i + 1;
  ldv_51643: ;
#line 398
  if (i <= 3) {
#line 400
    goto ldv_51642;
  } else {

  }
#line 401
  pxmitpriv->txirp_cnt = 1U;
#line 403
  sema_init(& pxmitpriv->tx_retevt, 0);
#line 406
  pxmitpriv->beq_cnt = 0;
#line 407
  pxmitpriv->bkq_cnt = 0;
#line 408
  pxmitpriv->viq_cnt = 0;
#line 409
  pxmitpriv->voq_cnt = 0;
#line 411
  pxmitpriv->ack_tx = 0;
#line 412
  __mutex_init(& pxmitpriv->ack_tx_mutex, "&pxmitpriv->ack_tx_mutex", & __key___1);
#line 413
  rtw_sctx_init23a(& pxmitpriv->ack_tx_ops, 0);
#line 414
  tasklet_init(& padapter->xmitpriv.xmit_tasklet, (void (*)(unsigned long  ))(& rtl8723au_xmit_tasklet),
               (unsigned long )padapter);
  exit: ;
#line 420
  return (res);
  fail: ;
#line 422
  goto exit;
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void _rtw_free_xmit_priv23a(struct xmit_priv *pxmitpriv ) 
{ 
  struct rtw_adapter *padapter ;
  struct xmit_frame *pxframe ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 427
  padapter = pxmitpriv->adapter;
#line 432
  plist = pxmitpriv->free_xmit_queue.queue.next;
#line 432
  ptmp = plist->next;
#line 432
  goto ldv_51658;
  ldv_51657: 
#line 433
  __mptr = (struct list_head  const  *)plist;
#line 433
  pxframe = (struct xmit_frame *)__mptr;
#line 434
  list_del_init(& pxframe->list);
#line 435
  rtw_os_xmit_complete23a(padapter, pxframe);
#line 436
  kfree((void const   *)pxframe);
#line 432
  plist = ptmp;
#line 432
  ptmp = plist->next;
  ldv_51658: ;
#line 432
  if ((unsigned long )(& pxmitpriv->free_xmit_queue.queue) != (unsigned long )plist) {
#line 434
    goto ldv_51657;
  } else {

  }
#line 439
  plist = pxmitpriv->xmitbuf_list.next;
#line 439
  ptmp = plist->next;
#line 439
  goto ldv_51663;
  ldv_51662: 
#line 440
  __mptr___0 = (struct list_head  const  *)plist;
#line 440
  pxmitbuf = (struct xmit_buf *)__mptr___0 + 0xfffffffffffffff0UL;
#line 441
  list_del_init(& pxmitbuf->list2);
#line 442
  rtw_os_xmit_resource_free23a(padapter, pxmitbuf);
#line 443
  kfree((void const   *)pxmitbuf);
#line 439
  plist = ptmp;
#line 439
  ptmp = plist->next;
  ldv_51663: ;
#line 439
  if ((unsigned long )(& pxmitpriv->xmitbuf_list) != (unsigned long )plist) {
#line 441
    goto ldv_51662;
  } else {

  }
#line 447
  plist = pxmitpriv->free_xframe_ext_queue.queue.next;
#line 447
  ptmp = plist->next;
#line 447
  goto ldv_51668;
  ldv_51667: 
#line 449
  __mptr___1 = (struct list_head  const  *)plist;
#line 449
  pxframe = (struct xmit_frame *)__mptr___1;
#line 450
  list_del_init(& pxframe->list);
#line 451
  rtw_os_xmit_complete23a(padapter, pxframe);
#line 452
  kfree((void const   *)pxframe);
#line 447
  plist = ptmp;
#line 447
  ptmp = plist->next;
  ldv_51668: ;
#line 447
  if ((unsigned long )(& pxmitpriv->free_xframe_ext_queue.queue) != (unsigned long )plist) {
#line 449
    goto ldv_51667;
  } else {

  }
#line 456
  plist = pxmitpriv->xmitextbuf_list.next;
#line 456
  ptmp = plist->next;
#line 456
  goto ldv_51673;
  ldv_51672: 
#line 457
  __mptr___2 = (struct list_head  const  *)plist;
#line 457
  pxmitbuf = (struct xmit_buf *)__mptr___2 + 0xfffffffffffffff0UL;
#line 458
  list_del_init(& pxmitbuf->list2);
#line 459
  rtw_os_xmit_resource_free23a(padapter, pxmitbuf);
#line 460
  kfree((void const   *)pxmitbuf);
#line 456
  plist = ptmp;
#line 456
  ptmp = plist->next;
  ldv_51673: ;
#line 456
  if ((unsigned long )(& pxmitpriv->xmitextbuf_list) != (unsigned long )plist) {
#line 458
    goto ldv_51672;
  } else {

  }
#line 463
  rtw_free_hwxmits23a(padapter);
#line 464
  mutex_destroy(& pxmitpriv->ack_tx_mutex);
#line 465
  return;
}
}
#line 467 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static void update_attrib_vcs_info(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  u32 sz ;
  struct pkt_attrib *pattrib ;
  struct sta_info *psta ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 HTOpMode ;

  {
#line 470
  pattrib = & pxmitframe->attrib;
#line 471
  psta = pattrib->psta;
#line 472
  pmlmeext = & padapter->mlmeextpriv;
#line 473
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 475
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 476
    psta = pattrib->psta;
  } else {
#line 478
    if (GlobalDebugLevel23A > 3U) {
#line 478
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "update_attrib_vcs_info");
    } else {

    }
#line 479
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 482
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 483
    if (GlobalDebugLevel23A > 3U) {
#line 483
      printk("\016RTL8723AU: %s, psta == NUL\n", "update_attrib_vcs_info");
    } else {

    }
#line 484
    return;
  } else {

  }
#line 487
  if ((psta->state & 1U) == 0U) {
#line 488
    if (GlobalDebugLevel23A > 3U) {
#line 488
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "update_attrib_vcs_info",
             psta->state);
    } else {

    }
#line 489
    return;
  } else {

  }
#line 492
  if ((unsigned int )pattrib->nr_frags != 1U) {
#line 493
    sz = padapter->xmitpriv.frag_len;
  } else {
#line 495
    sz = pattrib->last_txcmdsz;
  }
#line 501
  if ((unsigned int )pmlmeext->cur_wireless_mode <= 7U || (unsigned int )padapter->registrypriv.wifi_spec != 0U) {
#line 502
    if ((u32 )padapter->registrypriv.rts_thresh < sz) {
#line 503
      pattrib->vcs_mode = 1U;
    } else
#line 505
    if ((unsigned int )psta->rtsen != 0U) {
#line 506
      pattrib->vcs_mode = 1U;
    } else
#line 507
    if ((unsigned int )psta->cts2self != 0U) {
#line 508
      pattrib->vcs_mode = 2U;
    } else {
#line 510
      pattrib->vcs_mode = 0U;
    }
  } else {
    ldv_51687: ;
#line 515
    if (((unsigned int )pmlmeinfo->assoc_AP_vendor == 5U && (unsigned int )pattrib->ampdu_en != 0U) && padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 519
      pattrib->vcs_mode = 2U;
#line 520
      goto ldv_51685;
    } else {

    }
#line 524
    if ((unsigned int )psta->rtsen != 0U || (unsigned int )psta->cts2self != 0U) {
#line 525
      if ((unsigned int )psta->rtsen != 0U) {
#line 526
        pattrib->vcs_mode = 1U;
      } else
#line 527
      if ((unsigned int )psta->cts2self != 0U) {
#line 528
        pattrib->vcs_mode = 2U;
      } else {

      }
#line 530
      goto ldv_51685;
    } else {

    }
#line 534
    if ((unsigned int )pattrib->ht_en != 0U) {
#line 535
      HTOpMode = pmlmeinfo->HT_protection;
#line 536
      if (((unsigned int )pmlmeext->cur_bwmode != 0U && ((unsigned int )HTOpMode == 2U || (unsigned int )HTOpMode == 3U)) || ((unsigned int )pmlmeext->cur_bwmode == 0U && (unsigned int )HTOpMode == 3U)) {
#line 538
        pattrib->vcs_mode = 1U;
#line 539
        goto ldv_51685;
      } else {

      }
    } else {

    }
#line 544
    if ((u32 )padapter->registrypriv.rts_thresh < sz) {
#line 545
      pattrib->vcs_mode = 1U;
#line 546
      goto ldv_51685;
    } else {

    }
#line 552
    if ((unsigned int )pattrib->ampdu_en != 0U) {
#line 553
      pattrib->vcs_mode = 1U;
#line 554
      goto ldv_51685;
    } else {

    }
#line 557
    pattrib->vcs_mode = 0U;
#line 558
    goto ldv_51685;
#line 559
    goto ldv_51687;
    ldv_51685: ;
  }
#line 562
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static void update_attrib_phy_info(struct pkt_attrib *pattrib , struct sta_info *psta ) 
{ 


  {
#line 572
  pattrib->mdata = 0U;
#line 573
  pattrib->eosp = 0U;
#line 574
  pattrib->triggered = 0U;
#line 577
  pattrib->qos_en = (u8 )psta->qos_option;
#line 579
  pattrib->raid = psta->raid;
#line 580
  pattrib->ht_en = (u8 )psta->htpriv.ht_option;
#line 581
  pattrib->bwmode = psta->htpriv.bwmode;
#line 582
  pattrib->ch_offset = psta->htpriv.ch_offset;
#line 583
  pattrib->sgi = psta->htpriv.sgi;
#line 584
  pattrib->ampdu_en = 0U;
#line 586
  pattrib->retry_ctrl = 0U;
#line 587
  return;
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
u8 qos_acm23a(u8 acm_mask , u8 priority ) 
{ 
  u8 change_priority ;

  {
#line 591
  change_priority = priority;
#line 593
  switch ((int )priority) {
  case 0: ;
  case 3: ;
#line 596
  if (((unsigned long )acm_mask & 2UL) != 0UL) {
#line 597
    change_priority = 1U;
  } else {

  }
#line 598
  goto ldv_51699;
  case 1: ;
  case 2: ;
#line 601
  goto ldv_51699;
  case 4: ;
  case 5: ;
#line 604
  if (((unsigned long )acm_mask & 4UL) != 0UL) {
#line 605
    change_priority = 0U;
  } else {

  }
#line 606
  goto ldv_51699;
  case 6: ;
  case 7: ;
#line 609
  if (((unsigned long )acm_mask & 8UL) != 0UL) {
#line 610
    change_priority = 5U;
  } else {

  }
#line 611
  goto ldv_51699;
  default: ;
#line 613
  if (GlobalDebugLevel23A > 3U) {
#line 613
    printk("\016RTL8723AU: qos_acm23a(): invalid pattrib->priority: %d!!!\n", (int )priority);
  } else {

  }
#line 615
  change_priority = 0U;
#line 616
  goto ldv_51699;
  }
  ldv_51699: ;
#line 619
  return (change_priority);
}
}
#line 622 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static void set_qos(struct sk_buff *skb , struct pkt_attrib *pattrib ) 
{ 
  u8 *pframe ;
  struct iphdr *ip_hdr___0 ;
  u8 UserPriority ;

  {
#line 624
  pframe = skb->data;
#line 626
  UserPriority = 0U;
#line 629
  if ((unsigned int )pattrib->ether_type == 2048U) {
#line 630
    ip_hdr___0 = (struct iphdr *)pframe + 14U;
#line 631
    UserPriority = (u8 )((int )ip_hdr___0->tos >> 5);
  } else
#line 632
  if ((unsigned int )pattrib->ether_type == 34958U) {
#line 636
    UserPriority = 7U;
  } else {

  }
#line 639
  pattrib->priority = UserPriority;
#line 640
  pattrib->hdrlen = 26U;
#line 641
  pattrib->type = 136U;
#line 642
  return;
}
}
#line 644 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static int update_attrib(struct rtw_adapter *padapter , struct sk_buff *skb , struct pkt_attrib *pattrib ) 
{ 
  struct sta_info *psta ;
  int bmcast ;
  struct sta_priv *pstapriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  int res ;
  struct ethhdr *ehdr ;
  __u16 tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  u8 *pframe ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;

  {
#line 647
  psta = (struct sta_info *)0;
#line 649
  pstapriv = & padapter->stapriv;
#line 650
  psecuritypriv = & padapter->securitypriv;
#line 651
  pmlmepriv = & padapter->mlmepriv;
#line 652
  res = 1;
#line 653
  ehdr = (struct ethhdr *)skb->data;
#line 655
  tmp = __fswab16((int )ehdr->h_proto);
#line 655
  pattrib->ether_type = tmp;
#line 657
  ether_addr_copy((u8 *)(& pattrib->dst), (u8 const   *)(& ehdr->h_dest));
#line 658
  ether_addr_copy((u8 *)(& pattrib->src), (u8 const   *)(& ehdr->h_source));
#line 660
  pattrib->pctrl = 0U;
#line 662
  tmp___4 = check_fwstate(pmlmepriv, 32);
#line 662
  if ((int )tmp___4) {
#line 664
    ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 665
    ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
  } else {
#line 662
    tmp___5 = check_fwstate(pmlmepriv, 64);
#line 662
    if ((int )tmp___5) {
#line 664
      ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 665
      ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
    } else {
#line 666
      tmp___3 = check_fwstate(pmlmepriv, 8);
#line 666
      if ((int )tmp___3) {
#line 667
        tmp___0 = get_bssid(pmlmepriv);
#line 667
        ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)tmp___0);
#line 668
        ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)(& pattrib->src));
      } else {
#line 669
        tmp___2 = check_fwstate(pmlmepriv, 16);
#line 669
        if ((int )tmp___2) {
#line 670
          ether_addr_copy((u8 *)(& pattrib->ra), (u8 const   *)(& pattrib->dst));
#line 671
          tmp___1 = get_bssid(pmlmepriv);
#line 671
          ether_addr_copy((u8 *)(& pattrib->ta), (u8 const   *)tmp___1);
        } else {

        }
      }
    }
  }
#line 674
  pattrib->pktlen = skb->len - 14U;
#line 676
  if ((unsigned int )pattrib->ether_type == 2048U) {
#line 680
    pattrib->dhcp_pkt = 0U;
#line 682
    if (pattrib->pktlen > 306U) {
#line 683
      if ((unsigned int )pattrib->ether_type == 2048U) {
#line 684
        pframe = skb->data;
#line 685
        pframe = pframe + 14UL;
#line 687
        if (((unsigned int )*(pframe + 21UL) == 68U && (unsigned int )*(pframe + 23UL) == 67U) || ((unsigned int )*(pframe + 21UL) == 67U && (unsigned int )*(pframe + 23UL) == 68U)) {
#line 691
          if (GlobalDebugLevel23A > 3U) {
#line 691
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 691
            printk("\016======================update_attrib: get DHCP Packet\n");
          } else {

          }
#line 696
          pattrib->dhcp_pkt = 1U;
        } else {

        }
      } else {

      }
    } else {

    }
  } else
#line 700
  if ((unsigned int )pattrib->ether_type == 34958U) {
#line 701
    if (GlobalDebugLevel23A != 0U) {
#line 701
      printk("\016RTL8723AU: OLD_ERROR send eapol packet\n");
    } else {

    }
  } else {

  }
#line 704
  if ((unsigned int )pattrib->ether_type == 34958U || (unsigned int )pattrib->dhcp_pkt == 1U) {
#line 705
    rtw_set_scan_deny(padapter, 3000U);
  } else {

  }
#line 709
  if (((unsigned int )pattrib->ether_type == 2054U || (unsigned int )pattrib->ether_type == 34958U) || (unsigned int )pattrib->dhcp_pkt == 1U) {
#line 711
    rtw_lps_ctrl_wk_cmd23a(padapter, 4, 1);
  } else {

  }
#line 714
  tmp___6 = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 714
  bmcast = (int )tmp___6;
#line 717
  if (bmcast != 0) {
#line 718
    psta = rtw_get_bcmc_stainfo23a(padapter);
  } else {
#line 720
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
#line 721
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 722
      if (GlobalDebugLevel23A > 2U) {
#line 722
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 3);
#line 722
        printk("\016\nupdate_attrib => get sta_info fail, ra:%02x:%02x:%02x:%02x:%02x:%02x\n",
               (int )*((u8 *)(& pattrib->ra)), (int )*((u8 *)(& pattrib->ra) + 1UL),
               (int )*((u8 *)(& pattrib->ra) + 2UL), (int )*((u8 *)(& pattrib->ra) + 3UL),
               (int )*((u8 *)(& pattrib->ra) + 4UL), (int )*((u8 *)(& pattrib->ra) + 5UL));
      } else {

      }
#line 725
      res = 0;
#line 726
      goto exit;
    } else {
#line 727
      tmp___7 = check_fwstate(pmlmepriv, 16);
#line 727
      if ((int )tmp___7 && (psta->state & 1U) == 0U) {
#line 729
        res = 0;
#line 730
        goto exit;
      } else {

      }
    }
  }
#line 734
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 735
    pattrib->mac_id = (u8 )psta->mac_id;
#line 737
    pattrib->psta = psta;
  } else {
#line 740
    if (GlobalDebugLevel23A > 2U) {
#line 740
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 3);
#line 740
      printk("\016\nupdate_attrib => get sta_info fail, ra:%02x:%02x:%02x:%02x:%02x:%02x\n",
             (int )*((u8 *)(& pattrib->ra)), (int )*((u8 *)(& pattrib->ra) + 1UL),
             (int )*((u8 *)(& pattrib->ra) + 2UL), (int )*((u8 *)(& pattrib->ra) + 3UL),
             (int )*((u8 *)(& pattrib->ra) + 4UL), (int )*((u8 *)(& pattrib->ra) + 5UL));
    } else {

    }
#line 743
    res = 0;
#line 744
    goto exit;
  }
#line 747
  pattrib->ack_policy = 0U;
#line 751
  pattrib->pkt_hdrlen = 14U;
#line 753
  pattrib->hdrlen = 24U;
#line 754
  pattrib->type = 8U;
#line 755
  pattrib->priority = 0U;
#line 757
  tmp___8 = check_fwstate(pmlmepriv, 112);
#line 757
  if ((int )tmp___8) {
#line 759
    if (psta->qos_option != 0U) {
#line 760
      set_qos(skb, pattrib);
    } else {

    }
  } else
#line 762
  if (pmlmepriv->qos_option != 0U) {
#line 763
    set_qos(skb, pattrib);
#line 765
    if ((unsigned int )pmlmepriv->acm_mask != 0U) {
#line 766
      pattrib->priority = qos_acm23a((int )pmlmepriv->acm_mask, (int )pattrib->priority);
    } else {

    }
  } else {

  }
#line 772
  if (psta->ieee8021x_blocked == 1U) {
#line 773
    if (GlobalDebugLevel23A > 3U) {
#line 773
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 773
      printk("\016\n psta->ieee8021x_blocked == true\n");
    } else {

    }
#line 776
    pattrib->encrypt = 0U;
#line 778
    if ((unsigned int )pattrib->ether_type != 34958U) {
#line 778
      tmp___9 = check_fwstate(pmlmepriv, 65536);
#line 778
      if (tmp___9) {
#line 778
        tmp___10 = 0;
      } else {
#line 778
        tmp___10 = 1;
      }
#line 778
      if (tmp___10) {
#line 780
        if (GlobalDebugLevel23A > 3U) {
#line 780
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 780
          printk("\016\npsta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n",
                 (int )pattrib->ether_type);
        } else {

        }
#line 784
        res = 0;
#line 785
        goto exit;
      } else {

      }
    } else {

    }
  } else {
#line 788
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
#line 788
    pattrib->encrypt = psecuritypriv->dot11PrivacyAlgrthm;
#line 788
    goto ldv_51731;
    case 2U: ;
#line 788
    if (bmcast != 0) {
#line 788
      pattrib->encrypt = psecuritypriv->dot118021XGrpPrivacy;
    } else {
#line 788
      pattrib->encrypt = psta->dot118021XPrivacy;
    }
#line 788
    goto ldv_51731;
    }
    ldv_51731: ;
#line 790
    switch (psecuritypriv->dot11AuthAlgrthm) {
    case 0U: ;
    case 1U: ;
    case 3U: 
#line 794
    pattrib->key_idx = (unsigned char )psecuritypriv->dot11PrivacyKeyIndex;
#line 796
    goto ldv_51736;
    case 2U: ;
#line 798
    if (bmcast != 0) {
#line 799
      pattrib->key_idx = (unsigned char )psecuritypriv->dot118021XGrpKeyid;
    } else {
#line 802
      pattrib->key_idx = 0U;
    }
#line 803
    goto ldv_51736;
    default: 
#line 805
    pattrib->key_idx = 0U;
#line 806
    goto ldv_51736;
    }
    ldv_51736: ;
  }
#line 811
  switch (pattrib->encrypt) {
  case 1027073U: ;
  case 1027077U: 
#line 814
  pattrib->iv_len = 4U;
#line 815
  pattrib->icv_len = 4U;
#line 816
  goto ldv_51741;
  case 1027074U: 
#line 819
  pattrib->iv_len = 8U;
#line 820
  pattrib->icv_len = 4U;
#line 822
  if ((unsigned int )*((unsigned char *)padapter + 11436UL) == 0U) {
#line 823
    if (GlobalDebugLevel23A > 3U) {
#line 823
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 823
      printk("\016\npadapter->securitypriv.busetkipkey(%d) == false drop packet\n",
             (int )padapter->securitypriv.busetkipkey);
    } else {

    }
#line 827
    res = 0;
#line 828
    goto exit;
  } else {

  }
#line 831
  goto ldv_51741;
  case 1027076U: ;
#line 833
  if (GlobalDebugLevel23A > 6U) {
#line 833
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 833
    printk("\016pattrib->encrypt =%d (WLAN_CIPHER_SUITE_CCMP)\n", pattrib->encrypt);
  } else {

  }
#line 836
  pattrib->iv_len = 8U;
#line 837
  pattrib->icv_len = 8U;
#line 838
  goto ldv_51741;
  default: 
#line 841
  pattrib->iv_len = 0U;
#line 842
  pattrib->icv_len = 0U;
#line 843
  goto ldv_51741;
  }
  ldv_51741: ;
#line 846
  if (GlobalDebugLevel23A > 6U) {
#line 846
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 846
    printk("\016update_attrib: encrypt =%d\n", pattrib->encrypt);
  } else {

  }
#line 849
  if (pattrib->encrypt != 0U && (unsigned int )*((unsigned char *)psecuritypriv + 836UL) == 0U) {
#line 850
    pattrib->bswenc = 1U;
#line 851
    if (GlobalDebugLevel23A > 3U) {
#line 851
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 851
      printk("\016update_attrib: encrypt =%d bswenc = true\n", pattrib->encrypt);
    } else {

    }
  } else {
#line 855
    pattrib->bswenc = 0U;
#line 856
    if (GlobalDebugLevel23A > 6U) {
#line 856
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 856
      printk("\016update_attrib: bswenc = false\n");
    } else {

    }
  }
#line 859
  update_attrib_phy_info(pattrib, psta);
  exit: ;
#line 863
  return (res);
}
}
#line 866 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static int xmitframe_addmic(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct mic_data micdata ;
  struct sta_info *stainfo ;
  struct pkt_attrib *pattrib ;
  struct security_priv *psecuritypriv ;
  struct xmit_priv *pxmitpriv ;
  int curfragnum ;
  int length ;
  u8 *pframe ;
  u8 *payload ;
  u8 mic[8U] ;
  u8 priority[4U] ;
  u8 hw_hdr_offset ;
  int bmcst ;
  bool tmp ;
  u8 null_key[16U] ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 870
  pattrib = & pxmitframe->attrib;
#line 871
  psecuritypriv = & padapter->securitypriv;
#line 872
  pxmitpriv = & padapter->xmitpriv;
#line 875
  priority[0] = 0U;
#line 875
  priority[1] = 0U;
#line 875
  priority[2] = 0U;
#line 875
  priority[3] = 0U;
#line 876
  hw_hdr_offset = 0U;
#line 877
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 877
  bmcst = (int )tmp;
#line 879
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 880
    stainfo = pattrib->psta;
  } else {
#line 882
    if (GlobalDebugLevel23A > 3U) {
#line 882
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "xmitframe_addmic");
    } else {

    }
#line 883
    stainfo = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 886
  if ((unsigned long )stainfo == (unsigned long )((struct sta_info *)0)) {
#line 887
    if (GlobalDebugLevel23A > 3U) {
#line 887
      printk("\016RTL8723AU: %s, psta == NUL\n", "xmitframe_addmic");
    } else {

    }
#line 888
    return (0);
  } else {

  }
#line 891
  if ((stainfo->state & 1U) == 0U) {
#line 892
    if (GlobalDebugLevel23A > 3U) {
#line 892
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "xmitframe_addmic",
             stainfo->state);
    } else {

    }
#line 894
    return (0);
  } else {

  }
#line 897
  hw_hdr_offset = 40U;
#line 899
  if (pattrib->encrypt == 1027074U) {
#line 901
    if ((unsigned long )stainfo != (unsigned long )((struct sta_info *)0)) {
#line 902
      null_key[0] = 0U;
#line 902
      null_key[1] = 0U;
#line 902
      null_key[2] = 0U;
#line 902
      null_key[3] = 0U;
#line 902
      null_key[4] = 0U;
#line 902
      null_key[5] = 0U;
#line 902
      null_key[6] = 0U;
#line 902
      null_key[7] = 0U;
#line 902
      null_key[8] = 0U;
#line 902
      null_key[9] = 0U;
#line 902
      null_key[10] = 0U;
#line 902
      null_key[11] = 0U;
#line 902
      null_key[12] = 0U;
#line 902
      null_key[13] = 0U;
#line 902
      null_key[14] = 0U;
#line 902
      null_key[15] = 0U;
#line 907
      pframe = pxmitframe->buf_addr + (unsigned long )hw_hdr_offset;
#line 909
      if (bmcst != 0) {
#line 910
        tmp___0 = memcmp((void const   *)(& psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey),
                         (void const   *)(& null_key), 16UL);
#line 910
        if (tmp___0 == 0) {
#line 911
          return (0);
        } else {

        }
#line 914
        rtw_secmicsetkey23a(& micdata, (u8 *)(& psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey));
      } else {
#line 916
        tmp___1 = memcmp((void const   *)(& stainfo->dot11tkiptxmickey.skey), (void const   *)(& null_key),
                         16UL);
#line 916
        if (tmp___1 == 0) {
#line 918
          return (0);
        } else {

        }
#line 921
        rtw_secmicsetkey23a(& micdata, (u8 *)(& stainfo->dot11tkiptxmickey.skey));
      }
#line 924
      if ((int )*(pframe + 1UL) & 1) {
#line 926
        rtw_secmicappend23a(& micdata, pframe + 16UL, 6U);
#line 927
        if (((int )*(pframe + 1UL) & 2) != 0) {
#line 928
          rtw_secmicappend23a(& micdata, pframe + 24UL, 6U);
        } else {
#line 931
          rtw_secmicappend23a(& micdata, pframe + 10UL, 6U);
        }
      } else {
#line 935
        rtw_secmicappend23a(& micdata, pframe + 4UL, 6U);
#line 936
        if (((int )*(pframe + 1UL) & 2) != 0) {
#line 937
          rtw_secmicappend23a(& micdata, pframe + 16UL, 6U);
        } else {
#line 940
          rtw_secmicappend23a(& micdata, pframe + 10UL, 6U);
        }
      }
#line 945
      if ((unsigned int )pattrib->qos_en != 0U) {
#line 946
        priority[0] = pxmitframe->attrib.priority;
      } else {

      }
#line 948
      rtw_secmicappend23a(& micdata, (u8 *)(& priority), 4U);
#line 950
      payload = pframe;
#line 952
      curfragnum = 0;
#line 952
      goto ldv_51765;
      ldv_51764: 
#line 954
      payload = (u8 *)(((unsigned long )payload + 3UL) & 0xfffffffffffffffcUL);
#line 955
      if (GlobalDebugLevel23A > 3U) {
#line 955
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 955
        printk("\016=== curfragnum =%d, pframe = 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
               curfragnum, (int )*payload, (int )*(payload + 1UL), (int )*(payload + 2UL),
               (int )*(payload + 3UL), (int )*(payload + 4UL), (int )*(payload + 5UL),
               (int )*(payload + 6UL), (int )*(payload + 7UL));
      } else {

      }
#line 964
      payload = payload + ((unsigned long )pattrib->hdrlen + (unsigned long )pattrib->iv_len);
#line 966
      if (GlobalDebugLevel23A > 3U) {
#line 966
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 966
        printk("\016curfragnum =%d pattrib->hdrlen =%d pattrib->iv_len =%d", curfragnum,
               (int )pattrib->hdrlen, (int )pattrib->iv_len);
      } else {

      }
#line 970
      if (curfragnum + 1 == (int )pattrib->nr_frags) {
#line 971
        length = (int )(((pattrib->last_txcmdsz - (u32 )pattrib->hdrlen) - (u32 )pattrib->iv_len) - ((unsigned int )pattrib->bswenc != 0U ? (u32 )pattrib->icv_len : 0U));
#line 976
        rtw_secmicappend23a(& micdata, payload, (u32 )length);
#line 978
        payload = payload + (unsigned long )length;
      } else {
#line 980
        length = (int )(((pxmitpriv->frag_len - (uint )pattrib->hdrlen) - (uint )pattrib->iv_len) - ((unsigned int )pattrib->bswenc != 0U ? (uint )pattrib->icv_len : 0U));
#line 985
        rtw_secmicappend23a(& micdata, payload, (u32 )length);
#line 987
        payload = payload + ((unsigned long )length + (unsigned long )pattrib->icv_len);
#line 989
        if (GlobalDebugLevel23A > 3U) {
#line 989
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 989
          printk("\016curfragnum =%d length =%d pattrib->icv_len =%d", curfragnum,
                 length, (int )pattrib->icv_len);
        } else {

        }
      }
#line 953
      curfragnum = curfragnum + 1;
      ldv_51765: ;
#line 952
      if ((int )pattrib->nr_frags > curfragnum) {
#line 954
        goto ldv_51764;
      } else {

      }
#line 997
      rtw_secgetmic23a(& micdata, (u8 *)(& mic));
#line 998
      if (GlobalDebugLevel23A > 3U) {
#line 998
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 998
        printk("\016xmitframe_addmic: before add mic code!!\n");
      } else {

      }
#line 1000
      if (GlobalDebugLevel23A > 3U) {
#line 1000
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1000
        printk("\016xmitframe_addmic: pattrib->last_txcmdsz =%d!!!\n", pattrib->last_txcmdsz);
      } else {

      }
#line 1003
      if (GlobalDebugLevel23A > 3U) {
#line 1003
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1003
        printk("\016xmitframe_addmic: mic[0]= 0x%.2x , mic[1]=0x%.2x , mic[2]= 0x%.2x , mic[3]= 0x%.2x\nmic[4]= 0x%.2x , mic[5]= 0x%.2x , mic[6]= 0x%.2x , mic[7]= 0x%.2x !!!!\n",
               (int )mic[0], (int )mic[1], (int )mic[2], (int )mic[3], (int )mic[4],
               (int )mic[5], (int )mic[6], (int )mic[7]);
      } else {

      }
#line 1013
      __len = 8UL;
#line 1013
      if (__len > 63UL) {
#line 1013
        __ret = __memcpy((void *)payload, (void const   *)(& mic), __len);
      } else {
#line 1013
        __ret = __builtin_memcpy((void *)payload, (void const   *)(& mic), __len);
      }
#line 1014
      pattrib->last_txcmdsz = pattrib->last_txcmdsz + 8U;
#line 1016
      if (GlobalDebugLevel23A > 6U) {
#line 1016
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1016
        printk("\016\n ======== last pkt ========\n");
      } else {

      }
#line 1018
      payload = payload + (8UL - (unsigned long )pattrib->last_txcmdsz);
#line 1019
      curfragnum = 0;
#line 1019
      goto ldv_51771;
      ldv_51770: ;
#line 1021
      if (GlobalDebugLevel23A > 6U) {
#line 1021
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1021
        printk("\016 %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x ", (int )*(payload + (unsigned long )curfragnum),
               (int )*(payload + ((unsigned long )curfragnum + 1UL)), (int )*(payload + ((unsigned long )curfragnum + 2UL)),
               (int )*(payload + ((unsigned long )curfragnum + 3UL)), (int )*(payload + ((unsigned long )curfragnum + 4UL)),
               (int )*(payload + ((unsigned long )curfragnum + 5UL)), (int )*(payload + ((unsigned long )curfragnum + 6UL)),
               (int )*(payload + ((unsigned long )curfragnum + 7UL)));
      } else {

      }
#line 1020
      curfragnum = curfragnum + 8;
      ldv_51771: ;
#line 1019
      if ((u32 )curfragnum < pattrib->last_txcmdsz) {
#line 1021
        goto ldv_51770;
      } else {

      }

    } else
#line 1033
    if (GlobalDebugLevel23A > 3U) {
#line 1033
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1033
      printk("\016xmitframe_addmic: rtw_get_stainfo23a ==NULL!!!\n");
    } else {

    }
  } else {

  }
#line 1039
  return (1);
}
}
#line 1042 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static int xmitframe_swencrypt(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct pkt_attrib *pattrib ;

  {
#line 1045
  pattrib = & pxmitframe->attrib;
#line 1048
  if ((unsigned int )pattrib->bswenc != 0U) {
#line 1050
    if (GlobalDebugLevel23A > 2U) {
#line 1050
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 3);
#line 1050
      printk("\016### xmitframe_swencrypt\n");
    } else {

    }
#line 1052
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
#line 1055
    rtw_wep_encrypt23a(padapter, pxmitframe);
#line 1056
    goto ldv_51780;
    case 1027074U: 
#line 1058
    rtw_tkip_encrypt23a(padapter, pxmitframe);
#line 1059
    goto ldv_51780;
    case 1027076U: 
#line 1061
    rtw_aes_encrypt23a(padapter, pxmitframe);
#line 1062
    goto ldv_51780;
    default: ;
#line 1064
    goto ldv_51780;
    }
    ldv_51780: ;
  } else
#line 1068
  if (GlobalDebugLevel23A > 5U) {
#line 1068
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 6);
#line 1068
    printk("\016### xmitframe_hwencrypt\n");
  } else {

  }
#line 1072
  return (1);
}
}
#line 1075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static int rtw_make_wlanhdr(struct rtw_adapter *padapter , u8 *hdr , struct pkt_attrib *pattrib ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  struct ieee80211_qos_hdr *qoshdr ;
  struct mlme_priv *pmlmepriv ;
  u8 qos_option ;
  int res ;
  struct sta_info *psta ;
  int bmcst ;
  bool tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  u16 tx_seq ;

  {
#line 1078
  pwlanhdr = (struct ieee80211_hdr *)hdr;
#line 1080
  pmlmepriv = & padapter->mlmepriv;
#line 1081
  qos_option = 0U;
#line 1082
  res = 1;
#line 1086
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1086
  bmcst = (int )tmp;
#line 1088
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 1089
    psta = pattrib->psta;
  } else {
#line 1091
    if (GlobalDebugLevel23A > 3U) {
#line 1091
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_make_wlanhdr");
    } else {

    }
#line 1092
    if (bmcst != 0) {
#line 1093
      psta = rtw_get_bcmc_stainfo23a(padapter);
    } else {
#line 1095
      psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
    }
  }
#line 1099
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1100
    if (GlobalDebugLevel23A > 3U) {
#line 1100
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_make_wlanhdr");
    } else {

    }
#line 1101
    return (0);
  } else {

  }
#line 1104
  if ((psta->state & 1U) == 0U) {
#line 1105
    if (GlobalDebugLevel23A > 3U) {
#line 1105
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_make_wlanhdr",
             psta->state);
    } else {

    }
#line 1106
    return (0);
  } else {

  }
#line 1109
  memset((void *)hdr, 0, 64UL);
#line 1111
  pwlanhdr->frame_control = pattrib->type;
#line 1113
  if (((int )pattrib->type & 8) != 0) {
#line 1114
    tmp___7 = check_fwstate(pmlmepriv, 8);
#line 1114
    if ((int )tmp___7) {
#line 1117
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
#line 1119
      tmp___0 = get_bssid(pmlmepriv);
#line 1119
      ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)tmp___0);
#line 1120
      ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)(& pattrib->src));
#line 1121
      ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& pattrib->dst));
#line 1123
      if (pmlmepriv->qos_option != 0U) {
#line 1124
        qos_option = 1U;
      } else {

      }
    } else {
#line 1126
      tmp___6 = check_fwstate(pmlmepriv, 16);
#line 1126
      if ((int )tmp___6) {
#line 1128
        pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
#line 1130
        ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& pattrib->dst));
#line 1131
        tmp___1 = get_bssid(pmlmepriv);
#line 1131
        ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)tmp___1);
#line 1132
        ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& pattrib->src));
#line 1134
        if (psta->qos_option != 0U) {
#line 1135
          qos_option = 1U;
        } else {

        }
      } else {
#line 1136
        tmp___4 = check_fwstate(pmlmepriv, 32);
#line 1136
        if ((int )tmp___4) {
#line 1136
          goto _L;
        } else {
#line 1136
          tmp___5 = check_fwstate(pmlmepriv, 64);
#line 1136
          if ((int )tmp___5) {
            _L: /* CIL Label */ 
#line 1138
            ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)(& pattrib->dst));
#line 1139
            ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)(& pattrib->src));
#line 1140
            tmp___2 = get_bssid(pmlmepriv);
#line 1140
            ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___2);
#line 1142
            if (psta->qos_option != 0U) {
#line 1143
              qos_option = 1U;
            } else {

            }
          } else {
#line 1146
            if (GlobalDebugLevel23A > 3U) {
#line 1146
              printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1146
              tmp___3 = get_fwstate(pmlmepriv);
#line 1146
              printk("\016fw_state:%x is not allowed to xmit frame\n", tmp___3);
            } else {

            }
#line 1147
            res = 0;
#line 1148
            goto exit;
          }
        }
      }
    }
#line 1150
    if ((unsigned int )pattrib->mdata != 0U) {
#line 1151
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 8192U);
    } else {

    }
#line 1153
    if (pattrib->encrypt != 0U) {
#line 1154
      pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 16384U);
    } else {

    }
#line 1156
    if ((unsigned int )qos_option != 0U) {
#line 1157
      qoshdr = (struct ieee80211_qos_hdr *)hdr;
#line 1159
      qoshdr->qos_ctrl = (unsigned int )((unsigned short )pattrib->priority) & 15U;
#line 1162
      qoshdr->qos_ctrl = (__le16 )((int )((short )qoshdr->qos_ctrl) | ((int )((short )((int )pattrib->ack_policy << 5)) & 96));
#line 1166
      if ((unsigned int )pattrib->eosp != 0U) {
#line 1167
        qoshdr->qos_ctrl = (__le16 )((unsigned int )qoshdr->qos_ctrl | 16U);
      } else {

      }
    } else {

    }
#line 1173
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1174
      psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] = (u16 )((int )psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] + 1);
#line 1175
      psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] = (unsigned int )psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority] & 4095U;
#line 1176
      pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[(int )pattrib->priority];
#line 1178
      pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pattrib->seqnum << 4)) & 65520U;
#line 1181
      if ((unsigned int )pattrib->ht_en != 0U && psta->htpriv.ampdu_enable != 0U) {
#line 1182
        if ((unsigned int )pattrib->priority > 15U) {
#line 1183
          printk("\f%s: Invalid pattrib->priority %i\n", "rtw_make_wlanhdr", (int )pattrib->priority);
        } else {

        }
#line 1186
        if ((int )((unsigned long )psta->htpriv.agg_enable_bitmap >> (int )pattrib->priority) & 1) {
#line 1188
          pattrib->ampdu_en = 1U;
        } else {

        }
      } else {

      }
#line 1191
      if ((unsigned int )pattrib->ampdu_en != 0U) {
#line 1194
        tx_seq = psta->BA_starting_seqctrl[(int )pattrib->priority & 15];
#line 1197
        if ((((int )pattrib->seqnum - (int )tx_seq) & 2048) != 0) {
#line 1199
          pattrib->ampdu_en = 0U;
        } else
#line 1200
        if ((int )pattrib->seqnum == (int )tx_seq) {
#line 1201
          psta->BA_starting_seqctrl[(int )pattrib->priority & 15] = (unsigned int )((u16 )((unsigned int )tx_seq + 1U)) & 4095U;
#line 1202
          pattrib->ampdu_en = 1U;
        } else {
#line 1205
          psta->BA_starting_seqctrl[(int )pattrib->priority & 15] = (unsigned int )((u16 )((unsigned int )pattrib->seqnum + 1U)) & 4095U;
#line 1206
          pattrib->ampdu_en = 1U;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  exit: ;
#line 1212
  return (res);
}
}
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
s32 rtw_txframes_pending23a(struct rtw_adapter *padapter ) 
{ 
  struct xmit_priv *pxmitpriv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1217
  pxmitpriv = & padapter->xmitpriv;
#line 1219
  tmp = list_empty((struct list_head  const  *)(& pxmitpriv->be_pending.queue));
#line 1219
  if (tmp == 0) {
#line 1219
    tmp___3 = 1;
  } else {
#line 1219
    tmp___0 = list_empty((struct list_head  const  *)(& pxmitpriv->bk_pending.queue));
#line 1219
    if (tmp___0 == 0) {
#line 1219
      tmp___3 = 1;
    } else {
#line 1219
      tmp___1 = list_empty((struct list_head  const  *)(& pxmitpriv->vi_pending.queue));
#line 1219
      if (tmp___1 == 0) {
#line 1219
        tmp___3 = 1;
      } else {
#line 1219
        tmp___2 = list_empty((struct list_head  const  *)(& pxmitpriv->vo_pending.queue));
#line 1219
        if (tmp___2 == 0) {
#line 1219
          tmp___3 = 1;
        } else {
#line 1219
          tmp___3 = 0;
        }
      }
    }
  }
#line 1219
  return (tmp___3);
}
}
#line 1225 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
s32 rtw_txframes_sta_ac_pending23a(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) 
{ 
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  int priority ;

  {
#line 1230
  priority = (int )pattrib->priority;
#line 1232
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 1233
    psta = pattrib->psta;
  } else {
#line 1235
    if (GlobalDebugLevel23A > 3U) {
#line 1235
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_txframes_sta_ac_pending23a");
    } else {

    }
#line 1236
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 1238
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1239
    if (GlobalDebugLevel23A > 3U) {
#line 1239
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_txframes_sta_ac_pending23a");
    } else {

    }
#line 1240
    return (0);
  } else {

  }
#line 1242
  if ((psta->state & 1U) == 0U) {
#line 1243
    if (GlobalDebugLevel23A > 3U) {
#line 1243
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_txframes_sta_ac_pending23a",
             psta->state);
    } else {

    }
#line 1245
    return (0);
  } else {

  }
#line 1247
  switch (priority) {
  case 1: ;
  case 2: 
#line 1250
  ptxservq = & psta->sta_xmitpriv.bk_q;
#line 1251
  goto ldv_51813;
  case 4: ;
  case 5: 
#line 1254
  ptxservq = & psta->sta_xmitpriv.vi_q;
#line 1255
  goto ldv_51813;
  case 6: ;
  case 7: 
#line 1258
  ptxservq = & psta->sta_xmitpriv.vo_q;
#line 1259
  goto ldv_51813;
  case 0: ;
  case 3: ;
  default: 
#line 1263
  ptxservq = & psta->sta_xmitpriv.be_q;
#line 1264
  goto ldv_51813;
  }
  ldv_51813: ;
#line 1266
  return (ptxservq->qcnt);
}
}
#line 1273 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
u32 rtw_calculate_wlan_pkt_size_by_attribue23a(struct pkt_attrib *pattrib ) 
{ 
  u32 len ;

  {
#line 1275
  len = 0U;
#line 1277
  len = (u32 )((int )pattrib->hdrlen + (int )pattrib->iv_len);
#line 1278
  len = len + 8U;
#line 1279
  len = pattrib->pktlen + len;
#line 1280
  if (pattrib->encrypt == 1027074U) {
#line 1280
    len = len + 8U;
  } else {

  }
#line 1281
  len = ((unsigned int )pattrib->bswenc != 0U ? (u32 )pattrib->icv_len : 0U) + len;
#line 1283
  return (len);
}
}
#line 1298 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
s32 rtw_xmitframe_coalesce23a(struct rtw_adapter *padapter , struct sk_buff *skb ,
                              struct xmit_frame *pxmitframe ) 
{ 
  struct sta_info *psta ;
  struct xmit_priv *pxmitpriv ;
  struct pkt_attrib *pattrib ;
  struct ieee80211_hdr *hdr ;
  s32 frg_inx ;
  s32 frg_len ;
  s32 mpdu_len ;
  s32 llc_sz ;
  s32 mem_sz ;
  u8 *pframe ;
  u8 *mem_start ;
  u8 hw_hdr_offset ;
  u8 *pbuf_start ;
  u8 *pdata ;
  int data_len ;
  s32 bmcst ;
  bool tmp ;
  int res ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  s32 __min1 ;
  s32 __min2 ;
  s32 __min1___0 ;
  s32 __min2___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  int tmp___1 ;

  {
#line 1302
  pxmitpriv = & padapter->xmitpriv;
#line 1303
  pattrib = & pxmitframe->attrib;
#line 1309
  pdata = skb->data;
#line 1310
  data_len = (int )skb->len;
#line 1311
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 1311
  bmcst = (s32 )tmp;
#line 1312
  res = 1;
#line 1314
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 1315
    psta = pattrib->psta;
  } else {
#line 1317
    if (GlobalDebugLevel23A > 3U) {
#line 1317
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
#line 1318
    psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pattrib->ra));
  }
#line 1321
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1322
    if (GlobalDebugLevel23A > 3U) {
#line 1322
      printk("\016RTL8723AU: %s, psta == NUL\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
#line 1323
    return (0);
  } else {

  }
#line 1326
  if ((psta->state & 1U) == 0U) {
#line 1327
    if (GlobalDebugLevel23A > 3U) {
#line 1327
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_xmitframe_coalesce23a",
             psta->state);
    } else {

    }
#line 1329
    return (0);
  } else {

  }
#line 1332
  if ((unsigned long )pxmitframe->buf_addr == (unsigned long )((u8 *)0U)) {
#line 1333
    if (GlobalDebugLevel23A > 3U) {
#line 1333
      printk("\016RTL8723AU: ==> %s buf_addr == NULL\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
#line 1334
    return (0);
  } else {

  }
#line 1337
  pbuf_start = pxmitframe->buf_addr;
#line 1339
  hw_hdr_offset = 40U;
#line 1341
  mem_start = pbuf_start + (unsigned long )hw_hdr_offset;
#line 1343
  tmp___0 = rtw_make_wlanhdr(padapter, mem_start, pattrib);
#line 1343
  if (tmp___0 == 0) {
#line 1344
    if (GlobalDebugLevel23A > 3U) {
#line 1344
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1344
      printk("\016%s: rtw_make_wlanhdr fail; drop pkt\n", "rtw_xmitframe_coalesce23a");
    } else {

    }
#line 1346
    res = 0;
#line 1347
    goto exit;
  } else {

  }
#line 1350
  pdata = pdata + (unsigned long )pattrib->pkt_hdrlen;
#line 1351
  data_len = data_len - (int )pattrib->pkt_hdrlen;
#line 1353
  frg_inx = 0;
#line 1354
  frg_len = (s32 )(pxmitpriv->frag_len - 4U);
  ldv_51873: 
#line 1357
  llc_sz = 0;
#line 1359
  mpdu_len = frg_len;
#line 1361
  pframe = mem_start;
#line 1362
  hdr = (struct ieee80211_hdr *)mem_start;
#line 1364
  pframe = pframe + (unsigned long )pattrib->hdrlen;
#line 1365
  mpdu_len = mpdu_len - (int )pattrib->hdrlen;
#line 1368
  if ((unsigned int )pattrib->iv_len != 0U) {
#line 1369
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1370
      switch (pattrib->encrypt) {
      case 1027073U: ;
      case 1027077U: 
#line 1373
      pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
#line 1373
      pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
#line 1373
      pattrib->iv[2] = psta->dot11txpn._byte_.TSC2;
#line 1373
      pattrib->iv[3] = (u8 )((int )pattrib->key_idx << 6);
#line 1373
      psta->dot11txpn.val = psta->dot11txpn.val != 16777215ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
#line 1375
      goto ldv_51851;
      case 1027074U: ;
#line 1377
      if (bmcst != 0) {
#line 1378
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC1;
#line 1378
        pattrib->iv[1] = ((unsigned int )psta->dot11txpn._byte_.TSC1 & 95U) | 32U;
#line 1378
        pattrib->iv[2] = psta->dot11txpn._byte_.TSC0;
#line 1378
        pattrib->iv[3] = (u8 )((int )((signed char )((int )pattrib->key_idx << 6)) | 32);
#line 1378
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
#line 1378
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
#line 1378
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
#line 1378
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
#line 1378
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      } else {
#line 1382
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC1;
#line 1382
        pattrib->iv[1] = ((unsigned int )psta->dot11txpn._byte_.TSC1 & 95U) | 32U;
#line 1382
        pattrib->iv[2] = psta->dot11txpn._byte_.TSC0;
#line 1382
        pattrib->iv[3] = 32U;
#line 1382
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
#line 1382
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
#line 1382
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
#line 1382
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
#line 1382
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      }
#line 1384
      goto ldv_51851;
      case 1027076U: ;
#line 1386
      if (bmcst != 0) {
#line 1387
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
#line 1387
        pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
#line 1387
        pattrib->iv[2] = 0U;
#line 1387
        pattrib->iv[3] = (u8 )((int )((signed char )((int )pattrib->key_idx << 6)) | 32);
#line 1387
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
#line 1387
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
#line 1387
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
#line 1387
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
#line 1387
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      } else {
#line 1391
        pattrib->iv[0] = psta->dot11txpn._byte_.TSC0;
#line 1391
        pattrib->iv[1] = psta->dot11txpn._byte_.TSC1;
#line 1391
        pattrib->iv[2] = 0U;
#line 1391
        pattrib->iv[3] = 32U;
#line 1391
        pattrib->iv[4] = psta->dot11txpn._byte_.TSC2;
#line 1391
        pattrib->iv[5] = psta->dot11txpn._byte_.TSC3;
#line 1391
        pattrib->iv[6] = psta->dot11txpn._byte_.TSC4;
#line 1391
        pattrib->iv[7] = psta->dot11txpn._byte_.TSC5;
#line 1391
        psta->dot11txpn.val = psta->dot11txpn.val != 281474976710655ULL ? psta->dot11txpn.val + 1ULL : 0ULL;
      }
#line 1393
      goto ldv_51851;
      }
      ldv_51851: ;
    } else {

    }
#line 1397
    __len = (size_t )pattrib->iv_len;
#line 1397
    __ret = __builtin_memcpy((void *)pframe, (void const   *)(& pattrib->iv), __len);
#line 1399
    if (GlobalDebugLevel23A > 5U) {
#line 1399
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 6);
#line 1399
      printk("\016rtw_xmiaframe_coalesce23a: keyid =%d pattrib->iv[3]=%.2x pframe =%.2x %.2x %.2x %.2x\n",
             padapter->securitypriv.dot11PrivacyKeyIndex, (int )pattrib->iv[3], (int )*pframe,
             (int )*(pframe + 1UL), (int )*(pframe + 2UL), (int )*(pframe + 3UL));
    } else {

    }
#line 1405
    pframe = pframe + (unsigned long )pattrib->iv_len;
#line 1406
    mpdu_len = mpdu_len - (int )pattrib->iv_len;
  } else {

  }
#line 1408
  if (frg_inx == 0) {
#line 1409
    llc_sz = rtw_put_snap23a(pframe, (int )pattrib->ether_type);
#line 1410
    pframe = pframe + (unsigned long )llc_sz;
#line 1411
    mpdu_len = mpdu_len - llc_sz;
  } else {

  }
#line 1414
  if ((unsigned int )pattrib->icv_len != 0U && (unsigned int )pattrib->bswenc != 0U) {
#line 1415
    mpdu_len = mpdu_len - (int )pattrib->icv_len;
  } else {

  }
#line 1417
  if (bmcst != 0) {
#line 1419
    __min1 = data_len;
#line 1419
    __min2 = (s32 )pattrib->pktlen;
#line 1419
    mem_sz = __min1 < __min2 ? __min1 : __min2;
  } else {
#line 1421
    __min1___0 = data_len;
#line 1421
    __min2___0 = mpdu_len;
#line 1421
    mem_sz = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
  }
#line 1423
  __len___0 = (size_t )mem_sz;
#line 1423
  __ret___0 = __builtin_memcpy((void *)pframe, (void const   *)pdata, __len___0);
#line 1425
  pframe = pframe + (unsigned long )mem_sz;
#line 1426
  pdata = pdata + (unsigned long )mem_sz;
#line 1427
  data_len = data_len - mem_sz;
#line 1429
  if ((unsigned int )pattrib->icv_len != 0U && (unsigned int )pattrib->bswenc != 0U) {
#line 1430
    __len___1 = (size_t )pattrib->icv_len;
#line 1430
    __ret___1 = __builtin_memcpy((void *)pframe, (void const   *)(& pattrib->icv),
                                 __len___1);
#line 1431
    pframe = pframe + (unsigned long )pattrib->icv_len;
  } else {

  }
#line 1434
  frg_inx = frg_inx + 1;
#line 1436
  if (bmcst != 0 || data_len <= 0) {
#line 1437
    pattrib->nr_frags = (u8 )frg_inx;
#line 1439
    pattrib->last_txcmdsz = (u32 )(((((int )pattrib->hdrlen + (int )pattrib->iv_len) + ((unsigned int )pattrib->nr_frags == 1U ? llc_sz : 0)) + ((unsigned int )pattrib->bswenc != 0U ? (int )pattrib->icv_len : 0)) + mem_sz);
#line 1445
    hdr->frame_control = (unsigned int )hdr->frame_control & 64511U;
#line 1448
    goto ldv_51869;
  } else
#line 1450
  if (GlobalDebugLevel23A > 3U) {
#line 1450
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1450
    printk("\016%s: There\'re still something in packet!\n", "rtw_xmitframe_coalesce23a");
  } else {

  }
#line 1454
  hdr->frame_control = (__le16 )((unsigned int )hdr->frame_control | 1024U);
#line 1456
  mem_start = (u8 *)((unsigned long )hw_hdr_offset + (((unsigned long )pframe + 3UL) & 0xfffffffffffffffcUL));
#line 1457
  __len___2 = (size_t )pattrib->hdrlen;
#line 1457
  __ret___2 = __builtin_memcpy((void *)mem_start, (void const   *)pbuf_start + (unsigned long )hw_hdr_offset,
                               __len___2);
#line 1458
  goto ldv_51873;
  ldv_51869: 
#line 1460
  tmp___1 = xmitframe_addmic(padapter, pxmitframe);
#line 1460
  if (tmp___1 == 0) {
#line 1461
    if (GlobalDebugLevel23A > 3U) {
#line 1461
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1461
      printk("\016xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");
    } else {

    }
#line 1463
    if (GlobalDebugLevel23A > 3U) {
#line 1463
      printk("\016RTL8723AU: xmitframe_addmic(padapter, pxmitframe) == _FAIL\n");
    } else {

    }
#line 1464
    res = 0;
#line 1465
    goto exit;
  } else {

  }
#line 1468
  xmitframe_swencrypt(padapter, pxmitframe);
#line 1470
  if (bmcst == 0) {
#line 1471
    update_attrib_vcs_info(padapter, pxmitframe);
  } else {
#line 1473
    pattrib->vcs_mode = 0U;
  }
  exit: ;
#line 1476
  return (res);
}
}
#line 1486 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
s32 rtw_put_snap23a(u8 *data , u16 h_proto ) 
{ 
  struct ieee80211_snap_hdr *snap ;
  u8 *oui ;
  __u16 tmp ;

  {
#line 1491
  snap = (struct ieee80211_snap_hdr *)data;
#line 1492
  snap->dsap = 170U;
#line 1493
  snap->ssap = 170U;
#line 1494
  snap->ctrl = 3U;
#line 1496
  if ((unsigned int )h_proto == 33079U || (unsigned int )h_proto == 33011U) {
#line 1497
    oui = (u8 *)(& P802_1H_OUI);
  } else {
#line 1499
    oui = (u8 *)(& RFC1042_OUI);
  }
#line 1500
  snap->oui[0] = *oui;
#line 1501
  snap->oui[1] = *(oui + 1UL);
#line 1502
  snap->oui[2] = *(oui + 2UL);
#line 1503
  tmp = __fswab16((int )h_proto);
#line 1503
  *((u16 *)data + 6U) = tmp;
#line 1504
  return (8);
}
}
#line 1507 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw_update_protection23a(struct rtw_adapter *padapter , u8 *ie , uint ie_len ) 
{ 
  struct xmit_priv *pxmitpriv ;
  struct registry_priv *pregistrypriv ;
  uint protection ;
  u8 const   *p ;

  {
#line 1509
  pxmitpriv = & padapter->xmitpriv;
#line 1510
  pregistrypriv = & padapter->registrypriv;
#line 1514
  switch ((int )pxmitpriv->vcs_setting) {
  case 0: 
#line 1516
  pxmitpriv->vcs = 0U;
#line 1517
  goto ldv_51890;
  case 1: ;
#line 1519
  goto ldv_51890;
  case 2: ;
  default: 
#line 1522
  p = cfg80211_find_ie(42, (u8 const   *)ie, (int )ie_len);
#line 1523
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 1524
    pxmitpriv->vcs = 0U;
  } else {
#line 1526
    protection = (uint )*(p + 2UL) & 2U;
#line 1527
    if (protection != 0U) {
#line 1528
      if ((unsigned int )pregistrypriv->vcs_type == 1U) {
#line 1529
        pxmitpriv->vcs = 1U;
      } else {
#line 1531
        pxmitpriv->vcs = 2U;
      }
    } else {
#line 1533
      pxmitpriv->vcs = 0U;
    }
  }
#line 1536
  goto ldv_51890;
  }
  ldv_51890: ;
#line 1539
  return;
}
}
#line 1540 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw_count_tx_stats23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ,
                           int sz ) 
{ 
  struct sta_info *psta ;
  struct stainfo_stats *pstats ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;

  {
#line 1542
  psta = (struct sta_info *)0;
#line 1543
  pstats = (struct stainfo_stats *)0;
#line 1544
  pxmitpriv = & padapter->xmitpriv;
#line 1545
  pmlmepriv = & padapter->mlmepriv;
#line 1547
  if ((pxmitframe->frame_tag & 15) == 1) {
#line 1548
    pxmitpriv->tx_bytes = pxmitpriv->tx_bytes + (u64 )sz;
#line 1549
    pmlmepriv->LinkDetectInfo.NumTxOkInPeriod = pmlmepriv->LinkDetectInfo.NumTxOkInPeriod + 1U;
#line 1551
    psta = pxmitframe->attrib.psta;
#line 1552
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1553
      pstats = & psta->sta_stats;
#line 1554
      pstats->tx_pkts = pstats->tx_pkts + 1ULL;
#line 1555
      pstats->tx_bytes = pstats->tx_bytes + (u64 )sz;
    } else {

    }
  } else {

  }
#line 1558
  return;
}
}
#line 1560 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct xmit_buf *rtw_alloc_xmitbuf23a_ext(struct xmit_priv *pxmitpriv ) 
{ 
  unsigned long irqL ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *phead ;
  struct rtw_queue *pfree_queue ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1563
  pxmitbuf = (struct xmit_buf *)0;
#line 1565
  pfree_queue = & pxmitpriv->free_xmit_extbuf_queue;
#line 1567
  ldv_spin_lock();
#line 1569
  phead = get_list_head(pfree_queue);
#line 1571
  tmp = list_empty((struct list_head  const  *)phead);
#line 1571
  if (tmp == 0) {
#line 1572
    __mptr = (struct list_head  const  *)phead->next;
#line 1572
    pxmitbuf = (struct xmit_buf *)__mptr;
#line 1574
    list_del_init(& pxmitbuf->list);
#line 1576
    pxmitpriv->free_xmit_extbuf_cnt = pxmitpriv->free_xmit_extbuf_cnt - 1U;
#line 1577
    pxmitbuf->priv_data = (void *)0;
#line 1578
    pxmitbuf->ext_tag = 1U;
#line 1580
    if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
#line 1581
      if (GlobalDebugLevel23A > 3U) {
#line 1581
        printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_alloc_xmitbuf23a_ext");
      } else {

      }
#line 1582
      rtw23a_sctx_done_err(& pxmitbuf->sctx, 3);
    } else {

    }
  } else {

  }
#line 1586
  spin_unlock_irqrestore(& pfree_queue->lock, irqL);
#line 1588
  return (pxmitbuf);
}
}
#line 1591 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
s32 rtw_free_xmitbuf_ext23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) 
{ 
  unsigned long irqL ;
  struct rtw_queue *pfree_queue ;
  struct list_head *tmp ;

  {
#line 1595
  pfree_queue = & pxmitpriv->free_xmit_extbuf_queue;
#line 1597
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 1598
    return (0);
  } else {

  }
#line 1600
  ldv_spin_lock();
#line 1602
  list_del_init(& pxmitbuf->list);
#line 1604
  tmp = get_list_head(pfree_queue);
#line 1604
  list_add_tail(& pxmitbuf->list, tmp);
#line 1605
  pxmitpriv->free_xmit_extbuf_cnt = pxmitpriv->free_xmit_extbuf_cnt + 1U;
#line 1607
  spin_unlock_irqrestore(& pfree_queue->lock, irqL);
#line 1609
  return (1);
}
}
#line 1612 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct xmit_buf *rtw_alloc_xmitbuf23a(struct xmit_priv *pxmitpriv ) 
{ 
  unsigned long irqL ;
  struct xmit_buf *pxmitbuf ;
  struct list_head *phead ;
  struct rtw_queue *pfree_xmitbuf_queue ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1615
  pxmitbuf = (struct xmit_buf *)0;
#line 1617
  pfree_xmitbuf_queue = & pxmitpriv->free_xmitbuf_queue;
#line 1621
  ldv_spin_lock();
#line 1623
  phead = get_list_head(pfree_xmitbuf_queue);
#line 1625
  tmp = list_empty((struct list_head  const  *)phead);
#line 1625
  if (tmp == 0) {
#line 1626
    __mptr = (struct list_head  const  *)phead->next;
#line 1626
    pxmitbuf = (struct xmit_buf *)__mptr;
#line 1628
    list_del_init(& pxmitbuf->list);
#line 1630
    pxmitpriv->free_xmitbuf_cnt = pxmitpriv->free_xmitbuf_cnt - 1U;
#line 1631
    pxmitbuf->priv_data = (void *)0;
#line 1632
    pxmitbuf->ext_tag = 0U;
#line 1633
    pxmitbuf->flags = 0U;
#line 1635
    if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
#line 1636
      if (GlobalDebugLevel23A > 3U) {
#line 1636
        printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_alloc_xmitbuf23a");
      } else {

      }
#line 1637
      rtw23a_sctx_done_err(& pxmitbuf->sctx, 3);
    } else {

    }
  } else {

  }
#line 1641
  spin_unlock_irqrestore(& pfree_xmitbuf_queue->lock, irqL);
#line 1643
  return (pxmitbuf);
}
}
#line 1646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
s32 rtw_free_xmitbuf23a(struct xmit_priv *pxmitpriv , struct xmit_buf *pxmitbuf ) 
{ 
  unsigned long irqL ;
  struct rtw_queue *pfree_xmitbuf_queue ;
  struct list_head *tmp ;

  {
#line 1649
  pfree_xmitbuf_queue = & pxmitpriv->free_xmitbuf_queue;
#line 1653
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 1654
    return (0);
  } else {

  }
#line 1656
  if ((unsigned long )pxmitbuf->sctx != (unsigned long )((struct submit_ctx *)0)) {
#line 1657
    if (GlobalDebugLevel23A > 3U) {
#line 1657
      printk("\016RTL8723AU: %s pxmitbuf->sctx is not NULL\n", "rtw_free_xmitbuf23a");
    } else {

    }
#line 1658
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 4);
  } else {

  }
#line 1661
  if ((unsigned int )pxmitbuf->ext_tag != 0U) {
#line 1662
    rtw_free_xmitbuf_ext23a(pxmitpriv, pxmitbuf);
  } else {
#line 1664
    ldv_spin_lock();
#line 1666
    list_del_init(& pxmitbuf->list);
#line 1668
    tmp = get_list_head(pfree_xmitbuf_queue);
#line 1668
    list_add_tail(& pxmitbuf->list, tmp);
#line 1671
    pxmitpriv->free_xmitbuf_cnt = pxmitpriv->free_xmitbuf_cnt + 1U;
#line 1672
    spin_unlock_irqrestore(& pfree_xmitbuf_queue->lock, irqL);
  }
#line 1675
  return (1);
}
}
#line 1678 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static void rtw_init_xmitframe(struct xmit_frame *pxframe ) 
{ 


  {
#line 1680
  if ((unsigned long )pxframe != (unsigned long )((struct xmit_frame *)0)) {
#line 1682
    pxframe->buf_addr = (u8 *)0U;
#line 1683
    pxframe->pxmitbuf = (struct xmit_buf *)0;
#line 1685
    memset((void *)(& pxframe->attrib), 0, 112UL);
#line 1688
    pxframe->frame_tag = 1;
#line 1690
    pxframe->pkt = (struct sk_buff *)0;
#line 1691
    pxframe->pkt_offset = 1;
#line 1693
    pxframe->ack_report = 0U;
  } else {

  }
#line 1695
  return;
}
}
#line 1708 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv ) 
{ 
  struct xmit_frame *pxframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_queue *pfree_xmit_queue ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1710
  pxframe = (struct xmit_frame *)0;
#line 1712
  pfree_xmit_queue = & pxmitpriv->free_xmit_queue;
#line 1714
  spin_lock_bh(& pfree_xmit_queue->lock);
#line 1716
  tmp = list_empty((struct list_head  const  *)(& pfree_xmit_queue->queue));
#line 1716
  if (tmp != 0) {
#line 1717
    if (GlobalDebugLevel23A > 6U) {
#line 1717
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1717
      printk("\016rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {

    }
#line 1720
    pxframe = (struct xmit_frame *)0;
  } else {
#line 1722
    phead = get_list_head(pfree_xmit_queue);
#line 1724
    plist = phead->next;
#line 1726
    __mptr = (struct list_head  const  *)plist;
#line 1726
    pxframe = (struct xmit_frame *)__mptr;
#line 1728
    list_del_init(& pxframe->list);
#line 1729
    pxmitpriv->free_xmitframe_cnt = pxmitpriv->free_xmitframe_cnt - 1;
#line 1730
    if (GlobalDebugLevel23A > 6U) {
#line 1730
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1730
      printk("\016rtw_alloc_xmitframe():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {

    }
  }
#line 1735
  spin_unlock_bh(& pfree_xmit_queue->lock);
#line 1737
  rtw_init_xmitframe(pxframe);
#line 1739
  return (pxframe);
}
}
#line 1742 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct xmit_frame *rtw_alloc_xmitframe23a_ext(struct xmit_priv *pxmitpriv ) 
{ 
  struct xmit_frame *pxframe ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct rtw_queue *queue ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1744
  pxframe = (struct xmit_frame *)0;
#line 1746
  queue = & pxmitpriv->free_xframe_ext_queue;
#line 1748
  spin_lock_bh(& queue->lock);
#line 1750
  tmp = list_empty((struct list_head  const  *)(& queue->queue));
#line 1750
  if (tmp != 0) {
#line 1751
    if (GlobalDebugLevel23A > 6U) {
#line 1751
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1751
      printk("\016rtw_alloc_xmitframe23a_ext:%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {

    }
#line 1752
    pxframe = (struct xmit_frame *)0;
  } else {
#line 1754
    phead = get_list_head(queue);
#line 1755
    plist = phead->next;
#line 1756
    __mptr = (struct list_head  const  *)plist;
#line 1756
    pxframe = (struct xmit_frame *)__mptr;
#line 1758
    list_del_init(& pxframe->list);
#line 1759
    pxmitpriv->free_xframe_ext_cnt = pxmitpriv->free_xframe_ext_cnt - 1;
#line 1760
    if (GlobalDebugLevel23A > 6U) {
#line 1760
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1760
      printk("\016rtw_alloc_xmitframe23a_ext():free_xmitframe_cnt =%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {

    }
  }
#line 1763
  spin_unlock_bh(& queue->lock);
#line 1765
  rtw_init_xmitframe(pxframe);
#line 1767
  return (pxframe);
}
}
#line 1770 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
s32 rtw_free_xmitframe23a(struct xmit_priv *pxmitpriv , struct xmit_frame *pxmitframe ) 
{ 
  struct rtw_queue *queue ;
  struct rtw_adapter *padapter ;
  struct sk_buff *pndis_pkt ;
  struct list_head *tmp ;

  {
#line 1772
  queue = (struct rtw_queue *)0;
#line 1773
  padapter = pxmitpriv->adapter;
#line 1774
  pndis_pkt = (struct sk_buff *)0;
#line 1776
  if ((unsigned long )pxmitframe == (unsigned long )((struct xmit_frame *)0)) {
#line 1777
    if (GlobalDebugLevel23A > 3U) {
#line 1777
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1777
      printk("\016====== rtw_free_xmitframe23a():pxmitframe == NULL!!!!!!!!!!\n");
    } else {

    }
#line 1778
    goto exit;
  } else {

  }
#line 1781
  if ((unsigned long )pxmitframe->pkt != (unsigned long )((struct sk_buff *)0)) {
#line 1782
    pndis_pkt = pxmitframe->pkt;
#line 1783
    pxmitframe->pkt = (struct sk_buff *)0;
  } else {

  }
#line 1786
  if ((unsigned int )pxmitframe->ext_tag == 0U) {
#line 1787
    queue = & pxmitpriv->free_xmit_queue;
  } else
#line 1788
  if ((unsigned int )pxmitframe->ext_tag == 1U) {
#line 1789
    queue = & pxmitpriv->free_xframe_ext_queue;
  } else {

  }
#line 1791
  if ((unsigned long )queue == (unsigned long )((struct rtw_queue *)0)) {
#line 1792
    goto check_pkt_complete;
  } else {

  }
#line 1793
  spin_lock_bh(& queue->lock);
#line 1795
  list_del_init(& pxmitframe->list);
#line 1796
  tmp = get_list_head(queue);
#line 1796
  list_add_tail(& pxmitframe->list, tmp);
#line 1797
  if ((unsigned int )pxmitframe->ext_tag == 0U) {
#line 1798
    pxmitpriv->free_xmitframe_cnt = pxmitpriv->free_xmitframe_cnt + 1;
#line 1799
    if (GlobalDebugLevel23A > 7U) {
#line 1799
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 8);
#line 1799
      printk("\016rtw_free_xmitframe23a():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt);
    } else {

    }
  } else
#line 1800
  if ((unsigned int )pxmitframe->ext_tag == 1U) {
#line 1801
    pxmitpriv->free_xframe_ext_cnt = pxmitpriv->free_xframe_ext_cnt + 1;
#line 1802
    if (GlobalDebugLevel23A > 7U) {
#line 1802
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 8);
#line 1802
      printk("\016rtw_free_xmitframe23a():free_xframe_ext_cnt =%d\n", pxmitpriv->free_xframe_ext_cnt);
    } else {

    }
  } else {

  }
#line 1805
  spin_unlock_bh(& queue->lock);
  check_pkt_complete: ;
#line 1809
  if ((unsigned long )pndis_pkt != (unsigned long )((struct sk_buff *)0)) {
#line 1810
    rtw_os_pkt_complete23a(padapter, pndis_pkt);
  } else {

  }
  exit: ;
#line 1814
  return (1);
}
}
#line 1817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw_free_xmitframe_queue23a(struct xmit_priv *pxmitpriv , struct rtw_queue *pframequeue ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct list_head  const  *__mptr ;

  {
#line 1823
  spin_lock_bh(& pframequeue->lock);
#line 1825
  phead = get_list_head(pframequeue);
#line 1827
  plist = phead->next;
#line 1827
  ptmp = plist->next;
#line 1827
  goto ldv_51977;
  ldv_51976: 
#line 1828
  __mptr = (struct list_head  const  *)plist;
#line 1828
  pxmitframe = (struct xmit_frame *)__mptr;
#line 1830
  rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 1827
  plist = ptmp;
#line 1827
  ptmp = plist->next;
  ldv_51977: ;
#line 1827
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1829
    goto ldv_51976;
  } else {

  }
#line 1832
  spin_unlock_bh(& pframequeue->lock);
#line 1833
  return;
}
}
#line 1836 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
s32 rtw_xmitframe_enqueue23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  s32 tmp ;

  {
#line 1839
  tmp = rtw_xmit23a_classifier(padapter, pxmitframe);
#line 1839
  if (tmp == 0) {
#line 1840
    if (GlobalDebugLevel23A > 3U) {
#line 1840
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1840
      printk("\016rtw_xmitframe_enqueue23a: drop xmit pkt for classifier fail\n");
    } else {

    }
#line 1843
    return (0);
  } else {

  }
#line 1846
  return (1);
}
}
#line 1850 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit ,
                                                struct tx_servq *ptxservq , struct rtw_queue *pframe_queue ) 
{ 
  struct list_head *phead ;
  struct xmit_frame *pxmitframe ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1854
  pxmitframe = (struct xmit_frame *)0;
#line 1856
  phead = get_list_head(pframe_queue);
#line 1858
  tmp = list_empty((struct list_head  const  *)phead);
#line 1858
  if (tmp == 0) {
#line 1859
    __mptr = (struct list_head  const  *)phead->next;
#line 1859
    pxmitframe = (struct xmit_frame *)__mptr;
#line 1860
    list_del_init(& pxmitframe->list);
#line 1861
    ptxservq->qcnt = ptxservq->qcnt - 1;
  } else {

  }
#line 1863
  return (pxmitframe);
}
}
#line 1867 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct xmit_frame *rtw_dequeue_xframe23a(struct xmit_priv *pxmitpriv , struct hw_xmit *phwxmit_i ,
                                         int entry ) 
{ 
  struct list_head *sta_plist ;
  struct list_head *sta_phead ;
  struct list_head *ptmp ;
  struct hw_xmit *phwxmit ;
  struct tx_servq *ptxservq ;
  struct rtw_queue *pframe_queue ;
  struct xmit_frame *pxmitframe ;
  struct rtw_adapter *padapter ;
  struct registry_priv *pregpriv ;
  int i ;
  int inx[4U] ;
  int j ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1872
  ptxservq = (struct tx_servq *)0;
#line 1873
  pframe_queue = (struct rtw_queue *)0;
#line 1874
  pxmitframe = (struct xmit_frame *)0;
#line 1875
  padapter = pxmitpriv->adapter;
#line 1876
  pregpriv = & padapter->registrypriv;
#line 1879
  inx[0] = 0;
#line 1880
  inx[1] = 1;
#line 1881
  inx[2] = 2;
#line 1882
  inx[3] = 3;
#line 1883
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
#line 1886
    j = 0;
#line 1886
    goto ldv_52011;
    ldv_52010: 
#line 1887
    inx[j] = (int )pxmitpriv->wmm_para_seq[j];
#line 1886
    j = j + 1;
    ldv_52011: ;
#line 1886
    if (j <= 3) {
#line 1888
      goto ldv_52010;
    } else {

    }

  } else {

  }
#line 1890
  spin_lock_bh(& pxmitpriv->lock);
#line 1892
  i = 0;
#line 1892
  goto ldv_52020;
  ldv_52019: 
#line 1893
  phwxmit = phwxmit_i + (unsigned long )inx[i];
#line 1895
  sta_phead = get_list_head(phwxmit->sta_queue);
#line 1897
  sta_plist = sta_phead->next;
#line 1897
  ptmp = sta_plist->next;
#line 1897
  goto ldv_52017;
  ldv_52016: 
#line 1898
  __mptr = (struct list_head  const  *)sta_plist;
#line 1898
  ptxservq = (struct tx_servq *)__mptr;
#line 1901
  pframe_queue = & ptxservq->sta_pending;
#line 1903
  pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
#line 1905
  if ((unsigned long )pxmitframe != (unsigned long )((struct xmit_frame *)0)) {
#line 1906
    phwxmit->accnt = phwxmit->accnt - 1;
#line 1911
    tmp = list_empty((struct list_head  const  *)(& pframe_queue->queue));
#line 1911
    if (tmp != 0) {
#line 1912
      list_del_init(& ptxservq->tx_pending);
    } else {

    }
#line 1913
    goto exit;
  } else {

  }
#line 1897
  sta_plist = ptmp;
#line 1897
  ptmp = sta_plist->next;
  ldv_52017: ;
#line 1897
  if ((unsigned long )sta_plist != (unsigned long )sta_phead) {
#line 1899
    goto ldv_52016;
  } else {

  }
#line 1892
  i = i + 1;
  ldv_52020: ;
#line 1892
  if (i < entry) {
#line 1894
    goto ldv_52019;
  } else {

  }

  exit: 
#line 1918
  spin_unlock_bh(& pxmitpriv->lock);
#line 1919
  return (pxmitframe);
}
}
#line 1922 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct tx_servq *rtw_get_sta_pending23a(struct rtw_adapter *padapter , struct sta_info *psta ,
                                        int up___0 , u8 *ac ) 
{ 
  struct tx_servq *ptxservq ;

  {
#line 1924
  ptxservq = (struct tx_servq *)0;
#line 1926
  switch (up___0) {
  case 1: ;
  case 2: 
#line 1929
  ptxservq = & psta->sta_xmitpriv.bk_q;
#line 1930
  *ac = 3U;
#line 1931
  if (GlobalDebugLevel23A > 6U) {
#line 1931
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1931
    printk("\016rtw_get_sta_pending23a : BK\n");
  } else {

  }
#line 1932
  goto ldv_52031;
  case 4: ;
  case 5: 
#line 1935
  ptxservq = & psta->sta_xmitpriv.vi_q;
#line 1936
  *ac = 1U;
#line 1937
  if (GlobalDebugLevel23A > 6U) {
#line 1937
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1937
    printk("\016rtw_get_sta_pending23a : VI\n");
  } else {

  }
#line 1938
  goto ldv_52031;
  case 6: ;
  case 7: 
#line 1941
  ptxservq = & psta->sta_xmitpriv.vo_q;
#line 1942
  *ac = 0U;
#line 1943
  if (GlobalDebugLevel23A > 6U) {
#line 1943
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1943
    printk("\016rtw_get_sta_pending23a : VO\n");
  } else {

  }
#line 1944
  goto ldv_52031;
  case 0: ;
  case 3: ;
  default: 
#line 1948
  ptxservq = & psta->sta_xmitpriv.be_q;
#line 1949
  *ac = 2U;
#line 1950
  if (GlobalDebugLevel23A > 6U) {
#line 1950
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 1950
    printk("\016rtw_get_sta_pending23a : BE\n");
  } else {

  }
#line 1951
  goto ldv_52031;
  }
  ldv_52031: ;
#line 1953
  return (ptxservq);
}
}
#line 1960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
s32 rtw_xmit23a_classifier(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct sta_info *psta ;
  struct tx_servq *ptxservq ;
  struct pkt_attrib *pattrib ;
  struct sta_priv *pstapriv ;
  struct hw_xmit *phwxmits ;
  u8 ac_index ;
  int res ;
  struct list_head *tmp ;
  int tmp___0 ;
  struct list_head *tmp___1 ;

  {
#line 1965
  pattrib = & pxmitframe->attrib;
#line 1966
  pstapriv = & padapter->stapriv;
#line 1967
  phwxmits = padapter->xmitpriv.hwxmits;
#line 1969
  res = 1;
#line 1971
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 1972
    psta = pattrib->psta;
  } else {
#line 1974
    if (GlobalDebugLevel23A > 3U) {
#line 1974
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "rtw_xmit23a_classifier");
    } else {

    }
#line 1975
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
  }
#line 1977
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1978
    res = 0;
#line 1979
    if (GlobalDebugLevel23A > 3U) {
#line 1979
      printk("\016RTL8723AU: rtw_xmit23a_classifier: psta == NULL\n");
    } else {

    }
#line 1980
    if (GlobalDebugLevel23A > 3U) {
#line 1980
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 1980
      printk("\016rtw_xmit23a_classifier: psta == NULL\n");
    } else {

    }
#line 1982
    goto exit;
  } else {

  }
#line 1984
  if ((psta->state & 1U) == 0U) {
#line 1985
    if (GlobalDebugLevel23A > 3U) {
#line 1985
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "rtw_xmit23a_classifier",
             psta->state);
    } else {

    }
#line 1987
    return (0);
  } else {

  }
#line 1989
  ptxservq = rtw_get_sta_pending23a(padapter, psta, (int )pattrib->priority, & ac_index);
#line 1992
  tmp___0 = list_empty((struct list_head  const  *)(& ptxservq->tx_pending));
#line 1992
  if (tmp___0 != 0) {
#line 1993
    tmp = get_list_head((phwxmits + (unsigned long )ac_index)->sta_queue);
#line 1993
    list_add_tail(& ptxservq->tx_pending, tmp);
  } else {

  }
#line 1997
  tmp___1 = get_list_head(& ptxservq->sta_pending);
#line 1997
  list_add_tail(& pxmitframe->list, tmp___1);
#line 1998
  ptxservq->qcnt = ptxservq->qcnt + 1;
#line 1999
  (phwxmits + (unsigned long )ac_index)->accnt = (phwxmits + (unsigned long )ac_index)->accnt + 1;
  exit: ;
#line 2001
  return (res);
}
}
#line 2004 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw_alloc_hwxmits23a(struct rtw_adapter *padapter ) 
{ 
  struct hw_xmit *hwxmits ;
  struct xmit_priv *pxmitpriv ;
  int size ;
  void *tmp ;

  {
#line 2007
  pxmitpriv = & padapter->xmitpriv;
#line 2010
  pxmitpriv->hwxmit_entry = 4U;
#line 2012
  size = ((int )pxmitpriv->hwxmit_entry + 1) * 16;
#line 2013
  tmp = kzalloc((size_t )size, 208U);
#line 2013
  pxmitpriv->hwxmits = (struct hw_xmit *)tmp;
#line 2015
  hwxmits = pxmitpriv->hwxmits;
#line 2017
  if ((unsigned int )pxmitpriv->hwxmit_entry == 5U) {
#line 2020
    hwxmits->sta_queue = & pxmitpriv->bm_pending;
#line 2024
    (hwxmits + 1UL)->sta_queue = & pxmitpriv->vo_pending;
#line 2028
    (hwxmits + 2UL)->sta_queue = & pxmitpriv->vi_pending;
#line 2032
    (hwxmits + 3UL)->sta_queue = & pxmitpriv->bk_pending;
#line 2036
    (hwxmits + 4UL)->sta_queue = & pxmitpriv->be_pending;
  } else
#line 2038
  if ((unsigned int )pxmitpriv->hwxmit_entry == 4U) {
#line 2042
    hwxmits->sta_queue = & pxmitpriv->vo_pending;
#line 2046
    (hwxmits + 1UL)->sta_queue = & pxmitpriv->vi_pending;
#line 2050
    (hwxmits + 2UL)->sta_queue = & pxmitpriv->be_pending;
#line 2054
    (hwxmits + 3UL)->sta_queue = & pxmitpriv->bk_pending;
  } else {

  }
#line 2059
  return;
}
}
#line 2060 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw_free_hwxmits23a(struct rtw_adapter *padapter ) 
{ 
  struct hw_xmit *hwxmits ;
  struct xmit_priv *pxmitpriv ;

  {
#line 2063
  pxmitpriv = & padapter->xmitpriv;
#line 2065
  hwxmits = pxmitpriv->hwxmits;
#line 2066
  kfree((void const   *)hwxmits);
#line 2067
  return;
}
}
#line 2069 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw_init_hwxmits23a(struct hw_xmit *phwxmit , int entry ) 
{ 
  int i ;

  {
#line 2073
  i = 0;
#line 2073
  goto ldv_52069;
  ldv_52068: 
#line 2074
  phwxmit->accnt = 0;
#line 2073
  i = i + 1;
#line 2073
  phwxmit = phwxmit + 1;
  ldv_52069: ;
#line 2073
  if (i < entry) {
#line 2075
    goto ldv_52068;
  } else {

  }

#line 2080
  return;
}
}
#line 2077 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
u32 rtw_get_ff_hwaddr23a(struct xmit_frame *pxmitframe ) 
{ 
  u32 addr ;
  struct pkt_attrib *pattrib ;

  {
#line 2080
  pattrib = & pxmitframe->attrib;
#line 2082
  switch ((int )pattrib->qsel) {
  case 0: ;
  case 3: 
#line 2085
  addr = 2U;
#line 2086
  goto ldv_52078;
  case 1: ;
  case 2: 
#line 2089
  addr = 3U;
#line 2090
  goto ldv_52078;
  case 4: ;
  case 5: 
#line 2093
  addr = 1U;
#line 2094
  goto ldv_52078;
  case 6: ;
  case 7: 
#line 2097
  addr = 0U;
#line 2098
  goto ldv_52078;
  case 16: 
#line 2100
  addr = 4U;
#line 2101
  goto ldv_52078;
  case 17: 
#line 2103
  addr = 6U;
#line 2104
  goto ldv_52078;
  case 18: ;
  default: 
#line 2107
  addr = 5U;
#line 2108
  goto ldv_52078;
  }
  ldv_52078: ;
#line 2111
  return (addr);
}
}
#line 2114 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static void do_queue_select(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) 
{ 
  u8 qsel ;

  {
#line 2118
  qsel = pattrib->priority;
#line 2119
  if (GlobalDebugLevel23A > 6U) {
#line 2119
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 2119
    printk("\016### do_queue_select priority =%d , qsel = %d\n", (int )pattrib->priority,
           (int )qsel);
  } else {

  }
#line 2123
  pattrib->qsel = qsel;
#line 2124
  return;
}
}
#line 2134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
int rtw_xmit23a(struct rtw_adapter *padapter , struct sk_buff *skb ) 
{ 
  struct xmit_priv *pxmitpriv ;
  struct xmit_frame *pxmitframe ;
  int res ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 2136
  pxmitpriv = & padapter->xmitpriv;
#line 2137
  pxmitframe = (struct xmit_frame *)0;
#line 2140
  pxmitframe = rtw_alloc_xmitframe(pxmitpriv);
#line 2142
  if ((unsigned long )pxmitframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2143
    if (GlobalDebugLevel23A > 3U) {
#line 2143
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 4);
#line 2143
      printk("\016rtw_xmit23a: no more pxmitframe\n");
    } else {

    }
#line 2145
    return (-1);
  } else {

  }
#line 2148
  res = update_attrib(padapter, skb, & pxmitframe->attrib);
#line 2150
  if (res == 0) {
#line 2151
    if (GlobalDebugLevel23A > 3U) {
#line 2151
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 4);
#line 2151
      printk("\016rtw_xmit23a: update attrib fail\n");
    } else {

    }
#line 2152
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 2153
    return (-1);
  } else {

  }
#line 2155
  pxmitframe->pkt = skb;
#line 2159
  do_queue_select(padapter, & pxmitframe->attrib);
#line 2162
  spin_lock_bh(& pxmitpriv->lock);
#line 2163
  tmp = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
#line 2163
  if (tmp != 0) {
#line 2164
    spin_unlock_bh(& pxmitpriv->lock);
#line 2165
    return (1);
  } else {

  }
#line 2167
  spin_unlock_bh(& pxmitpriv->lock);
#line 2170
  tmp___0 = rtl8723au_hal_xmit(padapter, pxmitframe);
#line 2170
  if (tmp___0) {
#line 2170
    tmp___1 = 0;
  } else {
#line 2170
    tmp___1 = 1;
  }
#line 2170
  if (tmp___1) {
#line 2171
    return (1);
  } else {

  }
#line 2173
  return (0);
}
}
#line 2178 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
int xmitframe_enqueue_for_sleeping_sta23a(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int ret ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct pkt_attrib *pattrib ;
  struct mlme_priv *pmlmepriv ;
  int bmcst ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  struct list_head *tmp___2 ;
  u8 wmmps_ac ;
  struct list_head *tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;

  {
#line 2180
  ret = 0;
#line 2181
  psta = (struct sta_info *)0;
#line 2182
  pstapriv = & padapter->stapriv;
#line 2183
  pattrib = & pxmitframe->attrib;
#line 2184
  pmlmepriv = & padapter->mlmepriv;
#line 2185
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 2185
  bmcst = (int )tmp;
#line 2187
  tmp___0 = check_fwstate(pmlmepriv, 16);
#line 2187
  if (tmp___0) {
#line 2187
    tmp___1 = 0;
  } else {
#line 2187
    tmp___1 = 1;
  }
#line 2187
  if (tmp___1) {
#line 2188
    return (ret);
  } else {

  }
#line 2190
  if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 2191
    psta = pattrib->psta;
  } else {
#line 2193
    if (GlobalDebugLevel23A > 3U) {
#line 2193
      printk("\016RTL8723AU: %s, call rtw_get_stainfo23a()\n", "xmitframe_enqueue_for_sleeping_sta23a");
    } else {

    }
#line 2194
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
  }
#line 2197
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 2198
    if (GlobalDebugLevel23A > 3U) {
#line 2198
      printk("\016RTL8723AU: %s, psta == NUL\n", "xmitframe_enqueue_for_sleeping_sta23a");
    } else {

    }
#line 2199
    return (0);
  } else {

  }
#line 2202
  if ((psta->state & 1U) == 0U) {
#line 2203
    if (GlobalDebugLevel23A > 3U) {
#line 2203
      printk("\016RTL8723AU: %s, psta->state(0x%x) != _FW_LINKED\n", "xmitframe_enqueue_for_sleeping_sta23a",
             psta->state);
    } else {

    }
#line 2205
    return (0);
  } else {

  }
#line 2208
  if ((unsigned int )pattrib->triggered == 1U) {
#line 2209
    if (bmcst != 0) {
#line 2210
      pattrib->qsel = 17U;
    } else {

    }
#line 2211
    return (ret);
  } else {

  }
#line 2214
  if (bmcst != 0) {
#line 2215
    spin_lock_bh(& psta->sleep_q.lock);
#line 2217
    if ((unsigned int )pstapriv->sta_dz_bitmap != 0U) {
#line 2219
      list_del_init(& pxmitframe->list);
#line 2223
      tmp___2 = get_list_head(& psta->sleep_q);
#line 2223
      list_add_tail(& pxmitframe->list, tmp___2);
#line 2225
      psta->sleepq_len = psta->sleepq_len + 1U;
#line 2227
      pstapriv->tim_bitmap = (u16 )((unsigned int )pstapriv->tim_bitmap | 1U);
#line 2228
      pstapriv->sta_dz_bitmap = (u16 )((unsigned int )pstapriv->sta_dz_bitmap | 1U);
#line 2233
      update_beacon23a(padapter, 5, (u8 *)0U, 0);
#line 2237
      ret = 1;
    } else {

    }
#line 2241
    spin_unlock_bh(& psta->sleep_q.lock);
#line 2243
    return (ret);
  } else {

  }
#line 2247
  spin_lock_bh(& psta->sleep_q.lock);
#line 2249
  if ((psta->state & 4U) != 0U) {
#line 2250
    wmmps_ac = 0U;
#line 2252
    tmp___5 = CHKBIT(psta->aid);
#line 2252
    if (((u32 )pstapriv->sta_dz_bitmap & tmp___5) != 0U) {
#line 2253
      list_del_init(& pxmitframe->list);
#line 2257
      tmp___3 = get_list_head(& psta->sleep_q);
#line 2257
      list_add_tail(& pxmitframe->list, tmp___3);
#line 2259
      psta->sleepq_len = psta->sleepq_len + 1U;
#line 2261
      switch ((int )pattrib->priority) {
      case 1: ;
      case 2: 
#line 2264
      wmmps_ac = (unsigned int )psta->uapsd_bk & 1U;
#line 2265
      goto ldv_52115;
      case 4: ;
      case 5: 
#line 2268
      wmmps_ac = (unsigned int )psta->uapsd_vi & 1U;
#line 2269
      goto ldv_52115;
      case 6: ;
      case 7: 
#line 2272
      wmmps_ac = (unsigned int )psta->uapsd_vo & 1U;
#line 2273
      goto ldv_52115;
      case 0: ;
      case 3: ;
      default: 
#line 2277
      wmmps_ac = (unsigned int )psta->uapsd_be & 1U;
#line 2278
      goto ldv_52115;
      }
      ldv_52115: ;
#line 2281
      if ((unsigned int )wmmps_ac != 0U) {
#line 2282
        psta->sleepq_ac_len = psta->sleepq_ac_len + 1U;
      } else {

      }
#line 2284
      if (((unsigned int )psta->has_legacy_ac != 0U && (unsigned int )wmmps_ac == 0U) || ((unsigned int )psta->has_legacy_ac == 0U && (unsigned int )wmmps_ac != 0U)) {
#line 2286
        tmp___4 = CHKBIT(psta->aid);
#line 2286
        pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap | (int )((u16 )tmp___4);
#line 2288
        if (psta->sleepq_len == 1U) {
#line 2290
          update_beacon23a(padapter, 5, (u8 *)0U, 0);
        } else {

        }
      } else {

      }
#line 2302
      ret = 1;
    } else {

    }
  } else {

  }
#line 2308
  spin_unlock_bh(& psta->sleep_q.lock);
#line 2310
  return (ret);
}
}
#line 2314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static void dequeue_xmitframes_to_sleeping_queue(struct rtw_adapter *padapter , struct sta_info *psta ,
                                                 struct rtw_queue *pframequeue ) 
{ 
  int ret ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  u8 ac_index ;
  struct tx_servq *ptxservq ;
  struct pkt_attrib *pattrib ;
  struct xmit_frame *pxmitframe ;
  struct hw_xmit *phwxmits ;
  struct list_head  const  *__mptr ;

  {
#line 2324
  phwxmits = padapter->xmitpriv.hwxmits;
#line 2326
  phead = get_list_head(pframequeue);
#line 2328
  plist = phead->next;
#line 2328
  ptmp = plist->next;
#line 2328
  goto ldv_52140;
  ldv_52139: 
#line 2329
  __mptr = (struct list_head  const  *)plist;
#line 2329
  pxmitframe = (struct xmit_frame *)__mptr;
#line 2331
  ret = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
#line 2333
  if (ret == 1) {
#line 2334
    pattrib = & pxmitframe->attrib;
#line 2336
    ptxservq = rtw_get_sta_pending23a(padapter, psta, (int )pattrib->priority, & ac_index);
#line 2338
    ptxservq->qcnt = ptxservq->qcnt - 1;
#line 2339
    (phwxmits + (unsigned long )ac_index)->accnt = (phwxmits + (unsigned long )ac_index)->accnt - 1;
  } else {

  }
#line 2328
  plist = ptmp;
#line 2328
  ptmp = plist->next;
  ldv_52140: ;
#line 2328
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2330
    goto ldv_52139;
  } else {

  }

#line 2335
  return;
}
}
#line 2346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void stop_sta_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct sta_info *psta_bmc ;
  struct sta_xmit_priv *pstaxmitpriv ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  u32 tmp ;

  {
#line 2350
  pstapriv = & padapter->stapriv;
#line 2351
  pxmitpriv = & padapter->xmitpriv;
#line 2353
  pstaxmitpriv = & psta->sta_xmitpriv;
#line 2356
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 2358
  spin_lock_bh(& pxmitpriv->lock);
#line 2360
  psta->state = psta->state | 4U;
#line 2362
  tmp = CHKBIT(psta->aid);
#line 2362
  pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap | (int )((u16 )tmp);
#line 2364
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->vo_q.sta_pending);
#line 2365
  list_del_init(& pstaxmitpriv->vo_q.tx_pending);
#line 2367
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->vi_q.sta_pending);
#line 2368
  list_del_init(& pstaxmitpriv->vi_q.tx_pending);
#line 2370
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->be_q.sta_pending);
#line 2372
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
#line 2374
  dequeue_xmitframes_to_sleeping_queue(padapter, psta, & pstaxmitpriv->bk_q.sta_pending);
#line 2376
  list_del_init(& pstaxmitpriv->bk_q.tx_pending);
#line 2379
  pstaxmitpriv = & psta_bmc->sta_xmitpriv;
#line 2380
  dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, & pstaxmitpriv->be_q.sta_pending);
#line 2382
  list_del_init(& pstaxmitpriv->be_q.tx_pending);
#line 2384
  spin_unlock_bh(& pxmitpriv->lock);
#line 2385
  return;
}
}
#line 2387 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void wakeup_sta_to_xmit23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 update_mask ;
  u8 wmmps_ac ;
  struct sta_info *psta_bmc ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  struct list_head  const  *__mptr ;
  u32 tmp ;
  u32 tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2389
  update_mask = 0U;
#line 2389
  wmmps_ac = 0U;
#line 2392
  pxmitframe = (struct xmit_frame *)0;
#line 2393
  pstapriv = & padapter->stapriv;
#line 2394
  pxmitpriv = & padapter->xmitpriv;
#line 2396
  spin_lock_bh(& pxmitpriv->lock);
#line 2398
  phead = get_list_head(& psta->sleep_q);
#line 2400
  plist = phead->next;
#line 2400
  ptmp = plist->next;
#line 2400
  goto ldv_52176;
  ldv_52175: 
#line 2401
  __mptr = (struct list_head  const  *)plist;
#line 2401
  pxmitframe = (struct xmit_frame *)__mptr;
#line 2402
  list_del_init(& pxmitframe->list);
#line 2404
  switch ((int )pxmitframe->attrib.priority) {
  case 1: ;
  case 2: 
#line 2407
  wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
#line 2408
  goto ldv_52167;
  case 4: ;
  case 5: 
#line 2411
  wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
#line 2412
  goto ldv_52167;
  case 6: ;
  case 7: 
#line 2415
  wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
#line 2416
  goto ldv_52167;
  case 0: ;
  case 3: ;
  default: 
#line 2420
  wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
#line 2421
  goto ldv_52167;
  }
  ldv_52167: 
#line 2424
  psta->sleepq_len = psta->sleepq_len - 1U;
#line 2425
  if (psta->sleepq_len != 0U) {
#line 2426
    pxmitframe->attrib.mdata = 1U;
  } else {
#line 2428
    pxmitframe->attrib.mdata = 0U;
  }
#line 2430
  if ((unsigned int )wmmps_ac != 0U) {
#line 2431
    psta->sleepq_ac_len = psta->sleepq_ac_len - 1U;
#line 2432
    if (psta->sleepq_ac_len != 0U) {
#line 2433
      pxmitframe->attrib.mdata = 1U;
#line 2434
      pxmitframe->attrib.eosp = 0U;
    } else {
#line 2436
      pxmitframe->attrib.mdata = 0U;
#line 2437
      pxmitframe->attrib.eosp = 1U;
    }
  } else {

  }
#line 2441
  pxmitframe->attrib.triggered = 1U;
#line 2442
  rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 2400
  plist = ptmp;
#line 2400
  ptmp = plist->next;
  ldv_52176: ;
#line 2400
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2402
    goto ldv_52175;
  } else {

  }

#line 2445
  if (psta->sleepq_len == 0U) {
#line 2446
    tmp = CHKBIT(psta->aid);
#line 2446
    pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp));
#line 2449
    update_mask = 1U;
#line 2451
    if ((psta->state & 4U) != 0U) {
#line 2452
      psta->state = psta->state ^ 4U;
    } else {

    }
#line 2454
    if ((psta->state & 1024U) != 0U) {
#line 2455
      psta->expire_to = pstapriv->expire_to;
#line 2456
      psta->state = psta->state ^ 1024U;
    } else {

    }
#line 2459
    tmp___0 = CHKBIT(psta->aid);
#line 2459
    pstapriv->sta_dz_bitmap = (int )pstapriv->sta_dz_bitmap & ~ ((int )((u16 )tmp___0));
  } else {

  }
#line 2463
  spin_unlock_bh(& pxmitpriv->lock);
#line 2466
  psta_bmc = rtw_get_bcmc_stainfo23a(padapter);
#line 2467
  if ((unsigned long )psta_bmc == (unsigned long )((struct sta_info *)0)) {
#line 2468
    return;
  } else {

  }
#line 2470
  if (((int )pstapriv->sta_dz_bitmap & 65534) == 0) {
#line 2472
    spin_lock_bh(& pxmitpriv->lock);
#line 2474
    phead = get_list_head(& psta_bmc->sleep_q);
#line 2476
    plist = phead->next;
#line 2476
    ptmp = plist->next;
#line 2476
    goto ldv_52181;
    ldv_52180: 
#line 2477
    __mptr___0 = (struct list_head  const  *)plist;
#line 2477
    pxmitframe = (struct xmit_frame *)__mptr___0;
#line 2480
    list_del_init(& pxmitframe->list);
#line 2482
    psta_bmc->sleepq_len = psta_bmc->sleepq_len - 1U;
#line 2483
    if (psta_bmc->sleepq_len != 0U) {
#line 2484
      pxmitframe->attrib.mdata = 1U;
    } else {
#line 2486
      pxmitframe->attrib.mdata = 0U;
    }
#line 2488
    pxmitframe->attrib.triggered = 1U;
#line 2489
    rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 2476
    plist = ptmp;
#line 2476
    ptmp = plist->next;
    ldv_52181: ;
#line 2476
    if ((unsigned long )plist != (unsigned long )phead) {
#line 2478
      goto ldv_52180;
    } else {

    }

#line 2491
    if (psta_bmc->sleepq_len == 0U) {
#line 2492
      pstapriv->tim_bitmap = (unsigned int )pstapriv->tim_bitmap & 65534U;
#line 2493
      pstapriv->sta_dz_bitmap = (unsigned int )pstapriv->sta_dz_bitmap & 65534U;
#line 2497
      update_mask = (u8 )((unsigned int )update_mask | 2U);
    } else {

    }
#line 2501
    spin_unlock_bh(& pxmitpriv->lock);
  } else {

  }
#line 2504
  if ((unsigned int )update_mask != 0U) {
#line 2505
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
  } else {

  }
#line 2506
  return;
}
}
#line 2508 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void xmit_delivery_enabled_frames23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 wmmps_ac ;
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct xmit_frame *pxmitframe ;
  struct sta_priv *pstapriv ;
  struct xmit_priv *pxmitpriv ;
  struct list_head  const  *__mptr ;
  u32 tmp ;

  {
#line 2511
  wmmps_ac = 0U;
#line 2514
  pstapriv = & padapter->stapriv;
#line 2515
  pxmitpriv = & padapter->xmitpriv;
#line 2518
  spin_lock_bh(& pxmitpriv->lock);
#line 2520
  phead = get_list_head(& psta->sleep_q);
#line 2522
  plist = phead->next;
#line 2522
  ptmp = plist->next;
#line 2522
  goto ldv_52208;
  ldv_52207: 
#line 2523
  __mptr = (struct list_head  const  *)plist;
#line 2523
  pxmitframe = (struct xmit_frame *)__mptr;
#line 2525
  switch ((int )pxmitframe->attrib.priority) {
  case 1: ;
  case 2: 
#line 2528
  wmmps_ac = (unsigned int )psta->uapsd_bk & 2U;
#line 2529
  goto ldv_52198;
  case 4: ;
  case 5: 
#line 2532
  wmmps_ac = (unsigned int )psta->uapsd_vi & 2U;
#line 2533
  goto ldv_52198;
  case 6: ;
  case 7: 
#line 2536
  wmmps_ac = (unsigned int )psta->uapsd_vo & 2U;
#line 2537
  goto ldv_52198;
  case 0: ;
  case 3: ;
  default: 
#line 2541
  wmmps_ac = (unsigned int )psta->uapsd_be & 2U;
#line 2542
  goto ldv_52198;
  }
  ldv_52198: ;
#line 2545
  if ((unsigned int )wmmps_ac == 0U) {
#line 2546
    goto ldv_52206;
  } else {

  }
#line 2548
  list_del_init(& pxmitframe->list);
#line 2550
  psta->sleepq_len = psta->sleepq_len - 1U;
#line 2551
  psta->sleepq_ac_len = psta->sleepq_ac_len - 1U;
#line 2553
  if (psta->sleepq_ac_len != 0U) {
#line 2554
    pxmitframe->attrib.mdata = 1U;
#line 2555
    pxmitframe->attrib.eosp = 0U;
  } else {
#line 2557
    pxmitframe->attrib.mdata = 0U;
#line 2558
    pxmitframe->attrib.eosp = 1U;
  }
#line 2561
  pxmitframe->attrib.triggered = 1U;
#line 2563
  rtl8723au_hal_xmitframe_enqueue(padapter, pxmitframe);
#line 2565
  if ((psta->sleepq_ac_len == 0U && (unsigned int )psta->has_legacy_ac == 0U) && (unsigned int )wmmps_ac != 0U) {
#line 2567
    tmp = CHKBIT(psta->aid);
#line 2567
    pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap & ~ ((int )((u16 )tmp));
#line 2570
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
  } else {

  }
  ldv_52206: 
#line 2522
  plist = ptmp;
#line 2522
  ptmp = plist->next;
  ldv_52208: ;
#line 2522
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2524
    goto ldv_52207;
  } else {

  }
#line 2573
  spin_unlock_bh(& pxmitpriv->lock);
#line 2574
  return;
}
}
#line 2578 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw_sctx_init23a(struct submit_ctx *sctx , int timeout_ms ) 
{ 


  {
#line 2580
  sctx->timeout_ms = (u32 )timeout_ms;
#line 2581
  init_completion(& sctx->done);
#line 2582
  sctx->status = -1;
#line 2583
  return;
}
}
#line 2585 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
int rtw_sctx_wait23a(struct submit_ctx *sctx ) 
{ 
  int ret ;
  unsigned long expire ;
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 2587
  ret = 0;
#line 2589
  status = 0;
#line 2591
  if (sctx->timeout_ms != 0U) {
#line 2591
    tmp = msecs_to_jiffies(sctx->timeout_ms);
#line 2591
    expire = tmp;
  } else {
#line 2591
    expire = 9223372036854775807UL;
  }
#line 2593
  tmp___0 = wait_for_completion_timeout(& sctx->done, expire);
#line 2593
  if (tmp___0 == 0UL) {
#line 2595
    status = 2;
#line 2596
    if (GlobalDebugLevel23A > 3U) {
#line 2596
      printk("\016RTL8723AU: %s timeout\n", "rtw_sctx_wait23a");
    } else {

    }
  } else {
#line 2598
    status = sctx->status;
  }
#line 2601
  if (status == 0) {
#line 2602
    ret = 1;
  } else {

  }
#line 2604
  return (ret);
}
}
#line 2607 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
static bool rtw_sctx_chk_waring_status(int status ) 
{ 


  {
#line 2609
  switch (status) {
  case 1: ;
  case 3: ;
  case 4: ;
  case 9: ;
  case 10: ;
#line 2615
  return (1);
  default: ;
#line 2617
  return (0);
  }
}
}
#line 2621 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw23a_sctx_done_err(struct submit_ctx **sctx , int status ) 
{ 
  bool tmp ;

  {
#line 2623
  if ((unsigned long )*sctx != (unsigned long )((struct submit_ctx *)0)) {
#line 2624
    tmp = rtw_sctx_chk_waring_status(status);
#line 2624
    if ((int )tmp) {
#line 2625
      if (GlobalDebugLevel23A > 3U) {
#line 2625
        printk("\016RTL8723AU: %s status:%d\n", "rtw23a_sctx_done_err", status);
      } else {

      }
    } else {

    }
#line 2626
    (*sctx)->status = status;
#line 2627
    complete(& (*sctx)->done);
#line 2628
    *sctx = (struct submit_ctx *)0;
  } else {

  }
#line 2630
  return;
}
}
#line 2632 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw_sctx_done23a(struct submit_ctx **sctx ) 
{ 


  {
#line 2634
  rtw23a_sctx_done_err(sctx, 0);
#line 2635
  return;
}
}
#line 2637 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
int rtw_ack_tx_wait23a(struct xmit_priv *pxmitpriv , u32 timeout_ms ) 
{ 
  struct submit_ctx *pack_tx_ops ;
  int tmp ;

  {
#line 2639
  pack_tx_ops = & pxmitpriv->ack_tx_ops;
#line 2641
  pack_tx_ops->timeout_ms = timeout_ms;
#line 2642
  pack_tx_ops->status = -1;
#line 2644
  tmp = rtw_sctx_wait23a(pack_tx_ops);
#line 2644
  return (tmp);
}
}
#line 2647 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void rtw_ack_tx_done23a(struct xmit_priv *pxmitpriv , int status ) 
{ 
  struct submit_ctx *pack_tx_ops ;

  {
#line 2649
  pack_tx_ops = & pxmitpriv->ack_tx_ops;
#line 2651
  if (pxmitpriv->ack_tx != 0) {
#line 2652
    rtw23a_sctx_done_err(& pack_tx_ops, status);
  } else
#line 2654
  if (GlobalDebugLevel23A > 3U) {
#line 2654
    printk("\016RTL8723AU: %s ack_tx not set\n", "rtw_ack_tx_done23a");
  } else {

  }
#line 2655
  return;
}
}
#line 2784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
void *ldv_kmem_cache_alloc_830(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2787
  ldv_check_alloc_flags(flags);
#line 2789
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2790
  return ((void *)0);
}
}
#line 2828 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
int ldv_pskb_expand_head_836(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2831
  ldv_check_alloc_flags(flags);
#line 2833
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2833
  return (tmp);
}
}
#line 2844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct sk_buff *ldv_skb_clone_838(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2847
  ldv_check_alloc_flags(flags);
#line 2849
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2849
  return (tmp);
}
}
#line 2860 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct sk_buff *ldv_skb_copy_840(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2863
  ldv_check_alloc_flags(flags);
#line 2865
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2865
  return (tmp);
}
}
#line 2868 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_841(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2871
  ldv_check_alloc_flags(flags);
#line 2873
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2873
  return (tmp);
}
}
#line 2876 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_842(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2879
  ldv_check_alloc_flags(flags);
#line 2881
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2881
  return (tmp);
}
}
#line 2884 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_843(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2887
  ldv_check_alloc_flags(flags);
#line 2889
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2889
  return (tmp);
}
}
#line 2892 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
int ldv_pskb_expand_head_844(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2895
  ldv_check_alloc_flags(flags);
#line 2897
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2897
  return (tmp);
}
}
#line 2900 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
int ldv_pskb_expand_head_845(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2903
  ldv_check_alloc_flags(flags);
#line 2905
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2905
  return (tmp);
}
}
#line 2908 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_xmit.o.c.prepared"
struct sk_buff *ldv_skb_clone_846(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2911
  ldv_check_alloc_flags(flags);
#line 2913
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2913
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_872(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_880(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_888(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_882(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_878(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_886(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_887(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_883(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_884(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_885(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 196 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
void PHY_SetBWMode23a8723A(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ,
                           unsigned char Offset ) ;
#line 203
void PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) ;
#line 110 "drivers/staging/rtl8723au/include/hal_intf.h"
void rtw_hal_update_ra_mask23a(struct sta_info *psta , u8 rssi_level ) ;
#line 171 "drivers/staging/rtl8723au/include/hal_com.h"
void rtl8723a_set_ampdu_min_space(struct rtw_adapter *padapter , u8 MinSpacingToSet ) ;
#line 172
void rtl8723a_set_ampdu_factor(struct rtw_adapter *padapter , u8 FactorToSet ) ;
#line 173
void rtl8723a_set_acm_ctrl(struct rtw_adapter *padapter , u8 ctrl ) ;
#line 174
void rtl8723a_set_media_status(struct rtw_adapter *padapter , u8 status ) ;
#line 181
void rtl8723a_set_slot_time(struct rtw_adapter *padapter , u8 slottime ) ;
#line 182
void rtl8723a_ack_preamble(struct rtw_adapter *padapter , u8 bShortPreamble ) ;
#line 185
void rtl8723a_cam_invalid_all(struct rtw_adapter *padapter ) ;
#line 193
void rtl8723a_set_resp_sifs(struct rtw_adapter *padapter , u8 r2t1 , u8 r2t2 , u8 t2t1 ,
                            u8 t2t2 ) ;
#line 195
void rtl8723a_set_ac_param_vo(struct rtw_adapter *padapter , u32 vo ) ;
#line 196
void rtl8723a_set_ac_param_vi(struct rtw_adapter *padapter , u32 vi ) ;
#line 197
void rtl8723a_set_ac_param_be(struct rtw_adapter *padapter , u32 be ) ;
#line 198
void rtl8723a_set_ac_param_bk(struct rtw_adapter *padapter , u32 bk ) ;
#line 466 "drivers/staging/rtl8723au/include/rtw_mlme_ext.h"
unsigned char networktype_to_raid23a(unsigned char network_type ) ;
#line 467
u8 judge_network_type23a(struct rtw_adapter *padapter , unsigned char *rate , int ratelen ) ;
#line 477
__inline void rtw_set_oper_ch23a(struct rtw_adapter *adapter , u8 ch ) ;
#line 479
__inline void rtw_set_oper_bw23a(struct rtw_adapter *adapter , u8 bw ) ;
#line 481
__inline void rtw_set_oper_ch23aoffset23a(struct rtw_adapter *adapter , u8 offset ) ;
#line 491
void invalidate_cam_all23a(struct rtw_adapter *padapter ) ;
#line 537
unsigned int update_basic_rate23a(unsigned char *ptn , unsigned int ptn_sz ) ;
#line 538
unsigned int update_supported_rate23a(unsigned char *ptn , unsigned int ptn_sz ) ;
#line 539
unsigned int update_MSC_rate23a(struct HT_caps_element *pHT_caps ) ;
#line 546
unsigned char get_highest_rate_idx23a(u32 mask ) ;
#line 550
bool is_ap_in_wep23a(struct rtw_adapter *padapter ) ;
#line 551
bool should_forbid_n_rate23a(struct rtw_adapter *padapter ) ;
#line 604
int cckrates_included23a(unsigned char *rate , int ratelen ) ;
#line 605
int cckratesonly_included23a(unsigned char *rate , int ratelen ) ;
#line 272 "drivers/staging/rtl8723au/include/drv_types.h"
int rtw_handle_dualmac23a(struct rtw_adapter *adapter , bool init ) ;
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char ARTHEROS_OUI1[3U]  = {      0U,      3U,      127U};
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char ARTHEROS_OUI2[3U]  = {      0U,      19U,      116U};
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char BROADCOM_OUI1[3U]  = {      0U,      16U,      24U};
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char BROADCOM_OUI2[3U]  = {      0U,      10U,      247U};
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char CISCO_OUI[3U]  = {      0U,      64U,      150U};
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char MARVELL_OUI[3U]  = {      0U,      80U,      67U};
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char RALINK_OUI[3U]  = {      0U,      12U,      67U};
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char REALTEK_OUI[3U]  = {      0U,      224U,      76U};
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char AIRGOCAP_OUI[3U]  = {      0U,      10U,      245U};
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char EPIGRAM_OUI[3U]  = {      0U,      144U,      76U};
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char WPA_TKIP_CIPHER[4U]  = {      0U,      80U,      242U,      2U};
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char RSN_TKIP_CIPHER[4U]  = {      0U,      15U,      172U,      2U};
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static u8 rtw_basic_rate_cck[4U]  = {      130U,      132U,      139U,      150U};
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static u8 rtw_basic_rate_ofdm[3U]  = {      140U,      152U,      176U};
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static u8 rtw_basic_rate_mix[7U]  = {      130U,      132U,      139U,      150U, 
        140U,      152U,      176U};
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int cckrates_included23a(unsigned char *rate , int ratelen ) 
{ 
  int i ;

  {
#line 289
  i = 0;
#line 289
  goto ldv_51428;
  ldv_51427: ;
#line 290
  if (((((int )*(rate + (unsigned long )i) & 127) == 2 || ((int )*(rate + (unsigned long )i) & 127) == 4) || ((int )*(rate + (unsigned long )i) & 127) == 11) || ((int )*(rate + (unsigned long )i) & 127) == 22) {
#line 292
    return (1);
  } else {

  }
#line 289
  i = i + 1;
  ldv_51428: ;
#line 289
  if (i < ratelen) {
#line 291
    goto ldv_51427;
  } else {

  }

#line 295
  return (0);
}
}
#line 298 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int cckratesonly_included23a(unsigned char *rate , int ratelen ) 
{ 
  int i ;

  {
#line 302
  i = 0;
#line 302
  goto ldv_51436;
  ldv_51435: ;
#line 303
  if (((((int )*(rate + (unsigned long )i) & 127) != 2 && ((int )*(rate + (unsigned long )i) & 127) != 4) && ((int )*(rate + (unsigned long )i) & 127) != 11) && ((int )*(rate + (unsigned long )i) & 127) != 22) {
#line 305
    return (0);
  } else {

  }
#line 302
  i = i + 1;
  ldv_51436: ;
#line 302
  if (i < ratelen) {
#line 304
    goto ldv_51435;
  } else {

  }

#line 308
  return (1);
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
unsigned char networktype_to_raid23a(unsigned char network_type ) 
{ 
  unsigned char raid ;

  {
#line 315
  switch ((int )network_type) {
  case 1: 
#line 317
  raid = 6U;
#line 318
  goto ldv_51443;
  case 4: ;
  case 2: 
#line 321
  raid = 5U;
#line 322
  goto ldv_51443;
  case 3: 
#line 324
  raid = 4U;
#line 325
  goto ldv_51443;
  case 8: ;
  case 16: 
#line 328
  raid = 3U;
#line 329
  goto ldv_51443;
  case 20: ;
  case 10: 
#line 332
  raid = 1U;
#line 333
  goto ldv_51443;
  case 11: 
#line 335
  raid = 0U;
#line 336
  goto ldv_51443;
  default: 
#line 338
  raid = 4U;
#line 339
  goto ldv_51443;
  }
  ldv_51443: ;
#line 341
  return (raid);
}
}
#line 344 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
u8 judge_network_type23a(struct rtw_adapter *padapter , unsigned char *rate , int ratelen ) 
{ 
  u8 network_type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int tmp ;
  int tmp___0 ;

  {
#line 347
  network_type = 0U;
#line 348
  pmlmeext = & padapter->mlmeextpriv;
#line 349
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 351
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
#line 352
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 353
      network_type = 16U;
    } else {

    }
#line 354
    network_type = (u8 )((unsigned int )network_type | 4U);
  } else {
#line 356
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 357
      network_type = 8U;
    } else {

    }
#line 359
    tmp___0 = cckratesonly_included23a(rate, ratelen);
#line 359
    if (tmp___0 == 1) {
#line 360
      network_type = (u8 )((unsigned int )network_type | 1U);
    } else {
#line 361
      tmp = cckrates_included23a(rate, ratelen);
#line 361
      if (tmp == 1) {
#line 362
        network_type = (u8 )((unsigned int )network_type | 3U);
      } else {
#line 364
        network_type = (u8 )((unsigned int )network_type | 2U);
      }
    }
  }
#line 366
  return (network_type);
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned char ratetbl_val_2wifirate(unsigned char rate ) 
{ 
  unsigned char val ;

  {
#line 371
  val = 0U;
#line 373
  switch ((int )rate & 127) {
  case 0: 
#line 375
  val = 2U;
#line 376
  goto ldv_51466;
  case 1: 
#line 378
  val = 4U;
#line 379
  goto ldv_51466;
  case 2: 
#line 381
  val = 11U;
#line 382
  goto ldv_51466;
  case 3: 
#line 384
  val = 22U;
#line 385
  goto ldv_51466;
  case 4: 
#line 387
  val = 12U;
#line 388
  goto ldv_51466;
  case 5: 
#line 390
  val = 18U;
#line 391
  goto ldv_51466;
  case 6: 
#line 393
  val = 24U;
#line 394
  goto ldv_51466;
  case 7: 
#line 396
  val = 36U;
#line 397
  goto ldv_51466;
  case 8: 
#line 399
  val = 48U;
#line 400
  goto ldv_51466;
  case 9: 
#line 402
  val = 72U;
#line 403
  goto ldv_51466;
  case 10: 
#line 405
  val = 96U;
#line 406
  goto ldv_51466;
  case 11: 
#line 408
  val = 108U;
#line 409
  goto ldv_51466;
  }
  ldv_51466: ;
#line 411
  return (val);
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static int is_basicrate(struct rtw_adapter *padapter , unsigned char rate ) 
{ 
  int i ;
  unsigned char val ;
  struct mlme_ext_priv *pmlmeext ;
  unsigned char tmp ;

  {
#line 418
  pmlmeext = & padapter->mlmeextpriv;
#line 420
  i = 0;
#line 420
  goto ldv_51486;
  ldv_51485: 
#line 421
  val = pmlmeext->basicrate[i];
#line 423
  if ((unsigned int )val != 255U && (unsigned int )val != 254U) {
#line 424
    tmp = ratetbl_val_2wifirate((int )val);
#line 424
    if ((int )tmp == (int )rate) {
#line 425
      return (1);
    } else {

    }
  } else {

  }
#line 420
  i = i + 1;
  ldv_51486: ;
#line 420
  if (i <= 12) {
#line 422
    goto ldv_51485;
  } else {

  }

#line 429
  return (0);
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static unsigned int ratetbl2rateset(struct rtw_adapter *padapter , unsigned char *rateset ) 
{ 
  int i ;
  unsigned char rate ;
  unsigned int len ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;

  {
#line 437
  len = 0U;
#line 438
  pmlmeext = & padapter->mlmeextpriv;
#line 440
  i = 0;
#line 440
  goto ldv_51502;
  ldv_51501: 
#line 441
  rate = pmlmeext->datarate[i];
#line 443
  switch ((int )rate) {
  case 255: ;
#line 445
  return (len);
  case 254: ;
#line 447
  goto ldv_51498;
  default: 
#line 449
  rate = ratetbl_val_2wifirate((int )rate);
#line 451
  tmp = is_basicrate(padapter, (int )rate);
#line 451
  if (tmp == 1) {
#line 452
    rate = (unsigned int )rate | 128U;
  } else {

  }
#line 454
  *(rateset + (unsigned long )len) = rate;
#line 455
  len = len + 1U;
#line 456
  goto ldv_51500;
  }
  ldv_51500: ;
  ldv_51498: 
#line 440
  i = i + 1;
  ldv_51502: ;
#line 440
  if (i <= 12) {
#line 442
    goto ldv_51501;
  } else {

  }

#line 459
  return (len);
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void get_rate_set23a(struct rtw_adapter *padapter , unsigned char *pbssrate , int *bssrate_len ) 
{ 
  unsigned char supportedrates[13U] ;
  unsigned int tmp ;
  size_t __len ;
  void *__ret ;

  {
#line 467
  memset((void *)(& supportedrates), 0, 13UL);
#line 468
  tmp = ratetbl2rateset(padapter, (unsigned char *)(& supportedrates));
#line 468
  *bssrate_len = (int )tmp;
#line 469
  __len = (size_t )*bssrate_len;
#line 469
  __ret = __builtin_memcpy((void *)pbssrate, (void const   *)(& supportedrates), __len);
#line 471
  return;
}
}
#line 472 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void UpdateBrateTbl23a(struct rtw_adapter *Adapter , u8 *mBratesOS ) 
{ 
  u8 i ;
  u8 rate ;

  {
#line 478
  i = 0U;
#line 478
  goto ldv_51529;
  ldv_51528: 
#line 479
  rate = (unsigned int )*(mBratesOS + (unsigned long )i) & 127U;
#line 480
  switch ((int )rate) {
  case 2: ;
  case 4: ;
  case 11: ;
  case 22: ;
  case 12: ;
  case 24: ;
  case 48: 
#line 488
  *(mBratesOS + (unsigned long )i) = (u8 )((unsigned int )*(mBratesOS + (unsigned long )i) | 128U);
#line 489
  goto ldv_51526;
  default: ;
#line 491
  goto ldv_51526;
  }
  ldv_51526: 
#line 478
  i = (u8 )((int )i + 1);
  ldv_51529: ;
#line 478
  if ((unsigned int )i <= 15U) {
#line 480
    goto ldv_51528;
  } else {

  }

#line 485
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void Update23aTblForSoftAP(u8 *bssrateset , u32 bssratelen ) 
{ 
  u8 i ;
  u8 rate ;

  {
#line 501
  i = 0U;
#line 501
  goto ldv_51543;
  ldv_51542: 
#line 502
  rate = (unsigned int )*(bssrateset + (unsigned long )i) & 127U;
#line 503
  switch ((int )rate) {
  case 2: ;
  case 4: ;
  case 11: ;
  case 22: 
#line 508
  *(bssrateset + (unsigned long )i) = (u8 )((unsigned int )*(bssrateset + (unsigned long )i) | 128U);
#line 509
  goto ldv_51541;
  }
  ldv_51541: 
#line 501
  i = (u8 )((int )i + 1);
  ldv_51543: ;
#line 501
  if ((u32 )i < bssratelen) {
#line 503
    goto ldv_51542;
  } else {

  }

#line 508
  return;
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void Set_MSR23a(struct rtw_adapter *padapter , u8 type ) 
{ 


  {
#line 516
  rtl8723a_set_media_status(padapter, (int )type);
#line 517
  return;
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
__inline void rtw_set_oper_ch23a(struct rtw_adapter *adapter , u8 ch ) 
{ 


  {
#line 526
  (adapter->dvobj)->oper_channel = ch;
#line 527
  return;
}
}
#line 534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
__inline void rtw_set_oper_bw23a(struct rtw_adapter *adapter , u8 bw ) 
{ 


  {
#line 536
  (adapter->dvobj)->oper_bwmode = bw;
#line 537
  return;
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
__inline void rtw_set_oper_ch23aoffset23a(struct rtw_adapter *adapter , u8 offset ) 
{ 


  {
#line 546
  (adapter->dvobj)->oper_ch_offset = offset;
#line 547
  return;
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void SelectChannel23a(struct rtw_adapter *padapter , unsigned char channel ) 
{ 


  {
#line 551
  mutex_lock_nested(& (padapter->dvobj)->setch_mutex, 0U);
#line 554
  rtw_set_oper_ch23a(padapter, (int )channel);
#line 556
  PHY_SwChnl8723A(padapter, (int )channel);
#line 558
  mutex_unlock(& (padapter->dvobj)->setch_mutex);
#line 559
  return;
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static void set_bwmode(struct rtw_adapter *padapter , unsigned short bwmode , unsigned char channel_offset ) 
{ 


  {
#line 564
  mutex_lock_nested(& (padapter->dvobj)->setbw_mutex, 0U);
#line 567
  rtw_set_oper_bw23a(padapter, (int )((u8 )bwmode));
#line 568
  rtw_set_oper_ch23aoffset23a(padapter, (int )channel_offset);
#line 570
  PHY_SetBWMode23a8723A(padapter, (enum ht_channel_width )bwmode, (int )channel_offset);
#line 573
  mutex_unlock(& (padapter->dvobj)->setbw_mutex);
#line 574
  return;
}
}
#line 576 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void set_channel_bwmode23a(struct rtw_adapter *padapter , unsigned char channel ,
                           unsigned char channel_offset , unsigned short bwmode ) 
{ 
  u8 center_ch ;

  {
#line 581
  if ((unsigned int )padapter->bNotifyChannelChange != 0U) {
#line 582
    if (GlobalDebugLevel23A > 3U) {
#line 582
      printk("\016RTL8723AU: [%s] ch = %d, offset = %d, bwmode = %d\n", "set_channel_bwmode23a",
             (int )channel, (int )channel_offset, (int )bwmode);
    } else {

    }
  } else {

  }
#line 585
  if ((unsigned int )bwmode == 0U || (unsigned int )channel_offset == 0U) {
#line 588
    center_ch = channel;
  } else
#line 591
  if ((unsigned int )channel_offset == 1U) {
#line 593
    center_ch = (unsigned int )channel + 2U;
  } else {
#line 596
    center_ch = (unsigned int )channel + 254U;
  }
#line 601
  mutex_lock_nested(& (padapter->dvobj)->setch_mutex, 0U);
#line 604
  rtw_set_oper_ch23a(padapter, (int )channel);
#line 605
  rtw_set_oper_bw23a(padapter, (int )((u8 )bwmode));
#line 606
  rtw_set_oper_ch23aoffset23a(padapter, (int )channel_offset);
#line 608
  PHY_SwChnl8723A(padapter, (int )center_ch);
#line 610
  mutex_unlock(& (padapter->dvobj)->setch_mutex);
#line 612
  set_bwmode(padapter, (int )bwmode, (int )channel_offset);
#line 613
  return;
}
}
#line 620 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
u16 get_beacon_interval23a(struct wlan_bssid_ex *bss ) 
{ 
  unsigned short val ;
  size_t __len ;
  void *__ret ;
  __le16 *tmp ;
  __le16 *tmp___0 ;

  {
#line 623
  __len = 2UL;
#line 623
  if (__len > 63UL) {
#line 623
    tmp = rtw_get_beacon_interval23a_from_ie((u8 *)(& bss->IEs));
#line 623
    __ret = __memcpy((void *)(& val), (void const   *)tmp, __len);
  } else {
#line 623
    tmp___0 = rtw_get_beacon_interval23a_from_ie((u8 *)(& bss->IEs));
#line 623
    __ret = __builtin_memcpy((void *)(& val), (void const   *)tmp___0, __len);
  }
#line 625
  return (val);
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool is_client_associated_to_ap23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 633
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 634
    return (0);
  } else {

  }
#line 636
  pmlmeext = & padapter->mlmeextpriv;
#line 637
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 639
  if ((pmlmeinfo->state & 16384U) != 0U && (pmlmeinfo->state & 3U) == 2U) {
#line 641
    return (1);
  } else {
#line 643
    return (0);
  }
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool is_client_associated_to_ibss23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 648
  pmlmeext = & padapter->mlmeextpriv;
#line 649
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 651
  if ((pmlmeinfo->state & 16384U) != 0U && (pmlmeinfo->state & 3U) == 1U) {
#line 653
    return (1);
  } else {
#line 655
    return (0);
  }
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool is_IBSS_empty23a(struct rtw_adapter *padapter ) 
{ 
  unsigned int i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 661
  pmlmeext = & padapter->mlmeextpriv;
#line 662
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 664
  i = 2U;
#line 664
  goto ldv_51614;
  ldv_51613: ;
#line 665
  if (pmlmeinfo->FW_sta_info[i].status == 1U) {
#line 666
    return (0);
  } else {

  }
#line 664
  i = i + 1U;
  ldv_51614: ;
#line 664
  if (i <= 31U) {
#line 666
    goto ldv_51613;
  } else {

  }

#line 669
  return (1);
}
}
#line 672 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
unsigned int decide_wait_for_beacon_timeout23a(unsigned int bcn_interval ) 
{ 


  {
#line 674
  if (bcn_interval << 2 <= 5999U) {
#line 675
    return (6000U);
  } else
#line 676
  if (bcn_interval << 2 > 20000U) {
#line 677
    return (20000U);
  } else {
#line 679
    return (bcn_interval << 2);
  }
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void invalidate_cam_all23a(struct rtw_adapter *padapter ) 
{ 


  {
#line 684
  rtl8723a_cam_invalid_all(padapter);
#line 685
  return;
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void clear_cam_entry23a(struct rtw_adapter *padapter , u8 entry ) 
{ 
  unsigned char null_sta[6U] ;
  unsigned char null_key[16U] ;

  {
#line 689
  null_sta[0] = 0U;
#line 689
  null_sta[1] = 0U;
#line 689
  null_sta[2] = 0U;
#line 689
  null_sta[3] = 0U;
#line 689
  null_sta[4] = 0U;
#line 689
  null_sta[5] = 0U;
#line 691
  null_key[0] = 0U;
#line 691
  null_key[1] = 0U;
#line 691
  null_key[2] = 0U;
#line 691
  null_key[3] = 0U;
#line 691
  null_key[4] = 0U;
#line 691
  null_key[5] = 0U;
#line 691
  null_key[6] = 0U;
#line 691
  null_key[7] = 0U;
#line 691
  null_key[8] = 0U;
#line 691
  null_key[9] = 0U;
#line 691
  null_key[10] = 0U;
#line 691
  null_key[11] = 0U;
#line 691
  null_key[12] = 0U;
#line 691
  null_key[13] = 0U;
#line 691
  null_key[14] = 0U;
#line 691
  null_key[15] = 0U;
#line 695
  rtl8723a_cam_write(padapter, (int )entry, 0, (u8 const   *)(& null_sta), (u8 const   *)(& null_key));
#line 696
  return;
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int allocate_fw_sta_entry23a(struct rtw_adapter *padapter ) 
{ 
  unsigned int mac_id ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 701
  pmlmeext = & padapter->mlmeextpriv;
#line 702
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 704
  mac_id = 2U;
#line 704
  goto ldv_51636;
  ldv_51635: ;
#line 705
  if (pmlmeinfo->FW_sta_info[mac_id].status == 0U) {
#line 706
    pmlmeinfo->FW_sta_info[mac_id].status = 1U;
#line 707
    pmlmeinfo->FW_sta_info[mac_id].retry = 0U;
#line 708
    goto ldv_51634;
  } else {

  }
#line 704
  mac_id = mac_id + 1U;
  ldv_51636: ;
#line 704
  if (mac_id <= 31U) {
#line 706
    goto ldv_51635;
  } else {

  }
  ldv_51634: ;
#line 712
  return ((int )mac_id);
}
}
#line 715 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void flush_all_cam_entry23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 717
  pmlmeext = & padapter->mlmeextpriv;
#line 718
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 720
  rtl8723a_cam_invalid_all(padapter);
#line 722
  memset((void *)(& pmlmeinfo->FW_sta_info), 0, 1280UL);
#line 723
  return;
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int WMM_param_handler23a(struct rtw_adapter *padapter , u8 *p ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;

  {
#line 728
  pmlmepriv = & padapter->mlmepriv;
#line 729
  pmlmeext = & padapter->mlmeextpriv;
#line 730
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 732
  if (pmlmepriv->qos_option == 0U) {
#line 733
    pmlmeinfo->WMM_enable = 0U;
#line 734
    return (0);
  } else {

  }
#line 737
  pmlmeinfo->WMM_enable = 1U;
#line 738
  __len = 18UL;
#line 738
  if (__len > 63UL) {
#line 738
    __ret = __memcpy((void *)(& pmlmeinfo->WMM_param), (void const   *)p + 8U, __len);
  } else {
#line 738
    __ret = __builtin_memcpy((void *)(& pmlmeinfo->WMM_param), (void const   *)p + 8U,
                             __len);
  }
#line 740
  return (1);
}
}
#line 743 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void WMMOnAssocRsp23a(struct rtw_adapter *padapter ) 
{ 
  u8 ACI ;
  u8 ACM ;
  u8 AIFS ;
  u8 ECWMin ;
  u8 ECWMax ;
  u8 aSifsTime ;
  u8 acm_mask ;
  u16 TXOP ;
  u32 acParm ;
  u32 i ;
  u32 edca[4U] ;
  u32 inx[4U] ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct xmit_priv *pxmitpriv ;
  struct registry_priv *pregpriv ;
  u32 j ;
  u32 tmp ;
  u32 change_inx ;

  {
#line 750
  pmlmeext = & padapter->mlmeextpriv;
#line 751
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 752
  pxmitpriv = & padapter->xmitpriv;
#line 753
  pregpriv = & padapter->registrypriv;
#line 755
  if ((unsigned int )pmlmeinfo->WMM_enable == 0U) {
#line 756
    padapter->mlmepriv.acm_mask = 0U;
#line 757
    return;
  } else {

  }
#line 760
  acm_mask = 0U;
#line 762
  if ((unsigned int )pmlmeext->cur_wireless_mode == 1U) {
#line 763
    aSifsTime = 10U;
  } else {
#line 765
    aSifsTime = 16U;
  }
#line 767
  i = 0U;
#line 767
  goto ldv_51677;
  ldv_51676: 
#line 768
  ACI = (unsigned int )((u8 )((int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5)) & 3U;
#line 769
  ACM = (unsigned int )((u8 )((int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4)) & 1U;
#line 772
  AIFS = ((unsigned int )pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 15U) * (unsigned int )pmlmeinfo->slotTime + (unsigned int )aSifsTime;
#line 775
  ECWMin = (unsigned int )pmlmeinfo->WMM_param.ac_param[i].CW & 15U;
#line 776
  ECWMax = (u8 )((int )pmlmeinfo->WMM_param.ac_param[i].CW >> 4);
#line 777
  TXOP = pmlmeinfo->WMM_param.ac_param[i].TXOP_limit;
#line 779
  acParm = (u32 )((((int )AIFS | ((int )ECWMin << 8)) | ((int )ECWMax << 12)) | ((int )TXOP << 16));
#line 781
  switch ((int )ACI) {
  case 0: 
#line 783
  rtl8723a_set_ac_param_be(padapter, acParm);
#line 784
  acm_mask = ((unsigned int )ACM != 0U ? 2U : 0U) | (unsigned int )acm_mask;
#line 785
  edca[2] = acParm;
#line 786
  goto ldv_51672;
  case 1: 
#line 788
  rtl8723a_set_ac_param_bk(padapter, acParm);
#line 790
  edca[3] = acParm;
#line 791
  goto ldv_51672;
  case 2: 
#line 793
  rtl8723a_set_ac_param_vi(padapter, acParm);
#line 794
  acm_mask = ((unsigned int )ACM != 0U ? 4U : 0U) | (unsigned int )acm_mask;
#line 795
  edca[1] = acParm;
#line 796
  goto ldv_51672;
  case 3: 
#line 798
  rtl8723a_set_ac_param_vo(padapter, acParm);
#line 799
  acm_mask = ((unsigned int )ACM != 0U ? 8U : 0U) | (unsigned int )acm_mask;
#line 800
  edca[0] = acParm;
#line 801
  goto ldv_51672;
  }
  ldv_51672: ;
#line 804
  if (GlobalDebugLevel23A > 3U) {
#line 804
    printk("\016RTL8723AU: WMM(%x): %x, %x\n", (int )ACI, (int )ACM, acParm);
  } else {

  }
#line 767
  i = i + 1U;
  ldv_51677: ;
#line 767
  if (i <= 3U) {
#line 769
    goto ldv_51676;
  } else {

  }

#line 807
  if ((unsigned int )padapter->registrypriv.acm_method == 1U) {
#line 808
    rtl8723a_set_acm_ctrl(padapter, (int )acm_mask);
  } else {
#line 810
    padapter->mlmepriv.acm_mask = acm_mask;
  }
#line 812
  inx[0] = 0U;
#line 812
  inx[1] = 1U;
#line 812
  inx[2] = 2U;
#line 812
  inx[3] = 3U;
#line 814
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
#line 815
    change_inx = 0U;
#line 818
    i = 0U;
#line 818
    goto ldv_51686;
    ldv_51685: 
#line 819
    j = i + 1U;
#line 819
    goto ldv_51683;
    ldv_51682: ;
#line 821
    if ((edca[j] & 65535U) < (edca[i] & 65535U)) {
#line 822
      change_inx = 1U;
    } else
#line 823
    if (((edca[j] ^ edca[i]) & 65535U) == 0U) {
#line 826
      if (edca[j] >> 16 > edca[i] >> 16) {
#line 827
        change_inx = 1U;
      } else {

      }
    } else {

    }
#line 830
    if (change_inx != 0U) {
#line 831
      tmp = edca[i];
#line 832
      edca[i] = edca[j];
#line 833
      edca[j] = tmp;
#line 835
      tmp = inx[i];
#line 836
      inx[i] = inx[j];
#line 837
      inx[j] = tmp;
#line 839
      change_inx = 0U;
    } else {

    }
#line 819
    j = j + 1U;
    ldv_51683: ;
#line 819
    if (j <= 3U) {
#line 821
      goto ldv_51682;
    } else {

    }
#line 818
    i = i + 1U;
    ldv_51686: ;
#line 818
    if (i <= 3U) {
#line 820
      goto ldv_51685;
    } else {

    }

  } else {

  }
#line 845
  i = 0U;
#line 845
  goto ldv_51689;
  ldv_51688: 
#line 846
  pxmitpriv->wmm_para_seq[i] = (u8 )inx[i];
#line 847
  if (GlobalDebugLevel23A > 3U) {
#line 847
    printk("\016RTL8723AU: wmm_para_seq(%d): %d\n", i, (int )pxmitpriv->wmm_para_seq[i]);
  } else {

  }
#line 845
  i = i + 1U;
  ldv_51689: ;
#line 845
  if (i <= 3U) {
#line 847
    goto ldv_51688;
  } else {

  }

#line 851
  return;
}
}
#line 854 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static void bwmode_update_check(struct rtw_adapter *padapter , u8 *p ) 
{ 
  struct HT_info_element *pHT_info ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct registry_priv *pregistrypriv ;
  struct ht_priv *phtpriv ;
  unsigned char new_bwmode ;
  unsigned char new_ch_offset ;
  struct sta_info *psta ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_priv *pstapriv ;
  struct ht_priv *phtpriv_sta ;

  {
#line 857
  pmlmepriv = & padapter->mlmepriv;
#line 858
  pmlmeext = & padapter->mlmeextpriv;
#line 859
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 860
  pregistrypriv = & padapter->registrypriv;
#line 861
  phtpriv = & pmlmepriv->htpriv;
#line 865
  if ((unsigned long )p == (unsigned long )((u8 *)0U)) {
#line 866
    return;
  } else {

  }
#line 867
  if (phtpriv->ht_option == 0U) {
#line 868
    return;
  } else {

  }
#line 869
  if ((unsigned int )*(p + 1UL) > 22U) {
#line 870
    return;
  } else {

  }
#line 872
  pHT_info = (struct HT_info_element *)p + 2U;
#line 874
  if (((unsigned long )pHT_info->infos[0] & 4UL) != 0UL && (unsigned int )pregistrypriv->cbw40_enable != 0U) {
#line 875
    new_bwmode = 1U;
#line 877
    switch ((int )pHT_info->infos[0] & 3) {
    case 1: 
#line 879
    new_ch_offset = 1U;
#line 880
    goto ldv_51704;
    case 3: 
#line 882
    new_ch_offset = 2U;
#line 883
    goto ldv_51704;
    default: 
#line 885
    new_ch_offset = 0U;
#line 886
    goto ldv_51704;
    }
    ldv_51704: ;
  } else {
#line 889
    new_bwmode = 0U;
#line 890
    new_ch_offset = 0U;
  }
#line 893
  if ((int )pmlmeext->cur_bwmode != (int )new_bwmode || (int )pmlmeext->cur_ch_offset != (int )new_ch_offset) {
#line 895
    pmlmeinfo->bwmode_updated = 1U;
#line 897
    pmlmeext->cur_bwmode = new_bwmode;
#line 898
    pmlmeext->cur_ch_offset = new_ch_offset;
#line 901
    HT_info_handler23a(padapter, p);
  } else {
#line 903
    pmlmeinfo->bwmode_updated = 0U;
  }
#line 905
  if ((unsigned int )pmlmeinfo->bwmode_updated != 0U) {
#line 907
    cur_network = & pmlmeinfo->network;
#line 908
    pstapriv = & padapter->stapriv;
#line 914
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
#line 915
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 916
      phtpriv_sta = & psta->htpriv;
#line 918
      if (phtpriv_sta->ht_option != 0U) {
#line 920
        phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
#line 921
        phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
      } else {
#line 924
        phtpriv_sta->bwmode = 0U;
#line 925
        phtpriv_sta->ch_offset = 0U;
      }
    } else {

    }
  } else {

  }
#line 929
  return;
}
}
#line 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void HT_caps_handler23a(struct rtw_adapter *padapter , u8 *p ) 
{ 
  unsigned int i ;
  u8 rf_type ;
  u8 max_AMPDU_len ;
  u8 min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;

  {
#line 937
  pmlmeext = & padapter->mlmeextpriv;
#line 938
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 939
  pmlmepriv = & padapter->mlmepriv;
#line 940
  phtpriv = & pmlmepriv->htpriv;
#line 942
  if ((unsigned long )p == (unsigned long )((u8 *)0U)) {
#line 943
    return;
  } else {

  }
#line 945
  if (phtpriv->ht_option == 0U) {
#line 946
    return;
  } else {

  }
#line 948
  pmlmeinfo->HT_caps_enable = 1U;
#line 950
  i = 0U;
#line 950
  goto ldv_51724;
  ldv_51723: ;
#line 951
  if (i != 2U) {
#line 954
    pmlmeinfo->HT_caps.u.HT_cap[i] = (int )pmlmeinfo->HT_caps.u.HT_cap[i] & (int )*(p + (unsigned long )(i + 2U));
  } else {
#line 957
    if (((int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 3) > ((int )*(p + (unsigned long )(i + 2U)) & 3)) {
#line 958
      max_AMPDU_len = (unsigned int )*(p + (unsigned long )(i + 2U)) & 3U;
    } else {
#line 960
      max_AMPDU_len = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 3U;
    }
#line 962
    if (((int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 28) > ((int )*(p + (unsigned long )(i + 2U)) & 28)) {
#line 963
      min_MPDU_spacing = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 28U;
    } else {
#line 965
      min_MPDU_spacing = (unsigned int )*(p + (unsigned long )(i + 2U)) & 28U;
    }
#line 967
    pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para = (int )max_AMPDU_len | (int )min_MPDU_spacing;
  }
#line 950
  i = i + 1U;
  ldv_51724: ;
#line 950
  if ((unsigned int )*(p + 1UL) > i) {
#line 952
    goto ldv_51723;
  } else {

  }
#line 975
  pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info;
#line 977
  pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps;
#line 980
  rf_type = rtl8723a_get_rf_type(padapter);
#line 983
  i = 0U;
#line 983
  goto ldv_51727;
  ldv_51726: ;
#line 984
  if ((unsigned int )rf_type == 3U || (unsigned int )rf_type == 0U) {
#line 985
    pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] = (int )pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] & (int )MCS_rate_1R23A[i];
  } else {
#line 988
    pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] = (int )pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] & (int )MCS_rate_2R23A[i];
  }
#line 983
  i = i + 1U;
  ldv_51727: ;
#line 983
  if (i <= 15U) {
#line 985
    goto ldv_51726;
  } else {

  }

#line 991
  return;
}
}
#line 994 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void HT_info_handler23a(struct rtw_adapter *padapter , u8 *p ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv ;
  size_t __len ;
  void *__ret ;

  {
#line 996
  pmlmeext = & padapter->mlmeextpriv;
#line 997
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 998
  pmlmepriv = & padapter->mlmepriv;
#line 999
  phtpriv = & pmlmepriv->htpriv;
#line 1001
  if ((unsigned long )p == (unsigned long )((u8 *)0U)) {
#line 1002
    return;
  } else {

  }
#line 1004
  if (phtpriv->ht_option == 0U) {
#line 1005
    return;
  } else {

  }
#line 1007
  if ((unsigned int )*(p + 1UL) > 22U) {
#line 1008
    return;
  } else {

  }
#line 1010
  pmlmeinfo->HT_info_enable = 1U;
#line 1011
  __len = (size_t )*(p + 1UL);
#line 1011
  __ret = __builtin_memcpy((void *)(& pmlmeinfo->HT_info), (void const   *)p + 2U,
                           __len);
#line 1012
  return;
}
}
#line 1015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void HTOnAssocRsp23a(struct rtw_adapter *padapter ) 
{ 
  unsigned char max_AMPDU_len ;
  unsigned char min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 1020
  pmlmeext = & padapter->mlmeextpriv;
#line 1021
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1023
  if (GlobalDebugLevel23A > 3U) {
#line 1023
    printk("\016RTL8723AU: %s\n", "HTOnAssocRsp23a");
  } else {

  }
#line 1025
  if ((unsigned int )pmlmeinfo->HT_info_enable != 0U && (unsigned int )pmlmeinfo->HT_caps_enable != 0U) {
#line 1026
    pmlmeinfo->HT_enable = 1U;
  } else {
#line 1028
    pmlmeinfo->HT_enable = 0U;
#line 1031
    return;
  }
#line 1039
  max_AMPDU_len = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 3U;
#line 1041
  min_MPDU_spacing = (unsigned char )(((int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 28) >> 2);
#line 1044
  rtl8723a_set_ampdu_min_space(padapter, (int )min_MPDU_spacing);
#line 1045
  rtl8723a_set_ampdu_factor(padapter, (int )max_AMPDU_len);
#line 1046
  return;
}
}
#line 1048 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void ERP_IE_handler23a(struct rtw_adapter *padapter , u8 *p ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;

  {
#line 1050
  pmlmeext = & padapter->mlmeextpriv;
#line 1051
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1053
  if ((unsigned int )*(p + 1UL) > 1U) {
#line 1054
    return;
  } else {

  }
#line 1056
  pmlmeinfo->ERP_enable = 1U;
#line 1057
  __len = (size_t )*(p + 1UL);
#line 1057
  __ret = __builtin_memcpy((void *)(& pmlmeinfo->ERP_IE), (void const   *)p + 2U,
                           __len);
#line 1059
  return;
}
}
#line 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void VCS_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 1062
  pregpriv = & padapter->registrypriv;
#line 1063
  pmlmeext = & padapter->mlmeextpriv;
#line 1064
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1066
  switch ((int )pregpriv->vrtl_carrier_sense) {
  case 0: 
#line 1068
  psta->rtsen = 0U;
#line 1069
  psta->cts2self = 0U;
#line 1070
  goto ldv_51765;
  case 1: ;
#line 1072
  if ((unsigned int )pregpriv->vcs_type == 1U) {
#line 1073
    psta->rtsen = 1U;
#line 1074
    psta->cts2self = 0U;
  } else {
#line 1076
    psta->rtsen = 0U;
#line 1077
    psta->cts2self = 1U;
  }
#line 1079
  goto ldv_51765;
  case 2: ;
  default: ;
#line 1082
  if ((unsigned int )pmlmeinfo->ERP_enable != 0U && ((unsigned long )pmlmeinfo->ERP_IE & 2UL) != 0UL) {
#line 1083
    if ((unsigned int )pregpriv->vcs_type == 1U) {
#line 1084
      psta->rtsen = 1U;
#line 1085
      psta->cts2self = 0U;
    } else {
#line 1087
      psta->rtsen = 0U;
#line 1088
      psta->cts2self = 1U;
    }
  } else {
#line 1091
    psta->rtsen = 0U;
#line 1092
    psta->cts2self = 0U;
  }
#line 1094
  goto ldv_51765;
  }
  ldv_51765: ;
#line 1097
  return;
}
}
#line 1098 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int rtw_check_bcn_info23a(struct rtw_adapter *Adapter , struct ieee80211_mgmt *mgmt ,
                          u32 pkt_len ) 
{ 
  struct wlan_network *cur_network ;
  struct HT_info_element *pht_info ;
  struct ieee80211_ht_cap *pht_cap ;
  struct wlan_bssid_ex *bssid ;
  unsigned short val16 ;
  u16 wpa_len ;
  u16 rsn_len ;
  u8 encryp_protocol ;
  int group_cipher ;
  int pairwise_cipher ;
  int is_8021x ;
  int r ;
  u32 bcn_channel ;
  unsigned short ht_cap_info ;
  unsigned char ht_info_infos_0 ;
  int len ;
  int pie_len ;
  int ie_offset ;
  u8 const   *p ;
  u8 *pie ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___5 ;

  {
#line 1101
  cur_network = & Adapter->mlmepriv.cur_network;
#line 1106
  wpa_len = 0U;
#line 1106
  rsn_len = 0U;
#line 1108
  group_cipher = 0;
#line 1108
  pairwise_cipher = 0;
#line 1108
  is_8021x = 0;
#line 1116
  tmp = is_client_associated_to_ap23a(Adapter);
#line 1116
  if (tmp) {
#line 1116
    tmp___0 = 0;
  } else {
#line 1116
    tmp___0 = 1;
  }
#line 1116
  if (tmp___0) {
#line 1117
    return (1);
  } else {

  }
#line 1119
  tmp___1 = ieee80211_is_beacon((int )mgmt->frame_control);
#line 1119
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 1119
  if (tmp___2 != 0L) {
#line 1120
    printk("\f%s: received a non beacon frame!\n", "rtw_check_bcn_info23a");
#line 1122
    return (0);
  } else {

  }
#line 1125
  len = (int )(pkt_len - 24U);
#line 1127
  if (len > 768) {
#line 1128
    if (GlobalDebugLevel23A > 3U) {
#line 1128
      printk("\016RTL8723AU: %s IE too long for survey event\n", "rtw_check_bcn_info23a");
    } else {

    }
#line 1129
    return (0);
  } else {

  }
#line 1132
  tmp___3 = memcmp((void const   *)(& cur_network->network.MacAddress), (void const   *)(& mgmt->bssid),
                   6UL);
#line 1132
  if (tmp___3 != 0) {
#line 1133
    if (GlobalDebugLevel23A > 3U) {
#line 1133
      printk("\016RTL8723AU: Oops: rtw_check_network_encrypt linked but recv other bssid bcn\n%02x:%02x:%02x:%02x:%02x:%02x%02x:%02x:%02x:%02x:%02x:%02x",
             (int )*((u8 *)(& mgmt->bssid)), (int )*((u8 *)(& mgmt->bssid) + 1UL),
             (int )*((u8 *)(& mgmt->bssid) + 2UL), (int )*((u8 *)(& mgmt->bssid) + 3UL),
             (int )*((u8 *)(& mgmt->bssid) + 4UL), (int )*((u8 *)(& mgmt->bssid) + 5UL),
             (int )*((u8 *)(& cur_network->network.MacAddress)), (int )*((u8 *)(& cur_network->network.MacAddress) + 1UL),
             (int )*((u8 *)(& cur_network->network.MacAddress) + 2UL), (int )*((u8 *)(& cur_network->network.MacAddress) + 3UL),
             (int )*((u8 *)(& cur_network->network.MacAddress) + 4UL), (int )*((u8 *)(& cur_network->network.MacAddress) + 5UL));
    } else {

    }
#line 1137
    return (1);
  } else {

  }
#line 1140
  tmp___4 = kzalloc(863UL, 32U);
#line 1140
  bssid = (struct wlan_bssid_ex *)tmp___4;
#line 1141
  if ((unsigned long )bssid == (unsigned long )((struct wlan_bssid_ex *)0)) {
#line 1142
    return (0);
  } else {

  }
#line 1144
  bssid->reserved = 1U;
#line 1146
  bssid->Length = (u32 )len + 95U;
#line 1149
  bssid->IELength = (u32 )len;
#line 1150
  __len = (size_t )len;
#line 1150
  __ret = __builtin_memcpy((void *)(& bssid->IEs), (void const   *)(& mgmt->u), __len);
#line 1154
  ie_offset = 12;
#line 1156
  pie = (u8 *)(& bssid->IEs) + (unsigned long )ie_offset;
#line 1157
  pie_len = (int )(pkt_len - (u32 )ie_offset);
#line 1159
  p = cfg80211_find_ie(45, (u8 const   *)pie, pie_len);
#line 1160
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1161
    pht_cap = (struct ieee80211_ht_cap *)p + 2U;
#line 1162
    ht_cap_info = pht_cap->cap_info;
  } else {
#line 1164
    pht_cap = (struct ieee80211_ht_cap *)0;
#line 1165
    ht_cap_info = 0U;
  }
#line 1169
  p = cfg80211_find_ie(61, (u8 const   *)pie, pie_len);
#line 1170
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1171
    pht_info = (struct HT_info_element *)p + 2U;
#line 1172
    ht_info_infos_0 = pht_info->infos[0];
  } else {
#line 1174
    pht_info = (struct HT_info_element *)0;
#line 1175
    ht_info_infos_0 = 0U;
  }
#line 1178
  if ((int )cur_network->BcnInfo.ht_cap_info != (int )ht_cap_info || (((int )ht_info_infos_0 ^ (int )cur_network->BcnInfo.ht_info_infos_0) & 3) != 0) {
#line 1181
    if (GlobalDebugLevel23A > 3U) {
#line 1181
      printk("\016RTL8723AU: %s bcn now: ht_cap_info:%x ht_info_infos_0:%x\n", "rtw_check_bcn_info23a",
             (int )ht_cap_info, (int )ht_info_infos_0);
    } else {

    }
#line 1183
    if (GlobalDebugLevel23A > 3U) {
#line 1183
      printk("\016RTL8723AU: %s bcn link: ht_cap_info:%x ht_info_infos_0:%x\n", "rtw_check_bcn_info23a",
             (int )cur_network->BcnInfo.ht_cap_info, (int )cur_network->BcnInfo.ht_info_infos_0);
    } else {

    }
#line 1186
    if (GlobalDebugLevel23A > 3U) {
#line 1186
      printk("\016RTL8723AU: %s bw mode change, disconnect\n", "rtw_check_bcn_info23a");
    } else {

    }
#line 1188
    cur_network->BcnInfo.ht_cap_info = ht_cap_info;
#line 1189
    cur_network->BcnInfo.ht_info_infos_0 = ht_info_infos_0;
  } else {

  }
#line 1195
  p = cfg80211_find_ie(3, (u8 const   *)pie, pie_len);
#line 1196
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 1197
    bcn_channel = (u32 )*(p + 2UL);
  } else {
#line 1201
    p = cfg80211_find_ie(61, (u8 const   *)pie, pie_len);
#line 1203
    if ((unsigned long )pht_info != (unsigned long )((struct HT_info_element *)0)) {
#line 1204
      bcn_channel = (u32 )pht_info->primary_channel;
    } else {
#line 1206
      if (GlobalDebugLevel23A > 3U) {
#line 1206
        printk("\016RTL8723AU: Oops: %s we don\'t find channel IE, so don\'t check it\n",
               "rtw_check_bcn_info23a");
      } else {

      }
#line 1208
      bcn_channel = (u32 )Adapter->mlmeextpriv.cur_channel;
    }
  }
#line 1211
  if ((u32 )Adapter->mlmeextpriv.cur_channel != bcn_channel) {
#line 1212
    if (GlobalDebugLevel23A > 3U) {
#line 1212
      printk("\016RTL8723AU: %s beacon channel:%d cur channel:%d disconnect\n", "rtw_check_bcn_info23a",
             bcn_channel, (int )Adapter->mlmeextpriv.cur_channel);
    } else {

    }
#line 1215
    goto _mismatch;
  } else {

  }
#line 1219
  p = cfg80211_find_ie(0, (u8 const   *)pie, pie_len);
#line 1220
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1221
    __len___0 = (size_t )*(p + 1UL);
#line 1221
    __ret___0 = __builtin_memcpy((void *)(& bssid->Ssid.ssid), (void const   *)p + 2U,
                                 __len___0);
#line 1222
    bssid->Ssid.ssid_len = *(p + 1UL);
  } else {
#line 1224
    if (GlobalDebugLevel23A > 3U) {
#line 1224
      printk("\016RTL8723AU: %s marc: cannot find SSID for survey event\n", "rtw_check_bcn_info23a");
    } else {

    }
#line 1226
    bssid->Ssid.ssid_len = 0U;
#line 1227
    bssid->Ssid.ssid[0] = 0U;
  }
#line 1230
  if (GlobalDebugLevel23A > 6U) {
#line 1230
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1230
    printk("\016%s bssid.Ssid.Ssid:%s bssid.Ssid.SsidLength:%d cur_network->network.Ssid.Ssid:%s len:%d\n",
           "rtw_check_bcn_info23a", (u8 *)(& bssid->Ssid.ssid), (int )bssid->Ssid.ssid_len,
           (u8 *)(& cur_network->network.Ssid.ssid), (int )cur_network->network.Ssid.ssid_len);
  } else {

  }
#line 1237
  tmp___5 = memcmp((void const   *)(& bssid->Ssid.ssid), (void const   *)(& cur_network->network.Ssid.ssid),
                   32UL);
#line 1237
  if (tmp___5 != 0 || (int )bssid->Ssid.ssid_len != (int )cur_network->network.Ssid.ssid_len) {
#line 1239
    if ((unsigned int )bssid->Ssid.ssid[0] != 0U && (unsigned int )bssid->Ssid.ssid_len != 0U) {
#line 1241
      if (GlobalDebugLevel23A > 3U) {
#line 1241
        printk("\016RTL8723AU: %s(), SSID is not match return FAIL\n", "rtw_check_bcn_info23a");
      } else {

      }
#line 1243
      goto _mismatch;
    } else {

    }
  } else {

  }
#line 1248
  val16 = rtw_get_capability23a(bssid);
#line 1250
  if (((unsigned long )val16 & 16UL) != 0UL) {
#line 1251
    bssid->Privacy = 1U;
  } else {
#line 1253
    bssid->Privacy = 0U;
  }
#line 1255
  if (GlobalDebugLevel23A > 6U) {
#line 1255
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1255
    printk("\016%s(): cur_network->network.Privacy is %d, bssid.Privacy is %d\n",
           "rtw_check_bcn_info23a", cur_network->network.Privacy, bssid->Privacy);
  } else {

  }
#line 1259
  if (cur_network->network.Privacy != bssid->Privacy) {
#line 1260
    if (GlobalDebugLevel23A > 3U) {
#line 1260
      printk("\016RTL8723AU: %s(), privacy is not match return FAIL\n", "rtw_check_bcn_info23a");
    } else {

    }
#line 1261
    goto _mismatch;
  } else {

  }
#line 1264
  rtw_get_sec_ie23a((u8 *)(& bssid->IEs), bssid->IELength, (u8 *)0U, & rsn_len, (u8 *)0U,
                    & wpa_len);
#line 1267
  if ((unsigned int )rsn_len != 0U) {
#line 1268
    encryp_protocol = 3U;
  } else
#line 1269
  if ((unsigned int )wpa_len != 0U) {
#line 1270
    encryp_protocol = 2U;
  } else
#line 1272
  if (bssid->Privacy != 0U) {
#line 1273
    encryp_protocol = 1U;
  } else {
#line 1275
    encryp_protocol = 0U;
  }
#line 1278
  if ((int )cur_network->BcnInfo.encryp_protocol != (int )encryp_protocol) {
#line 1279
    if (GlobalDebugLevel23A > 3U) {
#line 1279
      printk("\016RTL8723AU: %s(): enctyp is not match, return FAIL\n", "rtw_check_bcn_info23a");
    } else {

    }
#line 1280
    goto _mismatch;
  } else {

  }
#line 1283
  if ((unsigned int )encryp_protocol == 2U || (unsigned int )encryp_protocol == 3U) {
#line 1285
    p = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)pie, pie_len);
#line 1288
    if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1289
      r = rtw_parse_wpa_ie23a(p, (int )*(p + 1UL) + 2, & group_cipher, & pairwise_cipher,
                              & is_8021x);
#line 1291
      if (r == 1) {
#line 1292
        if (GlobalDebugLevel23A > 6U) {
#line 1292
          printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1292
          printk("\016%s pnetwork->pairwise_cipher: %d, group_cipher is %d, is_8021x is %d\n",
                 "rtw_check_bcn_info23a", pairwise_cipher, group_cipher, is_8021x);
        } else {

        }
      } else {

      }
    } else {
#line 1298
      p = cfg80211_find_ie(48, (u8 const   *)pie, pie_len);
#line 1300
      if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 1301
        r = rtw_parse_wpa2_ie23a(p, (int )*(p + 1UL) + 2, & group_cipher, & pairwise_cipher,
                                 & is_8021x);
#line 1305
        if (r == 1) {
#line 1306
          if (GlobalDebugLevel23A > 6U) {
#line 1306
            printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 1306
            printk("\016%s pnetwork->pairwise_cipher: %d, pnetwork->group_cipher is %d, is_802x is %d\n",
                   "rtw_check_bcn_info23a", pairwise_cipher, group_cipher, is_8021x);
          } else {

          }
        } else {

        }
      } else {

      }
    }
#line 1316
    if (GlobalDebugLevel23A > 3U) {
#line 1316
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 4);
#line 1316
      printk("\016%s cur_network->group_cipher is %d: %d\n", "rtw_check_bcn_info23a",
             cur_network->BcnInfo.group_cipher, group_cipher);
    } else {

    }
#line 1319
    if (cur_network->BcnInfo.pairwise_cipher != pairwise_cipher || cur_network->BcnInfo.group_cipher != group_cipher) {
#line 1321
      if (GlobalDebugLevel23A > 3U) {
#line 1321
        printk("\016RTL8723AU: %s pairwise_cipher(%x:%x) or group_cipher (%x:%x) is not match, return FAIL\n",
               "rtw_check_bcn_info23a", pairwise_cipher, cur_network->BcnInfo.pairwise_cipher,
               group_cipher, cur_network->BcnInfo.group_cipher);
      } else {

      }
#line 1327
      goto _mismatch;
    } else {

    }
#line 1330
    if (cur_network->BcnInfo.is_8021x != is_8021x) {
#line 1331
      if (GlobalDebugLevel23A > 3U) {
#line 1331
        printk("\016RTL8723AU: %s authentication is not match, return FAIL\n", "rtw_check_bcn_info23a");
      } else {

      }
#line 1333
      goto _mismatch;
    } else {

    }
  } else {

  }
#line 1337
  kfree((void const   *)bssid);
#line 1338
  return (1);
  _mismatch: 
#line 1341
  kfree((void const   *)bssid);
#line 1343
  return (0);
}
}
#line 1346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void update_beacon23a_info(struct rtw_adapter *padapter , u8 *pframe , uint pkt_len ,
                           struct sta_info *psta ) 
{ 
  unsigned int i ;
  unsigned int len ;
  u8 *p ;

  {
#line 1353
  len = pkt_len - 36U;
#line 1356
  i = 0U;
#line 1356
  goto ldv_51816;
  ldv_51815: 
#line 1357
  p = pframe + ((unsigned long )i + 36UL);
#line 1359
  switch ((int )*p) {
  case 61: 
#line 1362
  bwmode_update_check(padapter, p);
#line 1363
  goto ldv_51812;
  case 42: 
#line 1365
  ERP_IE_handler23a(padapter, p);
#line 1366
  VCS_update23a(padapter, psta);
#line 1367
  goto ldv_51812;
  default: ;
#line 1369
  goto ldv_51812;
  }
  ldv_51812: 
#line 1371
  i = ((unsigned int )*(p + 1UL) + i) + 2U;
  ldv_51816: ;
#line 1356
  if (i < len) {
#line 1358
    goto ldv_51815;
  } else {

  }

#line 1363
  return;
}
}
#line 1375 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool is_ap_in_tkip23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 const   *p ;
  int bcn_fixed_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u16 tmp___2 ;

  {
#line 1378
  pmlmeext = & padapter->mlmeextpriv;
#line 1379
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1380
  cur_network = & pmlmeinfo->network;
#line 1384
  bcn_fixed_size = 12;
#line 1387
  tmp___2 = rtw_get_capability23a(cur_network);
#line 1387
  if (((int )tmp___2 & 16) != 0) {
#line 1388
    i = (u32 )bcn_fixed_size;
#line 1388
    goto ldv_51832;
    ldv_51831: 
#line 1389
    p = (u8 const   *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
#line 1391
    switch ((int )*p) {
    case 221: 
#line 1393
    tmp = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
#line 1393
    if (tmp == 0) {
#line 1393
      tmp___0 = memcmp((void const   *)p + 14U, (void const   *)(& WPA_TKIP_CIPHER),
                       4UL);
#line 1393
      if (tmp___0 == 0) {
#line 1395
        return (1);
      } else {

      }
    } else {

    }
#line 1396
    goto ldv_51828;
    case 48: 
#line 1398
    tmp___1 = memcmp((void const   *)p + 10U, (void const   *)(& RSN_TKIP_CIPHER),
                     4UL);
#line 1398
    if (tmp___1 == 0) {
#line 1399
      return (1);
    } else {

    }
#line 1400
    goto ldv_51828;
    default: ;
#line 1402
    goto ldv_51828;
    }
    ldv_51828: 
#line 1404
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_51832: ;
#line 1388
    if (pmlmeinfo->network.IELength > i) {
#line 1390
      goto ldv_51831;
    } else {

    }

#line 1406
    return (0);
  } else {
#line 1408
    return (0);
  }
}
}
#line 1411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool should_forbid_n_rate23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *cur_network ;
  u8 const   *p ;
  int bcn_fixed_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u16 tmp___4 ;

  {
#line 1414
  pmlmepriv = & padapter->mlmepriv;
#line 1415
  cur_network = & pmlmepriv->cur_network.network;
#line 1419
  bcn_fixed_size = 12;
#line 1422
  tmp___4 = rtw_get_capability23a(cur_network);
#line 1422
  if (((int )tmp___4 & 16) != 0) {
#line 1423
    i = (u32 )bcn_fixed_size;
#line 1423
    goto ldv_51847;
    ldv_51846: 
#line 1424
    p = (u8 const   *)(& cur_network->IEs) + (unsigned long )i;
#line 1426
    switch ((int )*p) {
    case 221: 
#line 1428
    tmp = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
#line 1428
    if (tmp == 0) {
#line 1428
      tmp___0 = memcmp((void const   *)p + 14U, (void const   *)(& WPA_CIPHER_SUITE_CCMP23A),
                       4UL);
#line 1428
      if (tmp___0 == 0) {
#line 1433
        return (0);
      } else {
#line 1428
        tmp___1 = memcmp((void const   *)p + 18U, (void const   *)(& WPA_CIPHER_SUITE_CCMP23A),
                         4UL);
#line 1428
        if (tmp___1 == 0) {
#line 1433
          return (0);
        } else {

        }
      }
    } else {

    }
#line 1434
    goto ldv_51843;
    case 48: 
#line 1436
    tmp___2 = memcmp((void const   *)p + 10U, (void const   *)(& RSN_CIPHER_SUITE_CCMP23A),
                     4UL);
#line 1436
    if (tmp___2 == 0) {
#line 1440
      return (0);
    } else {
#line 1436
      tmp___3 = memcmp((void const   *)p + 14U, (void const   *)(& RSN_CIPHER_SUITE_CCMP23A),
                       4UL);
#line 1436
      if (tmp___3 == 0) {
#line 1440
        return (0);
      } else {

      }
    }
    default: ;
#line 1442
    goto ldv_51843;
    }
    ldv_51843: 
#line 1445
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_51847: ;
#line 1423
    if (cur_network->IELength > i) {
#line 1425
      goto ldv_51846;
    } else {

    }

#line 1447
    return (1);
  } else {
#line 1449
    return (0);
  }
}
}
#line 1453 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
bool is_ap_in_wep23a(struct rtw_adapter *padapter ) 
{ 
  u32 i ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 const   *p ;
  int bcn_fixed_size ;
  int tmp ;
  u16 tmp___0 ;

  {
#line 1456
  pmlmeext = & padapter->mlmeextpriv;
#line 1457
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1458
  cur_network = & pmlmeinfo->network;
#line 1462
  bcn_fixed_size = 12;
#line 1465
  tmp___0 = rtw_get_capability23a(cur_network);
#line 1465
  if (((int )tmp___0 & 16) != 0) {
#line 1466
    i = (u32 )bcn_fixed_size;
#line 1466
    goto ldv_51863;
    ldv_51862: 
#line 1467
    p = (u8 const   *)(& pmlmeinfo->network.IEs) + (unsigned long )i;
#line 1469
    switch ((int )*p) {
    case 221: 
#line 1471
    tmp = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                 4UL);
#line 1471
    if (tmp == 0) {
#line 1472
      return (0);
    } else {

    }
#line 1473
    goto ldv_51859;
    case 48: ;
#line 1475
    return (0);
    default: ;
#line 1478
    goto ldv_51859;
    }
    ldv_51859: 
#line 1481
    i = ((u32 )*(p + 1UL) + i) + 2U;
    ldv_51863: ;
#line 1466
    if (pmlmeinfo->network.IELength > i) {
#line 1468
      goto ldv_51862;
    } else {

    }

#line 1484
    return (1);
  } else {
#line 1486
    return (0);
  }
}
}
#line 1489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static int wifirate2_ratetbl_inx23a(unsigned char rate ) 
{ 
  int inx ;

  {
#line 1491
  inx = 0;
#line 1492
  rate = (unsigned int )rate & 127U;
#line 1494
  switch ((int )rate) {
  case 108: 
#line 1496
  inx = 11;
#line 1497
  goto ldv_51870;
  case 96: 
#line 1499
  inx = 10;
#line 1500
  goto ldv_51870;
  case 72: 
#line 1502
  inx = 9;
#line 1503
  goto ldv_51870;
  case 48: 
#line 1505
  inx = 8;
#line 1506
  goto ldv_51870;
  case 36: 
#line 1508
  inx = 7;
#line 1509
  goto ldv_51870;
  case 24: 
#line 1511
  inx = 6;
#line 1512
  goto ldv_51870;
  case 18: 
#line 1514
  inx = 5;
#line 1515
  goto ldv_51870;
  case 12: 
#line 1517
  inx = 4;
#line 1518
  goto ldv_51870;
  case 22: 
#line 1520
  inx = 3;
#line 1521
  goto ldv_51870;
  case 11: 
#line 1523
  inx = 2;
#line 1524
  goto ldv_51870;
  case 4: 
#line 1526
  inx = 1;
#line 1527
  goto ldv_51870;
  case 2: 
#line 1529
  inx = 0;
#line 1530
  goto ldv_51870;
  }
  ldv_51870: ;
#line 1532
  return (inx);
}
}
#line 1535 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
unsigned int update_basic_rate23a(unsigned char *ptn , unsigned int ptn_sz ) 
{ 
  unsigned int i ;
  unsigned int num_of_rate ;
  unsigned int mask ;
  int tmp ;

  {
#line 1538
  mask = 0U;
#line 1540
  num_of_rate = 13U < ptn_sz ? 13U : ptn_sz;
#line 1542
  i = 0U;
#line 1542
  goto ldv_51890;
  ldv_51889: ;
#line 1543
  if ((int )((signed char )*(ptn + (unsigned long )i)) < 0) {
#line 1544
    tmp = wifirate2_ratetbl_inx23a((int )*(ptn + (unsigned long )i));
#line 1544
    mask = (unsigned int )(1 << tmp) | mask;
  } else {

  }
#line 1542
  i = i + 1U;
  ldv_51890: ;
#line 1542
  if (i < num_of_rate) {
#line 1544
    goto ldv_51889;
  } else {

  }

#line 1546
  return (mask);
}
}
#line 1549 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
unsigned int update_supported_rate23a(unsigned char *ptn , unsigned int ptn_sz ) 
{ 
  unsigned int i ;
  unsigned int num_of_rate ;
  unsigned int mask ;
  int tmp ;

  {
#line 1552
  mask = 0U;
#line 1554
  num_of_rate = 13U < ptn_sz ? 13U : ptn_sz;
#line 1556
  i = 0U;
#line 1556
  goto ldv_51900;
  ldv_51899: 
#line 1557
  tmp = wifirate2_ratetbl_inx23a((int )*(ptn + (unsigned long )i));
#line 1557
  mask = (unsigned int )(1 << tmp) | mask;
#line 1556
  i = i + 1U;
  ldv_51900: ;
#line 1556
  if (i < num_of_rate) {
#line 1558
    goto ldv_51899;
  } else {

  }

#line 1558
  return (mask);
}
}
#line 1561 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
unsigned int update_MSC_rate23a(struct HT_caps_element *pHT_caps ) 
{ 
  unsigned int mask ;

  {
#line 1563
  mask = 0U;
#line 1565
  mask = (unsigned int )(((int )pHT_caps->u.HT_cap_element.MCS_rate[0] << 12) | ((int )pHT_caps->u.HT_cap_element.MCS_rate[1] << 20));
#line 1568
  return (mask);
}
}
#line 1571 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int support_short_GI23a(struct rtw_adapter *padapter , struct HT_caps_element *pHT_caps ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  unsigned char bit_offset ;

  {
#line 1574
  pmlmeext = & padapter->mlmeextpriv;
#line 1575
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1578
  if ((unsigned int )pmlmeinfo->HT_enable == 0U) {
#line 1579
    return (0);
  } else {

  }
#line 1580
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 4U) {
#line 1581
    return (0);
  } else {

  }
#line 1582
  bit_offset = (int )pmlmeext->cur_bwmode & 1 ? 6U : 5U;
#line 1584
  if (((int )pHT_caps->u.HT_cap_element.HT_caps_info >> (int )bit_offset) & 1) {
#line 1585
    return (1);
  } else {
#line 1587
    return (0);
  }
}
}
#line 1590 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
unsigned char get_highest_rate_idx23a(u32 mask ) 
{ 
  int i ;
  unsigned char rate_idx ;

  {
#line 1593
  rate_idx = 0U;
#line 1595
  i = 27;
#line 1595
  goto ldv_51920;
  ldv_51919: ;
#line 1596
  if ((int )((unsigned long )mask >> i) & 1) {
#line 1597
    rate_idx = (unsigned char )i;
#line 1598
    goto ldv_51918;
  } else {

  }
#line 1595
  i = i - 1;
  ldv_51920: ;
#line 1595
  if (i >= 0) {
#line 1597
    goto ldv_51919;
  } else {

  }
  ldv_51918: ;
#line 1601
  return (rate_idx);
}
}
#line 1604 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void Update_RA_Entry23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
#line 1606
  rtw_hal_update_ra_mask23a(psta, 0);
#line 1607
  return;
}
}
#line 1609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static void enable_rate_adaptive(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
#line 1612
  Update_RA_Entry23a(padapter, psta);
#line 1613
  return;
}
}
#line 1615 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void set_sta_rate23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
#line 1618
  enable_rate_adaptive(padapter, psta);
#line 1619
  return;
}
}
#line 1622 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void update_tx_basic_rate23a(struct rtw_adapter *padapter , u8 wirelessmode ) 
{ 
  unsigned char supported_rates[16U] ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 1626
  memset((void *)(& supported_rates), 0, 16UL);
#line 1628
  if ((unsigned int )wirelessmode == 1U) {
#line 1629
    __len = 4UL;
#line 1629
    if (__len > 63UL) {
#line 1629
      __ret = __memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_cck),
                       __len);
    } else {
#line 1629
      __ret = __builtin_memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_cck),
                               __len);
    }
  } else
#line 1630
  if ((int )wirelessmode & 1) {
#line 1631
    __len___0 = 7UL;
#line 1631
    if (__len___0 > 63UL) {
#line 1631
      __ret___0 = __memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_mix),
                           __len___0);
    } else {
#line 1631
      __ret___0 = __builtin_memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_mix),
                                   __len___0);
    }
  } else {
#line 1633
    __len___1 = 3UL;
#line 1633
    if (__len___1 > 63UL) {
#line 1633
      __ret___1 = __memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_ofdm),
                           __len___1);
    } else {
#line 1633
      __ret___1 = __builtin_memcpy((void *)(& supported_rates), (void const   *)(& rtw_basic_rate_ofdm),
                                   __len___1);
    }
  }
#line 1636
  if ((int )wirelessmode & 1) {
#line 1637
    update_mgnt_tx_rate23a(padapter, 2);
  } else {
#line 1639
    update_mgnt_tx_rate23a(padapter, 12);
  }
#line 1641
  HalSetBrateCfg23a(padapter, (u8 *)(& supported_rates));
#line 1642
  return;
}
}
#line 1644 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
unsigned char check_assoc_AP23a(u8 *pframe , uint len ) 
{ 
  int i ;
  int bcn_fixed_size ;
  u8 epigram_vendor_flag ;
  u8 ralink_vendor_flag ;
  u8 const   *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1650
  epigram_vendor_flag = 0U;
#line 1651
  ralink_vendor_flag = 0U;
#line 1653
  bcn_fixed_size = 12;
#line 1656
  i = bcn_fixed_size;
#line 1656
  goto ldv_51960;
  ldv_51959: 
#line 1657
  p = (u8 const   *)pframe + (unsigned long )i;
#line 1659
  switch ((int )*p) {
  case 221: 
#line 1661
  tmp___8 = memcmp((void const   *)p + 2U, (void const   *)(& ARTHEROS_OUI1), 3UL);
#line 1661
  if (tmp___8 == 0) {
#line 1661
    goto _L___0;
  } else {
#line 1661
    tmp___9 = memcmp((void const   *)p + 2U, (void const   *)(& ARTHEROS_OUI2), 3UL);
#line 1661
    if (tmp___9 == 0) {
      _L___0: /* CIL Label */ 
#line 1663
      if (GlobalDebugLevel23A > 3U) {
#line 1663
        printk("\016RTL8723AU: link to Artheros AP\n");
      } else {

      }
#line 1664
      return (5U);
    } else {
#line 1665
      tmp___5 = memcmp((void const   *)p + 2U, (void const   *)(& BROADCOM_OUI1),
                       3UL);
#line 1665
      if (tmp___5 == 0) {
#line 1665
        goto _L;
      } else {
#line 1665
        tmp___6 = memcmp((void const   *)p + 2U, (void const   *)(& BROADCOM_OUI2),
                         3UL);
#line 1665
        if (tmp___6 == 0) {
#line 1665
          goto _L;
        } else {
#line 1665
          tmp___7 = memcmp((void const   *)p + 2U, (void const   *)(& BROADCOM_OUI2),
                           3UL);
#line 1665
          if (tmp___7 == 0) {
            _L: /* CIL Label */ 
#line 1668
            if (GlobalDebugLevel23A > 3U) {
#line 1668
              printk("\016RTL8723AU: link to Broadcom AP\n");
            } else {

            }
#line 1669
            return (3U);
          } else {
#line 1670
            tmp___4 = memcmp((void const   *)p + 2U, (void const   *)(& MARVELL_OUI),
                             3UL);
#line 1670
            if (tmp___4 == 0) {
#line 1671
              if (GlobalDebugLevel23A > 3U) {
#line 1671
                printk("\016RTL8723AU: link to Marvell AP\n");
              } else {

              }
#line 1672
              return (8U);
            } else {
#line 1673
              tmp___3 = memcmp((void const   *)p + 2U, (void const   *)(& RALINK_OUI),
                               3UL);
#line 1673
              if (tmp___3 == 0) {
#line 1674
                if ((unsigned int )ralink_vendor_flag == 0U) {
#line 1675
                  ralink_vendor_flag = 1U;
                } else {
#line 1677
                  if (GlobalDebugLevel23A > 3U) {
#line 1677
                    printk("\016RTL8723AU: link to Ralink AP\n");
                  } else {

                  }
#line 1678
                  return (4U);
                }
              } else {
#line 1680
                tmp___2 = memcmp((void const   *)p + 2U, (void const   *)(& CISCO_OUI),
                                 3UL);
#line 1680
                if (tmp___2 == 0) {
#line 1681
                  if (GlobalDebugLevel23A > 3U) {
#line 1681
                    printk("\016RTL8723AU: link to Cisco AP\n");
                  } else {

                  }
#line 1682
                  return (6U);
                } else {
#line 1683
                  tmp___1 = memcmp((void const   *)p + 2U, (void const   *)(& REALTEK_OUI),
                                   3UL);
#line 1683
                  if (tmp___1 == 0) {
#line 1684
                    if (GlobalDebugLevel23A > 3U) {
#line 1684
                      printk("\016RTL8723AU: link to Realtek 96B\n");
                    } else {

                    }
#line 1685
                    return (1U);
                  } else {
#line 1686
                    tmp___0 = memcmp((void const   *)p + 2U, (void const   *)(& AIRGOCAP_OUI),
                                     3UL);
#line 1686
                    if (tmp___0 == 0) {
#line 1687
                      if (GlobalDebugLevel23A > 3U) {
#line 1687
                        printk("\016RTL8723AU: link to Airgo Cap\n");
                      } else {

                      }
#line 1688
                      return (11U);
                    } else {
#line 1689
                      tmp = memcmp((void const   *)p + 2U, (void const   *)(& EPIGRAM_OUI),
                                   3UL);
#line 1689
                      if (tmp == 0) {
#line 1690
                        epigram_vendor_flag = 1U;
#line 1691
                        if ((unsigned int )ralink_vendor_flag != 0U) {
#line 1692
                          if (GlobalDebugLevel23A > 3U) {
#line 1692
                            printk("\016RTL8723AU: link to Tenda W311R AP\n");
                          } else {

                          }
#line 1693
                          return (16U);
                        } else
#line 1695
                        if (GlobalDebugLevel23A > 3U) {
#line 1695
                          printk("\016RTL8723AU: Capture EPIGRAM_OUI\n");
                        } else {

                        }
                      } else {
#line 1697
                        goto ldv_51957;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  default: ;
#line 1699
  goto ldv_51957;
  }
  ldv_51957: 
#line 1702
  i = ((int )*(p + 1UL) + 2) + i;
  ldv_51960: ;
#line 1656
  if ((uint )i < len) {
#line 1658
    goto ldv_51959;
  } else {

  }

#line 1705
  if ((unsigned int )ralink_vendor_flag != 0U && (unsigned int )epigram_vendor_flag == 0U) {
#line 1706
    if (GlobalDebugLevel23A > 3U) {
#line 1706
      printk("\016RTL8723AU: link to Ralink AP\n");
    } else {

    }
#line 1707
    return (4U);
  } else
#line 1708
  if ((unsigned int )ralink_vendor_flag != 0U && (unsigned int )epigram_vendor_flag != 0U) {
#line 1709
    if (GlobalDebugLevel23A > 3U) {
#line 1709
      printk("\016RTL8723AU: link to Tenda W311R AP\n");
    } else {

    }
#line 1710
    return (16U);
  } else {
#line 1712
    if (GlobalDebugLevel23A > 3U) {
#line 1712
      printk("\016RTL8723AU: link to new AP\n");
    } else {

    }
#line 1713
    return (0U);
  }
}
}
#line 1717 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void update_IOT_info23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 1719
  pmlmeext = & padapter->mlmeextpriv;
#line 1720
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1722
  switch ((int )pmlmeinfo->assoc_AP_vendor) {
  case 8: 
#line 1724
  pmlmeinfo->turboMode_cts2self = 1U;
#line 1725
  pmlmeinfo->turboMode_rtsen = 0U;
#line 1726
  goto ldv_51968;
  case 4: 
#line 1728
  pmlmeinfo->turboMode_cts2self = 0U;
#line 1729
  pmlmeinfo->turboMode_rtsen = 1U;
#line 1731
  rtl8723a_odm_support_ability_clr(padapter, 4294967291U);
#line 1733
  goto ldv_51968;
  case 1: 
#line 1738
  rtl8723a_odm_support_ability_clr(padapter, 4294967291U);
#line 1740
  goto ldv_51968;
  default: 
#line 1742
  pmlmeinfo->turboMode_cts2self = 0U;
#line 1743
  pmlmeinfo->turboMode_rtsen = 1U;
#line 1744
  goto ldv_51968;
  }
  ldv_51968: ;
#line 1747
  return;
}
}
#line 1748 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void update_capinfo23a(struct rtw_adapter *Adapter , u16 updateCap ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 1750
  pmlmeext = & Adapter->mlmeextpriv;
#line 1751
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1753
  if (((int )updateCap & 32) != 0) {
#line 1755
    if ((unsigned int )pmlmeinfo->preamble_mode != 3U) {
#line 1757
      pmlmeinfo->preamble_mode = 3U;
#line 1758
      rtl8723a_ack_preamble(Adapter, 1);
    } else {

    }
  } else
#line 1761
  if ((unsigned int )pmlmeinfo->preamble_mode != 1U) {
#line 1763
    pmlmeinfo->preamble_mode = 1U;
#line 1764
    rtl8723a_ack_preamble(Adapter, 0);
  } else {

  }
#line 1767
  if (((int )updateCap & 2) != 0) {
#line 1769
    pmlmeinfo->slotTime = 20U;
  } else
#line 1772
  if (((int )pmlmeext->cur_wireless_mode & 10) != 0) {
#line 1774
    if (((int )updateCap & 1024) != 0) {
#line 1775
      if ((unsigned int )pmlmeinfo->slotTime != 9U) {
#line 1776
        pmlmeinfo->slotTime = 9U;
      } else {

      }
    } else
#line 1778
    if ((unsigned int )pmlmeinfo->slotTime != 20U) {
#line 1779
      pmlmeinfo->slotTime = 20U;
    } else {

    }
  } else
#line 1782
  if (((int )pmlmeext->cur_wireless_mode & 20) != 0) {
#line 1784
    pmlmeinfo->slotTime = 9U;
  } else {
#line 1787
    pmlmeinfo->slotTime = 20U;
  }
#line 1790
  rtl8723a_set_slot_time(Adapter, (int )pmlmeinfo->slotTime);
#line 1791
  return;
}
}
#line 1793 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void update_wireless_mode23a(struct rtw_adapter *padapter ) 
{ 
  int ratelen ;
  int network_type ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  unsigned char *rate ;
  uint tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1795
  network_type = 0;
#line 1796
  pmlmeext = & padapter->mlmeextpriv;
#line 1797
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1798
  cur_network = & pmlmeinfo->network;
#line 1799
  rate = (unsigned char *)(& cur_network->SupportedRates);
#line 1801
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 1801
  ratelen = (int )tmp;
#line 1803
  if ((unsigned int )pmlmeinfo->HT_info_enable != 0U && (unsigned int )pmlmeinfo->HT_caps_enable != 0U) {
#line 1804
    pmlmeinfo->HT_enable = 1U;
  } else {

  }
#line 1806
  if ((unsigned int )pmlmeext->cur_channel > 14U) {
#line 1807
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 1808
      network_type = 16;
    } else {

    }
#line 1809
    network_type = network_type | 4;
  } else {
#line 1811
    if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 1812
      network_type = 8;
    } else {

    }
#line 1814
    tmp___1 = cckratesonly_included23a(rate, ratelen);
#line 1814
    if (tmp___1 == 1) {
#line 1815
      network_type = network_type | 1;
    } else {
#line 1816
      tmp___0 = cckrates_included23a(rate, ratelen);
#line 1816
      if (tmp___0 == 1) {
#line 1817
        network_type = network_type | 3;
      } else {
#line 1819
        network_type = network_type | 2;
      }
    }
  }
#line 1822
  pmlmeext->cur_wireless_mode = (unsigned char )((int )((signed char )padapter->registrypriv.wireless_mode) & (int )((signed char )network_type));
#line 1827
  rtl8723a_set_resp_sifs(padapter, 8, 8, 10, 10);
#line 1829
  if ((int )pmlmeext->cur_wireless_mode & 1) {
#line 1830
    update_mgnt_tx_rate23a(padapter, 2);
  } else {
#line 1832
    update_mgnt_tx_rate23a(padapter, 12);
  }
#line 1833
  return;
}
}
#line 1835 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void update_bmc_sta_support_rate23a(struct rtw_adapter *padapter , u32 mac_id ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1837
  pmlmeext = & padapter->mlmeextpriv;
#line 1838
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1840
  if ((int )pmlmeext->cur_wireless_mode & 1) {
#line 1842
    __len = 4UL;
#line 1842
    if (__len > 63UL) {
#line 1842
      __ret = __memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                       (void const   *)(& rtw_basic_rate_cck), __len);
    } else {
#line 1842
      __ret = __builtin_memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                               (void const   *)(& rtw_basic_rate_cck), __len);
    }
  } else {
#line 1845
    __len___0 = 3UL;
#line 1845
    if (__len___0 > 63UL) {
#line 1845
      __ret___0 = __memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                           (void const   *)(& rtw_basic_rate_ofdm), __len___0);
    } else {
#line 1845
      __ret___0 = __builtin_memcpy((void *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                                   (void const   *)(& rtw_basic_rate_ofdm), __len___0);
    }
  }
#line 1847
  return;
}
}
#line 1850 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int update_sta_support_rate23a(struct rtw_adapter *padapter , u8 *pvar_ie , uint var_ie_len ,
                               int cam_idx ) 
{ 
  int supportRateNum ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 const   *p ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1853
  supportRateNum = 0;
#line 1854
  pmlmeext = & padapter->mlmeextpriv;
#line 1855
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1858
  p = cfg80211_find_ie(1, (u8 const   *)pvar_ie, (int )var_ie_len);
#line 1859
  if ((unsigned long )p == (unsigned long )((u8 const   *)0U)) {
#line 1860
    return (0);
  } else {

  }
#line 1862
  __len = (size_t )*(p + 1UL);
#line 1862
  __ret = __builtin_memcpy((void *)(& pmlmeinfo->FW_sta_info[cam_idx].SupportedRates),
                           (void const   *)p + 2U, __len);
#line 1863
  supportRateNum = (int )*(p + 1UL);
#line 1865
  p = cfg80211_find_ie(50, (u8 const   *)pvar_ie, (int )var_ie_len);
#line 1866
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U)) {
#line 1867
    __len___0 = (size_t )*(p + 1UL);
#line 1867
    __ret___0 = __builtin_memcpy((void *)(& pmlmeinfo->FW_sta_info[cam_idx].SupportedRates) + (unsigned long )supportRateNum,
                                 (void const   *)p + 2U, __len___0);
  } else {

  }
#line 1869
  return (1);
}
}
#line 1872 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void process_addba_req23a(struct rtw_adapter *padapter , u8 *paddba_req , u8 *addr ) 
{ 
  struct sta_info *psta ;
  u16 tid ;
  u16 start_seq ;
  u16 param ;
  struct recv_reorder_ctrl *preorder_ctrl ;
  struct sta_priv *pstapriv ;
  struct ADDBA_request *preq ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 1878
  pstapriv = & padapter->stapriv;
#line 1879
  preq = (struct ADDBA_request *)paddba_req;
#line 1880
  pmlmeext = & padapter->mlmeextpriv;
#line 1881
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1883
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)addr);
#line 1885
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1886
    start_seq = (u16 )((int )preq->BA_starting_seqctrl >> 4);
#line 1888
    param = preq->BA_para_set;
#line 1889
    tid = (unsigned int )((u16 )((int )param >> 2)) & 15U;
#line 1891
    preorder_ctrl = (struct recv_reorder_ctrl *)(& psta->recvreorder_ctrl) + (unsigned long )tid;
#line 1893
    preorder_ctrl->indicate_seq = 65535U;
#line 1895
    preorder_ctrl->enable = (u8 )pmlmeinfo->bAcceptAddbaReq;
  } else {

  }
#line 1897
  return;
}
}
#line 1900 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
static struct rtw_adapter *pbuddy_padapter  ;
#line 1902 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int rtw_handle_dualmac23a(struct rtw_adapter *adapter , bool init ) 
{ 
  int status ;

  {
#line 1904
  status = 1;
#line 1906
  if ((int )init) {
#line 1907
    if ((unsigned long )pbuddy_padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 1908
      pbuddy_padapter = adapter;
#line 1909
      if (GlobalDebugLevel23A > 3U) {
#line 1909
        printk("\016RTL8723AU: %s(): pbuddy_padapter == NULL, Set pbuddy_padapter\n",
               "rtw_handle_dualmac23a");
      } else {

      }
    } else {
#line 1912
      adapter->pbuddy_adapter = pbuddy_padapter;
#line 1913
      pbuddy_padapter->pbuddy_adapter = adapter;
#line 1915
      pbuddy_padapter = (struct rtw_adapter *)0;
#line 1916
      if (GlobalDebugLevel23A > 3U) {
#line 1916
        printk("\016RTL8723AU: %s(): pbuddy_padapter exist, Exchange Information\n",
               "rtw_handle_dualmac23a");
      } else {

      }
    }
  } else {
#line 1920
    pbuddy_padapter = (struct rtw_adapter *)0;
  }
#line 1922
  return (status);
}
}
#line 2052 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
void *ldv_kmem_cache_alloc_872(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2055
  ldv_check_alloc_flags(flags);
#line 2057
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2058
  return ((void *)0);
}
}
#line 2096 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int ldv_pskb_expand_head_878(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2099
  ldv_check_alloc_flags(flags);
#line 2101
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2101
  return (tmp);
}
}
#line 2112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
struct sk_buff *ldv_skb_clone_880(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2115
  ldv_check_alloc_flags(flags);
#line 2117
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2117
  return (tmp);
}
}
#line 2128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
struct sk_buff *ldv_skb_copy_882(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2131
  ldv_check_alloc_flags(flags);
#line 2133
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2133
  return (tmp);
}
}
#line 2136 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_883(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2139
  ldv_check_alloc_flags(flags);
#line 2141
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2141
  return (tmp);
}
}
#line 2144 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_884(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2147
  ldv_check_alloc_flags(flags);
#line 2149
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2149
  return (tmp);
}
}
#line 2152 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_885(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2155
  ldv_check_alloc_flags(flags);
#line 2157
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2157
  return (tmp);
}
}
#line 2160 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int ldv_pskb_expand_head_886(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2163
  ldv_check_alloc_flags(flags);
#line 2165
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2165
  return (tmp);
}
}
#line 2168 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
int ldv_pskb_expand_head_887(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2171
  ldv_check_alloc_flags(flags);
#line 2173
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2173
  return (tmp);
}
}
#line 2176 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_wlan_util.o.c.prepared"
struct sk_buff *ldv_skb_clone_888(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2179
  ldv_check_alloc_flags(flags);
#line 2181
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2181
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_914(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_922(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_930(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_924(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_920(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_928(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_929(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_925(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_926(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_927(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 149 "drivers/staging/rtl8723au/include/hal_com.h"
void dump_chip_info23a(struct hal_version ChipVersion ) ;
#line 153
u8 hal_com_get_channel_plan23a(struct rtw_adapter *padapter , u8 hw_channel_plan ,
                               u8 sw_channel_plan , u8 def_channel_plan , bool AutoLoadFail ) ;
#line 161
u8 MRateToHwRate23a(u8 rate ) ;
#line 166
bool Hal_MappingOutPipe23a(struct rtw_adapter *pAdapter , u8 NumOutPipe ) ;
#line 175
void rtl8723a_set_media_status1(struct rtw_adapter *padapter , u8 status ) ;
#line 177
void rtl8723a_check_bssid(struct rtw_adapter *padapter , u8 val ) ;
#line 180
void rtl8723a_off_rcr_am(struct rtw_adapter *padapter ) ;
#line 184
void rtl8723a_cam_empty_entry(struct rtw_adapter *padapter , u8 ucIndex ) ;
#line 188
void rtl8723a_fifo_cleanup(struct rtw_adapter *padapter ) ;
#line 200
void rtl8723a_set_nav_upper(struct rtw_adapter *padapter , u32 usNavUpper ) ;
#line 24 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
bool rtl8723a_BT_enabled(struct rtw_adapter *padapter ) ;
#line 1028 "drivers/staging/rtl8723au/include/odm.h"
void ODM_Write_DIG23a(struct dm_odm_t *pDM_Odm , u8 CurrentIGI ) ;
#line 533 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void SetBcnCtrlReg23a(struct rtw_adapter *padapter , u8 SetBits , u8 ClearBits ) ;
#line 37 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
int rtl8723au_write32(struct rtw_adapter *padapter , u32 addr , u32 val ) ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void dump_chip_info23a(struct hal_version ChipVersion ) 
{ 
  int cnt ;
  u8 buf[128U] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 245
  cnt = 0;
#line 248
  tmp = sprintf((char *)(& buf) + (unsigned long )cnt, "Chip Version Info: CHIP_8723A_");
#line 248
  cnt = tmp + cnt;
#line 250
  tmp___0 = sprintf((char *)(& buf) + (unsigned long )cnt, "%s_", (unsigned int )ChipVersion.ChipType == 1U ? (char *)"Normal_Chip" : (char *)"Test_Chip");
#line 250
  cnt = tmp___0 + cnt;
#line 252
  tmp___1 = sprintf((char *)(& buf) + (unsigned long )cnt, "%s_", (unsigned int )ChipVersion.VendorType == 0U ? (char *)"TSMC" : (char *)"UMC");
#line 252
  cnt = tmp___1 + cnt;
#line 254
  if ((unsigned int )ChipVersion.CUTVersion == 0U) {
#line 255
    tmp___2 = sprintf((char *)(& buf) + (unsigned long )cnt, "A_CUT_");
#line 255
    cnt = tmp___2 + cnt;
  } else
#line 256
  if ((unsigned int )ChipVersion.CUTVersion == 1U) {
#line 257
    tmp___3 = sprintf((char *)(& buf) + (unsigned long )cnt, "B_CUT_");
#line 257
    cnt = tmp___3 + cnt;
  } else
#line 258
  if ((unsigned int )ChipVersion.CUTVersion == 2U) {
#line 259
    tmp___4 = sprintf((char *)(& buf) + (unsigned long )cnt, "C_CUT_");
#line 259
    cnt = tmp___4 + cnt;
  } else
#line 260
  if ((unsigned int )ChipVersion.CUTVersion == 3U) {
#line 261
    tmp___5 = sprintf((char *)(& buf) + (unsigned long )cnt, "D_CUT_");
#line 261
    cnt = tmp___5 + cnt;
  } else
#line 262
  if ((unsigned int )ChipVersion.CUTVersion == 4U) {
#line 263
    tmp___6 = sprintf((char *)(& buf) + (unsigned long )cnt, "E_CUT_");
#line 263
    cnt = tmp___6 + cnt;
  } else {
#line 265
    tmp___7 = sprintf((char *)(& buf) + (unsigned long )cnt, "UNKNOWN_CUT(%d)_", (unsigned int )ChipVersion.CUTVersion);
#line 265
    cnt = tmp___7 + cnt;
  }
#line 268
  if ((unsigned int )ChipVersion.RFType == 0U) {
#line 269
    tmp___8 = sprintf((char *)(& buf) + (unsigned long )cnt, "1T1R_");
#line 269
    cnt = tmp___8 + cnt;
  } else
#line 270
  if ((unsigned int )ChipVersion.RFType == 1U) {
#line 271
    tmp___9 = sprintf((char *)(& buf) + (unsigned long )cnt, "1T2R_");
#line 271
    cnt = tmp___9 + cnt;
  } else
#line 272
  if ((unsigned int )ChipVersion.RFType == 2U) {
#line 273
    tmp___10 = sprintf((char *)(& buf) + (unsigned long )cnt, "2T2R_");
#line 273
    cnt = tmp___10 + cnt;
  } else {
#line 275
    tmp___11 = sprintf((char *)(& buf) + (unsigned long )cnt, "UNKNOWN_RFTYPE(%d)_",
                       (unsigned int )ChipVersion.RFType);
#line 275
    cnt = tmp___11 + cnt;
  }
#line 278
  tmp___12 = sprintf((char *)(& buf) + (unsigned long )cnt, "RomVer(%d)\n", (int )ChipVersion.ROMVer);
#line 278
  cnt = tmp___12 + cnt;
#line 280
  if (GlobalDebugLevel23A > 3U) {
#line 280
    printk("\016RTL8723AU: %s", (u8 *)(& buf));
  } else {

  }
#line 281
  return;
}
}
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
u8 hal_com_get_channel_plan23a(struct rtw_adapter *padapter , u8 hw_channel_plan ,
                               u8 sw_channel_plan , u8 def_channel_plan , bool AutoLoadFail ) 
{ 
  u8 swConfig ;
  u8 chnlPlan ;

  {
#line 296
  swConfig = 1U;
#line 297
  if (! AutoLoadFail) {
#line 298
    if ((unsigned int )sw_channel_plan > 65U && (unsigned int )sw_channel_plan != 127U) {
#line 299
      swConfig = 0U;
    } else {

    }
#line 300
    if ((int )((signed char )hw_channel_plan) < 0) {
#line 301
      swConfig = 0U;
    } else {

    }
  } else {

  }
#line 304
  if ((unsigned int )swConfig == 1U) {
#line 305
    chnlPlan = sw_channel_plan;
  } else {
#line 307
    chnlPlan = (unsigned int )hw_channel_plan & 127U;
  }
#line 309
  if ((unsigned int )chnlPlan > 65U && (unsigned int )chnlPlan != 127U) {
#line 310
    chnlPlan = def_channel_plan;
  } else {

  }
#line 312
  return (chnlPlan);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
u8 MRateToHwRate23a(u8 rate ) 
{ 
  u8 ret ;

  {
#line 317
  ret = 0U;
#line 319
  switch ((int )rate) {
  case 2: 
#line 322
  ret = 0U;
#line 323
  goto ldv_54262;
  case 4: 
#line 325
  ret = 1U;
#line 326
  goto ldv_54262;
  case 11: 
#line 328
  ret = 2U;
#line 329
  goto ldv_54262;
  case 22: 
#line 331
  ret = 3U;
#line 332
  goto ldv_54262;
  case 12: 
#line 334
  ret = 4U;
#line 335
  goto ldv_54262;
  case 18: 
#line 337
  ret = 5U;
#line 338
  goto ldv_54262;
  case 24: 
#line 340
  ret = 6U;
#line 341
  goto ldv_54262;
  case 36: 
#line 343
  ret = 7U;
#line 344
  goto ldv_54262;
  case 48: 
#line 346
  ret = 8U;
#line 347
  goto ldv_54262;
  case 72: 
#line 349
  ret = 9U;
#line 350
  goto ldv_54262;
  case 96: 
#line 352
  ret = 10U;
#line 353
  goto ldv_54262;
  case 108: 
#line 355
  ret = 11U;
#line 356
  goto ldv_54262;
  default: ;
#line 369
  goto ldv_54262;
  }
  ldv_54262: ;
#line 371
  return (ret);
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void HalSetBrateCfg23a(struct rtw_adapter *padapter , u8 *mBratesOS ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 i ;
  u8 is_brate ;
  u8 brate ;
  u16 brate_cfg ;
  u8 rate_index ;
  u8 tmp ;

  {
#line 376
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 378
  brate_cfg = 0U;
#line 381
  i = 0U;
#line 381
  goto ldv_54299;
  ldv_54298: 
#line 382
  is_brate = (unsigned int )*(mBratesOS + (unsigned long )i) & 128U;
#line 383
  brate = (unsigned int )*(mBratesOS + (unsigned long )i) & 127U;
#line 385
  if ((unsigned int )is_brate != 0U) {
#line 386
    switch ((int )brate) {
    case 2: 
#line 388
    brate_cfg = (u16 )((unsigned int )brate_cfg | 1U);
#line 389
    goto ldv_54286;
    case 4: 
#line 391
    brate_cfg = (u16 )((unsigned int )brate_cfg | 2U);
#line 392
    goto ldv_54286;
    case 11: 
#line 394
    brate_cfg = (u16 )((unsigned int )brate_cfg | 4U);
#line 395
    goto ldv_54286;
    case 22: 
#line 397
    brate_cfg = (u16 )((unsigned int )brate_cfg | 8U);
#line 398
    goto ldv_54286;
    case 12: 
#line 400
    brate_cfg = (u16 )((unsigned int )brate_cfg | 16U);
#line 401
    goto ldv_54286;
    case 18: 
#line 403
    brate_cfg = (u16 )((unsigned int )brate_cfg | 32U);
#line 404
    goto ldv_54286;
    case 24: 
#line 406
    brate_cfg = (u16 )((unsigned int )brate_cfg | 64U);
#line 407
    goto ldv_54286;
    case 36: 
#line 409
    brate_cfg = (u16 )((unsigned int )brate_cfg | 128U);
#line 410
    goto ldv_54286;
    case 48: 
#line 412
    brate_cfg = (u16 )((unsigned int )brate_cfg | 256U);
#line 413
    goto ldv_54286;
    case 72: 
#line 415
    brate_cfg = (u16 )((unsigned int )brate_cfg | 512U);
#line 416
    goto ldv_54286;
    case 96: 
#line 418
    brate_cfg = (u16 )((unsigned int )brate_cfg | 1024U);
#line 419
    goto ldv_54286;
    case 108: 
#line 421
    brate_cfg = (u16 )((unsigned int )brate_cfg | 2048U);
#line 422
    goto ldv_54286;
    }
    ldv_54286: ;
  } else {

  }
#line 381
  i = (u8 )((int )i + 1);
  ldv_54299: ;
#line 381
  if ((unsigned int )i <= 15U) {
#line 383
    goto ldv_54298;
  } else {

  }
#line 438
  brate_cfg = ((unsigned int )brate_cfg & 336U) | 13U;
#line 439
  pHalData->BasicRateSet = brate_cfg;
#line 440
  brate_cfg = (u16 )((unsigned int )brate_cfg | 1U);
#line 441
  if (GlobalDebugLevel23A > 3U) {
#line 441
    printk("\016RTL8723AU: HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", (int )brate_cfg);
  } else {

  }
#line 444
  rtl8723au_write8(padapter, 1088U, (int )((u8 )brate_cfg));
#line 445
  rtl8723au_write8(padapter, 1089U, (int )((u8 )((int )brate_cfg >> 8)));
#line 446
  tmp = rtl8723au_read8(padapter, 1090U);
#line 446
  rtl8723au_write8(padapter, 1090U, (int )tmp & 240);
#line 449
  rate_index = 0U;
#line 451
  goto ldv_54302;
  ldv_54301: 
#line 452
  brate_cfg = (u16 )((int )brate_cfg >> 1);
#line 453
  rate_index = (u8 )((int )rate_index + 1);
  ldv_54302: ;
#line 451
  if ((unsigned int )brate_cfg > 1U) {
#line 453
    goto ldv_54301;
  } else {

  }
#line 456
  rtl8723au_write8(padapter, 1152U, (int )rate_index);
#line 458
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
static void _OneOutPipeMapping(struct rtw_adapter *pAdapter ) 
{ 
  struct dvobj_priv *pdvobjpriv ;

  {
#line 463
  pdvobjpriv = pAdapter->dvobj;
#line 465
  pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 466
  pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 467
  pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 468
  pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 470
  pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 471
  pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 472
  pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 473
  pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 474
  return;
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
static void _TwoOutPipeMapping(struct rtw_adapter *pAdapter , bool bWIFICfg ) 
{ 
  struct dvobj_priv *pdvobjpriv ;

  {
#line 478
  pdvobjpriv = pAdapter->dvobj;
#line 480
  if ((int )bWIFICfg) {
#line 484
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 485
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 486
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 487
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 489
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 490
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 491
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 492
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  } else {
#line 497
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 498
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 499
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 500
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 502
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 503
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 504
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 505
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  }
#line 507
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
static void _ThreeOutPipeMapping(struct rtw_adapter *pAdapter , bool bWIFICfg ) 
{ 
  struct dvobj_priv *pdvobjpriv ;

  {
#line 511
  pdvobjpriv = pAdapter->dvobj;
#line 513
  if ((int )bWIFICfg) {
#line 517
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 518
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 519
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[2];
#line 520
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 522
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 523
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 524
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 525
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  } else {
#line 530
    pdvobjpriv->Queue2Pipe[0] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 531
    pdvobjpriv->Queue2Pipe[1] = (u8 )pdvobjpriv->RtOutPipe[1];
#line 532
    pdvobjpriv->Queue2Pipe[2] = (u8 )pdvobjpriv->RtOutPipe[2];
#line 533
    pdvobjpriv->Queue2Pipe[3] = (u8 )pdvobjpriv->RtOutPipe[2];
#line 535
    pdvobjpriv->Queue2Pipe[4] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 536
    pdvobjpriv->Queue2Pipe[5] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 537
    pdvobjpriv->Queue2Pipe[6] = (u8 )pdvobjpriv->RtOutPipe[0];
#line 538
    pdvobjpriv->Queue2Pipe[7] = (u8 )pdvobjpriv->RtOutPipe[0];
  }
#line 540
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
bool Hal_MappingOutPipe23a(struct rtw_adapter *pAdapter , u8 NumOutPipe ) 
{ 
  struct registry_priv *pregistrypriv ;
  bool bWIFICfg ;
  bool result ;

  {
#line 544
  pregistrypriv = & pAdapter->registrypriv;
#line 545
  bWIFICfg = (unsigned int )pregistrypriv->wifi_spec != 0U;
#line 546
  result = 1;
#line 548
  switch ((int )NumOutPipe) {
  case 2: 
#line 550
  _TwoOutPipeMapping(pAdapter, (int )bWIFICfg);
#line 551
  goto ldv_54326;
  case 3: 
#line 553
  _ThreeOutPipeMapping(pAdapter, (int )bWIFICfg);
#line 554
  goto ldv_54326;
  case 1: 
#line 556
  _OneOutPipeMapping(pAdapter);
#line 557
  goto ldv_54326;
  default: 
#line 559
  result = 0;
#line 560
  goto ldv_54326;
  }
  ldv_54326: ;
#line 563
  return (result);
}
}
#line 572 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void c2h_evt_clear23a(struct rtw_adapter *adapter ) 
{ 


  {
#line 574
  rtl8723au_write8(adapter, 431U, 0);
#line 575
  return;
}
}
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
s32 c2h_evt_read23a(struct rtw_adapter *adapter , u8 *buf ) 
{ 
  int ret ;
  struct c2h_evt_hdr *c2h_evt ;
  int i ;
  u8 trigger ;
  int __i ;
  u8 *ptr ;
  int __i___0 ;
  u8 *ptr___0 ;

  {
#line 579
  ret = 0;
#line 584
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
#line 585
    goto exit;
  } else {

  }
#line 587
  trigger = rtl8723au_read8(adapter, 431U);
#line 589
  if ((unsigned int )trigger == 0U) {
#line 590
    goto exit;
  } else
#line 591
  if ((unsigned int )trigger != 255U) {
#line 592
    goto clear_evt;
  } else {

  }
#line 594
  c2h_evt = (struct c2h_evt_hdr *)buf;
#line 596
  memset((void *)c2h_evt, 0, 16UL);
#line 598
  *buf = rtl8723au_read8(adapter, 416U);
#line 599
  *(buf + 1UL) = rtl8723au_read8(adapter, 417U);
#line 601
  if (GlobalDebugLevel23A > 6U) {
#line 601
    ptr = (u8 *)(& c2h_evt);
#line 601
    printk("\016%s", (char *)"RTL8723AU: ");
#line 601
    printk("\016c2h_evt_read23a(): ");
#line 601
    __i = 0;
#line 601
    goto ldv_54346;
    ldv_54345: 
#line 601
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((unsigned int )(__i + 1) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 601
    if (((unsigned int )(__i + 1) & 15U) == 0U) {
#line 601
      printk("\n");
    } else {

    }
#line 601
    __i = __i + 1;
    ldv_54346: ;
#line 601
    if (__i <= 7) {
#line 603
      goto ldv_54345;
    } else {

    }
#line 601
    printk("\n");
  } else {

  }
#line 611
  i = 0;
#line 611
  goto ldv_54350;
  ldv_54349: 
#line 612
  c2h_evt->payload[i] = rtl8723au_read8(adapter, (u32 )i + 418U);
#line 611
  i = i + 1;
  ldv_54350: ;
#line 611
  if ((int )c2h_evt->plen > i) {
#line 613
    goto ldv_54349;
  } else {

  }

#line 616
  if (GlobalDebugLevel23A > 6U) {
#line 616
    ptr___0 = (u8 *)(& c2h_evt->payload);
#line 616
    printk("\016%s", (char *)"RTL8723AU: ");
#line 616
    printk("\016c2h_evt_read23a(): Command Content:\n");
#line 616
    __i___0 = 0;
#line 616
    goto ldv_54355;
    ldv_54354: 
#line 616
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((unsigned int )(__i___0 + 1) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 616
    if (((unsigned int )(__i___0 + 1) & 15U) == 0U) {
#line 616
      printk("\n");
    } else {

    }
#line 616
    __i___0 = __i___0 + 1;
    ldv_54355: ;
#line 616
    if ((int )c2h_evt->plen > __i___0) {
#line 618
      goto ldv_54354;
    } else {

    }
#line 616
    printk("\n");
  } else {

  }
#line 620
  ret = 1;
  clear_evt: 
#line 628
  c2h_evt_clear23a(adapter);
  exit: ;
#line 630
  return (ret);
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_ampdu_min_space(struct rtw_adapter *padapter , u8 MinSpacingToSet ) 
{ 
  u8 SecMinSpace ;
  u8 tmp ;

  {
#line 638
  if ((unsigned int )MinSpacingToSet <= 7U) {
#line 639
    switch (padapter->securitypriv.dot11PrivacyAlgrthm) {
    case 0U: ;
    case 1027076U: 
#line 642
    SecMinSpace = 0U;
#line 643
    goto ldv_54364;
    case 1027073U: ;
    case 1027077U: ;
    case 1027074U: 
#line 648
    SecMinSpace = 6U;
#line 649
    goto ldv_54364;
    default: 
#line 651
    SecMinSpace = 7U;
#line 652
    goto ldv_54364;
    }
    ldv_54364: ;
#line 655
    if ((int )MinSpacingToSet < (int )SecMinSpace) {
#line 656
      MinSpacingToSet = SecMinSpace;
    } else {

    }
#line 661
    tmp = rtl8723au_read8(padapter, 1116U);
#line 661
    MinSpacingToSet = (u8 )(((int )((signed char )tmp) & -8) | (int )((signed char )MinSpacingToSet));
#line 663
    rtl8723au_write8(padapter, 1116U, (int )MinSpacingToSet);
  } else {

  }
#line 665
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_ampdu_factor(struct rtw_adapter *padapter , u8 FactorToSet ) 
{ 
  u8 RegToSet_Normal[4U] ;
  u8 MaxAggNum ;
  u8 *pRegToSet ;
  u8 index ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 670
  RegToSet_Normal[0] = 65U;
#line 670
  RegToSet_Normal[1] = 168U;
#line 670
  RegToSet_Normal[2] = 114U;
#line 670
  RegToSet_Normal[3] = 185U;
#line 673
  index = 0U;
#line 675
  pRegToSet = (u8 *)(& RegToSet_Normal);
#line 677
  tmp = rtl8723a_BT_enabled(padapter);
#line 677
  if ((int )tmp) {
#line 677
    tmp___0 = rtl8723a_BT_using_antenna_1(padapter);
#line 677
    if ((int )tmp___0) {
#line 679
      MaxAggNum = 8U;
    } else {
#line 681
      MaxAggNum = 15U;
    }
  } else {
#line 681
    MaxAggNum = 15U;
  }
#line 683
  if ((unsigned int )FactorToSet <= 3U) {
#line 684
    FactorToSet = (u8 )(1 << ((int )FactorToSet + 2));
#line 685
    if ((int )FactorToSet > (int )MaxAggNum) {
#line 686
      FactorToSet = MaxAggNum;
    } else {

    }
#line 688
    index = 0U;
#line 688
    goto ldv_54378;
    ldv_54377: ;
#line 689
    if (((int )*(pRegToSet + (unsigned long )index) & 240) > (int )FactorToSet << 4) {
#line 690
      *(pRegToSet + (unsigned long )index) = (u8 )(((int )((signed char )*(pRegToSet + (unsigned long )index)) & 15) | (int )((signed char )((int )FactorToSet << 4)));
    } else {

    }
#line 693
    if (((int )*(pRegToSet + (unsigned long )index) & 15) > (int )FactorToSet) {
#line 694
      *(pRegToSet + (unsigned long )index) = (u8 )(((int )((signed char )*(pRegToSet + (unsigned long )index)) & -16) | (int )((signed char )FactorToSet));
    } else {

    }
#line 697
    rtl8723au_write8(padapter, (u32 )((int )index + 1112), (int )*(pRegToSet + (unsigned long )index));
#line 688
    index = (u8 )((int )index + 1);
    ldv_54378: ;
#line 688
    if ((unsigned int )index <= 3U) {
#line 690
      goto ldv_54377;
    } else {

    }

  } else {

  }
#line 696
  return;
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_acm_ctrl(struct rtw_adapter *padapter , u8 ctrl ) 
{ 
  u8 hwctrl ;

  {
#line 708
  hwctrl = 0U;
#line 710
  if ((unsigned int )ctrl != 0U) {
#line 711
    hwctrl = (u8 )((unsigned int )hwctrl | 1U);
#line 713
    if (((unsigned long )ctrl & 2UL) != 0UL) {
#line 714
      hwctrl = (u8 )((unsigned int )hwctrl | 2U);
    } else {

    }
#line 716
    if (((unsigned long )ctrl & 4UL) != 0UL) {
#line 717
      hwctrl = (u8 )((unsigned int )hwctrl | 4U);
    } else {

    }
#line 719
    if (((unsigned long )ctrl & 8UL) != 0UL) {
#line 720
      hwctrl = (u8 )((unsigned int )hwctrl | 8U);
    } else {

    }
  } else {

  }
#line 723
  if (GlobalDebugLevel23A > 3U) {
#line 723
    printk("\016RTL8723AU: [HW_VAR_ACM_CTRL] Write 0x%02X\n", (int )hwctrl);
  } else {

  }
#line 724
  rtl8723au_write8(padapter, 1472U, (int )hwctrl);
#line 725
  return;
}
}
#line 727 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_media_status(struct rtw_adapter *padapter , u8 status ) 
{ 
  u8 val8 ;
  u8 tmp ;

  {
#line 731
  tmp = rtl8723au_read8(padapter, 258U);
#line 731
  val8 = (unsigned int )tmp & 12U;
#line 732
  val8 = (u8 )((int )val8 | (int )status);
#line 733
  rtl8723au_write8(padapter, 258U, (int )val8);
#line 734
  return;
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_media_status1(struct rtw_adapter *padapter , u8 status ) 
{ 
  u8 val8 ;
  u8 tmp ;

  {
#line 740
  tmp = rtl8723au_read8(padapter, 258U);
#line 740
  val8 = (unsigned int )tmp & 3U;
#line 741
  val8 = (u8 )((int )((signed char )((int )status << 2)) | (int )((signed char )val8));
#line 742
  rtl8723au_write8(padapter, 258U, (int )val8);
#line 743
  return;
}
}
#line 745 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_bcn_func(struct rtw_adapter *padapter , u8 val ) 
{ 


  {
#line 747
  if ((unsigned int )val != 0U) {
#line 748
    SetBcnCtrlReg23a(padapter, 12, 0);
  } else {
#line 750
    SetBcnCtrlReg23a(padapter, 0, 12);
  }
#line 751
  return;
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_check_bssid(struct rtw_adapter *padapter , u8 val ) 
{ 
  u32 val32 ;

  {
#line 756
  val32 = rtl8723au_read32(padapter, 1544U);
#line 757
  if ((unsigned int )val != 0U) {
#line 758
    val32 = val32 | 192U;
  } else {
#line 760
    val32 = val32 & 4294967103U;
  }
#line 761
  rtl8723au_write32(padapter, 1544U, val32);
#line 762
  return;
}
}
#line 764 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_mlme_sitesurvey(struct rtw_adapter *padapter , u8 flag ) 
{ 
  u32 v32 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 v32___0 ;
  bool tmp ;

  {
#line 766
  if ((unsigned int )flag != 0U) {
#line 771
    v32 = rtl8723au_read32(padapter, 1544U);
#line 772
    v32 = v32 & 4294967167U;
#line 773
    rtl8723au_write32(padapter, 1544U, v32);
#line 775
    rtl8723au_write16(padapter, 1700U, 0);
#line 778
    SetBcnCtrlReg23a(padapter, 16, 0);
  } else {
#line 781
    pmlmeext = & padapter->mlmeextpriv;
#line 785
    pmlmeinfo = & pmlmeext->mlmext_info;
#line 787
    tmp = is_client_associated_to_ap23a(padapter);
#line 787
    if (((int )tmp || (pmlmeinfo->state & 3U) == 1U) || (pmlmeinfo->state & 3U) == 3U) {
#line 791
      rtl8723au_write16(padapter, 1700U, 65535);
#line 794
      SetBcnCtrlReg23a(padapter, 0, 16);
    } else {

    }
#line 797
    v32___0 = rtl8723au_read32(padapter, 1544U);
#line 798
    v32___0 = v32___0 | 128U;
#line 799
    rtl8723au_write32(padapter, 1544U, v32___0);
  }
#line 802
  rtl8723a_BT_wifiscan_notify(padapter, (unsigned int )flag != 0U);
#line 803
  return;
}
}
#line 805 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_on_rcr_am(struct rtw_adapter *padapter ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 807
  tmp = rtl8723au_read32(padapter, 1544U);
#line 807
  rtl8723au_write32(padapter, 1544U, tmp | 4U);
#line 809
  if (GlobalDebugLevel23A > 3U) {
#line 809
    tmp___0 = rtl8723au_read32(padapter, 1544U);
#line 809
    printk("\016RTL8723AU: %s, %d, RCR = %x \n", "rtl8723a_on_rcr_am", 810, tmp___0);
  } else {

  }
#line 810
  return;
}
}
#line 813 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_off_rcr_am(struct rtw_adapter *padapter ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 815
  tmp = rtl8723au_read32(padapter, 1544U);
#line 815
  rtl8723au_write32(padapter, 1544U, tmp & 4294967291U);
#line 817
  if (GlobalDebugLevel23A > 3U) {
#line 817
    tmp___0 = rtl8723au_read32(padapter, 1544U);
#line 817
    printk("\016RTL8723AU: %s, %d, RCR = %x \n", "rtl8723a_off_rcr_am", 818, tmp___0);
  } else {

  }
#line 818
  return;
}
}
#line 821 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_slot_time(struct rtw_adapter *padapter , u8 slottime ) 
{ 
  u8 u1bAIFS ;
  u8 aSifsTime ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 824
  pmlmeext = & padapter->mlmeextpriv;
#line 825
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 827
  rtl8723au_write8(padapter, 1307U, (int )slottime);
#line 829
  if ((unsigned int )pmlmeinfo->WMM_enable == 0U) {
#line 830
    if ((unsigned int )pmlmeext->cur_wireless_mode == 1U) {
#line 831
      aSifsTime = 10U;
    } else {
#line 833
      aSifsTime = 16U;
    }
#line 835
    u1bAIFS = (unsigned int )pmlmeinfo->slotTime * 2U + (unsigned int )aSifsTime;
#line 838
    rtl8723au_write8(padapter, 1280U, (int )u1bAIFS);
#line 839
    rtl8723au_write8(padapter, 1284U, (int )u1bAIFS);
#line 840
    rtl8723au_write8(padapter, 1288U, (int )u1bAIFS);
#line 841
    rtl8723au_write8(padapter, 1292U, (int )u1bAIFS);
  } else {

  }
#line 843
  return;
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_ack_preamble(struct rtw_adapter *padapter , u8 bShortPreamble ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 regTmp ;

  {
#line 847
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 852
  regTmp = (int )pHalData->nCur40MhzPrimeSC << 5U;
#line 854
  if ((unsigned int )bShortPreamble != 0U) {
#line 855
    regTmp = (u8 )((unsigned int )regTmp | 128U);
  } else {

  }
#line 856
  rtl8723au_write8(padapter, 1090U, (int )regTmp);
#line 857
  return;
}
}
#line 859 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_sec_cfg(struct rtw_adapter *padapter , u8 sec ) 
{ 


  {
#line 861
  rtl8723au_write8(padapter, 1664U, (int )sec);
#line 862
  return;
}
}
#line 864 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_cam_empty_entry(struct rtw_adapter *padapter , u8 ucIndex ) 
{ 
  u8 i ;
  u32 ulCommand ;
  u32 ulContent ;
  u32 ulEncAlgo ;

  {
#line 867
  ulCommand = 0U;
#line 868
  ulContent = 0U;
#line 869
  ulEncAlgo = 4U;
#line 871
  i = 0U;
#line 871
  goto ldv_54447;
  ldv_54446: ;
#line 873
  if ((unsigned int )i == 0U) {
#line 874
    ulContent = (u32 )(((int )ucIndex & 3) | ((int )((unsigned short )ulEncAlgo) << 2)) | ulContent;
  } else {
#line 878
    ulContent = 0U;
  }
#line 881
  ulCommand = (u32 )((int )ucIndex * 8 + (int )i);
#line 882
  ulCommand = ulCommand | 2147549184U;
#line 885
  rtl8723au_write32(padapter, 1652U, ulContent);
#line 890
  rtl8723au_write32(padapter, 1648U, ulCommand);
#line 871
  i = (u8 )((int )i + 1);
  ldv_54447: ;
#line 871
  if ((unsigned int )i <= 7U) {
#line 873
    goto ldv_54446;
  } else {

  }

#line 878
  return;
}
}
#line 897 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_cam_invalid_all(struct rtw_adapter *padapter ) 
{ 


  {
#line 899
  rtl8723au_write32(padapter, 1648U, 3221225472U);
#line 900
  return;
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_cam_write(struct rtw_adapter *padapter , u8 entry , u16 ctrl , u8 const   *mac ,
                        u8 const   *key ) 
{ 
  u32 cmd ;
  unsigned int i ;
  unsigned int val ;
  unsigned int addr ;
  int j ;

  {
#line 909
  addr = (unsigned int )((int )entry << 3);
#line 911
  j = 5;
#line 911
  goto ldv_54469;
  ldv_54468: ;
#line 912
  switch (j) {
  case 0: 
#line 914
  val = (unsigned int )(((int )ctrl | ((int )*mac << 16)) | ((int )*(mac + 1UL) << 24));
#line 915
  goto ldv_54465;
  case 1: 
#line 917
  val = (unsigned int )((((int )*(mac + 2UL) | ((int )*(mac + 3UL) << 8)) | ((int )*(mac + 4UL) << 16)) | ((int )*(mac + 5UL) << 24));
#line 919
  goto ldv_54465;
  default: 
#line 921
  i = (unsigned int )((j + -2) << 2);
#line 922
  val = (unsigned int )((((int )*(key + (unsigned long )i) | ((int )*(key + (unsigned long )(i + 1U)) << 8)) | ((int )*(key + (unsigned long )(i + 2U)) << 16)) | ((int )*(key + (unsigned long )(i + 3U)) << 24));
#line 924
  goto ldv_54465;
  }
  ldv_54465: 
#line 927
  rtl8723au_write32(padapter, 1652U, val);
#line 928
  cmd = (addr + (unsigned int )j) | 2147549184U;
#line 929
  rtl8723au_write32(padapter, 1648U, cmd);
#line 911
  j = j - 1;
  ldv_54469: ;
#line 911
  if (j >= 0) {
#line 913
    goto ldv_54468;
  } else {

  }

#line 918
  return;
}
}
#line 935 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_fifo_cleanup(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  u8 trycnt ;
  u32 v32 ;
  u32 tmp ;
  u8 tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;

  {
#line 940
  pwrpriv = & padapter->pwrctrlpriv;
#line 941
  trycnt = 100U;
#line 944
  rtl8723au_write8(padapter, 1314U, 255);
#line 947
  padapter->xmitpriv.nqos_ssn = rtl8723au_read16(padapter, 1244U);
#line 949
  if ((unsigned int )pwrpriv->bkeepfwalive != 1U) {
#line 953
    v32 = rtl8723au_read32(padapter, 644U);
#line 954
    v32 = v32 | 262144U;
#line 955
    rtl8723au_write32(padapter, 644U, v32);
    ldv_54478: 
#line 957
    tmp = rtl8723au_read32(padapter, 644U);
#line 957
    v32 = tmp & 131072U;
#line 959
    if (v32 == 0U) {
#line 960
      goto ldv_54477;
    } else {

    }
#line 961
    tmp___0 = trycnt;
#line 961
    trycnt = (u8 )((int )trycnt - 1);
#line 961
    if ((unsigned int )tmp___0 != 0U) {
#line 963
      goto ldv_54478;
    } else {

    }
    ldv_54477: ;
#line 962
    if ((unsigned int )trycnt == 0U) {
#line 963
      if (GlobalDebugLevel23A > 3U) {
#line 963
        printk("\016RTL8723AU: Stop RX DMA failed......\n");
      } else {

      }
    } else {

    }
#line 967
    rtl8723au_write16(padapter, 532U, 0);
#line 968
    rtl8723au_write32(padapter, 512U, 2147483648U);
#line 969
    __ms = 10UL;
#line 969
    goto ldv_54481;
    ldv_54480: 
#line 969
    __const_udelay(4295000UL);
    ldv_54481: 
#line 969
    tmp___1 = __ms;
#line 969
    __ms = __ms - 1UL;
#line 969
    if (tmp___1 != 0UL) {
#line 971
      goto ldv_54480;
    } else {

    }

  } else {

  }
#line 979
  return;
}
}
#line 973 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_bcn_valid(struct rtw_adapter *padapter ) 
{ 
  u8 tmp ;

  {
#line 977
  tmp = rtl8723au_read8(padapter, 522U);
#line 977
  rtl8723au_write8(padapter, 522U, (int )((unsigned int )tmp | 1U));
#line 979
  return;
}
}
#line 981 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
bool rtl8723a_get_bcn_valid(struct rtw_adapter *padapter ) 
{ 
  bool retval ;
  u8 tmp ;

  {
#line 985
  tmp = rtl8723au_read8(padapter, 522U);
#line 985
  retval = ((int )tmp & 1) != 0;
#line 987
  return (retval);
}
}
#line 990 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_beacon_interval(struct rtw_adapter *padapter , u16 interval ) 
{ 


  {
#line 992
  rtl8723au_write16(padapter, 1364U, (int )interval);
#line 993
  return;
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_resp_sifs(struct rtw_adapter *padapter , u8 r2t1 , u8 r2t2 , u8 t2t1 ,
                            u8 t2t2 ) 
{ 


  {
#line 1001
  rtl8723au_write8(padapter, 1596U, (int )r2t1);
#line 1003
  rtl8723au_write8(padapter, 1597U, (int )r2t2);
#line 1006
  rtl8723au_write8(padapter, 1598U, (int )t2t1);
#line 1008
  rtl8723au_write8(padapter, 1599U, (int )t2t2);
#line 1009
  return;
}
}
#line 1011 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_ac_param_vo(struct rtw_adapter *padapter , u32 vo ) 
{ 


  {
#line 1013
  rtl8723au_write32(padapter, 1280U, vo);
#line 1014
  return;
}
}
#line 1016 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_ac_param_vi(struct rtw_adapter *padapter , u32 vi ) 
{ 


  {
#line 1018
  rtl8723au_write32(padapter, 1284U, vi);
#line 1019
  return;
}
}
#line 1021 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_ac_param_be(struct rtw_adapter *padapter , u32 be ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1023
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1025
  pHalData->AcParam_BE = be;
#line 1026
  rtl8723au_write32(padapter, 1288U, be);
#line 1027
  return;
}
}
#line 1029 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_ac_param_bk(struct rtw_adapter *padapter , u32 bk ) 
{ 


  {
#line 1031
  rtl8723au_write32(padapter, 1292U, bk);
#line 1032
  return;
}
}
#line 1034 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_rxdma_agg_pg_th(struct rtw_adapter *padapter , u8 val ) 
{ 


  {
#line 1036
  rtl8723au_write8(padapter, 640U, (int )val);
#line 1037
  return;
}
}
#line 1039 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_nav_upper(struct rtw_adapter *padapter , u32 usNavUpper ) 
{ 


  {
#line 1041
  if (usNavUpper > 32640U) {
#line 1042
    if (GlobalDebugLevel23A > 5U) {
#line 1042
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 6);
#line 1042
      printk("\016The setting value (0x%08X us) of NAV_UPPER is larger than (%d * 0xFF)!!!\n",
             usNavUpper, 128);
    } else {

    }
#line 1046
    return;
  } else {

  }
#line 1052
  usNavUpper = (usNavUpper + 127U) / 128U;
#line 1054
  rtl8723au_write8(padapter, 1618U, (int )((unsigned char )usNavUpper));
#line 1055
  return;
}
}
#line 1057 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_initial_gain(struct rtw_adapter *padapter , u32 rx_gain ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dig_t *pDigTable ;

  {
#line 1059
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1060
  pDigTable = & pHalData->odmpriv.DM_DigTable;
#line 1062
  if (rx_gain == 255U) {
#line 1063
    ODM_Write_DIG23a(& pHalData->odmpriv, (int )pDigTable->BackupIGValue);
  } else {
#line 1065
    pDigTable->BackupIGValue = pDigTable->CurIGValue;
#line 1066
    ODM_Write_DIG23a(& pHalData->odmpriv, (int )((u8 )rx_gain));
  }
#line 1068
  return;
}
}
#line 1070 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_odm_support_ability_restore(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1072
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1074
  pHalData->odmpriv.SupportAbility = pHalData->odmpriv.BK_SupportAbility;
#line 1075
  return;
}
}
#line 1077 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_odm_support_ability_backup(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1079
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1081
  pHalData->odmpriv.BK_SupportAbility = pHalData->odmpriv.SupportAbility;
#line 1082
  return;
}
}
#line 1084 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_odm_support_ability_set(struct rtw_adapter *padapter , u32 val ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1086
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1088
  if (val == 268435455U) {
#line 1089
    pHalData->dmpriv.DMFlag = pHalData->dmpriv.InitDMFlag;
#line 1090
    pHalData->odmpriv.SupportAbility = pHalData->dmpriv.InitODMFlag;
  } else {
#line 1092
    pHalData->odmpriv.SupportAbility = pHalData->odmpriv.SupportAbility | val;
  }
#line 1093
  return;
}
}
#line 1096 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_odm_support_ability_clr(struct rtw_adapter *padapter , u32 val ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1098
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1100
  pHalData->odmpriv.SupportAbility = pHalData->odmpriv.SupportAbility & val;
#line 1101
  return;
}
}
#line 1103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void rtl8723a_set_rpwm(struct rtw_adapter *padapter , u8 val ) 
{ 


  {
#line 1105
  rtl8723au_write8(padapter, 65112U, (int )val);
#line 1106
  return;
}
}
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
u8 rtl8723a_get_rf_type(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1110
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1112
  return (pHalData->rf_type);
}
}
#line 1115 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
bool rtl8723a_get_fwlps_rf_on(struct rtw_adapter *padapter ) 
{ 
  bool retval ;
  u32 valRCR ;

  {
#line 1122
  if (padapter->bSurpriseRemoved == 1 || (unsigned int )padapter->pwrctrlpriv.rf_pwrstate == 2U) {
#line 1126
    retval = 1;
  } else {
#line 1128
    valRCR = rtl8723au_read32(padapter, 1544U);
#line 1129
    if ((valRCR & 458752U) != 0U) {
#line 1130
      retval = 0;
    } else {
#line 1132
      retval = 1;
    }
  }
#line 1135
  return (retval);
}
}
#line 1138 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
bool rtl8723a_chk_hi_queue_empty(struct rtw_adapter *padapter ) 
{ 
  u32 hgq ;

  {
#line 1142
  hgq = rtl8723au_read32(padapter, 1044U);
#line 1144
  return ((hgq & 65280U) == 0U);
}
}
#line 1274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
void *ldv_kmem_cache_alloc_914(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1277
  ldv_check_alloc_flags(flags);
#line 1279
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1280
  return ((void *)0);
}
}
#line 1318 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
int ldv_pskb_expand_head_920(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1321
  ldv_check_alloc_flags(flags);
#line 1323
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1323
  return (tmp);
}
}
#line 1334 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
struct sk_buff *ldv_skb_clone_922(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1337
  ldv_check_alloc_flags(flags);
#line 1339
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1339
  return (tmp);
}
}
#line 1350 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
struct sk_buff *ldv_skb_copy_924(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1353
  ldv_check_alloc_flags(flags);
#line 1355
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1355
  return (tmp);
}
}
#line 1358 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_925(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1361
  ldv_check_alloc_flags(flags);
#line 1363
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1363
  return (tmp);
}
}
#line 1366 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_926(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1369
  ldv_check_alloc_flags(flags);
#line 1371
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1371
  return (tmp);
}
}
#line 1374 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_927(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1377
  ldv_check_alloc_flags(flags);
#line 1379
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1379
  return (tmp);
}
}
#line 1382 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
int ldv_pskb_expand_head_928(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1385
  ldv_check_alloc_flags(flags);
#line 1387
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1387
  return (tmp);
}
}
#line 1390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
int ldv_pskb_expand_head_929(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1393
  ldv_check_alloc_flags(flags);
#line 1395
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1395
  return (tmp);
}
}
#line 1398 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_com.o.c.prepared"
struct sk_buff *ldv_skb_clone_930(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1401
  ldv_check_alloc_flags(flags);
#line 1403
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1403
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_956(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_964(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_972(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_966(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_962(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_970(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_971(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_967(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_968(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_969(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) ;
#line 32 "drivers/staging/rtl8723au/include/rtw_ap.h"
void add_RATid23a(struct rtw_adapter *padapter , struct sta_info *psta , u8 rssi_level ) ;
#line 554 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_update_ramask(struct rtw_adapter *padapter , u32 mac_id , u8 rssi_level ) ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
void rtw_hal_update_ra_mask23a(struct sta_info *psta , u8 rssi_level ) 
{ 
  struct rtw_adapter *padapter ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
#line 247
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 248
    return;
  } else {

  }
#line 250
  padapter = psta->padapter;
#line 252
  pmlmepriv = & padapter->mlmepriv;
#line 254
  tmp = check_fwstate(pmlmepriv, 16);
#line 254
  if ((int )tmp) {
#line 256
    add_RATid23a(padapter, psta, (int )rssi_level);
  } else {
#line 259
    rtl8723a_update_ramask(padapter, psta->mac_id, (int )rssi_level);
  }
#line 260
  return;
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
void *ldv_kmem_cache_alloc_956(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 392
  ldv_check_alloc_flags(flags);
#line 394
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 395
  return ((void *)0);
}
}
#line 433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
int ldv_pskb_expand_head_962(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 436
  ldv_check_alloc_flags(flags);
#line 438
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 438
  return (tmp);
}
}
#line 449 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
struct sk_buff *ldv_skb_clone_964(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 452
  ldv_check_alloc_flags(flags);
#line 454
  tmp = skb_clone(ldv_func_arg1, flags);
#line 454
  return (tmp);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
struct sk_buff *ldv_skb_copy_966(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 468
  ldv_check_alloc_flags(flags);
#line 470
  tmp = skb_copy(ldv_func_arg1, flags);
#line 470
  return (tmp);
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_967(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 476
  ldv_check_alloc_flags(flags);
#line 478
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 478
  return (tmp);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_968(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 484
  ldv_check_alloc_flags(flags);
#line 486
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 486
  return (tmp);
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_969(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                           gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 492
  ldv_check_alloc_flags(flags);
#line 494
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 494
  return (tmp);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
int ldv_pskb_expand_head_970(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 500
  ldv_check_alloc_flags(flags);
#line 502
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 502
  return (tmp);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
int ldv_pskb_expand_head_971(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 , int ldv_func_arg3 ,
                             gfp_t flags ) 
{ 
  int tmp ;

  {
#line 508
  ldv_check_alloc_flags(flags);
#line 510
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 510
  return (tmp);
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/hal_intf.o.c.prepared"
struct sk_buff *ldv_skb_clone_972(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 516
  ldv_check_alloc_flags(flags);
#line 518
  tmp = skb_clone(ldv_func_arg1, flags);
#line 518
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_998(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1006(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1014(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1008(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1004(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1012(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1013(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1009(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1010(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1011(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 140 "drivers/staging/rtl8723au/include/Hal8723PwrSeq.h"
struct wlan_pwr_cfg rtl8723AU_power_on_flow[16U] ;
#line 141
struct wlan_pwr_cfg rtl8723AU_radio_off_flow[16U] ;
#line 142
struct wlan_pwr_cfg rtl8723AU_card_disable_flow[31U] ;
#line 143
struct wlan_pwr_cfg rtl8723AU_card_enable_flow[31U] ;
#line 144
struct wlan_pwr_cfg rtl8723AU_suspend_flow[31U] ;
#line 145
struct wlan_pwr_cfg rtl8723AU_resume_flow[31U] ;
#line 146
struct wlan_pwr_cfg rtl8723AU_hwpdn_flow[31U] ;
#line 147
struct wlan_pwr_cfg rtl8723AU_enter_lps_flow[16U] ;
#line 148
struct wlan_pwr_cfg rtl8723AU_leave_lps_flow[16U] ;
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct wlan_pwr_cfg rtl8723AU_power_on_flow[16U]  = 
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
  {      {32U, 255U, 15U, 3U, 0U, 1U, 1U, 1U}, 
        {103U, 255U, 15U, 3U, 0U, 1U, 16U, 0U}, 
        {1U, 255U, 15U, 3U, 0U, 3U, 1U, 1U}, 
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U}, 
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct wlan_pwr_cfg rtl8723AU_radio_off_flow[16U]  = {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 0U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct wlan_pwr_cfg rtl8723AU_card_disable_flow[31U]  = 
#line 252
  {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 0U}, 
        {7U, 255U, 15U, 1U, 0U, 1U, 255U, 32U}, 
        {5U, 255U, 15U, 3U, 0U, 1U, 24U, 8U}, 
        {5U, 255U, 15U, 4U, 0U, 1U, 4U, 4U}, 
        {74U, 255U, 15U, 2U, 0U, 1U, 1U, 1U}, 
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 16U}, 
        {134U, 255U, 15U, 1U, 3U, 1U, 1U, 1U}, 
        {134U, 255U, 15U, 1U, 3U, 2U, 2U, 0U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct wlan_pwr_cfg rtl8723AU_card_enable_flow[31U]  = 
#line 259
  {      {5U, 255U, 15U, 15U, 0U, 1U, 136U, 0U}, 
        {134U, 255U, 15U, 1U, 3U, 1U, 1U, 0U}, 
        {134U, 255U, 15U, 1U, 3U, 2U, 2U, 2U}, 
        {74U, 255U, 15U, 2U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 0U}, 
        {769U, 255U, 15U, 4U, 0U, 1U, 255U, 0U}, 
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 1U}, 
        {103U, 255U, 15U, 3U, 0U, 1U, 16U, 0U}, 
        {1U, 255U, 15U, 3U, 0U, 3U, 1U, 1U}, 
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U}, 
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct wlan_pwr_cfg rtl8723AU_suspend_flow[31U]  = 
#line 266
  {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 4U, 0U, 1U, 24U, 24U}, 
        {5U, 255U, 15U, 3U, 0U, 1U, 24U, 8U}, 
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 16U}, 
        {7U, 255U, 15U, 1U, 0U, 1U, 255U, 32U}, 
        {5U, 255U, 15U, 4U, 0U, 1U, 24U, 24U}, 
        {134U, 255U, 15U, 1U, 3U, 1U, 1U, 1U}, 
        {134U, 255U, 15U, 1U, 3U, 2U, 2U, 0U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct wlan_pwr_cfg rtl8723AU_resume_flow[31U]  = 
#line 273
  {      {5U, 255U, 15U, 15U, 0U, 1U, 136U, 0U}, 
        {134U, 255U, 15U, 1U, 3U, 1U, 1U, 0U}, 
        {134U, 255U, 15U, 1U, 3U, 2U, 2U, 2U}, 
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 1U}, 
        {103U, 255U, 15U, 3U, 0U, 1U, 16U, 0U}, 
        {1U, 255U, 15U, 3U, 0U, 3U, 1U, 1U}, 
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 4U, 0U}, 
        {6U, 255U, 15U, 15U, 0U, 2U, 2U, 2U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 24U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 1U, 1U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 1U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 1U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct wlan_pwr_cfg rtl8723AU_hwpdn_flow[31U]  = 
#line 280
  {      {31U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {78U, 255U, 15U, 15U, 0U, 1U, 128U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {5U, 255U, 15U, 15U, 0U, 2U, 2U, 0U}, 
        {0U, 255U, 15U, 3U, 0U, 1U, 32U, 32U}, 
        {32U, 255U, 15U, 3U, 0U, 1U, 1U, 0U}, 
        {35U, 255U, 15U, 1U, 0U, 1U, 16U, 16U}, 
        {7U, 255U, 15U, 3U, 0U, 1U, 255U, 32U}, 
        {6U, 255U, 15U, 15U, 0U, 1U, 1U, 0U}, 
        {5U, 255U, 15U, 15U, 0U, 1U, 128U, 128U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct wlan_pwr_cfg rtl8723AU_enter_lps_flow[16U]  = 
#line 287
  {      {769U, 255U, 15U, 4U, 0U, 1U, 255U, 255U}, 
        {1314U, 255U, 15U, 15U, 0U, 1U, 255U, 255U}, 
        {1528U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {1529U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {1530U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {1531U, 255U, 15U, 15U, 0U, 2U, 255U, 0U}, 
        {2U, 255U, 15U, 15U, 0U, 1U, 1U, 0U}, 
        {2U, 255U, 15U, 15U, 0U, 3U, 0U, 0U}, 
        {2U, 255U, 15U, 15U, 0U, 1U, 2U, 0U}, 
        {256U, 255U, 15U, 15U, 0U, 1U, 255U, 3U}, 
        {257U, 255U, 15U, 15U, 0U, 1U, 2U, 0U}, 
        {147U, 255U, 15U, 1U, 0U, 1U, 255U, 0U}, 
        {1363U, 255U, 15U, 15U, 0U, 1U, 32U, 32U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct wlan_pwr_cfg rtl8723AU_leave_lps_flow[16U]  = 
#line 294
  {      {128U, 255U, 15U, 1U, 3U, 1U, 255U, 132U}, 
        {65112U, 255U, 15U, 2U, 0U, 1U, 255U, 132U}, 
        {865U, 255U, 15U, 4U, 0U, 1U, 255U, 132U}, 
        {2U, 255U, 15U, 15U, 0U, 3U, 0U, 1U}, 
        {8U, 255U, 15U, 15U, 0U, 1U, 16U, 0U}, 
        {265U, 255U, 15U, 15U, 0U, 2U, 128U, 0U}, 
        {41U, 255U, 15U, 15U, 0U, 1U, 192U, 0U}, 
        {257U, 255U, 15U, 15U, 0U, 1U, 2U, 2U}, 
        {256U, 255U, 15U, 15U, 0U, 1U, 255U, 255U}, 
        {2U, 255U, 15U, 15U, 0U, 1U, 3U, 3U}, 
        {1314U, 255U, 15U, 15U, 0U, 1U, 255U, 0U}, 
        {65535U, 255U, 15U, 15U, 0U, 4U, 0U, 0U}};
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
void *ldv_kmem_cache_alloc_998(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 430
  ldv_check_alloc_flags(flags);
#line 432
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 433
  return ((void *)0);
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
int ldv_pskb_expand_head_1004(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 474
  ldv_check_alloc_flags(flags);
#line 476
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 476
  return (tmp);
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct sk_buff *ldv_skb_clone_1006(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 490
  ldv_check_alloc_flags(flags);
#line 492
  tmp = skb_clone(ldv_func_arg1, flags);
#line 492
  return (tmp);
}
}
#line 503 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct sk_buff *ldv_skb_copy_1008(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 506
  ldv_check_alloc_flags(flags);
#line 508
  tmp = skb_copy(ldv_func_arg1, flags);
#line 508
  return (tmp);
}
}
#line 511 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1009(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 514
  ldv_check_alloc_flags(flags);
#line 516
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 516
  return (tmp);
}
}
#line 519 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1010(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 522
  ldv_check_alloc_flags(flags);
#line 524
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 524
  return (tmp);
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1011(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 530
  ldv_check_alloc_flags(flags);
#line 532
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 532
  return (tmp);
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
int ldv_pskb_expand_head_1012(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 538
  ldv_check_alloc_flags(flags);
#line 540
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 540
  return (tmp);
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
int ldv_pskb_expand_head_1013(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 546
  ldv_check_alloc_flags(flags);
#line 548
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 548
  return (tmp);
}
}
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723PwrSeq.o.c.prepared"
struct sk_buff *ldv_skb_clone_1014(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 554
  ldv_check_alloc_flags(flags);
#line 556
  tmp = skb_clone(ldv_func_arg1, flags);
#line 556
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1040(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1048(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1056(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1050(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1046(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1054(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1055(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1051(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1052(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1053(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 25 "drivers/staging/rtl8723au/include/Hal8723UHWImg_CE.h"
u32 Rtl8723UPHY_REG_Array_PG[336U] ;
#line 27
u32 Rtl8723UMACPHY_Array_PG[1U] ;
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
u32 Rtl8723UPHY_REG_Array_PG[336U]  = 
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
  {      3584U,      4294967295U,      168561676U,      3588U, 
        4294967295U,      33818120U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      168561934U,      3604U, 
        4294967295U,      33818120U,      3608U,      4294967295U, 
        168561934U,      3612U,      4294967295U,      33818120U, 
        2096U,      4294967295U,      168561676U,      2100U, 
        4294967295U,      33818120U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      168561934U,      2120U, 
        4294967295U,      33818120U,      2124U,      4294967295U, 
        168561934U,      2152U,      4294967295U,      33818120U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      67372036U,      3588U, 
        4294967295U,      131588U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      101058054U,      3604U, 
        4294967295U,      132102U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      67372036U,      2100U, 
        4294967295U,      131588U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      101058054U,      2120U, 
        4294967295U,      132102U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      67372036U,      3588U, 
        4294967295U,      131588U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      67372036U,      2100U, 
        4294967295U,      131588U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U};
#line 352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
u32 Rtl8723UMACPHY_Array_PG[1U]  = {      0U};
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
void *ldv_kmem_cache_alloc_1040(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 486
  ldv_check_alloc_flags(flags);
#line 488
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 489
  return ((void *)0);
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
int ldv_pskb_expand_head_1046(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 530
  ldv_check_alloc_flags(flags);
#line 532
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 532
  return (tmp);
}
}
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
struct sk_buff *ldv_skb_clone_1048(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 546
  ldv_check_alloc_flags(flags);
#line 548
  tmp = skb_clone(ldv_func_arg1, flags);
#line 548
  return (tmp);
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
struct sk_buff *ldv_skb_copy_1050(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 562
  ldv_check_alloc_flags(flags);
#line 564
  tmp = skb_copy(ldv_func_arg1, flags);
#line 564
  return (tmp);
}
}
#line 567 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1051(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 570
  ldv_check_alloc_flags(flags);
#line 572
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 572
  return (tmp);
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1052(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 578
  ldv_check_alloc_flags(flags);
#line 580
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 580
  return (tmp);
}
}
#line 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1053(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 586
  ldv_check_alloc_flags(flags);
#line 588
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 588
  return (tmp);
}
}
#line 591 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
int ldv_pskb_expand_head_1054(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 594
  ldv_check_alloc_flags(flags);
#line 596
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 596
  return (tmp);
}
}
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
int ldv_pskb_expand_head_1055(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 602
  ldv_check_alloc_flags(flags);
#line 604
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 604
  return (tmp);
}
}
#line 607 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/Hal8723UHWImg_CE.o.c.prepared"
struct sk_buff *ldv_skb_clone_1056(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 610
  ldv_check_alloc_flags(flags);
#line 612
  tmp = skb_clone(ldv_func_arg1, flags);
#line 612
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1082(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1090(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1098(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1092(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1088(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1096(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1097(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1093(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1094(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1095(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 177 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
u32 PHY_QueryBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask ) ;
#line 179
void PHY_SetBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask , u32 Data ) ;
#line 181
u32 PHY_QueryRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                   u32 BitMask ) ;
#line 184
void PHY_SetRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) ;
#line 1010 "drivers/staging/rtl8723au/include/odm.h"
u32 OFDMSwingTable23A[43U] ;
#line 1011
u8 CCKSwingTable_Ch1_Ch1323A[33U][8U] ;
#line 1012
u8 CCKSwingTable_Ch1423A[33U][8U] ;
#line 50 "drivers/staging/rtl8723au/include/HalDMOutSrc8723A.h"
void rtl8723a_phy_iq_calibrate(struct rtw_adapter *pAdapter , bool bReCovery ) ;
#line 55
void rtl8723a_phy_lc_calibrate(struct rtw_adapter *pAdapter ) ;
#line 60
void rtl8723a_phy_ap_calibrate(struct rtw_adapter *pAdapter , char delta ) ;
#line 62
void rtl8723a_odm_check_tx_power_tracking(struct rtw_adapter *Adapter ) ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void odm_TXPowerTrackingCallback_ThermalMeter_92C(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 ThermalValue ;
  u8 delta ;
  u8 delta_LCK ;
  u8 delta_IQK ;
  u8 delta_HP ;
  int ele_A ;
  int ele_D ;
  int TempCCk ;
  int X ;
  int value32 ;
  int Y ;
  int ele_C ;
  s8 OFDM_index[2U] ;
  s8 CCK_index ;
  s8 OFDM_index_old[2U] ;
  unsigned int tmp ;
  s8 CCK_index_old ;
  int i ;
  bool is2T ;
  u8 OFDM_min_index ;
  u8 rf ;
  u8 ThermalValue_HP_count ;
  u32 ThermalValue_HP ;
  s32 index_mapping_HP[15U] ;
  s8 index_HP ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 248
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 249
  pdmpriv = & pHalData->dmpriv;
#line 250
  ThermalValue = 0U;
#line 253
  CCK_index = 0;
#line 253
  OFDM_index_old[0] = 0;
#line 253
  tmp = 1U;
#line 253
  while (1) {
#line 253
    if (tmp >= 2U) {
#line 253
      break;
    } else {

    }
#line 253
    OFDM_index_old[tmp] = (signed char)0;
#line 253
    tmp = tmp + 1U;
  }
#line 254
  CCK_index_old = 0;
#line 255
  i = 0;
#line 256
  is2T = (bool )(((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U);
#line 257
  OFDM_min_index = 6U;
#line 258
  ThermalValue_HP_count = 0U;
#line 259
  ThermalValue_HP = 0U;
#line 260
  index_mapping_HP[0] = 0;
#line 260
  index_mapping_HP[1] = 1;
#line 260
  index_mapping_HP[2] = 3;
#line 260
  index_mapping_HP[3] = 4;
#line 260
  index_mapping_HP[4] = 6;
#line 260
  index_mapping_HP[5] = 7;
#line 260
  index_mapping_HP[6] = 9;
#line 260
  index_mapping_HP[7] = 10;
#line 260
  index_mapping_HP[8] = 12;
#line 260
  index_mapping_HP[9] = 13;
#line 260
  index_mapping_HP[10] = 15;
#line 260
  index_mapping_HP[11] = 16;
#line 260
  index_mapping_HP[12] = 18;
#line 260
  index_mapping_HP[13] = 19;
#line 260
  index_mapping_HP[14] = 21;
#line 267
  pdmpriv->TXPowerTrackingCallbackCnt = pdmpriv->TXPowerTrackingCallbackCnt + 1U;
#line 268
  pdmpriv->bTXPowerTrackingInit = 1U;
#line 270
  if ((unsigned int )pHalData->CurrentChannel == 14U && (unsigned int )pdmpriv->bCCKinCH14 == 0U) {
#line 271
    pdmpriv->bCCKinCH14 = 1U;
  } else
#line 272
  if ((unsigned int )pHalData->CurrentChannel != 14U && (unsigned int )pdmpriv->bCCKinCH14 != 0U) {
#line 273
    pdmpriv->bCCKinCH14 = 0U;
  } else {

  }
#line 275
  tmp___0 = PHY_QueryRFReg(Adapter, 0, 36U, 31U);
#line 275
  ThermalValue = (unsigned char )tmp___0;
#line 278
  rtl8723a_phy_ap_calibrate(Adapter, (int )((char )((int )ThermalValue - (int )pHalData->EEPROMThermalMeter)));
#line 281
  if ((int )is2T) {
#line 282
    rf = 2U;
  } else {
#line 284
    rf = 1U;
  }
#line 286
  if ((unsigned int )ThermalValue != 0U) {
#line 288
    tmp___1 = PHY_QueryBBReg(Adapter, 3200U, 4294967295U);
#line 288
    ele_D = (int )tmp___1 & -4194304;
#line 290
    i = 0;
#line 290
    goto ldv_54274;
    ldv_54273: ;
#line 292
    if ((u32 )ele_D == (OFDMSwingTable23A[i] & 4290772992U)) {
#line 293
      OFDM_index_old[0] = (s8 )i;
#line 294
      goto ldv_54272;
    } else {

    }
#line 290
    i = i + 1;
    ldv_54274: ;
#line 290
    if (i <= 36) {
#line 292
      goto ldv_54273;
    } else {

    }
    ldv_54272: ;
#line 299
    if ((int )is2T) {
#line 300
      tmp___2 = PHY_QueryBBReg(Adapter, 3208U, 4294967295U);
#line 300
      ele_D = (int )tmp___2 & -4194304;
#line 302
      i = 0;
#line 302
      goto ldv_54277;
      ldv_54276: ;
#line 303
      if ((u32 )ele_D == (OFDMSwingTable23A[i] & 4290772992U)) {
#line 304
        OFDM_index_old[1] = (s8 )i;
#line 305
        goto ldv_54275;
      } else {

      }
#line 302
      i = i + 1;
      ldv_54277: ;
#line 302
      if (i <= 36) {
#line 304
        goto ldv_54276;
      } else {

      }
      ldv_54275: ;
    } else {

    }
#line 311
    tmp___3 = PHY_QueryBBReg(Adapter, 2596U, 4294967295U);
#line 311
    TempCCk = (int )tmp___3 & 1061109567;
#line 313
    i = 0;
#line 313
    goto ldv_54280;
    ldv_54279: ;
#line 314
    if ((unsigned int )pdmpriv->bCCKinCH14 != 0U) {
#line 315
      tmp___4 = memcmp((void const   *)(& TempCCk), (void const   *)(& CCKSwingTable_Ch1423A) + ((unsigned long )i + 2UL),
                       4UL);
#line 315
      if (tmp___4 == 0) {
#line 317
        CCK_index_old = (s8 )i;
#line 318
        goto ldv_54278;
      } else {

      }
    } else {
#line 321
      tmp___5 = memcmp((void const   *)(& TempCCk), (void const   *)(& CCKSwingTable_Ch1_Ch1323A) + ((unsigned long )i + 2UL),
                       4UL);
#line 321
      if (tmp___5 == 0) {
#line 323
        CCK_index_old = (s8 )i;
#line 324
        goto ldv_54278;
      } else {

      }
    }
#line 313
    i = i + 1;
    ldv_54280: ;
#line 313
    if (i <= 32) {
#line 315
      goto ldv_54279;
    } else {

    }
    ldv_54278: ;
#line 329
    if ((unsigned int )pdmpriv->ThermalValue == 0U) {
#line 330
      pdmpriv->ThermalValue = pHalData->EEPROMThermalMeter;
#line 331
      pdmpriv->ThermalValue_LCK = ThermalValue;
#line 332
      pdmpriv->ThermalValue_IQK = ThermalValue;
#line 333
      pdmpriv->ThermalValue_DPK = pHalData->EEPROMThermalMeter;
#line 335
      i = 0;
#line 335
      goto ldv_54282;
      ldv_54281: 
#line 336
      pdmpriv->OFDM_index_HP[i] = (u8 )OFDM_index_old[i];
#line 337
      pdmpriv->OFDM_index[i] = (u8 )OFDM_index_old[i];
#line 335
      i = i + 1;
      ldv_54282: ;
#line 335
      if ((int )rf > i) {
#line 337
        goto ldv_54281;
      } else {

      }
#line 339
      pdmpriv->CCK_index_HP = (u8 )CCK_index_old;
#line 340
      pdmpriv->CCK_index = (u8 )CCK_index_old;
    } else {

    }
#line 343
    if ((unsigned int )pHalData->BoardType == 1U) {
#line 344
      pdmpriv->ThermalValue_HP[(int )pdmpriv->ThermalValue_HP_index] = ThermalValue;
#line 345
      pdmpriv->ThermalValue_HP_index = (u8 )((int )pdmpriv->ThermalValue_HP_index + 1);
#line 346
      if ((unsigned int )pdmpriv->ThermalValue_HP_index == 8U) {
#line 347
        pdmpriv->ThermalValue_HP_index = 0U;
      } else {

      }
#line 349
      i = 0;
#line 349
      goto ldv_54285;
      ldv_54284: ;
#line 350
      if ((unsigned int )pdmpriv->ThermalValue_HP[i] != 0U) {
#line 351
        ThermalValue_HP = (u32 )pdmpriv->ThermalValue_HP[i] + ThermalValue_HP;
#line 352
        ThermalValue_HP_count = (u8 )((int )ThermalValue_HP_count + 1);
      } else {

      }
#line 349
      i = i + 1;
      ldv_54285: ;
#line 349
      if (i <= 7) {
#line 351
        goto ldv_54284;
      } else {

      }

#line 356
      if ((unsigned int )ThermalValue_HP_count != 0U) {
#line 357
        ThermalValue = (unsigned char )(ThermalValue_HP / (u32 )ThermalValue_HP_count);
      } else {

      }
    } else {

    }
#line 360
    delta = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
#line 363
    if ((unsigned int )pHalData->BoardType == 1U) {
#line 364
      if ((unsigned int )pdmpriv->bDoneTxpower != 0U) {
#line 365
        delta_HP = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
      } else {
#line 369
        delta_HP = (int )pHalData->EEPROMThermalMeter < (int )ThermalValue ? (int )ThermalValue - (int )pHalData->EEPROMThermalMeter : (int )pHalData->EEPROMThermalMeter - (int )ThermalValue;
      }
    } else {
#line 373
      delta_HP = 0U;
    }
#line 375
    delta_LCK = (int )pdmpriv->ThermalValue_LCK < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue_LCK : (int )pdmpriv->ThermalValue_LCK - (int )ThermalValue;
#line 378
    delta_IQK = (int )pdmpriv->ThermalValue_IQK < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue_IQK : (int )pdmpriv->ThermalValue_IQK - (int )ThermalValue;
#line 382
    if ((unsigned int )delta_LCK > 1U) {
#line 383
      pdmpriv->ThermalValue_LCK = ThermalValue;
#line 384
      rtl8723a_phy_lc_calibrate(Adapter);
    } else {

    }
#line 387
    if (((unsigned int )delta != 0U || (unsigned int )delta_HP != 0U) && (unsigned int )pdmpriv->TxPowerTrackControl != 0U) {
#line 388
      if ((unsigned int )pHalData->BoardType == 1U) {
#line 389
        pdmpriv->bDoneTxpower = 1U;
#line 390
        delta_HP = (int )pHalData->EEPROMThermalMeter < (int )ThermalValue ? (int )ThermalValue - (int )pHalData->EEPROMThermalMeter : (int )pHalData->EEPROMThermalMeter - (int )ThermalValue;
#line 394
        if ((unsigned int )delta_HP > 14U) {
#line 395
          index_HP = (s8 )index_mapping_HP[14];
        } else {
#line 397
          index_HP = (s8 )index_mapping_HP[(int )delta_HP];
        }
#line 399
        if ((int )pHalData->EEPROMThermalMeter < (int )ThermalValue) {
#line 401
          i = 0;
#line 401
          goto ldv_54288;
          ldv_54287: 
#line 402
          OFDM_index[i] = (s8 )((int )pdmpriv->OFDM_index_HP[i] - (int )((unsigned char )index_HP));
#line 401
          i = i + 1;
          ldv_54288: ;
#line 401
          if ((int )rf > i) {
#line 403
            goto ldv_54287;
          } else {

          }
#line 403
          CCK_index = (s8 )((int )pdmpriv->CCK_index_HP - (int )((unsigned char )index_HP));
        } else {
#line 405
          i = 0;
#line 405
          goto ldv_54291;
          ldv_54290: 
#line 406
          OFDM_index[i] = (s8 )((int )pdmpriv->OFDM_index_HP[i] + (int )((unsigned char )index_HP));
#line 405
          i = i + 1;
          ldv_54291: ;
#line 405
          if ((int )rf > i) {
#line 407
            goto ldv_54290;
          } else {

          }
#line 407
          CCK_index = (s8 )((int )pdmpriv->CCK_index_HP + (int )((unsigned char )index_HP));
        }
#line 410
        delta_HP = (int )pdmpriv->ThermalValue < (int )ThermalValue ? (int )ThermalValue - (int )pdmpriv->ThermalValue : (int )pdmpriv->ThermalValue - (int )ThermalValue;
      } else
#line 414
      if ((int )pdmpriv->ThermalValue < (int )ThermalValue) {
#line 415
        i = 0;
#line 415
        goto ldv_54294;
        ldv_54293: 
#line 416
        pdmpriv->OFDM_index[i] = (int )pdmpriv->OFDM_index[i] - (int )delta;
#line 415
        i = i + 1;
        ldv_54294: ;
#line 415
        if ((int )rf > i) {
#line 417
          goto ldv_54293;
        } else {

        }
#line 417
        pdmpriv->CCK_index = (int )pdmpriv->CCK_index - (int )delta;
      } else {
#line 419
        i = 0;
#line 419
        goto ldv_54297;
        ldv_54296: 
#line 420
        pdmpriv->OFDM_index[i] = (int )pdmpriv->OFDM_index[i] + (int )delta;
#line 419
        i = i + 1;
        ldv_54297: ;
#line 419
        if ((int )rf > i) {
#line 421
          goto ldv_54296;
        } else {

        }
#line 421
        pdmpriv->CCK_index = (int )pdmpriv->CCK_index + (int )delta;
      }
#line 426
      if ((unsigned int )pHalData->BoardType != 1U) {
#line 427
        if ((int )pHalData->EEPROMThermalMeter < (int )ThermalValue) {
#line 428
          i = 0;
#line 428
          goto ldv_54300;
          ldv_54299: 
#line 429
          OFDM_index[i] = (s8 )((unsigned int )pdmpriv->OFDM_index[i] + 1U);
#line 428
          i = i + 1;
          ldv_54300: ;
#line 428
          if ((int )rf > i) {
#line 430
            goto ldv_54299;
          } else {

          }
#line 430
          CCK_index = (s8 )((unsigned int )pdmpriv->CCK_index + 1U);
        } else {
#line 432
          i = 0;
#line 432
          goto ldv_54303;
          ldv_54302: 
#line 433
          OFDM_index[i] = (s8 )pdmpriv->OFDM_index[i];
#line 432
          i = i + 1;
          ldv_54303: ;
#line 432
          if ((int )rf > i) {
#line 434
            goto ldv_54302;
          } else {

          }
#line 434
          CCK_index = (s8 )pdmpriv->CCK_index;
        }
      } else {

      }
#line 437
      i = 0;
#line 437
      goto ldv_54306;
      ldv_54305: ;
#line 438
      if ((int )OFDM_index[i] > 36) {
#line 439
        OFDM_index[i] = 36;
      } else
#line 440
      if ((int )OFDM_index[i] < (int )OFDM_min_index) {
#line 441
        OFDM_index[i] = (s8 )OFDM_min_index;
      } else {

      }
#line 437
      i = i + 1;
      ldv_54306: ;
#line 437
      if ((int )rf > i) {
#line 439
        goto ldv_54305;
      } else {

      }

#line 444
      if ((int )CCK_index > 32) {
#line 445
        CCK_index = 32;
      } else
#line 446
      if ((int )CCK_index < 0) {
#line 447
        CCK_index = 0;
      } else {

      }
    } else {

    }
#line 450
    if ((unsigned int )pdmpriv->TxPowerTrackControl != 0U && ((unsigned int )delta != 0U || (unsigned int )delta_HP != 0U)) {
#line 452
      ele_D = (int )(OFDMSwingTable23A[(int )OFDM_index[0]] >> 22);
#line 453
      X = pdmpriv->RegE94;
#line 454
      Y = pdmpriv->RegE9C;
#line 456
      if (X != 0) {
#line 457
        if ((X & 512) != 0) {
#line 458
          X = (int )((unsigned int )X | 4294966272U);
        } else {

        }
#line 459
        ele_A = (X * ele_D >> 8) & 1023;
#line 462
        if ((Y & 512) != 0) {
#line 463
          Y = (int )((unsigned int )Y | 4294966272U);
        } else {

        }
#line 464
        ele_C = (Y * ele_D >> 8) & 1023;
#line 467
        value32 = ((ele_D << 22) | ((ele_C & 63) << 16)) | ele_A;
#line 468
        PHY_SetBBReg(Adapter, 3200U, 4294967295U, (u32 )value32);
#line 470
        value32 = (ele_C & 960) >> 6;
#line 471
        PHY_SetBBReg(Adapter, 3220U, 4026531840U, (u32 )value32);
#line 473
        value32 = (X * ele_D >> 7) & 1;
#line 474
        PHY_SetBBReg(Adapter, 3148U, 2147483648U, (u32 )value32);
#line 477
        value32 = (Y * ele_D >> 7) & 1;
#line 478
        PHY_SetBBReg(Adapter, 3148U, 536870912U, (u32 )value32);
      } else {
#line 481
        PHY_SetBBReg(Adapter, 3200U, 4294967295U, OFDMSwingTable23A[(int )OFDM_index[0]]);
#line 484
        PHY_SetBBReg(Adapter, 3220U, 4026531840U, 0U);
#line 486
        PHY_SetBBReg(Adapter, 3148U, 2684354560U, 0U);
      }
#line 491
      if ((unsigned int )pdmpriv->bCCKinCH14 == 0U) {
#line 492
        rtl8723au_write8(Adapter, 2594U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][0]);
#line 493
        rtl8723au_write8(Adapter, 2595U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][1]);
#line 494
        rtl8723au_write8(Adapter, 2596U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][2]);
#line 495
        rtl8723au_write8(Adapter, 2597U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][3]);
#line 496
        rtl8723au_write8(Adapter, 2598U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][4]);
#line 497
        rtl8723au_write8(Adapter, 2599U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][5]);
#line 498
        rtl8723au_write8(Adapter, 2600U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][6]);
#line 499
        rtl8723au_write8(Adapter, 2601U, (int )CCKSwingTable_Ch1_Ch1323A[(int )CCK_index][7]);
      } else {
#line 501
        rtl8723au_write8(Adapter, 2594U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][0]);
#line 502
        rtl8723au_write8(Adapter, 2595U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][1]);
#line 503
        rtl8723au_write8(Adapter, 2596U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][2]);
#line 504
        rtl8723au_write8(Adapter, 2597U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][3]);
#line 505
        rtl8723au_write8(Adapter, 2598U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][4]);
#line 506
        rtl8723au_write8(Adapter, 2599U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][5]);
#line 507
        rtl8723au_write8(Adapter, 2600U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][6]);
#line 508
        rtl8723au_write8(Adapter, 2601U, (int )CCKSwingTable_Ch1423A[(int )CCK_index][7]);
      }
#line 511
      if ((int )is2T) {
#line 512
        ele_D = (int )(OFDMSwingTable23A[(int )((unsigned char )OFDM_index[1])] >> 22);
#line 515
        X = pdmpriv->RegEB4;
#line 516
        Y = pdmpriv->RegEBC;
#line 518
        if (X != 0) {
#line 519
          if ((X & 512) != 0) {
#line 520
            X = (int )((unsigned int )X | 4294966272U);
          } else {

          }
#line 521
          ele_A = (X * ele_D >> 8) & 1023;
#line 524
          if ((Y & 512) != 0) {
#line 525
            Y = (int )((unsigned int )Y | 4294966272U);
          } else {

          }
#line 526
          ele_C = (Y * ele_D >> 8) & 1023;
#line 529
          value32 = ((ele_D << 22) | ((ele_C & 63) << 16)) | ele_A;
#line 530
          PHY_SetBBReg(Adapter, 3208U, 4294967295U, (u32 )value32);
#line 532
          value32 = (ele_C & 960) >> 6;
#line 533
          PHY_SetBBReg(Adapter, 3228U, 4026531840U, (u32 )value32);
#line 535
          value32 = (X * ele_D >> 7) & 1;
#line 536
          PHY_SetBBReg(Adapter, 3148U, 134217728U, (u32 )value32);
#line 540
          value32 = (Y * ele_D >> 7) & 1;
#line 541
          PHY_SetBBReg(Adapter, 3148U, 33554432U, (u32 )value32);
        } else {
#line 545
          PHY_SetBBReg(Adapter, 3208U, 4294967295U, OFDMSwingTable23A[(int )OFDM_index[1]]);
#line 549
          PHY_SetBBReg(Adapter, 3228U, 4026531840U, 0U);
#line 552
          PHY_SetBBReg(Adapter, 3148U, 167772160U, 0U);
        }
      } else {

      }
    } else {

    }
#line 559
    if ((unsigned int )delta_IQK > 3U) {
#line 560
      pdmpriv->ThermalValue_IQK = ThermalValue;
#line 561
      rtl8723a_phy_iq_calibrate(Adapter, 0);
    } else {

    }
#line 565
    if ((unsigned int )pdmpriv->TxPowerTrackControl != 0U) {
#line 566
      pdmpriv->ThermalValue = ThermalValue;
    } else {

    }
  } else {

  }
#line 568
  pdmpriv->TXPowercount = 0U;
#line 569
  return;
}
}
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void ODM_TXPowerTracking92CDirectCall(struct rtw_adapter *Adapter ) 
{ 


  {
#line 579
  odm_TXPowerTrackingCallback_ThermalMeter_92C(Adapter);
#line 580
  return;
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void odm_CheckTXPowerTracking_ThermalMeter(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *podmpriv ;

  {
#line 584
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 585
  pdmpriv = & pHalData->dmpriv;
#line 586
  podmpriv = & pHalData->odmpriv;
#line 588
  if ((podmpriv->SupportAbility & 16777216U) == 0U) {
#line 589
    return;
  } else {

  }
#line 591
  if ((unsigned int )pdmpriv->TM_Trigger == 0U) {
#line 592
    PHY_SetRFReg(Adapter, 0, 36U, 1048575U, 96U);
#line 594
    pdmpriv->TM_Trigger = 1U;
#line 595
    return;
  } else {
#line 597
    ODM_TXPowerTracking92CDirectCall(Adapter);
#line 598
    pdmpriv->TM_Trigger = 0U;
  }
#line 600
  return;
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
void rtl8723a_odm_check_tx_power_tracking(struct rtw_adapter *Adapter ) 
{ 


  {
#line 604
  odm_CheckTXPowerTracking_ThermalMeter(Adapter);
#line 605
  return;
}
}
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static u8 _PHY_PathA_IQK(struct rtw_adapter *pAdapter , bool configPathB ) 
{ 
  u32 regEAC ;
  u32 regE94 ;
  u32 regE9C ;
  u32 regEA4 ;
  u8 result ;
  struct hal_data_8723a *pHalData ;

  {
#line 614
  result = 0U;
#line 615
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 618
  PHY_SetBBReg(pAdapter, 3632U, 4294967295U, 268471327U);
#line 619
  PHY_SetBBReg(pAdapter, 3636U, 4294967295U, 268471327U);
#line 620
  PHY_SetBBReg(pAdapter, 3640U, 4294967295U, 2182349058U);
#line 622
  PHY_SetBBReg(pAdapter, 3644U, 4294967295U, (int )configPathB ? 672530946U : (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) ? 672530946U : 672531714U));
#line 626
  if ((int )configPathB) {
#line 627
    PHY_SetBBReg(pAdapter, 3664U, 4294967295U, 268471330U);
#line 628
    PHY_SetBBReg(pAdapter, 3668U, 4294967295U, 268471330U);
#line 629
    PHY_SetBBReg(pAdapter, 3672U, 4294967295U, 2182349058U);
#line 630
    PHY_SetBBReg(pAdapter, 3676U, 4294967295U, 672530946U);
  } else {

  }
#line 634
  PHY_SetBBReg(pAdapter, 3660U, 4294967295U, 1059025U);
#line 637
  PHY_SetBBReg(pAdapter, 3656U, 4294967295U, 4177526784U);
#line 638
  PHY_SetBBReg(pAdapter, 3656U, 4294967295U, 4160749568U);
#line 641
  __const_udelay(4295000UL);
#line 644
  regEAC = PHY_QueryBBReg(pAdapter, 3756U, 4294967295U);
#line 645
  regE94 = PHY_QueryBBReg(pAdapter, 3732U, 4294967295U);
#line 646
  regE9C = PHY_QueryBBReg(pAdapter, 3740U, 4294967295U);
#line 647
  regEA4 = PHY_QueryBBReg(pAdapter, 3748U, 4294967295U);
#line 649
  if ((((unsigned long )regEAC & 268435456UL) == 0UL && (regE94 & 67043328U) >> 16 != 322U) && (regE9C & 67043328U) >> 16 != 66U) {
#line 652
    result = (u8 )((unsigned int )result | 1U);
  } else {
#line 654
    return (result);
  }
#line 656
  if ((((unsigned long )regEAC & 134217728UL) == 0UL && (regEA4 & 67043328U) >> 16 != 306U) && (regEAC & 67043328U) >> 16 != 54U) {
#line 659
    result = (u8 )((unsigned int )result | 2U);
  } else
#line 661
  if (GlobalDebugLevel23A > 3U) {
#line 661
    printk("\016RTL8723AU: Path A Rx IQK fail!!\n");
  } else {

  }
#line 662
  return (result);
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static u8 _PHY_PathB_IQK(struct rtw_adapter *pAdapter ) 
{ 
  u32 regEAC ;
  u32 regEB4 ;
  u32 regEBC ;
  u32 regEC4 ;
  u32 regECC ;
  u8 result ;

  {
#line 668
  result = 0U;
#line 671
  PHY_SetBBReg(pAdapter, 3680U, 4294967295U, 2U);
#line 672
  PHY_SetBBReg(pAdapter, 3680U, 4294967295U, 0U);
#line 675
  __const_udelay(4295000UL);
#line 678
  regEAC = PHY_QueryBBReg(pAdapter, 3756U, 4294967295U);
#line 679
  regEB4 = PHY_QueryBBReg(pAdapter, 3764U, 4294967295U);
#line 680
  regEBC = PHY_QueryBBReg(pAdapter, 3772U, 4294967295U);
#line 681
  regEC4 = PHY_QueryBBReg(pAdapter, 3780U, 4294967295U);
#line 682
  regECC = PHY_QueryBBReg(pAdapter, 3788U, 4294967295U);
#line 684
  if (((int )regEAC >= 0 && (regEB4 & 67043328U) >> 16 != 322U) && (regEBC & 67043328U) >> 16 != 66U) {
#line 687
    result = (u8 )((unsigned int )result | 1U);
  } else {
#line 689
    return (result);
  }
#line 691
  if ((((unsigned long )regEAC & 1073741824UL) == 0UL && (regEC4 & 67043328U) >> 16 != 306U) && (regECC & 67043328U) >> 16 != 54U) {
#line 694
    result = (u8 )((unsigned int )result | 2U);
  } else
#line 696
  if (GlobalDebugLevel23A > 3U) {
#line 696
    printk("\016RTL8723AU: Path B Rx IQK fail!!\n");
  } else {

  }
#line 697
  return (result);
}
}
#line 700 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_PathAFillIQKMatrix(struct rtw_adapter *pAdapter , bool bIQKOK , int (*result)[8U] ,
                                    u8 final_candidate , bool bTxOnly ) 
{ 
  u32 Oldval_0 ;
  u32 X ;
  u32 TX0_A ;
  u32 reg ;
  s32 Y ;
  s32 TX0_C ;
  u32 tmp ;

  {
#line 710
  if (GlobalDebugLevel23A > 3U) {
#line 710
    printk("\016RTL8723AU: Path A IQ Calibration %s !\n", (int )bIQKOK ? (char *)"Success" : (char *)"Failed");
  } else {

  }
#line 712
  if ((unsigned int )final_candidate == 255U) {
#line 713
    return;
  } else
#line 714
  if ((int )bIQKOK) {
#line 715
    tmp = PHY_QueryBBReg(pAdapter, 3200U, 4294967295U);
#line 715
    Oldval_0 = tmp >> 22;
#line 717
    X = (u32 )(*(result + (unsigned long )final_candidate))[0];
#line 718
    if ((X & 512U) != 0U) {
#line 719
      X = X | 4294966272U;
    } else {

    }
#line 720
    TX0_A = X * Oldval_0 >> 8;
#line 721
    PHY_SetBBReg(pAdapter, 3200U, 1023U, TX0_A);
#line 722
    PHY_SetBBReg(pAdapter, 3148U, 2147483648U, (X * Oldval_0 >> 7) & 1U);
#line 724
    Y = (*(result + (unsigned long )final_candidate))[1];
#line 725
    if ((Y & 512) != 0) {
#line 726
      Y = (s32 )((unsigned int )Y | 4294966272U);
    } else {

    }
#line 727
    TX0_C = (s32 )((u32 )Y * Oldval_0 >> 8);
#line 728
    PHY_SetBBReg(pAdapter, 3220U, 4026531840U, (u32 )((TX0_C & 960) >> 6));
#line 729
    PHY_SetBBReg(pAdapter, 3200U, 4128768U, (u32 )TX0_C & 63U);
#line 730
    PHY_SetBBReg(pAdapter, 3148U, 536870912U, ((u32 )Y * Oldval_0 >> 7) & 1U);
#line 732
    if ((int )bTxOnly) {
#line 733
      if (GlobalDebugLevel23A > 3U) {
#line 733
        printk("\016RTL8723AU: _PHY_PathAFillIQKMatrix only Tx OK\n");
      } else {

      }
#line 734
      return;
    } else {

    }
#line 737
    reg = (u32 )(*(result + (unsigned long )final_candidate))[2];
#line 738
    PHY_SetBBReg(pAdapter, 3092U, 1023U, reg);
#line 740
    reg = (u32 )(*(result + (unsigned long )final_candidate))[3] & 63U;
#line 741
    PHY_SetBBReg(pAdapter, 3092U, 64512U, reg);
#line 743
    reg = (u32 )((*(result + (unsigned long )final_candidate))[3] >> 6) & 15U;
#line 744
    PHY_SetBBReg(pAdapter, 3232U, 4026531840U, reg);
  } else {

  }
#line 746
  return;
}
}
#line 748 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_PathBFillIQKMatrix(struct rtw_adapter *pAdapter , bool bIQKOK , int (*result)[8U] ,
                                    u8 final_candidate , bool bTxOnly ) 
{ 
  u32 Oldval_1 ;
  u32 X ;
  u32 TX1_A ;
  u32 reg ;
  s32 Y ;
  s32 TX1_C ;
  u32 tmp ;

  {
#line 753
  if (GlobalDebugLevel23A > 3U) {
#line 753
    printk("\016RTL8723AU: Path B IQ Calibration %s !\n", (int )bIQKOK ? (char *)"Success" : (char *)"Failed");
  } else {

  }
#line 755
  if ((unsigned int )final_candidate == 255U) {
#line 756
    return;
  } else
#line 757
  if ((int )bIQKOK) {
#line 758
    tmp = PHY_QueryBBReg(pAdapter, 3208U, 4294967295U);
#line 758
    Oldval_1 = tmp >> 22;
#line 760
    X = (u32 )(*(result + (unsigned long )final_candidate))[4];
#line 761
    if ((X & 512U) != 0U) {
#line 762
      X = X | 4294966272U;
    } else {

    }
#line 763
    TX1_A = X * Oldval_1 >> 8;
#line 764
    PHY_SetBBReg(pAdapter, 3208U, 1023U, TX1_A);
#line 765
    PHY_SetBBReg(pAdapter, 3148U, 134217728U, (X * Oldval_1 >> 7) & 1U);
#line 767
    Y = (*(result + (unsigned long )final_candidate))[5];
#line 768
    if ((Y & 512) != 0) {
#line 769
      Y = (s32 )((unsigned int )Y | 4294966272U);
    } else {

    }
#line 770
    TX1_C = (s32 )((u32 )Y * Oldval_1 >> 8);
#line 771
    PHY_SetBBReg(pAdapter, 3228U, 4026531840U, (u32 )((TX1_C & 960) >> 6));
#line 772
    PHY_SetBBReg(pAdapter, 3208U, 4128768U, (u32 )TX1_C & 63U);
#line 773
    PHY_SetBBReg(pAdapter, 3148U, 33554432U, ((u32 )Y * Oldval_1 >> 7) & 1U);
#line 775
    if ((int )bTxOnly) {
#line 776
      return;
    } else {

    }
#line 778
    reg = (u32 )(*(result + (unsigned long )final_candidate))[6];
#line 779
    PHY_SetBBReg(pAdapter, 3100U, 1023U, reg);
#line 781
    reg = (u32 )(*(result + (unsigned long )final_candidate))[7] & 63U;
#line 782
    PHY_SetBBReg(pAdapter, 3100U, 64512U, reg);
#line 784
    reg = (u32 )((*(result + (unsigned long )final_candidate))[7] >> 6) & 15U;
#line 785
    PHY_SetBBReg(pAdapter, 3192U, 61440U, reg);
  } else {

  }
#line 787
  return;
}
}
#line 789 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_SaveADDARegisters(struct rtw_adapter *pAdapter , u32 *ADDAReg , u32 *ADDABackup ,
                                   u32 RegisterNum ) 
{ 
  u32 i ;

  {
#line 793
  i = 0U;
#line 793
  goto ldv_54373;
  ldv_54372: 
#line 794
  *(ADDABackup + (unsigned long )i) = PHY_QueryBBReg(pAdapter, *(ADDAReg + (unsigned long )i),
                                                     4294967295U);
#line 793
  i = i + 1U;
  ldv_54373: ;
#line 793
  if (i < RegisterNum) {
#line 795
    goto ldv_54372;
  } else {

  }

#line 800
  return;
}
}
#line 798 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_SaveMACRegisters(struct rtw_adapter *pAdapter , u32 *MACReg , u32 *MACBackup ) 
{ 
  u32 i ;
  u8 tmp ;

  {
#line 802
  i = 0U;
#line 802
  goto ldv_54382;
  ldv_54381: 
#line 803
  tmp = rtl8723au_read8(pAdapter, *(MACReg + (unsigned long )i));
#line 803
  *(MACBackup + (unsigned long )i) = (u32 )tmp;
#line 802
  i = i + 1U;
  ldv_54382: ;
#line 802
  if (i <= 2U) {
#line 804
    goto ldv_54381;
  } else {

  }
#line 805
  *(MACBackup + (unsigned long )i) = rtl8723au_read32(pAdapter, *(MACReg + (unsigned long )i));
#line 806
  return;
}
}
#line 808 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_ReloadADDARegisters(struct rtw_adapter *pAdapter , u32 *ADDAReg ,
                                     u32 *ADDABackup , u32 RegiesterNum ) 
{ 
  u32 i ;

  {
#line 812
  i = 0U;
#line 812
  goto ldv_54392;
  ldv_54391: 
#line 813
  PHY_SetBBReg(pAdapter, *(ADDAReg + (unsigned long )i), 4294967295U, *(ADDABackup + (unsigned long )i));
#line 812
  i = i + 1U;
  ldv_54392: ;
#line 812
  if (i < RegiesterNum) {
#line 814
    goto ldv_54391;
  } else {

  }

#line 819
  return;
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_ReloadMACRegisters(struct rtw_adapter *pAdapter , u32 *MACReg , u32 *MACBackup ) 
{ 
  u32 i ;

  {
#line 821
  i = 0U;
#line 821
  goto ldv_54401;
  ldv_54400: 
#line 822
  rtl8723au_write8(pAdapter, *(MACReg + (unsigned long )i), (int )((unsigned char )*(MACBackup + (unsigned long )i)));
#line 821
  i = i + 1U;
  ldv_54401: ;
#line 821
  if (i <= 2U) {
#line 823
    goto ldv_54400;
  } else {

  }
#line 824
  rtl8723au_write32(pAdapter, *(MACReg + (unsigned long )i), *(MACBackup + (unsigned long )i));
#line 825
  return;
}
}
#line 827 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_PathADDAOn(struct rtw_adapter *pAdapter , u32 *ADDAReg , bool isPathAOn ,
                            bool is2T ) 
{ 
  u32 pathOn ;
  u32 i ;

  {
#line 832
  pathOn = (int )isPathAOn ? 81470884U : 186328484U;
#line 833
  if (! is2T) {
#line 834
    pathOn = 198911392U;
#line 835
    PHY_SetBBReg(pAdapter, *ADDAReg, 4294967295U, 186328480U);
  } else {
#line 837
    PHY_SetBBReg(pAdapter, *ADDAReg, 4294967295U, pathOn);
  }
#line 840
  i = 1U;
#line 840
  goto ldv_54412;
  ldv_54411: 
#line 841
  PHY_SetBBReg(pAdapter, *(ADDAReg + (unsigned long )i), 4294967295U, pathOn);
#line 840
  i = i + 1U;
  ldv_54412: ;
#line 840
  if (i <= 15U) {
#line 842
    goto ldv_54411;
  } else {

  }

#line 847
  return;
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_MACSettingCalibration(struct rtw_adapter *pAdapter , u32 *MACReg ,
                                       u32 *MACBackup ) 
{ 
  u32 i ;

  {
#line 846
  i = 0U;
#line 848
  rtl8723au_write8(pAdapter, *(MACReg + (unsigned long )i), 63);
#line 850
  i = 1U;
#line 850
  goto ldv_54421;
  ldv_54420: 
#line 851
  rtl8723au_write8(pAdapter, *(MACReg + (unsigned long )i), (int )((unsigned char )*(MACBackup + (unsigned long )i)) & 247);
#line 850
  i = i + 1U;
  ldv_54421: ;
#line 850
  if (i <= 2U) {
#line 852
    goto ldv_54420;
  } else {

  }
#line 854
  rtl8723au_write8(pAdapter, *(MACReg + (unsigned long )i), (int )((unsigned char )*(MACBackup + (unsigned long )i)) & 223);
#line 855
  return;
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_PathAStandBy(struct rtw_adapter *pAdapter ) 
{ 


  {
#line 859
  PHY_SetBBReg(pAdapter, 3624U, 4294967295U, 0U);
#line 860
  PHY_SetBBReg(pAdapter, 2112U, 4294967295U, 65536U);
#line 861
  PHY_SetBBReg(pAdapter, 3624U, 4294967295U, 2155872256U);
#line 862
  return;
}
}
#line 864 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_PIModeSwitch(struct rtw_adapter *pAdapter , bool PIMode ) 
{ 
  u32 mode ;

  {
#line 868
  mode = (int )PIMode ? 16777472U : 16777216U;
#line 869
  PHY_SetBBReg(pAdapter, 2080U, 4294967295U, mode);
#line 870
  PHY_SetBBReg(pAdapter, 2088U, 4294967295U, mode);
#line 871
  return;
}
}
#line 876 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static bool _PHY_SimularityCompare(struct rtw_adapter *pAdapter , int (*result)[8U] ,
                                   u8 c1 , u8 c2 ) 
{ 
  u32 i ;
  u32 j ;
  u32 diff ;
  u32 SimularityBitMap ;
  u32 bound ;
  struct hal_data_8723a *pHalData ;
  u8 final_candidate[2U] ;
  bool bResult ;
  bool is2T ;

  {
#line 878
  bound = 0U;
#line 879
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 880
  final_candidate[0] = 255U;
#line 880
  final_candidate[1] = 255U;
#line 881
  bResult = 1;
#line 881
  is2T = (bool )(((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U);
#line 883
  if ((int )is2T) {
#line 884
    bound = 8U;
  } else {
#line 886
    bound = 4U;
  }
#line 888
  SimularityBitMap = 0U;
#line 890
  i = 0U;
#line 890
  goto ldv_54447;
  ldv_54446: 
#line 891
  diff = (u32 )((*(result + (unsigned long )c1))[i] > (*(result + (unsigned long )c2))[i] ? (*(result + (unsigned long )c1))[i] - (*(result + (unsigned long )c2))[i] : (*(result + (unsigned long )c2))[i] - (*(result + (unsigned long )c1))[i]);
#line 892
  if (diff > 5U) {
#line 893
    if ((i == 2U || i == 6U) && SimularityBitMap == 0U) {
#line 894
      if ((*(result + (unsigned long )c1))[i] + (*(result + (unsigned long )c1))[i + 1U] == 0) {
#line 895
        final_candidate[i / 4U] = c2;
      } else
#line 896
      if ((*(result + (unsigned long )c2))[i] + (*(result + (unsigned long )c2))[i + 1U] == 0) {
#line 897
        final_candidate[i / 4U] = c1;
      } else {
#line 899
        SimularityBitMap = (u32 )(1 << (int )i) | SimularityBitMap;
      }
    } else {
#line 901
      SimularityBitMap = (u32 )(1 << (int )i) | SimularityBitMap;
    }
  } else {

  }
#line 890
  i = i + 1U;
  ldv_54447: ;
#line 890
  if (i < bound) {
#line 892
    goto ldv_54446;
  } else {

  }

#line 906
  if (SimularityBitMap == 0U) {
#line 907
    i = 0U;
#line 907
    goto ldv_54453;
    ldv_54452: ;
#line 908
    if ((unsigned int )final_candidate[i] != 255U) {
#line 909
      j = i * 4U;
#line 909
      goto ldv_54450;
      ldv_54449: 
#line 910
      (*(result + 3UL))[j] = (*(result + (unsigned long )final_candidate[i]))[j];
#line 909
      j = j + 1U;
      ldv_54450: ;
#line 909
      if ((i + 1U) * 4U - 2U > j) {
#line 911
        goto ldv_54449;
      } else {

      }
#line 911
      bResult = 0;
    } else {

    }
#line 907
    i = i + 1U;
    ldv_54453: ;
#line 907
    if (bound / 4U > i) {
#line 909
      goto ldv_54452;
    } else {

    }

#line 914
    return (bResult);
  } else
#line 915
  if ((SimularityBitMap & 15U) == 0U) {
#line 917
    i = 0U;
#line 917
    goto ldv_54456;
    ldv_54455: 
#line 918
    (*(result + 3UL))[i] = (*(result + (unsigned long )c1))[i];
#line 917
    i = i + 1U;
    ldv_54456: ;
#line 917
    if (i <= 3U) {
#line 919
      goto ldv_54455;
    } else {

    }

#line 919
    return (0);
  } else
#line 920
  if ((SimularityBitMap & 240U) == 0U && (int )is2T) {
#line 922
    i = 4U;
#line 922
    goto ldv_54459;
    ldv_54458: 
#line 923
    (*(result + 3UL))[i] = (*(result + (unsigned long )c1))[i];
#line 922
    i = i + 1U;
    ldv_54459: ;
#line 922
    if (i <= 7U) {
#line 924
      goto ldv_54458;
    } else {

    }

#line 924
    return (0);
  } else {
#line 926
    return (0);
  }
}
}
#line 930 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_IQCalibrate(struct rtw_adapter *pAdapter , int (*result)[8U] , u8 t ,
                             bool is2T ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u32 i ;
  u8 PathAOK ;
  u8 PathBOK ;
  u32 ADDA_REG[16U] ;
  u32 IQK_MAC_REG[4U] ;
  u32 IQK_BB_REG_92C[9U] ;
  u32 retryCount ;
  u32 bbvalue ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;

  {
#line 932
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 933
  pdmpriv = & pHalData->dmpriv;
#line 936
  ADDA_REG[0] = 2140U;
#line 936
  ADDA_REG[1] = 3692U;
#line 936
  ADDA_REG[2] = 3696U;
#line 936
  ADDA_REG[3] = 3700U;
#line 936
  ADDA_REG[4] = 3704U;
#line 936
  ADDA_REG[5] = 3708U;
#line 936
  ADDA_REG[6] = 3712U;
#line 936
  ADDA_REG[7] = 3716U;
#line 936
  ADDA_REG[8] = 3720U;
#line 936
  ADDA_REG[9] = 3724U;
#line 936
  ADDA_REG[10] = 3792U;
#line 936
  ADDA_REG[11] = 3796U;
#line 936
  ADDA_REG[12] = 3800U;
#line 936
  ADDA_REG[13] = 3804U;
#line 936
  ADDA_REG[14] = 3808U;
#line 936
  ADDA_REG[15] = 3820U;
#line 947
  IQK_MAC_REG[0] = 1314U;
#line 947
  IQK_MAC_REG[1] = 1360U;
#line 947
  IQK_MAC_REG[2] = 1361U;
#line 947
  IQK_MAC_REG[3] = 64U;
#line 952
  IQK_BB_REG_92C[0] = 3076U;
#line 952
  IQK_BB_REG_92C[1] = 3080U;
#line 952
  IQK_BB_REG_92C[2] = 2164U;
#line 952
  IQK_BB_REG_92C[3] = 2920U;
#line 952
  IQK_BB_REG_92C[4] = 2924U;
#line 952
  IQK_BB_REG_92C[5] = 2160U;
#line 952
  IQK_BB_REG_92C[6] = 2144U;
#line 952
  IQK_BB_REG_92C[7] = 2148U;
#line 952
  IQK_BB_REG_92C[8] = 2048U;
#line 959
  retryCount = 2U;
#line 966
  if ((unsigned int )t == 0U) {
#line 967
    bbvalue = PHY_QueryBBReg(pAdapter, 2048U, 4294967295U);
#line 970
    _PHY_SaveADDARegisters(pAdapter, (u32 *)(& ADDA_REG), (u32 *)(& pdmpriv->ADDA_backup),
                           16U);
#line 971
    _PHY_SaveMACRegisters(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
#line 972
    _PHY_SaveADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup),
                           9U);
  } else {

  }
#line 974
  _PHY_PathADDAOn(pAdapter, (u32 *)(& ADDA_REG), 1, (int )is2T);
#line 976
  if ((unsigned int )t == 0U) {
#line 977
    tmp = PHY_QueryBBReg(pAdapter, 2080U, 256U);
#line 977
    pdmpriv->bRfPiEnable = (unsigned char )tmp;
  } else {

  }
#line 981
  if ((unsigned int )pdmpriv->bRfPiEnable == 0U) {
#line 983
    _PHY_PIModeSwitch(pAdapter, 1);
  } else {

  }
#line 986
  PHY_SetBBReg(pAdapter, 2048U, 16777216U, 0U);
#line 987
  PHY_SetBBReg(pAdapter, 3076U, 4294967295U, 60839424U);
#line 988
  PHY_SetBBReg(pAdapter, 3080U, 4294967295U, 524516U);
#line 989
  PHY_SetBBReg(pAdapter, 2164U, 4294967295U, 572538880U);
#line 990
  PHY_SetBBReg(pAdapter, 2160U, 1024U, 1U);
#line 991
  PHY_SetBBReg(pAdapter, 2160U, 67108864U, 1U);
#line 992
  PHY_SetBBReg(pAdapter, 2144U, 1024U, 0U);
#line 993
  PHY_SetBBReg(pAdapter, 2148U, 1024U, 0U);
#line 995
  if ((int )is2T) {
#line 996
    PHY_SetBBReg(pAdapter, 2112U, 4294967295U, 65536U);
#line 997
    PHY_SetBBReg(pAdapter, 2116U, 4294967295U, 65536U);
  } else {

  }
#line 1001
  _PHY_MACSettingCalibration(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
#line 1004
  PHY_SetBBReg(pAdapter, 2920U, 4294967295U, 524288U);
#line 1006
  if ((int )is2T) {
#line 1007
    PHY_SetBBReg(pAdapter, 2924U, 4294967295U, 524288U);
  } else {

  }
#line 1010
  PHY_SetBBReg(pAdapter, 3624U, 4294967295U, 2155872256U);
#line 1011
  PHY_SetBBReg(pAdapter, 3648U, 4294967295U, 16808960U);
#line 1012
  PHY_SetBBReg(pAdapter, 3652U, 4294967295U, 16795648U);
#line 1014
  i = 0U;
#line 1014
  goto ldv_54479;
  ldv_54478: 
#line 1015
  PathAOK = _PHY_PathA_IQK(pAdapter, (int )is2T);
#line 1016
  if ((unsigned int )PathAOK == 3U) {
#line 1017
    if (GlobalDebugLevel23A > 3U) {
#line 1017
      printk("\016RTL8723AU: Path A IQK Success!!\n");
    } else {

    }
#line 1018
    tmp___0 = PHY_QueryBBReg(pAdapter, 3732U, 4294967295U);
#line 1018
    (*(result + (unsigned long )t))[0] = (int )((tmp___0 & 67043328U) >> 16);
#line 1019
    tmp___1 = PHY_QueryBBReg(pAdapter, 3740U, 4294967295U);
#line 1019
    (*(result + (unsigned long )t))[1] = (int )((tmp___1 & 67043328U) >> 16);
#line 1020
    tmp___2 = PHY_QueryBBReg(pAdapter, 3748U, 4294967295U);
#line 1020
    (*(result + (unsigned long )t))[2] = (int )((tmp___2 & 67043328U) >> 16);
#line 1021
    tmp___3 = PHY_QueryBBReg(pAdapter, 3756U, 4294967295U);
#line 1021
    (*(result + (unsigned long )t))[3] = (int )((tmp___3 & 67043328U) >> 16);
#line 1022
    goto ldv_54477;
  } else
#line 1023
  if (retryCount - 1U == i && (unsigned int )PathAOK == 1U) {
#line 1025
    if (GlobalDebugLevel23A > 3U) {
#line 1025
      printk("\016RTL8723AU: Path A IQK Only  Tx Success!!\n");
    } else {

    }
#line 1027
    tmp___4 = PHY_QueryBBReg(pAdapter, 3732U, 4294967295U);
#line 1027
    (*(result + (unsigned long )t))[0] = (int )((tmp___4 & 67043328U) >> 16);
#line 1028
    tmp___5 = PHY_QueryBBReg(pAdapter, 3740U, 4294967295U);
#line 1028
    (*(result + (unsigned long )t))[1] = (int )((tmp___5 & 67043328U) >> 16);
  } else {

  }
#line 1014
  i = i + 1U;
  ldv_54479: ;
#line 1014
  if (i < retryCount) {
#line 1016
    goto ldv_54478;
  } else {

  }
  ldv_54477: ;
#line 1032
  if ((unsigned int )PathAOK == 0U) {
#line 1033
    if (GlobalDebugLevel23A > 3U) {
#line 1033
      printk("\016RTL8723AU: Path A IQK failed!!\n");
    } else {

    }
  } else {

  }
#line 1036
  if ((int )is2T) {
#line 1037
    _PHY_PathAStandBy(pAdapter);
#line 1040
    _PHY_PathADDAOn(pAdapter, (u32 *)(& ADDA_REG), 0, (int )is2T);
#line 1042
    i = 0U;
#line 1042
    goto ldv_54482;
    ldv_54481: 
#line 1043
    PathBOK = _PHY_PathB_IQK(pAdapter);
#line 1044
    if ((unsigned int )PathBOK == 3U) {
#line 1045
      if (GlobalDebugLevel23A > 3U) {
#line 1045
        printk("\016RTL8723AU: Path B IQK Success!!\n");
      } else {

      }
#line 1046
      tmp___6 = PHY_QueryBBReg(pAdapter, 3764U, 4294967295U);
#line 1046
      (*(result + (unsigned long )t))[4] = (int )((tmp___6 & 67043328U) >> 16);
#line 1047
      tmp___7 = PHY_QueryBBReg(pAdapter, 3772U, 4294967295U);
#line 1047
      (*(result + (unsigned long )t))[5] = (int )((tmp___7 & 67043328U) >> 16);
#line 1048
      tmp___8 = PHY_QueryBBReg(pAdapter, 3780U, 4294967295U);
#line 1048
      (*(result + (unsigned long )t))[6] = (int )((tmp___8 & 67043328U) >> 16);
#line 1049
      tmp___9 = PHY_QueryBBReg(pAdapter, 3788U, 4294967295U);
#line 1049
      (*(result + (unsigned long )t))[7] = (int )((tmp___9 & 67043328U) >> 16);
#line 1050
      goto ldv_54480;
    } else
#line 1051
    if (retryCount - 1U == i && (unsigned int )PathBOK == 1U) {
#line 1053
      if (GlobalDebugLevel23A > 3U) {
#line 1053
        printk("\016RTL8723AU: Path B Only Tx IQK Success!!\n");
      } else {

      }
#line 1054
      tmp___10 = PHY_QueryBBReg(pAdapter, 3764U, 4294967295U);
#line 1054
      (*(result + (unsigned long )t))[4] = (int )((tmp___10 & 67043328U) >> 16);
#line 1055
      tmp___11 = PHY_QueryBBReg(pAdapter, 3772U, 4294967295U);
#line 1055
      (*(result + (unsigned long )t))[5] = (int )((tmp___11 & 67043328U) >> 16);
    } else {

    }
#line 1042
    i = i + 1U;
    ldv_54482: ;
#line 1042
    if (i < retryCount) {
#line 1044
      goto ldv_54481;
    } else {

    }
    ldv_54480: ;
#line 1059
    if ((unsigned int )PathBOK == 0U) {
#line 1060
      if (GlobalDebugLevel23A > 3U) {
#line 1060
        printk("\016RTL8723AU: Path B IQK failed!!\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 1065
  PHY_SetBBReg(pAdapter, 3624U, 4294967295U, 0U);
#line 1067
  if ((unsigned int )t != 0U) {
#line 1068
    if ((unsigned int )pdmpriv->bRfPiEnable == 0U) {
#line 1070
      _PHY_PIModeSwitch(pAdapter, 0);
    } else {

    }
#line 1074
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& ADDA_REG), (u32 *)(& pdmpriv->ADDA_backup),
                             16U);
#line 1077
    _PHY_ReloadMACRegisters(pAdapter, (u32 *)(& IQK_MAC_REG), (u32 *)(& pdmpriv->IQK_MAC_backup));
#line 1080
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup),
                             9U);
#line 1083
    PHY_SetBBReg(pAdapter, 2112U, 4294967295U, 208595U);
#line 1084
    if ((int )is2T) {
#line 1085
      PHY_SetBBReg(pAdapter, 2116U, 4294967295U, 208595U);
    } else {

    }
#line 1089
    PHY_SetBBReg(pAdapter, 3632U, 4294967295U, 16813056U);
#line 1090
    PHY_SetBBReg(pAdapter, 3636U, 4294967295U, 16813056U);
  } else {

  }
#line 1092
  return;
}
}
#line 1095 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
static void _PHY_LCCalibrate(struct rtw_adapter *pAdapter , bool is2T ) 
{ 
  u8 tmpReg ;
  u32 RF_Amode ;
  u32 RF_Bmode ;
  u32 LC_Cal ;

  {
#line 1098
  RF_Amode = 0U;
#line 1098
  RF_Bmode = 0U;
#line 1101
  tmpReg = rtl8723au_read8(pAdapter, 3331U);
#line 1103
  if (((int )tmpReg & 112) != 0) {
#line 1106
    rtl8723au_write8(pAdapter, 3331U, (int )tmpReg & 143);
  } else {
#line 1110
    rtl8723au_write8(pAdapter, 1314U, 255);
  }
#line 1113
  if (((int )tmpReg & 112) != 0) {
#line 1116
    RF_Amode = PHY_QueryRFReg(pAdapter, 0, 0U, 4095U);
#line 1119
    if ((int )is2T) {
#line 1120
      RF_Bmode = PHY_QueryRFReg(pAdapter, 1, 0U, 4095U);
    } else {

    }
#line 1124
    PHY_SetRFReg(pAdapter, 0, 0U, 4095U, (RF_Amode & 589823U) | 65536U);
#line 1127
    if ((int )is2T) {
#line 1128
      PHY_SetRFReg(pAdapter, 1, 0U, 4095U, (RF_Bmode & 589823U) | 65536U);
    } else {

    }
  } else {

  }
#line 1132
  LC_Cal = PHY_QueryRFReg(pAdapter, 0, 24U, 4095U);
#line 1135
  PHY_SetRFReg(pAdapter, 0, 24U, 4095U, LC_Cal | 32768U);
#line 1137
  msleep(100U);
#line 1140
  if (((int )tmpReg & 112) != 0) {
#line 1142
    rtl8723au_write8(pAdapter, 3331U, (int )tmpReg);
#line 1143
    PHY_SetRFReg(pAdapter, 0, 0U, 4095U, RF_Amode);
#line 1146
    if ((int )is2T) {
#line 1147
      PHY_SetRFReg(pAdapter, 1, 0U, 4095U, RF_Bmode);
    } else {

    }
  } else {
#line 1149
    rtl8723au_write8(pAdapter, 1314U, 0);
  }
#line 1150
  return;
}
}
#line 1157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
void rtl8723a_phy_iq_calibrate(struct rtw_adapter *pAdapter , bool bReCovery ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  s32 result[4U][8U] ;
  u8 i ;
  u8 final_candidate ;
  bool bPathAOK ;
  bool bPathBOK ;
  s32 RegE94 ;
  s32 RegE9C ;
  s32 RegEA4 ;
  s32 RegEAC ;
  s32 RegEB4 ;
  s32 RegEBC ;
  s32 RegEC4 ;
  s32 RegECC ;
  s32 RegTmp ;
  bool is12simular ;
  bool is13simular ;
  bool is23simular ;
  bool bStartContTx ;
  bool bSingleTone ;
  bool bCarrierSuppression ;
  u32 IQK_BB_REG_92C[9U] ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;

  {
#line 1159
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 1160
  pdmpriv = & pHalData->dmpriv;
#line 1165
  RegTmp = 0;
#line 1167
  bStartContTx = 0;
#line 1167
  bSingleTone = 0;
#line 1168
  bCarrierSuppression = 0;
#line 1169
  IQK_BB_REG_92C[0] = 3092U;
#line 1169
  IQK_BB_REG_92C[1] = 3100U;
#line 1169
  IQK_BB_REG_92C[2] = 3148U;
#line 1169
  IQK_BB_REG_92C[3] = 3192U;
#line 1169
  IQK_BB_REG_92C[4] = 3200U;
#line 1169
  IQK_BB_REG_92C[5] = 3208U;
#line 1169
  IQK_BB_REG_92C[6] = 3220U;
#line 1169
  IQK_BB_REG_92C[7] = 3228U;
#line 1169
  IQK_BB_REG_92C[8] = 3232U;
#line 1178
  if (((int )bStartContTx || (int )bSingleTone) || (int )bCarrierSuppression) {
#line 1179
    return;
  } else {

  }
#line 1181
  if ((int )bReCovery) {
#line 1182
    _PHY_ReloadADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup_recover),
                             9U);
#line 1183
    return;
  } else {

  }
#line 1185
  if (GlobalDebugLevel23A > 3U) {
#line 1185
    printk("\016RTL8723AU: IQK:Start!!!\n");
  } else {

  }
#line 1187
  i = 0U;
#line 1187
  goto ldv_54519;
  ldv_54518: 
#line 1188
  result[0][(int )i] = 0;
#line 1189
  result[1][(int )i] = 0;
#line 1190
  result[2][(int )i] = 0;
#line 1191
  result[3][(int )i] = 0;
#line 1187
  i = (u8 )((int )i + 1);
  ldv_54519: ;
#line 1187
  if ((unsigned int )i <= 7U) {
#line 1189
    goto ldv_54518;
  } else {

  }
#line 1193
  final_candidate = 255U;
#line 1194
  bPathAOK = 0;
#line 1195
  bPathBOK = 0;
#line 1196
  is12simular = 0;
#line 1197
  is23simular = 0;
#line 1198
  is13simular = 0;
#line 1200
  i = 0U;
#line 1200
  goto ldv_54526;
  ldv_54525: ;
#line 1201
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U) {
#line 1202
    _PHY_IQCalibrate(pAdapter, (int (*)[8])(& result), (int )i, 1);
  } else {
#line 1205
    _PHY_IQCalibrate(pAdapter, (int (*)[8])(& result), (int )i, 0);
  }
#line 1208
  if ((unsigned int )i == 1U) {
#line 1209
    is12simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 0, 1);
#line 1210
    if ((int )is12simular) {
#line 1211
      final_candidate = 0U;
#line 1212
      goto ldv_54521;
    } else {

    }
  } else {

  }
#line 1216
  if ((unsigned int )i == 2U) {
#line 1217
    is13simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 0, 2);
#line 1218
    if ((int )is13simular) {
#line 1219
      final_candidate = 0U;
#line 1220
      goto ldv_54521;
    } else {

    }
#line 1223
    is23simular = _PHY_SimularityCompare(pAdapter, (int (*)[8])(& result), 1, 2);
#line 1224
    if ((int )is23simular) {
#line 1225
      final_candidate = 1U;
    } else {
#line 1227
      i = 0U;
#line 1227
      goto ldv_54523;
      ldv_54522: 
#line 1228
      RegTmp = result[3][(int )i] + RegTmp;
#line 1227
      i = (u8 )((int )i + 1);
      ldv_54523: ;
#line 1227
      if ((unsigned int )i <= 7U) {
#line 1229
        goto ldv_54522;
      } else {

      }

#line 1230
      if (RegTmp != 0) {
#line 1231
        final_candidate = 3U;
      } else {
#line 1233
        final_candidate = 255U;
      }
    }
  } else {

  }
#line 1200
  i = (u8 )((int )i + 1);
  ldv_54526: ;
#line 1200
  if ((unsigned int )i <= 2U) {
#line 1202
    goto ldv_54525;
  } else {

  }
  ldv_54521: 
#line 1238
  i = 0U;
#line 1238
  goto ldv_54528;
  ldv_54527: 
#line 1239
  RegE94 = result[(int )i][0];
#line 1240
  RegE9C = result[(int )i][1];
#line 1241
  RegEA4 = result[(int )i][2];
#line 1242
  RegEAC = result[(int )i][3];
#line 1243
  RegEB4 = result[(int )i][4];
#line 1244
  RegEBC = result[(int )i][5];
#line 1245
  RegEC4 = result[(int )i][6];
#line 1246
  RegECC = result[(int )i][7];
#line 1238
  i = (u8 )((int )i + 1);
  ldv_54528: ;
#line 1238
  if ((unsigned int )i <= 3U) {
#line 1240
    goto ldv_54527;
  } else {

  }

#line 1249
  if ((unsigned int )final_candidate != 255U) {
#line 1250
    RegE94 = result[(int )final_candidate][0];
#line 1251
    pdmpriv->RegE94 = RegE94;
#line 1252
    RegE9C = result[(int )final_candidate][1];
#line 1253
    pdmpriv->RegE9C = RegE9C;
#line 1254
    RegEA4 = result[(int )final_candidate][2];
#line 1255
    RegEAC = result[(int )final_candidate][3];
#line 1256
    RegEB4 = result[(int )final_candidate][4];
#line 1257
    pdmpriv->RegEB4 = RegEB4;
#line 1258
    RegEBC = result[(int )final_candidate][5];
#line 1259
    pdmpriv->RegEBC = RegEBC;
#line 1260
    RegEC4 = result[(int )final_candidate][6];
#line 1261
    RegECC = result[(int )final_candidate][7];
#line 1262
    if (GlobalDebugLevel23A > 3U) {
#line 1262
      printk("\016RTL8723AU: IQK: final_candidate is %x\n", (int )final_candidate);
    } else {

    }
#line 1263
    if (GlobalDebugLevel23A > 3U) {
#line 1263
      printk("\016RTL8723AU: IQK: RegE94 =%x RegE9C =%x RegEA4 =%x RegEAC =%x RegEB4 =%x RegEBC =%x RegEC4 =%x RegECC =%x\n ",
             RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC);
    } else {

    }
#line 1265
    bPathBOK = 1;
#line 1265
    bPathAOK = bPathBOK;
  } else {
#line 1267
    tmp___0 = 256;
#line 1267
    pdmpriv->RegEB4 = tmp___0;
#line 1267
    tmp = tmp___0;
#line 1267
    pdmpriv->RegE94 = tmp;
#line 1267
    RegEB4 = tmp;
#line 1267
    RegE94 = RegEB4;
#line 1268
    tmp___2 = 0;
#line 1268
    pdmpriv->RegEBC = tmp___2;
#line 1268
    tmp___1 = tmp___2;
#line 1268
    pdmpriv->RegE9C = tmp___1;
#line 1268
    RegEBC = tmp___1;
#line 1268
    RegE9C = RegEBC;
  }
#line 1271
  if (RegE94 != 0) {
#line 1272
    _PHY_PathAFillIQKMatrix(pAdapter, (int )bPathAOK, (int (*)[8])(& result), (int )final_candidate,
                            RegEA4 == 0);
  } else {

  }
#line 1274
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U) {
#line 1275
    if (RegEB4 != 0) {
#line 1276
      _PHY_PathBFillIQKMatrix(pAdapter, (int )bPathBOK, (int (*)[8])(& result), (int )final_candidate,
                              RegEC4 == 0);
    } else {

    }
  } else {

  }
#line 1279
  _PHY_SaveADDARegisters(pAdapter, (u32 *)(& IQK_BB_REG_92C), (u32 *)(& pdmpriv->IQK_BB_backup_recover),
                         9U);
#line 1280
  return;
}
}
#line 1282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
void rtl8723a_phy_lc_calibrate(struct rtw_adapter *pAdapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct mlme_ext_priv *pmlmeext ;
  bool bStartContTx ;
  bool bSingleTone ;
  bool bCarrierSuppression ;

  {
#line 1284
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 1285
  pmlmeext = & pAdapter->mlmeextpriv;
#line 1286
  bStartContTx = 0;
#line 1286
  bSingleTone = 0;
#line 1286
  bCarrierSuppression = 0;
#line 1289
  if (((int )bStartContTx || (int )bSingleTone) || (int )bCarrierSuppression) {
#line 1290
    return;
  } else {

  }
#line 1292
  if (pmlmeext->sitesurvey_res.state == 3) {
#line 1293
    return;
  } else {

  }
#line 1295
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U) {
#line 1296
    _PHY_LCCalibrate(pAdapter, 1);
  } else {
#line 1299
    _PHY_LCCalibrate(pAdapter, 0);
  }
#line 1300
  return;
}
}
#line 1304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
void rtl8723a_phy_ap_calibrate(struct rtw_adapter *pAdapter , char delta ) 
{ 


  {
#line 1306
  return;
}
}
#line 1435 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
void *ldv_kmem_cache_alloc_1082(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1438
  ldv_check_alloc_flags(flags);
#line 1440
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1441
  return ((void *)0);
}
}
#line 1479 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
int ldv_pskb_expand_head_1088(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1482
  ldv_check_alloc_flags(flags);
#line 1484
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1484
  return (tmp);
}
}
#line 1495 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
struct sk_buff *ldv_skb_clone_1090(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1498
  ldv_check_alloc_flags(flags);
#line 1500
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1500
  return (tmp);
}
}
#line 1511 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
struct sk_buff *ldv_skb_copy_1092(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1514
  ldv_check_alloc_flags(flags);
#line 1516
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1516
  return (tmp);
}
}
#line 1519 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1093(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1522
  ldv_check_alloc_flags(flags);
#line 1524
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1524
  return (tmp);
}
}
#line 1527 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1094(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1530
  ldv_check_alloc_flags(flags);
#line 1532
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1532
  return (tmp);
}
}
#line 1535 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1095(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1538
  ldv_check_alloc_flags(flags);
#line 1540
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1540
  return (tmp);
}
}
#line 1543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
int ldv_pskb_expand_head_1096(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1546
  ldv_check_alloc_flags(flags);
#line 1548
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1548
  return (tmp);
}
}
#line 1551 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
int ldv_pskb_expand_head_1097(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1554
  ldv_check_alloc_flags(flags);
#line 1556
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1556
  return (tmp);
}
}
#line 1559 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalDMOutSrc8723A_CE.o.c.prepared"
struct sk_buff *ldv_skb_clone_1098(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1562
  ldv_check_alloc_flags(flags);
#line 1564
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1564
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1124(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1132(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1140(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1134(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1130(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1138(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1139(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1135(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1136(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1137(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 24 "drivers/staging/rtl8723au/include/HalHWImg8723A_RF.h"
void ODM_ReadAndConfig_AGC_TAB_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 30 "drivers/staging/rtl8723au/include/HalHWImg8723A_BB.h"
void ODM_ReadAndConfig_PHY_REG_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 36
void ODM_ReadAndConfig_PHY_REG_MP_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 42
void ODM_ReadAndConfig_PHY_REG_PG_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 27 "drivers/staging/rtl8723au/include/odm_RegConfig8723A.h"
void odm_ConfigBB_AGC_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask , u32 Data ) ;
#line 30
void odm_ConfigBB_PHY_REG_PG_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask ,
                                   u32 Data ) ;
#line 32
void odm_ConfigBB_PHY_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask , u32 Data ) ;
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
static bool CheckCondition(u32 const   Condition , u32 const   Hex ) 
{ 
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;

  {
#line 238
  _board = (unsigned int )Hex & 255U;
#line 239
  _interface = ((unsigned int )Hex & 65280U) >> 8;
#line 240
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
#line 241
  cond = Condition;
#line 243
  if ((unsigned int )Condition == 3452816845U) {
#line 244
    return (1);
  } else {

  }
#line 246
  cond = (unsigned int )Condition & 255U;
#line 247
  if (_board == cond && cond != 0U) {
#line 248
    return (0);
  } else {

  }
#line 250
  cond = (unsigned int )Condition & 65280U;
#line 251
  cond = cond >> 8;
#line 252
  if ((_interface & cond) == 0U && cond != 7U) {
#line 253
    return (0);
  } else {

  }
#line 255
  cond = (unsigned int )Condition & 16711680U;
#line 256
  cond = cond >> 16;
#line 257
  if ((_platform & cond) == 0U && cond != 15U) {
#line 258
    return (0);
  } else {

  }
#line 259
  return (1);
}
}
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
static u32 Array_AGC_TAB_1T_8723A[320U]  = 
#line 266
  {      3192U,      2063597569U,      3192U,      2063663105U, 
        3192U,      2063728641U,      3192U,      2063794177U, 
        3192U,      2063859713U,      3192U,      2063925249U, 
        3192U,      2047213569U,      3192U,      2030501889U, 
        3192U,      2013790209U,      3192U,      1997078529U, 
        3192U,      1980366849U,      3192U,      1963655169U, 
        3192U,      1946943489U,      3192U,      1930231809U, 
        3192U,      1913520129U,      3192U,      1896808449U, 
        3192U,      1880096769U,      3192U,      1863385089U, 
        3192U,      1846673409U,      3192U,      1829961729U, 
        3192U,      1813250049U,      3192U,      1796538369U, 
        3192U,      1779826689U,      3192U,      1763115009U, 
        3192U,      1746403329U,      3192U,      1729691649U, 
        3192U,      1712979969U,      3192U,      1696268289U, 
        3192U,      1679556609U,      3192U,      1662844929U, 
        3192U,      1646133249U,      3192U,      1629421569U, 
        3192U,      1612709889U,      3192U,      1226899457U, 
        3192U,      1210187777U,      3192U,      1193476097U, 
        3192U,      1176764417U,      3192U,      1160052737U, 
        3192U,      1143341057U,      3192U,      1126629377U, 
        3192U,      1109917697U,      3192U,      1093206017U, 
        3192U,      1076494337U,      3192U,      640352257U, 
        3192U,      623640577U,      3192U,      606928897U, 
        3192U,      590217217U,      3192U,      573505537U, 
        3192U,      556793857U,      3192U,      540082177U, 
        3192U,      103940097U,      3192U,      87228417U, 
        3192U,      70516737U,      3192U,      53805057U, 
        3192U,      37093377U,      3192U,      20381697U, 
        3192U,      3670017U,      3192U,      3735553U, 
        3192U,      3801089U,      3192U,      3866625U, 
        3192U,      3932161U,      3192U,      3997697U, 
        3192U,      4063233U,      3192U,      4128769U, 
        3192U,      2067791873U,      3192U,      2067857409U, 
        3192U,      2067922945U,      3192U,      2067988481U, 
        3192U,      2068054017U,      3192U,      2068119553U, 
        3192U,      2051407873U,      3192U,      2034696193U, 
        3192U,      2017984513U,      3192U,      2001272833U, 
        3192U,      1984561153U,      3192U,      1967849473U, 
        3192U,      1951137793U,      3192U,      1934426113U, 
        3192U,      1917714433U,      3192U,      1901002753U, 
        3192U,      1884291073U,      3192U,      1867579393U, 
        3192U,      1850867713U,      3192U,      1834156033U, 
        3192U,      1817444353U,      3192U,      1800732673U, 
        3192U,      1784020993U,      3192U,      1767309313U, 
        3192U,      1750597633U,      3192U,      1733885953U, 
        3192U,      1717174273U,      3192U,      1700462593U, 
        3192U,      1683750913U,      3192U,      1667039233U, 
        3192U,      1650327553U,      3192U,      1633615873U, 
        3192U,      1616904193U,      3192U,      1231093761U, 
        3192U,      1214382081U,      3192U,      1197670401U, 
        3192U,      1180958721U,      3192U,      1164247041U, 
        3192U,      1147535361U,      3192U,      1130823681U, 
        3192U,      1114112001U,      3192U,      1097400321U, 
        3192U,      1080688641U,      3192U,      644546561U, 
        3192U,      627834881U,      3192U,      611123201U, 
        3192U,      594411521U,      3192U,      577699841U, 
        3192U,      560988161U,      3192U,      544276481U, 
        3192U,      108134401U,      3192U,      91422721U, 
        3192U,      74711041U,      3192U,      57999361U, 
        3192U,      41287681U,      3192U,      24576001U, 
        3192U,      7864321U,      3192U,      7929857U, 
        3192U,      7995393U,      3192U,      8060929U, 
        3192U,      8126465U,      3192U,      8192001U, 
        3192U,      8257537U,      3192U,      8323073U, 
        3192U,      939524126U,      3192U,      939589662U, 
        3192U,      939655198U,      3192U,      939720734U, 
        3192U,      939786270U,      3192U,      939851806U, 
        3192U,      939917342U,      3192U,      939982878U, 
        3192U,      940048414U,      3192U,      1007222814U, 
        3192U,      1040842782U,      3192U,      1074462750U, 
        3192U,      1141637150U,      3192U,      1208811550U, 
        3192U,      1275985950U,      3192U,      1343160350U, 
        3192U,      1376780318U,      3192U,      1443954718U, 
        3192U,      1511129118U,      3192U,      1578303518U, 
        3192U,      1611923486U,      3192U,      1611989022U, 
        3192U,      1612054558U,      3192U,      1645674526U, 
        3192U,      1645740062U,      3192U,      1645805598U, 
        3192U,      1645871134U,      3192U,      1645936670U, 
        3192U,      1646002206U,      3192U,      1646067742U, 
        3192U,      1646133278U,      3192U,      1646198814U};
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
void ODM_ReadAndConfig_AGC_TAB_1T_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 439
  platform = 4U;
#line 440
  interfaceValue = pDM_Odm->SupportInterface;
#line 441
  board = pDM_Odm->BoardType;
#line 442
  ArrayLen = 320U;
#line 443
  Array = (u32 *)(& Array_AGC_TAB_1T_8723A);
#line 445
  hex = (u32 )board;
#line 446
  hex = (u32 )((int )interfaceValue << 8) + hex;
#line 447
  hex = (u32 )((int )platform << 16) + hex;
#line 448
  hex = hex + 4278190080U;
#line 449
  i = 0U;
#line 449
  goto ldv_54232;
  ldv_54231: 
#line 450
  v1 = *(Array + (unsigned long )i);
#line 451
  v2 = *(Array + (unsigned long )(i + 1U));
#line 454
  if (v1 <= 3452816844U) {
#line 455
    odm_ConfigBB_AGC_8723A(pDM_Odm, v1, 4294967295U, v2);
#line 456
    goto ldv_54221;
  } else {
#line 458
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
#line 458
    if (tmp) {
#line 458
      tmp___0 = 0;
    } else {
#line 458
      tmp___0 = 1;
    }
#line 458
    if (tmp___0) {
#line 460
      i = i + 2U;
#line 460
      v1 = *(Array + (unsigned long )i);
#line 460
      v2 = *(Array + (unsigned long )(i + 1U));
#line 461
      goto ldv_54223;
      ldv_54222: 
#line 464
      i = i + 2U;
#line 464
      v1 = *(Array + (unsigned long )i);
#line 464
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54223: ;
#line 461
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 465
        goto ldv_54222;
      } else {

      }
#line 465
      i = i - 2U;
    } else {
#line 468
      i = i + 2U;
#line 468
      v1 = *(Array + (unsigned long )i);
#line 468
      v2 = *(Array + (unsigned long )(i + 1U));
#line 469
      goto ldv_54226;
      ldv_54225: 
#line 472
      odm_ConfigBB_AGC_8723A(pDM_Odm, v1, 4294967295U, v2);
#line 473
      i = i + 2U;
#line 473
      v1 = *(Array + (unsigned long )i);
#line 473
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54226: ;
#line 469
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 473
        goto ldv_54225;
      } else {

      }

#line 475
      goto ldv_54229;
      ldv_54228: 
#line 476
      i = i + 2U;
#line 476
      v1 = *(Array + (unsigned long )i);
#line 476
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54229: ;
#line 475
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 477
        goto ldv_54228;
      } else {

      }

    }
  }
  ldv_54221: 
#line 449
  i = i + 2U;
  ldv_54232: ;
#line 449
  if (i < ArrayLen) {
#line 451
    goto ldv_54231;
  } else {

  }

#line 456
  return;
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
static u32 Array_PHY_REG_1T_8723A[388U]  = 
#line 486
  {      2048U,      2147745792U,      2052U,      3U, 
        2056U,      64512U,      2060U,      10U, 
        2064U,      268440369U,      2068U,      34356496U, 
        2072U,      35652485U,      2076U,      0U, 
        2080U,      16777472U,      2084U,      3735556U, 
        2088U,      0U,      2092U,      0U, 
        2096U,      0U,      2100U,      0U, 
        2104U,      0U,      2108U,      0U, 
        2112U,      65536U,      2116U,      0U, 
        2120U,      0U,      2124U,      0U, 
        2128U,      0U,      2132U,      0U, 
        2136U,      1452955290U,      2140U,      1779108U, 
        2144U,      1727398160U,      2148U,      102695216U, 
        2152U,      0U,      2156U,      842150400U, 
        2160U,      117442400U,      2164U,      570441728U, 
        2168U,      2056U,      2172U,      0U, 
        2176U,      3221762160U,      2180U,      1237U, 
        2184U,      0U,      2188U,      3435135168U, 
        2192U,      2048U,      2196U,      4294967294U, 
        2200U,      1076895760U,      2204U,      7364688U, 
        2304U,      0U,      2308U,      35U, 
        2312U,      0U,      2316U,      2165444881U, 
        2560U,      13649864U,      2564U,      2164195340U, 
        2568U,      2357428992U,      2572U,      778572303U, 
        2576U,      2499853176U,      2580U,      286539816U, 
        2584U,      8917271U,      2588U,      2299793152U, 
        2592U,      437977088U,      2596U,      151917335U, 
        2600U,      516U,      2604U,      13828096U, 
        2672U,      270515968U,      2676U,      7U, 
        2680U,      2304U,      3072U,      1208425792U, 
        3076U,      60839441U,      3080U,      228U, 
        3084U,      1819044972U,      3088U,      142606336U, 
        3092U,      1073742080U,      3096U,      142606336U, 
        3100U,      1073742080U,      3104U,      0U, 
        3108U,      0U,      3112U,      0U, 
        3116U,      0U,      3120U,      1776921668U, 
        4279173407U,      43981U,      3124U,      1184256719U, 
        3452816845U,      52685U,      3124U,      1184256687U, 
        4279173407U,      57005U,      3128U,      1232689556U, 
        3132U,      177706780U,      3136U,      528236607U, 
        3140U,      65719U,      3144U,      3959554311U, 
        3148U,      8323967U,      3152U,      1767126048U, 
        3156U,      1136394388U,      3160U,      1767126048U, 
        3164U,      1128005780U,      3168U,      0U, 
        4279173407U,      43981U,      3172U,      1897301131U, 
        3452816845U,      52685U,      3172U,      1897038987U, 
        4279173407U,      57005U,      3176U,      1203768319U, 
        3180U,      54U,      3184U,      746520589U, 
        3188U,      25563355U,      3192U,      31U, 
        3196U,      12129810U,      3200U,      1073742080U, 
        3204U,      552992768U,      3208U,      1073742080U, 
        3212U,      538968064U,      3216U,      1185824U, 
        3220U,      0U,      3224U,      1185824U, 
        3228U,      32639U,      3232U,      0U, 
        3236U,      128U,      3240U,      0U, 
        3244U,      0U,      3248U,      0U, 
        3252U,      0U,      3256U,      0U, 
        3260U,      671088640U,      3264U,      0U, 
        3268U,      0U,      3272U,      0U, 
        3276U,      0U,      3280U,      0U, 
        3284U,      0U,      3288U,      1689396263U, 
        3292U,      7760178U,      3296U,      2236962U, 
        3300U,      0U,      3304U,      929317634U, 
        3308U,      798479372U,      3328U,      526144U, 
        3332U,      132097U,      3336U,      36991U, 
        3340U,      536936961U,      3344U,      2690855731U, 
        3348U,      859028547U,      3352U,      2056215403U, 
        3372U,      3432487285U,      3376U,      0U, 
        3380U,      2153807872U,      3384U,      0U, 
        3388U,      160403U,      3392U,      0U, 
        3396U,      0U,      3400U,      0U, 
        3404U,      0U,      3408U,      1681331210U, 
        3412U,      0U,      3416U,      0U, 
        3420U,      805511268U,      3424U,      1179901544U, 
        3428U,      72452668U,      3432U,      8449U, 
        3436U,      706747414U,      3440U,      403846702U, 
        3444U,      841753120U,      3448U,      932900U, 
        3584U,      707406378U,      3588U,      707406378U, 
        3592U,      59779626U,      3600U,      707406378U, 
        3604U,      707406378U,      3608U,      707406378U, 
        3612U,      707406378U,      3624U,      0U, 
        3632U,      268491807U,      3636U,      268471327U, 
        3640U,      34865410U,      3644U,      1746273474U, 
        3648U,      16808960U,      3652U,      16795648U, 
        3656U,      4211081216U,      3660U,      10449U, 
        3664U,      268491807U,      3668U,      268471327U, 
        3672U,      34865410U,      3676U,      672533765U, 
        3680U,      8U,      3688U,      1779108U, 
        3692U,      1662723488U,      3696U,      1662723488U, 
        3700U,      135996832U,      3704U,      135996832U, 
        3708U,      135996832U,      3712U,      135996832U, 
        3716U,      1662723488U,      3720U,      135996832U, 
        3724U,      1662723488U,      3792U,      1662723488U, 
        3796U,      1662723488U,      3800U,      1662723488U, 
        3804U,      1779104U,      3808U,      1779104U, 
        3820U,      1796941216U,      3860U,      3U, 
        3916U,      0U,      3840U,      768U};
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
void ODM_ReadAndConfig_PHY_REG_1T_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 685
  hex = 0U;
#line 686
  i = 0U;
#line 687
  platform = 4U;
#line 688
  interfaceValue = pDM_Odm->SupportInterface;
#line 689
  board = pDM_Odm->BoardType;
#line 690
  ArrayLen = 388U;
#line 691
  Array = (u32 *)(& Array_PHY_REG_1T_8723A);
#line 693
  hex = (u32 )board + hex;
#line 694
  hex = (u32 )((int )interfaceValue << 8) + hex;
#line 695
  hex = (u32 )((int )platform << 16) + hex;
#line 696
  hex = hex + 4278190080U;
#line 697
  i = 0U;
#line 697
  goto ldv_54258;
  ldv_54257: 
#line 698
  v1 = *(Array + (unsigned long )i);
#line 699
  v2 = *(Array + (unsigned long )(i + 1U));
#line 702
  if (v1 <= 3452816844U) {
#line 703
    odm_ConfigBB_PHY_8723A(pDM_Odm, v1, 4294967295U, v2);
#line 704
    goto ldv_54247;
  } else {
#line 706
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
#line 706
    if (tmp) {
#line 706
      tmp___0 = 0;
    } else {
#line 706
      tmp___0 = 1;
    }
#line 706
    if (tmp___0) {
#line 708
      i = i + 2U;
#line 708
      v1 = *(Array + (unsigned long )i);
#line 708
      v2 = *(Array + (unsigned long )(i + 1U));
#line 709
      goto ldv_54249;
      ldv_54248: 
#line 712
      i = i + 2U;
#line 712
      v1 = *(Array + (unsigned long )i);
#line 712
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54249: ;
#line 709
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 713
        goto ldv_54248;
      } else {

      }
#line 713
      i = i - 2U;
    } else {
#line 716
      i = i + 2U;
#line 716
      v1 = *(Array + (unsigned long )i);
#line 716
      v2 = *(Array + (unsigned long )(i + 1U));
#line 717
      goto ldv_54252;
      ldv_54251: 
#line 720
      odm_ConfigBB_PHY_8723A(pDM_Odm, v1, 4294967295U, v2);
#line 721
      i = i + 2U;
#line 721
      v1 = *(Array + (unsigned long )i);
#line 721
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54252: ;
#line 717
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 721
        goto ldv_54251;
      } else {

      }

#line 723
      goto ldv_54255;
      ldv_54254: 
#line 724
      i = i + 2U;
#line 724
      v1 = *(Array + (unsigned long )i);
#line 724
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54255: ;
#line 723
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 725
        goto ldv_54254;
      } else {

      }

    }
  }
  ldv_54247: 
#line 697
  i = i + 2U;
  ldv_54258: ;
#line 697
  if (i < ArrayLen) {
#line 699
    goto ldv_54257;
  } else {

  }

#line 704
  return;
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
static u32 Array_PHY_REG_MP_8723A[4U]  = {      3120U,      1776921674U,      3132U,      177706776U};
#line 739 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
void ODM_ReadAndConfig_PHY_REG_MP_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 741
  hex = 0U;
#line 742
  i = 0U;
#line 743
  platform = 4U;
#line 744
  interfaceValue = pDM_Odm->SupportInterface;
#line 745
  board = pDM_Odm->BoardType;
#line 746
  ArrayLen = 4U;
#line 747
  Array = (u32 *)(& Array_PHY_REG_MP_8723A);
#line 749
  hex = (u32 )board + hex;
#line 750
  hex = (u32 )((int )interfaceValue << 8) + hex;
#line 751
  hex = (u32 )((int )platform << 16) + hex;
#line 752
  hex = hex + 4278190080U;
#line 753
  i = 0U;
#line 753
  goto ldv_54284;
  ldv_54283: 
#line 754
  v1 = *(Array + (unsigned long )i);
#line 755
  v2 = *(Array + (unsigned long )(i + 1U));
#line 758
  if (v1 <= 3452816844U) {
#line 759
    odm_ConfigBB_PHY_8723A(pDM_Odm, v1, 4294967295U, v2);
#line 760
    goto ldv_54273;
  } else {
#line 762
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
#line 762
    if (tmp) {
#line 762
      tmp___0 = 0;
    } else {
#line 762
      tmp___0 = 1;
    }
#line 762
    if (tmp___0) {
#line 764
      i = i + 2U;
#line 764
      v1 = *(Array + (unsigned long )i);
#line 764
      v2 = *(Array + (unsigned long )(i + 1U));
#line 765
      goto ldv_54275;
      ldv_54274: 
#line 768
      i = i + 2U;
#line 768
      v1 = *(Array + (unsigned long )i);
#line 768
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54275: ;
#line 765
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 769
        goto ldv_54274;
      } else {

      }
#line 769
      i = i - 2U;
    } else {
#line 772
      i = i + 2U;
#line 772
      v1 = *(Array + (unsigned long )i);
#line 772
      v2 = *(Array + (unsigned long )(i + 1U));
#line 773
      goto ldv_54278;
      ldv_54277: 
#line 776
      odm_ConfigBB_PHY_8723A(pDM_Odm, v1, 4294967295U, v2);
#line 777
      i = i + 2U;
#line 777
      v1 = *(Array + (unsigned long )i);
#line 777
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54278: ;
#line 773
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 777
        goto ldv_54277;
      } else {

      }

#line 779
      goto ldv_54281;
      ldv_54280: 
#line 780
      i = i + 2U;
#line 780
      v1 = *(Array + (unsigned long )i);
#line 780
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54281: ;
#line 779
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 781
        goto ldv_54280;
      } else {

      }

    }
  }
  ldv_54273: 
#line 753
  i = i + 2U;
  ldv_54284: ;
#line 753
  if (i < ArrayLen) {
#line 755
    goto ldv_54283;
  } else {

  }

#line 760
  return;
}
}
#line 790 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
static u32 Array_PHY_REG_PG_8723A[336U]  = 
#line 790
  {      3584U,      4294967295U,      168561676U,      3588U, 
        4294967295U,      33818120U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      168561934U,      3604U, 
        4294967295U,      33818120U,      3608U,      4294967295U, 
        168561934U,      3612U,      4294967295U,      33818120U, 
        2096U,      4294967295U,      168561676U,      2100U, 
        4294967295U,      33818120U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      168561934U,      2120U, 
        4294967295U,      33818120U,      2124U,      4294967295U, 
        168561934U,      2152U,      4294967295U,      33818120U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      67372036U,      3588U, 
        4294967295U,      131588U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      101058054U,      3604U, 
        4294967295U,      132102U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      67372036U,      2100U, 
        4294967295U,      131588U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      101058054U,      2120U, 
        4294967295U,      132102U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      67372036U,      3588U, 
        4294967295U,      131588U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      67372036U,      2100U, 
        4294967295U,      131588U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U, 
        3584U,      4294967295U,      0U,      3588U, 
        4294967295U,      0U,      3592U,      65280U, 
        0U,      2156U,      4294967040U,      0U, 
        3600U,      4294967295U,      0U,      3604U, 
        4294967295U,      0U,      3608U,      4294967295U, 
        0U,      3612U,      4294967295U,      0U, 
        2096U,      4294967295U,      0U,      2100U, 
        4294967295U,      0U,      2104U,      4294967040U, 
        0U,      2156U,      255U,      0U, 
        2108U,      4294967295U,      0U,      2120U, 
        4294967295U,      0U,      2124U,      4294967295U, 
        0U,      2152U,      4294967295U,      0U};
#line 905 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
void ODM_ReadAndConfig_PHY_REG_PG_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  u32 v3 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 907
  hex = 0U;
#line 908
  i = 0U;
#line 909
  platform = 4U;
#line 910
  interfaceValue = pDM_Odm->SupportInterface;
#line 911
  board = pDM_Odm->BoardType;
#line 912
  ArrayLen = 336U;
#line 913
  Array = (u32 *)(& Array_PHY_REG_PG_8723A);
#line 915
  hex = (u32 )board + hex;
#line 916
  hex = (u32 )((int )interfaceValue << 8) + hex;
#line 917
  hex = (u32 )((int )platform << 16) + hex;
#line 918
  hex = hex + 4278190080U;
#line 919
  i = 0U;
#line 919
  goto ldv_54305;
  ldv_54304: 
#line 920
  v1 = *(Array + (unsigned long )i);
#line 921
  v2 = *(Array + (unsigned long )(i + 1U));
#line 922
  v3 = *(Array + (unsigned long )(i + 2U));
#line 925
  if (v1 <= 3452816844U) {
#line 926
    odm_ConfigBB_PHY_REG_PG_8723A(pDM_Odm, v1, v2, v3);
#line 927
    goto ldv_54300;
  } else {
#line 929
    tmp = CheckCondition(*(Array + (unsigned long )i), hex);
#line 929
    if (tmp) {
#line 929
      tmp___0 = 0;
    } else {
#line 929
      tmp___0 = 1;
    }
#line 929
    if (tmp___0) {
#line 931
      i = i + 2U;
#line 932
      v1 = *(Array + (unsigned long )i);
#line 933
      v2 = *(Array + (unsigned long )(i + 1U));
#line 934
      v3 = *(Array + (unsigned long )(i + 2U));
#line 935
      goto ldv_54302;
      ldv_54301: 
#line 936
      i = i + 3U;
#line 937
      v1 = *(Array + (unsigned long )i);
#line 938
      v2 = *(Array + (unsigned long )(i + 1U));
#line 939
      v3 = *(Array + (unsigned long )(i + 1U));
      ldv_54302: ;
#line 935
      if (v2 != 57005U) {
#line 937
        goto ldv_54301;
      } else {

      }

    } else {

    }
  }
  ldv_54300: 
#line 919
  i = i + 3U;
  ldv_54305: ;
#line 919
  if (i < ArrayLen) {
#line 921
    goto ldv_54304;
  } else {

  }

#line 926
  return;
}
}
#line 1073 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
void *ldv_kmem_cache_alloc_1124(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1076
  ldv_check_alloc_flags(flags);
#line 1078
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1079
  return ((void *)0);
}
}
#line 1117 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
int ldv_pskb_expand_head_1130(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1120
  ldv_check_alloc_flags(flags);
#line 1122
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1122
  return (tmp);
}
}
#line 1133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
struct sk_buff *ldv_skb_clone_1132(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1136
  ldv_check_alloc_flags(flags);
#line 1138
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1138
  return (tmp);
}
}
#line 1149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
struct sk_buff *ldv_skb_copy_1134(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1152
  ldv_check_alloc_flags(flags);
#line 1154
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1154
  return (tmp);
}
}
#line 1157 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1135(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1160
  ldv_check_alloc_flags(flags);
#line 1162
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1162
  return (tmp);
}
}
#line 1165 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1136(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1168
  ldv_check_alloc_flags(flags);
#line 1170
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1170
  return (tmp);
}
}
#line 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1137(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1176
  ldv_check_alloc_flags(flags);
#line 1178
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1178
  return (tmp);
}
}
#line 1181 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
int ldv_pskb_expand_head_1138(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1184
  ldv_check_alloc_flags(flags);
#line 1186
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1186
  return (tmp);
}
}
#line 1189 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
int ldv_pskb_expand_head_1139(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1192
  ldv_check_alloc_flags(flags);
#line 1194
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1194
  return (tmp);
}
}
#line 1197 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_BB.o.c.prepared"
struct sk_buff *ldv_skb_clone_1140(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1200
  ldv_check_alloc_flags(flags);
#line 1202
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1202
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1166(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1174(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1182(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1176(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1180(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1181(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1177(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1178(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1179(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 24 "drivers/staging/rtl8723au/include/HalHWImg8723A_MAC.h"
void ODM_ReadAndConfig_MAC_REG_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 25 "drivers/staging/rtl8723au/include/odm_RegConfig8723A.h"
void odm_ConfigMAC_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u8 Data ) ;
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
static bool CheckCondition___0(u32 const   Condition , u32 const   Hex ) 
{ 
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;

  {
#line 238
  _board = (unsigned int )Hex & 255U;
#line 239
  _interface = ((unsigned int )Hex & 65280U) >> 8;
#line 240
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
#line 241
  cond = Condition;
#line 243
  if ((unsigned int )Condition == 3452816845U) {
#line 244
    return (1);
  } else {

  }
#line 246
  cond = (unsigned int )Condition & 255U;
#line 247
  if (_board == cond && cond != 0U) {
#line 248
    return (0);
  } else {

  }
#line 250
  cond = (unsigned int )Condition & 65280U;
#line 251
  cond = cond >> 8;
#line 252
  if ((_interface & cond) == 0U && cond != 7U) {
#line 253
    return (0);
  } else {

  }
#line 255
  cond = (unsigned int )Condition & 16711680U;
#line 256
  cond = cond >> 16;
#line 257
  if ((_platform & cond) == 0U && cond != 15U) {
#line 258
    return (0);
  } else {

  }
#line 259
  return (1);
}
}
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
static u32 Array_MAC_REG_8723A[172U]  = 
#line 266
  {      1056U,      128U,      1059U,      0U, 
        1072U,      0U,      1073U,      0U, 
        1074U,      0U,      1075U,      1U, 
        1076U,      4U,      1077U,      5U, 
        1078U,      6U,      1079U,      7U, 
        1080U,      0U,      1081U,      0U, 
        1082U,      0U,      1083U,      1U, 
        1084U,      4U,      1085U,      5U, 
        1086U,      6U,      1087U,      7U, 
        1088U,      93U,      1089U,      1U, 
        1090U,      0U,      1092U,      21U, 
        1093U,      240U,      1094U,      15U, 
        1095U,      0U,      1112U,      65U, 
        1113U,      168U,      1114U,      114U, 
        1115U,      185U,      1120U,      102U, 
        1121U,      102U,      1122U,      8U, 
        1123U,      3U,      1224U,      255U, 
        1225U,      8U,      1228U,      255U, 
        1229U,      255U,      1230U,      1U, 
        1280U,      38U,      1281U,      162U, 
        1282U,      47U,      1283U,      0U, 
        1284U,      40U,      1285U,      163U, 
        1286U,      94U,      1287U,      0U, 
        1288U,      43U,      1289U,      164U, 
        1290U,      94U,      1291U,      0U, 
        1292U,      79U,      1293U,      164U, 
        1294U,      0U,      1295U,      0U, 
        1298U,      28U,      1300U,      10U, 
        1301U,      16U,      1302U,      10U, 
        1303U,      16U,      1306U,      22U, 
        1316U,      15U,      1317U,      79U, 
        1350U,      64U,      1351U,      0U, 
        1360U,      16U,      1361U,      16U, 
        1369U,      2U,      1370U,      2U, 
        1373U,      255U,      1541U,      48U, 
        1544U,      14U,      1545U,      42U, 
        1618U,      32U,      1596U,      10U, 
        1597U,      10U,      1598U,      14U, 
        1599U,      14U,      1646U,      5U, 
        1792U,      33U,      1793U,      67U, 
        1794U,      101U,      1795U,      135U, 
        1800U,      33U,      1801U,      67U, 
        1802U,      101U,      1803U,      135U};
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
void ODM_ReadAndConfig_MAC_REG_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 362
  hex = 0U;
#line 363
  i = 0U;
#line 364
  platform = 4U;
#line 365
  interfaceValue = pDM_Odm->SupportInterface;
#line 366
  board = pDM_Odm->BoardType;
#line 367
  ArrayLen = 172U;
#line 368
  Array = (u32 *)(& Array_MAC_REG_8723A);
#line 370
  hex = (u32 )board + hex;
#line 371
  hex = (u32 )((int )interfaceValue << 8) + hex;
#line 372
  hex = (u32 )((int )platform << 16) + hex;
#line 373
  hex = hex + 4278190080U;
#line 374
  i = 0U;
#line 374
  goto ldv_54232;
  ldv_54231: 
#line 375
  v1 = *(Array + (unsigned long )i);
#line 376
  v2 = *(Array + (unsigned long )(i + 1U));
#line 379
  if (v1 <= 3452816844U) {
#line 380
    odm_ConfigMAC_8723A(pDM_Odm, v1, (int )((unsigned char )v2));
#line 381
    goto ldv_54221;
  } else {
#line 383
    tmp = CheckCondition___0(*(Array + (unsigned long )i), hex);
#line 383
    if (tmp) {
#line 383
      tmp___0 = 0;
    } else {
#line 383
      tmp___0 = 1;
    }
#line 383
    if (tmp___0) {
#line 385
      i = i + 2U;
#line 385
      v1 = *(Array + (unsigned long )i);
#line 385
      v2 = *(Array + (unsigned long )(i + 1U));
#line 386
      goto ldv_54223;
      ldv_54222: 
#line 389
      i = i + 2U;
#line 389
      v1 = *(Array + (unsigned long )i);
#line 389
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54223: ;
#line 386
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 390
        goto ldv_54222;
      } else {

      }
#line 390
      i = i - 2U;
    } else {
#line 393
      i = i + 2U;
#line 393
      v1 = *(Array + (unsigned long )i);
#line 393
      v2 = *(Array + (unsigned long )(i + 1U));
#line 394
      goto ldv_54226;
      ldv_54225: 
#line 397
      odm_ConfigMAC_8723A(pDM_Odm, v1, (int )((unsigned char )v2));
#line 398
      i = i + 2U;
#line 398
      v1 = *(Array + (unsigned long )i);
#line 398
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54226: ;
#line 394
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 398
        goto ldv_54225;
      } else {

      }

#line 401
      goto ldv_54229;
      ldv_54228: 
#line 402
      i = i + 2U;
#line 402
      v1 = *(Array + (unsigned long )i);
#line 402
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54229: ;
#line 401
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 403
        goto ldv_54228;
      } else {

      }

    }
  }
  ldv_54221: 
#line 374
  i = i + 2U;
  ldv_54232: ;
#line 374
  if (i < ArrayLen) {
#line 376
    goto ldv_54231;
  } else {

  }

#line 381
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
void *ldv_kmem_cache_alloc_1166(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 538
  ldv_check_alloc_flags(flags);
#line 540
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 541
  return ((void *)0);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
int ldv_pskb_expand_head_1172(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 582
  ldv_check_alloc_flags(flags);
#line 584
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 584
  return (tmp);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
struct sk_buff *ldv_skb_clone_1174(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 598
  ldv_check_alloc_flags(flags);
#line 600
  tmp = skb_clone(ldv_func_arg1, flags);
#line 600
  return (tmp);
}
}
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
struct sk_buff *ldv_skb_copy_1176(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 614
  ldv_check_alloc_flags(flags);
#line 616
  tmp = skb_copy(ldv_func_arg1, flags);
#line 616
  return (tmp);
}
}
#line 619 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1177(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 622
  ldv_check_alloc_flags(flags);
#line 624
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 624
  return (tmp);
}
}
#line 627 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1178(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 630
  ldv_check_alloc_flags(flags);
#line 632
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 632
  return (tmp);
}
}
#line 635 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1179(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 638
  ldv_check_alloc_flags(flags);
#line 640
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 640
  return (tmp);
}
}
#line 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
int ldv_pskb_expand_head_1180(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 646
  ldv_check_alloc_flags(flags);
#line 648
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 648
  return (tmp);
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
int ldv_pskb_expand_head_1181(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 654
  ldv_check_alloc_flags(flags);
#line 656
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 656
  return (tmp);
}
}
#line 659 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_MAC.o.c.prepared"
struct sk_buff *ldv_skb_clone_1182(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 662
  ldv_check_alloc_flags(flags);
#line 664
  tmp = skb_clone(ldv_func_arg1, flags);
#line 664
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1208(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1216(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1224(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1218(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1214(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1222(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1223(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1219(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1220(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1221(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 23 "drivers/staging/rtl8723au/include/HalHWImg8723A_RF.h"
void ODM_ReadAndConfig_RadioA_1T_8723A(struct dm_odm_t *pDM_Odm ) ;
#line 21 "drivers/staging/rtl8723au/include/odm_RegConfig8723A.h"
void odm_ConfigRF_RadioA_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data ) ;
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
static bool CheckCondition___1(u32 const   Condition , u32 const   Hex ) 
{ 
  u32 _board ;
  u32 _interface ;
  u32 _platform ;
  u32 cond ;

  {
#line 238
  _board = (unsigned int )Hex & 255U;
#line 239
  _interface = ((unsigned int )Hex & 65280U) >> 8;
#line 240
  _platform = ((unsigned int )Hex & 16711680U) >> 16;
#line 241
  cond = Condition;
#line 243
  if ((unsigned int )Condition == 3452816845U) {
#line 244
    return (1);
  } else {

  }
#line 246
  cond = (unsigned int )Condition & 255U;
#line 247
  if (_board == cond && cond != 0U) {
#line 248
    return (0);
  } else {

  }
#line 250
  cond = (unsigned int )Condition & 65280U;
#line 251
  cond = cond >> 8;
#line 252
  if ((_interface & cond) == 0U && cond != 7U) {
#line 253
    return (0);
  } else {

  }
#line 255
  cond = (unsigned int )Condition & 16711680U;
#line 256
  cond = cond >> 16;
#line 257
  if ((_platform & cond) == 0U && cond != 15U) {
#line 258
    return (0);
  } else {

  }
#line 259
  return (1);
}
}
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
static u32 Array_RadioA_1T_8723A[312U]  = 
#line 266
  {      0U,      196953U,      1U,      201348U, 
        2U,      622592U,      4279173407U,      43981U, 
        3U,      101475U,      3452816845U,      52685U, 
        3U,      236643U,      4279173407U,      57005U, 
        4U,      135399U,      9U,      132175U, 
        10U,      107505U,      11U,      83847U, 
        12U,      562942U,      13U,      57388U, 
        14U,      236775U,      15U,      1105U, 
        25U,      0U,      26U,      197461U, 
        27U,      395776U,      28U,      1033080U, 
        29U,      660048U,      30U,      591U, 
        31U,      0U,      32U,      46612U, 
        33U,      442368U,      34U,      0U, 
        35U,      5464U,      36U,      96U, 
        37U,      1155U,      38U,      323584U, 
        39U,      968665U,      40U,      358192U, 
        41U,      18307U,      42U,      1U, 
        43U,      135988U,      42U,      0U, 
        43U,      84U,      42U,      1U, 
        43U,      2056U,      43U,      340787U, 
        44U,      12U,      42U,      2U, 
        43U,      2056U,      43U,      373555U, 
        44U,      13U,      42U,      3U, 
        43U,      2056U,      43U,      406323U, 
        44U,      13U,      42U,      4U, 
        43U,      2056U,      43U,      439091U, 
        44U,      13U,      42U,      5U, 
        43U,      2056U,      43U,      471859U, 
        44U,      13U,      42U,      6U, 
        43U,      1801U,      43U,      373555U, 
        44U,      13U,      42U,      7U, 
        43U,      1801U,      43U,      406323U, 
        44U,      13U,      42U,      8U, 
        43U,      1546U,      43U,      308019U, 
        44U,      13U,      42U,      9U, 
        43U,      1546U,      43U,      340787U, 
        44U,      13U,      42U,      10U, 
        43U,      1546U,      43U,      373555U, 
        44U,      13U,      42U,      11U, 
        43U,      1546U,      43U,      406323U, 
        44U,      13U,      42U,      12U, 
        43U,      1546U,      43U,      439091U, 
        44U,      13U,      42U,      13U, 
        43U,      1546U,      43U,      471859U, 
        44U,      13U,      42U,      14U, 
        43U,      1291U,      43U,      419430U, 
        44U,      26U,      42U,      917504U, 
        16U,      262159U,      17U,      930300U, 
        16U,      393231U,      17U,      1047032U, 
        16U,      131087U,      17U,      132089U, 
        16U,      196623U,      17U,      1045760U, 
        16U,      0U,      17U,      0U, 
        16U,      524303U,      17U,      258304U, 
        16U,      589839U,      17U,      143616U, 
        18U,      204800U,      18U,      462848U, 
        18U,      720896U,      18U,      1032192U, 
        19U,      165811U,      19U,      148663U, 
        19U,      132267U,      19U,      115871U, 
        19U,      99475U,      19U,      82587U, 
        19U,      66201U,      19U,      49820U, 
        19U,      33184U,      19U,      16556U, 
        19U,      32U,      20U,      103500U, 
        20U,      365636U,      20U,      627788U, 
        20U,      889924U,      4279173407U,      43981U, 
        21U,      62500U,      21U,      324644U, 
        21U,      586788U,      21U,      848932U, 
        3452816845U,      52685U,      21U,      62580U, 
        21U,      324727U,      21U,      586837U, 
        21U,      848981U,      4279173407U,      57005U, 
        22U,      825U,      22U,      262969U, 
        22U,      525113U,      4279173407U,      43981U, 
        22U,      787286U,      3452816845U,      52685U, 
        22U,      787302U,      4279173407U,      57005U, 
        0U,      65881U,      24U,      62465U, 
        254U,      0U,      254U,      0U, 
        31U,      3U,      254U,      0U, 
        254U,      0U,      30U,      583U, 
        31U,      0U,      0U,      196953U};
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
void ODM_ReadAndConfig_RadioA_1T_8723A(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 hex ;
  u32 i ;
  u8 platform ;
  u8 interfaceValue ;
  u8 board ;
  u32 ArrayLen ;
  u32 *Array ;
  u32 v1 ;
  u32 v2 ;
  bool tmp ;
  int tmp___0 ;

  {
#line 432
  hex = 0U;
#line 433
  i = 0U;
#line 434
  platform = 4U;
#line 435
  interfaceValue = pDM_Odm->SupportInterface;
#line 436
  board = pDM_Odm->BoardType;
#line 437
  ArrayLen = 312U;
#line 438
  Array = (u32 *)(& Array_RadioA_1T_8723A);
#line 440
  hex = (u32 )board + hex;
#line 441
  hex = (u32 )((int )interfaceValue << 8) + hex;
#line 442
  hex = (u32 )((int )platform << 16) + hex;
#line 443
  hex = hex + 4278190080U;
#line 445
  i = 0U;
#line 445
  goto ldv_54232;
  ldv_54231: 
#line 446
  v1 = *(Array + (unsigned long )i);
#line 447
  v2 = *(Array + (unsigned long )(i + 1U));
#line 450
  if (v1 <= 3452816844U) {
#line 451
    odm_ConfigRF_RadioA_8723A(pDM_Odm, v1, v2);
#line 452
    goto ldv_54221;
  } else {
#line 454
    tmp = CheckCondition___1(*(Array + (unsigned long )i), hex);
#line 454
    if (tmp) {
#line 454
      tmp___0 = 0;
    } else {
#line 454
      tmp___0 = 1;
    }
#line 454
    if (tmp___0) {
#line 456
      i = i + 2U;
#line 456
      v1 = *(Array + (unsigned long )i);
#line 456
      v2 = *(Array + (unsigned long )(i + 1U));
#line 457
      goto ldv_54223;
      ldv_54222: 
#line 460
      i = i + 2U;
#line 460
      v1 = *(Array + (unsigned long )i);
#line 460
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54223: ;
#line 457
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 461
        goto ldv_54222;
      } else {

      }
#line 461
      i = i - 2U;
    } else {
#line 464
      i = i + 2U;
#line 464
      v1 = *(Array + (unsigned long )i);
#line 464
      v2 = *(Array + (unsigned long )(i + 1U));
#line 465
      goto ldv_54226;
      ldv_54225: 
#line 468
      odm_ConfigRF_RadioA_8723A(pDM_Odm, v1, v2);
#line 469
      i = i + 2U;
#line 469
      v1 = *(Array + (unsigned long )i);
#line 469
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54226: ;
#line 465
      if (((v2 != 57005U && v2 != 52719U) && v2 != 52685U) && ArrayLen - 2U > i) {
#line 469
        goto ldv_54225;
      } else {

      }

#line 472
      goto ldv_54229;
      ldv_54228: 
#line 473
      i = i + 2U;
#line 473
      v1 = *(Array + (unsigned long )i);
#line 473
      v2 = *(Array + (unsigned long )(i + 1U));
      ldv_54229: ;
#line 472
      if (v2 != 57005U && ArrayLen - 2U > i) {
#line 474
        goto ldv_54228;
      } else {

      }

    }
  }
  ldv_54221: 
#line 445
  i = i + 2U;
  ldv_54232: ;
#line 445
  if (i < ArrayLen) {
#line 447
    goto ldv_54231;
  } else {

  }

#line 452
  return;
}
}
#line 606 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
void *ldv_kmem_cache_alloc_1208(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 609
  ldv_check_alloc_flags(flags);
#line 611
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 612
  return ((void *)0);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
int ldv_pskb_expand_head_1214(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 653
  ldv_check_alloc_flags(flags);
#line 655
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 655
  return (tmp);
}
}
#line 666 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
struct sk_buff *ldv_skb_clone_1216(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 669
  ldv_check_alloc_flags(flags);
#line 671
  tmp = skb_clone(ldv_func_arg1, flags);
#line 671
  return (tmp);
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
struct sk_buff *ldv_skb_copy_1218(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 685
  ldv_check_alloc_flags(flags);
#line 687
  tmp = skb_copy(ldv_func_arg1, flags);
#line 687
  return (tmp);
}
}
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1219(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 693
  ldv_check_alloc_flags(flags);
#line 695
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 695
  return (tmp);
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1220(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 701
  ldv_check_alloc_flags(flags);
#line 703
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 703
  return (tmp);
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1221(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 709
  ldv_check_alloc_flags(flags);
#line 711
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 711
  return (tmp);
}
}
#line 714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
int ldv_pskb_expand_head_1222(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 717
  ldv_check_alloc_flags(flags);
#line 719
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 719
  return (tmp);
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
int ldv_pskb_expand_head_1223(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 725
  ldv_check_alloc_flags(flags);
#line 727
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 727
  return (tmp);
}
}
#line 730 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalHWImg8723A_RF.o.c.prepared"
struct sk_buff *ldv_skb_clone_1224(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 733
  ldv_check_alloc_flags(flags);
#line 735
  tmp = skb_clone(ldv_func_arg1, flags);
#line 735
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1250(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 8 "include/asm-generic/delay.h"
extern void __udelay(unsigned long  ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1258(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1266(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1260(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1256(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1264(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1265(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1261(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1262(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1263(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 123 "drivers/staging/rtl8723au/include/HalPwrSeqCmd.h"
u8 HalPwrSeqCmdParsing23a(struct rtw_adapter *padapter , u8 CutVersion , u8 FabVersion ,
                          u8 InterfaceType , struct wlan_pwr_cfg *PwrSeqCmd ) ;
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
u8 HalPwrSeqCmdParsing23a(struct rtw_adapter *padapter , u8 CutVersion , u8 FabVersion ,
                          u8 InterfaceType , struct wlan_pwr_cfg *PwrSeqCmd ) 
{ 
  struct wlan_pwr_cfg PwrCfgCmd ;
  u8 bPollingBit ;
  u32 AryIdx ;
  u8 value ;
  u32 offset ;
  u32 pollingCount ;
  u32 maxPollingCnt ;
  u32 tmp ;

  {
#line 268
  PwrCfgCmd.offset = 0U;
#line 268
  PwrCfgCmd.cut_msk = (unsigned char)0;
#line 268
  PwrCfgCmd.fab_msk = (unsigned char)0;
#line 268
  PwrCfgCmd.interface_msk = (unsigned char)0;
#line 268
  PwrCfgCmd.base = (unsigned char)0;
#line 268
  PwrCfgCmd.cmd = (unsigned char)0;
#line 268
  PwrCfgCmd.msk = (unsigned char)0;
#line 268
  PwrCfgCmd.value = (unsigned char)0;
#line 269
  bPollingBit = 0U;
#line 270
  AryIdx = 0U;
#line 271
  value = 0U;
#line 272
  offset = 0U;
#line 273
  pollingCount = 0U;
#line 274
  maxPollingCnt = 5000U;
  ldv_51491: 
#line 277
  PwrCfgCmd = *(PwrSeqCmd + (unsigned long )AryIdx);
#line 279
  if (GlobalDebugLevel23A > 6U) {
#line 279
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 279
    printk("\016HalPwrSeqCmdParsing23a: offset(%#x) cut_msk(%#x) fab_msk(%#x) interface_msk(%#x) base(%#x) cmd(%#x) msk(%#x) value(%#x)\n",
           (int )PwrCfgCmd.offset, (int )PwrCfgCmd.cut_msk, (int )PwrCfgCmd.fab_msk,
           (int )PwrCfgCmd.interface_msk, (int )PwrCfgCmd.base, (int )PwrCfgCmd.cmd,
           (int )PwrCfgCmd.msk, (int )PwrCfgCmd.value);
  } else {

  }
#line 294
  if ((((int )PwrCfgCmd.fab_msk & (int )FabVersion) != 0 && (unsigned int )((int )PwrCfgCmd.cut_msk & (int )CutVersion) != 0U) && ((int )PwrCfgCmd.interface_msk & (int )InterfaceType) != 0) {
#line 297
    switch ((int )PwrCfgCmd.cmd) {
    case 0: ;
#line 299
    if (GlobalDebugLevel23A > 6U) {
#line 299
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 299
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_READ\n");
    } else {

    }
#line 302
    goto ldv_51483;
    case 1: ;
#line 305
    if (GlobalDebugLevel23A > 6U) {
#line 305
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 305
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_WRITE\n");
    } else {

    }
#line 308
    offset = (u32 )PwrCfgCmd.offset;
#line 311
    value = rtl8723au_read8(padapter, offset);
#line 313
    value = (u8 )(~ ((int )((signed char )PwrCfgCmd.msk)) & (int )((signed char )value));
#line 314
    value = (u8 )(((int )PwrCfgCmd.value & (int )PwrCfgCmd.msk) | (int )value);
#line 318
    rtl8723au_write8(padapter, offset, (int )value);
#line 319
    goto ldv_51483;
    case 2: ;
#line 322
    if (GlobalDebugLevel23A > 6U) {
#line 322
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 322
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_POLLING\n");
    } else {

    }
#line 326
    bPollingBit = 0U;
#line 327
    offset = (u32 )PwrCfgCmd.offset;
    ldv_51486: 
#line 329
    value = rtl8723au_read8(padapter, offset);
#line 332
    value = (u8 )((int )PwrCfgCmd.msk & (int )value);
#line 333
    if (((int )PwrCfgCmd.value & (int )PwrCfgCmd.msk) == (int )value) {
#line 336
      bPollingBit = 1U;
    } else {
#line 338
      __const_udelay(42950UL);
    }
#line 340
    tmp = pollingCount;
#line 340
    pollingCount = pollingCount + 1U;
#line 340
    if (tmp > maxPollingCnt) {
#line 341
      if (GlobalDebugLevel23A > 3U) {
#line 341
        printk("\016RTL8723AU: Fail to polling Offset[%#x]\n", offset);
      } else {

      }
#line 344
      return (0U);
    } else {

    }
#line 346
    if ((unsigned int )bPollingBit == 0U) {
#line 348
      goto ldv_51486;
    } else {

    }

#line 348
    goto ldv_51483;
    case 3: ;
#line 351
    if (GlobalDebugLevel23A > 6U) {
#line 351
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 351
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_DELAY\n");
    } else {

    }
#line 354
    if ((unsigned int )PwrCfgCmd.value == 0U) {
#line 356
      __udelay((unsigned long )PwrCfgCmd.offset);
    } else {
#line 358
      __udelay((unsigned long )((int )PwrCfgCmd.offset * 1000));
    }
#line 360
    goto ldv_51483;
    case 4: ;
#line 365
    if (GlobalDebugLevel23A > 6U) {
#line 365
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 365
      printk("\016HalPwrSeqCmdParsing23a: PWR_CMD_END\n");
    } else {

    }
#line 368
    return (1U);
    default: ;
#line 372
    if (GlobalDebugLevel23A > 3U) {
#line 372
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
#line 372
      printk("\016HalPwrSeqCmdParsing23a: Unknown CMD!!\n");
    } else {

    }
#line 375
    goto ldv_51483;
    }
    ldv_51483: ;
  } else {

  }
#line 379
  AryIdx = AryIdx + 1U;
#line 380
  goto ldv_51491;
#line 382
  return (1U);
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
void *ldv_kmem_cache_alloc_1250(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 515
  ldv_check_alloc_flags(flags);
#line 517
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 518
  return ((void *)0);
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
int ldv_pskb_expand_head_1256(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 559
  ldv_check_alloc_flags(flags);
#line 561
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 561
  return (tmp);
}
}
#line 572 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
struct sk_buff *ldv_skb_clone_1258(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 575
  ldv_check_alloc_flags(flags);
#line 577
  tmp = skb_clone(ldv_func_arg1, flags);
#line 577
  return (tmp);
}
}
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
struct sk_buff *ldv_skb_copy_1260(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 591
  ldv_check_alloc_flags(flags);
#line 593
  tmp = skb_copy(ldv_func_arg1, flags);
#line 593
  return (tmp);
}
}
#line 596 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1261(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 599
  ldv_check_alloc_flags(flags);
#line 601
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 601
  return (tmp);
}
}
#line 604 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1262(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 607
  ldv_check_alloc_flags(flags);
#line 609
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 609
  return (tmp);
}
}
#line 612 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1263(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 615
  ldv_check_alloc_flags(flags);
#line 617
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 617
  return (tmp);
}
}
#line 620 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
int ldv_pskb_expand_head_1264(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 623
  ldv_check_alloc_flags(flags);
#line 625
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 625
  return (tmp);
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
int ldv_pskb_expand_head_1265(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 631
  ldv_check_alloc_flags(flags);
#line 633
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 633
  return (tmp);
}
}
#line 636 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/HalPwrSeqCmd.o.c.prepared"
struct sk_buff *ldv_skb_clone_1266(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 639
  ldv_check_alloc_flags(flags);
#line 641
  tmp = skb_clone(ldv_func_arg1, flags);
#line 641
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1292(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1300(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1308(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1302(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1298(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1306(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1307(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1303(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1304(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1305(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 62 "drivers/staging/rtl8723au/include/odm_interface.h"
void ODM_Write1Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u8 Data ) ;
#line 67
void ODM_SetBBReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask , u32 Data ) ;
#line 69
void ODM_SetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) ;
#line 18 "drivers/staging/rtl8723au/include/odm_RegConfig8723A.h"
void odm_ConfigRFReg_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data , enum RF_RADIO_PATH RF_PATH ,
                           u32 RegAddr ) ;
#line 23
void odm_ConfigRF_RadioB_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data ) ;
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
void odm_ConfigRFReg_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data , enum RF_RADIO_PATH RF_PATH ,
                           u32 RegAddr ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;

  {
#line 245
  if (Addr == 254U) {
#line 246
    msleep(50U);
  } else
#line 247
  if (Addr == 253U) {
#line 248
    if (1) {
#line 248
      __const_udelay(21475000UL);
    } else {
#line 248
      __ms = 5UL;
#line 248
      goto ldv_54209;
      ldv_54208: 
#line 248
      __const_udelay(4295000UL);
      ldv_54209: 
#line 248
      tmp = __ms;
#line 248
      __ms = __ms - 1UL;
#line 248
      if (tmp != 0UL) {
#line 250
        goto ldv_54208;
      } else {

      }

    }
  } else
#line 249
  if (Addr == 252U) {
#line 250
    if (1) {
#line 250
      __const_udelay(4295000UL);
    } else {
#line 250
      __ms___0 = 1UL;
#line 250
      goto ldv_54213;
      ldv_54212: 
#line 250
      __const_udelay(4295000UL);
      ldv_54213: 
#line 250
      tmp___0 = __ms___0;
#line 250
      __ms___0 = __ms___0 - 1UL;
#line 250
      if (tmp___0 != 0UL) {
#line 252
        goto ldv_54212;
      } else {

      }

    }
  } else
#line 251
  if (Addr == 251U) {
#line 252
    __const_udelay(214750UL);
  } else
#line 253
  if (Addr == 250U) {
#line 254
    __const_udelay(21475UL);
  } else
#line 255
  if (Addr == 249U) {
#line 256
    __const_udelay(4295UL);
  } else {
#line 258
    ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, 1048575U, Data);
#line 260
    __const_udelay(4295UL);
  }
#line 263
  return;
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
void odm_ConfigRF_RadioA_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data ) 
{ 
  u32 content ;
  u32 maskforPhySet ;

  {
#line 269
  content = 4096U;
#line 270
  maskforPhySet = content & 57344U;
#line 272
  odm_ConfigRFReg_8723A(pDM_Odm, Addr, Data, 0, Addr | maskforPhySet);
#line 274
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 274
    printk("[ODM-8723A] ");
#line 274
    printk("%s(): ===> ODM_ConfigRFWithHeaderFile23a: [RadioA] %08X %08X\n", "odm_ConfigRF_RadioA_8723A",
           Addr, Data);
  } else {

  }
#line 276
  return;
}
}
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
void odm_ConfigRF_RadioB_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Data ) 
{ 
  u32 content ;
  u32 maskforPhySet ;

  {
#line 284
  content = 4097U;
#line 285
  maskforPhySet = content & 57344U;
#line 287
  odm_ConfigRFReg_8723A(pDM_Odm, Addr, Data, 1, Addr | maskforPhySet);
#line 289
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 289
    printk("[ODM-8723A] ");
#line 289
    printk("%s(): ===> ODM_ConfigRFWithHeaderFile23a: [RadioB] %08X %08X\n", "odm_ConfigRF_RadioB_8723A",
           Addr, Data);
  } else {

  }
#line 291
  return;
}
}
#line 294 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
void odm_ConfigMAC_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u8 Data ) 
{ 


  {
#line 299
  ODM_Write1Byte(pDM_Odm, Addr, (int )Data);
#line 300
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 300
    printk("[ODM-8723A] ");
#line 300
    printk("%s(): ===> ODM_ConfigMACWithHeaderFile23a: [MAC_REG] %08X %08X\n", "odm_ConfigMAC_8723A",
           Addr, (int )Data);
  } else {

  }
#line 302
  return;
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
void odm_ConfigBB_AGC_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask , u32 Data ) 
{ 


  {
#line 313
  ODM_SetBBReg(pDM_Odm, Addr, Bitmask, Data);
#line 315
  __const_udelay(4295UL);
#line 317
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 317
    printk("[ODM-8723A] ");
#line 317
    printk("%s(): ===> ODM_ConfigBBWithHeaderFile23a: [AGC_TAB] %08X %08X\n", "odm_ConfigBB_AGC_8723A",
           Addr, Data);
  } else {

  }
#line 319
  return;
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
void odm_ConfigBB_PHY_REG_PG_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask ,
                                   u32 Data ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;

  {
#line 330
  if (Addr == 254U) {
#line 331
    msleep(50U);
  } else
#line 332
  if (Addr == 253U) {
#line 333
    if (1) {
#line 333
      __const_udelay(21475000UL);
    } else {
#line 333
      __ms = 5UL;
#line 333
      goto ldv_54252;
      ldv_54251: 
#line 333
      __const_udelay(4295000UL);
      ldv_54252: 
#line 333
      tmp = __ms;
#line 333
      __ms = __ms - 1UL;
#line 333
      if (tmp != 0UL) {
#line 335
        goto ldv_54251;
      } else {

      }

    }
  } else
#line 334
  if (Addr == 252U) {
#line 335
    if (1) {
#line 335
      __const_udelay(4295000UL);
    } else {
#line 335
      __ms___0 = 1UL;
#line 335
      goto ldv_54256;
      ldv_54255: 
#line 335
      __const_udelay(4295000UL);
      ldv_54256: 
#line 335
      tmp___0 = __ms___0;
#line 335
      __ms___0 = __ms___0 - 1UL;
#line 335
      if (tmp___0 != 0UL) {
#line 337
        goto ldv_54255;
      } else {

      }

    }
  } else
#line 336
  if (Addr == 251U) {
#line 337
    __const_udelay(214750UL);
  } else
#line 338
  if (Addr == 250U) {
#line 339
    __const_udelay(21475UL);
  } else
#line 340
  if (Addr == 249U) {
#line 341
    __const_udelay(4295UL);
  } else {

  }
#line 345
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 345
    printk("[ODM-8723A] ");
#line 345
    printk("%s(): ===> ODM_ConfigBBWithHeaderFile23a: [PHY_REG] %08X %08X %08X\n",
           "odm_ConfigBB_PHY_REG_PG_8723A", Addr, Bitmask, Data);
  } else {

  }
#line 347
  return;
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
void odm_ConfigBB_PHY_8723A(struct dm_odm_t *pDM_Odm , u32 Addr , u32 Bitmask , u32 Data ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;

  {
#line 358
  if (Addr == 254U) {
#line 359
    msleep(50U);
  } else
#line 360
  if (Addr == 253U) {
#line 361
    if (1) {
#line 361
      __const_udelay(21475000UL);
    } else {
#line 361
      __ms = 5UL;
#line 361
      goto ldv_54267;
      ldv_54266: 
#line 361
      __const_udelay(4295000UL);
      ldv_54267: 
#line 361
      tmp = __ms;
#line 361
      __ms = __ms - 1UL;
#line 361
      if (tmp != 0UL) {
#line 363
        goto ldv_54266;
      } else {

      }

    }
  } else
#line 362
  if (Addr == 252U) {
#line 363
    if (1) {
#line 363
      __const_udelay(4295000UL);
    } else {
#line 363
      __ms___0 = 1UL;
#line 363
      goto ldv_54271;
      ldv_54270: 
#line 363
      __const_udelay(4295000UL);
      ldv_54271: 
#line 363
      tmp___0 = __ms___0;
#line 363
      __ms___0 = __ms___0 - 1UL;
#line 363
      if (tmp___0 != 0UL) {
#line 365
        goto ldv_54270;
      } else {

      }

    }
  } else
#line 364
  if (Addr == 251U) {
#line 365
    __const_udelay(214750UL);
  } else
#line 366
  if (Addr == 250U) {
#line 367
    __const_udelay(21475UL);
  } else
#line 368
  if (Addr == 249U) {
#line 369
    __const_udelay(4295UL);
  } else
#line 370
  if (Addr == 2596U) {
#line 371
    pDM_Odm->RFCalibrateInfo.RegA24 = Data;
  } else {

  }
#line 372
  ODM_SetBBReg(pDM_Odm, Addr, Bitmask, Data);
#line 375
  __const_udelay(4295UL);
#line 377
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 377
    printk("[ODM-8723A] ");
#line 377
    printk("%s(): ===> ODM_ConfigBBWithHeaderFile23a: [PHY_REG] %08X %08X\n", "odm_ConfigBB_PHY_8723A",
           Addr, Data);
  } else {

  }
#line 379
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
void *ldv_kmem_cache_alloc_1292(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 512
  ldv_check_alloc_flags(flags);
#line 514
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 515
  return ((void *)0);
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
int ldv_pskb_expand_head_1298(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 556
  ldv_check_alloc_flags(flags);
#line 558
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 558
  return (tmp);
}
}
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
struct sk_buff *ldv_skb_clone_1300(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 572
  ldv_check_alloc_flags(flags);
#line 574
  tmp = skb_clone(ldv_func_arg1, flags);
#line 574
  return (tmp);
}
}
#line 585 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
struct sk_buff *ldv_skb_copy_1302(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 588
  ldv_check_alloc_flags(flags);
#line 590
  tmp = skb_copy(ldv_func_arg1, flags);
#line 590
  return (tmp);
}
}
#line 593 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1303(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 596
  ldv_check_alloc_flags(flags);
#line 598
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 598
  return (tmp);
}
}
#line 601 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1304(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 604
  ldv_check_alloc_flags(flags);
#line 606
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 606
  return (tmp);
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1305(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 612
  ldv_check_alloc_flags(flags);
#line 614
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 614
  return (tmp);
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
int ldv_pskb_expand_head_1306(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 620
  ldv_check_alloc_flags(flags);
#line 622
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 622
  return (tmp);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
int ldv_pskb_expand_head_1307(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 628
  ldv_check_alloc_flags(flags);
#line 630
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 630
  return (tmp);
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_RegConfig8723A.o.c.prepared"
struct sk_buff *ldv_skb_clone_1308(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 636
  ldv_check_alloc_flags(flags);
#line 638
  tmp = skb_clone(ldv_func_arg1, flags);
#line 638
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1334(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1342(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1350(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1344(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1340(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1348(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1349(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1345(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1346(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1347(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 164 "drivers/staging/rtl8723au/include/rtw_debug.h"
u32 GlobalDebugLevel23A  ;
#line 137 "drivers/staging/rtl8723au/include/odm_debug.h"
void ODM_InitDebugSetting23a(struct dm_odm_t *pDM_Odm ) ;
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
void ODM_InitDebugSetting23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 238
  pDM_Odm->DebugLevel = 5U;
#line 239
  pDM_Odm->DebugComponents = 0ULL;
#line 240
  return;
}
}
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
void *ldv_kmem_cache_alloc_1334(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 374
  ldv_check_alloc_flags(flags);
#line 376
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 377
  return ((void *)0);
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
int ldv_pskb_expand_head_1340(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 418
  ldv_check_alloc_flags(flags);
#line 420
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 420
  return (tmp);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
struct sk_buff *ldv_skb_clone_1342(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 434
  ldv_check_alloc_flags(flags);
#line 436
  tmp = skb_clone(ldv_func_arg1, flags);
#line 436
  return (tmp);
}
}
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
struct sk_buff *ldv_skb_copy_1344(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 450
  ldv_check_alloc_flags(flags);
#line 452
  tmp = skb_copy(ldv_func_arg1, flags);
#line 452
  return (tmp);
}
}
#line 455 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1345(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 458
  ldv_check_alloc_flags(flags);
#line 460
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 460
  return (tmp);
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1346(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 466
  ldv_check_alloc_flags(flags);
#line 468
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 468
  return (tmp);
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1347(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 474
  ldv_check_alloc_flags(flags);
#line 476
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 476
  return (tmp);
}
}
#line 479 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
int ldv_pskb_expand_head_1348(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 482
  ldv_check_alloc_flags(flags);
#line 484
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 484
  return (tmp);
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
int ldv_pskb_expand_head_1349(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 490
  ldv_check_alloc_flags(flags);
#line 492
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 492
  return (tmp);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_debug.o.c.prepared"
struct sk_buff *ldv_skb_clone_1350(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 498
  ldv_check_alloc_flags(flags);
#line 500
  tmp = skb_clone(ldv_func_arg1, flags);
#line 500
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1376(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1384(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1392(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1386(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1382(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1390(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1391(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1387(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1388(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1389(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 59 "drivers/staging/rtl8723au/include/odm_interface.h"
u8 ODM_Read1Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr ) ;
#line 60
u16 ODM_Read2Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr ) ;
#line 61
u32 ODM_Read4Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr ) ;
#line 63
void ODM_Write2Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u16 Data ) ;
#line 64
void ODM_Write4Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 Data ) ;
#line 65
void ODM_SetMACReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask , u32 Data ) ;
#line 66
u32 ODM_GetMACReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask ) ;
#line 68
u32 ODM_GetBBReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask ) ;
#line 71
u32 ODM_GetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                 u32 BitMask ) ;
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
u8 ODM_Read1Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr ) 
{ 
  struct rtw_adapter *Adapter ;
  u8 tmp ;

  {
#line 248
  Adapter = pDM_Odm->Adapter;
#line 250
  tmp = rtl8723au_read8(Adapter, RegAddr);
#line 250
  return (tmp);
}
}
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
u16 ODM_Read2Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr ) 
{ 
  struct rtw_adapter *Adapter ;
  u16 tmp ;

  {
#line 255
  Adapter = pDM_Odm->Adapter;
#line 257
  tmp = rtl8723au_read16(Adapter, RegAddr);
#line 257
  return (tmp);
}
}
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
u32 ODM_Read4Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 tmp ;

  {
#line 262
  Adapter = pDM_Odm->Adapter;
#line 264
  tmp = rtl8723au_read32(Adapter, RegAddr);
#line 264
  return (tmp);
}
}
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
void ODM_Write1Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u8 Data ) 
{ 
  struct rtw_adapter *Adapter ;

  {
#line 269
  Adapter = pDM_Odm->Adapter;
#line 271
  rtl8723au_write8(Adapter, RegAddr, (int )Data);
#line 272
  return;
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
void ODM_Write2Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u16 Data ) 
{ 
  struct rtw_adapter *Adapter ;

  {
#line 276
  Adapter = pDM_Odm->Adapter;
#line 278
  rtl8723au_write16(Adapter, RegAddr, (int )Data);
#line 279
  return;
}
}
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
void ODM_Write4Byte(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 Data ) 
{ 
  struct rtw_adapter *Adapter ;

  {
#line 283
  Adapter = pDM_Odm->Adapter;
#line 285
  rtl8723au_write32(Adapter, RegAddr, Data);
#line 286
  return;
}
}
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
void ODM_SetMACReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask , u32 Data ) 
{ 
  struct rtw_adapter *Adapter ;

  {
#line 295
  Adapter = pDM_Odm->Adapter;
#line 297
  PHY_SetBBReg(Adapter, RegAddr, BitMask, Data);
#line 298
  return;
}
}
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
u32 ODM_GetMACReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 tmp ;

  {
#line 306
  Adapter = pDM_Odm->Adapter;
#line 308
  tmp = PHY_QueryBBReg(Adapter, RegAddr, BitMask);
#line 308
  return (tmp);
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
void ODM_SetBBReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask , u32 Data ) 
{ 
  struct rtw_adapter *Adapter ;

  {
#line 318
  Adapter = pDM_Odm->Adapter;
#line 320
  PHY_SetBBReg(Adapter, RegAddr, BitMask, Data);
#line 321
  return;
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
u32 ODM_GetBBReg(struct dm_odm_t *pDM_Odm , u32 RegAddr , u32 BitMask ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 tmp ;

  {
#line 329
  Adapter = pDM_Odm->Adapter;
#line 331
  tmp = PHY_QueryBBReg(Adapter, RegAddr, BitMask);
#line 331
  return (tmp);
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
void ODM_SetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) 
{ 
  struct rtw_adapter *Adapter ;

  {
#line 342
  Adapter = pDM_Odm->Adapter;
#line 344
  PHY_SetRFReg(Adapter, eRFPath, RegAddr, BitMask, Data);
#line 345
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
u32 ODM_GetRFReg(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                 u32 BitMask ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 tmp ;

  {
#line 354
  Adapter = pDM_Odm->Adapter;
#line 356
  tmp = PHY_QueryRFReg(Adapter, eRFPath, RegAddr, BitMask);
#line 356
  return (tmp);
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
void *ldv_kmem_cache_alloc_1376(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 489
  ldv_check_alloc_flags(flags);
#line 491
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 492
  return ((void *)0);
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
int ldv_pskb_expand_head_1382(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 533
  ldv_check_alloc_flags(flags);
#line 535
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 535
  return (tmp);
}
}
#line 546 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
struct sk_buff *ldv_skb_clone_1384(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 549
  ldv_check_alloc_flags(flags);
#line 551
  tmp = skb_clone(ldv_func_arg1, flags);
#line 551
  return (tmp);
}
}
#line 562 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
struct sk_buff *ldv_skb_copy_1386(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 565
  ldv_check_alloc_flags(flags);
#line 567
  tmp = skb_copy(ldv_func_arg1, flags);
#line 567
  return (tmp);
}
}
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1387(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 573
  ldv_check_alloc_flags(flags);
#line 575
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 575
  return (tmp);
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1388(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 581
  ldv_check_alloc_flags(flags);
#line 583
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 583
  return (tmp);
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1389(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 589
  ldv_check_alloc_flags(flags);
#line 591
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 591
  return (tmp);
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
int ldv_pskb_expand_head_1390(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 597
  ldv_check_alloc_flags(flags);
#line 599
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 599
  return (tmp);
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
int ldv_pskb_expand_head_1391(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 605
  ldv_check_alloc_flags(flags);
#line 607
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 607
  return (tmp);
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_interface.o.c.prepared"
struct sk_buff *ldv_skb_clone_1392(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 613
  ldv_check_alloc_flags(flags);
#line 615
  tmp = skb_clone(ldv_func_arg1, flags);
#line 615
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1418(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1426(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1434(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1428(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1424(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1432(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1433(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1429(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1430(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1431(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 1048 "drivers/staging/rtl8723au/include/odm.h"
void ODM_SwAntDivChkPerPktRssi(struct dm_odm_t *pDM_Odm , u8 StationID , struct phy_info *pPhyInfo ) ;
#line 145 "drivers/staging/rtl8723au/include/odm_HWConfig.h"
void odm_Init_RSSIForDM23a(struct dm_odm_t *pDM_Odm ) ;
#line 148
void ODM_PhyStatusQuery23a(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                           u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) ;
#line 155
void ODM_MacStatusQuery23a(struct dm_odm_t *pDM_Odm , u8 *pMacStatus , u8 MacID ,
                           bool bPacketMatchBSSID , bool bPacketToSelf , bool bPacketBeacon ) ;
#line 163
int ODM_ConfigRFWithHeaderFile23a(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH Content ,
                                  enum RF_RADIO_PATH eRFPath ) ;
#line 167
int ODM_ConfigBBWithHeaderFile23a(struct dm_odm_t *pDM_Odm , enum odm_bb_config_type ConfigType ) ;
#line 170
int ODM_ConfigMACWithHeaderFile23a(struct dm_odm_t *pDM_Odm ) ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
static u8 odm_QueryRxPwrPercentage(s8 AntPower ) 
{ 


  {
#line 247
  if ((int )AntPower < -99 || (int )AntPower > 19) {
#line 248
    return (0U);
  } else
#line 249
  if ((int )AntPower >= 0) {
#line 250
    return (100U);
  } else {
#line 252
    return ((unsigned int )((u8 )AntPower) + 100U);
  }
}
}
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
static s32 odm_SignalScaleMapping_92CSeries(struct dm_odm_t *pDM_Odm , s32 CurrSig ) 
{ 
  s32 RetSig ;

  {
#line 257
  RetSig = 0;
#line 259
  if ((unsigned int )pDM_Odm->SupportInterface == 2U || (unsigned int )pDM_Odm->SupportInterface == 4U) {
#line 260
    if (CurrSig > 50 && CurrSig <= 100) {
#line 261
      RetSig = 100;
    } else
#line 262
    if (CurrSig > 40 && CurrSig <= 50) {
#line 263
      RetSig = CurrSig * 2;
    } else
#line 264
    if (CurrSig > 30 && CurrSig <= 40) {
#line 265
      RetSig = CurrSig + 36;
    } else
#line 266
    if (CurrSig > 20 && CurrSig <= 30) {
#line 267
      RetSig = CurrSig + 34;
    } else
#line 268
    if (CurrSig > 9 && CurrSig <= 20) {
#line 269
      RetSig = ((CurrSig + -10) * 2) / 3 + 42;
    } else
#line 270
    if (CurrSig > 4 && CurrSig <= 9) {
#line 271
      RetSig = (CurrSig * 3 + -15) / 2 + 22;
    } else
#line 272
    if (CurrSig > 0 && CurrSig <= 4) {
#line 273
      RetSig = ((CurrSig + -1) * 3) / 2 + 6;
    } else {
#line 275
      RetSig = CurrSig;
    }
  } else {

  }
#line 277
  return (RetSig);
}
}
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
static s32 odm_SignalScaleMapping(struct dm_odm_t *pDM_Odm , s32 CurrSig ) 
{ 
  s32 tmp ;

  {
#line 282
  tmp = odm_SignalScaleMapping_92CSeries(pDM_Odm, CurrSig);
#line 282
  return (tmp);
}
}
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
static u8 odm_EVMdbToPercentage(s8 Value ) 
{ 
  s8 ret_val ;

  {
#line 295
  ret_val = Value;
#line 297
  if ((int )ret_val >= 0) {
#line 298
    ret_val = 0;
  } else {

  }
#line 299
  if ((int )ret_val < -32) {
#line 300
    ret_val = -33;
  } else {

  }
#line 302
  ret_val = (s8 )(- ((int )((unsigned char )ret_val)));
#line 303
  ret_val = (s8 )((unsigned int )((unsigned char )ret_val) * 3U);
#line 305
  if ((int )ret_val == 99) {
#line 306
    ret_val = 100;
  } else {

  }
#line 308
  return ((u8 )ret_val);
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
static void odm_RxPhyStatus92CSeries_Parsing(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                             u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) 
{ 
  struct phy_status_rpt *pPhyStaRpt ;
  u8 i ;
  u8 Max_spatial_stream ;
  s8 rx_pwr[4U] ;
  s8 rx_pwr_all ;
  u8 EVM ;
  u8 PWDB_ALL ;
  u8 PWDB_ALL_BT ;
  u8 RSSI ;
  u8 total_rssi ;
  u8 isCCKrate ;
  u8 rf_rx_num ;
  u8 cck_highpwr ;
  u8 report ;
  u8 cck_agc_rpt ;
  u8 SQ ;
  u8 SQ_rpt ;
  s8 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
#line 316
  pPhyStaRpt = (struct phy_status_rpt *)pPhyStatus;
#line 318
  rx_pwr_all = 0;
#line 319
  PWDB_ALL = 0U;
#line 320
  total_rssi = 0U;
#line 321
  isCCKrate = 0U;
#line 322
  rf_rx_num = 0U;
#line 323
  cck_highpwr = 0U;
#line 325
  isCCKrate = (unsigned int )pPktinfo->Rate <= 3U;
#line 326
  pPhyInfo->RxMIMOSignalQuality[0] = 255U;
#line 327
  pPhyInfo->RxMIMOSignalQuality[1] = 255U;
#line 329
  if ((unsigned int )isCCKrate != 0U) {
#line 333
    pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK + 1ULL;
#line 337
    cck_highpwr = (u8 )pDM_Odm->bCckHighPower;
#line 339
    cck_agc_rpt = pPhyStaRpt->cck_agc_rpt_ofdm_cfosho_a;
#line 342
    if ((unsigned int )cck_highpwr == 0U) {
#line 343
      report = (int )cck_agc_rpt >> 6;
#line 344
      switch ((int )report) {
      case 3: 
#line 348
      rx_pwr_all = (s8 )(210U - ((unsigned int )cck_agc_rpt & 62U));
#line 349
      goto ldv_54238;
      case 2: 
#line 351
      rx_pwr_all = (s8 )(230U - ((unsigned int )cck_agc_rpt & 62U));
#line 352
      goto ldv_54238;
      case 1: 
#line 354
      rx_pwr_all = (s8 )(244U - ((unsigned int )cck_agc_rpt & 62U));
#line 355
      goto ldv_54238;
      case 0: 
#line 357
      rx_pwr_all = (s8 )(16U - ((unsigned int )cck_agc_rpt & 62U));
#line 358
      goto ldv_54238;
      }
      ldv_54238: ;
    } else {
#line 361
      report = (u8 )(((int )cck_agc_rpt & 96) >> 5);
#line 362
      switch ((int )report) {
      case 3: 
#line 364
      rx_pwr_all = (s8 )(210U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
#line 365
      goto ldv_54243;
      case 2: 
#line 367
      rx_pwr_all = (s8 )(230U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
#line 368
      goto ldv_54243;
      case 1: 
#line 370
      rx_pwr_all = (s8 )(244U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
#line 371
      goto ldv_54243;
      case 0: 
#line 373
      rx_pwr_all = (s8 )(16U - (((unsigned int )cck_agc_rpt & 31U) << 1U));
#line 374
      goto ldv_54243;
      }
      ldv_54243: ;
    }
#line 378
    PWDB_ALL = odm_QueryRxPwrPercentage((int )rx_pwr_all);
#line 381
    if ((unsigned int )pDM_Odm->BoardType == 1U) {
#line 382
      if ((int )((signed char )cck_agc_rpt) >= 0) {
#line 383
        PWDB_ALL = (unsigned int )PWDB_ALL <= 94U ? (unsigned int )PWDB_ALL + 6U : 100U;
      } else
#line 385
      if ((unsigned int )PWDB_ALL > 38U) {
#line 386
        PWDB_ALL = (unsigned int )PWDB_ALL + 240U;
      } else {
#line 388
        PWDB_ALL = (unsigned int )PWDB_ALL <= 16U ? (u8 )((int )PWDB_ALL >> 2) : (unsigned int )PWDB_ALL + 244U;
      }
#line 392
      if ((unsigned int )PWDB_ALL > 25U && (unsigned int )PWDB_ALL <= 60U) {
#line 393
        PWDB_ALL = (unsigned int )PWDB_ALL + 6U;
      } else {

      }
    } else
#line 395
    if ((unsigned int )PWDB_ALL > 99U) {
#line 396
      PWDB_ALL = (unsigned int )PWDB_ALL + 248U;
    } else
#line 397
    if ((unsigned int )PWDB_ALL > 50U && (unsigned int )PWDB_ALL <= 68U) {
#line 398
      PWDB_ALL = (unsigned int )PWDB_ALL + 4U;
    } else {

    }
#line 400
    pPhyInfo->RxPWDBAll = PWDB_ALL;
#line 401
    pPhyInfo->BTRxRSSIPercentage = PWDB_ALL;
#line 402
    pPhyInfo->RecvSignalPower = rx_pwr_all;
#line 404
    if ((int )pPktinfo->bPacketMatchBSSID) {
#line 407
      SQ_rpt = pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all;
#line 409
      if ((unsigned int )SQ_rpt > 64U) {
#line 410
        SQ = 0U;
      } else
#line 411
      if ((unsigned int )SQ_rpt <= 19U) {
#line 412
        SQ = 100U;
      } else {
#line 414
        SQ = (u8 )(((int )SQ_rpt * -100 + 6400) / 44);
      }
#line 416
      pPhyInfo->SignalQuality = SQ;
#line 417
      pPhyInfo->RxMIMOSignalQuality[0] = SQ;
#line 418
      pPhyInfo->RxMIMOSignalQuality[1] = 255U;
    } else {

    }
  } else {
#line 421
    pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM + 1ULL;
#line 425
    i = 0U;
#line 425
    goto ldv_54250;
    ldv_54249: ;
#line 427
    if ((int )((unsigned long )pDM_Odm->RFPathRxEnable >> (int )i) & 1) {
#line 428
      rf_rx_num = (u8 )((int )rf_rx_num + 1);
    } else {

    }
#line 430
    rx_pwr[(int )i] = (s8 )((unsigned int )((unsigned char )(((int )pPhyStaRpt->path_agc[(int )i].gain & 63) + -55)) * 2U);
#line 432
    pPhyInfo->RxPwr[(int )i] = (u8 )rx_pwr[(int )i];
#line 435
    RSSI = odm_QueryRxPwrPercentage((int )rx_pwr[(int )i]);
#line 436
    total_rssi = (int )total_rssi + (int )RSSI;
#line 439
    if ((unsigned int )pDM_Odm->BoardType == 1U) {
#line 440
      if ((unsigned int )pPhyStaRpt->path_agc[(int )i].trsw == 1U) {
#line 441
        RSSI = (unsigned int )RSSI <= 94U ? (unsigned int )RSSI + 6U : 100U;
      } else {
#line 443
        RSSI = (unsigned int )RSSI <= 16U ? (u8 )((int )RSSI >> 3) : (unsigned int )RSSI + 240U;
      }
#line 445
      if ((unsigned int )RSSI <= 34U && (unsigned int )RSSI > 3U) {
#line 446
        RSSI = (unsigned int )RSSI + 252U;
      } else {

      }
    } else {

    }
#line 449
    pPhyInfo->RxMIMOSignalStrength[(int )i] = RSSI;
#line 452
    tmp = (s8 )((unsigned int )pPhyStaRpt->path_rxsnr[(int )i] / 2U);
#line 452
    pDM_Odm->PhyDbgInfo.RxSNRdB[(int )i] = tmp;
#line 452
    pPhyInfo->RxSNR[(int )i] = (u8 )tmp;
#line 425
    i = (u8 )((int )i + 1);
    ldv_54250: ;
#line 425
    if ((unsigned int )i <= 1U) {
#line 427
      goto ldv_54249;
    } else {

    }
#line 456
    rx_pwr_all = (s8 )((unsigned int )((int )pPhyStaRpt->cck_sig_qual_ofdm_pwdb_all >> 1) + 146U);
#line 458
    PWDB_ALL = odm_QueryRxPwrPercentage((int )rx_pwr_all);
#line 459
    PWDB_ALL_BT = PWDB_ALL;
#line 461
    pPhyInfo->RxPWDBAll = PWDB_ALL;
#line 462
    pPhyInfo->BTRxRSSIPercentage = PWDB_ALL_BT;
#line 463
    pPhyInfo->RxPower = rx_pwr_all;
#line 464
    pPhyInfo->RecvSignalPower = rx_pwr_all;
#line 467
    if ((unsigned int )pPktinfo->Rate > 19U && (unsigned int )pPktinfo->Rate <= 27U) {
#line 468
      Max_spatial_stream = 2U;
    } else {
#line 470
      Max_spatial_stream = 1U;
    }
#line 472
    i = 0U;
#line 472
    goto ldv_54253;
    ldv_54252: 
#line 476
    EVM = odm_EVMdbToPercentage((int )pPhyStaRpt->stream_rxevm[(int )i]);
#line 478
    if ((int )pPktinfo->bPacketMatchBSSID) {
#line 479
      if ((unsigned int )i == 0U) {
#line 481
        pPhyInfo->SignalQuality = EVM;
      } else {

      }
#line 483
      pPhyInfo->RxMIMOSignalQuality[(int )i] = EVM;
    } else {

    }
#line 472
    i = (u8 )((int )i + 1);
    ldv_54253: ;
#line 472
    if ((int )i < (int )Max_spatial_stream) {
#line 474
      goto ldv_54252;
    } else {

    }

  }
#line 489
  if ((unsigned int )isCCKrate != 0U) {
#line 490
    tmp___0 = odm_SignalScaleMapping(pDM_Odm, (s32 )PWDB_ALL);
#line 490
    pPhyInfo->SignalStrength = (unsigned char )tmp___0;
  } else
#line 492
  if ((unsigned int )rf_rx_num != 0U) {
#line 493
    total_rssi = (u8 )((int )total_rssi / (int )rf_rx_num);
#line 493
    tmp___1 = odm_SignalScaleMapping(pDM_Odm, (s32 )total_rssi);
#line 493
    pPhyInfo->SignalStrength = (unsigned char )tmp___1;
  } else {

  }
#line 494
  return;
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
void odm_Init_RSSIForDM23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 499
  return;
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
static void odm_Process_RSSIForDM(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                  struct odm_packet_info *pPktinfo ) 
{ 
  s32 UndecoratedSmoothedPWDB ;
  s32 UndecoratedSmoothedCCK ;
  s32 UndecoratedSmoothedOFDM ;
  s32 RSSI_Ave ;
  u8 isCCKrate ;
  u8 RSSI_max ;
  u8 RSSI_min ;
  u8 i ;
  u32 OFDM_pkt ;
  u32 Weighting ;
  struct sta_info *pEntry ;

  {
#line 507
  isCCKrate = 0U;
#line 509
  OFDM_pkt = 0U;
#line 510
  Weighting = 0U;
#line 513
  if ((unsigned int )pPktinfo->StationID == 255U) {
#line 514
    return;
  } else {

  }
#line 516
  pEntry = pDM_Odm->pODM_StaInfo[(int )pPktinfo->StationID];
#line 517
  if ((unsigned long )pEntry == (unsigned long )((struct sta_info *)0)) {
#line 518
    return;
  } else {

  }
#line 519
  if (! pPktinfo->bPacketMatchBSSID) {
#line 520
    return;
  } else {

  }
#line 522
  isCCKrate = (unsigned int )pPktinfo->Rate <= 3U;
#line 526
  UndecoratedSmoothedCCK = pEntry->rssi_stat.UndecoratedSmoothedCCK;
#line 527
  UndecoratedSmoothedOFDM = pEntry->rssi_stat.UndecoratedSmoothedOFDM;
#line 528
  UndecoratedSmoothedPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
#line 530
  if ((int )pPktinfo->bPacketToSelf || (int )pPktinfo->bPacketBeacon) {
#line 531
    if ((unsigned int )isCCKrate == 0U) {
#line 532
      if ((unsigned int )pPhyInfo->RxMIMOSignalStrength[1] == 0U) {
#line 533
        RSSI_Ave = (s32 )pPhyInfo->RxMIMOSignalStrength[0];
      } else {
#line 535
        if ((int )pPhyInfo->RxMIMOSignalStrength[0] > (int )pPhyInfo->RxMIMOSignalStrength[1]) {
#line 536
          RSSI_max = pPhyInfo->RxMIMOSignalStrength[0];
#line 537
          RSSI_min = pPhyInfo->RxMIMOSignalStrength[1];
        } else {
#line 539
          RSSI_max = pPhyInfo->RxMIMOSignalStrength[1];
#line 540
          RSSI_min = pPhyInfo->RxMIMOSignalStrength[0];
        }
#line 542
        if ((int )RSSI_max - (int )RSSI_min <= 2) {
#line 543
          RSSI_Ave = (s32 )RSSI_max;
        } else
#line 544
        if ((int )RSSI_max - (int )RSSI_min <= 5) {
#line 545
          RSSI_Ave = (int )RSSI_max + -1;
        } else
#line 546
        if ((int )RSSI_max - (int )RSSI_min <= 9) {
#line 547
          RSSI_Ave = (int )RSSI_max + -2;
        } else {
#line 549
          RSSI_Ave = (int )RSSI_max + -3;
        }
      }
#line 553
      if (UndecoratedSmoothedOFDM <= 0) {
#line 555
        UndecoratedSmoothedOFDM = (s32 )pPhyInfo->RxPWDBAll;
      } else
#line 557
      if ((unsigned int )pPhyInfo->RxPWDBAll > (unsigned int )UndecoratedSmoothedOFDM) {
#line 558
        UndecoratedSmoothedOFDM = (UndecoratedSmoothedOFDM * 19 + RSSI_Ave) / 20;
#line 561
        UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM + 1;
      } else {
#line 563
        UndecoratedSmoothedOFDM = (UndecoratedSmoothedOFDM * 19 + RSSI_Ave) / 20;
      }
#line 568
      pEntry->rssi_stat.PacketMap = (pEntry->rssi_stat.PacketMap << 1) | 1ULL;
    } else {
#line 571
      RSSI_Ave = (s32 )pPhyInfo->RxPWDBAll;
#line 574
      if (UndecoratedSmoothedCCK <= 0) {
#line 576
        UndecoratedSmoothedCCK = (s32 )pPhyInfo->RxPWDBAll;
      } else
#line 578
      if ((unsigned int )pPhyInfo->RxPWDBAll > (unsigned int )UndecoratedSmoothedCCK) {
#line 579
        UndecoratedSmoothedCCK = (UndecoratedSmoothedCCK * 19 + (int )pPhyInfo->RxPWDBAll) / 20;
#line 582
        UndecoratedSmoothedCCK = UndecoratedSmoothedCCK + 1;
      } else {
#line 584
        UndecoratedSmoothedCCK = (UndecoratedSmoothedCCK * 19 + (int )pPhyInfo->RxPWDBAll) / 20;
      }
#line 589
      pEntry->rssi_stat.PacketMap = pEntry->rssi_stat.PacketMap << 1;
    }
#line 593
    if ((unsigned int )pEntry->rssi_stat.ValidBit > 63U) {
#line 594
      pEntry->rssi_stat.ValidBit = 64U;
    } else {
#line 596
      pEntry->rssi_stat.ValidBit = (u8 )((int )pEntry->rssi_stat.ValidBit + 1);
    }
#line 598
    i = 0U;
#line 598
    goto ldv_54275;
    ldv_54274: 
#line 599
    OFDM_pkt = ((u32 )((unsigned char )(pEntry->rssi_stat.PacketMap >> (int )i)) & 1U) + OFDM_pkt;
#line 598
    i = (u8 )((int )i + 1);
    ldv_54275: ;
#line 598
    if ((int )pEntry->rssi_stat.ValidBit > (int )i) {
#line 600
      goto ldv_54274;
    } else {

    }

#line 602
    if ((unsigned int )pEntry->rssi_stat.ValidBit == 64U) {
#line 603
      Weighting = 64U < OFDM_pkt << 4 ? 64U : OFDM_pkt << 4;
#line 604
      UndecoratedSmoothedPWDB = (s32 )((Weighting * (u32 )UndecoratedSmoothedOFDM + (64U - Weighting) * (u32 )UndecoratedSmoothedCCK) >> 6);
    } else
#line 606
    if ((unsigned int )pEntry->rssi_stat.ValidBit != 0U) {
#line 607
      UndecoratedSmoothedPWDB = (s32 )((OFDM_pkt * (u32 )UndecoratedSmoothedOFDM + ((u32 )pEntry->rssi_stat.ValidBit - OFDM_pkt) * (u32 )UndecoratedSmoothedCCK) / (u32 )pEntry->rssi_stat.ValidBit);
    } else {
#line 609
      UndecoratedSmoothedPWDB = 0;
    }
#line 611
    pEntry->rssi_stat.UndecoratedSmoothedCCK = UndecoratedSmoothedCCK;
#line 612
    pEntry->rssi_stat.UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM;
#line 613
    pEntry->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
  } else {

  }
#line 615
  return;
}
}
#line 618 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
static void ODM_PhyStatusQuery23a_92CSeries(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                                            u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) 
{ 


  {
#line 623
  odm_RxPhyStatus92CSeries_Parsing(pDM_Odm, pPhyInfo, pPhyStatus, pPktinfo);
#line 625
  if ((int )pDM_Odm->RSSI_test) {
#line 627
    if ((int )pPktinfo->bPacketToSelf || (int )pPktinfo->bPacketBeacon) {
#line 628
      ODM_SwAntDivChkPerPktRssi(pDM_Odm, (int )pPktinfo->StationID, pPhyInfo);
    } else {

    }
  } else {
#line 630
    odm_Process_RSSIForDM(pDM_Odm, pPhyInfo, pPktinfo);
  }
#line 631
  return;
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
void ODM_PhyStatusQuery23a(struct dm_odm_t *pDM_Odm , struct phy_info *pPhyInfo ,
                           u8 *pPhyStatus , struct odm_packet_info *pPktinfo ) 
{ 


  {
#line 637
  ODM_PhyStatusQuery23a_92CSeries(pDM_Odm, pPhyInfo, pPhyStatus, pPktinfo);
#line 638
  return;
}
}
#line 641 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
void ODM_MacStatusQuery23a(struct dm_odm_t *pDM_Odm , u8 *pMacStatus , u8 MacID ,
                           bool bPacketMatchBSSID , bool bPacketToSelf , bool bPacketBeacon ) 
{ 


  {
#line 643
  return;
}
}
#line 649 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
int ODM_ConfigRFWithHeaderFile23a(struct dm_odm_t *pDM_Odm , enum RF_RADIO_PATH Content ,
                                  enum RF_RADIO_PATH eRFPath ) 
{ 


  {
#line 653
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 653
    printk("[ODM-8723A] ");
#line 653
    printk("%s(): ===>ODM_ConfigRFWithHeaderFile23a\n", "ODM_ConfigRFWithHeaderFile23a");
  } else {

  }
#line 655
  if (pDM_Odm->SupportICType == 8U) {
#line 656
    if ((unsigned int )eRFPath == 0U) {
#line 657
      ODM_ReadAndConfig_RadioA_1T_8723A(pDM_Odm);
    } else {

    }
#line 659
    if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 659
      printk("[ODM-8723A] ");
#line 659
      printk("%s():  ===> ODM_ConfigRFWithHeaderFile23a() Radio_A:Rtl8723RadioA_1TArray\n",
             "ODM_ConfigRFWithHeaderFile23a");
    } else {

    }
#line 661
    if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 661
      printk("[ODM-8723A] ");
#line 661
      printk("%s():  ===> ODM_ConfigRFWithHeaderFile23a() Radio_B:Rtl8723RadioB_1TArray\n",
             "ODM_ConfigRFWithHeaderFile23a");
    } else {

    }
  } else {

  }
#line 664
  if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 4U) {
#line 664
    printk("[ODM-8723A] ");
#line 664
    printk("%s(): ODM_ConfigRFWithHeaderFile23a: Radio No %x\n", "ODM_ConfigRFWithHeaderFile23a",
           (unsigned int )eRFPath);
  } else {

  }
#line 666
  return (1);
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
int ODM_ConfigBBWithHeaderFile23a(struct dm_odm_t *pDM_Odm , enum odm_bb_config_type ConfigType ) 
{ 


  {
#line 672
  if (pDM_Odm->SupportICType == 8U) {
#line 673
    if ((unsigned int )ConfigType == 0U) {
#line 674
      ODM_ReadAndConfig_PHY_REG_1T_8723A(pDM_Odm);
    } else
#line 675
    if ((unsigned int )ConfigType == 1U) {
#line 676
      ODM_ReadAndConfig_AGC_TAB_1T_8723A(pDM_Odm);
    } else {

    }
#line 677
    if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 677
      printk("[ODM-8723A] ");
#line 677
      printk("%s():  ===> phy_ConfigBBWithHeaderFile() phy:Rtl8723AGCTAB_1TArray\n",
             "ODM_ConfigBBWithHeaderFile23a");
    } else {

    }
#line 679
    if ((pDM_Odm->DebugComponents & 2147483648ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 679
      printk("[ODM-8723A] ");
#line 679
      printk("%s():  ===> phy_ConfigBBWithHeaderFile() agc:Rtl8723PHY_REG_1TArray\n",
             "ODM_ConfigBBWithHeaderFile23a");
    } else {

    }
  } else {

  }
#line 682
  return (1);
}
}
#line 685 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
int ODM_ConfigMACWithHeaderFile23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 687
  if (pDM_Odm->SupportICType == 8U) {
#line 688
    ODM_ReadAndConfig_MAC_REG_8723A(pDM_Odm);
  } else {

  }
#line 689
  return (1);
}
}
#line 819 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
void *ldv_kmem_cache_alloc_1418(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 822
  ldv_check_alloc_flags(flags);
#line 824
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 825
  return ((void *)0);
}
}
#line 863 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
int ldv_pskb_expand_head_1424(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 866
  ldv_check_alloc_flags(flags);
#line 868
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 868
  return (tmp);
}
}
#line 879 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
struct sk_buff *ldv_skb_clone_1426(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 882
  ldv_check_alloc_flags(flags);
#line 884
  tmp = skb_clone(ldv_func_arg1, flags);
#line 884
  return (tmp);
}
}
#line 895 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
struct sk_buff *ldv_skb_copy_1428(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 898
  ldv_check_alloc_flags(flags);
#line 900
  tmp = skb_copy(ldv_func_arg1, flags);
#line 900
  return (tmp);
}
}
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1429(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 906
  ldv_check_alloc_flags(flags);
#line 908
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 908
  return (tmp);
}
}
#line 911 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1430(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 914
  ldv_check_alloc_flags(flags);
#line 916
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 916
  return (tmp);
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1431(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 922
  ldv_check_alloc_flags(flags);
#line 924
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 924
  return (tmp);
}
}
#line 927 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
int ldv_pskb_expand_head_1432(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 930
  ldv_check_alloc_flags(flags);
#line 932
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 932
  return (tmp);
}
}
#line 935 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
int ldv_pskb_expand_head_1433(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 938
  ldv_check_alloc_flags(flags);
#line 940
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 940
  return (tmp);
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm_HWConfig.o.c.prepared"
struct sk_buff *ldv_skb_clone_1434(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 946
  ldv_check_alloc_flags(flags);
#line 948
  tmp = skb_clone(ldv_func_arg1, flags);
#line 948
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1460(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1468(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1476(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1470(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1466(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1474(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1475(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1471(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1472(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1473(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 1029 "drivers/staging/rtl8723au/include/odm.h"
void ODM_Write_CCK_CCA_Thres23a(struct dm_odm_t *pDM_Odm , u8 CurCCK_CCAThres ) ;
#line 1035
void ODM_RF_Saving23a(struct dm_odm_t *pDM_Odm , u8 bForceInNormal ) ;
#line 1038
void ODM_SwAntDivRestAfterLink(struct dm_odm_t *pDM_Odm ) ;
#line 1041
void ODM_TXPowerTrackingCheck23a(struct dm_odm_t *pDM_Odm ) ;
#line 1043
bool ODM_RAStateCheck23a(struct dm_odm_t *pDM_Odm , s32 RSSI , bool bForceUpdate ,
                         u8 *pRATRState ) ;
#line 1051
u32 ConvertTo_dB23a(u32 Value ) ;
#line 1053
u32 GetPSDData(struct dm_odm_t *pDM_Odm , unsigned int point , u8 initial_gain_psd ) ;
#line 1055
void odm_DIG23abyRSSI_LPS(struct dm_odm_t *pDM_Odm ) ;
#line 1057
u32 ODM_Get_Rate_Bitmap23a(struct dm_odm_t *pDM_Odm , u32 macid , u32 ra_mask , u8 rssi_level ) ;
#line 1060
void ODM23a_DMInit(struct dm_odm_t *pDM_Odm ) ;
#line 1062
void ODM_DMWatchdog23a(struct dm_odm_t *pDM_Odm ) ;
#line 1064
void ODM_CmnInfoInit23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , u32 Value ) ;
#line 1066
void ODM23a_CmnInfoHook(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , void *pValue ) ;
#line 1068
void ODM_CmnInfoPtrArrayHook23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo ,
                                u16 Index , void *pValue ) ;
#line 1070
void ODM_CmnInfoUpdate23a(struct dm_odm_t *pDM_Odm , u32 CmnInfo , u64 Value ) ;
#line 1076
void ODM_SingleDualAntennaDefaultSetting(struct dm_odm_t *pDM_Odm ) ;
#line 1078
bool ODM_SingleDualAntennaDetection(struct dm_odm_t *pDM_Odm , u8 mode ) ;
#line 1080
void odm_dtc(struct dm_odm_t *pDM_Odm ) ;
#line 33 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
bool rtl8723a_BT_disable_EDCA_turbo(struct rtw_adapter *padapter ) ;
#line 152 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
int rtl8723a_set_rssi_cmd(struct rtw_adapter *padapter , u8 *param ) ;
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
static u16 const   dB_Invert_Table[8U][12U]  = 
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
  { {        1U,        1U,        1U,        2U, 
            2U,        2U,        2U,        3U, 
            3U,        3U,        4U,        4U}, 
   {        4U,        5U,        6U,        6U, 
            7U,        8U,        9U,        10U, 
            11U,        13U,        14U,        16U}, 
   {        18U,        20U,        22U,        25U, 
            28U,        32U,        35U,        40U, 
            45U,        50U,        56U,        63U}, 
   {        71U,        79U,        89U,        100U, 
            112U,        126U,        141U,        158U, 
            178U,        200U,        224U,        251U}, 
   {        282U,        316U,        355U,        398U, 
            447U,        501U,        562U,        631U, 
            708U,        794U,        891U,        1000U}, 
   {        1122U,        1259U,        1413U,        1585U, 
            1778U,        1995U,        2239U,        2512U, 
            2818U,        3162U,        3548U,        3981U}, 
   {        4467U,        5012U,        5623U,        6310U, 
            7079U,        7943U,        8913U,        10000U, 
            11220U,        12589U,        14125U,        15849U}, 
   {        17783U,        19953U,        22387U,        25119U, 
            28184U,        31623U,        35481U,        39811U, 
            44668U,        50119U,        56234U,        65535U}};
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
static u32 EDCAParam[17U][3U]  = 
#line 248
  { {        6202411U,        6202411U,        6202411U}, 
   {        42063U,        6202447U,        6177564U}, 
   {        6202411U,        6202411U,        6202411U}, 
   {        6202155U,        6202411U,        6177570U}, 
   {        6202402U,        42063U,        42063U}, 
   {        6202146U,        42544U,        42063U}, 
   {        6177570U,        6177570U,        6177570U}, 
   {        6202447U,        42063U,        6202411U}, 
   {        6202411U,        6202411U,        6202411U}, 
   {        6202411U,        42544U,        6177564U}};
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
u32 OFDMSwingTable23A[43U]  = 
#line 264
  {      2139095550U,      2021655010U,      1908408775U,      1803551150U, 
        1698693525U,      1606418815U,      1514144105U,      1430258005U, 
        1350566210U,      1275068720U,      1203765535U,      1136656655U, 
        1073742080U,      1015021810U,      956301540U,      901775575U, 
        851443915U,      805306560U,      759169205U,      717226155U, 
        679477410U,      637534360U,      603979920U,      570425480U, 
        536871040U,      507510905U,      478150770U,      452984940U, 
        427819110U,      402653280U,      381681755U,      360710230U, 
        339738705U,      318767180U,      301989960U,      285212740U, 
        268435520U,      251658300U,      239075385U,      226492470U, 
        213909555U,      201326640U,      188743725U};
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
u8 CCKSwingTable_Ch1_Ch1323A[33U][8U]  = 
#line 310
  { {        54U,        53U,        46U,        37U, 
            28U,        18U,        9U,        4U}, 
   {        51U,        50U,        43U,        35U, 
            26U,        17U,        8U,        4U}, 
   {        48U,        47U,        41U,        33U, 
            25U,        16U,        8U,        3U}, 
   {        45U,        45U,        39U,        31U, 
            24U,        15U,        8U,        3U}, 
   {        43U,        42U,        37U,        30U, 
            22U,        14U,        7U,        3U}, 
   {        40U,        40U,        34U,        28U, 
            21U,        13U,        7U,        3U}, 
   {        38U,        37U,        33U,        27U, 
            20U,        13U,        6U,        3U}, 
   {        36U,        35U,        31U,        25U, 
            19U,        12U,        6U,        3U}, 
   {        34U,        33U,        29U,        24U, 
            17U,        11U,        6U,        2U}, 
   {        32U,        32U,        27U,        22U, 
            17U,        8U,        5U,        2U}, 
   {        31U,        30U,        26U,        21U, 
            16U,        10U,        5U,        2U}, 
   {        29U,        28U,        24U,        20U, 
            15U,        10U,        5U,        2U}, 
   {        27U,        26U,        23U,        19U, 
            14U,        9U,        4U,        2U}, 
   {        26U,        25U,        22U,        18U, 
            13U,        9U,        4U,        2U}, 
   {        24U,        23U,        21U,        17U, 
            12U,        8U,        4U,        2U}, 
   {        23U,        22U,        19U,        16U, 
            12U,        8U,        4U,        2U}, 
   {        22U,        21U,        18U,        15U, 
            11U,        7U,        4U,        1U}, 
   {        20U,        20U,        17U,        14U, 
            11U,        7U,        3U,        2U}, 
   {        19U,        19U,        16U,        13U, 
            10U,        6U,        3U,        1U}, 
   {        18U,        18U,        15U,        12U, 
            9U,        6U,        3U,        1U}, 
   {        17U,        17U,        15U,        12U, 
            9U,        6U,        3U,        1U}, 
   {        16U,        16U,        14U,        11U, 
            8U,        5U,        3U,        1U}, 
   {        15U,        15U,        13U,        11U, 
            8U,        5U,        3U,        1U}, 
   {        14U,        14U,        12U,        10U, 
            8U,        5U,        2U,        1U}, 
   {        13U,        13U,        12U,        10U, 
            7U,        5U,        2U,        1U}, 
   {        13U,        12U,        11U,        9U, 
            7U,        4U,        2U,        1U}, 
   {        12U,        12U,        10U,        9U, 
            6U,        4U,        2U,        1U}, 
   {        11U,        11U,        10U,        8U, 
            6U,        4U,        2U,        1U}, 
   {        11U,        10U,        9U,        8U, 
            6U,        4U,        2U,        1U}, 
   {        10U,        10U,        9U,        7U, 
            5U,        3U,        2U,        1U}, 
   {        10U,        9U,        8U,        7U, 
            5U,        3U,        2U,        1U}, 
   {        9U,        9U,        8U,        6U, 
            5U,        3U,        1U,        1U}, 
   {        9U,        8U,        7U,        6U, 
            4U,        3U,        1U,        1U}};
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
u8 CCKSwingTable_Ch1423A[33U][8U]  = 
#line 346
  { {        54U,        53U,        46U,        27U, 
            0U,        0U,        0U,        0U}, 
   {        51U,        50U,        43U,        25U, 
            0U,        0U,        0U,        0U}, 
   {        48U,        47U,        41U,        24U, 
            0U,        0U,        0U,        0U}, 
   {        45U,        45U,        23U,        23U, 
            0U,        0U,        0U,        0U}, 
   {        43U,        42U,        37U,        21U, 
            0U,        0U,        0U,        0U}, 
   {        40U,        40U,        36U,        20U, 
            0U,        0U,        0U,        0U}, 
   {        38U,        37U,        33U,        19U, 
            0U,        0U,        0U,        0U}, 
   {        36U,        35U,        31U,        18U, 
            0U,        0U,        0U,        0U}, 
   {        34U,        33U,        29U,        17U, 
            0U,        0U,        0U,        0U}, 
   {        32U,        32U,        27U,        16U, 
            0U,        0U,        0U,        0U}, 
   {        31U,        30U,        26U,        15U, 
            0U,        0U,        0U,        0U}, 
   {        29U,        28U,        24U,        14U, 
            0U,        0U,        0U,        0U}, 
   {        27U,        26U,        23U,        14U, 
            0U,        0U,        0U,        0U}, 
   {        26U,        25U,        22U,        13U, 
            0U,        0U,        0U,        0U}, 
   {        24U,        23U,        21U,        12U, 
            0U,        0U,        0U,        0U}, 
   {        23U,        22U,        19U,        11U, 
            0U,        0U,        0U,        0U}, 
   {        22U,        21U,        18U,        11U, 
            0U,        0U,        0U,        0U}, 
   {        20U,        20U,        17U,        10U, 
            0U,        0U,        0U,        0U}, 
   {        19U,        19U,        16U,        10U, 
            0U,        0U,        0U,        0U}, 
   {        18U,        18U,        15U,        9U, 
            0U,        0U,        0U,        0U}, 
   {        17U,        17U,        15U,        9U, 
            0U,        0U,        0U,        0U}, 
   {        16U,        16U,        14U,        8U, 
            0U,        0U,        0U,        0U}, 
   {        15U,        15U,        13U,        8U, 
            0U,        0U,        0U,        0U}, 
   {        14U,        14U,        12U,        7U, 
            0U,        0U,        0U,        0U}, 
   {        13U,        13U,        12U,        7U, 
            0U,        0U,        0U,        0U}, 
   {        13U,        12U,        11U,        6U, 
            0U,        0U,        0U,        0U}, 
   {        12U,        12U,        10U,        6U, 
            0U,        0U,        0U,        0U}, 
   {        11U,        11U,        10U,        6U, 
            0U,        0U,        0U,        0U}, 
   {        11U,        10U,        9U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        10U,        10U,        9U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        10U,        9U,        8U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        9U,        9U,        8U,        5U, 
            0U,        0U,        0U,        0U}, 
   {        9U,        8U,        7U,        4U, 
            0U,        0U,        0U,        0U}};
#line 385
void odm_CommonInfoSelfInit23a(struct dm_odm_t *pDM_Odm ) ;
#line 387
void odm_CommonInfoSelfUpdate23a(struct dm_odm_t *pDM_Odm ) ;
#line 389
void odm_CmnInfoInit_Debug23a(struct dm_odm_t *pDM_Odm ) ;
#line 391
void odm_CmnInfoHook_Debug23a(struct dm_odm_t *pDM_Odm ) ;
#line 393
void odm_CmnInfoUpdate_Debug23a(struct dm_odm_t *pDM_Odm ) ;
#line 396
void odm_FalseAlarmCounterStatistics23a(struct dm_odm_t *pDM_Odm ) ;
#line 398
void odm_DIG23aInit(struct dm_odm_t *pDM_Odm ) ;
#line 400
void odm_DIG23a(struct dm_odm_t *pDM_Odm ) ;
#line 402
void odm_CCKPacketDetectionThresh23a(struct dm_odm_t *pDM_Odm ) ;
#line 406
void odm23a_DynBBPSInit(struct dm_odm_t *pDM_Odm ) ;
#line 408
void odm_DynamicBBPowerSaving23a(struct dm_odm_t *pDM_Odm ) ;
#line 410
void odm_1R_CCA23a(struct dm_odm_t *pDM_Odm ) ;
#line 413
void odm_RefreshRateAdaptiveMask23aMP23a(struct dm_odm_t *pDM_Odm ) ;
#line 415
void odm_RefreshRateAdaptiveMask23aCE23a(struct dm_odm_t *pDM_Odm ) ;
#line 417
void odm_RefreshRateAdaptiveMask23aAPADSL23a(struct dm_odm_t *pDM_Odm ) ;
#line 419
void odm_DynamicTxPower23aInit(struct dm_odm_t *pDM_Odm ) ;
#line 421
void odm_RSSIMonitorInit(struct dm_odm_t *pDM_Odm ) ;
#line 423
void odm_RSSIMonitorCheck23aMP(struct dm_odm_t *pDM_Odm ) ;
#line 425
void odm_RSSIMonitorCheck23aCE(struct dm_odm_t *pDM_Odm ) ;
#line 426
void odm_RSSIMonitorCheck23aAP(struct dm_odm_t *pDM_Odm ) ;
#line 428
void odm_RSSIMonitorCheck23a(struct dm_odm_t *pDM_Odm ) ;
#line 431
void odm_SwAntDivInit(struct dm_odm_t *pDM_Odm ) ;
#line 435
void odm_SwAntDivChkAntSwitch(struct dm_odm_t *pDM_Odm , u8 Step ) ;
#line 441
void odm_SwAntDivChkAntSwitchCallback23a(unsigned long data ) ;
#line 443
void odm_RefreshRateAdaptiveMask23a(struct dm_odm_t *pDM_Odm ) ;
#line 447
void odm_TXPowerTrackingCheckAP(struct dm_odm_t *pDM_Odm ) ;
#line 449
void odm_RateAdaptiveMaskInit23a(struct dm_odm_t *pDM_Odm ) ;
#line 451
void odm_TXPowerTrackingThermalMeterInit23a(struct dm_odm_t *pDM_Odm ) ;
#line 453
void odm_TXPowerTrackingInit23a(struct dm_odm_t *pDM_Odm ) ;
#line 455
void odm_TXPowerTrackingCheckMP(struct dm_odm_t *pDM_Odm ) ;
#line 457
void odm_TXPowerTrackingCheckCE23a(struct dm_odm_t *pDM_Odm ) ;
#line 459
void odm_EdcaTurboCheck23a(struct dm_odm_t *pDM_Odm ) ;
#line 460
void ODM_EdcaTurboInit23a(struct dm_odm_t *pDM_Odm ) ;
#line 462
void odm_EdcaTurboCheck23aCE23a(struct dm_odm_t *pDM_Odm ) ;
#line 467
void odm_InitHybridAntDiv23a(struct dm_odm_t *pDM_Odm ) ;
#line 482
void odm_HwAntDiv23a(struct dm_odm_t *pDM_Odm ) ;
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM23a_DMInit(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 490
  odm_CommonInfoSelfInit23a(pDM_Odm);
#line 491
  odm_CmnInfoInit_Debug23a(pDM_Odm);
#line 492
  odm_DIG23aInit(pDM_Odm);
#line 493
  odm_RateAdaptiveMaskInit23a(pDM_Odm);
#line 495
  if ((pDM_Odm->SupportICType & 31U) != 0U) {
#line 496
    odm23a_DynBBPSInit(pDM_Odm);
#line 497
    odm_DynamicTxPower23aInit(pDM_Odm);
#line 498
    odm_TXPowerTrackingInit23a(pDM_Odm);
#line 499
    ODM_EdcaTurboInit23a(pDM_Odm);
#line 500
    if (((unsigned int )pDM_Odm->AntDivType == 1U || (unsigned int )pDM_Odm->AntDivType == 2U) || (unsigned int )pDM_Odm->AntDivType == 4U) {
#line 503
      odm_InitHybridAntDiv23a(pDM_Odm);
    } else
#line 504
    if ((unsigned int )pDM_Odm->AntDivType == 5U) {
#line 505
      odm_SwAntDivInit(pDM_Odm);
    } else {

    }
  } else {

  }
#line 507
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_DMWatchdog23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 515
  odm_CmnInfoHook_Debug23a(pDM_Odm);
#line 516
  odm_CmnInfoUpdate_Debug23a(pDM_Odm);
#line 517
  odm_CommonInfoSelfUpdate23a(pDM_Odm);
#line 518
  odm_FalseAlarmCounterStatistics23a(pDM_Odm);
#line 519
  odm_RSSIMonitorCheck23a(pDM_Odm);
#line 524
  if ((unsigned int )(pDM_Odm->Adapter)->pwrctrlpriv.pwr_mode != 0U && (pDM_Odm->SupportICType & 8U) != 0U) {
#line 526
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 526
      printk("[ODM-8723A] ");
#line 526
      printk("%s(): ----Step1: odm_DIG23a is in LPS mode\n", "ODM_DMWatchdog23a");
    } else {

    }
#line 527
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 527
      printk("[ODM-8723A] ");
#line 527
      printk("%s(): ---Step2: 8723AS is in LPS mode\n", "ODM_DMWatchdog23a");
    } else {

    }
#line 528
    odm_DIG23abyRSSI_LPS(pDM_Odm);
  } else {
#line 530
    odm_DIG23a(pDM_Odm);
  }
#line 533
  odm_CCKPacketDetectionThresh23a(pDM_Odm);
#line 535
  if ((int )*(pDM_Odm->pbPowerSaving)) {
#line 536
    return;
  } else {

  }
#line 538
  odm_RefreshRateAdaptiveMask23a(pDM_Odm);
#line 540
  odm_DynamicBBPowerSaving23a(pDM_Odm);
#line 541
  if (((unsigned int )pDM_Odm->AntDivType == 1U || (unsigned int )pDM_Odm->AntDivType == 2U) || (unsigned int )pDM_Odm->AntDivType == 4U) {
#line 544
    odm_HwAntDiv23a(pDM_Odm);
  } else
#line 545
  if ((unsigned int )pDM_Odm->AntDivType == 5U) {
#line 546
    odm_SwAntDivChkAntSwitch(pDM_Odm, 0);
  } else {

  }
#line 548
  if ((pDM_Odm->SupportICType & 31U) != 0U) {
#line 549
    ODM_TXPowerTrackingCheck23a(pDM_Odm);
#line 550
    odm_EdcaTurboCheck23a(pDM_Odm);
  } else {

  }
#line 553
  odm_dtc(pDM_Odm);
#line 554
  return;
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_CmnInfoInit23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , u32 Value ) 
{ 


  {
#line 569
  switch ((unsigned int )CmnInfo) {
  case 1U: 
#line 572
  pDM_Odm->SupportAbility = Value;
#line 573
  goto ldv_54354;
  case 0U: ;
#line 575
  goto ldv_54354;
  case 2U: 
#line 577
  pDM_Odm->SupportInterface = (unsigned char )Value;
#line 578
  goto ldv_54354;
  case 3U: 
#line 580
  pDM_Odm->bIsMPChip = (unsigned int )((unsigned char )Value) != 0U;
#line 581
  goto ldv_54354;
  case 4U: 
#line 583
  pDM_Odm->SupportICType = Value;
#line 584
  goto ldv_54354;
  case 5U: 
#line 586
  pDM_Odm->CutVersion = (unsigned char )Value;
#line 587
  goto ldv_54354;
  case 6U: 
#line 589
  pDM_Odm->FabVersion = (unsigned char )Value;
#line 590
  goto ldv_54354;
  case 7U: 
#line 592
  pDM_Odm->RFType = (unsigned char )Value;
#line 593
  goto ldv_54354;
  case 45U: 
#line 595
  pDM_Odm->AntDivType = (unsigned char )Value;
#line 596
  goto ldv_54354;
  case 8U: 
#line 598
  pDM_Odm->BoardType = (unsigned char )Value;
#line 599
  goto ldv_54354;
  case 9U: 
#line 601
  pDM_Odm->ExtLNA = (unsigned char )Value;
#line 602
  goto ldv_54354;
  case 10U: 
#line 604
  pDM_Odm->ExtPA = (unsigned char )Value;
#line 605
  goto ldv_54354;
  case 11U: 
#line 607
  pDM_Odm->ExtTRSW = (unsigned char )Value;
#line 608
  goto ldv_54354;
  case 12U: 
#line 610
  pDM_Odm->PatchID = (unsigned char )Value;
#line 611
  goto ldv_54354;
  case 13U: 
#line 613
  pDM_Odm->bInHctTest = Value != 0U;
#line 614
  goto ldv_54354;
  case 14U: 
#line 616
  pDM_Odm->bWIFITest = Value != 0U;
#line 617
  goto ldv_54354;
  case 15U: 
#line 619
  pDM_Odm->bDualMacSmartConcurrent = Value != 0U;
#line 620
  goto ldv_54354;
  default: ;
#line 624
  goto ldv_54354;
  }
  ldv_54354: 
#line 631
  pDM_Odm->BbSwingIdxOfdm = 12U;
#line 632
  pDM_Odm->BbSwingIdxOfdmCurrent = 12U;
#line 633
  pDM_Odm->BbSwingFlagOfdm = 0;
#line 634
  return;
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM23a_CmnInfoHook(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo , void *pValue ) 
{ 


  {
#line 643
  switch ((unsigned int )CmnInfo) {
  case 16U: 
#line 646
  pDM_Odm->pMacPhyMode = (u8 *)pValue;
#line 647
  goto ldv_54378;
  case 17U: 
#line 649
  pDM_Odm->pNumTxBytesUnicast = (u64 *)pValue;
#line 650
  goto ldv_54378;
  case 18U: 
#line 652
  pDM_Odm->pNumRxBytesUnicast = (u64 *)pValue;
#line 653
  goto ldv_54378;
  case 19U: 
#line 655
  pDM_Odm->pWirelessMode = (u8 *)pValue;
#line 656
  goto ldv_54378;
  case 20U: 
#line 658
  pDM_Odm->pBandType = (u8 *)pValue;
#line 659
  goto ldv_54378;
  case 21U: 
#line 661
  pDM_Odm->pSecChOffset = (u8 *)pValue;
#line 662
  goto ldv_54378;
  case 22U: 
#line 664
  pDM_Odm->pSecurity = (u8 *)pValue;
#line 665
  goto ldv_54378;
  case 23U: 
#line 667
  pDM_Odm->pBandWidth = (u8 *)pValue;
#line 668
  goto ldv_54378;
  case 24U: 
#line 670
  pDM_Odm->pChannel = (u8 *)pValue;
#line 671
  goto ldv_54378;
  case 25U: 
#line 673
  pDM_Odm->pbGetValueFromOtherMac = (bool *)pValue;
#line 674
  goto ldv_54378;
  case 26U: 
#line 676
  pDM_Odm->pBuddyAdapter = (struct rtw_adapter **)pValue;
#line 677
  goto ldv_54378;
  case 27U: 
#line 679
  pDM_Odm->pbMasterOfDMSP = (bool *)pValue;
#line 680
  goto ldv_54378;
  case 28U: 
#line 682
  pDM_Odm->pbScanInProcess = (bool *)pValue;
#line 683
  goto ldv_54378;
  case 29U: 
#line 685
  pDM_Odm->pbPowerSaving = (bool *)pValue;
#line 686
  goto ldv_54378;
  case 30U: 
#line 688
  pDM_Odm->pOnePathCCA = (u8 *)pValue;
#line 689
  goto ldv_54378;
  case 31U: 
#line 691
  pDM_Odm->pbDriverStopped = (bool *)pValue;
#line 692
  goto ldv_54378;
  case 32U: 
#line 694
  pDM_Odm->pbDriverIsGoingToPnpSetPowerSleep = (bool *)pValue;
#line 695
  goto ldv_54378;
  case 33U: 
#line 697
  pDM_Odm->pinit_adpt_in_progress = (bool *)pValue;
#line 698
  goto ldv_54378;
  case 34U: 
#line 700
  pDM_Odm->pAntennaTest = (u8 *)pValue;
#line 701
  goto ldv_54378;
  case 35U: 
#line 703
  pDM_Odm->pbNet_closed = (bool *)pValue;
#line 704
  goto ldv_54378;
  default: ;
#line 708
  goto ldv_54378;
  }
  ldv_54378: ;
#line 711
  return;
}
}
#line 712 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_CmnInfoPtrArrayHook23a(struct dm_odm_t *pDM_Odm , enum odm_cmninfo CmnInfo ,
                                u16 Index , void *pValue ) 
{ 


  {
#line 716
  switch ((unsigned int )CmnInfo) {
  case 51U: 
#line 719
  pDM_Odm->pODM_StaInfo[(int )Index] = (struct sta_info *)pValue;
#line 720
  goto ldv_54406;
  default: ;
#line 724
  goto ldv_54406;
  }
  ldv_54406: ;
#line 727
  return;
}
}
#line 729 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_CmnInfoUpdate23a(struct dm_odm_t *pDM_Odm , u32 CmnInfo , u64 Value ) 
{ 


  {
#line 732
  switch (CmnInfo) {
  case 1U: 
#line 734
  pDM_Odm->SupportAbility = (unsigned int )Value;
#line 735
  goto ldv_54414;
  case 7U: 
#line 737
  pDM_Odm->RFType = (unsigned char )Value;
#line 738
  goto ldv_54414;
  case 37U: 
#line 740
  pDM_Odm->bWIFI_Direct = Value != 0ULL;
#line 741
  goto ldv_54414;
  case 38U: 
#line 743
  pDM_Odm->bWIFI_Display = Value != 0ULL;
#line 744
  goto ldv_54414;
  case 39U: 
#line 746
  pDM_Odm->bLinked = Value != 0ULL;
#line 747
  goto ldv_54414;
  case 40U: 
#line 749
  pDM_Odm->RSSI_Min = (unsigned char )Value;
#line 750
  goto ldv_54414;
  case 41U: 
#line 752
  pDM_Odm->DebugComponents = Value;
#line 753
  goto ldv_54414;
  case 42U: 
#line 755
  pDM_Odm->DebugLevel = (unsigned int )Value;
#line 756
  goto ldv_54414;
  case 43U: 
#line 758
  pDM_Odm->RateAdaptive.HighRSSIThresh = (unsigned char )Value;
#line 759
  goto ldv_54414;
  case 44U: 
#line 761
  pDM_Odm->RateAdaptive.LowRSSIThresh = (unsigned char )Value;
#line 762
  goto ldv_54414;
  }
  ldv_54414: ;
#line 766
  return;
}
}
#line 767 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_CommonInfoSelfInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 770
  tmp = ODM_GetBBReg(pDM_Odm, 2084U, 512U);
#line 770
  pDM_Odm->bCckHighPower = tmp != 0U;
#line 771
  tmp___0 = ODM_GetBBReg(pDM_Odm, 3076U, 15U);
#line 771
  pDM_Odm->RFPathRxEnable = (unsigned char )tmp___0;
#line 772
  if ((pDM_Odm->SupportICType & 8U) != 0U) {
#line 773
    pDM_Odm->AntDivType = 5U;
  } else {

  }
#line 775
  ODM_InitDebugSetting23a(pDM_Odm);
#line 776
  return;
}
}
#line 778 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_CommonInfoSelfUpdate23a(struct dm_odm_t *pDM_Odm ) 
{ 
  u8 EntryCnt ;
  u8 i ;
  struct sta_info *pEntry ;

  {
#line 780
  EntryCnt = 0U;
#line 784
  if ((unsigned int )*(pDM_Odm->pBandWidth) == 1U) {
#line 785
    if ((unsigned int )*(pDM_Odm->pSecChOffset) == 1U) {
#line 786
      pDM_Odm->ControlChannel = (unsigned int )*(pDM_Odm->pChannel) + 254U;
    } else
#line 787
    if ((unsigned int )*(pDM_Odm->pSecChOffset) == 2U) {
#line 788
      pDM_Odm->ControlChannel = (unsigned int )*(pDM_Odm->pChannel) + 2U;
    } else {

    }
  } else {
#line 790
    pDM_Odm->ControlChannel = *(pDM_Odm->pChannel);
  }
#line 793
  i = 0U;
#line 793
  goto ldv_54434;
  ldv_54433: 
#line 794
  pEntry = pDM_Odm->pODM_StaInfo[(int )i];
#line 795
  if ((unsigned long )pEntry != (unsigned long )((struct sta_info *)0)) {
#line 796
    EntryCnt = (u8 )((int )EntryCnt + 1);
  } else {

  }
#line 793
  i = (u8 )((int )i + 1);
  ldv_54434: ;
#line 793
  if ((unsigned int )i <= 31U) {
#line 795
    goto ldv_54433;
  } else {

  }

#line 798
  if ((unsigned int )EntryCnt == 1U) {
#line 799
    pDM_Odm->bOneEntryOnly = 1;
  } else {
#line 801
    pDM_Odm->bOneEntryOnly = 0;
  }
#line 802
  return;
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_CmnInfoInit_Debug23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 806
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 806
    printk("[ODM-8723A] ");
#line 806
    printk("%s(): odm_CmnInfoInit_Debug23a ==>\n", "odm_CmnInfoInit_Debug23a");
  } else {

  }
#line 807
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 807
    printk("[ODM-8723A] ");
#line 807
    printk("%s(): SupportAbility = 0x%x\n", "odm_CmnInfoInit_Debug23a", pDM_Odm->SupportAbility);
  } else {

  }
#line 808
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 808
    printk("[ODM-8723A] ");
#line 808
    printk("%s(): SupportInterface =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->SupportInterface);
  } else {

  }
#line 809
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 809
    printk("[ODM-8723A] ");
#line 809
    printk("%s(): SupportICType = 0x%x\n", "odm_CmnInfoInit_Debug23a", pDM_Odm->SupportICType);
  } else {

  }
#line 810
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 810
    printk("[ODM-8723A] ");
#line 810
    printk("%s(): CutVersion =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->CutVersion);
  } else {

  }
#line 811
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 811
    printk("[ODM-8723A] ");
#line 811
    printk("%s(): FabVersion =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->FabVersion);
  } else {

  }
#line 812
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 812
    printk("[ODM-8723A] ");
#line 812
    printk("%s(): RFType =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->RFType);
  } else {

  }
#line 813
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 813
    printk("[ODM-8723A] ");
#line 813
    printk("%s(): BoardType =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->BoardType);
  } else {

  }
#line 814
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 814
    printk("[ODM-8723A] ");
#line 814
    printk("%s(): ExtLNA =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtLNA);
  } else {

  }
#line 815
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 815
    printk("[ODM-8723A] ");
#line 815
    printk("%s(): ExtPA =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtPA);
  } else {

  }
#line 816
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 816
    printk("[ODM-8723A] ");
#line 816
    printk("%s(): ExtTRSW =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->ExtTRSW);
  } else {

  }
#line 817
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 817
    printk("[ODM-8723A] ");
#line 817
    printk("%s(): PatchID =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->PatchID);
  } else {

  }
#line 818
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 818
    printk("[ODM-8723A] ");
#line 818
    printk("%s(): bInHctTest =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bInHctTest);
  } else {

  }
#line 819
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 819
    printk("[ODM-8723A] ");
#line 819
    printk("%s(): bWIFITest =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bWIFITest);
  } else {

  }
#line 820
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 820
    printk("[ODM-8723A] ");
#line 820
    printk("%s(): bDualMacSmartConcurrent =%d\n", "odm_CmnInfoInit_Debug23a", (int )pDM_Odm->bDualMacSmartConcurrent);
  } else {

  }
#line 822
  return;
}
}
#line 824 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_CmnInfoHook_Debug23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 826
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 826
    printk("[ODM-8723A] ");
#line 826
    printk("%s(): odm_CmnInfoHook_Debug23a ==>\n", "odm_CmnInfoHook_Debug23a");
  } else {

  }
#line 827
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 827
    printk("[ODM-8723A] ");
#line 827
    printk("%s(): pNumTxBytesUnicast =%llu\n", "odm_CmnInfoHook_Debug23a", *(pDM_Odm->pNumTxBytesUnicast));
  } else {

  }
#line 828
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 828
    printk("[ODM-8723A] ");
#line 828
    printk("%s(): pNumRxBytesUnicast =%llu\n", "odm_CmnInfoHook_Debug23a", *(pDM_Odm->pNumRxBytesUnicast));
  } else {

  }
#line 829
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 829
    printk("[ODM-8723A] ");
#line 829
    printk("%s(): pWirelessMode = 0x%x\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pWirelessMode));
  } else {

  }
#line 830
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 830
    printk("[ODM-8723A] ");
#line 830
    printk("%s(): pSecChOffset =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pSecChOffset));
  } else {

  }
#line 831
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 831
    printk("[ODM-8723A] ");
#line 831
    printk("%s(): pSecurity =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pSecurity));
  } else {

  }
#line 832
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 832
    printk("[ODM-8723A] ");
#line 832
    printk("%s(): pBandWidth =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pBandWidth));
  } else {

  }
#line 833
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 833
    printk("[ODM-8723A] ");
#line 833
    printk("%s(): pChannel =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pChannel));
  } else {

  }
#line 835
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 835
    printk("[ODM-8723A] ");
#line 835
    printk("%s(): pbScanInProcess =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pbScanInProcess));
  } else {

  }
#line 836
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 836
    printk("[ODM-8723A] ");
#line 836
    printk("%s(): pbPowerSaving =%d\n", "odm_CmnInfoHook_Debug23a", (int )*(pDM_Odm->pbPowerSaving));
  } else {

  }
#line 838
  return;
}
}
#line 839 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_CmnInfoUpdate_Debug23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 841
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 841
    printk("[ODM-8723A] ");
#line 841
    printk("%s(): odm_CmnInfoUpdate_Debug23a ==>\n", "odm_CmnInfoUpdate_Debug23a");
  } else {

  }
#line 842
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 842
    printk("[ODM-8723A] ");
#line 842
    printk("%s(): bWIFI_Direct =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bWIFI_Direct);
  } else {

  }
#line 843
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 843
    printk("[ODM-8723A] ");
#line 843
    printk("%s(): bWIFI_Display =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bWIFI_Display);
  } else {

  }
#line 844
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 844
    printk("[ODM-8723A] ");
#line 844
    printk("%s(): bLinked =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->bLinked);
  } else {

  }
#line 845
  if ((pDM_Odm->DebugComponents & 1073741824ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 845
    printk("[ODM-8723A] ");
#line 845
    printk("%s(): RSSI_Min =%d\n", "odm_CmnInfoUpdate_Debug23a", (int )pDM_Odm->RSSI_Min);
  } else {

  }
#line 847
  return;
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_Write_DIG23a(struct dm_odm_t *pDM_Odm , u8 CurrentIGI ) 
{ 
  struct dig_t *pDM_DigTable ;

  {
#line 852
  pDM_DigTable = & pDM_Odm->DM_DigTable;
#line 854
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 854
    printk("[ODM-8723A] ");
#line 854
    printk("%s(): ODM_REG(IGI_A, pDM_Odm) = 0x%x, ODM_BIT(IGI, pDM_Odm) = 0x%x \n",
           "ODM_Write_DIG23a", 3152, (pDM_Odm->SupportICType & 31U) != 0U ? 127U : 4294967295U);
  } else {

  }
#line 857
  if ((int )pDM_DigTable->CurIGValue != (int )CurrentIGI) {
#line 858
    ODM_SetBBReg(pDM_Odm, 3152U, (pDM_Odm->SupportICType & 31U) != 0U ? 127U : 4294967295U,
                 (u32 )CurrentIGI);
#line 859
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 859
      printk("[ODM-8723A] ");
#line 859
      printk("%s(): CurrentIGI(0x%02x). \n", "ODM_Write_DIG23a", (int )CurrentIGI);
    } else {

    }
#line 860
    pDM_DigTable->CurIGValue = CurrentIGI;
  } else {

  }
#line 862
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 862
    printk("[ODM-8723A] ");
#line 862
    printk("%s(): ODM_Write_DIG23a():CurrentIGI = 0x%x \n", "ODM_Write_DIG23a", (int )CurrentIGI);
  } else {

  }
#line 864
  return;
}
}
#line 868 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_DIG23abyRSSI_LPS(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *pAdapter ;
  struct false_alarm_stats *pFalseAlmCnt ;
  u8 RSSI_Lower ;
  u8 bFwCurrentInPSMode ;
  u8 CurrentIGI ;

  {
#line 870
  pAdapter = pDM_Odm->Adapter;
#line 871
  pFalseAlmCnt = & pDM_Odm->FalseAlmCnt;
#line 872
  RSSI_Lower = 30U;
#line 873
  bFwCurrentInPSMode = 0U;
#line 874
  CurrentIGI = pDM_Odm->RSSI_Min;
#line 876
  if ((pDM_Odm->SupportICType & 8U) == 0U) {
#line 877
    return;
  } else {

  }
#line 879
  CurrentIGI = (unsigned int )CurrentIGI + 5U;
#line 880
  bFwCurrentInPSMode = pAdapter->pwrctrlpriv.bFwCurrentInPSMode;
#line 885
  if ((unsigned int )bFwCurrentInPSMode != 0U) {
#line 886
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 886
      printk("[ODM-8723A] ");
#line 886
      printk("%s(): ---Neil---odm_DIG23a is in LPS mode\n", "odm_DIG23abyRSSI_LPS");
    } else {

    }
#line 888
    if (pFalseAlmCnt->Cnt_all > 30U) {
#line 889
      CurrentIGI = (unsigned int )CurrentIGI + 2U;
    } else
#line 890
    if (pFalseAlmCnt->Cnt_all > 15U) {
#line 891
      CurrentIGI = (unsigned int )CurrentIGI + 1U;
    } else
#line 892
    if (pFalseAlmCnt->Cnt_all <= 3U) {
#line 893
      CurrentIGI = (unsigned int )CurrentIGI + 255U;
    } else {

    }
  } else {
#line 895
    CurrentIGI = RSSI_Lower;
  }
#line 901
  if ((int )pDM_Odm->RSSI_Min + -10 > 30) {
#line 902
    RSSI_Lower = (unsigned int )pDM_Odm->RSSI_Min + 246U;
  } else {
#line 904
    RSSI_Lower = 30U;
  }
#line 907
  if ((unsigned int )CurrentIGI > 78U) {
#line 908
    CurrentIGI = 78U;
  } else
#line 909
  if ((int )CurrentIGI < (int )RSSI_Lower) {
#line 910
    CurrentIGI = RSSI_Lower;
  } else {

  }
#line 912
  ODM_Write_DIG23a(pDM_Odm, (int )CurrentIGI);
#line 913
  return;
}
}
#line 916 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_DIG23aInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct dig_t *pDM_DigTable ;
  u32 tmp ;

  {
#line 918
  pDM_DigTable = & pDM_Odm->DM_DigTable;
#line 920
  tmp = ODM_GetBBReg(pDM_Odm, 3152U, (pDM_Odm->SupportICType & 31U) != 0U ? 127U : 4294967295U);
#line 920
  pDM_DigTable->CurIGValue = (unsigned char )tmp;
#line 921
  pDM_DigTable->RssiLowThresh = 35;
#line 922
  pDM_DigTable->RssiHighThresh = 40;
#line 923
  pDM_DigTable->FALowThresh = 400U;
#line 924
  pDM_DigTable->FAHighThresh = 1000U;
#line 925
  if ((unsigned int )pDM_Odm->BoardType == 1U) {
#line 926
    pDM_DigTable->rx_gain_range_max = 78U;
#line 927
    pDM_DigTable->rx_gain_range_min = 30U;
  } else {
#line 929
    pDM_DigTable->rx_gain_range_max = 78U;
#line 930
    pDM_DigTable->rx_gain_range_min = 30U;
  }
#line 932
  pDM_DigTable->BackoffVal = 10;
#line 933
  pDM_DigTable->BackoffVal_range_max = 12;
#line 934
  pDM_DigTable->BackoffVal_range_min = -4;
#line 935
  pDM_DigTable->PreCCK_CCAThres = 255U;
#line 936
  pDM_DigTable->CurCCK_CCAThres = 131U;
#line 937
  pDM_DigTable->ForbiddenIGI = 30U;
#line 938
  pDM_DigTable->LargeFAHit = 0U;
#line 939
  pDM_DigTable->Recover_cnt = 0U;
#line 940
  pDM_DigTable->DIG_Dynamic_MIN_0 = 30U;
#line 941
  pDM_DigTable->DIG_Dynamic_MIN_1 = 30U;
#line 942
  pDM_DigTable->bMediaConnect_0 = 0;
#line 943
  pDM_DigTable->bMediaConnect_1 = 0;
#line 946
  pDM_Odm->bDMInitialGainEnable = 1;
#line 947
  return;
}
}
#line 950 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_DIG23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct dig_t *pDM_DigTable ;
  struct false_alarm_stats *pFalseAlmCnt ;
  u8 DIG_Dynamic_MIN ;
  u8 DIG_MaxOfMin ;
  bool FirstConnect ;
  bool FirstDisConnect ;
  u8 dm_dig_max ;
  u8 dm_dig_min ;
  u8 CurrentIGI ;

  {
#line 953
  pDM_DigTable = & pDM_Odm->DM_DigTable;
#line 954
  pFalseAlmCnt = & pDM_Odm->FalseAlmCnt;
#line 959
  CurrentIGI = pDM_DigTable->CurIGValue;
#line 961
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 961
    printk("[ODM-8723A] ");
#line 961
    printk("%s(): odm_DIG23a() ==>\n", "odm_DIG23a");
  } else {

  }
#line 963
  if ((pDM_Odm->SupportAbility & 1U) == 0U || (pDM_Odm->SupportAbility & 8U) == 0U) {
#line 964
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 964
      printk("[ODM-8723A] ");
#line 964
      printk("%s(): odm_DIG23a() Return: SupportAbility ODM_BB_DIG or ODM_BB_FA_CNT is disabled\n",
             "odm_DIG23a");
    } else {

    }
#line 966
    return;
  } else {

  }
#line 969
  if ((int )*(pDM_Odm->pbScanInProcess)) {
#line 970
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 970
      printk("[ODM-8723A] ");
#line 970
      printk("%s(): odm_DIG23a() Return: In Scan Progress \n", "odm_DIG23a");
    } else {

    }
#line 971
    return;
  } else {

  }
#line 975
  if (! pDM_Odm->bDMInitialGainEnable) {
#line 976
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 976
      printk("[ODM-8723A] ");
#line 976
      printk("%s(): odm_DIG23a() Return: PSD is Processing \n", "odm_DIG23a");
    } else {

    }
#line 977
    return;
  } else {

  }
#line 980
  DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
#line 981
  FirstConnect = (bool )((int )pDM_Odm->bLinked && ! pDM_DigTable->bMediaConnect_0);
#line 982
  FirstDisConnect = (bool )(! pDM_Odm->bLinked && (int )pDM_DigTable->bMediaConnect_0);
#line 985
  if ((pDM_Odm->SupportICType & 8U) != 0U && ((unsigned int )pDM_Odm->BoardType == 1U || (unsigned int )pDM_Odm->ExtLNA != 0U)) {
#line 987
    dm_dig_max = 70U;
#line 988
    dm_dig_min = 46U;
#line 989
    DIG_MaxOfMin = 66U;
  } else {
#line 991
    dm_dig_max = 78U;
#line 992
    dm_dig_min = 30U;
#line 993
    DIG_MaxOfMin = 50U;
  }
#line 996
  if ((int )pDM_Odm->bLinked) {
#line 998
    if (pDM_Odm->SupportICType == 8U) {
#line 1000
      if ((int )pDM_Odm->RSSI_Min + 10 > 78) {
#line 1001
        pDM_DigTable->rx_gain_range_max = 78U;
      } else
#line 1002
      if ((int )pDM_Odm->RSSI_Min + 10 <= 29) {
#line 1003
        pDM_DigTable->rx_gain_range_max = 30U;
      } else {
#line 1005
        pDM_DigTable->rx_gain_range_max = (unsigned int )pDM_Odm->RSSI_Min + 10U;
      }
#line 1008
      DIG_Dynamic_MIN = 30U;
    } else {
#line 1011
      if ((int )pDM_Odm->RSSI_Min + 20 > (int )dm_dig_max) {
#line 1012
        pDM_DigTable->rx_gain_range_max = dm_dig_max;
      } else
#line 1013
      if ((int )pDM_Odm->RSSI_Min + 20 < (int )dm_dig_min) {
#line 1014
        pDM_DigTable->rx_gain_range_max = dm_dig_min;
      } else {
#line 1016
        pDM_DigTable->rx_gain_range_max = (unsigned int )pDM_Odm->RSSI_Min + 20U;
      }
#line 1019
      if ((int )pDM_Odm->bOneEntryOnly) {
#line 1020
        if ((int )pDM_Odm->RSSI_Min < (int )dm_dig_min) {
#line 1021
          DIG_Dynamic_MIN = dm_dig_min;
        } else
#line 1022
        if ((int )pDM_Odm->RSSI_Min > (int )DIG_MaxOfMin) {
#line 1023
          DIG_Dynamic_MIN = DIG_MaxOfMin;
        } else {
#line 1025
          DIG_Dynamic_MIN = pDM_Odm->RSSI_Min;
        }
#line 1026
        if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1026
          printk("[ODM-8723A] ");
#line 1026
          printk("%s(): odm_DIG23a() : bOneEntryOnly = true,  DIG_Dynamic_MIN = 0x%x\n",
                 "odm_DIG23a", (int )DIG_Dynamic_MIN);
        } else {

        }
#line 1029
        if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1029
          printk("[ODM-8723A] ");
#line 1029
          printk("%s(): odm_DIG23a() : pDM_Odm->RSSI_Min =%d\n", "odm_DIG23a", (int )pDM_Odm->RSSI_Min);
        } else {

        }
      } else {
#line 1033
        DIG_Dynamic_MIN = dm_dig_min;
      }
    }
  } else {
#line 1037
    pDM_DigTable->rx_gain_range_max = dm_dig_max;
#line 1038
    DIG_Dynamic_MIN = dm_dig_min;
#line 1039
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1039
      printk("[ODM-8723A] ");
#line 1039
      printk("%s(): odm_DIG23a() : No Link\n", "odm_DIG23a");
    } else {

    }
  }
#line 1043
  if (pFalseAlmCnt->Cnt_all > 10000U) {
#line 1044
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1044
      printk("[ODM-8723A] ");
#line 1044
      printk("%s(): dm_DIG(): Abnornally false alarm case. \n", "odm_DIG23a");
    } else {

    }
#line 1047
    if ((unsigned int )pDM_DigTable->LargeFAHit != 3U) {
#line 1048
      pDM_DigTable->LargeFAHit = (u8 )((int )pDM_DigTable->LargeFAHit + 1);
    } else {

    }
#line 1049
    if ((int )pDM_DigTable->ForbiddenIGI < (int )CurrentIGI) {
#line 1050
      pDM_DigTable->ForbiddenIGI = CurrentIGI;
#line 1051
      pDM_DigTable->LargeFAHit = 1U;
    } else {

    }
#line 1054
    if ((unsigned int )pDM_DigTable->LargeFAHit > 2U) {
#line 1055
      if ((int )pDM_DigTable->ForbiddenIGI + 1 > (int )pDM_DigTable->rx_gain_range_max) {
#line 1056
        pDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
      } else {
#line 1058
        pDM_DigTable->rx_gain_range_min = (unsigned int )pDM_DigTable->ForbiddenIGI + 1U;
      }
#line 1059
      pDM_DigTable->Recover_cnt = 3600U;
    } else {

    }
  } else
#line 1063
  if (pDM_DigTable->Recover_cnt != 0U) {
#line 1064
    pDM_DigTable->Recover_cnt = pDM_DigTable->Recover_cnt - 1U;
  } else
#line 1066
  if ((unsigned int )pDM_DigTable->LargeFAHit <= 2U) {
#line 1067
    if ((int )pDM_DigTable->ForbiddenIGI + -1 < (int )DIG_Dynamic_MIN) {
#line 1068
      pDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN;
#line 1069
      pDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;
#line 1070
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1070
        printk("[ODM-8723A] ");
#line 1070
        printk("%s(): odm_DIG23a(): Normal Case: At Lower Bound\n", "odm_DIG23a");
      } else {

      }
    } else {
#line 1073
      pDM_DigTable->ForbiddenIGI = (u8 )((int )pDM_DigTable->ForbiddenIGI - 1);
#line 1074
      pDM_DigTable->rx_gain_range_min = (unsigned int )pDM_DigTable->ForbiddenIGI + 1U;
#line 1075
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1075
        printk("[ODM-8723A] ");
#line 1075
        printk("%s(): odm_DIG23a(): Normal Case: Approach Lower Bound\n", "odm_DIG23a");
      } else {

      }
    }
  } else {
#line 1079
    pDM_DigTable->LargeFAHit = 0U;
  }
#line 1083
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1083
    printk("[ODM-8723A] ");
#line 1083
    printk("%s(): odm_DIG23a(): pDM_DigTable->LargeFAHit =%d\n", "odm_DIG23a", (int )pDM_DigTable->LargeFAHit);
  } else {

  }
#line 1086
  if ((int )pDM_Odm->bLinked) {
#line 1087
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1087
      printk("[ODM-8723A] ");
#line 1087
      printk("%s(): odm_DIG23a(): DIG AfterLink\n", "odm_DIG23a");
    } else {

    }
#line 1088
    if ((int )FirstConnect) {
#line 1089
      CurrentIGI = pDM_Odm->RSSI_Min;
#line 1090
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1090
        printk("[ODM-8723A] ");
#line 1090
        printk("%s(): DIG: First Connect\n", "odm_DIG23a");
      } else {

      }
    } else
#line 1092
    if (pFalseAlmCnt->Cnt_all > 1024U) {
#line 1093
      CurrentIGI = (unsigned int )CurrentIGI + 4U;
    } else
#line 1094
    if (pFalseAlmCnt->Cnt_all > 768U) {
#line 1095
      CurrentIGI = (unsigned int )CurrentIGI + 2U;
    } else
#line 1096
    if (pFalseAlmCnt->Cnt_all <= 511U) {
#line 1097
      CurrentIGI = (unsigned int )CurrentIGI + 254U;
    } else {

    }
  } else {
#line 1100
    if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1100
      printk("[ODM-8723A] ");
#line 1100
      printk("%s(): odm_DIG23a(): DIG BeforeLink\n", "odm_DIG23a");
    } else {

    }
#line 1101
    if ((int )FirstDisConnect) {
#line 1102
      CurrentIGI = pDM_DigTable->rx_gain_range_min;
#line 1103
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1103
        printk("[ODM-8723A] ");
#line 1103
        printk("%s(): odm_DIG23a(): First DisConnect \n", "odm_DIG23a");
      } else {

      }
    } else {
#line 1106
      if (pFalseAlmCnt->Cnt_all > 10000U) {
#line 1107
        CurrentIGI = (unsigned int )CurrentIGI + 2U;
      } else
#line 1108
      if (pFalseAlmCnt->Cnt_all > 8000U) {
#line 1109
        CurrentIGI = (unsigned int )CurrentIGI + 1U;
      } else
#line 1110
      if (pFalseAlmCnt->Cnt_all <= 499U) {
#line 1111
        CurrentIGI = (unsigned int )CurrentIGI + 255U;
      } else {

      }
#line 1112
      if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1112
        printk("[ODM-8723A] ");
#line 1112
        printk("%s(): odm_DIG23a(): England DIG \n", "odm_DIG23a");
      } else {

      }
    }
  }
#line 1115
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1115
    printk("[ODM-8723A] ");
#line 1115
    printk("%s(): odm_DIG23a(): DIG End Adjust IGI\n", "odm_DIG23a");
  } else {

  }
#line 1117
  if ((int )pDM_DigTable->rx_gain_range_max < (int )CurrentIGI) {
#line 1118
    CurrentIGI = pDM_DigTable->rx_gain_range_max;
  } else {

  }
#line 1119
  if ((int )pDM_DigTable->rx_gain_range_min > (int )CurrentIGI) {
#line 1120
    CurrentIGI = pDM_DigTable->rx_gain_range_min;
  } else {

  }
#line 1122
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1122
    printk("[ODM-8723A] ");
#line 1122
    printk("%s(): odm_DIG23a(): rx_gain_range_max = 0x%x, rx_gain_range_min = 0x%x\n",
           "odm_DIG23a", (int )pDM_DigTable->rx_gain_range_max, (int )pDM_DigTable->rx_gain_range_min);
  } else {

  }
#line 1124
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1124
    printk("[ODM-8723A] ");
#line 1124
    printk("%s(): odm_DIG23a(): TotalFA =%d\n", "odm_DIG23a", pFalseAlmCnt->Cnt_all);
  } else {

  }
#line 1125
  if ((int )pDM_Odm->DebugComponents & 1 && pDM_Odm->DebugLevel > 3U) {
#line 1125
    printk("[ODM-8723A] ");
#line 1125
    printk("%s(): odm_DIG23a(): CurIGValue = 0x%x\n", "odm_DIG23a", (int )CurrentIGI);
  } else {

  }
#line 1129
  ODM_Write_DIG23a(pDM_Odm, (int )CurrentIGI);
#line 1130
  pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
#line 1131
  pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
#line 1132
  return;
}
}
#line 1138 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_FalseAlarmCounterStatistics23a(struct dm_odm_t *pDM_Odm ) 
{ 
  u32 ret_value ;
  struct false_alarm_stats *FalseAlmCnt ;

  {
#line 1141
  FalseAlmCnt = & pDM_Odm->FalseAlmCnt;
#line 1143
  if ((pDM_Odm->SupportAbility & 8U) == 0U) {
#line 1144
    return;
  } else {

  }
#line 1146
  if ((pDM_Odm->SupportICType & 31U) != 0U) {
#line 1148
    ODM_SetBBReg(pDM_Odm, 3072U, 2147483648U, 1U);
#line 1149
    ODM_SetBBReg(pDM_Odm, 3328U, 2147483648U, 1U);
#line 1151
    ret_value = ODM_GetBBReg(pDM_Odm, 3312U, 4294967295U);
#line 1152
    FalseAlmCnt->Cnt_Fast_Fsync = ret_value & 65535U;
#line 1153
    FalseAlmCnt->Cnt_SB_Search_fail = ret_value >> 16;
#line 1154
    ret_value = ODM_GetBBReg(pDM_Odm, 3488U, 4294967295U);
#line 1155
    FalseAlmCnt->Cnt_OFDM_CCA = ret_value & 65535U;
#line 1156
    FalseAlmCnt->Cnt_Parity_Fail = ret_value >> 16;
#line 1157
    ret_value = ODM_GetBBReg(pDM_Odm, 3492U, 4294967295U);
#line 1158
    FalseAlmCnt->Cnt_Rate_Illegal = ret_value & 65535U;
#line 1159
    FalseAlmCnt->Cnt_Crc8_fail = ret_value >> 16;
#line 1160
    ret_value = ODM_GetBBReg(pDM_Odm, 3496U, 4294967295U);
#line 1161
    FalseAlmCnt->Cnt_Mcs_fail = ret_value & 65535U;
#line 1163
    FalseAlmCnt->Cnt_Ofdm_fail = ((((FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal) + FalseAlmCnt->Cnt_Crc8_fail) + FalseAlmCnt->Cnt_Mcs_fail) + FalseAlmCnt->Cnt_Fast_Fsync) + FalseAlmCnt->Cnt_SB_Search_fail;
#line 1170
    ODM_SetBBReg(pDM_Odm, 2604U, 4096U, 1U);
#line 1171
    ODM_SetBBReg(pDM_Odm, 2604U, 16384U, 1U);
#line 1173
    ret_value = ODM_GetBBReg(pDM_Odm, 2652U, 255U);
#line 1174
    FalseAlmCnt->Cnt_Cck_fail = ret_value;
#line 1175
    ret_value = ODM_GetBBReg(pDM_Odm, 2648U, 4278190080U);
#line 1176
    FalseAlmCnt->Cnt_Cck_fail = FalseAlmCnt->Cnt_Cck_fail + ((ret_value << 8) & 65535U);
#line 1178
    ret_value = ODM_GetBBReg(pDM_Odm, 2656U, 4294967295U);
#line 1179
    FalseAlmCnt->Cnt_CCK_CCA = ((ret_value << 8) & 65535U) | ((ret_value & 65280U) >> 8);
#line 1181
    FalseAlmCnt->Cnt_all = (((((FalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail) + FalseAlmCnt->Cnt_Parity_Fail) + FalseAlmCnt->Cnt_Rate_Illegal) + FalseAlmCnt->Cnt_Crc8_fail) + FalseAlmCnt->Cnt_Mcs_fail) + FalseAlmCnt->Cnt_Cck_fail;
#line 1189
    FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA + FalseAlmCnt->Cnt_CCK_CCA;
#line 1191
    if (pDM_Odm->SupportICType > 7U) {
#line 1193
      ODM_SetBBReg(pDM_Odm, 3084U, 2147483648U, 1U);
#line 1194
      ODM_SetBBReg(pDM_Odm, 3084U, 2147483648U, 0U);
#line 1195
      ODM_SetBBReg(pDM_Odm, 3328U, 134217728U, 1U);
#line 1196
      ODM_SetBBReg(pDM_Odm, 3328U, 134217728U, 0U);
#line 1198
      ODM_SetBBReg(pDM_Odm, 3072U, 2147483648U, 0U);
#line 1199
      ODM_SetBBReg(pDM_Odm, 3328U, 2147483648U, 0U);
#line 1202
      ODM_SetBBReg(pDM_Odm, 2604U, 12288U, 0U);
#line 1204
      ODM_SetBBReg(pDM_Odm, 2604U, 12288U, 2U);
#line 1207
      ODM_SetBBReg(pDM_Odm, 2604U, 49152U, 0U);
#line 1209
      ODM_SetBBReg(pDM_Odm, 2604U, 49152U, 2U);
    } else {

    }
#line 1213
    if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1213
      printk("[ODM-8723A] ");
#line 1213
      printk("%s(): Enter odm_FalseAlarmCounterStatistics23a\n", "odm_FalseAlarmCounterStatistics23a");
    } else {

    }
#line 1214
    if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1214
      printk("[ODM-8723A] ");
#line 1214
      printk("%s(): Cnt_Fast_Fsync =%d, Cnt_SB_Search_fail =%d\n", "odm_FalseAlarmCounterStatistics23a",
             FalseAlmCnt->Cnt_Fast_Fsync, FalseAlmCnt->Cnt_SB_Search_fail);
    } else {

    }
#line 1216
    if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1216
      printk("[ODM-8723A] ");
#line 1216
      printk("%s(): Cnt_Parity_Fail =%d, Cnt_Rate_Illegal =%d\n", "odm_FalseAlarmCounterStatistics23a",
             FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal);
    } else {

    }
#line 1218
    if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1218
      printk("[ODM-8723A] ");
#line 1218
      printk("%s(): Cnt_Crc8_fail =%d, Cnt_Mcs_fail =%d\n", "odm_FalseAlarmCounterStatistics23a",
             FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail);
    } else {

    }
  } else {
#line 1222
    FalseAlmCnt->Cnt_Ofdm_fail = ODM_GetBBReg(pDM_Odm, 3912U, 65535U);
#line 1223
    FalseAlmCnt->Cnt_Cck_fail = ODM_GetBBReg(pDM_Odm, 2652U, 65535U);
#line 1224
    FalseAlmCnt->Cnt_all = FalseAlmCnt->Cnt_Ofdm_fail + FalseAlmCnt->Cnt_Cck_fail;
#line 1227
    ODM_SetBBReg(pDM_Odm, 2468U, 131072U, 1U);
#line 1228
    ODM_SetBBReg(pDM_Odm, 2468U, 131072U, 0U);
#line 1230
    ODM_SetBBReg(pDM_Odm, 2604U, 32768U, 0U);
#line 1231
    ODM_SetBBReg(pDM_Odm, 2604U, 32768U, 1U);
  }
#line 1233
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1233
    printk("[ODM-8723A] ");
#line 1233
    printk("%s(): Cnt_Cck_fail =%d\n", "odm_FalseAlarmCounterStatistics23a", FalseAlmCnt->Cnt_Cck_fail);
  } else {

  }
#line 1234
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1234
    printk("[ODM-8723A] ");
#line 1234
    printk("%s(): Cnt_Ofdm_fail =%d\n", "odm_FalseAlarmCounterStatistics23a", FalseAlmCnt->Cnt_Ofdm_fail);
  } else {

  }
#line 1235
  if ((pDM_Odm->DebugComponents & 8ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1235
    printk("[ODM-8723A] ");
#line 1235
    printk("%s(): Total False Alarm =%d\n", "odm_FalseAlarmCounterStatistics23a",
           FalseAlmCnt->Cnt_all);
  } else {

  }
#line 1237
  return;
}
}
#line 1242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_CCKPacketDetectionThresh23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct false_alarm_stats *FalseAlmCnt ;
  u8 CurCCK_CCAThres ;

  {
#line 1244
  FalseAlmCnt = & pDM_Odm->FalseAlmCnt;
#line 1247
  if ((pDM_Odm->SupportAbility & 40U) == 0U) {
#line 1248
    return;
  } else {

  }
#line 1250
  if ((unsigned int )pDM_Odm->ExtLNA != 0U) {
#line 1251
    return;
  } else {

  }
#line 1253
  if ((int )pDM_Odm->bLinked) {
#line 1254
    if ((unsigned int )pDM_Odm->RSSI_Min > 25U) {
#line 1255
      CurCCK_CCAThres = 205U;
    } else
#line 1256
    if ((unsigned int )pDM_Odm->RSSI_Min <= 25U && (unsigned int )pDM_Odm->RSSI_Min > 10U) {
#line 1257
      CurCCK_CCAThres = 131U;
    } else
#line 1259
    if (FalseAlmCnt->Cnt_Cck_fail > 1000U) {
#line 1260
      CurCCK_CCAThres = 131U;
    } else {
#line 1262
      CurCCK_CCAThres = 64U;
    }
  } else
#line 1265
  if (FalseAlmCnt->Cnt_Cck_fail > 1000U) {
#line 1266
    CurCCK_CCAThres = 131U;
  } else {
#line 1268
    CurCCK_CCAThres = 64U;
  }
#line 1271
  ODM_Write_CCK_CCA_Thres23a(pDM_Odm, (int )CurCCK_CCAThres);
#line 1272
  return;
}
}
#line 1274 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_Write_CCK_CCA_Thres23a(struct dm_odm_t *pDM_Odm , u8 CurCCK_CCAThres ) 
{ 
  struct dig_t *pDM_DigTable ;

  {
#line 1276
  pDM_DigTable = & pDM_Odm->DM_DigTable;
#line 1278
  if ((int )pDM_DigTable->CurCCK_CCAThres != (int )CurCCK_CCAThres) {
#line 1279
    ODM_Write1Byte(pDM_Odm, 2570U, (int )CurCCK_CCAThres);
  } else {

  }
#line 1280
  pDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;
#line 1281
  pDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;
#line 1282
  return;
}
}
#line 1288 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm23a_DynBBPSInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct dynamic_pwr_sav *pDM_PSTable ;

  {
#line 1290
  pDM_PSTable = & pDM_Odm->DM_PSTable;
#line 1292
  pDM_PSTable->PreCCAState = 2U;
#line 1293
  pDM_PSTable->CurCCAState = 2U;
#line 1294
  pDM_PSTable->PreRFState = 2U;
#line 1295
  pDM_PSTable->CurRFState = 2U;
#line 1296
  pDM_PSTable->Rssi_val_min = 0;
#line 1297
  pDM_PSTable->initialize = 0U;
#line 1298
  return;
}
}
#line 1300 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_DynamicBBPowerSaving23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1302
  return;
}
}
#line 1305 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_1R_CCA23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct dynamic_pwr_sav *pDM_PSTable ;

  {
#line 1307
  pDM_PSTable = & pDM_Odm->DM_PSTable;
#line 1309
  if ((unsigned int )pDM_Odm->RSSI_Min != 255U) {
#line 1310
    if ((unsigned int )pDM_PSTable->PreCCAState == 1U) {
#line 1311
      if ((unsigned int )pDM_Odm->RSSI_Min > 34U) {
#line 1312
        pDM_PSTable->CurCCAState = 0U;
      } else {
#line 1314
        pDM_PSTable->CurCCAState = 1U;
      }
    } else
#line 1316
    if ((unsigned int )pDM_Odm->RSSI_Min <= 30U) {
#line 1317
      pDM_PSTable->CurCCAState = 1U;
    } else {
#line 1319
      pDM_PSTable->CurCCAState = 0U;
    }
  } else {
#line 1322
    pDM_PSTable->CurCCAState = 2U;
  }
#line 1325
  if ((int )pDM_PSTable->PreCCAState != (int )pDM_PSTable->CurCCAState) {
#line 1326
    if ((unsigned int )pDM_PSTable->CurCCAState == 0U) {
#line 1327
      if ((unsigned int )pDM_Odm->RFType == 2U) {
#line 1328
        ODM_SetBBReg(pDM_Odm, 3076U, 255U, 19U);
      } else {
#line 1330
        ODM_SetBBReg(pDM_Odm, 3076U, 255U, 35U);
      }
    } else {
#line 1332
      ODM_SetBBReg(pDM_Odm, 3076U, 255U, 51U);
    }
#line 1335
    pDM_PSTable->PreCCAState = pDM_PSTable->CurCCAState;
  } else {

  }
#line 1337
  return;
}
}
#line 1339 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_RF_Saving23a(struct dm_odm_t *pDM_Odm , u8 bForceInNormal ) 
{ 
  struct dynamic_pwr_sav *pDM_PSTable ;
  u8 Rssi_Up_bound ;
  u8 Rssi_Low_bound ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 1341
  pDM_PSTable = & pDM_Odm->DM_PSTable;
#line 1342
  Rssi_Up_bound = 30U;
#line 1343
  Rssi_Low_bound = 25U;
#line 1344
  if ((unsigned int )pDM_Odm->PatchID == 40U) {
#line 1345
    Rssi_Up_bound = 50U;
#line 1346
    Rssi_Low_bound = 45U;
  } else {

  }
#line 1348
  if ((unsigned int )pDM_PSTable->initialize == 0U) {
#line 1350
    tmp = ODM_GetBBReg(pDM_Odm, 2164U, 4294967295U);
#line 1350
    pDM_PSTable->Reg874 = (tmp & 1884160U) >> 14;
#line 1351
    tmp___0 = ODM_GetBBReg(pDM_Odm, 3184U, 4294967295U);
#line 1351
    pDM_PSTable->RegC70 = (u32 )(((unsigned long )tmp___0 & 8UL) >> 3);
#line 1353
    tmp___1 = ODM_GetBBReg(pDM_Odm, 2140U, 4294967295U);
#line 1353
    pDM_PSTable->Reg85C = tmp___1 >> 24;
#line 1354
    tmp___2 = ODM_GetBBReg(pDM_Odm, 2676U, 4294967295U);
#line 1354
    pDM_PSTable->RegA74 = (tmp___2 & 61440U) >> 12;
#line 1356
    pDM_PSTable->initialize = 1U;
  } else {

  }
#line 1359
  if ((unsigned int )bForceInNormal == 0U) {
#line 1360
    if ((unsigned int )pDM_Odm->RSSI_Min != 255U) {
#line 1361
      if ((unsigned int )pDM_PSTable->PreRFState == 1U) {
#line 1362
        if ((int )pDM_Odm->RSSI_Min >= (int )Rssi_Up_bound) {
#line 1363
          pDM_PSTable->CurRFState = 0U;
        } else {
#line 1365
          pDM_PSTable->CurRFState = 1U;
        }
      } else
#line 1367
      if ((int )pDM_Odm->RSSI_Min <= (int )Rssi_Low_bound) {
#line 1368
        pDM_PSTable->CurRFState = 1U;
      } else {
#line 1370
        pDM_PSTable->CurRFState = 0U;
      }
    } else {
#line 1373
      pDM_PSTable->CurRFState = 2U;
    }
  } else {
#line 1376
    pDM_PSTable->CurRFState = 1U;
  }
#line 1379
  if ((int )pDM_PSTable->PreRFState != (int )pDM_PSTable->CurRFState) {
#line 1380
    if ((unsigned int )pDM_PSTable->CurRFState == 0U) {
#line 1383
      if (pDM_Odm->SupportICType == 8U) {
#line 1384
        ODM_SetBBReg(pDM_Odm, 2164U, 32U, 1U);
      } else {

      }
#line 1385
      ODM_SetBBReg(pDM_Odm, 2164U, 1835008U, 2U);
#line 1386
      ODM_SetBBReg(pDM_Odm, 3184U, 8U, 0U);
#line 1387
      ODM_SetBBReg(pDM_Odm, 2140U, 4278190080U, 99U);
#line 1388
      ODM_SetBBReg(pDM_Odm, 2164U, 49152U, 2U);
#line 1389
      ODM_SetBBReg(pDM_Odm, 2676U, 61440U, 3U);
#line 1390
      ODM_SetBBReg(pDM_Odm, 2072U, 268435456U, 0U);
#line 1391
      ODM_SetBBReg(pDM_Odm, 2072U, 268435456U, 1U);
    } else {
#line 1393
      ODM_SetBBReg(pDM_Odm, 2164U, 1884160U, pDM_PSTable->Reg874);
#line 1394
      ODM_SetBBReg(pDM_Odm, 3184U, 8U, pDM_PSTable->RegC70);
#line 1395
      ODM_SetBBReg(pDM_Odm, 2140U, 4278190080U, pDM_PSTable->Reg85C);
#line 1396
      ODM_SetBBReg(pDM_Odm, 2676U, 61440U, pDM_PSTable->RegA74);
#line 1397
      ODM_SetBBReg(pDM_Odm, 2072U, 268435456U, 0U);
#line 1399
      if (pDM_Odm->SupportICType == 8U) {
#line 1400
        ODM_SetBBReg(pDM_Odm, 2164U, 32U, 0U);
      } else {

      }
    }
#line 1402
    pDM_PSTable->PreRFState = pDM_PSTable->CurRFState;
  } else {

  }
#line 1404
  return;
}
}
#line 1413 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RateAdaptiveMaskInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct odm_rate_adapt *pOdmRA ;

  {
#line 1415
  pOdmRA = & pDM_Odm->RateAdaptive;
#line 1417
  pOdmRA->Type = 1U;
#line 1418
  if ((unsigned int )pOdmRA->Type == 1U) {
#line 1419
    pDM_Odm->bUseRAMask = 1U;
  } else {
#line 1421
    pDM_Odm->bUseRAMask = 0U;
  }
#line 1423
  pOdmRA->RATRState = 0U;
#line 1424
  pOdmRA->HighRSSIThresh = 50U;
#line 1425
  pOdmRA->LowRSSIThresh = 20U;
#line 1426
  return;
}
}
#line 1428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
u32 ODM_Get_Rate_Bitmap23a(struct dm_odm_t *pDM_Odm , u32 macid , u32 ra_mask , u8 rssi_level ) 
{ 
  struct sta_info *pEntry ;
  u32 rate_bitmap ;
  u8 WirelessMode ;

  {
#line 1434
  rate_bitmap = 268435455U;
#line 1438
  pEntry = pDM_Odm->pODM_StaInfo[macid];
#line 1439
  if ((unsigned long )pEntry == (unsigned long )((struct sta_info *)0)) {
#line 1440
    return (ra_mask);
  } else {

  }
#line 1442
  WirelessMode = pEntry->wireless_mode;
#line 1444
  switch ((int )WirelessMode) {
  case 1: ;
#line 1446
  if ((ra_mask & 12U) != 0U) {
#line 1447
    rate_bitmap = 13U;
  } else {
#line 1449
    rate_bitmap = 15U;
  }
#line 1450
  goto ldv_54528;
  case 6: ;
#line 1452
  if ((unsigned int )rssi_level == 1U) {
#line 1453
    rate_bitmap = 3840U;
  } else {
#line 1455
    rate_bitmap = 4080U;
  }
#line 1456
  goto ldv_54528;
  case 3: ;
#line 1458
  if ((unsigned int )rssi_level == 1U) {
#line 1459
    rate_bitmap = 3840U;
  } else
#line 1460
  if ((unsigned int )rssi_level == 2U) {
#line 1461
    rate_bitmap = 4080U;
  } else {
#line 1463
    rate_bitmap = 4085U;
  }
#line 1464
  goto ldv_54528;
  case 11: ;
  case 15: ;
#line 1467
  if ((unsigned int )pDM_Odm->RFType == 1U || (unsigned int )pDM_Odm->RFType == 0U) {
#line 1468
    if ((unsigned int )rssi_level == 1U) {
#line 1469
      rate_bitmap = 983040U;
    } else
#line 1470
    if ((unsigned int )rssi_level == 2U) {
#line 1471
      rate_bitmap = 1044480U;
    } else
#line 1473
    if ((unsigned int )*(pDM_Odm->pBandWidth) == 1U) {
#line 1474
      rate_bitmap = 1044501U;
    } else {
#line 1476
      rate_bitmap = 1044485U;
    }
  } else
#line 1479
  if ((unsigned int )rssi_level == 1U) {
#line 1480
    rate_bitmap = 261029888U;
  } else
#line 1481
  if ((unsigned int )rssi_level == 2U) {
#line 1482
    rate_bitmap = 261091328U;
  } else
#line 1484
  if ((unsigned int )*(pDM_Odm->pBandWidth) == 1U) {
#line 1485
    rate_bitmap = 261091349U;
  } else {
#line 1487
    rate_bitmap = 261091333U;
  }
#line 1490
  goto ldv_54528;
  default: ;
#line 1494
  if ((unsigned int )pDM_Odm->RFType == 0U) {
#line 1495
    rate_bitmap = 1048575U;
  } else {
#line 1497
    rate_bitmap = 268435455U;
  }
#line 1498
  goto ldv_54528;
  }
  ldv_54528: ;
#line 1502
  if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1502
    printk("[ODM-8723A] ");
#line 1502
    printk("%s():  ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n",
           "ODM_Get_Rate_Bitmap23a", (int )rssi_level, (int )WirelessMode, rate_bitmap);
  } else {

  }
#line 1504
  return (rate_bitmap);
}
}
#line 1524 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RefreshRateAdaptiveMask23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1526
  if ((pDM_Odm->SupportAbility & 2U) == 0U) {
#line 1527
    return;
  } else {

  }
#line 1533
  odm_RefreshRateAdaptiveMask23aCE23a(pDM_Odm);
#line 1534
  return;
}
}
#line 1536 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RefreshRateAdaptiveMask23aMP23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1538
  return;
}
}
#line 1540 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RefreshRateAdaptiveMask23aCE23a(struct dm_odm_t *pDM_Odm ) 
{ 
  u8 i ;
  struct rtw_adapter *pAdapter ;
  struct sta_info *pstat ;
  bool tmp ;

  {
#line 1543
  pAdapter = pDM_Odm->Adapter;
#line 1545
  if (pAdapter->bDriverStopped != 0) {
#line 1546
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 4U) {
#line 1546
      printk("[ODM-8723A] ");
#line 1546
      printk("%s(): <---- odm_RefreshRateAdaptiveMask23a(): driver is going to unload\n",
             "odm_RefreshRateAdaptiveMask23aCE23a");
    } else {

    }
#line 1548
    return;
  } else {

  }
#line 1551
  if ((unsigned int )pDM_Odm->bUseRAMask == 0U) {
#line 1552
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1552
      printk("[ODM-8723A] ");
#line 1552
      printk("%s(): <---- odm_RefreshRateAdaptiveMask23a(): driver does not control rate adaptive mask\n",
             "odm_RefreshRateAdaptiveMask23aCE23a");
    } else {

    }
#line 1554
    return;
  } else {

  }
#line 1559
  i = 0U;
#line 1559
  goto ldv_54549;
  ldv_54548: 
#line 1560
  pstat = pDM_Odm->pODM_StaInfo[(int )i];
#line 1561
  if ((unsigned long )pstat != (unsigned long )((struct sta_info *)0)) {
#line 1562
    tmp = ODM_RAStateCheck23a(pDM_Odm, pstat->rssi_stat.UndecoratedSmoothedPWDB, 0,
                              & pstat->rssi_level);
#line 1562
    if ((int )tmp) {
#line 1563
      if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1563
        printk("[ODM-8723A] ");
#line 1563
        printk("%s(): RSSI:%d, RSSI_LEVEL:%d\n", "odm_RefreshRateAdaptiveMask23aCE23a",
               pstat->rssi_stat.UndecoratedSmoothedPWDB, (int )pstat->rssi_level);
      } else {

      }
#line 1567
      rtw_hal_update_ra_mask23a(pstat, (int )pstat->rssi_level);
    } else {

    }
  } else {

  }
#line 1559
  i = (u8 )((int )i + 1);
  ldv_54549: ;
#line 1559
  if ((unsigned int )i <= 31U) {
#line 1561
    goto ldv_54548;
  } else {

  }

#line 1566
  return;
}
}
#line 1575 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RefreshRateAdaptiveMask23aAPADSL23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1577
  return;
}
}
#line 1581 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
bool ODM_RAStateCheck23a(struct dm_odm_t *pDM_Odm , s32 RSSI , bool bForceUpdate ,
                         u8 *pRATRState ) 
{ 
  struct odm_rate_adapt *pRA ;
  u8 GoUpGap ;
  u8 HighRSSIThreshForRA ;
  u8 LowRSSIThreshForRA ;
  u8 RATRState ;

  {
#line 1584
  pRA = & pDM_Odm->RateAdaptive;
#line 1585
  GoUpGap = 5U;
#line 1586
  HighRSSIThreshForRA = pRA->HighRSSIThresh;
#line 1587
  LowRSSIThreshForRA = pRA->LowRSSIThresh;
#line 1593
  switch ((int )*pRATRState) {
  case 0: ;
  case 1: ;
#line 1596
  goto ldv_54567;
  case 2: 
#line 1598
  HighRSSIThreshForRA = (int )HighRSSIThreshForRA + (int )GoUpGap;
#line 1599
  goto ldv_54567;
  case 3: 
#line 1601
  HighRSSIThreshForRA = (int )HighRSSIThreshForRA + (int )GoUpGap;
#line 1602
  LowRSSIThreshForRA = (int )LowRSSIThreshForRA + (int )GoUpGap;
#line 1603
  goto ldv_54567;
  default: 
#line 1605
  printk("Assertion failed! %s at ......\n", (char *)"false");
#line 1605
  printk("      ......%s,%s,line=%d\n", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared",
         "ODM_RAStateCheck23a", 1605);
#line 1605
  printk("%s(): wrong rssi level setting %d !", "ODM_RAStateCheck23a", (int )*pRATRState);
#line 1606
  goto ldv_54567;
  }
  ldv_54567: ;
#line 1610
  if ((int )HighRSSIThreshForRA < RSSI) {
#line 1611
    RATRState = 1U;
  } else
#line 1612
  if ((int )LowRSSIThreshForRA < RSSI) {
#line 1613
    RATRState = 2U;
  } else {
#line 1615
    RATRState = 3U;
  }
#line 1617
  if ((int )*pRATRState != (int )RATRState || (int )bForceUpdate) {
#line 1618
    if ((pDM_Odm->DebugComponents & 2ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1618
      printk("[ODM-8723A] ");
#line 1618
      printk("%s(): RSSI Level %d -> %d\n", "ODM_RAStateCheck23a", (int )*pRATRState,
             (int )RATRState);
    } else {

    }
#line 1620
    *pRATRState = RATRState;
#line 1621
    return (1);
  } else {

  }
#line 1623
  return (0);
}
}
#line 1630 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_DynamicTxPower23aInit(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;

  {
#line 1632
  Adapter = pDM_Odm->Adapter;
#line 1633
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1634
  pdmpriv = & pHalData->dmpriv;
#line 1640
  pdmpriv->DynamicTxHighPowerLvl = 0U;
#line 1641
  return;
}
}
#line 1647 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RSSIMonitorInit(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1649
  return;
}
}
#line 1651 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RSSIMonitorCheck23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1656
  if ((pDM_Odm->SupportAbility & 16U) == 0U) {
#line 1657
    return;
  } else {

  }
#line 1662
  odm_RSSIMonitorCheck23aCE(pDM_Odm);
#line 1663
  return;
}
}
#line 1665 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RSSIMonitorCheck23aMP(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1667
  return;
}
}
#line 1670 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
static void FindMinimumRSSI(struct rtw_adapter *pAdapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;

  {
#line 1674
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 1675
  pdmpriv = & pHalData->dmpriv;
#line 1676
  pDM_Odm = & pHalData->odmpriv;
#line 1680
  if (! pDM_Odm->bLinked && pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0) {
#line 1682
    pdmpriv->MinUndecoratedPWDBForDM = 0;
  } else {
#line 1684
    pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
  }
#line 1685
  return;
}
}
#line 1687 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RSSIMonitorCheck23aCE(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  int i ;
  int tmpEntryMaxPWDB ;
  int tmpEntryMinPWDB ;
  u8 sta_cnt ;
  u32 PWDB_rssi[32U] ;
  unsigned int tmp ;
  struct sta_info *psta ;
  u8 tmp___0 ;

  {
#line 1689
  Adapter = pDM_Odm->Adapter;
#line 1690
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1691
  pdmpriv = & pHalData->dmpriv;
#line 1693
  tmpEntryMaxPWDB = 0;
#line 1693
  tmpEntryMinPWDB = 255;
#line 1694
  sta_cnt = 0U;
#line 1695
  PWDB_rssi[0] = 0U;
#line 1695
  tmp = 1U;
#line 1695
  while (1) {
#line 1695
    if (tmp >= 32U) {
#line 1695
      break;
    } else {

    }
#line 1695
    PWDB_rssi[tmp] = 0U;
#line 1695
    tmp = tmp + 1U;
  }
#line 1698
  if (! pDM_Odm->bLinked) {
#line 1699
    return;
  } else {

  }
#line 1701
  i = 0;
#line 1701
  goto ldv_54606;
  ldv_54605: 
#line 1702
  psta = pDM_Odm->pODM_StaInfo[i];
#line 1703
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 1704
    if (psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB) {
#line 1705
      tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
    } else {

    }
#line 1707
    if (psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB) {
#line 1708
      tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
    } else {

    }
#line 1710
    if (psta->rssi_stat.UndecoratedSmoothedPWDB != -1) {
#line 1711
      tmp___0 = sta_cnt;
#line 1711
      sta_cnt = (u8 )((int )sta_cnt + 1);
#line 1711
      PWDB_rssi[(int )tmp___0] = psta->mac_id | (uint )(psta->rssi_stat.UndecoratedSmoothedPWDB << 16);
    } else {

    }
  } else {

  }
#line 1701
  i = i + 1;
  ldv_54606: ;
#line 1701
  if (i <= 31) {
#line 1703
    goto ldv_54605;
  } else {

  }
#line 1715
  i = 0;
#line 1715
  goto ldv_54609;
  ldv_54608: ;
#line 1716
  if (PWDB_rssi[i] != 0U) {
#line 1717
    if ((unsigned int )pHalData->fw_ractrl != 0U) {
#line 1718
      rtl8723a_set_rssi_cmd(Adapter, (u8 *)(& PWDB_rssi) + (unsigned long )i);
    } else {

    }
  } else {

  }
#line 1715
  i = i + 1;
  ldv_54609: ;
#line 1715
  if ((int )sta_cnt > i) {
#line 1717
    goto ldv_54608;
  } else {

  }

#line 1722
  if (tmpEntryMaxPWDB != 0) {
#line 1723
    pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
  } else {
#line 1725
    pdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;
  }
#line 1727
  if (tmpEntryMinPWDB != 255) {
#line 1728
    pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
  } else {
#line 1730
    pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
  }
#line 1732
  FindMinimumRSSI(Adapter);
#line 1734
  ODM_CmnInfoUpdate23a(& pHalData->odmpriv, 40U, (u64 )pdmpriv->MinUndecoratedPWDBForDM);
#line 1735
  return;
}
}
#line 1737 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_RSSIMonitorCheck23aAP(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1739
  return;
}
}
#line 1746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_TXPowerTrackingInit23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1748
  odm_TXPowerTrackingThermalMeterInit23a(pDM_Odm);
#line 1749
  return;
}
}
#line 1751 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_TXPowerTrackingThermalMeterInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;

  {
#line 1753
  Adapter = pDM_Odm->Adapter;
#line 1754
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1755
  pdmpriv = & pHalData->dmpriv;
#line 1757
  pdmpriv->bTXPowerTracking = 1U;
#line 1758
  pdmpriv->TXPowercount = 0U;
#line 1759
  pdmpriv->bTXPowerTrackingInit = 0U;
#line 1760
  pdmpriv->TxPowerTrackControl = 1U;
#line 1761
  if (GlobalDebugLevel23A > 3U) {
#line 1761
    printk("\016RTL8723AU: pdmpriv->TxPowerTrackControl = %d\n", (int )pdmpriv->TxPowerTrackControl);
  } else {

  }
#line 1763
  pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = 1U;
#line 1764
  return;
}
}
#line 1766 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_TXPowerTrackingCheck23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1774
  odm_TXPowerTrackingCheckCE23a(pDM_Odm);
#line 1775
  return;
}
}
#line 1777 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_TXPowerTrackingCheckCE23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1779
  return;
}
}
#line 1781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_TXPowerTrackingCheckMP(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1783
  return;
}
}
#line 1785 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_TXPowerTrackingCheckAP(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1787
  return;
}
}
#line 1800 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_SwAntDivInit(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1802
  return;
}
}
#line 1804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_SwAntDivChkPerPktRssi(struct dm_odm_t *pDM_Odm , u8 StationID , struct phy_info *pPhyInfo ) 
{ 


  {
#line 1806
  return;
}
}
#line 1809 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_SwAntDivChkAntSwitch(struct dm_odm_t *pDM_Odm , u8 Step ) 
{ 


  {
#line 1811
  return;
}
}
#line 1813 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_SwAntDivRestAfterLink(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1815
  return;
}
}
#line 1817 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_SwAntDivChkAntSwitchCallback23a(unsigned long data ) 
{ 


  {
#line 1819
  return;
}
}
#line 1825 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_InitHybridAntDiv23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1827
  return;
}
}
#line 1829 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_HwAntDiv23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1831
  return;
}
}
#line 1834 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_EdcaTurboInit23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
#line 1837
  Adapter = pDM_Odm->Adapter;
#line 1838
  pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 0;
#line 1839
  pDM_Odm->DM_EDCA_Table.bIsCurRDLState = 0;
#line 1840
  Adapter->recvpriv.bIsAnyNonBEPkts = 0U;
#line 1842
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1842
    printk("[ODM-8723A] ");
#line 1842
    tmp = ODM_Read4Byte(pDM_Odm, 1280U);
#line 1842
    printk("%s(): Orginial VO PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp);
  } else {

  }
#line 1843
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1843
    printk("[ODM-8723A] ");
#line 1843
    tmp___0 = ODM_Read4Byte(pDM_Odm, 1284U);
#line 1843
    printk("%s(): Orginial VI PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___0);
  } else {

  }
#line 1844
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1844
    printk("[ODM-8723A] ");
#line 1844
    tmp___1 = ODM_Read4Byte(pDM_Odm, 1288U);
#line 1844
    printk("%s(): Orginial BE PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___1);
  } else {

  }
#line 1845
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1845
    printk("[ODM-8723A] ");
#line 1845
    tmp___2 = ODM_Read4Byte(pDM_Odm, 1292U);
#line 1845
    printk("%s(): Orginial BK PARAM: 0x%x\n", "ODM_EdcaTurboInit23a", tmp___2);
  } else {

  }
#line 1847
  return;
}
}
#line 1849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_EdcaTurboCheck23a(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 1857
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1857
    printk("[ODM-8723A] ");
#line 1857
    printk("%s(): odm_EdcaTurboCheck23a ========================>\n", "odm_EdcaTurboCheck23a");
  } else {

  }
#line 1859
  if ((pDM_Odm->SupportAbility & 65536U) == 0U) {
#line 1860
    return;
  } else {

  }
#line 1862
  odm_EdcaTurboCheck23aCE23a(pDM_Odm);
#line 1863
  if ((pDM_Odm->DebugComponents & 65536ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 1863
    printk("[ODM-8723A] ");
#line 1863
    printk("%s(): <======================== odm_EdcaTurboCheck23a\n", "odm_EdcaTurboCheck23a");
  } else {

  }
#line 1865
  return;
}
}
#line 1867 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_EdcaTurboCheck23aCE23a(struct dm_odm_t *pDM_Odm ) 
{ 
  struct rtw_adapter *Adapter ;
  u32 trafficIndex ;
  u32 edca_param ;
  u64 cur_tx_bytes ;
  u64 cur_rx_bytes ;
  u8 bbtchange ;
  struct hal_data_8723a *pHalData ;
  struct xmit_priv *pxmitpriv ;
  struct recv_priv *precvpriv ;
  struct registry_priv *pregpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;

  {
#line 1869
  Adapter = pDM_Odm->Adapter;
#line 1873
  cur_tx_bytes = 0ULL;
#line 1874
  cur_rx_bytes = 0ULL;
#line 1875
  bbtchange = 0U;
#line 1876
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1877
  pxmitpriv = & Adapter->xmitpriv;
#line 1878
  precvpriv = & Adapter->recvpriv;
#line 1879
  pregpriv = & Adapter->registrypriv;
#line 1880
  pmlmeext = & Adapter->mlmeextpriv;
#line 1881
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1883
  if ((unsigned int )pregpriv->wifi_spec == 1U) {
#line 1884
    goto dm_CheckEdcaTurbo_EXIT;
  } else {

  }
#line 1886
  if ((unsigned int )pmlmeinfo->assoc_AP_vendor > 16U) {
#line 1887
    goto dm_CheckEdcaTurbo_EXIT;
  } else {

  }
#line 1889
  tmp = rtl8723a_BT_disable_EDCA_turbo(Adapter);
#line 1889
  if ((int )tmp) {
#line 1890
    goto dm_CheckEdcaTurbo_EXIT;
  } else {

  }
#line 1893
  if ((unsigned int )bbtchange != 0U || precvpriv->bIsAnyNonBEPkts == 0U) {
#line 1894
    cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
#line 1895
    cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
#line 1898
    if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 4U || (unsigned int )pmlmeinfo->assoc_AP_vendor == 5U) {
#line 1900
      if (cur_rx_bytes << 2 < cur_tx_bytes) {
#line 1902
        trafficIndex = 0U;
      } else {
#line 1904
        trafficIndex = 1U;
      }
    } else
#line 1907
    if (cur_tx_bytes << 2 < cur_rx_bytes) {
#line 1909
      trafficIndex = 1U;
    } else {
#line 1911
      trafficIndex = 0U;
    }
#line 1915
    if (pDM_Odm->DM_EDCA_Table.prv_traffic_idx != trafficIndex || ! pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA) {
#line 1917
      if ((unsigned int )pmlmeinfo->assoc_AP_vendor == 6U && ((int )pmlmeext->cur_wireless_mode & 8) != 0) {
#line 1919
        edca_param = EDCAParam[(int )pmlmeinfo->assoc_AP_vendor][trafficIndex];
      } else {
#line 1921
        edca_param = EDCAParam[0][trafficIndex];
      }
#line 1922
      rtl8723au_write32(Adapter, 1288U, edca_param);
#line 1925
      pDM_Odm->DM_EDCA_Table.prv_traffic_idx = trafficIndex;
    } else {

    }
#line 1928
    pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 1;
  } else
#line 1932
  if ((int )pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA) {
#line 1933
    rtl8723au_write32(Adapter, 1288U, pHalData->AcParam_BE);
#line 1935
    pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = 0;
  } else {

  }
  dm_CheckEdcaTurbo_EXIT: 
#line 1941
  precvpriv->bIsAnyNonBEPkts = 0U;
#line 1942
  pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
#line 1943
  precvpriv->last_rx_bytes = precvpriv->rx_bytes;
#line 1944
  return;
}
}
#line 1946 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
u32 GetPSDData(struct dm_odm_t *pDM_Odm , unsigned int point , u8 initial_gain_psd ) 
{ 
  u32 psd_report ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 1951
  ODM_SetBBReg(pDM_Odm, 2056U, 1023U, point);
#line 1954
  ODM_SetBBReg(pDM_Odm, 2056U, 4194304U, 1U);
#line 1956
  __const_udelay(128850UL);
#line 1957
  ODM_SetBBReg(pDM_Odm, 2056U, 4194304U, 0U);
#line 1959
  tmp = ODM_GetBBReg(pDM_Odm, 2228U, 4294967295U);
#line 1959
  psd_report = tmp & 65535U;
#line 1961
  tmp___0 = ConvertTo_dB23a(psd_report);
#line 1961
  psd_report = (tmp___0 + (u32 )initial_gain_psd) + 4294967268U;
#line 1963
  return (psd_report);
}
}
#line 1967 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
u32 ConvertTo_dB23a(u32 Value ) 
{ 
  u8 i ;
  u8 j ;
  u32 dB ;

  {
#line 1974
  Value = Value & 65535U;
#line 1976
  i = 0U;
#line 1976
  goto ldv_54698;
  ldv_54697: ;
#line 1977
  if ((u32 )dB_Invert_Table[(int )i][11] >= Value) {
#line 1978
    goto ldv_54696;
  } else {

  }
#line 1976
  i = (u8 )((int )i + 1);
  ldv_54698: ;
#line 1976
  if ((unsigned int )i <= 7U) {
#line 1978
    goto ldv_54697;
  } else {

  }
  ldv_54696: ;
#line 1981
  if ((unsigned int )i > 7U) {
#line 1982
    return (96U);
  } else {

  }
#line 1984
  j = 0U;
#line 1984
  goto ldv_54701;
  ldv_54700: ;
#line 1985
  if ((u32 )dB_Invert_Table[(int )i][(int )j] >= Value) {
#line 1986
    goto ldv_54699;
  } else {

  }
#line 1984
  j = (u8 )((int )j + 1);
  ldv_54701: ;
#line 1984
  if ((unsigned int )j <= 11U) {
#line 1986
    goto ldv_54700;
  } else {

  }
  ldv_54699: 
#line 1989
  dB = (u32 )(((int )i * 12 + (int )j) + 1);
#line 1991
  return (dB);
}
}
#line 2000 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void ODM_SingleDualAntennaDefaultSetting(struct dm_odm_t *pDM_Odm ) 
{ 
  struct sw_ant_sw *pDM_SWAT_Table ;

  {
#line 2002
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
#line 2003
  pDM_SWAT_Table->ANTA_ON = 1;
#line 2004
  pDM_SWAT_Table->ANTB_ON = 1;
#line 2005
  return;
}
}
#line 2009 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
static void odm_PHY_SaveAFERegisters(struct dm_odm_t *pDM_Odm , u32 *AFEReg , u32 *AFEBackup ,
                                     u32 RegisterNum ) 
{ 
  u32 i ;

  {
#line 2019
  i = 0U;
#line 2019
  goto ldv_54714;
  ldv_54713: 
#line 2020
  *(AFEBackup + (unsigned long )i) = ODM_GetBBReg(pDM_Odm, *(AFEReg + (unsigned long )i),
                                                  4294967295U);
#line 2019
  i = i + 1U;
  ldv_54714: ;
#line 2019
  if (i < RegisterNum) {
#line 2021
    goto ldv_54713;
  } else {

  }

#line 2026
  return;
}
}
#line 2023 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
static void odm_PHY_ReloadAFERegisters(struct dm_odm_t *pDM_Odm , u32 *AFEReg , u32 *AFEBackup ,
                                       u32 RegiesterNum ) 
{ 
  u32 i ;

  {
#line 2028
  i = 0U;
#line 2028
  goto ldv_54724;
  ldv_54723: 
#line 2029
  ODM_SetBBReg(pDM_Odm, *(AFEReg + (unsigned long )i), 4294967295U, *(AFEBackup + (unsigned long )i));
#line 2028
  i = i + 1U;
  ldv_54724: ;
#line 2028
  if (i < RegiesterNum) {
#line 2030
    goto ldv_54723;
  } else {

  }

#line 2035
  return;
}
}
#line 2036 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
bool ODM_SingleDualAntennaDetection(struct dm_odm_t *pDM_Odm , u8 mode ) 
{ 
  struct sw_ant_sw *pDM_SWAT_Table ;
  u32 CurrentChannel ;
  u32 RfLoopReg ;
  u8 n ;
  u32 Reg88c ;
  u32 Regc08 ;
  u32 Reg874 ;
  u32 Regc50 ;
  u8 initial_gain ;
  u32 PSD_report_tmp ;
  u32 AntA_report ;
  u32 AntB_report ;
  u32 AntO_report ;
  bool bResult ;
  u32 AFE_Backup[16U] ;
  u32 AFE_REG_8723A[16U] ;

  {
#line 2038
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
#line 2042
  initial_gain = 90U;
#line 2044
  AntA_report = 0U;
#line 2044
  AntB_report = 0U;
#line 2044
  AntO_report = 0U;
#line 2045
  bResult = 1;
#line 2047
  AFE_REG_8723A[0] = 3696U;
#line 2047
  AFE_REG_8723A[1] = 3700U;
#line 2047
  AFE_REG_8723A[2] = 3704U;
#line 2047
  AFE_REG_8723A[3] = 3708U;
#line 2047
  AFE_REG_8723A[4] = 3712U;
#line 2047
  AFE_REG_8723A[5] = 3716U;
#line 2047
  AFE_REG_8723A[6] = 3720U;
#line 2047
  AFE_REG_8723A[7] = 3724U;
#line 2047
  AFE_REG_8723A[8] = 3792U;
#line 2047
  AFE_REG_8723A[9] = 3796U;
#line 2047
  AFE_REG_8723A[10] = 3800U;
#line 2047
  AFE_REG_8723A[11] = 3804U;
#line 2047
  AFE_REG_8723A[12] = 3808U;
#line 2047
  AFE_REG_8723A[13] = 3820U;
#line 2047
  AFE_REG_8723A[14] = 2140U;
#line 2047
  AFE_REG_8723A[15] = 3692U;
#line 2057
  if ((pDM_Odm->SupportICType & 8U) == 0U) {
#line 2058
    return (bResult);
  } else {

  }
#line 2060
  if ((pDM_Odm->SupportAbility & 64U) == 0U) {
#line 2061
    return (bResult);
  } else {

  }
#line 2064
  CurrentChannel = ODM_GetRFReg(pDM_Odm, 0, 24U, 1048575U);
#line 2065
  RfLoopReg = ODM_GetRFReg(pDM_Odm, 0, 0U, 1048575U);
#line 2066
  ODM_SetBBReg(pDM_Odm, 2144U, 768U, 1U);
#line 2069
  __const_udelay(42950UL);
#line 2072
  Reg88c = ODM_GetBBReg(pDM_Odm, 2188U, 4294967295U);
#line 2073
  Regc08 = ODM_GetBBReg(pDM_Odm, 3080U, 4294967295U);
#line 2074
  Reg874 = ODM_GetBBReg(pDM_Odm, 2164U, 4294967295U);
#line 2075
  Regc50 = ODM_GetBBReg(pDM_Odm, 3152U, 4294967295U);
#line 2078
  odm_PHY_SaveAFERegisters(pDM_Odm, (u32 *)(& AFE_REG_8723A), (u32 *)(& AFE_Backup),
                           16U);
#line 2081
  ODM_SetBBReg(pDM_Odm, 2056U, 49152U, 0U);
#line 2084
  ODM_SetRFReg(pDM_Odm, 0, 24U, 1048575U, 1U);
#line 2087
  ODM_SetBBReg(pDM_Odm, 3696U, 4294967295U, 1876632996U);
#line 2088
  ODM_SetBBReg(pDM_Odm, 3700U, 4294967295U, 1876632996U);
#line 2089
  ODM_SetBBReg(pDM_Odm, 3704U, 4294967295U, 1876632996U);
#line 2090
  ODM_SetBBReg(pDM_Odm, 3708U, 4294967295U, 1876632996U);
#line 2091
  ODM_SetBBReg(pDM_Odm, 3712U, 4294967295U, 1876632996U);
#line 2092
  ODM_SetBBReg(pDM_Odm, 3716U, 4294967295U, 1876632996U);
#line 2093
  ODM_SetBBReg(pDM_Odm, 3720U, 4294967295U, 1876632996U);
#line 2094
  ODM_SetBBReg(pDM_Odm, 3724U, 4294967295U, 1876632996U);
#line 2095
  ODM_SetBBReg(pDM_Odm, 3792U, 4294967295U, 1876632996U);
#line 2096
  ODM_SetBBReg(pDM_Odm, 3796U, 4294967295U, 1876632996U);
#line 2097
  ODM_SetBBReg(pDM_Odm, 3800U, 4294967295U, 1876632996U);
#line 2098
  ODM_SetBBReg(pDM_Odm, 3804U, 4294967295U, 1876632996U);
#line 2099
  ODM_SetBBReg(pDM_Odm, 3808U, 4294967295U, 1876632996U);
#line 2100
  ODM_SetBBReg(pDM_Odm, 3820U, 4294967295U, 1876632996U);
#line 2101
  ODM_SetBBReg(pDM_Odm, 2140U, 4294967295U, 1876632996U);
#line 2102
  ODM_SetBBReg(pDM_Odm, 3692U, 4294967295U, 1876632996U);
#line 2105
  ODM_SetBBReg(pDM_Odm, 2188U, 4294967295U, 3438280896U);
#line 2108
  ODM_SetBBReg(pDM_Odm, 3080U, 4294967295U, 524516U);
#line 2109
  ODM_SetBBReg(pDM_Odm, 2164U, 4294967295U, 572555264U);
#line 2112
  ODM_SetBBReg(pDM_Odm, 3632U, 4294967295U, 268471324U);
#line 2113
  ODM_SetBBReg(pDM_Odm, 3648U, 4294967295U, 16808960U);
#line 2116
  ODM_SetBBReg(pDM_Odm, 2920U, 4294967295U, 524288U);
#line 2117
  ODM_SetBBReg(pDM_Odm, 2920U, 4294967295U, 257949696U);
#line 2118
  ODM_SetBBReg(pDM_Odm, 3652U, 4294967295U, 16795648U);
#line 2119
  ODM_SetBBReg(pDM_Odm, 3636U, 4294967295U, 268471327U);
#line 2120
  ODM_SetBBReg(pDM_Odm, 3640U, 4294967295U, 2182414344U);
#line 2121
  ODM_SetBBReg(pDM_Odm, 3644U, 4294967295U, 672464904U);
#line 2122
  ODM_SetBBReg(pDM_Odm, 3660U, 4294967295U, 1059024U);
#line 2125
  ODM_SetRFReg(pDM_Odm, 0, 0U, 1048575U, 327688U);
#line 2128
  ODM_SetBBReg(pDM_Odm, 3624U, 4294967295U, 2155872256U);
#line 2129
  ODM_SetBBReg(pDM_Odm, 3656U, 4294967295U, 4160749568U);
#line 2130
  __const_udelay(4295000UL);
#line 2131
  PSD_report_tmp = 0U;
#line 2133
  n = 0U;
#line 2133
  goto ldv_54747;
  ldv_54746: 
#line 2134
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
#line 2135
  if (PSD_report_tmp > AntA_report) {
#line 2136
    AntA_report = PSD_report_tmp;
  } else {

  }
#line 2133
  n = (u8 )((int )n + 1);
  ldv_54747: ;
#line 2133
  if ((unsigned int )n <= 1U) {
#line 2135
    goto ldv_54746;
  } else {

  }
#line 2139
  PSD_report_tmp = 0U;
#line 2141
  ODM_SetBBReg(pDM_Odm, 2144U, 768U, 2U);
#line 2142
  __const_udelay(42950UL);
#line 2144
  n = 0U;
#line 2144
  goto ldv_54750;
  ldv_54749: 
#line 2145
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
#line 2146
  if (PSD_report_tmp > AntB_report) {
#line 2147
    AntB_report = PSD_report_tmp;
  } else {

  }
#line 2144
  n = (u8 )((int )n + 1);
  ldv_54750: ;
#line 2144
  if ((unsigned int )n <= 1U) {
#line 2146
    goto ldv_54749;
  } else {

  }
#line 2151
  ODM_SetBBReg(pDM_Odm, 2144U, 768U, 0U);
#line 2152
  __const_udelay(42950UL);
#line 2154
  n = 0U;
#line 2154
  goto ldv_54753;
  ldv_54752: 
#line 2155
  PSD_report_tmp = GetPSDData(pDM_Odm, 14U, (int )initial_gain);
#line 2156
  if (PSD_report_tmp > AntO_report) {
#line 2157
    AntO_report = PSD_report_tmp;
  } else {

  }
#line 2154
  n = (u8 )((int )n + 1);
  ldv_54753: ;
#line 2154
  if ((unsigned int )n <= 1U) {
#line 2156
    goto ldv_54752;
  } else {

  }
#line 2161
  ODM_SetBBReg(pDM_Odm, 3624U, 4294967295U, 0U);
#line 2162
  PSD_report_tmp = 0U;
#line 2165
  ODM_SetBBReg(pDM_Odm, 2144U, 768U, 1U);
#line 2166
  ODM_SetBBReg(pDM_Odm, 2188U, 4294967295U, Reg88c);
#line 2167
  ODM_SetBBReg(pDM_Odm, 3080U, 4294967295U, Regc08);
#line 2168
  ODM_SetBBReg(pDM_Odm, 2164U, 4294967295U, Reg874);
#line 2169
  ODM_SetBBReg(pDM_Odm, 3152U, 127U, 64U);
#line 2170
  ODM_SetBBReg(pDM_Odm, 3152U, 4294967295U, Regc50);
#line 2171
  ODM_SetRFReg(pDM_Odm, 0, 24U, 1048575U, CurrentChannel);
#line 2172
  ODM_SetRFReg(pDM_Odm, 0, 0U, 1048575U, RfLoopReg);
#line 2175
  odm_PHY_ReloadAFERegisters(pDM_Odm, (u32 *)(& AFE_REG_8723A), (u32 *)(& AFE_Backup),
                             16U);
#line 2177
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2177
    printk("[ODM-8723A] ");
#line 2177
    printk("%s(): psd_report_A[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntA_report);
  } else {

  }
#line 2178
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2178
    printk("[ODM-8723A] ");
#line 2178
    printk("%s(): psd_report_B[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntB_report);
  } else {

  }
#line 2179
  if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2179
    printk("[ODM-8723A] ");
#line 2179
    printk("%s(): psd_report_O[%d]= %d \n", "ODM_SingleDualAntennaDetection", 2416,
           AntO_report);
  } else {

  }
#line 2182
  if ((unsigned int )mode == 2U) {
#line 2183
    if (AntA_report > 99U) {
#line 2184
      if (AntA_report + 1U < AntB_report) {
#line 2185
        pDM_SWAT_Table->ANTB_ON = 0;
#line 2186
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2186
          printk("[ODM-8723A] ");
#line 2186
          printk("%s(): ODM_SingleDualAntennaDetection(): Single Antenna A\n", "ODM_SingleDualAntennaDetection");
        } else {

        }
      } else {
#line 2188
        pDM_SWAT_Table->ANTB_ON = 1;
#line 2189
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2189
          printk("[ODM-8723A] ");
#line 2189
          printk("%s(): ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n",
                 "ODM_SingleDualAntennaDetection");
        } else {

        }
      }
    } else {
#line 2192
      if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2192
        printk("[ODM-8723A] ");
#line 2192
        printk("%s(): ODM_SingleDualAntennaDetection(): Need to check again\n", "ODM_SingleDualAntennaDetection");
      } else {

      }
#line 2193
      pDM_SWAT_Table->ANTB_ON = 0;
#line 2194
      bResult = 0;
    }
  } else
#line 2196
  if ((unsigned int )mode == 0U) {
#line 2198
    if (AntO_report > 99U && AntO_report <= 117U) {
#line 2199
      if (AntO_report + 1U < AntA_report) {
#line 2200
        pDM_SWAT_Table->ANTA_ON = 0;
#line 2201
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2201
          printk("[ODM-8723A] ");
#line 2201
          printk("%s(): Ant A is OFF", "ODM_SingleDualAntennaDetection");
        } else {

        }
      } else {
#line 2203
        pDM_SWAT_Table->ANTA_ON = 1;
#line 2204
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2204
          printk("[ODM-8723A] ");
#line 2204
          printk("%s(): Ant A is ON", "ODM_SingleDualAntennaDetection");
        } else {

        }
      }
#line 2207
      if (AntO_report + 2U < AntB_report) {
#line 2208
        pDM_SWAT_Table->ANTB_ON = 0;
#line 2209
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2209
          printk("[ODM-8723A] ");
#line 2209
          printk("%s(): Ant B is OFF", "ODM_SingleDualAntennaDetection");
        } else {

        }
      } else {
#line 2211
        pDM_SWAT_Table->ANTB_ON = 1;
#line 2212
        if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2212
          printk("[ODM-8723A] ");
#line 2212
          printk("%s(): Ant B is ON", "ODM_SingleDualAntennaDetection");
        } else {

        }
      }
    } else {

    }
  } else {
#line 2216
    if ((pDM_Odm->DebugComponents & 64ULL) != 0ULL && pDM_Odm->DebugLevel > 3U) {
#line 2216
      printk("[ODM-8723A] ");
#line 2216
      printk("%s(): ODM_SingleDualAntennaDetection(): Need to check again\n", "ODM_SingleDualAntennaDetection");
    } else {

    }
#line 2217
    pDM_SWAT_Table->ANTA_ON = 1;
#line 2218
    pDM_SWAT_Table->ANTB_ON = 0;
#line 2219
    bResult = 0;
  }
#line 2221
  return (bResult);
}
}
#line 2225 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void odm_dtc(struct dm_odm_t *pDM_Odm ) 
{ 


  {
#line 2227
  return;
}
}
#line 2356 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
void *ldv_kmem_cache_alloc_1460(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2359
  ldv_check_alloc_flags(flags);
#line 2361
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2362
  return ((void *)0);
}
}
#line 2400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
int ldv_pskb_expand_head_1466(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2403
  ldv_check_alloc_flags(flags);
#line 2405
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2405
  return (tmp);
}
}
#line 2416 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
struct sk_buff *ldv_skb_clone_1468(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2419
  ldv_check_alloc_flags(flags);
#line 2421
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2421
  return (tmp);
}
}
#line 2432 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
struct sk_buff *ldv_skb_copy_1470(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2435
  ldv_check_alloc_flags(flags);
#line 2437
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2437
  return (tmp);
}
}
#line 2440 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1471(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2443
  ldv_check_alloc_flags(flags);
#line 2445
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2445
  return (tmp);
}
}
#line 2448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1472(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2451
  ldv_check_alloc_flags(flags);
#line 2453
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2453
  return (tmp);
}
}
#line 2456 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1473(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2459
  ldv_check_alloc_flags(flags);
#line 2461
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2461
  return (tmp);
}
}
#line 2464 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
int ldv_pskb_expand_head_1474(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2467
  ldv_check_alloc_flags(flags);
#line 2469
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2469
  return (tmp);
}
}
#line 2472 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
int ldv_pskb_expand_head_1475(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2475
  ldv_check_alloc_flags(flags);
#line 2477
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2477
  return (tmp);
}
}
#line 2480 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/odm.o.c.prepared"
struct sk_buff *ldv_skb_clone_1476(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2483
  ldv_check_alloc_flags(flags);
#line 2485
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2485
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1502(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1510(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1518(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1512(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1508(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1516(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1517(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1513(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1514(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1515(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 29 "drivers/staging/rtl8723au/include/rtw_ioctl_set.h"
s32 FillH2CCmd(struct rtw_adapter *padapter , u8 ElementID , u32 CmdLen , u8 *pCmdBuffer ) ;
#line 217 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
void rtl8723a_fill_fake_txdesc(struct rtw_adapter *padapter , u8 *pDesc , u32 BufferLen ,
                               u8 IsPsPoll , u8 IsBTQosNull ) ;
#line 148 "drivers/staging/rtl8723au/include/rtl8723a_cmd.h"
void rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(struct rtw_adapter *padapter ) ;
#line 153
int rtl8723a_set_raid_cmd(struct rtw_adapter *padapter , u32 mask , u8 arg ) ;
#line 154
void rtl8723a_add_rateatid(struct rtw_adapter *pAdapter , u32 bitmap , u8 arg , u8 rssi_level ) ;
#line 156
void CheckFwRsvdPageContent23a(struct rtw_adapter *Adapter ) ;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
static u8 _is_fw_read_cmd_down(struct rtw_adapter *padapter , u8 msgbox_num ) 
{ 
  u8 read_down ;
  int retry_cnts ;
  u8 valid ;
  u8 tmp ;
  int tmp___0 ;

  {
#line 250
  read_down = 0U;
#line 251
  retry_cnts = 100;
  ldv_54292: 
#line 255
  tmp = rtl8723au_read8(padapter, 460U);
#line 255
  valid = (int )tmp & (int )((u8 )(1UL << (int )msgbox_num));
#line 256
  if ((unsigned int )valid == 0U) {
#line 257
    read_down = 1U;
  } else {

  }
#line 258
  if ((unsigned int )read_down == 0U) {
#line 258
    tmp___0 = retry_cnts;
#line 258
    retry_cnts = retry_cnts - 1;
#line 258
    if (tmp___0 != 0) {
#line 260
      goto ldv_54292;
    } else {
#line 263
      goto ldv_54293;
    }
  } else {

  }
  ldv_54293: ;
#line 260
  return (read_down);
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
s32 FillH2CCmd(struct rtw_adapter *padapter , u8 ElementID , u32 CmdLen , u8 *pCmdBuffer ) 
{ 
  u8 bcmd_down ;
  s32 retry_cnts ;
  u8 h2c_box_num ;
  u32 msgbox_addr ;
  u32 msgbox_ex_addr ;
  struct hal_data_8723a *pHalData ;
  u32 h2c_cmd ;
  u16 h2c_cmd_ex ;
  int ret ;
  u8 tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  s32 tmp___0 ;

  {
#line 272
  bcmd_down = 0U;
#line 273
  retry_cnts = 100;
#line 277
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 278
  h2c_cmd = 0U;
#line 279
  h2c_cmd_ex = 0U;
#line 280
  ret = 0;
#line 282
  padapter = (padapter->dvobj)->if1;
#line 283
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 285
  mutex_lock_nested(& (padapter->dvobj)->h2c_fwcmd_mutex, 0U);
#line 287
  if ((unsigned long )pCmdBuffer == (unsigned long )((u8 *)0U)) {
#line 288
    goto exit;
  } else {

  }
#line 289
  if (CmdLen > 5U) {
#line 290
    goto exit;
  } else {

  }
#line 291
  if (padapter->bSurpriseRemoved == 1) {
#line 292
    goto exit;
  } else {

  }
  ldv_54319: 
#line 296
  h2c_box_num = pHalData->LastHMEBoxNum;
#line 298
  tmp = _is_fw_read_cmd_down(padapter, (int )h2c_box_num);
#line 298
  if ((unsigned int )tmp == 0U) {
#line 299
    if (GlobalDebugLevel23A > 3U) {
#line 299
      printk("\016RTL8723AU:  fw read cmd failed...\n");
    } else {

    }
#line 300
    goto exit;
  } else {

  }
#line 303
  if (CmdLen <= 3U) {
#line 304
    __len = (size_t )CmdLen;
#line 304
    __ret = __builtin_memcpy((void *)(& h2c_cmd) + 1U, (void const   *)pCmdBuffer,
                             __len);
  } else {
#line 306
    __len___0 = 2UL;
#line 306
    if (__len___0 > 63UL) {
#line 306
      __ret___0 = __memcpy((void *)(& h2c_cmd_ex), (void const   *)pCmdBuffer, __len___0);
    } else {
#line 306
      __ret___0 = __builtin_memcpy((void *)(& h2c_cmd_ex), (void const   *)pCmdBuffer,
                                   __len___0);
    }
#line 307
    __len___1 = (size_t )(CmdLen - 2U);
#line 307
    __ret___1 = __builtin_memcpy((void *)(& h2c_cmd) + 1U, (void const   *)pCmdBuffer + 2U,
                                 __len___1);
#line 308
    *((u8 *)(& h2c_cmd)) = (u8 )((unsigned int )*((u8 *)(& h2c_cmd)) | 128U);
  }
#line 311
  *((u8 *)(& h2c_cmd)) = (u8 )((int )*((u8 *)(& h2c_cmd)) | (int )ElementID);
#line 313
  if (((unsigned long )h2c_cmd & 128UL) != 0UL) {
#line 314
    msgbox_ex_addr = (u32 )(((int )h2c_box_num + 68) * 2);
#line 315
    h2c_cmd_ex = h2c_cmd_ex;
#line 316
    rtl8723au_write16(padapter, msgbox_ex_addr, (int )h2c_cmd_ex);
  } else {

  }
#line 318
  msgbox_addr = (u32 )(((int )h2c_box_num + 116) * 4);
#line 319
  h2c_cmd = h2c_cmd;
#line 320
  rtl8723au_write32(padapter, msgbox_addr, h2c_cmd);
#line 322
  bcmd_down = 1U;
#line 324
  pHalData->LastHMEBoxNum = (u8 )(((int )h2c_box_num + 1) % 4);
#line 326
  if ((unsigned int )bcmd_down == 0U) {
#line 326
    tmp___0 = retry_cnts;
#line 326
    retry_cnts = retry_cnts - 1;
#line 326
    if (tmp___0 != 0) {
#line 328
      goto ldv_54319;
    } else {
#line 331
      goto ldv_54320;
    }
  } else {

  }
  ldv_54320: 
#line 328
  ret = 1;
  exit: 
#line 331
  mutex_unlock(& (padapter->dvobj)->h2c_fwcmd_mutex);
#line 332
  return (ret);
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
int rtl8723a_set_rssi_cmd(struct rtw_adapter *padapter , u8 *param ) 
{ 
  int res ;

  {
#line 337
  res = 1;
#line 339
  *((u32 *)param) = *((u32 *)param);
#line 341
  FillH2CCmd(padapter, 5, 3U, param);
#line 343
  return (res);
}
}
#line 346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
int rtl8723a_set_raid_cmd(struct rtw_adapter *padapter , u32 mask , u8 arg ) 
{ 
  u8 buf[5U] ;
  int res ;
  size_t __len ;
  void *__ret ;

  {
#line 349
  res = 1;
#line 351
  memset((void *)(& buf), 0, 5UL);
#line 352
  mask = mask;
#line 353
  __len = 4UL;
#line 353
  if (__len > 63UL) {
#line 353
    __ret = __memcpy((void *)(& buf), (void const   *)(& mask), __len);
  } else {
#line 353
    __ret = __builtin_memcpy((void *)(& buf), (void const   *)(& mask), __len);
  }
#line 354
  buf[4] = arg;
#line 356
  FillH2CCmd(padapter, 6, 5U, (u8 *)(& buf));
#line 358
  return (res);
}
}
#line 365 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
void rtl8723a_add_rateatid(struct rtw_adapter *pAdapter , u32 bitmap , u8 arg , u8 rssi_level ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 macid ;
  u8 raid ;
  u8 init_rate ;
  u8 shortGIrate ;
  unsigned char tmp ;

  {
#line 367
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 368
  macid = (unsigned int )arg & 31U;
#line 369
  raid = (u8 )(bitmap >> 28);
#line 371
  bitmap = bitmap & 268435455U;
#line 372
  if ((unsigned int )rssi_level != 0U) {
#line 373
    bitmap = ODM_Get_Rate_Bitmap23a(& pHalData->odmpriv, (u32 )macid, bitmap, (int )rssi_level);
  } else {

  }
#line 375
  bitmap = (u32 )((int )raid << 28) | bitmap;
#line 377
  if ((unsigned int )pHalData->fw_ractrl == 1U) {
#line 378
    rtl8723a_set_raid_cmd(pAdapter, bitmap, (int )arg);
  } else {
#line 380
    shortGIrate = 0U;
#line 382
    tmp = get_highest_rate_idx23a(bitmap & 268435455U);
#line 382
    init_rate = (unsigned int )tmp & 63U;
#line 384
    shortGIrate = ((unsigned long )arg & 32UL) != 0UL;
#line 386
    if ((unsigned int )shortGIrate == 1U) {
#line 387
      init_rate = (u8 )((unsigned int )init_rate | 64U);
    } else {

    }
#line 389
    rtl8723au_write8(pAdapter, (u32 )((int )macid + 1156), (int )init_rate);
  }
#line 391
  return;
}
}
#line 394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
void rtl8723a_set_FwPwrMode_cmd(struct rtw_adapter *padapter , u8 Mode ) 
{ 
  struct setpwrmode_parm H2CSetPwrMode ;
  struct pwrctrl_priv *pwrpriv ;
  struct hal_data_8723a *pHalData ;

  {
#line 397
  pwrpriv = & padapter->pwrctrlpriv;
#line 398
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 400
  if (GlobalDebugLevel23A > 3U) {
#line 400
    printk("\016RTL8723AU: %s: Mode =%d SmartPS =%d UAPSD =%d BcnMode = 0x%02x\n",
           "rtl8723a_set_FwPwrMode_cmd", (int )Mode, (int )pwrpriv->smart_ps, (int )padapter->registrypriv.uapsd_enable,
           (int )pwrpriv->bcn_ant_mode);
  } else {

  }
#line 407
  if ((unsigned int )Mode != 0U && (((unsigned int )pHalData->VersionID.ICType != 2U && (unsigned int )pHalData->VersionID.ICType != 1U) || (unsigned int )pHalData->VersionID.RFType != 2U)) {
#line 409
    ODM_RF_Saving23a(& pHalData->odmpriv, 1);
  } else {

  }
#line 412
  H2CSetPwrMode.Mode = Mode;
#line 413
  H2CSetPwrMode.SmartPS = pwrpriv->smart_ps;
#line 414
  H2CSetPwrMode.AwakeInterval = 1U;
#line 415
  H2CSetPwrMode.bAllQueueUAPSD = padapter->registrypriv.uapsd_enable;
#line 416
  H2CSetPwrMode.BcnAntMode = pwrpriv->bcn_ant_mode;
#line 418
  FillH2CCmd(padapter, 1, 5U, (u8 *)(& H2CSetPwrMode));
#line 419
  return;
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
static void ConstructBeacon(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  u32 rate_len ;
  u32 pktlen ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  u8 bc_addr[6U] ;
  int bcn_fixed_size ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp ;
  u8 *tmp___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  size_t __len___2 ;
  void *__ret___2 ;
  __le16 *tmp___3 ;
  __le16 *tmp___4 ;
  size_t __len___3 ;
  void *__ret___3 ;
  __le16 *tmp___5 ;
  __le16 *tmp___6 ;
  size_t __len___4 ;
  void *__ret___4 ;
  u32 ATIMWindow ;

  {
#line 426
  pmlmeext = & padapter->mlmeextpriv;
#line 427
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 428
  cur_network = & pmlmeinfo->network;
#line 429
  bc_addr[0] = 255U;
#line 429
  bc_addr[1] = 255U;
#line 429
  bc_addr[2] = 255U;
#line 429
  bc_addr[3] = 255U;
#line 429
  bc_addr[4] = 255U;
#line 429
  bc_addr[5] = 255U;
#line 434
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 436
  pwlanhdr->frame_control = 128U;
#line 439
  __len = 6UL;
#line 439
  if (__len > 63UL) {
#line 439
    __ret = __memcpy((void *)(& pwlanhdr->addr1), (void const   *)(& bc_addr), __len);
  } else {
#line 439
    __ret = __builtin_memcpy((void *)(& pwlanhdr->addr1), (void const   *)(& bc_addr),
                             __len);
  }
#line 440
  __len___0 = 6UL;
#line 440
  if (__len___0 > 63UL) {
#line 440
    tmp = myid(& padapter->eeprompriv);
#line 440
    __ret___0 = __memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp, __len___0);
  } else {
#line 440
    tmp___0 = myid(& padapter->eeprompriv);
#line 440
    __ret___0 = __builtin_memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___0,
                                 __len___0);
  }
#line 441
  __len___1 = 6UL;
#line 441
  if (__len___1 > 63UL) {
#line 441
    tmp___1 = get_my_bssid23a(cur_network);
#line 441
    __ret___1 = __memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___1, __len___1);
  } else {
#line 441
    tmp___2 = get_my_bssid23a(cur_network);
#line 441
    __ret___1 = __builtin_memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___2,
                                 __len___1);
  }
#line 444
  pwlanhdr->seq_ctrl = 0U;
#line 446
  pframe = pframe + 24UL;
#line 447
  pktlen = 24U;
#line 450
  pframe = pframe + 8UL;
#line 451
  pktlen = pktlen + 8U;
#line 454
  __len___2 = 2UL;
#line 454
  if (__len___2 > 63UL) {
#line 454
    tmp___3 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
#line 454
    __ret___2 = __memcpy((void *)pframe, (void const   *)tmp___3, __len___2);
  } else {
#line 454
    tmp___4 = rtw_get_beacon_interval23a_from_ie((u8 *)(& cur_network->IEs));
#line 454
    __ret___2 = __builtin_memcpy((void *)pframe, (void const   *)tmp___4, __len___2);
  }
#line 456
  pframe = pframe + 2UL;
#line 457
  pktlen = pktlen + 2U;
#line 460
  __len___3 = 2UL;
#line 460
  if (__len___3 > 63UL) {
#line 460
    tmp___5 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
#line 460
    __ret___3 = __memcpy((void *)pframe, (void const   *)tmp___5, __len___3);
  } else {
#line 460
    tmp___6 = rtw_get_capability23a_from_ie((u8 *)(& cur_network->IEs));
#line 460
    __ret___3 = __builtin_memcpy((void *)pframe, (void const   *)tmp___6, __len___3);
  }
#line 462
  pframe = pframe + 2UL;
#line 463
  pktlen = pktlen + 2U;
#line 465
  if ((pmlmeinfo->state & 3U) == 3U) {
#line 466
    bcn_fixed_size = 12;
#line 471
    pktlen = (cur_network->IELength - (u32 )bcn_fixed_size) + pktlen;
#line 472
    __len___4 = (size_t )pktlen;
#line 472
    __ret___4 = __builtin_memcpy((void *)pframe, (void const   *)(& cur_network->IEs) + (unsigned long )bcn_fixed_size,
                                 __len___4);
#line 474
    goto _ConstructBeacon;
  } else {

  }
#line 480
  pframe = rtw_set_ie23a(pframe, 0, (uint )cur_network->Ssid.ssid_len, (u8 const   *)(& cur_network->Ssid.ssid),
                         & pktlen);
#line 485
  rate_len = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 486
  pframe = rtw_set_ie23a(pframe, 1, 8U < rate_len ? 8U : rate_len, (u8 const   *)(& cur_network->SupportedRates),
                         & pktlen);
#line 490
  pframe = rtw_set_ie23a(pframe, 3, 1U, (u8 const   *)(& cur_network->DSConfig), & pktlen);
#line 493
  if ((pmlmeinfo->state & 3U) == 1U) {
#line 497
    ATIMWindow = 0U;
#line 498
    pframe = rtw_set_ie23a(pframe, 6, 2U, (u8 const   *)(& ATIMWindow), & pktlen);
  } else {

  }
#line 505
  if (rate_len > 8U) {
#line 506
    pframe = rtw_set_ie23a(pframe, 50, rate_len - 8U, (u8 const   *)(& cur_network->SupportedRates) + 8U,
                           & pktlen);
  } else {

  }
  _ConstructBeacon: ;
#line 515
  if (pktlen + 32U > 512U) {
#line 516
    if (GlobalDebugLevel23A > 3U) {
#line 516
      printk("\016RTL8723AU: beacon frame too large\n");
    } else {

    }
#line 517
    return;
  } else {

  }
#line 520
  *pLength = pktlen;
#line 521
  return;
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
static void ConstructPSPoll(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;
  u8 *tmp ;
  u8 *tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;

  {
#line 530
  pmlmeext = & padapter->mlmeextpriv;
#line 531
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 533
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 536
  pwlanhdr->frame_control = 164U;
#line 538
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
#line 541
  pwlanhdr->duration_id = (unsigned int )pmlmeinfo->aid | 49152U;
#line 544
  __len = 6UL;
#line 544
  if (__len > 63UL) {
#line 544
    tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 544
    __ret = __memcpy((void *)(& pwlanhdr->addr1), (void const   *)tmp, __len);
  } else {
#line 544
    tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 544
    __ret = __builtin_memcpy((void *)(& pwlanhdr->addr1), (void const   *)tmp___0,
                             __len);
  }
#line 547
  __len___0 = 6UL;
#line 547
  if (__len___0 > 63UL) {
#line 547
    tmp___1 = myid(& padapter->eeprompriv);
#line 547
    __ret___0 = __memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___1, __len___0);
  } else {
#line 547
    tmp___2 = myid(& padapter->eeprompriv);
#line 547
    __ret___0 = __builtin_memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___2,
                                 __len___0);
  }
#line 549
  *pLength = 16U;
#line 550
  return;
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
static void ConstructNullFunctionData(struct rtw_adapter *padapter , u8 *pframe ,
                                      u32 *pLength , u8 *StaAddr , u8 bQoS , u8 AC ,
                                      u8 bEosp , u8 bForcePowerSave ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  u32 pktlen ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  size_t __len ;
  void *__ret ;
  u8 *tmp ;
  u8 *tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  size_t __len___4 ;
  void *__ret___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  size_t __len___5 ;
  void *__ret___5 ;
  size_t __len___6 ;
  void *__ret___6 ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  size_t __len___7 ;
  void *__ret___7 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  struct ieee80211_qos_hdr *qoshdr ;

  {
#line 559
  pmlmepriv = & padapter->mlmepriv;
#line 560
  cur_network = & pmlmepriv->cur_network;
#line 561
  pmlmeext = & padapter->mlmeextpriv;
#line 562
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 564
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 566
  pwlanhdr->frame_control = 0U;
#line 567
  pwlanhdr->seq_ctrl = 0U;
#line 569
  if ((unsigned int )bForcePowerSave != 0U) {
#line 570
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 4096U);
  } else {

  }
#line 572
  switch ((unsigned int )cur_network->network.ifmode) {
  case 8U: ;
  case 2U: 
#line 575
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 256U);
#line 576
  __len = 6UL;
#line 576
  if (__len > 63UL) {
#line 576
    tmp = get_my_bssid23a(& pmlmeinfo->network);
#line 576
    __ret = __memcpy((void *)(& pwlanhdr->addr1), (void const   *)tmp, __len);
  } else {
#line 576
    tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 576
    __ret = __builtin_memcpy((void *)(& pwlanhdr->addr1), (void const   *)tmp___0,
                             __len);
  }
#line 578
  __len___0 = 6UL;
#line 578
  if (__len___0 > 63UL) {
#line 578
    tmp___1 = myid(& padapter->eeprompriv);
#line 578
    __ret___0 = __memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___1, __len___0);
  } else {
#line 578
    tmp___2 = myid(& padapter->eeprompriv);
#line 578
    __ret___0 = __builtin_memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___2,
                                 __len___0);
  }
#line 580
  __len___1 = 6UL;
#line 580
  if (__len___1 > 63UL) {
#line 580
    __ret___1 = __memcpy((void *)(& pwlanhdr->addr3), (void const   *)StaAddr, __len___1);
  } else {
#line 580
    __ret___1 = __builtin_memcpy((void *)(& pwlanhdr->addr3), (void const   *)StaAddr,
                                 __len___1);
  }
#line 581
  goto ldv_54429;
  case 9U: ;
  case 3U: 
#line 584
  pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 512U);
#line 585
  __len___2 = 6UL;
#line 585
  if (__len___2 > 63UL) {
#line 585
    __ret___2 = __memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr, __len___2);
  } else {
#line 585
    __ret___2 = __builtin_memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr,
                                 __len___2);
  }
#line 586
  __len___3 = 6UL;
#line 586
  if (__len___3 > 63UL) {
#line 586
    tmp___3 = get_my_bssid23a(& pmlmeinfo->network);
#line 586
    __ret___3 = __memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___3, __len___3);
  } else {
#line 586
    tmp___4 = get_my_bssid23a(& pmlmeinfo->network);
#line 586
    __ret___3 = __builtin_memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___4,
                                 __len___3);
  }
#line 588
  __len___4 = 6UL;
#line 588
  if (__len___4 > 63UL) {
#line 588
    tmp___5 = myid(& padapter->eeprompriv);
#line 588
    __ret___4 = __memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___5, __len___4);
  } else {
#line 588
    tmp___6 = myid(& padapter->eeprompriv);
#line 588
    __ret___4 = __builtin_memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___6,
                                 __len___4);
  }
#line 590
  goto ldv_54429;
  case 1U: ;
  default: 
#line 593
  __len___5 = 6UL;
#line 593
  if (__len___5 > 63UL) {
#line 593
    __ret___5 = __memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr, __len___5);
  } else {
#line 593
    __ret___5 = __builtin_memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr,
                                 __len___5);
  }
#line 594
  __len___6 = 6UL;
#line 594
  if (__len___6 > 63UL) {
#line 594
    tmp___7 = myid(& padapter->eeprompriv);
#line 594
    __ret___6 = __memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___7, __len___6);
  } else {
#line 594
    tmp___8 = myid(& padapter->eeprompriv);
#line 594
    __ret___6 = __builtin_memcpy((void *)(& pwlanhdr->addr2), (void const   *)tmp___8,
                                 __len___6);
  }
#line 595
  __len___7 = 6UL;
#line 595
  if (__len___7 > 63UL) {
#line 595
    tmp___9 = get_my_bssid23a(& pmlmeinfo->network);
#line 595
    __ret___7 = __memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___9, __len___7);
  } else {
#line 595
    tmp___10 = get_my_bssid23a(& pmlmeinfo->network);
#line 595
    __ret___7 = __builtin_memcpy((void *)(& pwlanhdr->addr3), (void const   *)tmp___10,
                                 __len___7);
  }
#line 597
  goto ldv_54429;
  }
  ldv_54429: ;
#line 600
  if ((unsigned int )bQoS == 1U) {
#line 602
    qoshdr = (struct ieee80211_qos_hdr *)pframe;
#line 604
    qoshdr->frame_control = (__le16 )((unsigned int )qoshdr->frame_control | 200U);
#line 608
    qoshdr->qos_ctrl = (unsigned int )((unsigned short )AC) & 15U;
#line 609
    if ((unsigned int )bEosp != 0U) {
#line 610
      qoshdr->qos_ctrl = (__le16 )((unsigned int )qoshdr->qos_ctrl | 16U);
    } else {

    }
#line 612
    pktlen = 26U;
  } else {
#line 614
    pwlanhdr->frame_control = (__le16 )((unsigned int )pwlanhdr->frame_control | 72U);
#line 618
    pktlen = 24U;
  }
#line 621
  *pLength = pktlen;
#line 622
  return;
}
}
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
static void ConstructProbeRsp(struct rtw_adapter *padapter , u8 *pframe , u32 *pLength ,
                              u8 *StaAddr , bool bHideSSID ) 
{ 
  struct ieee80211_hdr *pwlanhdr ;
  u8 *mac ;
  u8 *bssid ;
  u32 pktlen ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;

  {
#line 630
  pmlmeext = & padapter->mlmeextpriv;
#line 631
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 632
  cur_network = & pmlmeinfo->network;
#line 636
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 638
  mac = myid(& padapter->eeprompriv);
#line 639
  bssid = (u8 *)(& cur_network->MacAddress);
#line 641
  pwlanhdr->frame_control = 80U;
#line 644
  pwlanhdr->seq_ctrl = 0U;
#line 646
  __len = 6UL;
#line 646
  if (__len > 63UL) {
#line 646
    __ret = __memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr, __len);
  } else {
#line 646
    __ret = __builtin_memcpy((void *)(& pwlanhdr->addr1), (void const   *)StaAddr,
                             __len);
  }
#line 647
  __len___0 = 6UL;
#line 647
  if (__len___0 > 63UL) {
#line 647
    __ret___0 = __memcpy((void *)(& pwlanhdr->addr2), (void const   *)mac, __len___0);
  } else {
#line 647
    __ret___0 = __builtin_memcpy((void *)(& pwlanhdr->addr2), (void const   *)mac,
                                 __len___0);
  }
#line 648
  __len___1 = 6UL;
#line 648
  if (__len___1 > 63UL) {
#line 648
    __ret___1 = __memcpy((void *)(& pwlanhdr->addr3), (void const   *)bssid, __len___1);
  } else {
#line 648
    __ret___1 = __builtin_memcpy((void *)(& pwlanhdr->addr3), (void const   *)bssid,
                                 __len___1);
  }
#line 650
  pktlen = 24U;
#line 651
  pframe = pframe + (unsigned long )pktlen;
#line 653
  if (cur_network->IELength > 768U) {
#line 654
    return;
  } else {

  }
#line 656
  __len___2 = (size_t )cur_network->IELength;
#line 656
  __ret___2 = __builtin_memcpy((void *)pframe, (void const   *)(& cur_network->IEs),
                               __len___2);
#line 657
  pframe = pframe + (unsigned long )cur_network->IELength;
#line 658
  pktlen = cur_network->IELength + pktlen;
#line 660
  *pLength = pktlen;
#line 661
  return;
}
}
#line 664 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
void CheckFwRsvdPageContent23a(struct rtw_adapter *Adapter ) 
{ 


  {
#line 666
  return;
}
}
#line 678 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
static void SetFwRsvdPagePkt(struct rtw_adapter *padapter , bool bDLFinished ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u32 BeaconLength ;
  u32 ProbeRspLength ;
  u32 PSPollLength ;
  u32 NullDataLength ;
  u32 QosNullLength ;
  u32 BTQosNullLength ;
  u8 *ReservedPagePacket ;
  u8 PageNum ;
  u8 PageNeed ;
  u8 TxDescLen ;
  u16 BufIndex ;
  u32 TotalPacketLen ;
  struct rsvdpage_loc RsvdPageLoc ;
  void *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u32 tmp___4 ;
  size_t __len ;
  void *__ret ;

  {
#line 686
  BeaconLength = 0U;
#line 686
  ProbeRspLength = 0U;
#line 694
  if (GlobalDebugLevel23A > 3U) {
#line 694
    printk("\016RTL8723AU: %s\n", "SetFwRsvdPagePkt");
  } else {

  }
#line 696
  tmp = kzalloc(1000UL, 208U);
#line 696
  ReservedPagePacket = (u8 *)tmp;
#line 697
  if ((unsigned long )ReservedPagePacket == (unsigned long )((u8 *)0U)) {
#line 698
    if (GlobalDebugLevel23A > 3U) {
#line 698
      printk("\016RTL8723AU: %s: alloc ReservedPagePacket fail!\n", "SetFwRsvdPagePkt");
    } else {

    }
#line 699
    return;
  } else {

  }
#line 702
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 703
  pxmitpriv = & padapter->xmitpriv;
#line 704
  pmlmeext = & padapter->mlmeextpriv;
#line 705
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 707
  TxDescLen = 32U;
#line 708
  PageNum = 0U;
#line 711
  BufIndex = 40U;
#line 712
  ConstructBeacon(padapter, ReservedPagePacket + (unsigned long )BufIndex, & BeaconLength);
#line 716
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + BeaconLength) >> 7)) + ((((u32 )TxDescLen + BeaconLength) & 127U) != 0U ? 1U : 0U);
#line 718
  if ((unsigned int )PageNeed == 1U) {
#line 719
    PageNeed = (unsigned int )PageNeed + 1U;
  } else {

  }
#line 720
  PageNum = (int )PageNum + (int )PageNeed;
#line 721
  pHalData->FwRsvdPageStartOffset = PageNum;
#line 723
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 726
  RsvdPageLoc.LocPsPoll = PageNum;
#line 727
  ConstructPSPoll(padapter, ReservedPagePacket + (unsigned long )BufIndex, & PSPollLength);
#line 728
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            PSPollLength, 1, 0);
#line 730
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + PSPollLength) >> 7)) + ((((u32 )TxDescLen + PSPollLength) & 127U) != 0U ? 1U : 0U);
#line 731
  PageNum = (int )PageNum + (int )PageNeed;
#line 733
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 736
  RsvdPageLoc.LocNullData = PageNum;
#line 737
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 737
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & NullDataLength, tmp___0, 0, 0, 0, 0);
#line 741
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            NullDataLength, 0, 0);
#line 745
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + NullDataLength) >> 7)) + ((((u32 )TxDescLen + NullDataLength) & 127U) != 0U ? 1U : 0U);
#line 746
  PageNum = (int )PageNum + (int )PageNeed;
#line 748
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 751
  RsvdPageLoc.LocProbeRsp = PageNum;
#line 752
  tmp___1 = get_my_bssid23a(& pmlmeinfo->network);
#line 752
  ConstructProbeRsp(padapter, ReservedPagePacket + (unsigned long )BufIndex, & ProbeRspLength,
                    tmp___1, 0);
#line 758
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            ProbeRspLength, 0, 0);
#line 760
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + ProbeRspLength) >> 7)) + ((((u32 )TxDescLen + ProbeRspLength) & 127U) != 0U ? 1U : 0U);
#line 761
  PageNum = (int )PageNum + (int )PageNeed;
#line 763
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 766
  RsvdPageLoc.LocQosNull = PageNum;
#line 767
  tmp___2 = get_my_bssid23a(& pmlmeinfo->network);
#line 767
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & QosNullLength, tmp___2, 1, 0, 0, 0);
#line 773
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            QosNullLength, 0, 0);
#line 775
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + QosNullLength) >> 7)) + ((((u32 )TxDescLen + QosNullLength) & 127U) != 0U ? 1U : 0U);
#line 776
  PageNum = (int )PageNum + (int )PageNeed;
#line 778
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 781
  RsvdPageLoc.LocBTQosNull = PageNum;
#line 782
  tmp___3 = get_my_bssid23a(& pmlmeinfo->network);
#line 782
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & BTQosNullLength, tmp___3, 1, 0, 0, 0);
#line 788
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            BTQosNullLength, 0, 1);
#line 790
  TotalPacketLen = (u32 )BufIndex + BTQosNullLength;
#line 792
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 793
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 794
    goto exit;
  } else {

  }
#line 797
  pattrib = & pmgntframe->attrib;
#line 798
  update_mgntframe_attrib23a(padapter, pattrib);
#line 799
  pattrib->qsel = 16U;
#line 800
  tmp___4 = TotalPacketLen - 40U;
#line 800
  pattrib->last_txcmdsz = tmp___4;
#line 800
  pattrib->pktlen = tmp___4;
#line 801
  __len = (size_t )TotalPacketLen;
#line 801
  __ret = __builtin_memcpy((void *)pmgntframe->buf_addr, (void const   *)ReservedPagePacket,
                           __len);
#line 803
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 805
  if (GlobalDebugLevel23A > 3U) {
#line 805
    printk("\016RTL8723AU: %s: Set RSVD page location to Fw\n", "SetFwRsvdPagePkt");
  } else {

  }
#line 806
  FillH2CCmd(padapter, 3, 5U, (u8 *)(& RsvdPageLoc));
  exit: 
#line 809
  kfree((void const   *)ReservedPagePacket);
#line 810
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
void rtl8723a_set_FwJoinBssReport_cmd(struct rtw_adapter *padapter , u8 mstatus ) 
{ 
  struct joinbssrpt_parm JoinBssRptParm ;
  struct hal_data_8723a *pHalData ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool bRecover ;
  u8 v8 ;

  {
#line 815
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 816
  pmlmeext = & padapter->mlmeextpriv;
#line 817
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 819
  if (GlobalDebugLevel23A > 3U) {
#line 819
    printk("\016RTL8723AU: %s mstatus(%x)\n", "rtl8723a_set_FwJoinBssReport_cmd",
           (int )mstatus);
  } else {

  }
#line 821
  if ((unsigned int )mstatus == 1U) {
#line 822
    bRecover = 0;
#line 827
    rtl8723au_write16(padapter, 1704U, (int )((unsigned int )pmlmeinfo->aid | 49152U));
#line 836
    v8 = rtl8723au_read8(padapter, 257U);
#line 837
    v8 = (u8 )((unsigned int )v8 | 1U);
#line 838
    rtl8723au_write8(padapter, 257U, (int )v8);
#line 845
    SetBcnCtrlReg23a(padapter, 16, 8);
#line 848
    if (((unsigned long )pHalData->RegFwHwTxQCtrl & 64UL) != 0UL) {
#line 849
      bRecover = 1;
    } else {

    }
#line 853
    rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl & 191);
#line 855
    pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
#line 856
    SetFwRsvdPagePkt(padapter, 0);
#line 859
    SetBcnCtrlReg23a(padapter, 8, 16);
#line 866
    if ((int )bRecover) {
#line 867
      rtl8723au_write8(padapter, 1058U, (int )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U));
#line 869
      pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
    } else {

    }
#line 873
    v8 = rtl8723au_read8(padapter, 257U);
#line 874
    v8 = (unsigned int )v8 & 254U;
#line 875
    rtl8723au_write8(padapter, 257U, (int )v8);
  } else {

  }
#line 878
  JoinBssRptParm.OpMode = mstatus;
#line 880
  FillH2CCmd(padapter, 2, 1U, (u8 *)(& JoinBssRptParm));
#line 881
  return;
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
static void SetFwRsvdPagePkt_BTCoex(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 fakemac[6U] ;
  u32 NullDataLength ;
  u32 BTQosNullLength ;
  u8 *ReservedPagePacket ;
  u8 PageNum ;
  u8 PageNeed ;
  u8 TxDescLen ;
  u16 BufIndex ;
  u32 TotalPacketLen ;
  struct rsvdpage_loc RsvdPageLoc ;
  void *tmp ;
  u32 tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 893
  fakemac[0] = 0U;
#line 893
  fakemac[1] = 224U;
#line 893
  fakemac[2] = 76U;
#line 893
  fakemac[3] = 0U;
#line 893
  fakemac[4] = 0U;
#line 893
  fakemac[5] = 0U;
#line 901
  if (GlobalDebugLevel23A > 3U) {
#line 901
    printk("\016RTL8723AU: +%s\n", "SetFwRsvdPagePkt_BTCoex");
  } else {

  }
#line 903
  tmp = kzalloc(1024UL, 208U);
#line 903
  ReservedPagePacket = (u8 *)tmp;
#line 904
  if ((unsigned long )ReservedPagePacket == (unsigned long )((u8 *)0U)) {
#line 905
    if (GlobalDebugLevel23A > 3U) {
#line 905
      printk("\016RTL8723AU: %s: alloc ReservedPagePacket fail!\n", "SetFwRsvdPagePkt_BTCoex");
    } else {

    }
#line 906
    return;
  } else {

  }
#line 909
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 910
  pxmitpriv = & padapter->xmitpriv;
#line 911
  pmlmeext = & padapter->mlmeextpriv;
#line 912
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 914
  TxDescLen = 32U;
#line 915
  PageNum = 0U;
#line 918
  BufIndex = 40U;
#line 920
  PageNeed = 3U;
#line 922
  PageNum = (int )PageNum + (int )PageNeed;
#line 923
  pHalData->FwRsvdPageStartOffset = PageNum;
#line 925
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 928
  RsvdPageLoc.LocNullData = PageNum;
#line 929
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & NullDataLength, (u8 *)(& fakemac), 0, 0, 0, 0);
#line 935
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            NullDataLength, 0, 0);
#line 937
  PageNeed = (unsigned int )((unsigned char )(((u32 )TxDescLen + NullDataLength) >> 7)) + ((((u32 )TxDescLen + NullDataLength) & 127U) != 0U ? 1U : 0U);
#line 938
  PageNum = (int )PageNum + (int )PageNeed;
#line 940
  BufIndex = (unsigned int )((u16 )PageNeed) * 128U + (unsigned int )BufIndex;
#line 943
  RsvdPageLoc.LocBTQosNull = PageNum;
#line 944
  ConstructNullFunctionData(padapter, ReservedPagePacket + (unsigned long )BufIndex,
                            & BTQosNullLength, (u8 *)(& fakemac), 1, 0, 0, 0);
#line 950
  rtl8723a_fill_fake_txdesc(padapter, ReservedPagePacket + (unsigned long )((int )BufIndex - (int )TxDescLen),
                            BTQosNullLength, 0, 1);
#line 952
  TotalPacketLen = (u32 )BufIndex + BTQosNullLength;
#line 954
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 955
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 956
    goto exit;
  } else {

  }
#line 959
  pattrib = & pmgntframe->attrib;
#line 960
  update_mgntframe_attrib23a(padapter, pattrib);
#line 961
  pattrib->qsel = 16U;
#line 962
  tmp___0 = TotalPacketLen - 40U;
#line 962
  pattrib->last_txcmdsz = tmp___0;
#line 962
  pattrib->pktlen = tmp___0;
#line 963
  __len = (size_t )TotalPacketLen;
#line 963
  __ret = __builtin_memcpy((void *)pmgntframe->buf_addr, (void const   *)ReservedPagePacket,
                           __len);
#line 965
  rtl8723au_mgnt_xmit(padapter, pmgntframe);
#line 967
  if (GlobalDebugLevel23A > 3U) {
#line 967
    printk("\016RTL8723AU: %s: Set RSVD page location to Fw\n", "SetFwRsvdPagePkt_BTCoex");
  } else {

  }
#line 968
  FillH2CCmd(padapter, 3, 5U, (u8 *)(& RsvdPageLoc));
  exit: 
#line 971
  kfree((void const   *)ReservedPagePacket);
#line 972
  return;
}
}
#line 974 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
void rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 bRecover ;

  {
#line 977
  bRecover = 0U;
#line 979
  if (GlobalDebugLevel23A > 3U) {
#line 979
    printk("\016RTL8723AU: +%s\n", "rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd");
  } else {

  }
#line 981
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 984
  if (((unsigned long )pHalData->RegFwHwTxQCtrl & 64UL) != 0UL) {
#line 985
    bRecover = 1U;
  } else {

  }
#line 988
  pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
#line 989
  rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl);
#line 991
  SetFwRsvdPagePkt_BTCoex(padapter);
#line 998
  if ((unsigned int )bRecover != 0U) {
#line 999
    pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
#line 1000
    rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl);
  } else {

  }
#line 1003
  return;
}
}
#line 1132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
void *ldv_kmem_cache_alloc_1502(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1135
  ldv_check_alloc_flags(flags);
#line 1137
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1138
  return ((void *)0);
}
}
#line 1176 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
int ldv_pskb_expand_head_1508(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1179
  ldv_check_alloc_flags(flags);
#line 1181
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1181
  return (tmp);
}
}
#line 1192 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
struct sk_buff *ldv_skb_clone_1510(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1195
  ldv_check_alloc_flags(flags);
#line 1197
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1197
  return (tmp);
}
}
#line 1208 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
struct sk_buff *ldv_skb_copy_1512(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1211
  ldv_check_alloc_flags(flags);
#line 1213
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1213
  return (tmp);
}
}
#line 1216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1513(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1219
  ldv_check_alloc_flags(flags);
#line 1221
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1221
  return (tmp);
}
}
#line 1224 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1514(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1227
  ldv_check_alloc_flags(flags);
#line 1229
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1229
  return (tmp);
}
}
#line 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1515(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1235
  ldv_check_alloc_flags(flags);
#line 1237
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1237
  return (tmp);
}
}
#line 1240 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
int ldv_pskb_expand_head_1516(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1243
  ldv_check_alloc_flags(flags);
#line 1245
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1245
  return (tmp);
}
}
#line 1248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
int ldv_pskb_expand_head_1517(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1251
  ldv_check_alloc_flags(flags);
#line 1253
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1253
  return (tmp);
}
}
#line 1256 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_cmd.o.c.prepared"
struct sk_buff *ldv_skb_clone_1518(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1259
  ldv_check_alloc_flags(flags);
#line 1261
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1261
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1544(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1552(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1560(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1554(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1550(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1558(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1559(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1555(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1556(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1557(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 136 "drivers/staging/rtl8723au/include/rtl8723a_dm.h"
void rtl8723a_init_dm_priv(struct rtw_adapter *Adapter ) ;
#line 137
void rtl8723a_deinit_dm_priv(struct rtw_adapter *Adapter ) ;
#line 139
void rtl8723a_InitHalDm(struct rtw_adapter *Adapter ) ;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
static void dm_CheckStatistics(struct rtw_adapter *Adapter ) 
{ 


  {
#line 257
  return;
}
}
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
static void dm_CheckPbcGPIO(struct rtw_adapter *padapter ) 
{ 
  u8 tmp1byte ;
  u8 bPbcPressed ;
  struct pid *tmp ;

  {
#line 262
  bPbcPressed = 0U;
#line 264
  if ((unsigned int )padapter->registrypriv.hw_wps_pbc == 0U) {
#line 265
    return;
  } else {

  }
#line 267
  tmp1byte = rtl8723au_read8(padapter, 70U);
#line 268
  tmp1byte = (u8 )((unsigned int )tmp1byte | 4U);
#line 270
  rtl8723au_write8(padapter, 70U, (int )tmp1byte);
#line 272
  tmp1byte = (unsigned int )tmp1byte & 251U;
#line 274
  rtl8723au_write8(padapter, 68U, (int )tmp1byte);
#line 276
  tmp1byte = rtl8723au_read8(padapter, 70U);
#line 277
  tmp1byte = (unsigned int )tmp1byte & 251U;
#line 279
  rtl8723au_write8(padapter, 70U, (int )tmp1byte);
#line 281
  tmp1byte = rtl8723au_read8(padapter, 68U);
#line 283
  if ((unsigned int )tmp1byte == 255U) {
#line 284
    return;
  } else {

  }
#line 286
  if (((unsigned long )tmp1byte & 4UL) != 0UL) {
#line 287
    bPbcPressed = 1U;
  } else {

  }
#line 289
  if ((unsigned int )bPbcPressed != 0U) {
#line 292
    if (GlobalDebugLevel23A > 3U) {
#line 292
      printk("\016RTL8723AU: CheckPbcGPIO - PBC is pressed\n");
    } else {

    }
#line 294
    if (padapter->pid[0] == 0) {
#line 298
      return;
    } else {

    }
#line 301
    tmp = find_vpid(padapter->pid[0]);
#line 301
    kill_pid(tmp, 10, 1);
  } else {

  }
#line 303
  return;
}
}
#line 307 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
static void Init_ODM_ComInfo_8723a(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  u8 cut_ver ;
  u8 fab_ver ;

  {
#line 310
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 311
  pDM_Odm = & pHalData->odmpriv;
#line 317
  memset((void *)pDM_Odm, 0, 3632UL);
#line 319
  pDM_Odm->Adapter = Adapter;
#line 320
  ODM_CmnInfoInit23a(pDM_Odm, 0, 4U);
#line 321
  ODM_CmnInfoInit23a(pDM_Odm, 2, 2U);
#line 323
  ODM_CmnInfoInit23a(pDM_Odm, 4, 8U);
#line 325
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 0U) {
#line 326
    fab_ver = 1U;
#line 327
    cut_ver = 1U;
  } else
#line 328
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) {
#line 329
    fab_ver = 1U;
#line 330
    cut_ver = 2U;
  } else {
#line 332
    fab_ver = 0U;
#line 333
    cut_ver = 1U;
  }
#line 335
  ODM_CmnInfoInit23a(pDM_Odm, 6, (u32 )fab_ver);
#line 336
  ODM_CmnInfoInit23a(pDM_Odm, 5, (u32 )cut_ver);
#line 337
  ODM_CmnInfoInit23a(pDM_Odm, 3, (unsigned int )pHalData->VersionID.ChipType == 1U);
#line 339
  ODM_CmnInfoInit23a(pDM_Odm, 8, (u32 )pHalData->BoardType);
#line 341
  if ((unsigned int )pHalData->BoardType == 1U) {
#line 342
    ODM_CmnInfoInit23a(pDM_Odm, 9, 1U);
#line 343
    ODM_CmnInfoInit23a(pDM_Odm, 10, 1U);
  } else {

  }
#line 345
  ODM_CmnInfoInit23a(pDM_Odm, 12, (u32 )pHalData->CustomerID);
#line 346
  ODM_CmnInfoInit23a(pDM_Odm, 14, (u32 )Adapter->registrypriv.wifi_spec);
#line 348
  if ((unsigned int )pHalData->rf_type == 3U) {
#line 349
    ODM_CmnInfoUpdate23a(pDM_Odm, 7U, 0ULL);
  } else
#line 350
  if ((unsigned int )pHalData->rf_type == 2U) {
#line 351
    ODM_CmnInfoUpdate23a(pDM_Odm, 7U, 2ULL);
  } else
#line 352
  if ((unsigned int )pHalData->rf_type == 0U) {
#line 353
    ODM_CmnInfoUpdate23a(pDM_Odm, 7U, 1ULL);
  } else {

  }
#line 354
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
static void Update_ODM_ComInfo_8723a(struct rtw_adapter *Adapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrctrlpriv ;
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct dm_priv *pdmpriv ;
  int i ;

  {
#line 358
  pmlmeext = & Adapter->mlmeextpriv;
#line 359
  pmlmepriv = & Adapter->mlmepriv;
#line 360
  pwrctrlpriv = & Adapter->pwrctrlpriv;
#line 361
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 362
  pDM_Odm = & pHalData->odmpriv;
#line 363
  pdmpriv = & pHalData->dmpriv;
#line 365
  pdmpriv->InitODMFlag = 83951807U;
#line 377
  ODM_CmnInfoUpdate23a(pDM_Odm, 1U, (u64 )pdmpriv->InitODMFlag);
#line 379
  ODM23a_CmnInfoHook(pDM_Odm, 17, (void *)(& Adapter->xmitpriv.tx_bytes));
#line 381
  ODM23a_CmnInfoHook(pDM_Odm, 18, (void *)(& Adapter->recvpriv.rx_bytes));
#line 383
  ODM23a_CmnInfoHook(pDM_Odm, 19, (void *)(& pmlmeext->cur_wireless_mode));
#line 385
  ODM23a_CmnInfoHook(pDM_Odm, 21, (void *)(& pHalData->nCur40MhzPrimeSC));
#line 387
  ODM23a_CmnInfoHook(pDM_Odm, 22, (void *)(& Adapter->securitypriv.dot11PrivacyAlgrthm));
#line 389
  ODM23a_CmnInfoHook(pDM_Odm, 23, (void *)(& pHalData->CurrentChannelBW));
#line 391
  ODM23a_CmnInfoHook(pDM_Odm, 24, (void *)(& pHalData->CurrentChannel));
#line 393
  ODM23a_CmnInfoHook(pDM_Odm, 35, (void *)(& Adapter->net_closed));
#line 395
  ODM23a_CmnInfoHook(pDM_Odm, 28, (void *)(& pmlmepriv->bScanInProcess));
#line 396
  ODM23a_CmnInfoHook(pDM_Odm, 29, (void *)(& pwrctrlpriv->bpower_saving));
#line 399
  i = 0;
#line 399
  goto ldv_54269;
  ldv_54268: 
#line 400
  ODM_CmnInfoPtrArrayHook23a(pDM_Odm, 51, (int )((u16 )i), (void *)0);
#line 399
  i = i + 1;
  ldv_54269: ;
#line 399
  if (i <= 31) {
#line 401
    goto ldv_54268;
  } else {

  }

#line 406
  return;
}
}
#line 403 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
void rtl8723a_InitHalDm(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct dm_odm_t *pDM_Odm ;
  u8 i ;
  u8 tmp ;

  {
#line 405
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 406
  pdmpriv = & pHalData->dmpriv;
#line 407
  pDM_Odm = & pHalData->odmpriv;
#line 410
  pdmpriv->DM_Type = 1U;
#line 411
  pdmpriv->DMFlag = 0U;
#line 414
  pdmpriv->DMFlag = (u8 )((unsigned int )pdmpriv->DMFlag | 1U);
#line 416
  pdmpriv->InitDMFlag = pdmpriv->DMFlag;
#line 418
  Update_ODM_ComInfo_8723a(Adapter);
#line 419
  ODM23a_DMInit(pDM_Odm);
#line 421
  i = 0U;
#line 421
  goto ldv_54279;
  ldv_54278: 
#line 422
  tmp = rtl8723au_read8(Adapter, (u32 )((int )i + 1156));
#line 422
  pdmpriv->INIDATA_RATE[(int )i] = (unsigned int )tmp & 63U;
#line 421
  i = (u8 )((int )i + 1);
  ldv_54279: ;
#line 421
  if ((unsigned int )i <= 31U) {
#line 423
    goto ldv_54278;
  } else {

  }

#line 428
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
void rtl8723a_HalDmWatchDog(struct rtw_adapter *Adapter ) 
{ 
  bool bFwCurrentInPSMode ;
  bool bFwPSAwake ;
  u8 hw_init_completed ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 tmp ;
  u8 i ;
  u8 tmp___0 ;
  bool tmp___1 ;
  u8 bLinked ;
  int tmp___2 ;

  {
#line 430
  bFwCurrentInPSMode = 0;
#line 431
  bFwPSAwake = 1;
#line 432
  hw_init_completed = 0U;
#line 433
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 434
  pdmpriv = & pHalData->dmpriv;
#line 436
  hw_init_completed = Adapter->hw_init_completed;
#line 438
  if ((unsigned int )hw_init_completed == 0U) {
#line 439
    goto skip_dm;
  } else {

  }
#line 441
  bFwCurrentInPSMode = (unsigned int )Adapter->pwrctrlpriv.bFwCurrentInPSMode != 0U;
#line 442
  bFwPSAwake = rtl8723a_get_fwlps_rf_on(Adapter);
#line 444
  if ((unsigned int )hw_init_completed != 0U && (! bFwCurrentInPSMode && (int )bFwPSAwake)) {
#line 446
    dm_CheckStatistics(Adapter);
#line 449
    tmp___1 = check_fwstate(& Adapter->mlmepriv, 8);
#line 449
    if ((int )tmp___1) {
#line 450
      tmp = rtl8723au_read8(Adapter, 1156U);
#line 450
      pdmpriv->INIDATA_RATE[0] = (unsigned int )tmp & 63U;
    } else {
#line 453
      i = 1U;
#line 453
      goto ldv_54292;
      ldv_54291: 
#line 454
      tmp___0 = rtl8723au_read8(Adapter, (u32 )((int )i + 1156));
#line 454
      pdmpriv->INIDATA_RATE[(int )i] = (unsigned int )tmp___0 & 63U;
#line 453
      i = (u8 )((int )i + 1);
      ldv_54292: ;
#line 453
      if ((int )i < Adapter->stapriv.asoc_sta_count + 1) {
#line 455
        goto ldv_54291;
      } else {

      }

    }
  } else {

  }
#line 459
  if ((unsigned int )hw_init_completed == 1U) {
#line 460
    bLinked = 0U;
#line 462
    tmp___2 = rtw_linked_check(Adapter);
#line 462
    if (tmp___2 != 0) {
#line 463
      bLinked = 1U;
    } else {

    }
#line 465
    ODM_CmnInfoUpdate23a(& pHalData->odmpriv, 39U, (u64 )bLinked);
#line 467
    ODM_DMWatchdog23a(& pHalData->odmpriv);
  } else {

  }
  skip_dm: 
#line 474
  dm_CheckPbcGPIO(Adapter);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
void rtl8723a_init_dm_priv(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;

  {
#line 479
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 480
  pdmpriv = & pHalData->dmpriv;
#line 482
  memset((void *)pdmpriv, 0, 356UL);
#line 483
  Init_ODM_ComInfo_8723a(Adapter);
#line 484
  return;
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
void rtl8723a_deinit_dm_priv(struct rtw_adapter *Adapter ) 
{ 


  {
#line 488
  return;
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
void *ldv_kmem_cache_alloc_1544(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 620
  ldv_check_alloc_flags(flags);
#line 622
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 623
  return ((void *)0);
}
}
#line 661 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
int ldv_pskb_expand_head_1550(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 664
  ldv_check_alloc_flags(flags);
#line 666
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 666
  return (tmp);
}
}
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
struct sk_buff *ldv_skb_clone_1552(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 680
  ldv_check_alloc_flags(flags);
#line 682
  tmp = skb_clone(ldv_func_arg1, flags);
#line 682
  return (tmp);
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
struct sk_buff *ldv_skb_copy_1554(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 696
  ldv_check_alloc_flags(flags);
#line 698
  tmp = skb_copy(ldv_func_arg1, flags);
#line 698
  return (tmp);
}
}
#line 701 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1555(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 704
  ldv_check_alloc_flags(flags);
#line 706
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 706
  return (tmp);
}
}
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1556(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 712
  ldv_check_alloc_flags(flags);
#line 714
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 714
  return (tmp);
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1557(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 720
  ldv_check_alloc_flags(flags);
#line 722
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 722
  return (tmp);
}
}
#line 725 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
int ldv_pskb_expand_head_1558(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 728
  ldv_check_alloc_flags(flags);
#line 730
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 730
  return (tmp);
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
int ldv_pskb_expand_head_1559(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 736
  ldv_check_alloc_flags(flags);
#line 738
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 738
  return (tmp);
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_dm.o.c.prepared"
struct sk_buff *ldv_skb_clone_1560(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 744
  ldv_check_alloc_flags(flags);
#line 746
  tmp = skb_clone(ldv_func_arg1, flags);
#line 746
  return (tmp);
}
}
#line 120 "include/linux/string.h"
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1586(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 49
extern void release_firmware(struct firmware  const  * ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1594(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1602(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1596(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1592(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1600(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1601(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1597(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1598(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1599(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 116 "drivers/staging/rtl8723au/include/hal_intf.h"
void hw_var_set_macaddr(struct rtw_adapter *padapter , u8 *val ) ;
#line 193 "drivers/staging/rtl8723au/include/drv_types.h"
__inline static struct device *dvobj_to_dev(struct dvobj_priv *dvobj ) 
{ 


  {
#line 196
  return (& (dvobj->pusbintf)->dev);
}
}
#line 36 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
void rtl8723a_BT_wifiassociate_notify(struct rtw_adapter *padapter , u8 action ) ;
#line 37
void rtl8723a_BT_init_hal_vars(struct rtw_adapter *padapter ) ;
#line 38
void rtl8723a_fw_c2h_BT_info(struct rtw_adapter *padapter , u8 *tmpBuf , u8 length ) ;
#line 215 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
void handle_txrpt_ccx_8723a(struct rtw_adapter *adapter , void *buf ) ;
#line 216
void rtl8723a_update_txdesc(struct xmit_frame *pxmitframe , u8 *pbuf ) ;
#line 502 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
s32 rtl8723a_FirmwareDownload(struct rtw_adapter *padapter ) ;
#line 503
void rtl8723a_FirmwareSelfReset(struct rtw_adapter *padapter ) ;
#line 504
void rtl8723a_InitializeFirmwareVars(struct rtw_adapter *padapter ) ;
#line 506
void rtl8723a_InitAntenna_Selection(struct rtw_adapter *padapter ) ;
#line 507
void rtl8723a_DeinitAntenna_Selection(struct rtw_adapter *padapter ) ;
#line 508
void rtl8723a_CheckAntenna_Selection(struct rtw_adapter *padapter ) ;
#line 509
void rtl8723a_init_default_value(struct rtw_adapter *padapter ) ;
#line 511
s32 InitLLTTable23a(struct rtw_adapter *padapter , u32 boundary ) ;
#line 513
s32 CardDisableHWSM(struct rtw_adapter *padapter , u8 resetMCU ) ;
#line 514
s32 CardDisableWithoutHWSM(struct rtw_adapter *padapter ) ;
#line 517
u8 GetEEPROMSize8723A(struct rtw_adapter *padapter ) ;
#line 518
void Hal_InitPGData(struct rtw_adapter *padapter , u8 *PROMContent ) ;
#line 519
void Hal_EfuseParseIDCode(struct rtw_adapter *padapter , u8 *hwinfo ) ;
#line 520
void Hal_EfuseParsetxpowerinfo_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                     bool AutoLoadFail ) ;
#line 521
void Hal_EfuseParseBTCoexistInfo_8723A(struct rtw_adapter *padapter , u8 *hwinfo ,
                                       bool AutoLoadFail ) ;
#line 522
void Hal_EfuseParseEEPROMVer(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
#line 523
void rtl8723a_EfuseParseChnlPlan(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
#line 524
void Hal_EfuseParseCustomerID(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
#line 525
void Hal_EfuseParseAntennaDiversity(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) ;
#line 526
void Hal_EfuseParseRateIndicationOption(struct rtw_adapter *padapter , u8 *hwinfo ,
                                        bool AutoLoadFail ) ;
#line 527
void Hal_EfuseParseXtal_8723A(struct rtw_adapter *pAdapter , u8 *hwinfo , u8 AutoLoadFail ) ;
#line 528
void Hal_EfuseParseThermalMeter_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                      bool AutoloadFail ) ;
#line 530
void Hal_InitChannelPlan23a(struct rtw_adapter *padapter ) ;
#line 534
void rtl8723a_InitBeaconParameters(struct rtw_adapter *padapter ) ;
#line 543
void rtl8723a_read_chip_version(struct rtw_adapter *padapter ) ;
#line 544
void rtl8723a_notch_filter(struct rtw_adapter *adapter , bool enable ) ;
#line 38 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
int rtl8723au_writeN(struct rtw_adapter *padapter , u32 addr , u32 length , u8 *pdata ) ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void _FWDownloadEnable(struct rtw_adapter *padapter , bool enable ) 
{ 
  u8 tmp ;

  {
#line 246
  if ((int )enable) {
#line 248
    tmp = rtl8723au_read8(padapter, 3U);
#line 249
    rtl8723au_write8(padapter, 3U, (int )((unsigned int )tmp | 4U));
#line 252
    tmp = rtl8723au_read8(padapter, 128U);
#line 253
    rtl8723au_write8(padapter, 128U, (int )((unsigned int )tmp | 1U));
#line 256
    tmp = rtl8723au_read8(padapter, 130U);
#line 257
    rtl8723au_write8(padapter, 130U, (int )tmp & 247);
  } else {
#line 260
    tmp = rtl8723au_read8(padapter, 128U);
#line 261
    rtl8723au_write8(padapter, 128U, (int )tmp & 254);
#line 264
    rtl8723au_write8(padapter, 129U, 0);
  }
#line 266
  return;
}
}
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static int _BlockWrite(struct rtw_adapter *padapter , void *buffer , u32 buffSize ) 
{ 
  int ret ;
  u32 blockSize_p1 ;
  u32 blockSize_p2 ;
  u32 blockSize_p3 ;
  u32 blockCount_p1 ;
  u32 blockCount_p2 ;
  u32 blockCount_p3 ;
  u32 remainSize_p1 ;
  u32 remainSize_p2 ;
  u8 *bufferPtr ;
  u32 i ;
  u32 offset ;

  {
#line 270
  ret = 1;
#line 272
  blockSize_p1 = 4U;
#line 274
  blockSize_p2 = 8U;
#line 276
  blockSize_p3 = 1U;
#line 277
  blockCount_p1 = 0U;
#line 277
  blockCount_p2 = 0U;
#line 277
  blockCount_p3 = 0U;
#line 278
  remainSize_p1 = 0U;
#line 278
  remainSize_p2 = 0U;
#line 279
  bufferPtr = (u8 *)buffer;
#line 280
  i = 0U;
#line 280
  offset = 0U;
#line 282
  blockSize_p1 = 254U;
#line 285
  blockCount_p1 = buffSize / blockSize_p1;
#line 286
  remainSize_p1 = buffSize % blockSize_p1;
#line 288
  if (blockCount_p1 != 0U) {
#line 289
    if (GlobalDebugLevel23A > 5U) {
#line 289
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 6);
#line 289
      printk("\016_BlockWrite: [P1] buffSize(%d) blockSize_p1(%d) blockCount_p1(%d) remainSize_p1(%d)\n",
             buffSize, blockSize_p1, blockCount_p1, remainSize_p1);
    } else {

    }
  } else {

  }
#line 296
  i = 0U;
#line 296
  goto ldv_54296;
  ldv_54295: 
#line 297
  ret = rtl8723au_writeN(padapter, i * blockSize_p1 + 4096U, blockSize_p1, bufferPtr + (unsigned long )(i * blockSize_p1));
#line 301
  if (ret == 0) {
#line 302
    goto exit;
  } else {

  }
#line 296
  i = i + 1U;
  ldv_54296: ;
#line 296
  if (i < blockCount_p1) {
#line 298
    goto ldv_54295;
  } else {

  }

#line 306
  if (remainSize_p1 != 0U) {
#line 307
    offset = blockCount_p1 * blockSize_p1;
#line 309
    blockCount_p2 = remainSize_p1 / blockSize_p2;
#line 310
    remainSize_p2 = remainSize_p1 % blockSize_p2;
#line 312
    if (blockCount_p2 != 0U) {
#line 313
      if (GlobalDebugLevel23A > 5U) {
#line 313
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 6);
#line 313
        printk("\016_BlockWrite: [P2] buffSize_p2(%d) blockSize_p2(%d) blockCount_p2(%d) remainSize_p2(%d)\n",
               buffSize - offset, blockSize_p2, blockCount_p2, remainSize_p2);
      } else {

      }
    } else {

    }
#line 321
    i = 0U;
#line 321
    goto ldv_54299;
    ldv_54298: 
#line 322
    ret = rtl8723au_writeN(padapter, (i * blockSize_p2 + offset) + 4096U, blockSize_p2,
                           bufferPtr + ((unsigned long )offset + (unsigned long )(i * blockSize_p2)));
#line 329
    if (ret == 0) {
#line 330
      goto exit;
    } else {

    }
#line 321
    i = i + 1U;
    ldv_54299: ;
#line 321
    if (i < blockCount_p2) {
#line 323
      goto ldv_54298;
    } else {

    }

  } else {

  }
#line 335
  if (remainSize_p2 != 0U) {
#line 336
    offset = blockCount_p1 * blockSize_p1 + blockCount_p2 * blockSize_p2;
#line 339
    blockCount_p3 = remainSize_p2 / blockSize_p3;
#line 341
    if (GlobalDebugLevel23A > 5U) {
#line 341
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 6);
#line 341
      printk("\016_BlockWrite: [P3] buffSize_p3(%d) blockSize_p3(%d) blockCount_p3(%d)\n",
             buffSize - offset, blockSize_p3, blockCount_p3);
    } else {

    }
#line 346
    i = 0U;
#line 346
    goto ldv_54302;
    ldv_54301: 
#line 347
    ret = rtl8723au_write8(padapter, (offset + i) + 4096U, (int )*(bufferPtr + ((unsigned long )offset + (unsigned long )i)));
#line 351
    if (ret == 0) {
#line 352
      goto exit;
    } else {

    }
#line 346
    i = i + 1U;
    ldv_54302: ;
#line 346
    if (i < blockCount_p3) {
#line 348
      goto ldv_54301;
    } else {

    }

  } else {

  }
  exit: ;
#line 357
  return (ret);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static int _PageWrite(struct rtw_adapter *padapter , u32 page , void *buffer , u32 size ) 
{ 
  u8 value8 ;
  u8 u8Page ;
  u8 tmp ;
  int tmp___0 ;

  {
#line 364
  u8Page = (unsigned int )((unsigned char )page) & 7U;
#line 366
  tmp = rtl8723au_read8(padapter, 130U);
#line 366
  value8 = (u8 )(((int )((signed char )tmp) & -8) | (int )((signed char )u8Page));
#line 367
  rtl8723au_write8(padapter, 130U, (int )value8);
#line 369
  tmp___0 = _BlockWrite(padapter, buffer, size);
#line 369
  return (tmp___0);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static int _WriteFW(struct rtw_adapter *padapter , void *buffer , u32 size ) 
{ 
  int ret ;
  u32 pageNums ;
  u32 remainSize ;
  u32 page ;
  u32 offset ;
  u8 *bufferPtr ;

  {
#line 377
  ret = 1;
#line 380
  bufferPtr = (u8 *)buffer;
#line 382
  pageNums = size / 4096U;
#line 385
  remainSize = size & 4095U;
#line 387
  page = 0U;
#line 387
  goto ldv_54325;
  ldv_54324: 
#line 388
  offset = page * 4096U;
#line 389
  ret = _PageWrite(padapter, page, (void *)bufferPtr + (unsigned long )offset, 4096U);
#line 392
  if (ret == 0) {
#line 393
    goto exit;
  } else {

  }
#line 387
  page = page + 1U;
  ldv_54325: ;
#line 387
  if (page < pageNums) {
#line 389
    goto ldv_54324;
  } else {

  }

#line 395
  if (remainSize != 0U) {
#line 396
    offset = pageNums * 4096U;
#line 397
    page = pageNums;
#line 398
    ret = _PageWrite(padapter, page, (void *)bufferPtr + (unsigned long )offset, remainSize);
#line 401
    if (ret == 0) {
#line 402
      goto exit;
    } else {

    }
  } else {

  }
#line 404
  if (GlobalDebugLevel23A > 6U) {
#line 404
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 404
    printk("\016_WriteFW Done- for Normal chip.\n");
  } else {

  }
  exit: ;
#line 408
  return (ret);
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static int _FWFreeToGo(struct rtw_adapter *padapter ) 
{ 
  u32 counter ;
  u32 value32 ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 413
  counter = 0U;
  ldv_54333: 
#line 418
  value32 = rtl8723au_read32(padapter, 128U);
#line 419
  if (((unsigned long )value32 & 4UL) != 0UL) {
#line 420
    goto ldv_54332;
  } else {

  }
#line 421
  tmp = counter;
#line 421
  counter = counter + 1U;
#line 421
  if (tmp <= 999U) {
#line 423
    goto ldv_54333;
  } else {

  }
  ldv_54332: ;
#line 423
  if (counter > 999U) {
#line 424
    if (GlobalDebugLevel23A > 3U) {
#line 424
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
#line 424
      printk("\016%s: chksum report fail! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo", value32);
    } else {

    }
#line 427
    return (0);
  } else {

  }
#line 429
  if (GlobalDebugLevel23A > 6U) {
#line 429
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 429
    printk("\016%s: Checksum report OK! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo", value32);
  } else {

  }
#line 433
  value32 = rtl8723au_read32(padapter, 128U);
#line 434
  value32 = value32 | 2U;
#line 435
  value32 = value32 & 4294967231U;
#line 436
  rtl8723au_write32(padapter, 128U, value32);
#line 439
  counter = 0U;
  ldv_54335: 
#line 441
  value32 = rtl8723au_read32(padapter, 128U);
#line 442
  if (((unsigned long )value32 & 64UL) != 0UL) {
#line 443
    if (GlobalDebugLevel23A > 6U) {
#line 443
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 443
      printk("\016%s: Polling FW ready success!! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
             value32);
    } else {

    }
#line 447
    return (1);
  } else {

  }
#line 449
  __const_udelay(21475UL);
#line 450
  tmp___0 = counter;
#line 450
  counter = counter + 1U;
#line 450
  if (tmp___0 <= 999U) {
#line 452
    goto ldv_54335;
  } else {

  }

#line 452
  if (GlobalDebugLevel23A > 3U) {
#line 452
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
#line 452
    printk("\016%s: Polling FW ready fail!! REG_MCUFWDL:0x%08x\n", "_FWFreeToGo",
           value32);
  } else {

  }
#line 455
  return (0);
}
}
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_FirmwareSelfReset(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 u1bTmp ;
  u8 Delay ;

  {
#line 462
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 464
  Delay = 100U;
#line 466
  if (((int )((struct hal_data_8723a *)padapter->HalData)->FirmwareSignature & 65520) != 35008 || ((unsigned int )pHalData->FirmwareVersion > 32U && ((unsigned int )pHalData->FirmwareVersion != 33U || (unsigned int )pHalData->FirmwareSubVersion != 0U))) {
#line 472
    rtl8723au_write8(padapter, 463U, 32);
#line 474
    u1bTmp = rtl8723au_read8(padapter, 3U);
#line 475
    goto ldv_54345;
    ldv_54344: 
#line 476
    Delay = (u8 )((int )Delay - 1);
#line 477
    if ((unsigned int )Delay == 0U) {
#line 478
      goto ldv_54343;
    } else {

    }
#line 479
    __const_udelay(214750UL);
#line 480
    u1bTmp = rtl8723au_read8(padapter, 3U);
    ldv_54345: ;
#line 475
    if (((unsigned long )u1bTmp & 4UL) != 0UL) {
#line 477
      goto ldv_54344;
    } else {

    }
    ldv_54343: ;
#line 482
    if (GlobalDebugLevel23A > 6U) {
#line 482
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 482
      printk("\016-%s: 8051 reset success (%d)\n", "rtl8723a_FirmwareSelfReset", (int )Delay);
    } else {

    }
#line 486
    if ((unsigned int )Delay == 0U) {
#line 488
      u1bTmp = rtl8723au_read8(padapter, 3U);
#line 489
      rtl8723au_write8(padapter, 3U, (int )u1bTmp & 251);
    } else {

    }
  } else {

  }
#line 492
  return;
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
s32 rtl8723a_FirmwareDownload(struct rtw_adapter *padapter ) 
{ 
  int rtStatus ;
  u8 writeFW_retry ;
  unsigned long fwdl_start_time ;
  struct hal_data_8723a *pHalData ;
  struct dvobj_priv *dvobj ;
  struct device *device ;
  struct device *tmp ;
  struct rt_8723a_firmware_hdr *pFwHdr ;
  struct firmware  const  *fw ;
  char *fw_name ;
  u8 *firmware_buf ;
  u8 *buf ;
  int fw_size ;
  int log_version ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  unsigned int tmp___6 ;
  u8 tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 502
  rtStatus = 1;
#line 503
  writeFW_retry = 0U;
#line 505
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 506
  dvobj = padapter->dvobj;
#line 507
  tmp = dvobj_to_dev(dvobj);
#line 507
  device = tmp;
#line 508
  pFwHdr = (struct rt_8723a_firmware_hdr *)0;
#line 511
  firmware_buf = (u8 *)0U;
#line 516
  if (GlobalDebugLevel23A > 6U) {
#line 516
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 516
    printk("\016+%s\n", "rtl8723a_FirmwareDownload");
  } else {

  }
#line 518
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 0U) {
#line 519
    fw_name = (char *)"rtlwifi/rtl8723aufw.bin";
#line 520
    if (GlobalDebugLevel23A > 6U) {
#line 520
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 520
      printk("\016rtl8723a_FirmwareDownload: R8723FwImageArray_UMC for RTL8723A A CUT\n");
    } else {

    }
  } else
#line 523
  if ((unsigned int )pHalData->VersionID.ICType == 4U && (unsigned int )pHalData->VersionID.CUTVersion == 1U) {
#line 525
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
#line 526
      fw_name = (char *)"rtlwifi/rtl8723aufw_B_NoBT.bin";
#line 527
      if (GlobalDebugLevel23A > 3U) {
#line 527
        printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithoutBT for RTL8723A B CUT\n");
      } else {

      }
    } else {
#line 530
      tmp___0 = rtl8723a_BT_coexist(padapter);
#line 530
      if ((int )tmp___0) {
#line 531
        fw_name = (char *)"rtlwifi/rtl8723aufw_B.bin";
#line 532
        if (GlobalDebugLevel23A > 3U) {
#line 532
          printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithBT for RTL8723A B CUT\n");
        } else {

        }
      } else {
#line 535
        fw_name = (char *)"rtlwifi/rtl8723aufw_B_NoBT.bin";
#line 536
        if (GlobalDebugLevel23A > 3U) {
#line 536
          printk("\016RTL8723AU:  Rtl8723_FwUMCBCutImageArrayWithout BT for RTL8723A B CUT\n");
        } else {

        }
      }
    }
  } else {
#line 543
    if (GlobalDebugLevel23A > 3U) {
#line 543
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
#line 543
      printk("\016%s: unknow version!\n", "rtl8723a_FirmwareDownload");
    } else {

    }
#line 545
    rtStatus = 0;
#line 546
    goto Exit;
  }
#line 549
  printk("\016rtl8723au: Loading firmware %s\n", fw_name);
#line 550
  tmp___1 = request_firmware(& fw, (char const   *)fw_name, device);
#line 550
  if (tmp___1 != 0) {
#line 551
    printk("\vrtl8723au: request_firmware load failed\n");
#line 552
    rtStatus = 0;
#line 553
    goto Exit;
  } else {

  }
#line 555
  if ((unsigned long )fw == (unsigned long )((struct firmware  const  *)0)) {
#line 556
    printk("\vrtl8723au: Firmware %s not available\n", fw_name);
#line 557
    rtStatus = 0;
#line 558
    goto Exit;
  } else {

  }
#line 560
  tmp___2 = kmemdup((void const   *)fw->data, fw->size, 208U);
#line 560
  firmware_buf = (u8 *)tmp___2;
#line 561
  if ((unsigned long )firmware_buf == (unsigned long )((u8 *)0U)) {
#line 562
    rtStatus = 0;
#line 563
    goto Exit;
  } else {

  }
#line 565
  buf = firmware_buf;
#line 566
  fw_size = (int )fw->size;
#line 567
  release_firmware(fw);
#line 570
  pFwHdr = (struct rt_8723a_firmware_hdr *)firmware_buf;
#line 572
  pHalData->FirmwareVersion = pFwHdr->Version;
#line 573
  pHalData->FirmwareSubVersion = (u16 )pFwHdr->Subversion;
#line 574
  pHalData->FirmwareSignature = pFwHdr->Signature;
#line 576
  if (GlobalDebugLevel23A > 3U) {
#line 576
    printk("\016RTL8723AU: %s: fw_ver =%d fw_subver =%d sig = 0x%x\n", "rtl8723a_FirmwareDownload",
           (int )pHalData->FirmwareVersion, (int )pHalData->FirmwareSubVersion, (int )pHalData->FirmwareSignature);
  } else {

  }
#line 580
  tmp___3 = log_version;
#line 580
  log_version = log_version + 1;
#line 580
  if (tmp___3 == 0) {
#line 581
    printk("\016%sFirmware Version %d, SubVersion %d, Signature 0x%x\n", (char *)"RTL8723AU: ",
           (int )pHalData->FirmwareVersion, (int )pHalData->FirmwareSubVersion, (int )pHalData->FirmwareSignature);
  } else {

  }
#line 586
  if ((((int )pFwHdr->Signature & 65520) == 37568 || ((int )pFwHdr->Signature & 65520) == 35008) || ((int )pFwHdr->Signature & 65520) == 8960) {
#line 588
    buf = buf + 32UL;
#line 589
    fw_size = fw_size + -32;
  } else {

  }
#line 595
  tmp___4 = rtl8723au_read8(padapter, 128U);
#line 595
  if ((int )((signed char )tmp___4) < 0) {
#line 597
    rtl8723a_FirmwareSelfReset(padapter);
#line 598
    rtl8723au_write8(padapter, 128U, 0);
  } else {

  }
#line 601
  _FWDownloadEnable(padapter, 1);
#line 602
  fwdl_start_time = jiffies;
  ldv_54366: 
#line 605
  tmp___5 = rtl8723au_read8(padapter, 128U);
#line 605
  rtl8723au_write8(padapter, 128U, (int )((unsigned int )tmp___5 | 4U));
#line 609
  rtStatus = _WriteFW(padapter, (void *)buf, (u32 )fw_size);
#line 611
  if (rtStatus == 1) {
#line 614
    goto ldv_54365;
  } else {
#line 611
    tmp___6 = jiffies_to_msecs((unsigned long )jiffies - fwdl_start_time);
#line 611
    if (tmp___6 > 500U) {
#line 611
      tmp___7 = writeFW_retry;
#line 611
      writeFW_retry = (u8 )((int )writeFW_retry + 1);
#line 611
      if ((unsigned int )tmp___7 > 2U) {
#line 614
        goto ldv_54365;
      } else {

      }
    } else {

    }
  }
#line 616
  if (GlobalDebugLevel23A > 3U) {
#line 616
    tmp___8 = jiffies_to_msecs((unsigned long )jiffies - fwdl_start_time);
#line 616
    printk("\016RTL8723AU: %s writeFW_retry:%u, time after fwdl_start_time:%ums\n",
           "rtl8723a_FirmwareDownload", (int )writeFW_retry, tmp___8);
  } else {

  }
#line 619
  goto ldv_54366;
  ldv_54365: 
#line 620
  _FWDownloadEnable(padapter, 0);
#line 621
  if (rtStatus != 1) {
#line 622
    if (GlobalDebugLevel23A > 3U) {
#line 622
      printk("\016RTL8723AU: DL Firmware failed!\n");
    } else {

    }
#line 623
    goto Exit;
  } else {

  }
#line 626
  rtStatus = _FWFreeToGo(padapter);
#line 627
  if (rtStatus != 1) {
#line 628
    if (GlobalDebugLevel23A > 3U) {
#line 628
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
#line 628
      printk("\016DL Firmware failed!\n");
    } else {

    }
#line 630
    goto Exit;
  } else {

  }
#line 632
  if (GlobalDebugLevel23A > 6U) {
#line 632
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 632
    printk("\016Firmware is ready to run!\n");
  } else {

  }
  Exit: 
#line 636
  kfree((void const   *)firmware_buf);
#line 637
  return (rtStatus);
}
}
#line 640 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_InitializeFirmwareVars(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 642
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 645
  padapter->pwrctrlpriv.bFwCurrentInPSMode = 0U;
#line 648
  pHalData->LastHMEBoxNum = 0U;
#line 649
  return;
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static u8 hal_EfuseSwitchToBank(struct rtw_adapter *padapter , u8 bank ) 
{ 
  u8 bRet ;
  u32 value32 ;

  {
#line 657
  bRet = 0U;
#line 658
  value32 = 0U;
#line 660
  if (GlobalDebugLevel23A > 3U) {
#line 660
    printk("\016RTL8723AU: %s: Efuse switch bank to %d\n", "hal_EfuseSwitchToBank",
           (int )bank);
  } else {

  }
#line 661
  value32 = rtl8723au_read32(padapter, 52U);
#line 662
  bRet = 1U;
#line 663
  switch ((int )bank) {
  case 0: 
#line 665
  value32 = value32 & 4294966527U;
#line 667
  goto ldv_54379;
  case 1: 
#line 669
  value32 = (value32 & 4294966527U) | 256U;
#line 671
  goto ldv_54379;
  case 2: 
#line 673
  value32 = (value32 & 4294966527U) | 512U;
#line 675
  goto ldv_54379;
  case 3: 
#line 677
  value32 = value32 | 768U;
#line 679
  goto ldv_54379;
  default: 
#line 681
  value32 = value32 & 4294966527U;
#line 683
  bRet = 0U;
#line 684
  goto ldv_54379;
  }
  ldv_54379: 
#line 686
  rtl8723au_write32(padapter, 52U, value32);
#line 688
  return (bRet);
}
}
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void hal_ReadEFuse_WiFi(struct rtw_adapter *padapter , u16 _offset , u16 _size_byte ,
                               u8 *pbuf ) 
{ 
  u8 *efuseTbl ;
  u16 eFuse_Addr ;
  u8 offset ;
  u8 wden ;
  u8 efuseHeader ;
  u8 efuseExtHdr ;
  u8 efuseData ;
  u16 i ;
  u16 total ;
  u16 used ;
  struct hal_data_8723a *pHalData ;
  void *tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;
  u16 addr ;
  u16 tmp___2 ;
  u16 tmp___3 ;
  u8 tmp___4 ;

  {
#line 695
  efuseTbl = (u8 *)0U;
#line 696
  eFuse_Addr = 0U;
#line 700
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 704
  if ((int )_offset + (int )_size_byte > 256) {
#line 705
    if (GlobalDebugLevel23A > 3U) {
#line 705
      printk("\016RTL8723AU: %s: Invalid offset(%#x) with read bytes(%#x)!!\n", "hal_ReadEFuse_WiFi",
             (int )_offset, (int )_size_byte);
    } else {

    }
#line 707
    return;
  } else {

  }
#line 710
  tmp = kmalloc(256UL, 208U);
#line 710
  efuseTbl = (u8 *)tmp;
#line 711
  if ((unsigned long )efuseTbl == (unsigned long )((u8 *)0U)) {
#line 712
    if (GlobalDebugLevel23A > 3U) {
#line 712
      printk("\016RTL8723AU: %s: alloc efuseTbl fail!\n", "hal_ReadEFuse_WiFi");
    } else {

    }
#line 713
    return;
  } else {

  }
#line 716
  memset((void *)efuseTbl, 255, 256UL);
#line 719
  hal_EfuseSwitchToBank(padapter, 0);
#line 721
  goto ldv_54403;
  ldv_54408: 
#line 722
  tmp___0 = eFuse_Addr;
#line 722
  eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 722
  ReadEFuseByte23a(padapter, (int )tmp___0, & efuseHeader);
#line 723
  if ((unsigned int )efuseHeader == 255U) {
#line 724
    if (GlobalDebugLevel23A > 3U) {
#line 724
      printk("\016RTL8723AU: %s: data end at address =%#x\n", "hal_ReadEFuse_WiFi",
             (int )eFuse_Addr);
    } else {

    }
#line 726
    goto ldv_54402;
  } else {

  }
#line 730
  if (((int )efuseHeader & 31) == 15) {
#line 731
    offset = (int )efuseHeader >> 5;
#line 733
    tmp___1 = eFuse_Addr;
#line 733
    eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 733
    ReadEFuseByte23a(padapter, (int )tmp___1, & efuseExtHdr);
#line 734
    if (((int )efuseExtHdr & 15) == 15) {
#line 735
      goto ldv_54403;
    } else {

    }
#line 738
    offset = (u8 )((int )((signed char )(((int )efuseExtHdr & 240) >> 1)) | (int )((signed char )offset));
#line 739
    wden = (unsigned int )efuseExtHdr & 15U;
  } else {
#line 741
    offset = (u8 )((int )efuseHeader >> 4);
#line 742
    wden = (unsigned int )efuseHeader & 15U;
  }
#line 745
  if ((unsigned int )offset <= 31U) {
#line 749
    addr = (unsigned int )((u16 )offset) * 8U;
#line 750
    i = 0U;
#line 750
    goto ldv_54406;
    ldv_54405: ;
#line 752
    if ((((int )wden >> (int )i) & 1) == 0) {
#line 753
      tmp___2 = eFuse_Addr;
#line 753
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 753
      ReadEFuseByte23a(padapter, (int )tmp___2, & efuseData);
#line 755
      *(efuseTbl + (unsigned long )addr) = efuseData;
#line 757
      tmp___3 = eFuse_Addr;
#line 757
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 757
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuseData);
#line 759
      *(efuseTbl + ((unsigned long )addr + 1UL)) = efuseData;
    } else {

    }
#line 761
    addr = (unsigned int )addr + 2U;
#line 750
    i = (u16 )((int )i + 1);
    ldv_54406: ;
#line 750
    if ((unsigned int )i <= 3U) {
#line 752
      goto ldv_54405;
    } else {

    }

  } else {
#line 764
    if (GlobalDebugLevel23A > 3U) {
#line 764
      printk("\016RTL8723AU: \v%s: offset(%d) is illegal!!\n", "hal_ReadEFuse_WiFi",
             (int )offset);
    } else {

    }
#line 766
    tmp___4 = Efuse_CalculateWordCnts23a((int )wden);
#line 766
    eFuse_Addr = (unsigned int )((u16 )tmp___4) * 2U + (unsigned int )eFuse_Addr;
  }
  ldv_54403: ;
#line 721
  if ((unsigned int )eFuse_Addr <= 511U) {
#line 723
    goto ldv_54408;
  } else {

  }
  ldv_54402: 
#line 771
  i = 0U;
#line 771
  goto ldv_54410;
  ldv_54409: 
#line 772
  *(pbuf + (unsigned long )i) = *(efuseTbl + (unsigned long )((int )_offset + (int )i));
#line 771
  i = (u16 )((int )i + 1);
  ldv_54410: ;
#line 771
  if ((int )i < (int )_size_byte) {
#line 773
    goto ldv_54409;
  } else {

  }
#line 775
  EFUSE_GetEfuseDefinition23a(padapter, 0, 3, (void *)(& total));
#line 777
  used = (unsigned int )eFuse_Addr + 65535U;
#line 778
  pHalData->EfuseUsedBytes = used;
#line 780
  kfree((void const   *)efuseTbl);
#line 781
  return;
}
}
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void hal_ReadEFuse_BT(struct rtw_adapter *padapter , u16 _offset , u16 _size_byte ,
                             u8 *pbuf ) 
{ 
  u8 *efuseTbl ;
  u8 bank ;
  u16 eFuse_Addr ;
  u8 efuseHeader ;
  u8 efuseExtHdr ;
  u8 efuseData ;
  u8 offset ;
  u8 wden ;
  u16 i ;
  u16 total ;
  u16 used ;
  struct hal_data_8723a *pHalData ;
  void *tmp ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 addr ;
  u16 tmp___3 ;
  u16 tmp___4 ;
  u8 tmp___5 ;

  {
#line 793
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 797
  if ((int )_offset + (int )_size_byte > 1024) {
#line 798
    if (GlobalDebugLevel23A > 3U) {
#line 798
      printk("\016RTL8723AU: %s: Invalid offset(%#x) with read bytes(%#x)!!\n", "hal_ReadEFuse_BT",
             (int )_offset, (int )_size_byte);
    } else {

    }
#line 800
    return;
  } else {

  }
#line 803
  tmp = kmalloc(1024UL, 208U);
#line 803
  efuseTbl = (u8 *)tmp;
#line 804
  if ((unsigned long )efuseTbl == (unsigned long )((u8 *)0U)) {
#line 805
    if (GlobalDebugLevel23A > 3U) {
#line 805
      printk("\016RTL8723AU: %s: efuseTbl malloc fail!\n", "hal_ReadEFuse_BT");
    } else {

    }
#line 806
    return;
  } else {

  }
#line 809
  memset((void *)efuseTbl, 255, 1024UL);
#line 811
  EFUSE_GetEfuseDefinition23a(padapter, 1, 2, (void *)(& total));
#line 814
  bank = 1U;
#line 814
  goto ldv_54441;
  ldv_54440: 
#line 815
  tmp___0 = hal_EfuseSwitchToBank(padapter, (int )bank);
#line 815
  if ((unsigned int )tmp___0 == 0U) {
#line 816
    if (GlobalDebugLevel23A > 3U) {
#line 816
      printk("\016RTL8723AU: %s: hal_EfuseSwitchToBank Fail!!\n", "hal_ReadEFuse_BT");
    } else {

    }
#line 818
    goto exit;
  } else {

  }
#line 821
  eFuse_Addr = 0U;
#line 823
  goto ldv_54433;
  ldv_54438: 
#line 824
  tmp___1 = eFuse_Addr;
#line 824
  eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 824
  ReadEFuseByte23a(padapter, (int )tmp___1, & efuseHeader);
#line 825
  if ((unsigned int )efuseHeader == 255U) {
#line 826
    goto ldv_54432;
  } else {

  }
#line 829
  if (((int )efuseHeader & 31) == 15) {
#line 830
    offset = (int )efuseHeader >> 5;
#line 832
    tmp___2 = eFuse_Addr;
#line 832
    eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 832
    ReadEFuseByte23a(padapter, (int )tmp___2, & efuseExtHdr);
#line 834
    if (((int )efuseExtHdr & 15) == 15) {
#line 835
      goto ldv_54433;
    } else {

    }
#line 838
    offset = (u8 )((int )((signed char )(((int )efuseExtHdr & 240) >> 1)) | (int )((signed char )offset));
#line 839
    wden = (unsigned int )efuseExtHdr & 15U;
  } else {
#line 841
    offset = (u8 )((int )efuseHeader >> 4);
#line 842
    wden = (unsigned int )efuseHeader & 15U;
  }
#line 845
  if ((int )((signed char )offset) >= 0) {
#line 850
    addr = (unsigned int )((u16 )offset) * 8U;
#line 851
    i = 0U;
#line 851
    goto ldv_54436;
    ldv_54435: ;
#line 854
    if ((((int )wden >> (int )i) & 1) == 0) {
#line 855
      tmp___3 = eFuse_Addr;
#line 855
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 855
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuseData);
#line 858
      *(efuseTbl + (unsigned long )addr) = efuseData;
#line 860
      tmp___4 = eFuse_Addr;
#line 860
      eFuse_Addr = (u16 )((int )eFuse_Addr + 1);
#line 860
      ReadEFuseByte23a(padapter, (int )tmp___4, & efuseData);
#line 863
      *(efuseTbl + ((unsigned long )addr + 1UL)) = efuseData;
    } else {

    }
#line 865
    addr = (unsigned int )addr + 2U;
#line 851
    i = (u16 )((int )i + 1);
    ldv_54436: ;
#line 851
    if ((unsigned int )i <= 3U) {
#line 853
      goto ldv_54435;
    } else {

    }

  } else {
#line 868
    if (GlobalDebugLevel23A > 3U) {
#line 868
      printk("\016RTL8723AU: \v%s: offset(%d) is illegal!!\n", "hal_ReadEFuse_BT",
             (int )offset);
    } else {

    }
#line 871
    tmp___5 = Efuse_CalculateWordCnts23a((int )wden);
#line 871
    eFuse_Addr = (unsigned int )((u16 )tmp___5) * 2U + (unsigned int )eFuse_Addr;
  }
  ldv_54433: ;
#line 823
  if ((unsigned int )eFuse_Addr <= 511U) {
#line 825
    goto ldv_54438;
  } else {

  }
  ldv_54432: ;
#line 875
  if ((int )eFuse_Addr + -1 < (int )total) {
#line 876
    if (GlobalDebugLevel23A > 3U) {
#line 876
      printk("\016RTL8723AU: %s: bank(%d) data end at %#x\n", "hal_ReadEFuse_BT",
             (int )bank, (int )eFuse_Addr + -1);
    } else {

    }
#line 878
    goto ldv_54439;
  } else {

  }
#line 814
  bank = (u8 )((int )bank + 1);
  ldv_54441: ;
#line 814
  if ((unsigned int )bank <= 3U) {
#line 816
    goto ldv_54440;
  } else {

  }
  ldv_54439: 
#line 883
  hal_EfuseSwitchToBank(padapter, 0);
#line 886
  i = 0U;
#line 886
  goto ldv_54443;
  ldv_54442: 
#line 887
  *(pbuf + (unsigned long )i) = *(efuseTbl + (unsigned long )((int )_offset + (int )i));
#line 886
  i = (u16 )((int )i + 1);
  ldv_54443: ;
#line 886
  if ((int )i < (int )_size_byte) {
#line 888
    goto ldv_54442;
  } else {

  }
#line 892
  EFUSE_GetEfuseDefinition23a(padapter, 1, 3, (void *)(& total));
#line 894
  used = ((unsigned int )((u16 )((int )bank + -1)) * 512U + (unsigned int )eFuse_Addr) + 65535U;
#line 895
  pHalData->BTEfuseUsedBytes = used;
  exit: 
#line 898
  kfree((void const   *)efuseTbl);
#line 899
  return;
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_readefuse(struct rtw_adapter *padapter , u8 efuseType , u16 _offset ,
                        u16 _size_byte , u8 *pbuf ) 
{ 


  {
#line 905
  if ((unsigned int )efuseType == 0U) {
#line 906
    hal_ReadEFuse_WiFi(padapter, (int )_offset, (int )_size_byte, pbuf);
  } else {
#line 908
    hal_ReadEFuse_BT(padapter, (int )_offset, (int )_size_byte, pbuf);
  }
#line 909
  return;
}
}
#line 911 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
u16 rtl8723a_EfuseGetCurrentSize_WiFi(struct rtw_adapter *padapter ) 
{ 
  u16 efuse_addr ;
  u8 hoffset ;
  u8 hworden ;
  u8 efuse_data ;
  u8 word_cnts ;
  struct hal_data_8723a *pHalData ;
  int tmp ;

  {
#line 913
  efuse_addr = 0U;
#line 914
  hoffset = 0U;
#line 914
  hworden = 0U;
#line 915
  word_cnts = 0U;
#line 916
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 918
  efuse_addr = pHalData->EfuseUsedBytes;
#line 920
  if (GlobalDebugLevel23A > 3U) {
#line 920
    printk("\016RTL8723AU: %s: start_efuse_addr = 0x%X\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
           (int )efuse_addr);
  } else {

  }
#line 923
  hal_EfuseSwitchToBank(padapter, 0);
#line 925
  goto ldv_54463;
  ldv_54464: 
#line 926
  tmp = efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
#line 926
  if (tmp == 0) {
#line 928
    if (GlobalDebugLevel23A > 3U) {
#line 928
      printk("\016RTL8723AU: \v%s: efuse_OneByteRead23a Fail! addr = 0x%X !!\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
             (int )efuse_addr);
    } else {

    }
#line 930
    goto ldv_54462;
  } else {

  }
#line 933
  if ((unsigned int )efuse_data == 255U) {
#line 934
    goto ldv_54462;
  } else {

  }
#line 936
  if (((int )efuse_data & 31) == 15) {
#line 937
    hoffset = (int )efuse_data >> 5;
#line 938
    efuse_addr = (u16 )((int )efuse_addr + 1);
#line 939
    efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
#line 940
    if (((int )efuse_data & 15) == 15) {
#line 941
      goto ldv_54463;
    } else {

    }
#line 944
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
#line 945
    hworden = (unsigned int )efuse_data & 15U;
  } else {
#line 947
    hoffset = (u8 )((int )efuse_data >> 4);
#line 948
    hworden = (unsigned int )efuse_data & 15U;
  }
#line 951
  word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
#line 952
  efuse_addr = ((unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr) + 1U;
  ldv_54463: ;
#line 925
  if ((unsigned int )efuse_addr <= 511U) {
#line 927
    goto ldv_54464;
  } else {

  }
  ldv_54462: 
#line 955
  pHalData->EfuseUsedBytes = efuse_addr;
#line 957
  if (GlobalDebugLevel23A > 3U) {
#line 957
    printk("\016RTL8723AU: %s: CurrentSize =%d\n", "rtl8723a_EfuseGetCurrentSize_WiFi",
           (int )efuse_addr);
  } else {

  }
#line 959
  return (efuse_addr);
}
}
#line 962 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
u16 rtl8723a_EfuseGetCurrentSize_BT(struct rtw_adapter *padapter ) 
{ 
  u16 btusedbytes ;
  u16 efuse_addr ;
  u8 bank ;
  u8 startBank ;
  u8 hoffset ;
  u8 hworden ;
  u8 efuse_data ;
  u8 word_cnts ;
  u16 retU2 ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  int tmp___0 ;

  {
#line 967
  hoffset = 0U;
#line 967
  hworden = 0U;
#line 968
  word_cnts = 0U;
#line 969
  retU2 = 0U;
#line 970
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 972
  btusedbytes = pHalData->BTEfuseUsedBytes;
#line 974
  efuse_addr = (unsigned int )btusedbytes & 511U;
#line 975
  startBank = (unsigned int )((unsigned char )((unsigned int )btusedbytes / 512U)) + 1U;
#line 977
  if (GlobalDebugLevel23A > 3U) {
#line 977
    printk("\016RTL8723AU: %s: start from bank =%d addr = 0x%X\n", "rtl8723a_EfuseGetCurrentSize_BT",
           (int )startBank, (int )efuse_addr);
  } else {

  }
#line 980
  EFUSE_GetEfuseDefinition23a(padapter, 1, 2, (void *)(& retU2));
#line 983
  bank = startBank;
#line 983
  goto ldv_54484;
  ldv_54483: 
#line 984
  tmp = hal_EfuseSwitchToBank(padapter, (int )bank);
#line 984
  if ((unsigned int )tmp == 0U) {
#line 985
    if (GlobalDebugLevel23A > 3U) {
#line 985
      printk("\016RTL8723AU: \v%s: switch bank(%d) Fail!!\n", "rtl8723a_EfuseGetCurrentSize_BT",
             (int )bank);
    } else {

    }
#line 987
    bank = 4U;
#line 988
    goto ldv_54479;
  } else {

  }
#line 993
  if ((int )bank != (int )startBank) {
#line 994
    efuse_addr = 0U;
  } else {

  }
#line 996
  goto ldv_54481;
  ldv_54482: 
#line 997
  tmp___0 = efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
#line 997
  if (tmp___0 == 0) {
#line 999
    if (GlobalDebugLevel23A > 3U) {
#line 999
      printk("\016RTL8723AU: \v%s: efuse_OneByteRead23a Fail! addr = 0x%X !!\n", "rtl8723a_EfuseGetCurrentSize_BT",
             (int )efuse_addr);
    } else {

    }
#line 1002
    bank = 4U;
#line 1003
    goto ldv_54480;
  } else {

  }
#line 1006
  if ((unsigned int )efuse_data == 255U) {
#line 1007
    goto ldv_54480;
  } else {

  }
#line 1009
  if (((int )efuse_data & 31) == 15) {
#line 1010
    hoffset = (int )efuse_data >> 5;
#line 1011
    efuse_addr = (u16 )((int )efuse_addr + 1);
#line 1012
    efuse_OneByteRead23a(padapter, (int )efuse_addr, & efuse_data);
#line 1014
    if (((int )efuse_data & 15) == 15) {
#line 1015
      efuse_addr = (u16 )((int )efuse_addr + 1);
#line 1016
      goto ldv_54481;
    } else {

    }
#line 1019
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
#line 1020
    hworden = (unsigned int )efuse_data & 15U;
  } else {
#line 1022
    hoffset = (u8 )((int )efuse_data >> 4);
#line 1023
    hworden = (unsigned int )efuse_data & 15U;
  }
#line 1025
  word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
#line 1027
  efuse_addr = ((unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr) + 1U;
  ldv_54481: ;
#line 996
  if ((unsigned int )efuse_addr <= 511U) {
#line 998
    goto ldv_54482;
  } else {

  }
  ldv_54480: ;
#line 1031
  if ((int )efuse_addr < (int )retU2) {
#line 1032
    goto ldv_54479;
  } else {

  }
#line 983
  bank = (u8 )((int )bank + 1);
  ldv_54484: ;
#line 983
  if ((unsigned int )bank <= 3U) {
#line 985
    goto ldv_54483;
  } else {

  }
  ldv_54479: 
#line 1036
  retU2 = (unsigned int )((u16 )((int )bank + -1)) * 512U + (unsigned int )efuse_addr;
#line 1037
  pHalData->BTEfuseUsedBytes = retU2;
#line 1039
  if (GlobalDebugLevel23A > 3U) {
#line 1039
    printk("\016RTL8723AU: %s: CurrentSize =%d\n", "rtl8723a_EfuseGetCurrentSize_BT",
           (int )retU2);
  } else {

  }
#line 1040
  return (retU2);
}
}
#line 1044 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
bool rtl8723a_EfusePgPacketRead(struct rtw_adapter *padapter , u8 offset , u8 *data ) 
{ 
  u8 efuse_data ;
  u8 word_cnts ;
  u16 efuse_addr ;
  u8 hoffset ;
  u8 hworden ;
  u8 i ;
  u8 max_section ;
  s32 ret ;
  u16 tmp ;
  int tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  u16 tmp___3 ;

  {
#line 1046
  word_cnts = 0U;
#line 1047
  efuse_addr = 0U;
#line 1048
  hoffset = 0U;
#line 1048
  hworden = 0U;
#line 1050
  max_section = 0U;
#line 1053
  if ((unsigned long )data == (unsigned long )((u8 *)0U)) {
#line 1054
    return (0);
  } else {

  }
#line 1056
  EFUSE_GetEfuseDefinition23a(padapter, 0, 0, (void *)(& max_section));
#line 1058
  if ((int )offset > (int )max_section) {
#line 1059
    if (GlobalDebugLevel23A > 3U) {
#line 1059
      printk("\016RTL8723AU: %s: Packet offset(%d) is illegal(>%d)!\n", "rtl8723a_EfusePgPacketRead",
             (int )offset, (int )max_section);
    } else {

    }
#line 1061
    return (0);
  } else {

  }
#line 1064
  memset((void *)data, 255, 8UL);
#line 1065
  ret = 1;
#line 1073
  goto ldv_54500;
  ldv_54504: 
#line 1074
  tmp = efuse_addr;
#line 1074
  efuse_addr = (u16 )((int )efuse_addr + 1);
#line 1074
  tmp___0 = efuse_OneByteRead23a(padapter, (int )tmp, & efuse_data);
#line 1074
  if (tmp___0 == 0) {
#line 1076
    ret = 0;
#line 1077
    goto ldv_54499;
  } else {

  }
#line 1080
  if ((unsigned int )efuse_data == 255U) {
#line 1081
    goto ldv_54499;
  } else {

  }
#line 1083
  if (((int )efuse_data & 31) == 15) {
#line 1084
    hoffset = (int )efuse_data >> 5;
#line 1085
    tmp___1 = efuse_addr;
#line 1085
    efuse_addr = (u16 )((int )efuse_addr + 1);
#line 1085
    efuse_OneByteRead23a(padapter, (int )tmp___1, & efuse_data);
#line 1086
    if (((int )efuse_data & 15) == 15) {
#line 1087
      if (GlobalDebugLevel23A > 3U) {
#line 1087
        printk("\016RTL8723AU: %s: Error!! All words disabled!\n", "rtl8723a_EfusePgPacketRead");
      } else {

      }
#line 1089
      goto ldv_54500;
    } else {

    }
#line 1092
    hoffset = (u8 )((int )((signed char )(((int )efuse_data & 240) >> 1)) | (int )((signed char )hoffset));
#line 1093
    hworden = (unsigned int )efuse_data & 15U;
  } else {
#line 1095
    hoffset = (u8 )((int )efuse_data >> 4);
#line 1096
    hworden = (unsigned int )efuse_data & 15U;
  }
#line 1099
  if ((int )hoffset == (int )offset) {
#line 1100
    i = 0U;
#line 1100
    goto ldv_54502;
    ldv_54501: ;
#line 1102
    if ((((int )hworden >> (int )i) & 1) == 0) {
#line 1103
      tmp___2 = efuse_addr;
#line 1103
      efuse_addr = (u16 )((int )efuse_addr + 1);
#line 1103
      ReadEFuseByte23a(padapter, (int )tmp___2, & efuse_data);
#line 1105
      *(data + (unsigned long )((int )i * 2)) = efuse_data;
#line 1107
      tmp___3 = efuse_addr;
#line 1107
      efuse_addr = (u16 )((int )efuse_addr + 1);
#line 1107
      ReadEFuseByte23a(padapter, (int )tmp___3, & efuse_data);
#line 1109
      *(data + ((unsigned long )((int )i * 2) + 1UL)) = efuse_data;
    } else {

    }
#line 1100
    i = (u8 )((int )i + 1);
    ldv_54502: ;
#line 1100
    if ((unsigned int )i <= 3U) {
#line 1102
      goto ldv_54501;
    } else {

    }

  } else {
#line 1113
    word_cnts = Efuse_CalculateWordCnts23a((int )hworden);
#line 1114
    efuse_addr = (unsigned int )((u16 )word_cnts) * 2U + (unsigned int )efuse_addr;
  }
  ldv_54500: ;
#line 1073
  if ((unsigned int )efuse_addr <= 511U) {
#line 1075
    goto ldv_54504;
  } else {

  }
  ldv_54499: ;
#line 1118
  return (ret != 0);
}
}
#line 1121 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_read_chip_version(struct rtw_adapter *padapter ) 
{ 
  u32 value32 ;
  struct hal_version ChipVersion ;
  struct hal_data_8723a *pHalData ;

  {
#line 1127
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1129
  value32 = rtl8723au_read32(padapter, 240U);
#line 1130
  ChipVersion.ICType = 4;
#line 1131
  ChipVersion.ChipType = ((unsigned long )value32 & 8388608UL) == 0UL;
#line 1132
  ChipVersion.RFType = 0;
#line 1133
  ChipVersion.VendorType = ((unsigned long )value32 & 524288UL) != 0UL;
#line 1135
  ChipVersion.CUTVersion = (enum hal_cut_version )((value32 & 61440U) >> 12);
#line 1138
  pHalData->RegulatorMode = ((unsigned long )value32 & 16777216UL) != 0UL;
#line 1141
  value32 = rtl8723au_read32(padapter, 244U);
#line 1143
  ChipVersion.ROMVer = (u8 )(((unsigned long )value32 & 4026531840UL) >> 20);
#line 1146
  pHalData->MultiFunc = 0;
#line 1147
  value32 = rtl8723au_read32(padapter, 104U);
#line 1148
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 4UL) != 0UL ? 1U : 0U));
#line 1150
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 262144UL) != 0UL ? 2U : 0U));
#line 1151
  pHalData->MultiFunc = (enum RT_MULTI_FUNC )((unsigned int )pHalData->MultiFunc | (((unsigned long )value32 & 4194304UL) != 0UL ? 4U : 0U));
#line 1153
  pHalData->PolarityCtl = ((unsigned long )value32 & 2UL) != 0UL;
#line 1156
  dump_chip_info23a(ChipVersion);
#line 1157
  pHalData->VersionID = ChipVersion;
#line 1159
  if ((unsigned int )ChipVersion.RFType == 1U) {
#line 1160
    pHalData->rf_type = 0U;
  } else
#line 1161
  if ((unsigned int )ChipVersion.RFType == 2U) {
#line 1162
    pHalData->rf_type = 2U;
  } else {
#line 1164
    pHalData->rf_type = 3U;
  }
#line 1166
  if (GlobalDebugLevel23A > 3U) {
#line 1166
    printk("\016RTL8723AU: RF_Type is %x!!\n", (int )pHalData->rf_type);
  } else {

  }
#line 1167
  return;
}
}
#line 1180 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void SetBcnCtrlReg23a(struct rtw_adapter *padapter , u8 SetBits , u8 ClearBits ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 addr ;
  u8 *pRegBcnCtrlVal ;

  {
#line 1186
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1187
  pRegBcnCtrlVal = (u8 *)(& pHalData->RegBcnCtrlVal);
#line 1189
  addr = 1360U;
#line 1191
  *pRegBcnCtrlVal = rtl8723au_read8(padapter, addr);
#line 1192
  *pRegBcnCtrlVal = (u8 )((int )*pRegBcnCtrlVal | (int )SetBits);
#line 1193
  *pRegBcnCtrlVal = (u8 )((int )((signed char )*pRegBcnCtrlVal) & ~ ((int )((signed char )ClearBits)));
#line 1195
  rtl8723au_write8(padapter, addr, (int )*pRegBcnCtrlVal);
#line 1196
  return;
}
}
#line 1198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_InitBeaconParameters(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  int tmp___0 ;

  {
#line 1200
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1202
  rtl8723au_write16(padapter, 1360U, 4112);
#line 1203
  pHalData->RegBcnCtrlVal = 4112U;
#line 1206
  rtl8723au_write16(padapter, 1344U, 25604);
#line 1209
  tmp = check_fwstate(& padapter->mlmepriv, 8);
#line 1209
  if (tmp) {
#line 1209
    tmp___0 = 0;
  } else {
#line 1209
    tmp___0 = 1;
  }
#line 1209
  if (tmp___0) {
#line 1210
    rtl8723au_write8(padapter, 1368U, 5);
  } else {

  }
#line 1213
  rtl8723au_write8(padapter, 1369U, 2);
#line 1218
  rtl8723au_write16(padapter, 1296U, 26127);
#line 1219
  return;
}
}
#line 1221 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void ResumeTxBeacon(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1223
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1229
  if (GlobalDebugLevel23A > 6U) {
#line 1229
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 1229
    printk("\016+ResumeTxBeacon\n");
  } else {

  }
#line 1231
  pHalData->RegFwHwTxQCtrl = (u8 )((unsigned int )pHalData->RegFwHwTxQCtrl | 64U);
#line 1232
  rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl);
#line 1234
  rtl8723au_write8(padapter, 1345U, 255);
#line 1235
  pHalData->RegReg542 = (u8 )((unsigned int )pHalData->RegReg542 | 1U);
#line 1236
  rtl8723au_write8(padapter, 1346U, (int )pHalData->RegReg542);
#line 1237
  return;
}
}
#line 1239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void StopTxBeacon(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1241
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1247
  if (GlobalDebugLevel23A > 6U) {
#line 1247
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 1247
    printk("\016+StopTxBeacon\n");
  } else {

  }
#line 1249
  pHalData->RegFwHwTxQCtrl = (unsigned int )pHalData->RegFwHwTxQCtrl & 191U;
#line 1250
  rtl8723au_write8(padapter, 1058U, (int )pHalData->RegFwHwTxQCtrl);
#line 1252
  rtl8723au_write8(padapter, 1345U, 100);
#line 1253
  pHalData->RegReg542 = (unsigned int )pHalData->RegReg542 & 254U;
#line 1254
  rtl8723au_write8(padapter, 1346U, (int )pHalData->RegReg542);
#line 1256
  CheckFwRsvdPageContent23a(padapter);
#line 1257
  return;
}
}
#line 1259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void _BeaconFunctionEnable(struct rtw_adapter *padapter , u8 Enable , u8 Linked ) 
{ 


  {
#line 1262
  SetBcnCtrlReg23a(padapter, 26, 0);
#line 1264
  rtl8723au_write8(padapter, 1317U, 111);
#line 1265
  return;
}
}
#line 1267 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_SetBeaconRelatedRegisters(struct rtw_adapter *padapter ) 
{ 
  u32 value32 ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  bool tmp ;

  {
#line 1270
  pmlmeext = & padapter->mlmeextpriv;
#line 1271
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1288
  rtl8723au_write16(padapter, 1370U, 2);
#line 1293
  rtl8723au_write16(padapter, 1364U, (int )pmlmeinfo->bcn_interval);
#line 1295
  rtl8723a_InitBeaconParameters(padapter);
#line 1297
  rtl8723au_write8(padapter, 1307U, 9);
#line 1302
  value32 = rtl8723au_read32(padapter, 1540U);
#line 1303
  value32 = value32 & 4294967294U;
#line 1304
  rtl8723au_write32(padapter, 1540U, value32);
#line 1306
  value32 = value32 | 1U;
#line 1307
  rtl8723au_write32(padapter, 1540U, value32);
#line 1310
  tmp = check_fwstate(& padapter->mlmepriv, 112);
#line 1310
  if ((int )tmp) {
#line 1312
    rtl8723au_write8(padapter, 1374U, 80);
#line 1313
    rtl8723au_write8(padapter, 1375U, 80);
  } else {

  }
#line 1316
  _BeaconFunctionEnable(padapter, 1, 1);
#line 1318
  ResumeTxBeacon(padapter);
#line 1319
  SetBcnCtrlReg23a(padapter, 2, 0);
#line 1320
  return;
}
}
#line 1322 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_SetHalODMVar(struct rtw_adapter *Adapter , enum hal_odm_variable eVariable ,
                           void *pValue1 , bool bSet ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *podmpriv ;
  struct sta_info *psta ;

  {
#line 1326
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1327
  podmpriv = & pHalData->odmpriv;
#line 1328
  switch ((unsigned int )eVariable) {
  case 0U: 
#line 1331
  psta = (struct sta_info *)pValue1;
#line 1333
  if ((int )bSet) {
#line 1334
    if (GlobalDebugLevel23A > 3U) {
#line 1334
      printk("\016RTL8723AU: Set STA_(%d) info\n", psta->mac_id);
    } else {

    }
#line 1335
    ODM_CmnInfoPtrArrayHook23a(podmpriv, 51, (int )((u16 )psta->mac_id), (void *)psta);
  } else {
#line 1339
    if (GlobalDebugLevel23A > 3U) {
#line 1339
      printk("\016RTL8723AU: Clean STA_(%d) info\n", psta->mac_id);
    } else {

    }
#line 1340
    ODM_CmnInfoPtrArrayHook23a(podmpriv, 51, (int )((u16 )psta->mac_id), (void *)0);
  }
#line 1345
  goto ldv_54552;
  case 1U: 
#line 1347
  ODM_CmnInfoUpdate23a(podmpriv, 37U, (u64 )bSet);
#line 1348
  goto ldv_54552;
  case 2U: 
#line 1350
  ODM_CmnInfoUpdate23a(podmpriv, 38U, (u64 )bSet);
#line 1351
  goto ldv_54552;
  default: ;
#line 1353
  goto ldv_54552;
  }
  ldv_54552: ;
#line 1356
  return;
}
}
#line 1357 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_notch_filter(struct rtw_adapter *adapter , bool enable ) 
{ 
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 1359
  if ((int )enable) {
#line 1360
    if (GlobalDebugLevel23A > 3U) {
#line 1360
      printk("\016RTL8723AU: Enable notch filter\n");
    } else {

    }
#line 1361
    tmp = rtl8723au_read8(adapter, 3137U);
#line 1361
    rtl8723au_write8(adapter, 3137U, (int )((unsigned int )tmp | 2U));
  } else {
#line 1365
    if (GlobalDebugLevel23A > 3U) {
#line 1365
      printk("\016RTL8723AU: Disable notch filter\n");
    } else {

    }
#line 1366
    tmp___0 = rtl8723au_read8(adapter, 3137U);
#line 1366
    rtl8723au_write8(adapter, 3137U, (int )tmp___0 & 253);
  }
#line 1369
  return;
}
}
#line 1372 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
bool c2h_id_filter_ccx_8723a(u8 id ) 
{ 
  bool ret ;

  {
#line 1374
  ret = 0;
#line 1375
  if ((unsigned int )id == 3U) {
#line 1376
    ret = 1;
  } else {

  }
#line 1378
  return (ret);
}
}
#line 1381 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
int c2h_handler_8723a(struct rtw_adapter *padapter , struct c2h_evt_hdr *c2h_evt ) 
{ 
  int ret ;
  u8 i ;

  {
#line 1383
  ret = 1;
#line 1384
  i = 0U;
#line 1386
  if ((unsigned long )c2h_evt == (unsigned long )((struct c2h_evt_hdr *)0)) {
#line 1387
    if (GlobalDebugLevel23A > 3U) {
#line 1387
      printk("\016RTL8723AU: %s c2h_evt is NULL\n", "c2h_handler_8723a");
    } else {

    }
#line 1388
    ret = 0;
#line 1389
    goto exit;
  } else {

  }
#line 1392
  switch ((int )c2h_evt->id) {
  case 0: ;
#line 1394
  if (GlobalDebugLevel23A > 6U) {
#line 1394
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 1394
    printk("\016C2HCommandHandler: %s\n", (u8 *)(& c2h_evt->payload));
  } else {

  }
#line 1396
  goto ldv_54573;
  case 3: 
#line 1399
  handle_txrpt_ccx_8723a(padapter, (void *)(& c2h_evt->payload));
#line 1400
  goto ldv_54573;
  case 6: ;
#line 1402
  goto ldv_54573;
  case 10: ;
#line 1404
  if (GlobalDebugLevel23A > 6U) {
#line 1404
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 1404
    printk("\016[BT], C2H_HW_INFO_EXCH\n");
  } else {

  }
#line 1406
  i = 0U;
#line 1406
  goto ldv_54578;
  ldv_54577: ;
#line 1407
  if (GlobalDebugLevel23A > 6U) {
#line 1407
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 1407
    printk("\016[BT], tmpBuf[%d]= 0x%x\n", (int )i, (int )c2h_evt->payload[(int )i]);
  } else {

  }
#line 1406
  i = (u8 )((int )i + 1);
  ldv_54578: ;
#line 1406
  if ((int )i < (int )c2h_evt->plen) {
#line 1408
    goto ldv_54577;
  } else {

  }

#line 1411
  goto ldv_54573;
  case 11: ;
#line 1414
  if (GlobalDebugLevel23A > 6U) {
#line 1414
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 1414
    printk("\016[BT], C2H_H2C_TEST\n");
  } else {

  }
#line 1416
  if (GlobalDebugLevel23A > 6U) {
#line 1416
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 1416
    printk("\016[BT], tmpBuf[0]/[1]/[2]/[3]/[4]= 0x%x/ 0x%x/ 0x%x/ 0x%x/ 0x%x\n",
           (int )c2h_evt->payload[0], (int )c2h_evt->payload[1], (int )c2h_evt->payload[2],
           (int )c2h_evt->payload[3], (int )c2h_evt->payload[4]);
  } else {

  }
#line 1421
  goto ldv_54573;
  case 12: ;
#line 1424
  if (GlobalDebugLevel23A > 3U) {
#line 1424
    printk("\016RTL8723AU: %s ,  Got  C2H_BT_INFO \n", "c2h_handler_8723a");
  } else {

  }
#line 1425
  rtl8723a_fw_c2h_BT_info(padapter, (u8 *)(& c2h_evt->payload), (int )c2h_evt->plen);
#line 1427
  goto ldv_54573;
  default: 
#line 1430
  ret = 0;
#line 1431
  goto ldv_54573;
  }
  ldv_54573: ;
  exit: ;
#line 1435
  return (ret);
}
}
#line 1438 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_InitAntenna_Selection(struct rtw_adapter *padapter ) 
{ 
  u8 val ;

  {
#line 1442
  val = rtl8723au_read8(padapter, 78U);
#line 1444
  val = (u8 )((unsigned int )val | 128U);
#line 1445
  rtl8723au_write8(padapter, 78U, (int )val);
#line 1446
  return;
}
}
#line 1448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_CheckAntenna_Selection(struct rtw_adapter *padapter ) 
{ 
  u8 val ;

  {
#line 1452
  val = rtl8723au_read8(padapter, 78U);
#line 1454
  if ((int )((signed char )val) >= 0) {
#line 1455
    val = (u8 )((unsigned int )val | 128U);
#line 1456
    rtl8723au_write8(padapter, 78U, (int )val);
  } else {

  }
#line 1458
  return;
}
}
#line 1460 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_DeinitAntenna_Selection(struct rtw_adapter *padapter ) 
{ 
  u8 val ;

  {
#line 1464
  val = rtl8723au_read8(padapter, 78U);
#line 1466
  val = (unsigned int )val & 127U;
#line 1467
  rtl8723au_write8(padapter, 78U, (int )val);
#line 1468
  return;
}
}
#line 1470 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_init_default_value(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 i ;

  {
#line 1476
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1477
  pdmpriv = & pHalData->dmpriv;
#line 1480
  pHalData->fw_ractrl = 0U;
#line 1481
  pHalData->bIQKInitialized = 0U;
#line 1482
  if ((unsigned int )padapter->pwrctrlpriv.bkeepfwalive == 0U) {
#line 1483
    pHalData->LastHMEBoxNum = 0U;
  } else {

  }
#line 1485
  pHalData->bIQKInitialized = 0U;
#line 1488
  pdmpriv->TM_Trigger = 0U;
#line 1493
  pdmpriv->ThermalValue_HP_index = 0U;
#line 1494
  i = 0U;
#line 1494
  goto ldv_54602;
  ldv_54601: 
#line 1495
  pdmpriv->ThermalValue_HP[(int )i] = 0U;
#line 1494
  i = (u8 )((int )i + 1);
  ldv_54602: ;
#line 1494
  if ((unsigned int )i <= 7U) {
#line 1496
    goto ldv_54601;
  } else {

  }
#line 1498
  pHalData->EfuseUsedBytes = 0U;
#line 1499
  pHalData->BTEfuseUsedBytes = 0U;
#line 1500
  return;
}
}
#line 1502 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
u8 GetEEPROMSize8723A(struct rtw_adapter *padapter ) 
{ 
  u8 size ;
  u32 cr ;
  u16 tmp ;

  {
#line 1504
  size = 0U;
#line 1507
  tmp = rtl8723au_read16(padapter, 10U);
#line 1507
  cr = (u32 )tmp;
#line 1509
  size = ((unsigned long )cr & 16UL) != 0UL ? 6U : 4U;
#line 1511
  if (GlobalDebugLevel23A > 3U) {
#line 1511
    printk("\016RTL8723AU: EEPROM type is %s\n", (unsigned int )size == 4U ? (char *)"E-FUSE" : (char *)"93C46");
  } else {

  }
#line 1513
  return (size);
}
}
#line 1521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static int _LLTWrite(struct rtw_adapter *padapter , u32 address , u32 data ) 
{ 
  int status ;
  s32 count ;
  u32 value ;
  u16 LLTReg ;
  s32 tmp ;

  {
#line 1523
  status = 1;
#line 1524
  count = 0;
#line 1525
  value = (((address << 8) & 65535U) | (data & 255U)) | 1073741824U;
#line 1527
  LLTReg = 480U;
#line 1529
  rtl8723au_write32(padapter, (u32 )LLTReg, value);
  ldv_54619: 
#line 1533
  value = rtl8723au_read32(padapter, (u32 )LLTReg);
#line 1534
  if (value >> 30 == 0U) {
#line 1535
    goto ldv_54618;
  } else {

  }
#line 1538
  if (count > 20) {
#line 1539
    if (GlobalDebugLevel23A > 3U) {
#line 1539
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
#line 1539
      printk("\016Failed to polling write LLT done at address %d!\n", address);
    } else {

    }
#line 1542
    status = 0;
#line 1543
    goto ldv_54618;
  } else {

  }
#line 1545
  tmp = count;
#line 1545
  count = count + 1;
#line 1545
  if (tmp != 0) {
#line 1547
    goto ldv_54619;
  } else {

  }
  ldv_54618: ;
#line 1547
  return (status);
}
}
#line 1550 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
s32 InitLLTTable23a(struct rtw_adapter *padapter , u32 boundary ) 
{ 
  int status ;
  u32 i ;
  u32 txpktbuf_bndy ;
  u32 Last_Entry_Of_TxPktBuf ;

  {
#line 1552
  status = 1;
#line 1554
  txpktbuf_bndy = boundary;
#line 1555
  Last_Entry_Of_TxPktBuf = 255U;
#line 1557
  i = 0U;
#line 1557
  goto ldv_54629;
  ldv_54628: 
#line 1558
  status = _LLTWrite(padapter, i, i + 1U);
#line 1559
  if (status != 1) {
#line 1560
    return (status);
  } else {

  }
#line 1557
  i = i + 1U;
  ldv_54629: ;
#line 1557
  if (txpktbuf_bndy - 1U > i) {
#line 1559
    goto ldv_54628;
  } else {

  }
#line 1565
  status = _LLTWrite(padapter, txpktbuf_bndy - 1U, 255U);
#line 1566
  if (status != 1) {
#line 1567
    return (status);
  } else {

  }
#line 1574
  i = txpktbuf_bndy;
#line 1574
  goto ldv_54632;
  ldv_54631: 
#line 1575
  status = _LLTWrite(padapter, i, i + 1U);
#line 1576
  if (status != 1) {
#line 1577
    return (status);
  } else {

  }
#line 1574
  i = i + 1U;
  ldv_54632: ;
#line 1574
  if (i < Last_Entry_Of_TxPktBuf) {
#line 1576
    goto ldv_54631;
  } else {

  }
#line 1582
  status = _LLTWrite(padapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
#line 1583
  if (status != 1) {
#line 1584
    return (status);
  } else {

  }
#line 1587
  return (status);
}
}
#line 1590 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void _DisableGPIO(struct rtw_adapter *padapter ) 
{ 
  u32 value32 ;
  u32 u4bTmp ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 1603
  rtl8723au_write16(padapter, 70U, 0);
#line 1604
  tmp = rtl8723au_read32(padapter, 68U);
#line 1604
  value32 = tmp & 4294902015U;
#line 1605
  u4bTmp = value32 & 255U;
#line 1606
  value32 = ((u4bTmp << 8) | value32) | 16711680U;
#line 1607
  rtl8723au_write32(padapter, 68U, value32);
#line 1618
  rtl8723au_write16(padapter, 98U, 0);
#line 1619
  tmp___0 = rtl8723au_read32(padapter, 96U);
#line 1619
  value32 = tmp___0 & 4294901791U;
#line 1620
  u4bTmp = value32 & 31U;
#line 1622
  value32 = ((u4bTmp << 8) | value32) | 1900544U;
#line 1623
  rtl8723au_write32(padapter, 96U, value32);
#line 1626
  rtl8723au_write16(padapter, 76U, 32896);
#line 1627
  return;
}
}
#line 1629 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void _DisableRFAFEAndResetBB8192C(struct rtw_adapter *padapter ) 
{ 
  u8 eRFPath ;
  u8 value8 ;

  {
#line 1638
  eRFPath = 0U;
#line 1638
  value8 = 0U;
#line 1640
  rtl8723au_write8(padapter, 1314U, 255);
#line 1642
  PHY_SetRFReg(padapter, (enum RF_RADIO_PATH )eRFPath, 0U, 255U, 0U);
#line 1644
  value8 = (u8 )((unsigned int )value8 | 64U);
#line 1645
  rtl8723au_write8(padapter, 1536U, (int )value8);
#line 1648
  value8 = 0U;
#line 1649
  value8 = (u8 )((unsigned int )value8 | 22U);
#line 1650
  rtl8723au_write8(padapter, 2U, (int )value8);
#line 1653
  value8 = (unsigned int )value8 & 253U;
#line 1654
  rtl8723au_write8(padapter, 2U, (int )value8);
#line 1655
  return;
}
}
#line 1662 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void _DisableRFAFEAndResetBB(struct rtw_adapter *padapter ) 
{ 


  {
#line 1664
  _DisableRFAFEAndResetBB8192C(padapter);
#line 1665
  return;
}
}
#line 1667 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void _ResetDigitalProcedure1_92C(struct rtw_adapter *padapter , bool bWithoutHWSM ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 valu16 ;
  u16 tmp ;
  u8 retry_cnts ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  unsigned long __ms ;
  unsigned long tmp___2 ;
  u8 tmp___3 ;

  {
#line 1670
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1672
  if (((int )((struct hal_data_8723a *)padapter->HalData)->FirmwareSignature & 65520) == 35008 && (unsigned int )pHalData->FirmwareVersion <= 32U) {
#line 1680
    valu16 = 0U;
#line 1681
    rtl8723au_write8(padapter, 128U, 0);
#line 1683
    valu16 = rtl8723au_read16(padapter, 2U);
#line 1685
    rtl8723au_write16(padapter, 2U, (int )valu16 & 64511);
#line 1688
    tmp = rtl8723au_read16(padapter, 2U);
#line 1688
    valu16 = (unsigned int )tmp & 4095U;
#line 1690
    rtl8723au_write16(padapter, 2U, (int )((unsigned int )valu16 | 20480U));
#line 1693
    valu16 = rtl8723au_read16(padapter, 2U);
#line 1695
    rtl8723au_write16(padapter, 2U, (int )((unsigned int )valu16 | 1024U));
  } else {
#line 1698
    retry_cnts = 0U;
#line 1705
    tmp___3 = rtl8723au_read8(padapter, 128U);
#line 1705
    if (((unsigned long )tmp___3 & 2UL) != 0UL) {
#line 1707
      if ((unsigned int )padapter->bFWReady != 0U) {
#line 1711
        rtl8723au_write8(padapter, 304U, 32);
#line 1715
        rtl8723au_write8(padapter, 312U, 0);
#line 1716
        rtl8723au_write8(padapter, 80U, 0);
#line 1719
        rtl8723au_write8(padapter, 463U, 32);
#line 1722
        goto ldv_54655;
        ldv_54654: 
#line 1726
        __const_udelay(214750UL);
        ldv_54655: 
#line 1722
        tmp___0 = retry_cnts;
#line 1722
        retry_cnts = (u8 )((int )retry_cnts + 1);
#line 1722
        if ((unsigned int )tmp___0 <= 99U) {
#line 1722
          tmp___1 = rtl8723au_read16(padapter, 2U);
#line 1722
          if (((unsigned int )tmp___1 & 1024U) != 0U) {
#line 1724
            goto ldv_54654;
          } else {
#line 1727
            goto ldv_54656;
          }
        } else {

        }
        ldv_54656: ;
#line 1729
        if ((unsigned int )retry_cnts > 99U) {
#line 1731
          rtl8723au_write8(padapter, 3U, 80);
#line 1734
          __ms = 10UL;
#line 1734
          goto ldv_54659;
          ldv_54658: 
#line 1734
          __const_udelay(4295000UL);
          ldv_54659: 
#line 1734
          tmp___2 = __ms;
#line 1734
          __ms = __ms - 1UL;
#line 1734
          if (tmp___2 != 0UL) {
#line 1736
            goto ldv_54658;
          } else {

          }

        } else {

        }
      } else {

      }
    } else {

    }
#line 1739
    rtl8723au_write8(padapter, 3U, 84);
#line 1740
    rtl8723au_write8(padapter, 128U, 0);
  }
#line 1743
  if ((int )bWithoutHWSM) {
#line 1752
    rtl8723au_write16(padapter, 8U, 28835);
#line 1753
    rtl8723au_write8(padapter, 40U, 128);
#line 1754
    rtl8723au_write16(padapter, 36U, 34831);
#line 1755
    rtl8723au_write8(padapter, 0U, 249);
  } else {
#line 1758
    rtl8723au_write8(padapter, 31U, 0);
  }
#line 1759
  return;
}
}
#line 1762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void _ResetDigitalProcedure1(struct rtw_adapter *padapter , bool bWithoutHWSM ) 
{ 


  {
#line 1765
  _ResetDigitalProcedure1_92C(padapter, (int )bWithoutHWSM);
#line 1766
  return;
}
}
#line 1768 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void _ResetDigitalProcedure2(struct rtw_adapter *padapter ) 
{ 


  {
#line 1776
  rtl8723au_write16(padapter, 8U, 28835);
#line 1778
  rtl8723au_write8(padapter, 1U, 130);
#line 1779
  return;
}
}
#line 1781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void _DisableAnalog(struct rtw_adapter *padapter , bool bWithoutHWSM ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 value16 ;
  u8 value8 ;

  {
#line 1783
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1784
  value16 = 0U;
#line 1785
  value8 = 0U;
#line 1787
  if ((int )bWithoutHWSM) {
#line 1795
    rtl8723au_write8(padapter, 32U, 4);
#line 1798
    value8 = rtl8723au_read8(padapter, 33U);
#line 1799
    value8 = (unsigned int )value8 & 254U;
#line 1800
    rtl8723au_write8(padapter, 33U, (int )value8);
  } else {

  }
#line 1809
  value8 = 35U;
#line 1810
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U)) {
#line 1811
    value8 = (u8 )((unsigned int )value8 | 8U);
  } else {

  }
#line 1813
  rtl8723au_write8(padapter, 17U, (int )value8);
#line 1815
  if ((int )bWithoutHWSM) {
#line 1821
    value16 = (u16 )((unsigned int )value16 | 18434U);
  } else {
#line 1823
    value16 = (u16 )((unsigned int )value16 | 18434U);
  }
#line 1826
  rtl8723au_write16(padapter, 4U, (int )value16);
#line 1828
  rtl8723au_write8(padapter, 28U, 14);
#line 1829
  return;
}
}
#line 1832 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
s32 CardDisableHWSM(struct rtw_adapter *padapter , u8 resetMCU ) 
{ 
  int rtStatus ;

  {
#line 1834
  rtStatus = 1;
#line 1836
  if (padapter->bSurpriseRemoved != 0) {
#line 1837
    return (rtStatus);
  } else {

  }
#line 1840
  _DisableRFAFEAndResetBB(padapter);
#line 1843
  _ResetDigitalProcedure1(padapter, 0);
#line 1846
  _DisableGPIO(padapter);
#line 1849
  _DisableAnalog(padapter, 0);
#line 1851
  if (GlobalDebugLevel23A > 6U) {
#line 1851
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 1851
    printk("\016======> Card disable finished.\n");
  } else {

  }
#line 1854
  return (rtStatus);
}
}
#line 1858 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
s32 CardDisableWithoutHWSM(struct rtw_adapter *padapter ) 
{ 
  int rtStatus ;

  {
#line 1860
  rtStatus = 1;
#line 1864
  if (padapter->bSurpriseRemoved != 0) {
#line 1865
    return (rtStatus);
  } else {

  }
#line 1869
  _DisableRFAFEAndResetBB(padapter);
#line 1872
  _ResetDigitalProcedure1(padapter, 1);
#line 1875
  _DisableGPIO(padapter);
#line 1878
  _ResetDigitalProcedure2(padapter);
#line 1881
  _DisableAnalog(padapter, 1);
#line 1885
  return (rtStatus);
}
}
#line 1888 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_InitPGData(struct rtw_adapter *padapter , u8 *PROMContent ) 
{ 
  struct eeprom_priv *pEEPROM ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 1890
  pEEPROM = & padapter->eeprompriv;
#line 1892
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 0U) {
#line 1893
    if ((unsigned int )pEEPROM->EepromOrEfuse == 0U) {
#line 1895
      EFUSE_ShadowMapUpdate23a(padapter, 0);
#line 1896
      __len = 256UL;
#line 1896
      if (__len > 63UL) {
#line 1896
        __ret = __memcpy((void *)PROMContent, (void const   *)(& pEEPROM->efuse_eeprom_data),
                         __len);
      } else {
#line 1896
        __ret = __builtin_memcpy((void *)PROMContent, (void const   *)(& pEEPROM->efuse_eeprom_data),
                                 __len);
      }
    } else {

    }
  } else {
#line 1901
    if (GlobalDebugLevel23A > 5U) {
#line 1901
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 6);
#line 1901
      printk("\016AutoLoad Fail reported from CR9346!!\n");
    } else {

    }
#line 1905
    if ((unsigned int )pEEPROM->EepromOrEfuse == 0U) {
#line 1906
      EFUSE_ShadowMapUpdate23a(padapter, 0);
    } else {

    }
#line 1907
    __len___0 = 256UL;
#line 1907
    if (__len___0 > 63UL) {
#line 1907
      __ret___0 = __memcpy((void *)PROMContent, (void const   *)(& pEEPROM->efuse_eeprom_data),
                           __len___0);
    } else {
#line 1907
      __ret___0 = __builtin_memcpy((void *)PROMContent, (void const   *)(& pEEPROM->efuse_eeprom_data),
                                   __len___0);
    }
  }
#line 1910
  return;
}
}
#line 1912 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_EfuseParseIDCode(struct rtw_adapter *padapter , u8 *hwinfo ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u16 EEPROMId ;

  {
#line 1914
  pEEPROM = & padapter->eeprompriv;
#line 1919
  EEPROMId = *((u16 *)hwinfo);
#line 1920
  if ((unsigned int )EEPROMId != 33065U) {
#line 1921
    if (GlobalDebugLevel23A > 3U) {
#line 1921
      printk("\016RTL8723AU: EEPROM ID(%#x) is invalid!!\n", (int )EEPROMId);
    } else {

    }
#line 1922
    pEEPROM->bautoload_fail_flag = 1U;
  } else {
#line 1924
    pEEPROM->bautoload_fail_flag = 0U;
  }
#line 1927
  if (GlobalDebugLevel23A > 6U) {
#line 1927
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 1927
    printk("\016EEPROM ID = 0x%04x\n", (int )EEPROMId);
  } else {

  }
#line 1929
  return;
}
}
#line 1931 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void Hal_EEValueCheck(u8 EEType , void *pInValue , void *pOutValue ) 
{ 
  u8 *pIn ;
  u8 *pOut ;

  {
#line 1933
  switch ((int )EEType) {
  case 0: 
#line 1937
  pIn = (u8 *)pInValue;
#line 1938
  pOut = (u8 *)pOutValue;
#line 1939
  if ((unsigned int )*pIn <= 63U) {
#line 1940
    *pOut = *pIn;
  } else {
#line 1942
    if (GlobalDebugLevel23A > 3U) {
#line 1942
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
#line 1942
      printk("\016EETYPE_TX_PWR, value =%d is invalid, set to default = 0x%x\n", (int )*pIn,
             34);
    } else {

    }
#line 1946
    *pOut = 34U;
  }
#line 1949
  goto ldv_54709;
  default: ;
#line 1951
  goto ldv_54709;
  }
  ldv_54709: ;
#line 1954
  return;
}
}
#line 1956 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void Hal_ReadPowerValueFromPROM_8723A(struct txpowerinfo *pwrInfo , u8 *PROMContent ,
                                             bool AutoLoadFail ) 
{ 
  u32 rfPath ;
  u32 eeAddr ;
  u32 group ;
  u32 rfPathMax ;

  {
#line 1959
  rfPathMax = 1U;
#line 1961
  memset((void *)pwrInfo, 0, 180UL);
#line 1963
  if ((int )AutoLoadFail) {
#line 1964
    group = 0U;
#line 1964
    goto ldv_54724;
    ldv_54723: 
#line 1965
    rfPath = 0U;
#line 1965
    goto ldv_54721;
    ldv_54720: 
#line 1966
    pwrInfo->CCKIndex[rfPath][group] = 34U;
#line 1968
    pwrInfo->HT40_1SIndex[rfPath][group] = 34U;
#line 1970
    pwrInfo->HT40_2SIndexDiff[rfPath][group] = 0U;
#line 1972
    pwrInfo->HT20IndexDiff[rfPath][group] = 2U;
#line 1974
    pwrInfo->OFDMIndexDiff[rfPath][group] = 3U;
#line 1976
    pwrInfo->HT40MaxOffset[rfPath][group] = 0U;
#line 1978
    pwrInfo->HT20MaxOffset[rfPath][group] = 0U;
#line 1965
    rfPath = rfPath + 1U;
    ldv_54721: ;
#line 1965
    if (rfPath < rfPathMax) {
#line 1967
      goto ldv_54720;
    } else {

    }
#line 1964
    group = group + 1U;
    ldv_54724: ;
#line 1964
    if (group <= 11U) {
#line 1966
      goto ldv_54723;
    } else {

    }
#line 1982
    pwrInfo->TSSI_A[0] = 0U;
#line 1983
    return;
  } else {

  }
#line 1986
  rfPath = 0U;
#line 1986
  goto ldv_54730;
  ldv_54729: 
#line 1987
  group = 0U;
#line 1987
  goto ldv_54727;
  ldv_54726: 
#line 1988
  eeAddr = (rfPath * 3U + group) + 16U;
#line 1992
  Hal_EEValueCheck(0, (void *)PROMContent + (unsigned long )eeAddr, (void *)(& pwrInfo->CCKIndex) + ((unsigned long )rfPath + (unsigned long )group));
#line 1994
  eeAddr = (rfPath * 3U + group) + 22U;
#line 1998
  Hal_EEValueCheck(0, (void *)PROMContent + (unsigned long )eeAddr, (void *)(& pwrInfo->HT40_1SIndex) + ((unsigned long )rfPath + (unsigned long )group));
#line 1987
  group = group + 1U;
  ldv_54727: ;
#line 1987
  if (group <= 11U) {
#line 1989
    goto ldv_54726;
  } else {

  }
#line 1986
  rfPath = rfPath + 1U;
  ldv_54730: ;
#line 1986
  if (rfPath < rfPathMax) {
#line 1988
    goto ldv_54729;
  } else {

  }
#line 2003
  group = 0U;
#line 2003
  goto ldv_54736;
  ldv_54735: 
#line 2004
  rfPath = 0U;
#line 2004
  goto ldv_54733;
  ldv_54732: 
#line 2005
  pwrInfo->HT40_2SIndexDiff[rfPath][group] = 0U;
#line 2006
  pwrInfo->HT20IndexDiff[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 28U)) >> (int )(rfPath * 4U))) & 15U;
#line 2011
  if (((unsigned long )pwrInfo->HT20IndexDiff[rfPath][group] & 8UL) != 0UL) {
#line 2012
    pwrInfo->HT20IndexDiff[rfPath][group] = (u8 )((unsigned int )pwrInfo->HT20IndexDiff[rfPath][group] | 240U);
  } else {

  }
#line 2014
  pwrInfo->OFDMIndexDiff[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 31U)) >> (int )(rfPath * 4U))) & 15U;
#line 2018
  pwrInfo->HT40MaxOffset[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 34U)) >> (int )(rfPath * 4U))) & 15U;
#line 2022
  pwrInfo->HT20MaxOffset[rfPath][group] = (unsigned int )((u8 )((int )*(PROMContent + (unsigned long )(group + 37U)) >> (int )(rfPath * 4U))) & 15U;
#line 2004
  rfPath = rfPath + 1U;
  ldv_54733: ;
#line 2004
  if (rfPath < rfPathMax) {
#line 2006
    goto ldv_54732;
  } else {

  }
#line 2003
  group = group + 1U;
  ldv_54736: ;
#line 2003
  if (group <= 11U) {
#line 2005
    goto ldv_54735;
  } else {

  }
#line 2028
  pwrInfo->TSSI_A[0] = *(PROMContent + 41UL);
#line 2029
  return;
}
}
#line 2031 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static u8 Hal_GetChnlGroup(u8 chnl ) 
{ 
  u8 group ;

  {
#line 2033
  group = 0U;
#line 2035
  if ((unsigned int )chnl <= 2U) {
#line 2036
    group = 0U;
  } else
#line 2037
  if ((unsigned int )chnl <= 8U) {
#line 2038
    group = 1U;
  } else {
#line 2040
    group = 2U;
  }
#line 2042
  return (group);
}
}
#line 2046 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_EfuseParsetxpowerinfo_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                     bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct txpowerinfo pwrInfo ;
  u8 rfPath ;
  u8 ch ;
  u8 group ;
  u8 rfPathMax ;
  u8 pwr ;
  u8 diff ;
  struct registry_priv *registry_par ;

  {
#line 2049
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 2051
  rfPathMax = 1U;
#line 2054
  Hal_ReadPowerValueFromPROM_8723A(& pwrInfo, PROMContent, (int )AutoLoadFail);
#line 2055
  rfPath = 0U;
#line 2055
  goto ldv_54759;
  ldv_54758: 
#line 2056
  ch = 0U;
#line 2056
  goto ldv_54756;
  ldv_54755: 
#line 2057
  group = Hal_GetChnlGroup((int )ch);
#line 2059
  pHalData->TxPwrLevelCck[(int )rfPath][(int )ch] = pwrInfo.CCKIndex[(int )rfPath][(int )group];
#line 2061
  pHalData->TxPwrLevelHT40_1S[(int )rfPath][(int )ch] = pwrInfo.HT40_1SIndex[(int )rfPath][(int )group];
#line 2064
  pHalData->TxPwrHt20Diff[(int )rfPath][(int )ch] = pwrInfo.HT20IndexDiff[(int )rfPath][(int )group];
#line 2066
  pHalData->TxPwrLegacyHtDiff[(int )rfPath][(int )ch] = pwrInfo.OFDMIndexDiff[(int )rfPath][(int )group];
#line 2068
  pHalData->PwrGroupHT20[(int )rfPath][(int )ch] = pwrInfo.HT20MaxOffset[(int )rfPath][(int )group];
#line 2070
  pHalData->PwrGroupHT40[(int )rfPath][(int )ch] = pwrInfo.HT40MaxOffset[(int )rfPath][(int )group];
#line 2073
  pwr = pwrInfo.HT40_1SIndex[(int )rfPath][(int )group];
#line 2074
  diff = pwrInfo.HT40_2SIndexDiff[(int )rfPath][(int )group];
#line 2076
  pHalData->TxPwrLevelHT40_2S[(int )rfPath][(int )ch] = (int )pwr > (int )diff ? (int )pwr - (int )diff : 0U;
#line 2056
  ch = (u8 )((int )ch + 1);
  ldv_54756: ;
#line 2056
  if ((unsigned int )ch <= 13U) {
#line 2058
    goto ldv_54755;
  } else {

  }
#line 2055
  rfPath = (u8 )((int )rfPath + 1);
  ldv_54759: ;
#line 2055
  if ((int )rfPath < (int )rfPathMax) {
#line 2057
    goto ldv_54758;
  } else {

  }
#line 2080
  rfPath = 0U;
#line 2080
  goto ldv_54765;
  ldv_54764: 
#line 2081
  ch = 0U;
#line 2081
  goto ldv_54762;
  ldv_54761: ;
#line 2082
  if (GlobalDebugLevel23A > 6U) {
#line 2082
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2082
    printk("\016RF(%u)-Ch(%u) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n",
           (int )rfPath, (int )ch, (int )pHalData->TxPwrLevelCck[(int )rfPath][(int )ch],
           (int )pHalData->TxPwrLevelHT40_1S[(int )rfPath][(int )ch], (int )pHalData->TxPwrLevelHT40_2S[(int )rfPath][(int )ch]);
  } else {

  }
#line 2081
  ch = (u8 )((int )ch + 1);
  ldv_54762: ;
#line 2081
  if ((unsigned int )ch <= 13U) {
#line 2083
    goto ldv_54761;
  } else {

  }
#line 2080
  rfPath = (u8 )((int )rfPath + 1);
  ldv_54765: ;
#line 2080
  if ((unsigned int )rfPath <= 1U) {
#line 2082
    goto ldv_54764;
  } else {

  }
#line 2092
  ch = 0U;
#line 2092
  goto ldv_54768;
  ldv_54767: ;
#line 2093
  if (GlobalDebugLevel23A > 6U) {
#line 2093
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2093
    printk("\016RF-A Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", (int )ch, (int )pHalData->TxPwrHt20Diff[0][(int )ch],
           (int )pHalData->TxPwrHt20Diff[0][(int )ch]);
  } else {

  }
#line 2092
  ch = (u8 )((int )ch + 1);
  ldv_54768: ;
#line 2092
  if ((unsigned int )ch <= 13U) {
#line 2094
    goto ldv_54767;
  } else {

  }
#line 2098
  ch = 0U;
#line 2098
  goto ldv_54771;
  ldv_54770: ;
#line 2099
  if (GlobalDebugLevel23A > 6U) {
#line 2099
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2099
    printk("\016RF-A Legacy to Ht40 Diff[%u] = 0x%x\n", (int )ch, (int )pHalData->TxPwrLegacyHtDiff[0][(int )ch]);
  } else {

  }
#line 2098
  ch = (u8 )((int )ch + 1);
  ldv_54771: ;
#line 2098
  if ((unsigned int )ch <= 13U) {
#line 2100
    goto ldv_54770;
  } else {

  }
#line 2102
  ch = 0U;
#line 2102
  goto ldv_54774;
  ldv_54773: ;
#line 2103
  if (GlobalDebugLevel23A > 6U) {
#line 2103
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2103
    printk("\016RF-B Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", (int )ch, (int )pHalData->TxPwrHt20Diff[1][(int )ch],
           (int )pHalData->TxPwrHt20Diff[1][(int )ch]);
  } else {

  }
#line 2102
  ch = (u8 )((int )ch + 1);
  ldv_54774: ;
#line 2102
  if ((unsigned int )ch <= 13U) {
#line 2104
    goto ldv_54773;
  } else {

  }
#line 2108
  ch = 0U;
#line 2108
  goto ldv_54777;
  ldv_54776: ;
#line 2109
  if (GlobalDebugLevel23A > 6U) {
#line 2109
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2109
    printk("\016RF-B Legacy to HT40 Diff[%u] = 0x%x\n", (int )ch, (int )pHalData->TxPwrLegacyHtDiff[1][(int )ch]);
  } else {

  }
#line 2108
  ch = (u8 )((int )ch + 1);
  ldv_54777: ;
#line 2108
  if ((unsigned int )ch <= 13U) {
#line 2110
    goto ldv_54776;
  } else {

  }

#line 2112
  if (! AutoLoadFail) {
#line 2113
    registry_par = & padapter->registrypriv;
#line 2114
    if ((unsigned int )registry_par->regulatory_tid == 255U) {
#line 2115
      if ((unsigned int )*(PROMContent + 43UL) == 255U) {
#line 2116
        pHalData->EEPROMRegulatory = 0U;
      } else {
#line 2118
        pHalData->EEPROMRegulatory = (unsigned int )*(PROMContent + 43UL) & 7U;
      }
    } else {
#line 2121
      pHalData->EEPROMRegulatory = registry_par->regulatory_tid;
    }
  } else {
#line 2125
    pHalData->EEPROMRegulatory = 0U;
  }
#line 2127
  if (GlobalDebugLevel23A > 6U) {
#line 2127
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2127
    printk("\016EEPROMRegulatory = 0x%x\n", (int )pHalData->EEPROMRegulatory);
  } else {

  }
#line 2130
  if (! AutoLoadFail) {
#line 2131
    pHalData->bTXPowerDataReadFromEEPORM = 1U;
  } else {

  }
#line 2132
  return;
}
}
#line 2135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_EfuseParseBTCoexistInfo_8723A(struct rtw_adapter *padapter , u8 *hwinfo ,
                                       bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tempval ;
  u32 tmpu4 ;

  {
#line 2138
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 2142
  if (! AutoLoadFail) {
#line 2143
    tmpu4 = rtl8723au_read32(padapter, 104U);
#line 2144
    if (((unsigned long )tmpu4 & 262144UL) != 0UL) {
#line 2145
      pHalData->EEPROMBluetoothCoexist = 1U;
    } else {
#line 2147
      pHalData->EEPROMBluetoothCoexist = 0U;
    }
#line 2148
    pHalData->EEPROMBluetoothType = 6U;
#line 2152
    tempval = *(hwinfo + 46UL);
#line 2153
    pHalData->EEPROMBluetoothAntNum = (unsigned int )tempval & 1U;
#line 2154
    pHalData->EEPROMBluetoothAntIsolation = (u8 )(((int )tempval & 16) >> 4);
#line 2155
    pHalData->EEPROMBluetoothRadioShared = (u8 )(((int )tempval & 32) >> 5);
  } else {
#line 2157
    pHalData->EEPROMBluetoothCoexist = 0U;
#line 2158
    pHalData->EEPROMBluetoothType = 6U;
#line 2159
    pHalData->EEPROMBluetoothAntNum = 0U;
#line 2160
    pHalData->EEPROMBluetoothAntIsolation = 0U;
#line 2161
    pHalData->EEPROMBluetoothRadioShared = 0U;
  }
#line 2164
  rtl8723a_BT_init_hal_vars(padapter);
#line 2165
  return;
}
}
#line 2168 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_EfuseParseEEPROMVer(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 2171
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 2173
  if (! AutoLoadFail) {
#line 2174
    pHalData->EEPROMVersion = *(hwinfo + 48UL);
  } else {
#line 2176
    pHalData->EEPROMVersion = 1U;
  }
#line 2177
  if (GlobalDebugLevel23A > 6U) {
#line 2177
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2177
    printk("\016Hal_EfuseParseEEPROMVer(), EEVer = %d\n", (int )pHalData->EEPROMVersion);
  } else {

  }
#line 2179
  return;
}
}
#line 2183 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_EfuseParseChnlPlan(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 


  {
#line 2186
  padapter->mlmepriv.ChannelPlan = hal_com_get_channel_plan23a(padapter, (unsigned long )hwinfo != (unsigned long )((u8 *)0U) ? (int )*(hwinfo + 40UL) : 255,
                                                               (int )padapter->registrypriv.channel_plan,
                                                               10, (int )AutoLoadFail);
#line 2193
  if (GlobalDebugLevel23A > 3U) {
#line 2193
    printk("\016RTL8723AU: mlmepriv.ChannelPlan = 0x%02x\n", (int )padapter->mlmepriv.ChannelPlan);
  } else {

  }
#line 2194
  return;
}
}
#line 2198 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_EfuseParseCustomerID(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 2201
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 2203
  if (! AutoLoadFail) {
#line 2204
    pHalData->EEPROMCustomerID = *(hwinfo + 49UL);
#line 2205
    pHalData->EEPROMSubCustomerID = *(hwinfo + 50UL);
  } else {
#line 2208
    pHalData->EEPROMCustomerID = 0U;
#line 2209
    pHalData->EEPROMSubCustomerID = 0U;
  }
#line 2211
  if (GlobalDebugLevel23A > 6U) {
#line 2211
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2211
    printk("\016EEPROM Customer ID: 0x%2x\n", (int )pHalData->EEPROMCustomerID);
  } else {

  }
#line 2213
  if (GlobalDebugLevel23A > 6U) {
#line 2213
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2213
    printk("\016EEPROM SubCustomer ID: 0x%02x\n", (int )pHalData->EEPROMSubCustomerID);
  } else {

  }
#line 2215
  return;
}
}
#line 2219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_EfuseParseAntennaDiversity(struct rtw_adapter *padapter , u8 *hwinfo , bool AutoLoadFail ) 
{ 


  {
#line 2221
  return;
}
}
#line 2225 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_EfuseParseRateIndicationOption(struct rtw_adapter *padapter , u8 *hwinfo ,
                                        bool AutoLoadFail ) 
{ 


  {
#line 2227
  return;
}
}
#line 2231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_EfuseParseXtal_8723A(struct rtw_adapter *pAdapter , u8 *hwinfo , u8 AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 2234
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 2236
  if ((unsigned int )AutoLoadFail == 0U) {
#line 2237
    pHalData->CrystalCap = *(hwinfo + 51UL);
#line 2238
    if ((unsigned int )pHalData->CrystalCap == 255U) {
#line 2239
      pHalData->CrystalCap = 32U;
    } else {

    }
  } else {
#line 2241
    pHalData->CrystalCap = 32U;
  }
#line 2243
  if (GlobalDebugLevel23A > 6U) {
#line 2243
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 2243
    printk("\016%s: CrystalCap = 0x%2x\n", "Hal_EfuseParseXtal_8723A", (int )pHalData->CrystalCap);
  } else {

  }
#line 2245
  return;
}
}
#line 2249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_EfuseParseThermalMeter_8723A(struct rtw_adapter *padapter , u8 *PROMContent ,
                                      bool AutoloadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 2252
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 2257
  if (! AutoloadFail) {
#line 2258
    pHalData->EEPROMThermalMeter = *(PROMContent + 42UL);
  } else {
#line 2261
    pHalData->EEPROMThermalMeter = 18U;
  }
#line 2263
  if ((unsigned int )pHalData->EEPROMThermalMeter == 255U || (int )AutoloadFail) {
#line 2264
    pHalData->bAPKThermalMeterIgnore = 1U;
#line 2265
    pHalData->EEPROMThermalMeter = 18U;
  } else {

  }
#line 2268
  if (GlobalDebugLevel23A > 3U) {
#line 2268
    printk("\016RTL8723AU: %s: ThermalMeter = 0x%x\n", "Hal_EfuseParseThermalMeter_8723A",
           (int )pHalData->EEPROMThermalMeter);
  } else {

  }
#line 2269
  return;
}
}
#line 2272 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void Hal_InitChannelPlan23a(struct rtw_adapter *padapter ) 
{ 


  {
#line 2274
  return;
}
}
#line 2276 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void rtl8723a_cal_txdesc_chksum(struct tx_desc *ptxdesc ) 
{ 
  u16 *usPtr ;
  u32 count ;
  u32 index ;
  u16 checksum ;

  {
#line 2278
  usPtr = (u16 *)ptxdesc;
#line 2279
  count = 16U;
#line 2281
  checksum = 0U;
#line 2284
  ptxdesc->txdw7 = ptxdesc->txdw7 & 4294901760U;
#line 2286
  index = 0U;
#line 2286
  goto ldv_54840;
  ldv_54839: 
#line 2287
  checksum = (u16 )((int )*(usPtr + (unsigned long )index) ^ (int )checksum);
#line 2286
  index = index + 1U;
  ldv_54840: ;
#line 2286
  if (index < count) {
#line 2288
    goto ldv_54839;
  } else {

  }
#line 2290
  ptxdesc->txdw7 = ptxdesc->txdw7 | (__le32 )checksum;
#line 2291
  return;
}
}
#line 2293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void fill_txdesc_sectype(struct pkt_attrib *pattrib , struct txdesc_8723a *ptxdesc ) 
{ 


  {
#line 2296
  if (pattrib->encrypt != 0U && (unsigned int )pattrib->bswenc == 0U) {
#line 2297
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: ;
    case 1027074U: 
#line 2302
    ptxdesc->sectype = 1U;
#line 2303
    goto ldv_54849;
    case 1027076U: 
#line 2306
    ptxdesc->sectype = 3U;
#line 2307
    goto ldv_54849;
    case 0U: ;
    default: ;
#line 2311
    goto ldv_54849;
    }
    ldv_54849: ;
  } else {

  }
#line 2315
  return;
}
}
#line 2316 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void fill_txdesc_vcs(struct pkt_attrib *pattrib , struct txdesc_8723a *ptxdesc ) 
{ 


  {
#line 2321
  switch ((int )pattrib->vcs_mode) {
  case 1: 
#line 2323
  ptxdesc->rtsen = 1U;
#line 2324
  goto ldv_54858;
  case 2: 
#line 2327
  ptxdesc->cts2self = 1U;
#line 2328
  goto ldv_54858;
  case 0: ;
  default: ;
#line 2332
  goto ldv_54858;
  }
  ldv_54858: ;
#line 2335
  if ((unsigned int )pattrib->vcs_mode != 0U) {
#line 2336
    ptxdesc->hw_rts_en = 1U;
#line 2339
    if ((unsigned int )pattrib->ht_en != 0U) {
#line 2340
      if ((int )pattrib->bwmode & 1) {
#line 2341
        ptxdesc->rts_bw = 1U;
      } else {

      }
#line 2343
      switch ((int )pattrib->ch_offset) {
      case 0: 
#line 2345
      ptxdesc->rts_sc = 0U;
#line 2346
      goto ldv_54863;
      case 1: 
#line 2349
      ptxdesc->rts_sc = 1U;
#line 2350
      goto ldv_54863;
      case 2: 
#line 2353
      ptxdesc->rts_sc = 2U;
#line 2354
      goto ldv_54863;
      default: 
#line 2357
      ptxdesc->rts_sc = 3U;
#line 2358
      goto ldv_54863;
      }
      ldv_54863: ;
    } else {

    }
  } else {

  }
#line 2363
  return;
}
}
#line 2364 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void fill_txdesc_phy(struct pkt_attrib *pattrib , struct txdesc_8723a *ptxdesc ) 
{ 


  {
#line 2367
  if ((unsigned int )pattrib->ht_en != 0U) {
#line 2368
    if ((int )pattrib->bwmode & 1) {
#line 2369
      ptxdesc->data_bw = 1U;
    } else {

    }
#line 2371
    switch ((int )pattrib->ch_offset) {
    case 0: 
#line 2373
    ptxdesc->data_sc = 0U;
#line 2374
    goto ldv_54872;
    case 1: 
#line 2377
    ptxdesc->data_sc = 1U;
#line 2378
    goto ldv_54872;
    case 2: 
#line 2381
    ptxdesc->data_sc = 2U;
#line 2382
    goto ldv_54872;
    default: 
#line 2385
    ptxdesc->data_sc = 3U;
#line 2386
    goto ldv_54872;
    }
    ldv_54872: ;
  } else {

  }
#line 2390
  return;
}
}
#line 2391 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
static void rtl8723a_fill_default_txdesc(struct xmit_frame *pxmitframe , u8 *pbuf ) 
{ 
  struct rtw_adapter *padapter ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct pkt_attrib *pattrib ;
  struct txdesc_8723a *ptxdesc ;
  s32 bmcst ;
  bool tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;

  {
#line 2403
  padapter = pxmitframe->padapter;
#line 2404
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 2405
  pdmpriv = & pHalData->dmpriv;
#line 2406
  pmlmeext = & padapter->mlmeextpriv;
#line 2407
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2409
  pattrib = & pxmitframe->attrib;
#line 2410
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 2410
  bmcst = (s32 )tmp;
#line 2412
  ptxdesc = (struct txdesc_8723a *)pbuf;
#line 2414
  if (pxmitframe->frame_tag == 1) {
#line 2415
    ptxdesc->macid = pattrib->mac_id;
#line 2417
    if ((unsigned int )pattrib->ampdu_en == 1U) {
#line 2418
      ptxdesc->agg_en = 1U;
    } else {
#line 2420
      ptxdesc->bk = 1U;
    }
#line 2422
    ptxdesc->qsel = pattrib->qsel;
#line 2423
    ptxdesc->rate_id = pattrib->raid;
#line 2425
    fill_txdesc_sectype(pattrib, ptxdesc);
#line 2427
    ptxdesc->seq = pattrib->seqnum;
#line 2429
    if (((unsigned int )pattrib->ether_type != 34958U && (unsigned int )pattrib->ether_type != 2054U) && (unsigned int )pattrib->dhcp_pkt != 1U) {
#line 2434
      fill_txdesc_vcs(pattrib, ptxdesc);
#line 2435
      fill_txdesc_phy(pattrib, ptxdesc);
#line 2437
      ptxdesc->rtsrate = 8U;
#line 2438
      ptxdesc->data_ratefb_lmt = 31U;
#line 2439
      ptxdesc->rts_ratefb_lmt = 15U;
#line 2442
      ptxdesc->datarate = pdmpriv->INIDATA_RATE[(int )pattrib->mac_id];
    } else {
#line 2450
      ptxdesc->bk = 1U;
#line 2451
      ptxdesc->userate = 1U;
#line 2452
      if ((unsigned int )pmlmeinfo->preamble_mode == 3U) {
#line 2453
        ptxdesc->data_short = 1U;
      } else {

      }
#line 2454
      tmp___0 = MRateToHwRate23a((int )pmlmeext->tx_rate);
#line 2454
      ptxdesc->datarate = tmp___0;
    }
  } else
#line 2456
  if (pxmitframe->frame_tag == 3) {
#line 2460
    ptxdesc->macid = pattrib->mac_id;
#line 2461
    ptxdesc->qsel = pattrib->qsel;
#line 2462
    ptxdesc->rate_id = pattrib->raid;
#line 2463
    ptxdesc->seq = pattrib->seqnum;
#line 2464
    ptxdesc->userate = 1U;
#line 2465
    ptxdesc->rty_lmt_en = 1U;
#line 2466
    ptxdesc->data_rt_lmt = 6U;
#line 2469
    if ((unsigned int )pxmitframe->ack_report != 0U) {
#line 2470
      ptxdesc->ccx = 1U;
    } else {

    }
#line 2472
    tmp___1 = MRateToHwRate23a((int )pmlmeext->tx_rate);
#line 2472
    ptxdesc->datarate = tmp___1;
  } else
#line 2473
  if (pxmitframe->frame_tag == 8) {
#line 2474
    if (GlobalDebugLevel23A > 4U) {
#line 2474
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 268435456U, 5);
#line 2474
      printk("\016%s: TXAGG_FRAMETAG\n", "rtl8723a_fill_default_txdesc");
    } else {

    }
  } else {
#line 2477
    if (GlobalDebugLevel23A > 4U) {
#line 2477
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 268435456U, 5);
#line 2477
      printk("\016%s: frame_tag = 0x%x\n", "rtl8723a_fill_default_txdesc", pxmitframe->frame_tag);
    } else {

    }
#line 2481
    ptxdesc->macid = 4U;
#line 2482
    ptxdesc->rate_id = 6U;
#line 2483
    ptxdesc->seq = pattrib->seqnum;
#line 2484
    ptxdesc->userate = 1U;
#line 2485
    tmp___2 = MRateToHwRate23a((int )pmlmeext->tx_rate);
#line 2485
    ptxdesc->datarate = tmp___2;
  }
#line 2488
  ptxdesc->pktlen = (unsigned short )pattrib->last_txcmdsz;
#line 2489
  ptxdesc->offset = 32U;
#line 2490
  if (bmcst != 0) {
#line 2491
    ptxdesc->bmc = 1U;
  } else {

  }
#line 2492
  ptxdesc->ls = 1U;
#line 2493
  ptxdesc->fs = 1U;
#line 2494
  ptxdesc->own = 1U;
#line 2507
  if ((unsigned int )pattrib->qos_en == 0U) {
#line 2509
    ptxdesc->hwseq_en = 1U;
#line 2510
    ptxdesc->hwseq_sel = 0U;
  } else {

  }
#line 2512
  return;
}
}
#line 2521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_update_txdesc(struct xmit_frame *pxmitframe , u8 *pbuf ) 
{ 
  struct tx_desc *pdesc ;

  {
#line 2525
  pdesc = (struct tx_desc *)pbuf;
#line 2526
  memset((void *)pdesc, 0, 32UL);
#line 2528
  rtl8723a_fill_default_txdesc(pxmitframe, pbuf);
#line 2530
  pdesc->txdw0 = pdesc->txdw0;
#line 2531
  pdesc->txdw1 = pdesc->txdw1;
#line 2532
  pdesc->txdw2 = pdesc->txdw2;
#line 2533
  pdesc->txdw3 = pdesc->txdw3;
#line 2534
  pdesc->txdw4 = pdesc->txdw4;
#line 2535
  pdesc->txdw5 = pdesc->txdw5;
#line 2536
  pdesc->txdw6 = pdesc->txdw6;
#line 2537
  pdesc->txdw7 = pdesc->txdw7;
#line 2538
  rtl8723a_cal_txdesc_chksum(pdesc);
#line 2539
  return;
}
}
#line 2549 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void rtl8723a_fill_fake_txdesc(struct rtw_adapter *padapter , u8 *pDesc , u32 BufferLen ,
                               u8 IsPsPoll , u8 IsBTQosNull ) 
{ 
  struct tx_desc *ptxdesc ;

  {
#line 2555
  ptxdesc = (struct tx_desc *)pDesc;
#line 2556
  memset((void *)pDesc, 0, 32UL);
#line 2560
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2348810240U;
#line 2563
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2097152U;
#line 2567
  ptxdesc->txdw0 = ptxdesc->txdw0 | (BufferLen & 65535U);
#line 2571
  ptxdesc->txdw1 = ptxdesc->txdw1 | 4608U;
#line 2575
  if ((unsigned int )IsPsPoll != 0U) {
#line 2576
    ptxdesc->txdw1 = ptxdesc->txdw1 | 1048576U;
  } else {
#line 2579
    ptxdesc->txdw4 = ptxdesc->txdw4 | 128U;
#line 2581
    ptxdesc->txdw3 = ptxdesc->txdw3 | 2147483648U;
  }
#line 2584
  if ((unsigned int )IsBTQosNull == 1U) {
#line 2585
    ptxdesc->txdw2 = ptxdesc->txdw2 | 8388608U;
  } else {

  }
#line 2589
  ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
#line 2595
  rtl8723a_cal_txdesc_chksum(ptxdesc);
#line 2596
  return;
}
}
#line 2598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void hw_var_set_opmode(struct rtw_adapter *padapter , u8 mode ) 
{ 
  u8 val8 ;

  {
#line 2602
  if ((unsigned int )mode == 2U || (unsigned int )mode == 0U) {
#line 2603
    StopTxBeacon(padapter);
#line 2606
    val8 = 25U;
#line 2607
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else
#line 2608
  if ((unsigned int )mode == 1U) {
#line 2609
    ResumeTxBeacon(padapter);
#line 2611
    val8 = 26U;
#line 2612
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else
#line 2613
  if ((unsigned int )mode == 3U) {
#line 2615
    rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(padapter);
#line 2617
    ResumeTxBeacon(padapter);
#line 2619
    val8 = 18U;
#line 2620
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
#line 2626
    rtl8723au_write32(padapter, 1544U, 1879057038U);
#line 2628
    rtl8723au_write16(padapter, 1700U, 65535);
#line 2630
    rtl8723au_write16(padapter, 1698U, 1024);
#line 2634
    rtl8723au_write8(padapter, 1369U, 2);
#line 2636
    rtl8723au_write8(padapter, 1368U, 5);
#line 2638
    rtl8723au_write8(padapter, 1370U, 10);
#line 2639
    rtl8723au_write16(padapter, 1296U, 0);
#line 2640
    rtl8723au_write16(padapter, 1344U, 65284);
#line 2642
    rtl8723au_write16(padapter, 1304U, 32767);
#line 2645
    rtl8723au_write8(padapter, 1363U, 1);
#line 2650
    val8 = 30U;
#line 2652
    SetBcnCtrlReg23a(padapter, (int )val8, ~ ((int )val8));
  } else {

  }
#line 2655
  val8 = rtl8723au_read8(padapter, 258U);
#line 2656
  val8 = (u8 )(((int )((signed char )val8) & 12) | (int )((signed char )mode));
#line 2657
  rtl8723au_write8(padapter, 258U, (int )val8);
#line 2658
  return;
}
}
#line 2660 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void hw_var_set_macaddr(struct rtw_adapter *padapter , u8 *val ) 
{ 
  u8 idx ;
  u32 reg_macid ;

  {
#line 2662
  idx = 0U;
#line 2665
  reg_macid = 1552U;
#line 2667
  idx = 0U;
#line 2667
  goto ldv_54914;
  ldv_54913: 
#line 2668
  rtl8723au_write8(padapter, (u32 )idx + reg_macid, (int )*(val + (unsigned long )idx));
#line 2667
  idx = (u8 )((int )idx + 1);
  ldv_54914: ;
#line 2667
  if ((unsigned int )idx <= 5U) {
#line 2669
    goto ldv_54913;
  } else {

  }

#line 2674
  return;
}
}
#line 2671 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void hw_var_set_bssid(struct rtw_adapter *padapter , u8 *val ) 
{ 
  u8 idx ;
  u32 reg_bssid ;

  {
#line 2673
  idx = 0U;
#line 2676
  reg_bssid = 1560U;
#line 2678
  idx = 0U;
#line 2678
  goto ldv_54923;
  ldv_54922: 
#line 2679
  rtl8723au_write8(padapter, (u32 )idx + reg_bssid, (int )*(val + (unsigned long )idx));
#line 2678
  idx = (u8 )((int )idx + 1);
  ldv_54923: ;
#line 2678
  if ((unsigned int )idx <= 5U) {
#line 2680
    goto ldv_54922;
  } else {

  }

#line 2685
  return;
}
}
#line 2682 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void hw_var_set_correct_tsf(struct rtw_adapter *padapter ) 
{ 
  u64 tsf ;
  u32 reg_tsftr ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  uint32_t __base ;
  uint32_t __rem ;

  {
#line 2686
  pmlmeext = & padapter->mlmeextpriv;
#line 2687
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2692
  __base = (uint32_t )((int )pmlmeinfo->bcn_interval * 1024);
#line 2692
  __rem = (uint32_t )(pmlmeext->TSFValue % (u64 )__base);
#line 2692
  pmlmeext->TSFValue = pmlmeext->TSFValue / (u64 )__base;
#line 2692
  tsf = (pmlmeext->TSFValue - (u64 )__rem) - 1024ULL;
#line 2695
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
#line 2700
    StopTxBeacon(padapter);
  } else {

  }
#line 2703
  reg_tsftr = 1376U;
#line 2706
  SetBcnCtrlReg23a(padapter, 0, 8);
#line 2708
  rtl8723au_write32(padapter, reg_tsftr, (u32 )tsf);
#line 2709
  rtl8723au_write32(padapter, reg_tsftr + 4U, (u32 )(tsf >> 32));
#line 2712
  SetBcnCtrlReg23a(padapter, 8, 0);
#line 2714
  if ((pmlmeinfo->state & 3U) == 1U || (pmlmeinfo->state & 3U) == 3U) {
#line 2716
    ResumeTxBeacon(padapter);
  } else {

  }
#line 2717
  return;
}
}
#line 2719 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void hw_var_set_mlme_disconnect(struct rtw_adapter *padapter ) 
{ 


  {
#line 2722
  rtl8723au_write16(padapter, 1700U, 0);
#line 2725
  rtl8723au_write8(padapter, 1363U, 1);
#line 2728
  SetBcnCtrlReg23a(padapter, 16, 0);
#line 2729
  return;
}
}
#line 2731 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void hw_var_set_mlme_join(struct rtw_adapter *padapter , u8 type ) 
{ 
  u8 RetryLimit ;
  struct hal_data_8723a *pHalData ;
  struct mlme_priv *pmlmepriv ;
  u32 v32 ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 2733
  RetryLimit = 48U;
#line 2735
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 2736
  pmlmepriv = & padapter->mlmepriv;
#line 2738
  if ((unsigned int )type == 0U) {
#line 2744
    rtl8723au_write16(padapter, 1700U, 65535);
#line 2746
    v32 = rtl8723au_read32(padapter, 1544U);
#line 2747
    v32 = v32 | 192U;
#line 2748
    rtl8723au_write32(padapter, 1544U, v32);
#line 2750
    tmp = check_fwstate(pmlmepriv, 8);
#line 2750
    if ((int )tmp) {
#line 2751
      RetryLimit = (unsigned int )pHalData->CustomerID == 18U ? 7U : 48U;
    } else {
#line 2754
      RetryLimit = 7U;
    }
  } else
#line 2755
  if ((unsigned int )type == 1U) {
#line 2758
    rtl8723au_write16(padapter, 1700U, 0);
  } else
#line 2759
  if ((unsigned int )type == 2U) {
#line 2761
    SetBcnCtrlReg23a(padapter, 0, 16);
#line 2763
    tmp___0 = check_fwstate(pmlmepriv, 96);
#line 2763
    if ((int )tmp___0) {
#line 2766
      rtl8723au_write8(padapter, 1346U, 2);
#line 2767
      RetryLimit = 7U;
    } else {

    }
  } else {

  }
#line 2771
  rtl8723au_write16(padapter, 1066U, (int )((u16 )((int )((short )((int )RetryLimit << 8)) | (int )((short )RetryLimit))));
#line 2775
  switch ((int )type) {
  case 0: 
#line 2778
  rtl8723a_BT_wifiassociate_notify(padapter, 1);
#line 2779
  goto ldv_54947;
  case 1: 
#line 2782
  rtl8723a_BT_wifiassociate_notify(padapter, 0);
#line 2783
  goto ldv_54947;
  case 2: ;
#line 2787
  goto ldv_54947;
  }
  ldv_54947: ;
#line 2790
  return;
}
}
#line 2918 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
void *ldv_kmem_cache_alloc_1586(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2921
  ldv_check_alloc_flags(flags);
#line 2923
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2924
  return ((void *)0);
}
}
#line 2962 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
int ldv_pskb_expand_head_1592(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2965
  ldv_check_alloc_flags(flags);
#line 2967
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2967
  return (tmp);
}
}
#line 2978 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
struct sk_buff *ldv_skb_clone_1594(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2981
  ldv_check_alloc_flags(flags);
#line 2983
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2983
  return (tmp);
}
}
#line 2994 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
struct sk_buff *ldv_skb_copy_1596(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2997
  ldv_check_alloc_flags(flags);
#line 2999
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2999
  return (tmp);
}
}
#line 3002 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1597(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3005
  ldv_check_alloc_flags(flags);
#line 3007
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 3007
  return (tmp);
}
}
#line 3010 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1598(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3013
  ldv_check_alloc_flags(flags);
#line 3015
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 3015
  return (tmp);
}
}
#line 3018 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1599(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3021
  ldv_check_alloc_flags(flags);
#line 3023
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 3023
  return (tmp);
}
}
#line 3026 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
int ldv_pskb_expand_head_1600(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 3029
  ldv_check_alloc_flags(flags);
#line 3031
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 3031
  return (tmp);
}
}
#line 3034 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
int ldv_pskb_expand_head_1601(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 3037
  ldv_check_alloc_flags(flags);
#line 3039
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 3039
  return (tmp);
}
}
#line 3042 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_hal_init.o.c.prepared"
struct sk_buff *ldv_skb_clone_1602(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 3045
  ldv_check_alloc_flags(flags);
#line 3047
  tmp = skb_clone(ldv_func_arg1, flags);
#line 3047
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1628(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1636(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1644(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1638(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1634(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1642(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1643(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1639(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1640(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1641(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 191 "drivers/staging/rtl8723au/include/Hal8723APhyCfg.h"
void PHY_SetTxPowerLevel8723A(struct rtw_adapter *Adapter , u8 channel ) ;
#line 226
int PHY_BBConfig8723A(struct rtw_adapter *Adapter ) ;
#line 227
int PHY_RFConfig8723A(struct rtw_adapter *Adapter ) ;
#line 228
s32 PHY_MACConfig8723A(struct rtw_adapter *Adapter ) ;
#line 47 "drivers/staging/rtl8723au/include/rtl8723a_rf.h"
void rtl8723a_phy_rf6052set_bw(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ) ;
#line 49
void rtl823a_phy_rf6052setccktxpower(struct rtw_adapter *Adapter , u8 *pPowerlevel ) ;
#line 51
void rtl8723a_PHY_RF6052SetOFDMTxPower(struct rtw_adapter *Adapter , u8 *pPowerLevel ,
                                       u8 Channel ) ;
#line 56
int PHY_RF6052_Config8723A(struct rtw_adapter *Adapter ) ;
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static u32 phy_CalculateBitShift(u32 BitMask ) 
{ 
  u32 i ;

  {
#line 279
  i = 0U;
#line 279
  goto ldv_54249;
  ldv_54248: ;
#line 280
  if ((int )(BitMask >> (int )i) & 1) {
#line 281
    goto ldv_54247;
  } else {

  }
#line 279
  i = i + 1U;
  ldv_54249: ;
#line 279
  if (i <= 31U) {
#line 281
    goto ldv_54248;
  } else {

  }
  ldv_54247: ;
#line 284
  return (i);
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
u32 PHY_QueryBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask ) 
{ 
  u32 ReturnValue ;
  u32 OriginalValue ;
  u32 BitShift ;

  {
#line 307
  ReturnValue = 0U;
#line 309
  OriginalValue = rtl8723au_read32(Adapter, RegAddr);
#line 310
  BitShift = phy_CalculateBitShift(BitMask);
#line 311
  ReturnValue = (OriginalValue & BitMask) >> (int )BitShift;
#line 312
  return (ReturnValue);
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
void PHY_SetBBReg(struct rtw_adapter *Adapter , u32 RegAddr , u32 BitMask , u32 Data ) 
{ 
  u32 OriginalValue ;
  u32 BitShift ;

  {
#line 344
  if (BitMask != 4294967295U) {
#line 345
    OriginalValue = rtl8723au_read32(Adapter, RegAddr);
#line 346
    BitShift = phy_CalculateBitShift(BitMask);
#line 347
    Data = (~ BitMask & OriginalValue) | (Data << (int )BitShift);
  } else {

  }
#line 350
  rtl8723au_write32(Adapter, RegAddr, Data);
#line 351
  return;
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static u32 phy_RFSerialRead(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath ,
                            u32 Offset ) 
{ 
  u32 retValue ;
  struct hal_data_8723a *pHalData ;
  struct bb_reg_define *pPhyReg ;
  u32 NewOffset ;
  u32 tmplong ;
  u32 tmplong2 ;
  u8 RfPiEnable ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 384
  retValue = 0U;
#line 385
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 386
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
#line 389
  RfPiEnable = 0U;
#line 393
  Offset = Offset & 63U;
#line 398
  NewOffset = Offset;
#line 411
  tmplong = PHY_QueryBBReg(Adapter, 2084U, 4294967295U);
#line 412
  if ((unsigned int )eRFPath == 0U) {
#line 413
    tmplong2 = tmplong;
  } else {
#line 415
    tmplong2 = PHY_QueryBBReg(Adapter, pPhyReg->rfHSSIPara2, 4294967295U);
  }
#line 418
  tmplong2 = ((tmplong2 & 2155872255U) | (NewOffset << 23)) | 2147483648U;
#line 421
  PHY_SetBBReg(Adapter, 2084U, 4294967295U, tmplong & 2147483647U);
#line 423
  __const_udelay(42950UL);
#line 425
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 4294967295U, tmplong2);
#line 426
  __const_udelay(429500UL);
#line 428
  PHY_SetBBReg(Adapter, 2084U, 4294967295U, tmplong | 2147483648U);
#line 430
  __const_udelay(42950UL);
#line 432
  if ((unsigned int )eRFPath == 0U) {
#line 433
    tmp = PHY_QueryBBReg(Adapter, 2080U, 256U);
#line 433
    RfPiEnable = (unsigned char )tmp;
  } else
#line 436
  if ((unsigned int )eRFPath == 1U) {
#line 437
    tmp___0 = PHY_QueryBBReg(Adapter, 2088U, 256U);
#line 437
    RfPiEnable = (unsigned char )tmp___0;
  } else {

  }
#line 441
  if ((unsigned int )RfPiEnable != 0U) {
#line 443
    retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBackPi, 1048575U);
  } else {
#line 448
    retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBack, 1048575U);
  }
#line 454
  return (retValue);
}
}
#line 502 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static void phy_RFSerialWrite(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath ,
                              u32 Offset , u32 Data ) 
{ 
  u32 DataAndAddr ;
  struct hal_data_8723a *pHalData ;
  struct bb_reg_define *pPhyReg ;
  u32 NewOffset ;

  {
#line 505
  DataAndAddr = 0U;
#line 506
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 507
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
#line 518
  Offset = Offset & 63U;
#line 528
  NewOffset = Offset;
#line 535
  DataAndAddr = ((NewOffset << 20) | (Data & 1048575U)) & 268435455U;
#line 540
  PHY_SetBBReg(Adapter, pPhyReg->rf3wireOffset, 4294967295U, DataAndAddr);
#line 541
  return;
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
u32 PHY_QueryRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                   u32 BitMask ) 
{ 
  u32 Original_Value ;
  u32 Readback_Value ;
  u32 BitShift ;

  {
#line 573
  Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
#line 575
  BitShift = phy_CalculateBitShift(BitMask);
#line 576
  Readback_Value = (Original_Value & BitMask) >> (int )BitShift;
#line 578
  return (Readback_Value);
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
void PHY_SetRFReg(struct rtw_adapter *Adapter , enum RF_RADIO_PATH eRFPath , u32 RegAddr ,
                  u32 BitMask , u32 Data ) 
{ 
  u32 Original_Value ;
  u32 BitShift ;

  {
#line 610
  if (BitMask != 1048575U) {
#line 611
    Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
#line 612
    BitShift = phy_CalculateBitShift(BitMask);
#line 613
    Data = (~ BitMask & Original_Value) | (Data << (int )BitShift);
  } else {

  }
#line 616
  phy_RFSerialWrite(Adapter, eRFPath, RegAddr, Data);
#line 617
  return;
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
s32 PHY_MACConfig8723A(struct rtw_adapter *Adapter ) 
{ 
  int rtStatus ;
  struct hal_data_8723a *pHalData ;
  bool is92C ;
  int tmp ;

  {
#line 639
  rtStatus = 1;
#line 640
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 641
  is92C = (bool )(((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U);
#line 646
  tmp = ODM_ConfigMACWithHeaderFile23a(& pHalData->odmpriv);
#line 646
  if (tmp == 0) {
#line 647
    rtStatus = 0;
  } else {

  }
#line 651
  rtl8723au_write8(Adapter, 1226U, 10);
#line 652
  if ((int )is92C && (unsigned int )pHalData->BoardType == 0U) {
#line 653
    rtl8723au_write8(Adapter, 64U, 4);
  } else {

  }
#line 655
  return (rtStatus);
}
}
#line 672 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static void phy_InitBBRFRegisterDefinition(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 674
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 678
  pHalData->PHYRegDef[0].rfintfs = 2160U;
#line 680
  pHalData->PHYRegDef[1].rfintfs = 2160U;
#line 684
  pHalData->PHYRegDef[0].rfintfi = 2272U;
#line 686
  pHalData->PHYRegDef[1].rfintfi = 2272U;
#line 690
  pHalData->PHYRegDef[0].rfintfo = 2144U;
#line 692
  pHalData->PHYRegDef[1].rfintfo = 2148U;
#line 696
  pHalData->PHYRegDef[0].rfintfe = 2144U;
#line 698
  pHalData->PHYRegDef[1].rfintfe = 2148U;
#line 701
  pHalData->PHYRegDef[0].rf3wireOffset = 2112U;
#line 702
  pHalData->PHYRegDef[1].rf3wireOffset = 2116U;
#line 706
  pHalData->PHYRegDef[0].rfLSSI_Select = 2168U;
#line 707
  pHalData->PHYRegDef[1].rfLSSI_Select = 2168U;
#line 710
  pHalData->PHYRegDef[0].rfTxGainStage = 2060U;
#line 711
  pHalData->PHYRegDef[1].rfTxGainStage = 2060U;
#line 715
  pHalData->PHYRegDef[0].rfHSSIPara1 = 2080U;
#line 717
  pHalData->PHYRegDef[1].rfHSSIPara1 = 2088U;
#line 721
  pHalData->PHYRegDef[0].rfHSSIPara2 = 2084U;
#line 723
  pHalData->PHYRegDef[1].rfHSSIPara2 = 2092U;
#line 726
  pHalData->PHYRegDef[0].rfSwitchControl = 2136U;
#line 728
  pHalData->PHYRegDef[1].rfSwitchControl = 2136U;
#line 732
  pHalData->PHYRegDef[0].rfAGCControl1 = 3152U;
#line 733
  pHalData->PHYRegDef[1].rfAGCControl1 = 3160U;
#line 736
  pHalData->PHYRegDef[0].rfAGCControl2 = 3156U;
#line 737
  pHalData->PHYRegDef[1].rfAGCControl2 = 3164U;
#line 740
  pHalData->PHYRegDef[0].rfRxIQImbalance = 3092U;
#line 741
  pHalData->PHYRegDef[1].rfRxIQImbalance = 3100U;
#line 744
  pHalData->PHYRegDef[0].rfRxAFE = 3088U;
#line 745
  pHalData->PHYRegDef[1].rfRxAFE = 3096U;
#line 748
  pHalData->PHYRegDef[0].rfTxIQImbalance = 3200U;
#line 749
  pHalData->PHYRegDef[1].rfTxIQImbalance = 3208U;
#line 752
  pHalData->PHYRegDef[0].rfTxAFE = 3204U;
#line 753
  pHalData->PHYRegDef[1].rfTxAFE = 3212U;
#line 756
  pHalData->PHYRegDef[0].rfLSSIReadBack = 2208U;
#line 757
  pHalData->PHYRegDef[1].rfLSSIReadBack = 2212U;
#line 760
  pHalData->PHYRegDef[0].rfLSSIReadBackPi = 2232U;
#line 762
  pHalData->PHYRegDef[1].rfLSSIReadBackPi = 2236U;
#line 763
  return;
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static void storePwrIndexDiffRateOffset(struct rtw_adapter *Adapter , u32 RegAddr ,
                                        u32 BitMask , u32 Data ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 771
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 773
  if (RegAddr == 3584U) {
#line 774
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][0] = Data;
  } else {

  }
#line 781
  if (RegAddr == 3588U) {
#line 782
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][1] = Data;
  } else {

  }
#line 789
  if (RegAddr == 3592U) {
#line 790
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][6] = Data;
  } else {

  }
#line 797
  if (RegAddr == 2156U && BitMask == 4294967040U) {
#line 798
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][7] = Data;
  } else {

  }
#line 805
  if (RegAddr == 3600U) {
#line 806
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][2] = Data;
  } else {

  }
#line 813
  if (RegAddr == 3604U) {
#line 814
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][3] = Data;
  } else {

  }
#line 821
  if (RegAddr == 3608U) {
#line 822
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][4] = Data;
  } else {

  }
#line 829
  if (RegAddr == 3612U) {
#line 830
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][5] = Data;
  } else {

  }
#line 837
  if (RegAddr == 2096U) {
#line 838
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][8] = Data;
  } else {

  }
#line 845
  if (RegAddr == 2100U) {
#line 846
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][9] = Data;
  } else {

  }
#line 853
  if (RegAddr == 2104U) {
#line 854
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][14] = Data;
  } else {

  }
#line 861
  if (RegAddr == 2156U && BitMask == 255U) {
#line 862
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][15] = Data;
  } else {

  }
#line 869
  if (RegAddr == 2108U) {
#line 870
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][10] = Data;
  } else {

  }
#line 877
  if (RegAddr == 2120U) {
#line 878
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][11] = Data;
  } else {

  }
#line 885
  if (RegAddr == 2124U) {
#line 886
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][12] = Data;
  } else {

  }
#line 893
  if (RegAddr == 2152U) {
#line 894
    pHalData->MCSTxPowerLevelOriginalOffset[(int )pHalData->pwrGroupCnt][13] = Data;
#line 900
    pHalData->pwrGroupCnt = (u8 )((int )pHalData->pwrGroupCnt + 1);
  } else {

  }
#line 902
  return;
}
}
#line 921 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static int phy_ConfigBBWithPgHeaderFile(struct rtw_adapter *Adapter , u8 ConfigType ) 
{ 
  int i ;
  u32 *Rtl819XPHY_REGArray_Table_PG ;
  u16 PHY_REGArrayPGLen ;

  {
#line 927
  PHY_REGArrayPGLen = 336U;
#line 928
  Rtl819XPHY_REGArray_Table_PG = (u32 *)(& Rtl8723UPHY_REG_Array_PG);
#line 930
  if ((unsigned int )ConfigType == 0U) {
#line 931
    i = 0;
#line 931
    goto ldv_54331;
    ldv_54330: 
#line 932
    storePwrIndexDiffRateOffset(Adapter, *(Rtl819XPHY_REGArray_Table_PG + (unsigned long )i),
                                *(Rtl819XPHY_REGArray_Table_PG + ((unsigned long )i + 1UL)),
                                *(Rtl819XPHY_REGArray_Table_PG + ((unsigned long )i + 2UL)));
#line 931
    i = i + 3;
    ldv_54331: ;
#line 931
    if ((int )PHY_REGArrayPGLen > i) {
#line 933
      goto ldv_54330;
    } else {

    }

  } else {

  }
#line 939
  return (1);
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static void phy_BB8192C_Config_1T(struct rtw_adapter *Adapter ) 
{ 


  {
#line 946
  PHY_SetBBReg(Adapter, 2052U, 3U, 2U);
#line 947
  PHY_SetBBReg(Adapter, 2316U, 3145779U, 2097186U);
#line 951
  PHY_SetBBReg(Adapter, 2564U, 4278190080U, 69U);
#line 952
  PHY_SetBBReg(Adapter, 3076U, 255U, 35U);
#line 954
  PHY_SetBBReg(Adapter, 3184U, 48U, 1U);
#line 956
  PHY_SetBBReg(Adapter, 3700U, 201326592U, 2U);
#line 957
  PHY_SetBBReg(Adapter, 3704U, 201326592U, 2U);
#line 958
  PHY_SetBBReg(Adapter, 3708U, 201326592U, 2U);
#line 959
  PHY_SetBBReg(Adapter, 3712U, 201326592U, 2U);
#line 960
  PHY_SetBBReg(Adapter, 3720U, 201326592U, 2U);
#line 961
  return;
}
}
#line 964 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static int phy_BB8723a_Config_ParaFile(struct rtw_adapter *Adapter ) 
{ 
  struct eeprom_priv *pEEPROM ;
  struct hal_data_8723a *pHalData ;
  int rtStatus ;
  int tmp ;
  int tmp___0 ;

  {
#line 966
  pEEPROM = & Adapter->eeprompriv;
#line 967
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 968
  rtStatus = 1;
#line 974
  tmp = ODM_ConfigBBWithHeaderFile23a(& pHalData->odmpriv, 0);
#line 974
  if (tmp == 0) {
#line 976
    rtStatus = 0;
  } else {

  }
#line 977
  if (rtStatus != 1) {
#line 978
    goto phy_BB8190_Config_ParaFile_Fail;
  } else {

  }
#line 983
  if ((unsigned int )pHalData->rf_type == 0U) {
#line 984
    phy_BB8192C_Config_1T(Adapter);
#line 985
    if (GlobalDebugLevel23A > 3U) {
#line 985
      printk("\016RTL8723AU: phy_BB8723a_Config_ParaFile():Config to 1T!!\n");
    } else {

    }
  } else {

  }
#line 992
  if ((unsigned int )pEEPROM->bautoload_fail_flag == 0U) {
#line 993
    pHalData->pwrGroupCnt = 0U;
#line 995
    rtStatus = phy_ConfigBBWithPgHeaderFile(Adapter, 0);
  } else {

  }
#line 999
  if (rtStatus != 1) {
#line 1000
    goto phy_BB8190_Config_ParaFile_Fail;
  } else {

  }
#line 1005
  tmp___0 = ODM_ConfigBBWithHeaderFile23a(& pHalData->odmpriv, 1);
#line 1005
  if (tmp___0 == 0) {
#line 1007
    rtStatus = 0;
  } else {

  }
  phy_BB8190_Config_ParaFile_Fail: ;
#line 1011
  return (rtStatus);
}
}
#line 1015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
int PHY_BBConfig8723A(struct rtw_adapter *Adapter ) 
{ 
  int rtStatus ;
  struct hal_data_8723a *pHalData ;
  u8 TmpU1B ;
  u8 CrystalCap ;

  {
#line 1017
  rtStatus = 1;
#line 1018
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1019
  TmpU1B = 0U;
#line 1022
  phy_InitBBRFRegisterDefinition(Adapter);
#line 1026
  TmpU1B = rtl8723au_read8(Adapter, 40U);
#line 1027
  __const_udelay(8590UL);
#line 1028
  rtl8723au_write8(Adapter, 40U, (int )((unsigned int )TmpU1B | 2U));
#line 1029
  __const_udelay(8590UL);
#line 1032
  rtl8723au_write8(Adapter, 41U, 255);
#line 1033
  __const_udelay(8590UL);
#line 1036
  TmpU1B = rtl8723au_read8(Adapter, 2U);
#line 1037
  rtl8723au_write8(Adapter, 2U, (int )((unsigned int )TmpU1B | 3U));
#line 1041
  TmpU1B = rtl8723au_read8(Adapter, 37U);
#line 1042
  rtl8723au_write8(Adapter, 37U, (int )TmpU1B & 191);
#line 1045
  TmpU1B = rtl8723au_read8(Adapter, 38U);
#line 1046
  rtl8723au_write8(Adapter, 38U, (int )TmpU1B & 239);
#line 1049
  rtl8723au_write8(Adapter, 31U, 7);
#line 1054
  rtStatus = phy_BB8723a_Config_ParaFile(Adapter);
#line 1057
  if ((unsigned int )pHalData->EEPROMVersion != 0U) {
#line 1058
    CrystalCap = (unsigned int )pHalData->CrystalCap & 63U;
#line 1059
    PHY_SetBBReg(Adapter, 44U, 16773120U, (u32 )((int )CrystalCap | ((int )CrystalCap << 6)));
  } else {

  }
#line 1063
  PHY_SetBBReg(Adapter, 32U, 4294967295U, 22488325U);
#line 1064
  return (rtStatus);
}
}
#line 1068 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
int PHY_RFConfig8723A(struct rtw_adapter *Adapter ) 
{ 
  int rtStatus ;

  {
#line 1070
  rtStatus = 1;
#line 1075
  rtStatus = PHY_RF6052_Config8723A(Adapter);
#line 1076
  return (rtStatus);
}
}
#line 1079 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static void getTxPowerIndex(struct rtw_adapter *Adapter , u8 channel , u8 *cckPowerLevel ,
                            u8 *ofdmPowerLevel ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 index ;

  {
#line 1082
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1083
  index = (unsigned int )channel + 255U;
#line 1085
  *cckPowerLevel = pHalData->TxPwrLevelCck[0][(int )index];
#line 1086
  *(cckPowerLevel + 1UL) = pHalData->TxPwrLevelCck[1][(int )index];
#line 1089
  if ((unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 0U || (unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 3U) {
#line 1091
    *ofdmPowerLevel = pHalData->TxPwrLevelHT40_1S[0][(int )index];
#line 1093
    *(ofdmPowerLevel + 1UL) = pHalData->TxPwrLevelHT40_1S[1][(int )index];
  } else
#line 1095
  if ((unsigned int )((struct hal_data_8723a *)Adapter->HalData)->rf_type == 2U) {
#line 1097
    *ofdmPowerLevel = pHalData->TxPwrLevelHT40_2S[0][(int )index];
#line 1099
    *(ofdmPowerLevel + 1UL) = pHalData->TxPwrLevelHT40_2S[1][(int )index];
  } else {

  }
#line 1102
  return;
}
}
#line 1104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static void ccxPowerIndexCheck(struct rtw_adapter *Adapter , u8 channel , u8 *cckPowerLevel ,
                               u8 *ofdmPowerLevel ) 
{ 


  {
#line 1106
  return;
}
}
#line 1123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
void PHY_SetTxPowerLevel8723A(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 cckPowerLevel[2U] ;
  u8 ofdmPowerLevel[2U] ;

  {
#line 1125
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1128
  if ((unsigned int )pHalData->bTXPowerDataReadFromEEPORM == 0U) {
#line 1129
    return;
  } else {

  }
#line 1131
  getTxPowerIndex(Adapter, (int )channel, (u8 *)(& cckPowerLevel), (u8 *)(& ofdmPowerLevel));
#line 1134
  ccxPowerIndexCheck(Adapter, (int )channel, (u8 *)(& cckPowerLevel), (u8 *)(& ofdmPowerLevel));
#line 1137
  rtl823a_phy_rf6052setccktxpower(Adapter, (u8 *)(& cckPowerLevel));
#line 1138
  rtl8723a_PHY_RF6052SetOFDMTxPower(Adapter, (u8 *)(& ofdmPowerLevel), (int )channel);
#line 1139
  return;
}
}
#line 1158 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static void _PHY_SetBWMode23a92C(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 regBwOpMode ;
  u8 regRRSR_RSC ;

  {
#line 1160
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1164
  if ((unsigned int )pHalData->rf_chip == 5U) {
#line 1165
    return;
  } else {

  }
#line 1168
  if ((unsigned int )pHalData->rf_chip == 1U) {
#line 1169
    return;
  } else {

  }
#line 1171
  if (Adapter->bDriverStopped != 0) {
#line 1172
    return;
  } else {

  }
#line 1178
  regBwOpMode = rtl8723au_read8(Adapter, 1539U);
#line 1179
  regRRSR_RSC = rtl8723au_read8(Adapter, 1090U);
#line 1181
  switch ((unsigned int )pHalData->CurrentChannelBW) {
  case 0U: 
#line 1183
  regBwOpMode = (u8 )((unsigned int )regBwOpMode | 4U);
#line 1184
  rtl8723au_write8(Adapter, 1539U, (int )regBwOpMode);
#line 1185
  goto ldv_54382;
  case 1U: 
#line 1187
  regBwOpMode = (unsigned int )regBwOpMode & 251U;
#line 1188
  rtl8723au_write8(Adapter, 1539U, (int )regBwOpMode);
#line 1189
  regRRSR_RSC = (u8 )(((int )((signed char )regRRSR_RSC) & -112) | (int )((signed char )((int )pHalData->nCur40MhzPrimeSC << 5)));
#line 1191
  rtl8723au_write8(Adapter, 1090U, (int )regRRSR_RSC);
#line 1192
  goto ldv_54382;
  default: ;
#line 1195
  goto ldv_54382;
  }
  ldv_54382: ;
#line 1201
  switch ((unsigned int )pHalData->CurrentChannelBW) {
  case 0U: 
#line 1204
  PHY_SetBBReg(Adapter, 2048U, 1U, 0U);
#line 1205
  PHY_SetBBReg(Adapter, 2304U, 1U, 0U);
#line 1206
  PHY_SetBBReg(Adapter, 2180U, 1024U, 1U);
#line 1208
  goto ldv_54386;
  case 1U: 
#line 1212
  PHY_SetBBReg(Adapter, 2048U, 1U, 1U);
#line 1213
  PHY_SetBBReg(Adapter, 2304U, 1U, 1U);
#line 1217
  PHY_SetBBReg(Adapter, 2560U, 16U, (u32 )((int )pHalData->nCur40MhzPrimeSC >> 1));
#line 1219
  PHY_SetBBReg(Adapter, 3328U, 3072U, (u32 )pHalData->nCur40MhzPrimeSC);
#line 1221
  PHY_SetBBReg(Adapter, 2180U, 1024U, 0U);
#line 1223
  PHY_SetBBReg(Adapter, 2072U, 201326592U, (unsigned int )pHalData->nCur40MhzPrimeSC == 1U ? 2U : 1U);
#line 1226
  goto ldv_54386;
  default: ;
#line 1232
  goto ldv_54386;
  }
  ldv_54386: ;
#line 1245
  switch ((int )pHalData->rf_chip) {
  case 1: ;
#line 1249
  goto ldv_54390;
  case 2: ;
#line 1255
  goto ldv_54390;
  case 3: ;
#line 1260
  goto ldv_54390;
  case 5: ;
#line 1264
  goto ldv_54390;
  case 4: 
#line 1267
  rtl8723a_phy_rf6052set_bw(Adapter, pHalData->CurrentChannelBW);
#line 1268
  goto ldv_54390;
  default: ;
#line 1273
  goto ldv_54390;
  }
  ldv_54390: ;
#line 1281
  return;
}
}
#line 1297 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
void PHY_SetBWMode23a8723A(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ,
                           unsigned char Offset ) 
{ 
  struct hal_data_8723a *pHalData ;
  enum ht_channel_width tmpBW ;

  {
#line 1300
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1301
  tmpBW = pHalData->CurrentChannelBW;
#line 1303
  pHalData->CurrentChannelBW = Bandwidth;
#line 1305
  pHalData->nCur40MhzPrimeSC = Offset;
#line 1307
  if (Adapter->bDriverStopped == 0 && Adapter->bSurpriseRemoved == 0) {
#line 1308
    _PHY_SetBWMode23a92C(Adapter);
  } else {
#line 1310
    pHalData->CurrentChannelBW = tmpBW;
  }
#line 1311
  return;
}
}
#line 1313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
static void _PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  u8 eRFPath ;
  u32 param1 ;
  u32 param2 ;
  struct hal_data_8723a *pHalData ;

  {
#line 1317
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1319
  if ((unsigned int )Adapter->bNotifyChannelChange != 0U) {
#line 1320
    if (GlobalDebugLevel23A > 3U) {
#line 1320
      printk("\016RTL8723AU: [%s] ch = %d\n", "_PHY_SwChnl8723A", (int )channel);
    } else {

    }
  } else {

  }
#line 1323
  PHY_SetTxPowerLevel8723A(Adapter, (int )channel);
#line 1327
  param1 = 24U;
#line 1328
  param2 = (u32 )channel;
#line 1329
  eRFPath = 0U;
#line 1329
  goto ldv_54413;
  ldv_54412: 
#line 1330
  pHalData->RfRegChnlVal[(int )eRFPath] = (pHalData->RfRegChnlVal[(int )eRFPath] & 4294966272U) | param2;
#line 1332
  PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH )eRFPath, param1, 1048575U, pHalData->RfRegChnlVal[(int )eRFPath]);
#line 1329
  eRFPath = (u8 )((int )eRFPath + 1);
  ldv_54413: ;
#line 1329
  if ((int )pHalData->NumTotalRFPath > (int )eRFPath) {
#line 1331
    goto ldv_54412;
  } else {

  }

#line 1336
  return;
}
}
#line 1339 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
void PHY_SwChnl8723A(struct rtw_adapter *Adapter , u8 channel ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmpchannel ;
  bool result ;

  {
#line 1341
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1342
  tmpchannel = pHalData->CurrentChannel;
#line 1343
  result = 1;
#line 1345
  if ((unsigned int )pHalData->rf_chip == 5U) {
#line 1347
    return;
  } else {

  }
#line 1350
  if ((unsigned int )channel == 0U) {
#line 1351
    channel = 1U;
  } else {

  }
#line 1353
  pHalData->CurrentChannel = channel;
#line 1355
  if (Adapter->bDriverStopped == 0 && Adapter->bSurpriseRemoved == 0) {
#line 1356
    _PHY_SwChnl8723A(Adapter, (int )channel);
#line 1358
    if (! result) {
#line 1359
      pHalData->CurrentChannel = tmpchannel;
    } else {

    }
  } else {
#line 1361
    pHalData->CurrentChannel = tmpchannel;
  }
#line 1362
  return;
}
}
#line 1492 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
void *ldv_kmem_cache_alloc_1628(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1495
  ldv_check_alloc_flags(flags);
#line 1497
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1498
  return ((void *)0);
}
}
#line 1536 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
int ldv_pskb_expand_head_1634(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1539
  ldv_check_alloc_flags(flags);
#line 1541
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1541
  return (tmp);
}
}
#line 1552 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
struct sk_buff *ldv_skb_clone_1636(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1555
  ldv_check_alloc_flags(flags);
#line 1557
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1557
  return (tmp);
}
}
#line 1568 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
struct sk_buff *ldv_skb_copy_1638(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1571
  ldv_check_alloc_flags(flags);
#line 1573
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1573
  return (tmp);
}
}
#line 1576 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1639(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1579
  ldv_check_alloc_flags(flags);
#line 1581
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1581
  return (tmp);
}
}
#line 1584 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1640(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1587
  ldv_check_alloc_flags(flags);
#line 1589
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1589
  return (tmp);
}
}
#line 1592 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1641(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1595
  ldv_check_alloc_flags(flags);
#line 1597
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1597
  return (tmp);
}
}
#line 1600 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
int ldv_pskb_expand_head_1642(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1603
  ldv_check_alloc_flags(flags);
#line 1605
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1605
  return (tmp);
}
}
#line 1608 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
int ldv_pskb_expand_head_1643(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1611
  ldv_check_alloc_flags(flags);
#line 1613
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1613
  return (tmp);
}
}
#line 1616 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_phycfg.o.c.prepared"
struct sk_buff *ldv_skb_clone_1644(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1619
  ldv_check_alloc_flags(flags);
#line 1621
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1621
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1670(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1678(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1686(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1680(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1676(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1684(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1685(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1681(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1682(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1683(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
void rtl8723a_phy_rf6052set_bw(struct rtw_adapter *Adapter , enum ht_channel_width Bandwidth ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 296
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 298
  switch ((unsigned int )Bandwidth) {
  case 0U: 
#line 300
  pHalData->RfRegChnlVal[0] = (pHalData->RfRegChnlVal[0] & 4294964223U) | 1024U;
#line 301
  PHY_SetRFReg(Adapter, 0, 24U, 1048575U, pHalData->RfRegChnlVal[0]);
#line 302
  goto ldv_54255;
  case 1U: 
#line 304
  pHalData->RfRegChnlVal[0] = pHalData->RfRegChnlVal[0] & 4294964223U;
#line 305
  PHY_SetRFReg(Adapter, 0, 24U, 1048575U, pHalData->RfRegChnlVal[0]);
#line 306
  goto ldv_54255;
  default: ;
#line 308
  goto ldv_54255;
  }
  ldv_54255: ;
#line 311
  return;
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
void rtl823a_phy_rf6052setccktxpower(struct rtw_adapter *Adapter , u8 *pPowerlevel ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u32 TxAGC[2U] ;
  u32 tmpval ;
  bool TurboScanOff ;
  u8 idx1 ;
  u8 idx2 ;
  u8 *ptr ;

  {
#line 331
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 332
  pdmpriv = & pHalData->dmpriv;
#line 333
  pmlmeext = & Adapter->mlmeextpriv;
#line 334
  TxAGC[0] = 0U;
#line 334
  TxAGC[1] = 0U;
#line 334
  tmpval = 0U;
#line 335
  TurboScanOff = 0;
#line 341
  if ((unsigned int )pHalData->EEPROMRegulatory != 0U || (unsigned int )pHalData->ExternalPA != 0U) {
#line 342
    TurboScanOff = 1;
  } else {

  }
#line 344
  if (pmlmeext->sitesurvey_res.state == 3) {
#line 345
    TxAGC[0] = 1061109567U;
#line 346
    TxAGC[1] = 1061109567U;
#line 348
    TurboScanOff = 1;
#line 350
    if ((int )TurboScanOff) {
#line 351
      idx1 = 0U;
#line 351
      goto ldv_54272;
      ldv_54271: 
#line 352
      TxAGC[(int )idx1] = (u32 )((((int )*(pPowerlevel + (unsigned long )idx1) | ((int )*(pPowerlevel + (unsigned long )idx1) << 8)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 16)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 24));
#line 356
      if (TxAGC[(int )idx1] > 32U && (unsigned int )pHalData->ExternalPA != 0U) {
#line 357
        TxAGC[(int )idx1] = 32U;
      } else {

      }
#line 351
      idx1 = (u8 )((int )idx1 + 1);
      ldv_54272: ;
#line 351
      if ((unsigned int )idx1 <= 1U) {
#line 353
        goto ldv_54271;
      } else {

      }

    } else {

    }
  } else
#line 364
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 1U) {
#line 365
    TxAGC[0] = 269488144U;
#line 366
    TxAGC[1] = 269488144U;
  } else
#line 367
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 2U) {
#line 368
    TxAGC[0] = 0U;
#line 369
    TxAGC[1] = 0U;
  } else {
#line 371
    idx1 = 0U;
#line 371
    goto ldv_54275;
    ldv_54274: 
#line 372
    TxAGC[(int )idx1] = (u32 )((((int )*(pPowerlevel + (unsigned long )idx1) | ((int )*(pPowerlevel + (unsigned long )idx1) << 8)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 16)) | ((int )*(pPowerlevel + (unsigned long )idx1) << 24));
#line 371
    idx1 = (u8 )((int )idx1 + 1);
    ldv_54275: ;
#line 371
    if ((unsigned int )idx1 <= 1U) {
#line 373
      goto ldv_54274;
    } else {

    }

#line 377
    if ((unsigned int )pHalData->EEPROMRegulatory == 0U) {
#line 378
      tmpval = pHalData->MCSTxPowerLevelOriginalOffset[0][6] + (pHalData->MCSTxPowerLevelOriginalOffset[0][7] << 8);
#line 380
      TxAGC[0] = TxAGC[0] + tmpval;
#line 382
      tmpval = pHalData->MCSTxPowerLevelOriginalOffset[0][14] + (pHalData->MCSTxPowerLevelOriginalOffset[0][15] << 24);
#line 384
      TxAGC[1] = TxAGC[1] + tmpval;
    } else {

    }
  }
#line 389
  idx1 = 0U;
#line 389
  goto ldv_54281;
  ldv_54280: 
#line 390
  ptr = (u8 *)(& TxAGC) + (unsigned long )idx1;
#line 391
  idx2 = 0U;
#line 391
  goto ldv_54278;
  ldv_54277: ;
#line 392
  if ((unsigned int )*ptr > 63U) {
#line 393
    *ptr = 63U;
  } else {

  }
#line 394
  ptr = ptr + 1;
#line 391
  idx2 = (u8 )((int )idx2 + 1);
  ldv_54278: ;
#line 391
  if ((unsigned int )idx2 <= 3U) {
#line 393
    goto ldv_54277;
  } else {

  }
#line 389
  idx1 = (u8 )((int )idx1 + 1);
  ldv_54281: ;
#line 389
  if ((unsigned int )idx1 <= 1U) {
#line 391
    goto ldv_54280;
  } else {

  }
#line 399
  tmpval = TxAGC[0] & 255U;
#line 400
  PHY_SetBBReg(Adapter, 3592U, 65280U, tmpval);
#line 401
  tmpval = TxAGC[0] >> 8;
#line 402
  PHY_SetBBReg(Adapter, 2156U, 4294967040U, tmpval);
#line 405
  tmpval = TxAGC[1] >> 24;
#line 406
  PHY_SetBBReg(Adapter, 2156U, 255U, tmpval);
#line 407
  tmpval = TxAGC[1] & 16777215U;
#line 408
  PHY_SetBBReg(Adapter, 2104U, 4294967040U, tmpval);
#line 409
  return;
}
}
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
static void getPowerBase(struct rtw_adapter *Adapter , u8 *pPowerLevel , u8 Channel ,
                         u32 *OfdmBase , u32 *MCSBase ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 powerBase0 ;
  u32 powerBase1 ;
  u8 Legacy_pwrdiff ;
  s8 HT20_pwrdiff ;
  u8 i ;
  u8 powerlevel[2U] ;

  {
#line 421
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 423
  Legacy_pwrdiff = 0U;
#line 424
  HT20_pwrdiff = 0;
#line 427
  i = 0U;
#line 427
  goto ldv_54298;
  ldv_54297: 
#line 428
  powerlevel[(int )i] = *(pPowerLevel + (unsigned long )i);
#line 429
  Legacy_pwrdiff = pHalData->TxPwrLegacyHtDiff[(int )i][(int )Channel + -1];
#line 430
  powerBase0 = (u32 )((int )powerlevel[(int )i] + (int )Legacy_pwrdiff);
#line 432
  powerBase0 = (((powerBase0 << 24) | (powerBase0 << 16)) | (powerBase0 << 8)) | powerBase0;
#line 433
  *(OfdmBase + (unsigned long )i) = powerBase0;
#line 427
  i = (u8 )((int )i + 1);
  ldv_54298: ;
#line 427
  if ((unsigned int )i <= 1U) {
#line 429
    goto ldv_54297;
  } else {

  }
#line 436
  i = 0U;
#line 436
  goto ldv_54301;
  ldv_54300: ;
#line 438
  if ((unsigned int )pHalData->CurrentChannelBW == 0U) {
#line 439
    HT20_pwrdiff = (s8 )pHalData->TxPwrHt20Diff[(int )i][(int )Channel + -1];
#line 440
    powerlevel[(int )i] = (int )powerlevel[(int )i] + (int )((u8 )HT20_pwrdiff);
  } else {

  }
#line 442
  powerBase1 = (u32 )powerlevel[(int )i];
#line 443
  powerBase1 = (((powerBase1 << 24) | (powerBase1 << 16)) | (powerBase1 << 8)) | powerBase1;
#line 444
  *(MCSBase + (unsigned long )i) = powerBase1;
#line 436
  i = (u8 )((int )i + 1);
  ldv_54301: ;
#line 436
  if ((unsigned int )i <= 1U) {
#line 438
    goto ldv_54300;
  } else {

  }

#line 443
  return;
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
static void getTxPowerWriteValByRegulatory(struct rtw_adapter *Adapter , u8 Channel ,
                                           u8 index , u32 *powerBase0 , u32 *powerBase1 ,
                                           u32 *pOutWriteVal ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  u8 i ;
  u8 chnlGroup ;
  u8 pwr_diff_limit[4U] ;
  u32 writeVal ;
  u32 customer_limit ;
  u32 rf ;

  {
#line 457
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 458
  pdmpriv = & pHalData->dmpriv;
#line 459
  chnlGroup = 0U;
#line 463
  rf = 0U;
#line 463
  goto ldv_54329;
  ldv_54328: ;
#line 464
  switch ((int )pHalData->EEPROMRegulatory) {
  case 0: 
#line 467
  chnlGroup = 0U;
#line 468
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
#line 470
  goto ldv_54320;
  case 1: ;
#line 473
  if ((unsigned int )pHalData->pwrGroupCnt == 1U) {
#line 474
    chnlGroup = 0U;
  } else {

  }
#line 475
  if ((unsigned int )pHalData->pwrGroupCnt > 2U) {
#line 476
    if ((unsigned int )Channel <= 3U) {
#line 477
      chnlGroup = 0U;
    } else
#line 478
    if ((unsigned int )Channel > 3U && (unsigned int )Channel <= 9U) {
#line 479
      chnlGroup = 1U;
    } else
#line 480
    if ((unsigned int )Channel > 9U) {
#line 481
      chnlGroup = 2U;
    } else {

    }
#line 483
    if ((unsigned int )pHalData->CurrentChannelBW == 0U) {
#line 484
      chnlGroup = (u8 )((int )chnlGroup + 1);
    } else {
#line 486
      chnlGroup = (unsigned int )chnlGroup + 4U;
    }
  } else {

  }
#line 488
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
#line 490
  goto ldv_54320;
  case 2: 
#line 493
  writeVal = (unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf);
#line 494
  goto ldv_54320;
  case 3: 
#line 496
  chnlGroup = 0U;
#line 498
  i = 0U;
#line 498
  goto ldv_54325;
  ldv_54324: 
#line 499
  pwr_diff_limit[(int )i] = (unsigned char )((pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] & (u32 )(127 << (int )i * 8)) >> (int )i * 8);
#line 501
  if ((unsigned int )pHalData->CurrentChannelBW == 1U) {
#line 502
    if ((int )pwr_diff_limit[(int )i] > (int )pHalData->PwrGroupHT40[rf][(int )Channel + -1]) {
#line 503
      pwr_diff_limit[(int )i] = pHalData->PwrGroupHT40[rf][(int )Channel + -1];
    } else {

    }
  } else
#line 505
  if ((int )pwr_diff_limit[(int )i] > (int )pHalData->PwrGroupHT20[rf][(int )Channel + -1]) {
#line 506
    pwr_diff_limit[(int )i] = pHalData->PwrGroupHT20[rf][(int )Channel + -1];
  } else {

  }
#line 498
  i = (u8 )((int )i + 1);
  ldv_54325: ;
#line 498
  if ((unsigned int )i <= 3U) {
#line 500
    goto ldv_54324;
  } else {

  }
#line 509
  customer_limit = (u32 )(((((int )pwr_diff_limit[3] << 24) | ((int )pwr_diff_limit[2] << 16)) | ((int )pwr_diff_limit[1] << 8)) | (int )pwr_diff_limit[0]);
#line 511
  writeVal = ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf)) + customer_limit;
#line 512
  goto ldv_54320;
  default: 
#line 514
  chnlGroup = 0U;
#line 515
  writeVal = pHalData->MCSTxPowerLevelOriginalOffset[(int )chnlGroup][(int )index + (rf != 0U ? 8 : 0)] + ((unsigned int )index <= 1U ? *(powerBase0 + (unsigned long )rf) : *(powerBase1 + (unsigned long )rf));
#line 517
  goto ldv_54320;
  }
  ldv_54320: ;
#line 524
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 1U) {
#line 525
    writeVal = 336860180U;
  } else
#line 526
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 2U) {
#line 527
    writeVal = 0U;
  } else {

  }
#line 531
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 3U) {
#line 532
    writeVal = writeVal - 101058054U;
  } else
#line 533
  if ((unsigned int )pdmpriv->DynamicTxHighPowerLvl == 4U) {
#line 534
    writeVal = writeVal;
  } else {

  }
#line 535
  *(pOutWriteVal + (unsigned long )rf) = writeVal;
#line 463
  rf = rf + 1U;
  ldv_54329: ;
#line 463
  if (rf <= 1U) {
#line 465
    goto ldv_54328;
  } else {

  }

#line 470
  return;
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
static void writeOFDMPowerReg(struct rtw_adapter *Adapter , u8 index , u32 *pValue ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 RegOffset_A[6U] ;
  u16 RegOffset_B[6U] ;
  u8 i ;
  u8 rf ;
  u8 pwr_val[4U] ;
  u32 writeVal ;
  u16 RegOffset ;

  {
#line 541
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 542
  RegOffset_A[0] = 3584U;
#line 542
  RegOffset_A[1] = 3588U;
#line 542
  RegOffset_A[2] = 3600U;
#line 542
  RegOffset_A[3] = 3604U;
#line 542
  RegOffset_A[4] = 3608U;
#line 542
  RegOffset_A[5] = 3612U;
#line 547
  RegOffset_B[0] = 2096U;
#line 547
  RegOffset_B[1] = 2100U;
#line 547
  RegOffset_B[2] = 2108U;
#line 547
  RegOffset_B[3] = 2120U;
#line 547
  RegOffset_B[4] = 2124U;
#line 547
  RegOffset_B[5] = 2152U;
#line 556
  rf = 0U;
#line 556
  goto ldv_54351;
  ldv_54350: 
#line 557
  writeVal = *(pValue + (unsigned long )rf);
#line 558
  i = 0U;
#line 558
  goto ldv_54345;
  ldv_54344: 
#line 559
  pwr_val[(int )i] = (unsigned char )(((u32 )(127 << (int )i * 8) & writeVal) >> (int )i * 8);
#line 560
  if ((unsigned int )pwr_val[(int )i] > 63U) {
#line 561
    pwr_val[(int )i] = 63U;
  } else {

  }
#line 558
  i = (u8 )((int )i + 1);
  ldv_54345: ;
#line 558
  if ((unsigned int )i <= 3U) {
#line 560
    goto ldv_54344;
  } else {

  }
#line 563
  writeVal = (u32 )(((((int )pwr_val[3] << 24) | ((int )pwr_val[2] << 16)) | ((int )pwr_val[1] << 8)) | (int )pwr_val[0]);
#line 566
  if ((unsigned int )rf == 0U) {
#line 567
    RegOffset = RegOffset_A[(int )index];
  } else {
#line 569
    RegOffset = RegOffset_B[(int )index];
  }
#line 571
  PHY_SetBBReg(Adapter, (u32 )RegOffset, 4294967295U, writeVal);
#line 574
  if (((unsigned int )pHalData->rf_type == 2U && ((unsigned int )RegOffset == 3612U || (unsigned int )RegOffset == 2152U)) || ((unsigned int )pHalData->rf_type != 2U && ((unsigned int )RegOffset == 3604U || (unsigned int )RegOffset == 2120U))) {
#line 580
    writeVal = (u32 )pwr_val[3];
#line 581
    if ((unsigned int )RegOffset == 3612U || (unsigned int )RegOffset == 3604U) {
#line 582
      RegOffset = 3216U;
    } else {

    }
#line 583
    if ((unsigned int )RegOffset == 2152U || (unsigned int )RegOffset == 2120U) {
#line 584
      RegOffset = 3224U;
    } else {

    }
#line 585
    i = 0U;
#line 585
    goto ldv_54348;
    ldv_54347: ;
#line 586
    if ((unsigned int )i != 2U) {
#line 587
      writeVal = writeVal > 8U ? writeVal - 8U : 0U;
    } else {
#line 589
      writeVal = writeVal > 6U ? writeVal - 6U : 0U;
    }
#line 590
    rtl8723au_write8(Adapter, (u32 )((int )RegOffset + (int )i), (int )((unsigned char )writeVal));
#line 585
    i = (u8 )((int )i + 1);
    ldv_54348: ;
#line 585
    if ((unsigned int )i <= 2U) {
#line 587
      goto ldv_54347;
    } else {

    }

  } else {

  }
#line 556
  rf = (u8 )((int )rf + 1);
  ldv_54351: ;
#line 556
  if ((unsigned int )rf <= 1U) {
#line 558
    goto ldv_54350;
  } else {

  }

#line 563
  return;
}
}
#line 618 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
void rtl8723a_PHY_RF6052SetOFDMTxPower(struct rtw_adapter *Adapter , u8 *pPowerLevel ,
                                       u8 Channel ) 
{ 
  u32 writeVal[2U] ;
  u32 powerBase0[2U] ;
  u32 powerBase1[2U] ;
  u8 index ;

  {
#line 621
  index = 0U;
#line 623
  getPowerBase(Adapter, pPowerLevel, (int )Channel, (u32 *)(& powerBase0), (u32 *)(& powerBase1));
#line 625
  index = 0U;
#line 625
  goto ldv_54363;
  ldv_54362: 
#line 626
  getTxPowerWriteValByRegulatory(Adapter, (int )Channel, (int )index, (u32 *)(& powerBase0),
                                 (u32 *)(& powerBase1), (u32 *)(& writeVal));
#line 629
  writeOFDMPowerReg(Adapter, (int )index, (u32 *)(& writeVal));
#line 625
  index = (u8 )((int )index + 1);
  ldv_54363: ;
#line 625
  if ((unsigned int )index <= 5U) {
#line 627
    goto ldv_54362;
  } else {

  }

#line 632
  return;
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
static int phy_RF6052_Config_ParaFile(struct rtw_adapter *Adapter ) 
{ 
  u32 u4RegValue ;
  u8 eRFPath ;
  struct bb_reg_define *pPhyReg ;
  int rtStatus ;
  struct hal_data_8723a *pHalData ;
  int tmp ;
  int tmp___0 ;

  {
#line 635
  u4RegValue = 0U;
#line 638
  rtStatus = 1;
#line 639
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 644
  eRFPath = 0U;
#line 644
  goto ldv_54384;
  ldv_54383: 
#line 646
  pPhyReg = (struct bb_reg_define *)(& pHalData->PHYRegDef) + (unsigned long )eRFPath;
#line 649
  switch ((int )eRFPath) {
  case 0: 
#line 651
  u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, 16U);
#line 652
  goto ldv_54374;
  case 1: 
#line 654
  u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, 1048576U);
#line 655
  goto ldv_54374;
  }
  ldv_54374: 
#line 659
  PHY_SetBBReg(Adapter, pPhyReg->rfintfe, 1048576U, 1U);
#line 660
  __const_udelay(4295UL);
#line 663
  PHY_SetBBReg(Adapter, pPhyReg->rfintfo, 16U, 1U);
#line 664
  __const_udelay(4295UL);
#line 667
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 1024U, 0U);
#line 668
  __const_udelay(4295UL);
#line 670
  PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, 2048U, 0U);
#line 671
  __const_udelay(4295UL);
#line 674
  switch ((int )eRFPath) {
  case 0: 
#line 676
  tmp = ODM_ConfigRFWithHeaderFile23a(& pHalData->odmpriv, (enum RF_RADIO_PATH )eRFPath,
                                      (enum RF_RADIO_PATH )eRFPath);
#line 676
  if (tmp == 0) {
#line 681
    rtStatus = 0;
  } else {

  }
#line 682
  goto ldv_54377;
  case 1: 
#line 684
  tmp___0 = ODM_ConfigRFWithHeaderFile23a(& pHalData->odmpriv, (enum RF_RADIO_PATH )eRFPath,
                                          (enum RF_RADIO_PATH )eRFPath);
#line 684
  if (tmp___0 == 0) {
#line 689
    rtStatus = 0;
  } else {

  }
#line 690
  goto ldv_54377;
  }
  ldv_54377: ;
#line 694
  switch ((int )eRFPath) {
  case 0: 
#line 696
  PHY_SetBBReg(Adapter, pPhyReg->rfintfs, 16U, u4RegValue);
#line 697
  goto ldv_54380;
  case 1: 
#line 699
  PHY_SetBBReg(Adapter, pPhyReg->rfintfs, 1048576U, u4RegValue);
#line 700
  goto ldv_54380;
  }
  ldv_54380: ;
#line 703
  if (rtStatus != 1) {
#line 705
    goto phy_RF6052_Config_ParaFile_Fail;
  } else {

  }
#line 644
  eRFPath = (u8 )((int )eRFPath + 1);
  ldv_54384: ;
#line 644
  if ((int )pHalData->NumTotalRFPath > (int )eRFPath) {
#line 646
    goto ldv_54383;
  } else {

  }

  phy_RF6052_Config_ParaFile_Fail: ;
#line 709
  return (rtStatus);
}
}
#line 712 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
int PHY_RF6052_Config8723A(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  int rtStatus ;

  {
#line 714
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 715
  rtStatus = 1;
#line 719
  if ((unsigned int )pHalData->rf_type == 3U) {
#line 720
    pHalData->NumTotalRFPath = 1U;
  } else {
#line 722
    pHalData->NumTotalRFPath = 2U;
  }
#line 725
  rtStatus = phy_RF6052_Config_ParaFile(Adapter);
#line 726
  return (rtStatus);
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
void *ldv_kmem_cache_alloc_1670(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 859
  ldv_check_alloc_flags(flags);
#line 861
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 862
  return ((void *)0);
}
}
#line 900 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
int ldv_pskb_expand_head_1676(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 903
  ldv_check_alloc_flags(flags);
#line 905
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 905
  return (tmp);
}
}
#line 916 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
struct sk_buff *ldv_skb_clone_1678(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 919
  ldv_check_alloc_flags(flags);
#line 921
  tmp = skb_clone(ldv_func_arg1, flags);
#line 921
  return (tmp);
}
}
#line 932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
struct sk_buff *ldv_skb_copy_1680(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 935
  ldv_check_alloc_flags(flags);
#line 937
  tmp = skb_copy(ldv_func_arg1, flags);
#line 937
  return (tmp);
}
}
#line 940 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1681(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 943
  ldv_check_alloc_flags(flags);
#line 945
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 945
  return (tmp);
}
}
#line 948 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1682(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 951
  ldv_check_alloc_flags(flags);
#line 953
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 953
  return (tmp);
}
}
#line 956 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1683(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 959
  ldv_check_alloc_flags(flags);
#line 961
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 961
  return (tmp);
}
}
#line 964 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
int ldv_pskb_expand_head_1684(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 967
  ldv_check_alloc_flags(flags);
#line 969
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 969
  return (tmp);
}
}
#line 972 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
int ldv_pskb_expand_head_1685(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 975
  ldv_check_alloc_flags(flags);
#line 977
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 977
  return (tmp);
}
}
#line 980 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rf6052.o.c.prepared"
struct sk_buff *ldv_skb_clone_1686(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 983
  ldv_check_alloc_flags(flags);
#line 985
  tmp = skb_clone(ldv_func_arg1, flags);
#line 985
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1712(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1720(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1728(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1722(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1718(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1726(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1727(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1723(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1724(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1725(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 65 "drivers/staging/rtl8723au/include/rtl8723a_recv.h"
void rtl8723a_process_phy_info(struct rtw_adapter *padapter , void *prframe ) ;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
static void process_rssi(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct signal_stat *signal_stat ;

  {
#line 242
  pattrib = & prframe->attrib;
#line 243
  signal_stat = & padapter->recvpriv.signal_strength_data;
#line 245
  if ((unsigned int )signal_stat->update_req != 0U) {
#line 246
    signal_stat->total_num = 0U;
#line 247
    signal_stat->total_val = 0U;
#line 248
    signal_stat->update_req = 0U;
  } else {

  }
#line 251
  signal_stat->total_num = signal_stat->total_num + 1U;
#line 252
  signal_stat->total_val = signal_stat->total_val + (u32 )pattrib->phy_info.SignalStrength;
#line 253
  signal_stat->avg_val = (u8 )(signal_stat->total_val / signal_stat->total_num);
#line 254
  return;
}
}
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
static void process_link_qual(struct rtw_adapter *padapter , struct recv_frame *prframe ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct signal_stat *signal_stat ;

  {
#line 262
  if ((unsigned long )prframe == (unsigned long )((struct recv_frame *)0) || (unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 263
    return;
  } else {

  }
#line 265
  pattrib = & prframe->attrib;
#line 266
  signal_stat = & padapter->recvpriv.signal_qual_data;
#line 268
  if ((unsigned int )signal_stat->update_req != 0U) {
#line 269
    signal_stat->total_num = 0U;
#line 270
    signal_stat->total_val = 0U;
#line 271
    signal_stat->update_req = 0U;
  } else {

  }
#line 274
  signal_stat->total_num = signal_stat->total_num + 1U;
#line 275
  signal_stat->total_val = signal_stat->total_val + (u32 )pattrib->phy_info.SignalQuality;
#line 276
  signal_stat->avg_val = (u8 )(signal_stat->total_val / signal_stat->total_num);
#line 277
  return;
}
}
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
void rtl8723a_process_phy_info(struct rtw_adapter *padapter , void *prframe ) 
{ 
  struct recv_frame *precvframe ;

  {
#line 282
  precvframe = (struct recv_frame *)prframe;
#line 284
  process_rssi(padapter, precvframe);
#line 286
  process_link_qual(padapter, precvframe);
#line 287
  return;
}
}
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
void *ldv_kmem_cache_alloc_1712(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 419
  ldv_check_alloc_flags(flags);
#line 421
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 422
  return ((void *)0);
}
}
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
int ldv_pskb_expand_head_1718(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 463
  ldv_check_alloc_flags(flags);
#line 465
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 465
  return (tmp);
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
struct sk_buff *ldv_skb_clone_1720(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 479
  ldv_check_alloc_flags(flags);
#line 481
  tmp = skb_clone(ldv_func_arg1, flags);
#line 481
  return (tmp);
}
}
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
struct sk_buff *ldv_skb_copy_1722(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 495
  ldv_check_alloc_flags(flags);
#line 497
  tmp = skb_copy(ldv_func_arg1, flags);
#line 497
  return (tmp);
}
}
#line 500 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1723(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 503
  ldv_check_alloc_flags(flags);
#line 505
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 505
  return (tmp);
}
}
#line 508 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1724(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 511
  ldv_check_alloc_flags(flags);
#line 513
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 513
  return (tmp);
}
}
#line 516 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1725(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 519
  ldv_check_alloc_flags(flags);
#line 521
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 521
  return (tmp);
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
int ldv_pskb_expand_head_1726(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 527
  ldv_check_alloc_flags(flags);
#line 529
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 529
  return (tmp);
}
}
#line 532 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
int ldv_pskb_expand_head_1727(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 535
  ldv_check_alloc_flags(flags);
#line 537
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 537
  return (tmp);
}
}
#line 540 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_rxdesc.o.c.prepared"
struct sk_buff *ldv_skb_clone_1728(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 543
  ldv_check_alloc_flags(flags);
#line 545
  tmp = skb_clone(ldv_func_arg1, flags);
#line 545
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1754(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1762(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1770(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1764(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1760(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1768(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1769(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1765(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1766(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1767(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
void rtl8723a_sreset_xmit_status_check(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;
  unsigned long current_time ;
  struct xmit_priv *pxmitpriv ;
  unsigned int diff_time ;
  u32 txdma_status ;

  {
#line 241
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 242
  psrtpriv = & pHalData->srestpriv;
#line 245
  pxmitpriv = & padapter->xmitpriv;
#line 249
  txdma_status = rtl8723au_read32(padapter, 528U);
#line 250
  if (txdma_status != 0U) {
#line 251
    if (GlobalDebugLevel23A > 3U) {
#line 251
      printk("\016RTL8723AU: %s REG_TXDMA_STATUS:0x%08x\n", "rtl8723a_sreset_xmit_status_check",
             txdma_status);
    } else {

    }
#line 252
    rtw_sreset_reset(padapter);
  } else {

  }
#line 255
  current_time = jiffies;
#line 257
  if (pxmitpriv->free_xmitbuf_cnt == 0U || pxmitpriv->free_xmit_extbuf_cnt == 0U) {
#line 259
    diff_time = jiffies_to_msecs((unsigned long )jiffies - psrtpriv->last_tx_time);
#line 261
    if (diff_time > 2000U) {
#line 262
      if (psrtpriv->last_tx_complete_time == 0UL) {
#line 263
        psrtpriv->last_tx_complete_time = current_time;
      } else {
#line 265
        diff_time = jiffies_to_msecs((unsigned long )jiffies - psrtpriv->last_tx_complete_time);
#line 266
        if (diff_time > 4000U) {
#line 268
          if (GlobalDebugLevel23A > 3U) {
#line 268
            printk("\016RTL8723AU: %s tx hang\n", "rtl8723a_sreset_xmit_status_check");
          } else {

          }
#line 269
          rtw_sreset_reset(padapter);
        } else {

        }
      }
    } else {

    }
  } else {

  }
#line 275
  if (psrtpriv->dbg_trigger_point == 1) {
#line 276
    psrtpriv->dbg_trigger_point = 0;
#line 277
    rtw_sreset_reset(padapter);
#line 278
    return;
  } else {

  }
#line 280
  return;
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
void rtl8723a_sreset_linked_status_check(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct sreset_priv *psrtpriv ;

  {
#line 284
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 285
  psrtpriv = & pHalData->srestpriv;
#line 287
  if (psrtpriv->dbg_trigger_point == 2) {
#line 288
    psrtpriv->dbg_trigger_point = 0;
#line 289
    rtw_sreset_reset(padapter);
#line 290
    return;
  } else {

  }
#line 292
  return;
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
void *ldv_kmem_cache_alloc_1754(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 424
  ldv_check_alloc_flags(flags);
#line 426
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 427
  return ((void *)0);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
int ldv_pskb_expand_head_1760(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 468
  ldv_check_alloc_flags(flags);
#line 470
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 470
  return (tmp);
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
struct sk_buff *ldv_skb_clone_1762(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 484
  ldv_check_alloc_flags(flags);
#line 486
  tmp = skb_clone(ldv_func_arg1, flags);
#line 486
  return (tmp);
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
struct sk_buff *ldv_skb_copy_1764(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 500
  ldv_check_alloc_flags(flags);
#line 502
  tmp = skb_copy(ldv_func_arg1, flags);
#line 502
  return (tmp);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1765(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 508
  ldv_check_alloc_flags(flags);
#line 510
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 510
  return (tmp);
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1766(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 516
  ldv_check_alloc_flags(flags);
#line 518
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 518
  return (tmp);
}
}
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1767(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 524
  ldv_check_alloc_flags(flags);
#line 526
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 526
  return (tmp);
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
int ldv_pskb_expand_head_1768(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 532
  ldv_check_alloc_flags(flags);
#line 534
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 534
  return (tmp);
}
}
#line 537 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
int ldv_pskb_expand_head_1769(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 540
  ldv_check_alloc_flags(flags);
#line 542
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 542
  return (tmp);
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_sreset.o.c.prepared"
struct sk_buff *ldv_skb_clone_1770(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 548
  ldv_check_alloc_flags(flags);
#line 550
  tmp = skb_clone(ldv_func_arg1, flags);
#line 550
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1796(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1804(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1812(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1806(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1802(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1810(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1811(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1807(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1808(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1809(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 214 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
void dump_txrpt_ccx_8723a(void *buf ) ;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
void dump_txrpt_ccx_8723a(void *buf ) 
{ 
  struct txrpt_ccx_8723a *txrpt_ccx ;

  {
#line 241
  txrpt_ccx = (struct txrpt_ccx_8723a *)buf;
#line 243
  if (GlobalDebugLevel23A > 3U) {
#line 243
    printk("\016RTL8723AU: %s:\ntag1:%u, rsvd:%u, int_bt:%u, int_tri:%u, int_ccx:%u\nmac_id:%u, pkt_drop:%u, pkt_ok:%u, bmc:%u\nretry_cnt:%u, lifetime_over:%u, retry_over:%u\nccx_qtime:%u\nfinal_data_rate:0x%02x\nqsel:%u, sw:0x%03x\n",
           "dump_txrpt_ccx_8723a", (int )txrpt_ccx->tag1, (int )txrpt_ccx->rsvd, (int )txrpt_ccx->int_bt,
           (int )txrpt_ccx->int_tri, (int )txrpt_ccx->int_ccx, (int )txrpt_ccx->mac_id,
           (int )txrpt_ccx->pkt_drop, (int )txrpt_ccx->pkt_ok, (int )txrpt_ccx->bmc,
           (int )txrpt_ccx->retry_cnt, (int )txrpt_ccx->lifetime_over, (int )txrpt_ccx->retry_over,
           (int )txrpt_ccx->ccx_qtime0 + ((int )txrpt_ccx->ccx_qtime1 << 8), (int )txrpt_ccx->final_data_rate,
           (int )txrpt_ccx->qsel, (int )txrpt_ccx->sw0 + ((int )txrpt_ccx->sw1 << 8));
  } else {

  }
#line 244
  return;
}
}
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
void handle_txrpt_ccx_8723a(struct rtw_adapter *adapter , void *buf ) 
{ 
  struct txrpt_ccx_8723a *txrpt_ccx ;

  {
#line 262
  txrpt_ccx = (struct txrpt_ccx_8723a *)buf;
#line 264
  if ((unsigned int )*((unsigned char *)txrpt_ccx + 0UL) != 0U) {
#line 265
    if ((unsigned int )*((unsigned char *)txrpt_ccx + 1UL) != 0U) {
#line 266
      rtw_ack_tx_done23a(& adapter->xmitpriv, 0);
    } else {
#line 268
      rtw_ack_tx_done23a(& adapter->xmitpriv, 8);
    }
  } else {

  }
#line 269
  return;
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
void *ldv_kmem_cache_alloc_1796(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 402
  ldv_check_alloc_flags(flags);
#line 404
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 405
  return ((void *)0);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
int ldv_pskb_expand_head_1802(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 446
  ldv_check_alloc_flags(flags);
#line 448
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 448
  return (tmp);
}
}
#line 459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
struct sk_buff *ldv_skb_clone_1804(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 462
  ldv_check_alloc_flags(flags);
#line 464
  tmp = skb_clone(ldv_func_arg1, flags);
#line 464
  return (tmp);
}
}
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
struct sk_buff *ldv_skb_copy_1806(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 478
  ldv_check_alloc_flags(flags);
#line 480
  tmp = skb_copy(ldv_func_arg1, flags);
#line 480
  return (tmp);
}
}
#line 483 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1807(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 486
  ldv_check_alloc_flags(flags);
#line 488
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 488
  return (tmp);
}
}
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1808(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 494
  ldv_check_alloc_flags(flags);
#line 496
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 496
  return (tmp);
}
}
#line 499 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1809(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 502
  ldv_check_alloc_flags(flags);
#line 504
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 504
  return (tmp);
}
}
#line 507 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
int ldv_pskb_expand_head_1810(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 510
  ldv_check_alloc_flags(flags);
#line 512
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 512
  return (tmp);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
int ldv_pskb_expand_head_1811(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 518
  ldv_check_alloc_flags(flags);
#line 520
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 520
  return (tmp);
}
}
#line 523 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_xmit.o.c.prepared"
struct sk_buff *ldv_skb_clone_1812(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 526
  ldv_check_alloc_flags(flags);
#line 528
  tmp = skb_clone(ldv_func_arg1, flags);
#line 528
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1838(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1846(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1854(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1848(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1844(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1852(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1853(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1849(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1850(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1851(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 25 "drivers/staging/rtl8723au/include/rtl8723a_led.h"
void rtl8723au_InitSwLeds(struct rtw_adapter *padapter ) ;
#line 26
void rtl8723au_DeInitSwLeds(struct rtw_adapter *padapter ) ;
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
void SwLedOn23a(struct rtw_adapter *padapter , struct led_8723a *pLed ) 
{ 
  u8 LedCfg ;

  {
#line 255
  LedCfg = 0U;
#line 257
  if (padapter->bSurpriseRemoved == 1 || padapter->bDriverStopped == 1) {
#line 258
    return;
  } else {

  }
#line 259
  switch ((unsigned int )pLed->LedPin) {
  case 4U: ;
#line 261
  goto ldv_54259;
  case 1U: 
#line 264
  rtl8723au_write8(padapter, 76U, (int )(((unsigned int )LedCfg & 144U) | 96U));
#line 266
  goto ldv_54259;
  case 2U: 
#line 269
  rtl8723au_write8(padapter, 77U, 64);
#line 270
  goto ldv_54259;
  case 3U: 
#line 272
  LedCfg = rtl8723au_read8(padapter, 78U);
#line 274
  rtl8723au_write8(padapter, 78U, (int )(((unsigned int )LedCfg & 128U) | 32U));
#line 275
  goto ldv_54259;
  default: ;
#line 277
  goto ldv_54259;
  }
  ldv_54259: 
#line 279
  pLed->bLedOn = 1U;
#line 280
  return;
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
void SwLedOff23a(struct rtw_adapter *padapter , struct led_8723a *pLed ) 
{ 
  u8 LedCfg ;

  {
#line 286
  LedCfg = 0U;
#line 289
  if (padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) {
#line 290
    goto exit;
  } else {

  }
#line 292
  switch ((unsigned int )pLed->LedPin) {
  case 4U: ;
#line 294
  goto ldv_54271;
  case 1U: 
#line 297
  rtl8723au_write8(padapter, 76U, (int )(((unsigned int )LedCfg & 144U) | 96U));
#line 299
  goto ldv_54271;
  case 2U: 
#line 302
  rtl8723au_write8(padapter, 77U, 96);
#line 304
  goto ldv_54271;
  case 3U: 
#line 306
  LedCfg = rtl8723au_read8(padapter, 78U);
#line 308
  rtl8723au_write8(padapter, 78U, (int )(((unsigned int )LedCfg & 128U) | 40U));
#line 310
  goto ldv_54271;
  default: ;
#line 312
  goto ldv_54271;
  }
  ldv_54271: ;
  exit: 
#line 315
  pLed->bLedOn = 0U;
#line 316
  return;
}
}
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
void rtl8723au_InitSwLeds(struct rtw_adapter *padapter ) 
{ 
  struct led_priv *pledpriv ;

  {
#line 325
  pledpriv = & padapter->ledpriv;
#line 327
  pledpriv->LedControlHandler = & LedControl871x23a;
#line 329
  InitLed871x23a(padapter, & pledpriv->SwLed0, 3);
#line 330
  return;
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
void rtl8723au_DeInitSwLeds(struct rtw_adapter *padapter ) 
{ 
  struct led_priv *ledpriv ;

  {
#line 339
  ledpriv = & padapter->ledpriv;
#line 341
  DeInitLed871x23a(& ledpriv->SwLed0);
#line 342
  return;
}
}
#line 471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
void *ldv_kmem_cache_alloc_1838(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 474
  ldv_check_alloc_flags(flags);
#line 476
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 477
  return ((void *)0);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
int ldv_pskb_expand_head_1844(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 518
  ldv_check_alloc_flags(flags);
#line 520
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 520
  return (tmp);
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
struct sk_buff *ldv_skb_clone_1846(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 534
  ldv_check_alloc_flags(flags);
#line 536
  tmp = skb_clone(ldv_func_arg1, flags);
#line 536
  return (tmp);
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
struct sk_buff *ldv_skb_copy_1848(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 550
  ldv_check_alloc_flags(flags);
#line 552
  tmp = skb_copy(ldv_func_arg1, flags);
#line 552
  return (tmp);
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1849(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 558
  ldv_check_alloc_flags(flags);
#line 560
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 560
  return (tmp);
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1850(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 566
  ldv_check_alloc_flags(flags);
#line 568
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 568
  return (tmp);
}
}
#line 571 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1851(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 574
  ldv_check_alloc_flags(flags);
#line 576
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 576
  return (tmp);
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
int ldv_pskb_expand_head_1852(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 582
  ldv_check_alloc_flags(flags);
#line 584
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 584
  return (tmp);
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
int ldv_pskb_expand_head_1853(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 590
  ldv_check_alloc_flags(flags);
#line 592
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 592
  return (tmp);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_led.o.c.prepared"
struct sk_buff *ldv_skb_clone_1854(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 598
  ldv_check_alloc_flags(flags);
#line 600
  tmp = skb_clone(ldv_func_arg1, flags);
#line 600
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1880(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1888(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1896(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1890(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1886(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1894(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1895(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 1189 "include/linux/skbuff.h"
__inline static __u32 skb_queue_len(struct sk_buff_head  const  *list_ ) 
{ 


  {
#line 1191
  return ((__u32 )list_->qlen);
}
}
#line 1218 "include/linux/skbuff.h"
__inline static void skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct lock_class_key __key ;

  {
#line 1220
  spinlock_check(& list->lock);
#line 1220
  __raw_spin_lock_init(& list->lock.ldv_6347.rlock, "&(&list->lock)->rlock", & __key);
#line 1221
  __skb_queue_head_init(list);
#line 1222
  return;
}
}
#line 1381
extern void skb_queue_tail(struct sk_buff_head * , struct sk_buff * ) ;
#line 1666 "include/linux/skbuff.h"
__inline static void skb_reserve(struct sk_buff *skb , int len ) 
{ 


  {
#line 1668
  skb->data = skb->data + (unsigned long )len;
#line 1669
  skb->tail = skb->tail + (sk_buff_data_t )len;
#line 1670
  return;
}
}
#line 2002
extern void skb_queue_purge(struct sk_buff_head * ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1891(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1892(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1893(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2032
struct sk_buff *ldv___netdev_alloc_skb_1899(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 1581 "include/linux/usb.h"
extern struct urb *usb_alloc_urb(int  , gfp_t  ) ;
#line 1584
struct urb *ldv_usb_alloc_urb_1897(int ldv_func_arg1 , gfp_t flags ) ;
#line 1588
struct urb *ldv_usb_alloc_urb_1898(int ldv_func_arg1 , gfp_t flags ) ;
#line 1590
extern void usb_free_urb(struct urb * ) ;
#line 39 "drivers/staging/rtl8723au/include/usb_ops.h"
void rtl8723au_recv_tasklet(void *priv ) ;
#line 66 "drivers/staging/rtl8723au/include/rtl8723a_recv.h"
void update_recvframe_attrib(struct recv_frame *precvframe , struct recv_stat *prxstat ) ;
#line 67
void update_recvframe_phyinfo(struct recv_frame *precvframe , struct phy_stat *pphy_status ) ;
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
int rtl8723au_init_recv_priv(struct rtw_adapter *padapter ) 
{ 
  struct recv_priv *precvpriv ;
  int i ;
  int size ;
  int res ;
  struct recv_buf *precvbuf ;
  unsigned long tmpaddr ;
  unsigned long alignment ;
  struct sk_buff *pskb ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 246
  precvpriv = & padapter->recvpriv;
#line 247
  res = 1;
#line 253
  tasklet_init(& precvpriv->recv_tasklet, (void (*)(unsigned long  ))(& rtl8723au_recv_tasklet),
               (unsigned long )padapter);
#line 257
  precvpriv->int_in_urb = ldv_usb_alloc_urb_1897(0, 208U);
#line 258
  if ((unsigned long )precvpriv->int_in_urb == (unsigned long )((struct urb *)0)) {
#line 259
    if (GlobalDebugLevel23A > 3U) {
#line 259
      printk("\016RTL8723AU: alloc_urb for interrupt in endpoint fail !!!!\n");
    } else {

    }
  } else {

  }
#line 260
  tmp = kzalloc(56UL, 208U);
#line 260
  precvpriv->int_in_buf = (u8 *)tmp;
#line 261
  if ((unsigned long )precvpriv->int_in_buf == (unsigned long )((u8 *)0U)) {
#line 262
    if (GlobalDebugLevel23A > 3U) {
#line 262
      printk("\016RTL8723AU: alloc_mem for interrupt in endpoint fail !!!!\n");
    } else {

    }
  } else {

  }
#line 264
  size = 160;
#line 265
  tmp___0 = kzalloc((size_t )size, 208U);
#line 265
  precvpriv->precv_buf = (u8 *)tmp___0;
#line 266
  if ((unsigned long )precvpriv->precv_buf == (unsigned long )((u8 *)0U)) {
#line 267
    res = 0;
#line 268
    if (GlobalDebugLevel23A > 3U) {
#line 268
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 268
      printk("\016alloc recv_buf fail!\n");
    } else {

    }
#line 270
    goto exit;
  } else {

  }
#line 273
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
#line 275
  i = 0;
#line 275
  goto ldv_54320;
  ldv_54319: 
#line 276
  INIT_LIST_HEAD(& precvbuf->list);
#line 278
  precvbuf->purb = ldv_usb_alloc_urb_1898(0, 208U);
#line 279
  if ((unsigned long )precvbuf->purb == (unsigned long )((struct urb *)0)) {
#line 280
    goto ldv_54318;
  } else {

  }
#line 282
  precvbuf->adapter = padapter;
#line 284
  precvbuf = precvbuf + 1;
#line 275
  i = i + 1;
  ldv_54320: ;
#line 275
  if (i <= 3) {
#line 277
    goto ldv_54319;
  } else {

  }
  ldv_54318: 
#line 287
  skb_queue_head_init(& precvpriv->rx_skb_queue);
#line 288
  skb_queue_head_init(& precvpriv->free_recv_skb_queue);
#line 290
  i = 0;
#line 290
  goto ldv_54322;
  ldv_54321: 
#line 291
  size = 15368;
#line 292
  pskb = ldv___netdev_alloc_skb_1899(padapter->pnetdev, (unsigned int )size, 208U);
#line 294
  if ((unsigned long )pskb != (unsigned long )((struct sk_buff *)0)) {
#line 295
    pskb->dev = padapter->pnetdev;
#line 297
    tmpaddr = (unsigned long )pskb->data;
#line 298
    alignment = tmpaddr & 7UL;
#line 299
    skb_reserve(pskb, (int )(8U - (unsigned int )alignment));
#line 301
    skb_queue_tail(& precvpriv->free_recv_skb_queue, pskb);
  } else {

  }
#line 304
  pskb = (struct sk_buff *)0;
#line 290
  i = i + 1;
  ldv_54322: ;
#line 290
  if (i <= 7) {
#line 292
    goto ldv_54321;
  } else {

  }

  exit: ;
#line 308
  return (res);
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
void rtl8723au_free_recv_priv(struct rtw_adapter *padapter ) 
{ 
  int i ;
  struct recv_buf *precvbuf ;
  struct recv_priv *precvpriv ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
#line 315
  precvpriv = & padapter->recvpriv;
#line 317
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
#line 319
  i = 0;
#line 319
  goto ldv_54331;
  ldv_54330: 
#line 320
  usb_free_urb(precvbuf->purb);
#line 322
  if ((unsigned long )precvbuf->pskb != (unsigned long )((struct sk_buff *)0)) {
#line 323
    dev_kfree_skb_any(precvbuf->pskb);
  } else {

  }
#line 325
  precvbuf = precvbuf + 1;
#line 319
  i = i + 1;
  ldv_54331: ;
#line 319
  if (i <= 3) {
#line 321
    goto ldv_54330;
  } else {

  }
#line 328
  kfree((void const   *)precvpriv->precv_buf);
#line 330
  usb_free_urb(precvpriv->int_in_urb);
#line 331
  kfree((void const   *)precvpriv->int_in_buf);
#line 333
  tmp = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->rx_skb_queue));
#line 333
  if (tmp != 0U) {
#line 334
    if (GlobalDebugLevel23A > 3U) {
#line 334
      printk("\016RTL8723AU: \frx_skb_queue not empty\n");
    } else {

    }
  } else {

  }
#line 336
  skb_queue_purge(& precvpriv->rx_skb_queue);
#line 338
  tmp___1 = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->free_recv_skb_queue));
#line 338
  if (tmp___1 != 0U) {
#line 339
    if (GlobalDebugLevel23A > 3U) {
#line 339
      tmp___0 = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->free_recv_skb_queue));
#line 339
      printk("\016RTL8723AU: \ffree_recv_skb_queue not empty, %d\n", tmp___0);
    } else {

    }
  } else {

  }
#line 343
  skb_queue_purge(& precvpriv->free_recv_skb_queue);
#line 344
  return;
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
void update_recvframe_attrib(struct recv_frame *precvframe , struct recv_stat *prxstat ) 
{ 
  struct rx_pkt_attrib *pattrib ;
  struct recv_stat_cpu report ;
  struct rxreport_8723a *prxreport ;

  {
#line 362
  report.rxdw0 = prxstat->rxdw0;
#line 363
  report.rxdw1 = prxstat->rxdw1;
#line 364
  report.rxdw2 = prxstat->rxdw2;
#line 365
  report.rxdw3 = prxstat->rxdw3;
#line 366
  report.rxdw4 = prxstat->rxdw4;
#line 367
  report.rxdw5 = prxstat->rxdw5;
#line 369
  prxreport = (struct rxreport_8723a *)(& report);
#line 371
  pattrib = & precvframe->attrib;
#line 372
  memset((void *)pattrib, 0, 96UL);
#line 375
  pattrib->pkt_len = prxreport->pktlen;
#line 376
  pattrib->drvinfo_sz = (int )prxreport->drvinfosize << 3U;
#line 377
  pattrib->physt = prxreport->physt;
#line 379
  pattrib->crc_err = prxreport->crc32;
#line 380
  pattrib->icv_err = prxreport->icverr;
#line 382
  pattrib->bdecrypted = (unsigned int )*((unsigned char *)prxreport + 3UL) == 0U;
#line 383
  pattrib->encrypt = (u32 )prxreport->security;
#line 385
  pattrib->qos = prxreport->qos;
#line 386
  pattrib->priority = prxreport->tid;
#line 388
  pattrib->amsdu = prxreport->amsdu;
#line 390
  pattrib->seq_num = prxreport->seq;
#line 391
  pattrib->frag_num = prxreport->frag;
#line 392
  pattrib->mfrag = prxreport->mf;
#line 393
  pattrib->mdata = prxreport->md;
#line 395
  pattrib->mcs_rate = prxreport->rxmcs;
#line 396
  pattrib->rxht = prxreport->rxht;
#line 397
  return;
}
}
#line 399 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
void update_recvframe_phyinfo(struct recv_frame *precvframe , struct phy_stat *pphy_status ) 
{ 
  struct rtw_adapter *padapter ;
  struct rx_pkt_attrib *pattrib ;
  struct hal_data_8723a *pHalData ;
  struct phy_info *pPHYInfo ;
  struct odm_packet_info pkt_info ;
  u8 *sa ;
  u8 *da ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct sk_buff *skb ;
  struct ieee80211_hdr *hdr ;
  bool matchbssid ;
  u8 *bssid ;
  int tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;

  {
#line 402
  padapter = precvframe->adapter;
#line 403
  pattrib = & precvframe->attrib;
#line 404
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 405
  pPHYInfo = & pattrib->phy_info;
#line 407
  sa = (u8 *)0U;
#line 410
  skb = precvframe->pkt;
#line 411
  hdr = (struct ieee80211_hdr *)skb->data;
#line 412
  matchbssid = 0;
#line 415
  tmp = ieee80211_is_ctl((int )hdr->frame_control);
#line 415
  matchbssid = (bool )((tmp == 0 && (unsigned int )pattrib->icv_err == 0U) && (unsigned int )pattrib->crc_err == 0U);
#line 418
  if ((int )matchbssid) {
#line 419
    switch ((int )hdr->frame_control & 768) {
    case 256: 
#line 423
    bssid = (u8 *)(& hdr->addr1);
#line 424
    goto ldv_54365;
    case 512: 
#line 426
    bssid = (u8 *)(& hdr->addr2);
#line 427
    goto ldv_54365;
    case 0: 
#line 429
    bssid = (u8 *)(& hdr->addr3);
#line 430
    goto ldv_54365;
    default: 
#line 432
    bssid = (u8 *)0U;
#line 433
    matchbssid = 0;
    }
    ldv_54365: ;
#line 436
    if ((unsigned long )bssid != (unsigned long )((u8 *)0U)) {
#line 437
      tmp___0 = get_bssid(& padapter->mlmepriv);
#line 437
      matchbssid = ether_addr_equal((u8 const   *)tmp___0, (u8 const   *)bssid);
    } else {

    }
  } else {

  }
#line 441
  pkt_info.bPacketMatchBSSID = matchbssid;
#line 443
  da = ieee80211_get_DA(hdr);
#line 444
  if ((int )pkt_info.bPacketMatchBSSID) {
#line 444
    tmp___1 = myid(& padapter->eeprompriv);
#line 444
    tmp___2 = memcmp((void const   *)da, (void const   *)tmp___1, 6UL);
#line 444
    if (tmp___2 == 0) {
#line 444
      tmp___3 = 1;
    } else {
#line 444
      tmp___3 = 0;
    }
  } else {
#line 444
    tmp___3 = 0;
  }
#line 444
  pkt_info.bPacketToSelf = (bool )tmp___3;
#line 447
  if ((int )pkt_info.bPacketMatchBSSID) {
#line 447
    tmp___4 = ieee80211_is_beacon((int )hdr->frame_control);
#line 447
    if (tmp___4 != 0) {
#line 447
      tmp___5 = 1;
    } else {
#line 447
      tmp___5 = 0;
    }
  } else {
#line 447
    tmp___5 = 0;
  }
#line 447
  pkt_info.bPacketBeacon = (bool )tmp___5;
#line 450
  pkt_info.StationID = 255U;
#line 451
  if ((int )pkt_info.bPacketBeacon) {
#line 452
    tmp___6 = check_fwstate(& padapter->mlmepriv, 8);
#line 452
    if ((int )tmp___6) {
#line 453
      sa = (u8 *)(& padapter->mlmepriv.cur_network.network.MacAddress);
    } else {

    }
  } else {
#line 456
    sa = ieee80211_get_SA(hdr);
  }
#line 459
  pstapriv = & padapter->stapriv;
#line 460
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)sa);
#line 461
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 462
    pkt_info.StationID = (u8 )psta->mac_id;
  } else {

  }
#line 465
  pkt_info.Rate = pattrib->mcs_rate;
#line 467
  ODM_PhyStatusQuery23a(& pHalData->odmpriv, pPHYInfo, (u8 *)pphy_status, & pkt_info);
#line 469
  precvframe->psta = (struct sta_info *)0;
#line 470
  if ((int )pkt_info.bPacketMatchBSSID) {
#line 470
    tmp___8 = check_fwstate(& padapter->mlmepriv, 16);
#line 470
    if ((int )tmp___8) {
#line 472
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 473
        precvframe->psta = psta;
#line 474
        rtl8723a_process_phy_info(padapter, (void *)precvframe);
      } else {

      }
    } else {
#line 470
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 476
  if ((int )pkt_info.bPacketToSelf || (int )pkt_info.bPacketBeacon) {
#line 477
    tmp___7 = check_fwstate(& padapter->mlmepriv, 96);
#line 477
    if ((int )tmp___7) {
#line 480
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 481
        precvframe->psta = psta;
      } else {

      }
    } else {

    }
#line 483
    rtl8723a_process_phy_info(padapter, (void *)precvframe);
  } else {

  }
#line 485
  return;
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
void *ldv_kmem_cache_alloc_1880(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 617
  ldv_check_alloc_flags(flags);
#line 619
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 620
  return ((void *)0);
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
int ldv_pskb_expand_head_1886(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 661
  ldv_check_alloc_flags(flags);
#line 663
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 663
  return (tmp);
}
}
#line 674 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct sk_buff *ldv_skb_clone_1888(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 677
  ldv_check_alloc_flags(flags);
#line 679
  tmp = skb_clone(ldv_func_arg1, flags);
#line 679
  return (tmp);
}
}
#line 690 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct sk_buff *ldv_skb_copy_1890(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 693
  ldv_check_alloc_flags(flags);
#line 695
  tmp = skb_copy(ldv_func_arg1, flags);
#line 695
  return (tmp);
}
}
#line 698 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1891(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 701
  ldv_check_alloc_flags(flags);
#line 703
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 703
  return (tmp);
}
}
#line 706 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1892(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 709
  ldv_check_alloc_flags(flags);
#line 711
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 711
  return (tmp);
}
}
#line 714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1893(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 717
  ldv_check_alloc_flags(flags);
#line 719
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 719
  return (tmp);
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
int ldv_pskb_expand_head_1894(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 725
  ldv_check_alloc_flags(flags);
#line 727
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 727
  return (tmp);
}
}
#line 730 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
int ldv_pskb_expand_head_1895(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 733
  ldv_check_alloc_flags(flags);
#line 735
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 735
  return (tmp);
}
}
#line 738 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct sk_buff *ldv_skb_clone_1896(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 741
  ldv_check_alloc_flags(flags);
#line 743
  tmp = skb_clone(ldv_func_arg1, flags);
#line 743
  return (tmp);
}
}
#line 746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct urb *ldv_usb_alloc_urb_1897(int ldv_func_arg1 , gfp_t flags ) 
{ 
  struct urb *tmp ;

  {
#line 749
  ldv_check_alloc_flags(flags);
#line 751
  tmp = usb_alloc_urb(ldv_func_arg1, flags);
#line 751
  return (tmp);
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct urb *ldv_usb_alloc_urb_1898(int ldv_func_arg1 , gfp_t flags ) 
{ 
  struct urb *tmp ;

  {
#line 757
  ldv_check_alloc_flags(flags);
#line 759
  tmp = usb_alloc_urb(ldv_func_arg1, flags);
#line 759
  return (tmp);
}
}
#line 762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_recv.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1899(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 765
  ldv_check_alloc_flags(flags);
#line 767
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 767
  return (tmp);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1928(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1936(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1944(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1938(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1934(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1942(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1943(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1939(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1940(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1941(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 27 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
int rtl8723au_write_port(struct rtw_adapter *padapter , u32 addr , u32 cnt , struct xmit_buf *pxmitbuf ) ;
#line 224 "drivers/staging/rtl8723au/include/rtl8723a_xmit.h"
bool rtl8723au_xmitframe_complete(struct rtw_adapter *padapter , struct xmit_priv *pxmitpriv ,
                                  struct xmit_buf *pxmitbuf ) ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
static void do_queue_select___0(struct rtw_adapter *padapter , struct pkt_attrib *pattrib ) 
{ 
  u8 qsel ;

  {
#line 246
  qsel = pattrib->priority;
#line 247
  if (GlobalDebugLevel23A > 6U) {
#line 247
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 247
    printk("\016### do_queue_select priority =%d , qsel = %d\n", (int )pattrib->priority,
           (int )qsel);
  } else {

  }
#line 251
  pattrib->qsel = qsel;
#line 252
  return;
}
}
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
static int urb_zero_packet_chk(struct rtw_adapter *padapter , int sz ) 
{ 
  int blnSetTxDescOffset ;
  struct dvobj_priv *pdvobj ;

  {
#line 257
  pdvobj = padapter->dvobj;
#line 259
  if ((unsigned int )pdvobj->ishighspeed != 0U) {
#line 260
    if (((unsigned int )(sz + 32) & 511U) == 0U) {
#line 261
      blnSetTxDescOffset = 1;
    } else {
#line 263
      blnSetTxDescOffset = 0;
    }
  } else
#line 265
  if (((unsigned int )(sz + 32) & 63U) == 0U) {
#line 266
    blnSetTxDescOffset = 1;
  } else {
#line 268
    blnSetTxDescOffset = 0;
  }
#line 270
  return (blnSetTxDescOffset);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
static void rtl8192cu_cal_txdesc_chksum(struct tx_desc *ptxdesc ) 
{ 
  u16 *usPtr ;
  u32 count ;
  u32 index ;
  u16 checksum ;

  {
#line 275
  usPtr = (u16 *)ptxdesc;
#line 276
  count = 16U;
#line 278
  checksum = 0U;
#line 281
  ptxdesc->txdw7 = ptxdesc->txdw7 & 4294901760U;
#line 283
  index = 0U;
#line 283
  goto ldv_54281;
  ldv_54280: 
#line 284
  checksum = (u16 )((int )*(usPtr + (unsigned long )index) ^ (int )checksum);
#line 283
  index = index + 1U;
  ldv_54281: ;
#line 283
  if (index < count) {
#line 285
    goto ldv_54280;
  } else {

  }
#line 286
  ptxdesc->txdw7 = ptxdesc->txdw7 | (__le32 )checksum;
#line 287
  return;
}
}
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
static void fill_txdesc_sectype___0(struct pkt_attrib *pattrib , struct tx_desc *ptxdesc ) 
{ 


  {
#line 291
  if (pattrib->encrypt != 0U && (unsigned int )pattrib->bswenc == 0U) {
#line 292
    switch (pattrib->encrypt) {
    case 1027073U: ;
    case 1027077U: 
#line 296
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4194304U;
#line 297
    goto ldv_54289;
    case 1027074U: 
#line 300
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4194304U;
#line 301
    goto ldv_54289;
    case 1027076U: 
#line 303
    ptxdesc->txdw1 = ptxdesc->txdw1 | 12582912U;
#line 304
    goto ldv_54289;
    case 0U: ;
    default: ;
#line 307
    goto ldv_54289;
    }
    ldv_54289: ;
  } else {

  }
#line 311
  return;
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
static void fill_txdesc_vcs___0(struct pkt_attrib *pattrib , u32 *pdw ) 
{ 


  {
#line 316
  switch ((int )pattrib->vcs_mode) {
  case 1: 
#line 318
  *pdw = *pdw | 4096U;
#line 319
  goto ldv_54299;
  case 2: 
#line 321
  *pdw = *pdw | 2048U;
#line 322
  goto ldv_54299;
  case 0: ;
  default: ;
#line 325
  goto ldv_54299;
  }
  ldv_54299: ;
#line 328
  if ((unsigned int )pattrib->vcs_mode != 0U) {
#line 329
    *pdw = *pdw | 8192U;
#line 332
    if ((unsigned int )pattrib->ht_en != 0U) {
#line 333
      *pdw = *pdw | ((int )pattrib->bwmode & 1 ? 134217728U : 0U);
#line 335
      if ((unsigned int )pattrib->ch_offset == 1U) {
#line 336
        *pdw = *pdw | 268435456U;
      } else
#line 337
      if ((unsigned int )pattrib->ch_offset == 2U) {
#line 338
        *pdw = *pdw | 536870912U;
      } else
#line 339
      if ((unsigned int )pattrib->ch_offset == 0U) {
#line 340
        *pdw = *pdw;
      } else {
#line 342
        *pdw = *pdw | 805306368U;
      }
    } else {

    }
  } else {

  }
#line 345
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
static void fill_txdesc_phy___0(struct pkt_attrib *pattrib , u32 *pdw ) 
{ 


  {
#line 349
  if ((unsigned int )pattrib->ht_en != 0U) {
#line 350
    *pdw = *pdw | ((int )pattrib->bwmode & 1 ? 33554432U : 0U);
#line 352
    if ((unsigned int )pattrib->ch_offset == 1U) {
#line 353
      *pdw = *pdw | 1048576U;
    } else
#line 354
    if ((unsigned int )pattrib->ch_offset == 2U) {
#line 355
      *pdw = *pdw | 2097152U;
    } else
#line 356
    if ((unsigned int )pattrib->ch_offset == 0U) {
#line 357
      *pdw = *pdw;
    } else {
#line 359
      *pdw = *pdw | 3145728U;
    }
  } else {

  }
#line 361
  return;
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
static s32 update_txdesc(struct xmit_frame *pxmitframe , u8 *pmem , s32 sz , u8 bagg_pkt ) 
{ 
  int pull ;
  uint qsel ;
  struct rtw_adapter *padapter ;
  struct pkt_attrib *pattrib ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct tx_desc *ptxdesc ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  int bmcst ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;

  {
#line 365
  pull = 0;
#line 367
  padapter = pxmitframe->padapter;
#line 368
  pattrib = & pxmitframe->attrib;
#line 369
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 370
  pdmpriv = & pHalData->dmpriv;
#line 371
  ptxdesc = (struct tx_desc *)pmem;
#line 372
  pmlmeext = & padapter->mlmeextpriv;
#line 373
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 374
  tmp = is_multicast_ether_addr((u8 const   *)(& pattrib->ra));
#line 374
  bmcst = (int )tmp;
#line 376
  if ((unsigned int )bagg_pkt == 0U) {
#line 376
    tmp___0 = urb_zero_packet_chk(padapter, sz);
#line 376
    if (tmp___0 == 0) {
#line 377
      ptxdesc = (struct tx_desc *)pmem + 8U;
#line 378
      pull = 1;
#line 379
      pxmitframe->pkt_offset = (s8 )((int )pxmitframe->pkt_offset - 1);
    } else {

    }
  } else {

  }
#line 382
  memset((void *)ptxdesc, 0, 32UL);
#line 384
  if ((pxmitframe->frame_tag & 15) == 1) {
#line 386
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )pattrib->mac_id & 31U);
#line 388
    qsel = (unsigned int )pattrib->qsel & 31U;
#line 389
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((qsel << 8) & 7936U);
#line 391
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pattrib->raid << 16) & 983040U);
#line 393
    fill_txdesc_sectype___0(pattrib, ptxdesc);
#line 395
    if ((unsigned int )pattrib->ampdu_en != 0U) {
#line 396
      ptxdesc->txdw1 = ptxdesc->txdw1 | 32U;
    } else {
#line 398
      ptxdesc->txdw1 = ptxdesc->txdw1 | 64U;
    }
#line 403
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
#line 406
    if ((unsigned int )pattrib->qos_en != 0U) {
#line 407
      ptxdesc->txdw4 = ptxdesc->txdw4 | 64U;
    } else {

    }
#line 409
    if (((unsigned int )pattrib->ether_type != 34958U && (unsigned int )pattrib->ether_type != 2054U) && (unsigned int )pattrib->dhcp_pkt != 1U) {
#line 414
      fill_txdesc_vcs___0(pattrib, & ptxdesc->txdw4);
#line 415
      fill_txdesc_phy___0(pattrib, & ptxdesc->txdw4);
#line 417
      ptxdesc->txdw4 = ptxdesc->txdw4 | 8U;
#line 418
      ptxdesc->txdw5 = ptxdesc->txdw5 | 130816U;
#line 421
      ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )pdmpriv->INIDATA_RATE[(int )pattrib->mac_id];
    } else {
#line 427
      ptxdesc->txdw1 = ptxdesc->txdw1 | 64U;
#line 429
      ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
#line 431
      if ((unsigned int )pmlmeinfo->preamble_mode == 3U) {
#line 432
        ptxdesc->txdw4 = ptxdesc->txdw4 | 16777216U;
      } else {

      }
#line 434
      tmp___1 = MRateToHwRate23a((int )pmlmeext->tx_rate);
#line 434
      ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___1;
    }
  } else
#line 436
  if ((pxmitframe->frame_tag & 15) == 3) {
#line 438
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )pattrib->mac_id & 31U);
#line 440
    qsel = (unsigned int )pattrib->qsel & 31U;
#line 441
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((qsel << 8) & 7936U);
#line 443
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pattrib->raid << 16) & 983040U);
#line 447
    if ((unsigned int )pxmitframe->ack_report != 0U) {
#line 448
      ptxdesc->txdw2 = ptxdesc->txdw2 | 524288U;
    } else {

    }
#line 451
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
#line 454
    ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
#line 457
    ptxdesc->txdw5 = ptxdesc->txdw5 | 131072U;
#line 458
    ptxdesc->txdw5 = ptxdesc->txdw5 | 1572864U;
#line 460
    tmp___2 = MRateToHwRate23a((int )pmlmeext->tx_rate);
#line 460
    ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___2;
  } else
#line 461
  if ((pxmitframe->frame_tag & 15) == 8) {
#line 462
    if (GlobalDebugLevel23A > 3U) {
#line 462
      printk("\016RTL8723AU: pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
    } else {

    }
  } else {
#line 464
    if (GlobalDebugLevel23A > 3U) {
#line 464
      printk("\016RTL8723AU: pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
    } else {

    }
#line 467
    ptxdesc->txdw1 = ptxdesc->txdw1 | 4U;
#line 469
    ptxdesc->txdw1 = ptxdesc->txdw1 | 393216U;
#line 474
    ptxdesc->txdw3 = ptxdesc->txdw3 | (__le32 )((int )pattrib->seqnum << 16);
#line 477
    ptxdesc->txdw4 = ptxdesc->txdw4 | 256U;
#line 480
    tmp___3 = MRateToHwRate23a((int )pmlmeext->tx_rate);
#line 480
    ptxdesc->txdw5 = ptxdesc->txdw5 | (__le32 )tmp___3;
  }
#line 489
  if ((unsigned int )pattrib->qos_en == 0U) {
#line 491
    ptxdesc->txdw4 = ptxdesc->txdw4 | 128U;
#line 493
    ptxdesc->txdw3 = ptxdesc->txdw3 | 2147483648U;
  } else {

  }
#line 497
  ptxdesc->txdw0 = ptxdesc->txdw0 | ((__le32 )sz & 65535U);
#line 498
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2348810240U;
#line 499
  ptxdesc->txdw0 = ptxdesc->txdw0 | 2097152U;
#line 501
  if (bmcst != 0) {
#line 502
    ptxdesc->txdw0 = ptxdesc->txdw0 | 16777216U;
  } else {

  }
#line 504
  if (GlobalDebugLevel23A > 6U) {
#line 504
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 504
    printk("\016offset0-txdesc = 0x%x\n", ptxdesc->txdw0);
  } else {

  }
#line 508
  if ((int )pxmitframe->pkt_offset > 0) {
#line 509
    ptxdesc->txdw1 = ptxdesc->txdw1 | ((__le32 )((int )pxmitframe->pkt_offset << 26) & 2080374784U);
  } else {

  }
#line 511
  rtl8192cu_cal_txdesc_chksum(ptxdesc);
#line 512
  return (pull);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
static int rtw_dump_xframe(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int ret ;
  int inner_ret ;
  int t ;
  int sz ;
  int w_sz ;
  int pull ;
  u8 *mem_addr ;
  u32 ff_hwaddr ;
  struct xmit_buf *pxmitbuf ;
  struct pkt_attrib *pattrib ;
  struct xmit_priv *pxmitpriv ;

  {
#line 518
  ret = 1;
#line 519
  inner_ret = 1;
#line 520
  pull = 0;
#line 523
  pxmitbuf = pxmitframe->pxmitbuf;
#line 524
  pattrib = & pxmitframe->attrib;
#line 525
  pxmitpriv = & padapter->xmitpriv;
#line 527
  if (((pxmitframe->frame_tag == 1 && (unsigned int )pxmitframe->attrib.ether_type != 2054U) && (unsigned int )pxmitframe->attrib.ether_type != 34958U) && (unsigned int )pxmitframe->attrib.dhcp_pkt != 1U) {
#line 531
    rtw_issue_addbareq_cmd23a(padapter, pxmitframe);
  } else {

  }
#line 533
  mem_addr = pxmitframe->buf_addr;
#line 535
  if (GlobalDebugLevel23A > 6U) {
#line 535
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 535
    printk("\016rtw_dump_xframe()\n");
  } else {

  }
#line 537
  t = 0;
#line 537
  goto ldv_54339;
  ldv_54338: ;
#line 538
  if (inner_ret != 1 && ret == 1) {
#line 539
    ret = 0;
  } else {

  }
#line 541
  if ((int )pattrib->nr_frags + -1 != t) {
#line 542
    if (GlobalDebugLevel23A > 3U) {
#line 542
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 4);
#line 542
      printk("\016pattrib->nr_frags =%d\n", (int )pattrib->nr_frags);
    } else {

    }
#line 545
    sz = (int )pxmitpriv->frag_len;
#line 546
    sz = (sz + -4) - (int )pattrib->icv_len;
  } else {
#line 549
    sz = (int )pattrib->last_txcmdsz;
  }
#line 552
  pull = update_txdesc(pxmitframe, mem_addr, sz, 0);
#line 554
  if (pull != 0) {
#line 555
    mem_addr = mem_addr + 8UL;
#line 557
    pxmitframe->buf_addr = mem_addr;
#line 559
    w_sz = sz + 32;
  } else {
#line 561
    w_sz = sz + 40;
  }
#line 564
  ff_hwaddr = rtw_get_ff_hwaddr23a(pxmitframe);
#line 565
  inner_ret = rtl8723au_write_port(padapter, ff_hwaddr, (u32 )w_sz, pxmitbuf);
#line 567
  rtw_count_tx_stats23a(padapter, pxmitframe, sz);
#line 569
  if (GlobalDebugLevel23A > 6U) {
#line 569
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 569
    printk("\016rtw_write_port, w_sz =%d\n", w_sz);
  } else {

  }
#line 572
  mem_addr = mem_addr + (unsigned long )w_sz;
#line 574
  mem_addr = (u8 *)(((unsigned long )mem_addr + 3UL) & 0xfffffffffffffffcUL);
#line 537
  t = t + 1;
  ldv_54339: ;
#line 537
  if ((int )pattrib->nr_frags > t) {
#line 539
    goto ldv_54338;
  } else {

  }
#line 577
  rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 579
  if (ret != 1) {
#line 580
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 1);
  } else {

  }
#line 582
  return (ret);
}
}
#line 585 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
bool rtl8723au_xmitframe_complete(struct rtw_adapter *padapter , struct xmit_priv *pxmitpriv ,
                                  struct xmit_buf *pxmitbuf ) 
{ 
  struct hw_xmit *phwxmits ;
  struct xmit_frame *pxmitframe ;
  int hwentry ;
  int res ;
  int xcnt ;

  {
#line 592
  res = 1;
#line 592
  xcnt = 0;
#line 594
  phwxmits = pxmitpriv->hwxmits;
#line 595
  hwentry = (int )pxmitpriv->hwxmit_entry;
#line 597
  if (GlobalDebugLevel23A > 6U) {
#line 597
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 597
    printk("\016xmitframe_complete()\n");
  } else {

  }
#line 599
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 600
    pxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);
#line 601
    if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 602
      return (0);
    } else {

    }
  } else {

  }
#line 604
  pxmitframe = rtw_dequeue_xframe23a(pxmitpriv, phwxmits, hwentry);
#line 606
  if ((unsigned long )pxmitframe != (unsigned long )((struct xmit_frame *)0)) {
#line 607
    pxmitframe->pxmitbuf = pxmitbuf;
#line 609
    pxmitframe->buf_addr = pxmitbuf->pbuf;
#line 611
    pxmitbuf->priv_data = (void *)pxmitframe;
#line 613
    if ((pxmitframe->frame_tag & 15) == 1) {
#line 614
      if ((unsigned int )pxmitframe->attrib.priority <= 15U) {
#line 615
        res = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);
      } else {

      }
#line 617
      rtw_os_xmit_complete23a(padapter, pxmitframe);
    } else {

    }
#line 620
    if (GlobalDebugLevel23A > 6U) {
#line 620
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1U, 7);
#line 620
      printk("\016xmitframe_complete(): rtw_dump_xframe\n");
    } else {

    }
#line 622
    if (res == 1) {
#line 623
      rtw_dump_xframe(padapter, pxmitframe);
    } else {
#line 625
      rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
#line 626
      rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
    }
#line 628
    xcnt = xcnt + 1;
  } else {
#line 630
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
#line 631
    return (0);
  }
#line 633
  return (1);
}
}
#line 636 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
static int xmitframe_direct(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int res ;

  {
#line 641
  res = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);
#line 642
  if (res == 1) {
#line 643
    rtw_dump_xframe(padapter, pxmitframe);
  } else {

  }
#line 644
  return (res);
}
}
#line 652 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
bool rtl8723au_hal_xmit(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  int res ;
  struct xmit_buf *pxmitbuf ;
  struct xmit_priv *pxmitpriv ;
  struct pkt_attrib *pattrib ;
  struct mlme_priv *pmlmepriv ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  int tmp ;
  s32 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 656
  pxmitbuf = (struct xmit_buf *)0;
#line 657
  pxmitpriv = & padapter->xmitpriv;
#line 658
  pattrib = & pxmitframe->attrib;
#line 659
  pmlmepriv = & padapter->mlmepriv;
#line 661
  do_queue_select___0(padapter, pattrib);
#line 662
  spin_lock_bh(& pxmitpriv->lock);
#line 665
  tmp = xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe);
#line 665
  if (tmp != 0) {
#line 667
    pstapriv = & padapter->stapriv;
#line 669
    spin_unlock_bh(& pxmitpriv->lock);
#line 671
    if ((unsigned long )pattrib->psta != (unsigned long )((struct sta_info *)0)) {
#line 672
      psta = pattrib->psta;
    } else {
#line 674
      psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->ra));
    }
#line 676
    if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 677
      if (psta->sleepq_len > 32U) {
#line 678
        wakeup_sta_to_xmit23a(padapter, psta);
      } else {

      }
    } else {

    }
#line 681
    return (0);
  } else {

  }
#line 685
  tmp___0 = rtw_txframes_sta_ac_pending23a(padapter, pattrib);
#line 685
  if (tmp___0 > 0) {
#line 686
    goto enqueue;
  } else {

  }
#line 688
  tmp___1 = check_fwstate(pmlmepriv, 2176);
#line 688
  if ((int )tmp___1) {
#line 689
    goto enqueue;
  } else {

  }
#line 691
  pxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);
#line 692
  if ((unsigned long )pxmitbuf == (unsigned long )((struct xmit_buf *)0)) {
#line 693
    goto enqueue;
  } else {

  }
#line 695
  spin_unlock_bh(& pxmitpriv->lock);
#line 697
  pxmitframe->pxmitbuf = pxmitbuf;
#line 698
  pxmitframe->buf_addr = pxmitbuf->pbuf;
#line 699
  pxmitbuf->priv_data = (void *)pxmitframe;
#line 701
  tmp___2 = xmitframe_direct(padapter, pxmitframe);
#line 701
  if (tmp___2 != 1) {
#line 702
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
#line 703
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
  } else {

  }
#line 705
  return (1);
  enqueue: 
#line 708
  res = rtw_xmitframe_enqueue23a(padapter, pxmitframe);
#line 709
  spin_unlock_bh(& pxmitpriv->lock);
#line 711
  if (res != 1) {
#line 712
    if (GlobalDebugLevel23A > 3U) {
#line 712
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 4);
#line 712
      printk("\016pre_xmitframe: enqueue xmitframe fail\n");
    } else {

    }
#line 714
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 717
    pxmitpriv->tx_pkts = pxmitpriv->tx_pkts - 1ULL;
#line 718
    pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
#line 719
    return (1);
  } else {

  }
#line 721
  return (0);
}
}
#line 724 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
int rtl8723au_mgnt_xmit(struct rtw_adapter *padapter , struct xmit_frame *pmgntframe ) 
{ 
  int tmp ;

  {
#line 727
  tmp = rtw_dump_xframe(padapter, pmgntframe);
#line 727
  return (tmp);
}
}
#line 730 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
int rtl8723au_hal_xmitframe_enqueue(struct rtw_adapter *padapter , struct xmit_frame *pxmitframe ) 
{ 
  struct xmit_priv *pxmitpriv ;
  int err ;

  {
#line 733
  pxmitpriv = & padapter->xmitpriv;
#line 736
  err = rtw_xmitframe_enqueue23a(padapter, pxmitframe);
#line 737
  if (err != 1) {
#line 738
    rtw_free_xmitframe23a(pxmitpriv, pxmitframe);
#line 741
    pxmitpriv->tx_pkts = pxmitpriv->tx_pkts - 1ULL;
#line 742
    pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
  } else {
#line 744
    tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  }
#line 746
  return (err);
}
}
#line 876 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
void *ldv_kmem_cache_alloc_1928(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 879
  ldv_check_alloc_flags(flags);
#line 881
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 882
  return ((void *)0);
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
int ldv_pskb_expand_head_1934(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 923
  ldv_check_alloc_flags(flags);
#line 925
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 925
  return (tmp);
}
}
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
struct sk_buff *ldv_skb_clone_1936(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 939
  ldv_check_alloc_flags(flags);
#line 941
  tmp = skb_clone(ldv_func_arg1, flags);
#line 941
  return (tmp);
}
}
#line 952 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
struct sk_buff *ldv_skb_copy_1938(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 955
  ldv_check_alloc_flags(flags);
#line 957
  tmp = skb_copy(ldv_func_arg1, flags);
#line 957
  return (tmp);
}
}
#line 960 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1939(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 963
  ldv_check_alloc_flags(flags);
#line 965
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 965
  return (tmp);
}
}
#line 968 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1940(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 971
  ldv_check_alloc_flags(flags);
#line 973
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 973
  return (tmp);
}
}
#line 976 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1941(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 979
  ldv_check_alloc_flags(flags);
#line 981
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 981
  return (tmp);
}
}
#line 984 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
int ldv_pskb_expand_head_1942(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 987
  ldv_check_alloc_flags(flags);
#line 989
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 989
  return (tmp);
}
}
#line 992 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
int ldv_pskb_expand_head_1943(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 995
  ldv_check_alloc_flags(flags);
#line 997
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 997
  return (tmp);
}
}
#line 1000 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723au_xmit.o.c.prepared"
struct sk_buff *ldv_skb_clone_1944(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1003
  ldv_check_alloc_flags(flags);
#line 1005
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1005
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_1970(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_1978(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_1986(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_1980(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_1976(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_1984(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_1985(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_1981(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_1982(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_1983(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 106 "drivers/staging/rtl8723au/include/hal_intf.h"
int rtw_hal_init23a(struct rtw_adapter *padapter ) ;
#line 107
int rtw_hal_deinit23a(struct rtw_adapter *padapter ) ;
#line 44 "drivers/staging/rtl8723au/include/osdep_intf.h"
int rtl8723au_inirp_init(struct rtw_adapter *Adapter ) ;
#line 45
int rtl8723au_inirp_deinit(struct rtw_adapter *Adapter ) ;
#line 34 "drivers/staging/rtl8723au/include/rtl8723a_bt_intf.h"
void rtl8723a_dual_antenna_detection(struct rtw_adapter *padapter ) ;
#line 35
void rtl8723a_BT_init_hwconfig(struct rtw_adapter *padapter ) ;
#line 34 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
void BT_HaltProcess(struct rtw_adapter *padapter ) ;
#line 542 "drivers/staging/rtl8723au/include/rtl8723a_hal.h"
void rtl8723a_read_adapter_info(struct rtw_adapter *Adapter ) ;
#line 24 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
int rtl8723au_read_port(struct rtw_adapter *adapter , u32 addr , u32 cnt , struct recv_buf *precvbuf ) ;
#line 26
void rtl8723au_read_port_cancel(struct rtw_adapter *padapter ) ;
#line 30
int rtl8723au_read_interrupt(struct rtw_adapter *adapter , u32 addr ) ;
#line 66 "drivers/staging/rtl8723au/include/usb_ops.h"
void rtl8723au_chip_configure(struct rtw_adapter *padapter ) ;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _ConfigChipOutEP(struct rtw_adapter *pAdapter , u8 NumOutPipe ) 
{ 
  u8 value8 ;
  struct hal_data_8723a *pHalData ;

  {
#line 251
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 253
  pHalData->OutEpQueueSel = 0U;
#line 254
  pHalData->OutEpNumber = 0U;
#line 257
  value8 = rtl8723au_read8(pAdapter, 65126U);
#line 259
  if (((int )value8 & 15) != 0) {
#line 260
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 1U);
#line 261
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {

  }
#line 264
  if ((((int )value8 >> 4) & 15) != 0) {
#line 265
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 4U);
#line 266
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {

  }
#line 270
  value8 = rtl8723au_read8(pAdapter, 65127U);
#line 271
  if (((int )value8 & 15) != 0) {
#line 272
    pHalData->OutEpQueueSel = (u8 )((unsigned int )pHalData->OutEpQueueSel | 2U);
#line 273
    pHalData->OutEpNumber = (u8 )((int )pHalData->OutEpNumber + 1);
  } else {

  }
#line 275
  return;
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static bool rtl8723au_set_queue_pipe_mapping(struct rtw_adapter *pAdapter , u8 NumInPipe ,
                                             u8 NumOutPipe ) 
{ 
  struct hal_data_8723a *pHalData ;
  bool result ;

  {
#line 285
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 286
  result = 0;
#line 288
  _ConfigChipOutEP(pAdapter, (int )NumOutPipe);
#line 291
  if ((unsigned int )pHalData->OutEpNumber == 1U) {
#line 292
    if ((unsigned int )NumInPipe != 1U) {
#line 293
      return (result);
    } else {

    }
  } else {

  }
#line 296
  result = Hal_MappingOutPipe23a(pAdapter, (int )NumOutPipe);
#line 298
  return (result);
}
}
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
void rtl8723au_chip_configure(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dvobj_priv *pdvobjpriv ;

  {
#line 303
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 304
  pdvobjpriv = padapter->dvobj;
#line 306
  pHalData->interfaceIndex = (u32 )pdvobjpriv->InterfaceNumber;
#line 308
  rtl8723au_set_queue_pipe_mapping(padapter, (int )pdvobjpriv->RtNumInPipes, (int )pdvobjpriv->RtNumOutPipes);
#line 311
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static int _InitPowerOn(struct rtw_adapter *padapter ) 
{ 
  int status ;
  u16 value16 ;
  u8 value8 ;
  u8 tmp ;

  {
#line 315
  status = 1;
#line 316
  value16 = 0U;
#line 317
  value8 = 0U;
#line 321
  rtl8723au_write8(padapter, 28U, 0);
#line 324
  tmp = HalPwrSeqCmdParsing23a(padapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_card_enable_flow));
#line 324
  if ((unsigned int )tmp == 0U) {
#line 326
    return (0);
  } else {

  }
#line 329
  value8 = rtl8723au_read8(padapter, 6U);
#line 330
  rtl8723au_write8(padapter, 6U, (int )((unsigned int )value8 | 8U));
#line 335
  value16 = rtl8723au_read16(padapter, 256U);
#line 336
  value16 = (u16 )((unsigned int )value16 | 1791U);
#line 339
  rtl8723au_write16(padapter, 256U, (int )value16);
#line 342
  PHY_SetBBReg(padapter, 48U, 1879048192U, 6U);
#line 344
  return (status);
}
}
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitInterrupt(struct rtw_adapter *Adapter ) 
{ 
  u32 value32 ;

  {
#line 353
  value32 = 4294967295U;
#line 354
  rtl8723au_write32(Adapter, 292U, value32);
#line 357
  rtl8723au_write32(Adapter, 288U, value32);
#line 358
  return;
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitQueueReservedPage(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct registry_priv *pregistrypriv ;
  u32 numHQ ;
  u32 numLQ ;
  u32 numNQ ;
  u32 numPubQ ;
  u32 value32 ;
  u8 value8 ;
  bool bWiFiConfig ;

  {
#line 362
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 363
  pregistrypriv = & Adapter->registrypriv;
#line 364
  numHQ = 0U;
#line 365
  numLQ = 0U;
#line 366
  numNQ = 0U;
#line 370
  bWiFiConfig = (unsigned int )pregistrypriv->wifi_spec != 0U;
#line 375
  numPubQ = (int )bWiFiConfig ? 176U : 231U;
#line 377
  if ((int )pHalData->OutEpQueueSel & 1) {
#line 378
    numHQ = (int )bWiFiConfig ? 41U : 12U;
  } else {

  }
#line 382
  if (((unsigned long )pHalData->OutEpQueueSel & 2UL) != 0UL) {
#line 383
    numLQ = (int )bWiFiConfig ? 28U : 2U;
  } else {

  }
#line 388
  if (((unsigned long )pHalData->OutEpQueueSel & 4UL) != 0UL) {
#line 389
    numNQ = (int )bWiFiConfig ? 28U : 2U;
  } else {

  }
#line 392
  value8 = (unsigned char )numNQ;
#line 393
  rtl8723au_write8(Adapter, 532U, (int )value8);
#line 396
  value32 = (((numHQ & 255U) | ((numLQ << 8) & 65535U)) | ((numPubQ & 255U) << 16)) | 2147483648U;
#line 397
  rtl8723au_write32(Adapter, 512U, value32);
#line 398
  return;
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitTxBufferBoundary(struct rtw_adapter *Adapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  u8 txpktbuf_bndy ;

  {
#line 402
  pregistrypriv = & Adapter->registrypriv;
#line 406
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
#line 407
    txpktbuf_bndy = 249U;
  } else {
#line 409
    txpktbuf_bndy = 246U;
  }
#line 411
  rtl8723au_write8(Adapter, 1060U, (int )txpktbuf_bndy);
#line 412
  rtl8723au_write8(Adapter, 1061U, (int )txpktbuf_bndy);
#line 413
  rtl8723au_write8(Adapter, 1117U, (int )txpktbuf_bndy);
#line 414
  rtl8723au_write8(Adapter, 276U, (int )txpktbuf_bndy);
#line 415
  rtl8723au_write8(Adapter, 521U, (int )txpktbuf_bndy);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitPageBoundary(struct rtw_adapter *Adapter ) 
{ 
  u16 rxff_bndy ;

  {
#line 422
  rxff_bndy = 10239U;
#line 424
  rtl8723au_write16(Adapter, 278U, (int )rxff_bndy);
#line 425
  return;
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitNormalChipRegPriority(struct rtw_adapter *Adapter , u16 beQ , u16 bkQ ,
                                       u16 viQ , u16 voQ , u16 mgtQ , u16 hiQ ) 
{ 
  u16 value16 ;
  u16 tmp ;

  {
#line 433
  tmp = rtl8723au_read16(Adapter, 268U);
#line 433
  value16 = (unsigned int )tmp & 7U;
#line 435
  value16 = (u16 )(((((((int )((short )(((int )beQ & 3) << 8)) | (int )((short )(((int )bkQ & 3) << 10))) | ((int )((short )((int )viQ << 6)) & 255)) | (int )((short )(((int )voQ & 3) << 4))) | (int )((short )(((int )mgtQ & 3) << 12))) | (int )((short )((int )hiQ << 14))) | (int )((short )value16));
#line 439
  rtl8723au_write16(Adapter, 268U, (int )value16);
#line 440
  return;
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitNormalChipOneOutEpPriority(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u16 value ;

  {
#line 444
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 445
  value = 0U;
#line 447
  switch ((int )pHalData->OutEpQueueSel) {
  case 1: 
#line 449
  value = 3U;
#line 450
  goto ldv_54364;
  case 2: 
#line 452
  value = 1U;
#line 453
  goto ldv_54364;
  case 4: 
#line 455
  value = 2U;
#line 456
  goto ldv_54364;
  default: ;
#line 459
  goto ldv_54364;
  }
  ldv_54364: 
#line 462
  _InitNormalChipRegPriority(Adapter, (int )value, (int )value, (int )value, (int )value,
                             (int )value, (int )value);
#line 463
  return;
}
}
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitNormalChipTwoOutEpPriority(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct registry_priv *pregistrypriv ;
  u16 beQ ;
  u16 bkQ ;
  u16 viQ ;
  u16 voQ ;
  u16 mgtQ ;
  u16 hiQ ;
  u16 valueHi ;
  u16 valueLow ;

  {
#line 468
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 469
  pregistrypriv = & Adapter->registrypriv;
#line 471
  valueHi = 0U;
#line 472
  valueLow = 0U;
#line 474
  switch ((int )pHalData->OutEpQueueSel) {
  case 3: 
#line 476
  valueHi = 3U;
#line 477
  valueLow = 1U;
#line 478
  goto ldv_54382;
  case 6: 
#line 480
  valueHi = 2U;
#line 481
  valueLow = 1U;
#line 482
  goto ldv_54382;
  case 5: 
#line 484
  valueHi = 3U;
#line 485
  valueLow = 2U;
#line 486
  goto ldv_54382;
  default: ;
#line 489
  goto ldv_54382;
  }
  ldv_54382: ;
#line 492
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
#line 493
    beQ = valueLow;
#line 494
    bkQ = valueLow;
#line 495
    viQ = valueHi;
#line 496
    voQ = valueHi;
#line 497
    mgtQ = valueHi;
#line 498
    hiQ = valueHi;
  } else {
#line 500
    beQ = valueLow;
#line 501
    bkQ = valueHi;
#line 502
    viQ = valueHi;
#line 503
    voQ = valueLow;
#line 504
    mgtQ = valueHi;
#line 505
    hiQ = valueHi;
  }
#line 508
  _InitNormalChipRegPriority(Adapter, (int )beQ, (int )bkQ, (int )viQ, (int )voQ,
                             (int )mgtQ, (int )hiQ);
#line 509
  return;
}
}
#line 511 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitNormalChipThreeOutEpPriority(struct rtw_adapter *Adapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  u16 beQ ;
  u16 bkQ ;
  u16 viQ ;
  u16 voQ ;
  u16 mgtQ ;
  u16 hiQ ;

  {
#line 513
  pregistrypriv = & Adapter->registrypriv;
#line 516
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
#line 517
    beQ = 1U;
#line 518
    bkQ = 1U;
#line 519
    viQ = 2U;
#line 520
    voQ = 3U;
#line 521
    mgtQ = 3U;
#line 522
    hiQ = 3U;
  } else {
#line 524
    beQ = 1U;
#line 525
    bkQ = 2U;
#line 526
    viQ = 2U;
#line 527
    voQ = 3U;
#line 528
    mgtQ = 3U;
#line 529
    hiQ = 3U;
  }
#line 531
  _InitNormalChipRegPriority(Adapter, (int )beQ, (int )bkQ, (int )viQ, (int )voQ,
                             (int )mgtQ, (int )hiQ);
#line 532
  return;
}
}
#line 534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitNormalChipQueuePriority(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 536
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 538
  switch ((int )pHalData->OutEpNumber) {
  case 1: 
#line 540
  _InitNormalChipOneOutEpPriority(Adapter);
#line 541
  goto ldv_54401;
  case 2: 
#line 543
  _InitNormalChipTwoOutEpPriority(Adapter);
#line 544
  goto ldv_54401;
  case 3: 
#line 546
  _InitNormalChipThreeOutEpPriority(Adapter);
#line 547
  goto ldv_54401;
  default: ;
#line 550
  goto ldv_54401;
  }
  ldv_54401: ;
#line 553
  return;
}
}
#line 554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitQueuePriority(struct rtw_adapter *Adapter ) 
{ 


  {
#line 556
  _InitNormalChipQueuePriority(Adapter);
#line 557
  return;
}
}
#line 559 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitNetworkType(struct rtw_adapter *Adapter ) 
{ 
  u32 value32 ;

  {
#line 563
  value32 = rtl8723au_read32(Adapter, 256U);
#line 566
  value32 = (value32 & 4294770687U) | 131072U;
#line 567
  rtl8723au_write32(Adapter, 256U, value32);
#line 568
  return;
}
}
#line 570 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitTransferPageSize(struct rtw_adapter *Adapter ) 
{ 
  u8 value8 ;

  {
#line 575
  value8 = 17U;
#line 576
  rtl8723au_write8(Adapter, 260U, (int )value8);
#line 577
  return;
}
}
#line 579 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitDriverInfoSize(struct rtw_adapter *Adapter , u8 drvInfoSize ) 
{ 


  {
#line 581
  rtl8723au_write8(Adapter, 1551U, (int )drvInfoSize);
#line 582
  return;
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitWMACSetting(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 586
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 589
  pHalData->ReceiveConfig = 1879072974U;
#line 596
  rtl8723au_write32(Adapter, 1544U, pHalData->ReceiveConfig);
#line 599
  rtl8723au_write32(Adapter, 1568U, 4294967295U);
#line 600
  rtl8723au_write32(Adapter, 1572U, 4294967295U);
#line 601
  return;
}
}
#line 623 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitAdaptiveCtrl(struct rtw_adapter *Adapter ) 
{ 
  u16 value16 ;
  u32 value32 ;

  {
#line 629
  value32 = rtl8723au_read32(Adapter, 1088U);
#line 630
  value32 = value32 & 4293918720U;
#line 631
  value32 = value32 | 1048561U;
#line 632
  rtl8723au_write32(Adapter, 1088U, value32);
#line 638
  value16 = 4112U;
#line 639
  rtl8723au_write16(Adapter, 1064U, (int )value16);
#line 642
  value16 = 12336U;
#line 643
  rtl8723au_write16(Adapter, 1066U, (int )value16);
#line 644
  return;
}
}
#line 646 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitRateFallback(struct rtw_adapter *Adapter ) 
{ 


  {
#line 649
  rtl8723au_write32(Adapter, 1072U, 0U);
#line 650
  rtl8723au_write32(Adapter, 1076U, 268960772U);
#line 651
  rtl8723au_write32(Adapter, 1080U, 67305985U);
#line 652
  rtl8723au_write32(Adapter, 1084U, 134678021U);
#line 653
  return;
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitEDCA(struct rtw_adapter *Adapter ) 
{ 


  {
#line 658
  rtl8723au_write16(Adapter, 1064U, 4106);
#line 659
  rtl8723au_write16(Adapter, 1594U, 4106);
#line 662
  rtl8723au_write16(Adapter, 1300U, 4106);
#line 665
  rtl8723au_write16(Adapter, 1302U, 4106);
#line 668
  rtl8723au_write32(Adapter, 1288U, 6202411U);
#line 669
  rtl8723au_write32(Adapter, 1292U, 42063U);
#line 670
  rtl8723au_write32(Adapter, 1284U, 6202148U);
#line 671
  rtl8723au_write32(Adapter, 1280U, 3121702U);
#line 672
  return;
}
}
#line 674 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitHWLed(struct rtw_adapter *Adapter ) 
{ 
  struct led_priv *pledpriv ;

  {
#line 676
  pledpriv = & Adapter->ledpriv;
#line 678
  if ((unsigned int )pledpriv->LedStrategy != 50U) {
#line 679
    return;
  } else {

  }
#line 680
  return;
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitRDGSetting(struct rtw_adapter *Adapter ) 
{ 


  {
#line 688
  rtl8723au_write8(Adapter, 1316U, 255);
#line 689
  rtl8723au_write16(Adapter, 1348U, 512);
#line 690
  rtl8723au_write8(Adapter, 1123U, 5);
#line 691
  return;
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitRetryFunction(struct rtw_adapter *Adapter ) 
{ 
  u8 value8 ;

  {
#line 697
  value8 = rtl8723au_read8(Adapter, 1056U);
#line 698
  value8 = (u8 )((unsigned int )value8 | 128U);
#line 699
  rtl8723au_write8(Adapter, 1056U, (int )value8);
#line 702
  rtl8723au_write8(Adapter, 1600U, 64);
#line 703
  return;
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void usb_AggSettingTxUpdate(struct rtw_adapter *Adapter ) 
{ 


  {
#line 722
  return;
}
}
#line 739 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void usb_AggSettingRxUpdate(struct rtw_adapter *Adapter ) 
{ 


  {
#line 741
  return;
}
}
#line 743 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void InitUsbAggregationSetting(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 745
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 748
  usb_AggSettingTxUpdate(Adapter);
#line 751
  usb_AggSettingRxUpdate(Adapter);
#line 754
  pHalData->UsbRxHighSpeedMode = 0;
#line 755
  return;
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitOperationMode(struct rtw_adapter *Adapter ) 
{ 


  {
#line 759
  return;
}
}
#line 761 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _InitRFType(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  bool is92CU ;

  {
#line 763
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 764
  is92CU = (bool )(((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && (unsigned int )pHalData->VersionID.RFType == 2U);
#line 766
  pHalData->rf_chip = 4U;
#line 768
  if (! is92CU) {
#line 769
    pHalData->rf_type = 3U;
#line 770
    if (GlobalDebugLevel23A > 3U) {
#line 770
      printk("\016RTL8723AU: Set RF Chip ID to RF_6052 and RF type to 1T1R.\n");
    } else {

    }
#line 771
    return;
  } else {

  }
#line 778
  if (GlobalDebugLevel23A > 3U) {
#line 778
    printk("\016RTL8723AU: Set RF Chip ID to RF_6052 and RF type to %d.\n", (int )pHalData->rf_type);
  } else {

  }
#line 779
  return;
}
}
#line 783 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _BBTurnOnBlock(struct rtw_adapter *Adapter ) 
{ 


  {
#line 785
  PHY_SetBBReg(Adapter, 2048U, 16777216U, 1U);
#line 786
  PHY_SetBBReg(Adapter, 2048U, 33554432U, 1U);
#line 787
  return;
}
}
#line 790 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _RfPowerSave(struct rtw_adapter *padapter ) 
{ 


  {
#line 792
  return;
}
}
#line 799 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
enum rt_rf_power_state RfOnOffDetect23a(struct rtw_adapter *pAdapter ) 
{ 
  u8 val8 ;
  enum rt_rf_power_state rfpowerstate ;
  u8 tmp ;

  {
#line 803
  rfpowerstate = 2;
#line 805
  if ((unsigned int )pAdapter->pwrctrlpriv.bHWPowerdown != 0U) {
#line 806
    val8 = rtl8723au_read8(pAdapter, 92U);
#line 807
    if (GlobalDebugLevel23A > 3U) {
#line 807
      printk("\016RTL8723AU: pwrdown, 0x5c(BIT7) =%02x\n", (int )val8);
    } else {

    }
#line 808
    rfpowerstate = (int )((signed char )val8) < 0 ? 2 : 0;
  } else {
#line 810
    tmp = rtl8723au_read8(pAdapter, 67U);
#line 810
    rtl8723au_write8(pAdapter, 67U, (int )tmp & 247);
#line 813
    val8 = rtl8723au_read8(pAdapter, 66U);
#line 814
    if (GlobalDebugLevel23A > 3U) {
#line 814
      printk("\016RTL8723AU: GPIO_IN =%02x\n", (int )val8);
    } else {

    }
#line 815
    rfpowerstate = ((unsigned long )val8 & 8UL) != 0UL ? 0 : 2;
  }
#line 817
  return (rfpowerstate);
}
}
#line 820
void _ps_open_RF23a(struct rtw_adapter *padapter ) ;
#line 822 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static int rtl8723au_hal_init(struct rtw_adapter *Adapter ) 
{ 
  u8 val8 ;
  u32 boundary ;
  int status ;
  struct hal_data_8723a *pHalData ;
  struct pwrctrl_priv *pwrctrlpriv ;
  struct registry_priv *pregistrypriv ;
  unsigned long init_start_time ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 824
  val8 = 0U;
#line 826
  status = 1;
#line 827
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 828
  pwrctrlpriv = & Adapter->pwrctrlpriv;
#line 829
  pregistrypriv = & Adapter->registrypriv;
#line 831
  init_start_time = jiffies;
#line 833
  if ((unsigned int )Adapter->pwrctrlpriv.bkeepfwalive != 0U) {
#line 834
    _ps_open_RF23a(Adapter);
#line 836
    if ((unsigned int )pHalData->bIQKInitialized != 0U) {
#line 837
      rtl8723a_phy_iq_calibrate(Adapter, 1);
    } else {
#line 839
      rtl8723a_phy_iq_calibrate(Adapter, 0);
#line 840
      pHalData->bIQKInitialized = 1U;
    }
#line 842
    rtl8723a_odm_check_tx_power_tracking(Adapter);
#line 843
    rtl8723a_phy_lc_calibrate(Adapter);
#line 845
    goto exit;
  } else {

  }
#line 849
  val8 = rtl8723au_read8(Adapter, 256U);
#line 850
  if (GlobalDebugLevel23A > 6U) {
#line 850
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 850
    printk("\016%s: REG_CR 0x100 = 0x%02x\n", "rtl8723au_hal_init", (int )val8);
  } else {

  }
#line 856
  if ((unsigned int )val8 == 234U) {
#line 857
    pHalData->bMACFuncEnable = 0;
  } else {
#line 859
    pHalData->bMACFuncEnable = 1;
#line 860
    if (GlobalDebugLevel23A > 6U) {
#line 860
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 860
      printk("\016%s: MAC has already power on\n", "rtl8723au_hal_init");
    } else {

    }
  }
#line 864
  status = _InitPowerOn(Adapter);
#line 865
  if (status == 0) {
#line 866
    if (GlobalDebugLevel23A > 3U) {
#line 866
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
#line 866
      printk("\016Failed to init power on!\n");
    } else {

    }
#line 868
    goto exit;
  } else {

  }
#line 871
  if ((unsigned int )pregistrypriv->wifi_spec == 0U) {
#line 872
    boundary = 249U;
  } else {
#line 875
    boundary = 246U;
  }
#line 878
  if (! pHalData->bMACFuncEnable) {
#line 879
    status = InitLLTTable23a(Adapter, boundary);
#line 880
    if (status == 0) {
#line 881
      if (GlobalDebugLevel23A > 3U) {
#line 881
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
#line 881
        printk("\016Failed to init LLT table\n");
      } else {

      }
#line 883
      goto exit;
    } else {

    }
  } else {

  }
#line 887
  if ((int )pHalData->bRDGEnable) {
#line 888
    _InitRDGSetting(Adapter);
  } else {

  }
#line 890
  status = rtl8723a_FirmwareDownload(Adapter);
#line 891
  if (status != 1) {
#line 892
    Adapter->bFWReady = 0U;
#line 893
    pHalData->fw_ractrl = 0U;
#line 894
    if (GlobalDebugLevel23A > 3U) {
#line 894
      printk("\016RTL8723AU: fw download fail!\n");
    } else {

    }
#line 895
    goto exit;
  } else {
#line 897
    Adapter->bFWReady = 1U;
#line 898
    pHalData->fw_ractrl = 1U;
#line 899
    if (GlobalDebugLevel23A > 3U) {
#line 899
      printk("\016RTL8723AU: fw download ok!\n");
    } else {

    }
  }
#line 902
  rtl8723a_InitializeFirmwareVars(Adapter);
#line 904
  if ((unsigned int )pwrctrlpriv->reg_rfoff == 1U) {
#line 905
    pwrctrlpriv->rf_pwrstate = 2;
  } else {

  }
#line 915
  _InitRFType(Adapter);
#line 919
  pHalData->CurrentChannel = 6U;
#line 921
  status = PHY_MACConfig8723A(Adapter);
#line 922
  if (status == 0) {
#line 923
    if (GlobalDebugLevel23A > 3U) {
#line 923
      printk("\016RTL8723AU: PHY_MACConfig8723A fault !!\n");
    } else {

    }
#line 924
    goto exit;
  } else {

  }
#line 930
  status = PHY_BBConfig8723A(Adapter);
#line 931
  if (status == 0) {
#line 932
    if (GlobalDebugLevel23A > 3U) {
#line 932
      printk("\016RTL8723AU: PHY_BBConfig8723A fault !!\n");
    } else {

    }
#line 933
    goto exit;
  } else {

  }
#line 939
  status = PHY_RFConfig8723A(Adapter);
#line 940
  if (status == 0) {
#line 941
    if (GlobalDebugLevel23A > 3U) {
#line 941
      printk("\016RTL8723AU: PHY_RFConfig8723A fault !!\n");
    } else {

    }
#line 942
    goto exit;
  } else {

  }
#line 946
  PHY_SetBBReg(Adapter, 36U, 4294967295U, 58818701U);
#line 947
  PHY_SetBBReg(Adapter, 40U, 4294967295U, 4076863363U);
#line 948
  PHY_SetBBReg(Adapter, 40U, 4294967295U, 4076863362U);
#line 949
  PHY_SetBBReg(Adapter, 40U, 4294967295U, 4076863363U);
#line 952
  PHY_SetBBReg(Adapter, 2052U, 4294967295U, 3U);
#line 953
  PHY_SetBBReg(Adapter, 2160U, 4294967295U, 117442400U);
#line 954
  PHY_SetBBReg(Adapter, 2144U, 4294967295U, 1727398416U);
#line 956
  if (GlobalDebugLevel23A > 6U) {
#line 956
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 956
    tmp = PHY_QueryBBReg(Adapter, 2160U, 4294967295U);
#line 956
    printk("\016%s: 0x870 = value 0x%x\n", "rtl8723au_hal_init", tmp);
  } else {

  }
#line 961
  pHalData->RfRegChnlVal[0] = PHY_QueryRFReg(Adapter, 0, 24U, 1048575U);
#line 962
  pHalData->RfRegChnlVal[1] = PHY_QueryRFReg(Adapter, 1, 24U, 1048575U);
#line 964
  if (! pHalData->bMACFuncEnable) {
#line 965
    _InitQueueReservedPage(Adapter);
#line 966
    _InitTxBufferBoundary(Adapter);
  } else {

  }
#line 968
  _InitQueuePriority(Adapter);
#line 969
  _InitPageBoundary(Adapter);
#line 970
  _InitTransferPageSize(Adapter);
#line 973
  _InitDriverInfoSize(Adapter, 4);
#line 975
  _InitInterrupt(Adapter);
#line 976
  hw_var_set_macaddr(Adapter, (u8 *)(& Adapter->eeprompriv.mac_addr));
#line 977
  _InitNetworkType(Adapter);
#line 978
  _InitWMACSetting(Adapter);
#line 979
  _InitAdaptiveCtrl(Adapter);
#line 980
  _InitEDCA(Adapter);
#line 981
  _InitRateFallback(Adapter);
#line 982
  _InitRetryFunction(Adapter);
#line 983
  InitUsbAggregationSetting(Adapter);
#line 984
  _InitOperationMode(Adapter);
#line 985
  rtl8723a_InitBeaconParameters(Adapter);
#line 987
  _InitHWLed(Adapter);
#line 989
  _BBTurnOnBlock(Adapter);
#line 992
  invalidate_cam_all23a(Adapter);
#line 995
  PHY_SetTxPowerLevel8723A(Adapter, (int )pHalData->CurrentChannel);
#line 997
  rtl8723a_InitAntenna_Selection(Adapter);
#line 1001
  rtl8723au_write8(Adapter, 1059U, 255);
#line 1007
  rtl8723au_write32(Adapter, 1228U, 33685503U);
#line 1009
  if ((unsigned int )pregistrypriv->wifi_spec != 0U) {
#line 1010
    rtl8723au_write16(Adapter, 1120U, 0);
  } else {

  }
#line 1013
  _RfPowerSave(Adapter);
#line 1019
  if ((unsigned int )pwrctrlpriv->rf_pwrstate == 0U) {
#line 1020
    if ((unsigned int )pHalData->bIQKInitialized != 0U) {
#line 1021
      rtl8723a_phy_iq_calibrate(Adapter, 1);
    } else {
#line 1023
      rtl8723a_phy_iq_calibrate(Adapter, 0);
#line 1024
      pHalData->bIQKInitialized = 1U;
    }
#line 1027
    rtl8723a_odm_check_tx_power_tracking(Adapter);
#line 1029
    rtl8723a_phy_lc_calibrate(Adapter);
#line 1031
    rtl8723a_dual_antenna_detection(Adapter);
  } else {

  }
#line 1035
  rtl8723au_write8(Adapter, 65088U, 224);
#line 1036
  rtl8723au_write8(Adapter, 65089U, 141);
#line 1037
  rtl8723au_write8(Adapter, 65090U, 128);
#line 1038
  rtl8723au_write32(Adapter, 524U, 16581408U);
#line 1040
  if (((unsigned int )pHalData->VersionID.ICType != 2U && (unsigned int )pHalData->VersionID.ICType != 1U) || ((unsigned int )pHalData->VersionID.VendorType != 1U || (unsigned int )pHalData->VersionID.CUTVersion != 0U)) {
#line 1042
    rtl8723au_write8(Adapter, 65088U, 230);
#line 1043
    rtl8723au_write8(Adapter, 65089U, 148);
#line 1044
    rtl8723au_write8(Adapter, 65090U, 128);
#line 1047
    rtl8723au_write8(Adapter, 65088U, 224);
#line 1048
    rtl8723au_write8(Adapter, 65089U, 25);
#line 1049
    rtl8723au_write8(Adapter, 65090U, 128);
#line 1052
    rtl8723au_write8(Adapter, 65088U, 229);
#line 1053
    rtl8723au_write8(Adapter, 65089U, 145);
#line 1054
    rtl8723au_write8(Adapter, 65090U, 128);
#line 1057
    rtl8723au_write8(Adapter, 65088U, 226);
#line 1058
    rtl8723au_write8(Adapter, 65089U, 129);
#line 1059
    rtl8723au_write8(Adapter, 65090U, 128);
  } else {

  }
#line 1066
  rtl8723a_BT_init_hwconfig(Adapter);
#line 1068
  rtl8723a_InitHalDm(Adapter);
#line 1070
  rtl8723a_set_nav_upper(Adapter, 30000U);
#line 1073
  tmp___0 = rtl8723au_read32(Adapter, 2048U);
#line 1073
  if ((tmp___0 & 4278190080U) != 2197815296U) {
#line 1075
    PHY_SetBBReg(Adapter, 2048U, 16777216U, 1U);
#line 1076
    if (GlobalDebugLevel23A > 3U) {
#line 1076
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
#line 1076
      printk("\016%s: IQK fail recorver\n", "rtl8723au_hal_init");
    } else {

    }
  } else {

  }
#line 1080
  tmp___1 = rtl8723au_read32(Adapter, 1056U);
#line 1080
  rtl8723au_write32(Adapter, 1056U, tmp___1 | 4096U);
  exit: ;
#line 1084
  if (GlobalDebugLevel23A > 3U) {
#line 1084
    tmp___2 = jiffies_to_msecs((unsigned long )jiffies - init_start_time);
#line 1084
    printk("\016RTL8723AU: %s in %dms\n", "rtl8723au_hal_init", tmp___2);
  } else {

  }
#line 1086
  return (status);
}
}
#line 1089 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void phy_SsPwrSwitch92CU(struct rtw_adapter *Adapter , enum rt_rf_power_state eRFPowerState ,
                                int bRegSSPwrLvl ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 value8 ;
  u8 bytetmp ;
  u8 tmp ;
  unsigned long __ms ;
  unsigned long tmp___0 ;
  u8 tmp___1 ;
  unsigned long __ms___0 ;
  unsigned long tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u8 eRFPath ;
  u8 value8___0 ;
  unsigned long __ms___1 ;
  unsigned long tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  unsigned long __ms___2 ;
  unsigned long tmp___12 ;

  {
#line 1093
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1097
  switch ((unsigned int )eRFPowerState) {
  case 0U: ;
#line 1099
  if (bRegSSPwrLvl == 1) {
#line 1105
    tmp = rtl8723au_read8(Adapter, 17U);
#line 1105
    rtl8723au_write8(Adapter, 17U, (int )((unsigned int )tmp | 9U));
#line 1111
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1112
      PHY_SetBBReg(Adapter, 2168U, 3670072U, 1U);
    } else {
#line 1115
      PHY_SetBBReg(Adapter, 2168U, 56U, 1U);
    }
#line 1117
    PHY_SetBBReg(Adapter, 3076U, 240U, 1U);
#line 1118
    PHY_SetBBReg(Adapter, 2048U, 2U, 0U);
#line 1121
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1122
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1675306400U);
    } else
#line 1124
    if ((unsigned int )pHalData->rf_type == 3U) {
#line 1125
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1662723488U);
    } else {

    }
#line 1132
    PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 208277U);
#line 1134
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1135
      PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 208277U);
    } else {

    }
  } else {
#line 1141
    rtl8723au_write8(Adapter, 40U, 129);
#line 1145
    rtl8723au_write16(Adapter, 36U, 32783);
#line 1146
    if (1) {
#line 1146
      __const_udelay(4295000UL);
    } else {
#line 1146
      __ms = 1UL;
#line 1146
      goto ldv_54503;
      ldv_54502: 
#line 1146
      __const_udelay(4295000UL);
      ldv_54503: 
#line 1146
      tmp___0 = __ms;
#line 1146
      __ms = __ms - 1UL;
#line 1146
      if (tmp___0 != 0UL) {
#line 1148
        goto ldv_54502;
      } else {

      }

    }
#line 1149
    tmp___1 = rtl8723au_read8(Adapter, 17U);
#line 1149
    rtl8723au_write8(Adapter, 17U, (int )((unsigned int )tmp___1 | 9U));
#line 1155
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1156
      PHY_SetBBReg(Adapter, 2168U, 3670072U, 1U);
    } else {
#line 1159
      PHY_SetBBReg(Adapter, 2168U, 56U, 1U);
    }
#line 1161
    PHY_SetBBReg(Adapter, 3076U, 240U, 1U);
#line 1162
    PHY_SetBBReg(Adapter, 2048U, 2U, 0U);
#line 1165
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1166
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1675306400U);
    } else
#line 1168
    if ((unsigned int )pHalData->rf_type == 3U) {
#line 1169
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1662723488U);
    } else {

    }
#line 1176
    PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 208277U);
#line 1178
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1179
      PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 208277U);
    } else {

    }
#line 1184
    bytetmp = rtl8723au_read8(Adapter, 1536U);
#line 1185
    rtl8723au_write8(Adapter, 1536U, (int )bytetmp & 191);
#line 1188
    __ms___0 = 10UL;
#line 1188
    goto ldv_54507;
    ldv_54506: 
#line 1188
    __const_udelay(4295000UL);
    ldv_54507: 
#line 1188
    tmp___2 = __ms___0;
#line 1188
    __ms___0 = __ms___0 - 1UL;
#line 1188
    if (tmp___2 != 0UL) {
#line 1190
      goto ldv_54506;
    } else {

    }
#line 1192
    rtl8723au_write8(Adapter, 2U, 23);
#line 1195
    rtl8723au_write8(Adapter, 1314U, 0);
  }
#line 1197
  goto ldv_54509;
  case 1U: ;
  case 2U: 
#line 1200
  value8 = rtl8723au_read8(Adapter, 17U);
#line 1201
  if (((unsigned int )pHalData->VersionID.ICType == 2U || (unsigned int )pHalData->VersionID.ICType == 1U) && ((unsigned int )pHalData->VersionID.VendorType == 1U && (unsigned int )pHalData->VersionID.CUTVersion == 1U)) {
#line 1202
    value8 = (unsigned int )value8 & 254U;
  } else {
#line 1204
    value8 = (unsigned int )value8 & 246U;
  }
#line 1205
  if (bRegSSPwrLvl == 1) {
#line 1206
    if (GlobalDebugLevel23A > 3U) {
#line 1206
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
#line 1206
      printk("\016SS LVL1\n");
    } else {

    }
#line 1217
    tmp___3 = PHY_QueryBBReg(Adapter, 2168U, 4294967295U);
#line 1217
    Adapter->pwrctrlpriv.PS_BBRegBackup[0] = (unsigned long )tmp___3;
#line 1220
    tmp___4 = PHY_QueryBBReg(Adapter, 3076U, 4294967295U);
#line 1220
    Adapter->pwrctrlpriv.PS_BBRegBackup[1] = (unsigned long )tmp___4;
#line 1223
    tmp___5 = PHY_QueryBBReg(Adapter, 2048U, 4294967295U);
#line 1223
    Adapter->pwrctrlpriv.PS_BBRegBackup[2] = (unsigned long )tmp___5;
#line 1226
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1227
      PHY_SetBBReg(Adapter, 2168U, 3670072U, 0U);
    } else
#line 1229
    if ((unsigned int )pHalData->rf_type == 3U) {
#line 1230
      PHY_SetBBReg(Adapter, 2168U, 56U, 0U);
    } else {

    }
#line 1233
    PHY_SetBBReg(Adapter, 3076U, 240U, 0U);
#line 1234
    PHY_SetBBReg(Adapter, 2048U, 2U, 1U);
#line 1237
    tmp___6 = PHY_QueryBBReg(Adapter, 3696U, 4294967295U);
#line 1237
    Adapter->pwrctrlpriv.PS_BBRegBackup[3] = (unsigned long )tmp___6;
#line 1240
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1241
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 14362016U);
    } else
#line 1243
    if ((unsigned int )pHalData->rf_type == 3U) {
#line 1244
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1779104U);
    } else {

    }
#line 1248
    PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 0U);
#line 1249
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1250
      PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 0U);
    } else {

    }
#line 1254
    rtl8723au_write8(Adapter, 17U, (int )value8);
  } else {
#line 1256
    if (GlobalDebugLevel23A > 3U) {
#line 1256
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
#line 1256
      printk("\016SS LVL2\n");
    } else {

    }
#line 1258
    eRFPath = 0U;
#line 1258
    value8___0 = 0U;
#line 1259
    rtl8723au_write8(Adapter, 1314U, 255);
#line 1260
    PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH )eRFPath, 0U, 255U, 0U);
#line 1263
    value8___0 = (u8 )((unsigned int )value8___0 | 64U);
#line 1265
    rtl8723au_write8(Adapter, 1536U, (int )value8___0);
#line 1270
    __ms___1 = 10UL;
#line 1270
    goto ldv_54516;
    ldv_54515: 
#line 1270
    __const_udelay(4295000UL);
    ldv_54516: 
#line 1270
    tmp___7 = __ms___1;
#line 1270
    __ms___1 = __ms___1 - 1UL;
#line 1270
    if (tmp___7 != 0UL) {
#line 1272
      goto ldv_54515;
    } else {

    }
#line 1273
    value8___0 = 0U;
#line 1274
    value8___0 = (u8 )((unsigned int )value8___0 | 22U);
#line 1277
    rtl8723au_write8(Adapter, 2U, (int )value8___0);
#line 1291
    tmp___8 = PHY_QueryBBReg(Adapter, 2168U, 4294967295U);
#line 1291
    Adapter->pwrctrlpriv.PS_BBRegBackup[0] = (unsigned long )tmp___8;
#line 1294
    tmp___9 = PHY_QueryBBReg(Adapter, 3076U, 4294967295U);
#line 1294
    Adapter->pwrctrlpriv.PS_BBRegBackup[1] = (unsigned long )tmp___9;
#line 1297
    tmp___10 = PHY_QueryBBReg(Adapter, 2048U, 4294967295U);
#line 1297
    Adapter->pwrctrlpriv.PS_BBRegBackup[2] = (unsigned long )tmp___10;
#line 1300
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1301
      PHY_SetBBReg(Adapter, 2168U, 3670072U, 0U);
    } else
#line 1303
    if ((unsigned int )pHalData->rf_type == 3U) {
#line 1304
      PHY_SetBBReg(Adapter, 2168U, 56U, 0U);
    } else {

    }
#line 1306
    PHY_SetBBReg(Adapter, 3076U, 240U, 0U);
#line 1307
    PHY_SetBBReg(Adapter, 2048U, 2U, 1U);
#line 1310
    tmp___11 = PHY_QueryBBReg(Adapter, 3696U, 4294967295U);
#line 1310
    Adapter->pwrctrlpriv.PS_BBRegBackup[3] = (unsigned long )tmp___11;
#line 1313
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1314
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 14362016U);
    } else
#line 1316
    if ((unsigned int )pHalData->rf_type == 3U) {
#line 1317
      PHY_SetBBReg(Adapter, 3696U, 4294967295U, 1779104U);
    } else {

    }
#line 1321
    PHY_SetRFReg(Adapter, 0, 0U, 1048575U, 0U);
#line 1322
    if ((unsigned int )pHalData->rf_type == 2U) {
#line 1323
      PHY_SetRFReg(Adapter, 1, 0U, 1048575U, 0U);
    } else {

    }
#line 1327
    rtl8723au_write8(Adapter, 17U, (int )value8);
#line 1332
    rtl8723au_write8(Adapter, 40U, 128);
#line 1333
    if (1) {
#line 1333
      __const_udelay(4295000UL);
    } else {
#line 1333
      __ms___2 = 1UL;
#line 1333
      goto ldv_54520;
      ldv_54519: 
#line 1333
      __const_udelay(4295000UL);
      ldv_54520: 
#line 1333
      tmp___12 = __ms___2;
#line 1333
      __ms___2 = __ms___2 - 1UL;
#line 1333
      if (tmp___12 != 0UL) {
#line 1335
        goto ldv_54519;
      } else {

      }

    }
#line 1337
    rtl8723au_write16(Adapter, 36U, 43023);
  }
#line 1339
  goto ldv_54509;
  default: ;
#line 1341
  goto ldv_54509;
  }
  ldv_54509: ;
#line 1345
  return;
}
}
#line 1346 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
void _ps_open_RF23a(struct rtw_adapter *padapter ) 
{ 


  {
#line 1349
  phy_SsPwrSwitch92CU(padapter, 0, 1);
#line 1350
  return;
}
}
#line 1352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void CardDisableRTL8723U(struct rtw_adapter *Adapter ) 
{ 
  u8 u1bTmp ;
  u8 tmp ;

  {
#line 1356
  if (GlobalDebugLevel23A > 3U) {
#line 1356
    printk("\016RTL8723AU: CardDisableRTL8723U\n");
  } else {

  }
#line 1359
  HalPwrSeqCmdParsing23a(Adapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_enter_lps_flow));
#line 1363
  rtl8723au_write8(Adapter, 31U, 0);
#line 1366
  tmp = rtl8723au_read8(Adapter, 128U);
#line 1366
  if ((int )((signed char )tmp) < 0 && (unsigned int )Adapter->bFWReady != 0U) {
#line 1368
    rtl8723a_FirmwareSelfReset(Adapter);
  } else {

  }
#line 1371
  u1bTmp = rtl8723au_read8(Adapter, 3U);
#line 1372
  rtl8723au_write8(Adapter, 3U, (int )u1bTmp & 251);
#line 1375
  rtl8723au_write8(Adapter, 128U, 0);
#line 1379
  HalPwrSeqCmdParsing23a(Adapter, 255, 15, 2, (struct wlan_pwr_cfg *)(& rtl8723AU_card_disable_flow));
#line 1384
  u1bTmp = rtl8723au_read8(Adapter, 29U);
#line 1385
  rtl8723au_write8(Adapter, 29U, (int )u1bTmp & 254);
#line 1386
  u1bTmp = rtl8723au_read8(Adapter, 29U);
#line 1387
  rtl8723au_write8(Adapter, 29U, (int )((unsigned int )u1bTmp | 1U));
#line 1390
  rtl8723au_write8(Adapter, 28U, 14);
#line 1391
  return;
}
}
#line 1393 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static int rtl8723au_hal_deinit(struct rtw_adapter *padapter ) 
{ 


  {
#line 1395
  if (GlobalDebugLevel23A > 3U) {
#line 1395
    printk("\016RTL8723AU: ==> %s\n", "rtl8723au_hal_deinit");
  } else {

  }
#line 1398
  BT_HaltProcess(padapter);
#line 1404
  CardDisableRTL8723U(padapter);
#line 1406
  return (1);
}
}
#line 1409 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
int rtl8723au_inirp_init(struct rtw_adapter *Adapter ) 
{ 
  u8 i ;
  struct recv_buf *precvbuf ;
  int status ;
  struct recv_priv *precvpriv ;
  struct hal_data_8723a *pHalData ;
  int tmp ;
  int tmp___0 ;

  {
#line 1414
  precvpriv = & Adapter->recvpriv;
#line 1415
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1417
  status = 1;
#line 1419
  if (GlobalDebugLevel23A > 6U) {
#line 1419
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 1419
    printk("\016===> usb_inirp_init\n");
  } else {

  }
#line 1422
  precvbuf = (struct recv_buf *)precvpriv->precv_buf;
#line 1423
  i = 0U;
#line 1423
  goto ldv_54544;
  ldv_54543: 
#line 1424
  tmp = rtl8723au_read_port(Adapter, 128U, 0U, precvbuf);
#line 1424
  if (tmp == 0) {
#line 1426
    if (GlobalDebugLevel23A > 3U) {
#line 1426
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
#line 1426
      printk("\016usb_rx_init: usb_read_port error\n");
    } else {

    }
#line 1428
    status = 0;
#line 1429
    goto exit;
  } else {

  }
#line 1431
  precvbuf = precvbuf + 1;
#line 1423
  i = (u8 )((int )i + 1);
  ldv_54544: ;
#line 1423
  if ((unsigned int )i <= 3U) {
#line 1425
    goto ldv_54543;
  } else {

  }
#line 1433
  tmp___0 = rtl8723au_read_interrupt(Adapter, 129U);
#line 1433
  if (tmp___0 == 0) {
#line 1434
    if (GlobalDebugLevel23A > 3U) {
#line 1434
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 4);
#line 1434
      printk("\016usb_rx_init: usb_read_interrupt error\n");
    } else {

    }
#line 1436
    status = 0;
  } else {

  }
#line 1438
  pHalData->IntrMask[0] = rtl8723au_read32(Adapter, 65080U);
#line 1439
  if (GlobalDebugLevel23A > 3U) {
#line 1439
    printk("\016RTL8723AU: pHalData->IntrMask = 0x%04x\n", pHalData->IntrMask[0]);
  } else {

  }
#line 1440
  pHalData->IntrMask[0] = pHalData->IntrMask[0] | 1280U;
#line 1441
  rtl8723au_write32(Adapter, 65080U, pHalData->IntrMask[0]);
  exit: ;
#line 1443
  if (GlobalDebugLevel23A > 6U) {
#line 1443
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 1443
    printk("\016<=== usb_inirp_init\n");
  } else {

  }
#line 1445
  return (status);
}
}
#line 1448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
int rtl8723au_inirp_deinit(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1450
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1452
  if (GlobalDebugLevel23A > 6U) {
#line 1452
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 1452
    printk("\016\n ===> usb_rx_deinit\n");
  } else {

  }
#line 1454
  rtl8723au_read_port_cancel(Adapter);
#line 1455
  pHalData->IntrMask[0] = rtl8723au_read32(Adapter, 65080U);
#line 1456
  if (GlobalDebugLevel23A > 3U) {
#line 1456
    printk("\016RTL8723AU: %s pHalData->IntrMask = 0x%04x\n", "rtl8723au_inirp_deinit",
           pHalData->IntrMask[0]);
  } else {

  }
#line 1458
  pHalData->IntrMask[0] = 0U;
#line 1459
  rtl8723au_write32(Adapter, 65080U, pHalData->IntrMask[0]);
#line 1460
  if (GlobalDebugLevel23A > 6U) {
#line 1460
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 7);
#line 1460
    printk("\016\n <=== usb_rx_deinit\n");
  } else {

  }
#line 1462
  return (1);
}
}
#line 1465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _ReadBoardType(struct rtw_adapter *Adapter , u8 *PROMContent , bool AutoloadFail ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 boardType ;

  {
#line 1468
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1469
  boardType = 0U;
#line 1471
  if ((int )AutoloadFail) {
#line 1472
    if ((unsigned int )pHalData->VersionID.ICType == 4U) {
#line 1473
      pHalData->rf_type = 3U;
    } else {
#line 1475
      pHalData->rf_type = 2U;
    }
#line 1476
    pHalData->BoardType = boardType;
#line 1477
    return;
  } else {

  }
#line 1480
  boardType = *(PROMContent + 121UL);
#line 1481
  boardType = (unsigned int )boardType & 224U;
#line 1482
  boardType = (u8 )((int )boardType >> 5);
#line 1484
  pHalData->BoardType = boardType;
#line 1485
  if (GlobalDebugLevel23A > 3U) {
#line 1485
    printk("\016RTL8723AU: _ReadBoardType(%x)\n", (int )pHalData->BoardType);
  } else {

  }
#line 1487
  if ((unsigned int )boardType == 1U) {
#line 1488
    pHalData->ExternalPA = 1U;
  } else {

  }
#line 1489
  return;
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _ReadLEDSetting(struct rtw_adapter *Adapter , u8 *PROMContent , bool AutoloadFail ) 
{ 
  struct led_priv *pledpriv ;

  {
#line 1494
  pledpriv = & Adapter->ledpriv;
#line 1496
  pledpriv->LedStrategy = 50;
#line 1497
  return;
}
}
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void Hal_EfuseParsePIDVID_8723AU(struct rtw_adapter *pAdapter , u8 *hwinfo ,
                                        bool AutoLoadFail ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1502
  pHalData = (struct hal_data_8723a *)pAdapter->HalData;
#line 1504
  if ((int )AutoLoadFail) {
#line 1505
    pHalData->EEPROMVID = 0U;
#line 1506
    pHalData->EEPROMPID = 0U;
  } else {
#line 1509
    pHalData->EEPROMVID = *((u16 *)hwinfo + 183U);
#line 1511
    pHalData->EEPROMPID = *((u16 *)hwinfo + 185U);
  }
#line 1515
  if (GlobalDebugLevel23A > 3U) {
#line 1515
    printk("\016RTL8723AU: EEPROM VID = 0x%4x\n", (int )pHalData->EEPROMVID);
  } else {

  }
#line 1516
  if (GlobalDebugLevel23A > 3U) {
#line 1516
    printk("\016RTL8723AU: EEPROM PID = 0x%4x\n", (int )pHalData->EEPROMPID);
  } else {

  }
#line 1517
  return;
}
}
#line 1519 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void Hal_EfuseParseMACAddr_8723AU(struct rtw_adapter *padapter , u8 *hwinfo ,
                                         bool AutoLoadFail ) 
{ 
  u16 i ;
  u8 sMacAddr[6U] ;
  struct eeprom_priv *pEEPROM ;
  size_t __len ;
  void *__ret ;

  {
#line 1523
  sMacAddr[0] = 0U;
#line 1523
  sMacAddr[1] = 224U;
#line 1523
  sMacAddr[2] = 76U;
#line 1523
  sMacAddr[3] = 135U;
#line 1523
  sMacAddr[4] = 35U;
#line 1523
  sMacAddr[5] = 0U;
#line 1524
  pEEPROM = & padapter->eeprompriv;
#line 1526
  if ((int )AutoLoadFail) {
#line 1527
    i = 0U;
#line 1527
    goto ldv_54579;
    ldv_54578: 
#line 1528
    pEEPROM->mac_addr[(int )i] = sMacAddr[(int )i];
#line 1527
    i = (u16 )((int )i + 1);
    ldv_54579: ;
#line 1527
    if ((unsigned int )i <= 5U) {
#line 1529
      goto ldv_54578;
    } else {

    }

  } else {
#line 1531
    __len = 6UL;
#line 1531
    if (__len > 63UL) {
#line 1531
      __ret = __memcpy((void *)(& pEEPROM->mac_addr), (void const   *)hwinfo + 198U,
                       __len);
    } else {
#line 1531
      __ret = __builtin_memcpy((void *)(& pEEPROM->mac_addr), (void const   *)hwinfo + 198U,
                               __len);
    }
  }
#line 1535
  if (GlobalDebugLevel23A > 5U) {
#line 1535
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 32768U, 6);
#line 1535
    printk("\016Hal_EfuseParseMACAddr_8723AU: Permanent Address =%02x:%02x:%02x:%02x:%02x:%02x\n",
           (int )pEEPROM->mac_addr[0], (int )pEEPROM->mac_addr[1], (int )pEEPROM->mac_addr[2],
           (int )pEEPROM->mac_addr[3], (int )pEEPROM->mac_addr[4], (int )pEEPROM->mac_addr[5]);
  } else {

  }
#line 1537
  return;
}
}
#line 1543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void readAdapterInfo(struct rtw_adapter *padapter ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u8 hwinfo[256U] ;

  {
#line 1545
  pEEPROM = & padapter->eeprompriv;
#line 1549
  Hal_InitPGData(padapter, (u8 *)(& hwinfo));
#line 1550
  Hal_EfuseParseIDCode(padapter, (u8 *)(& hwinfo));
#line 1551
  Hal_EfuseParsePIDVID_8723AU(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1553
  Hal_EfuseParseEEPROMVer(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1555
  Hal_EfuseParseMACAddr_8723AU(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1557
  Hal_EfuseParsetxpowerinfo_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1559
  _ReadBoardType(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1560
  Hal_EfuseParseBTCoexistInfo_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1563
  rtl8723a_EfuseParseChnlPlan(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1565
  Hal_EfuseParseThermalMeter_8723A(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1567
  _ReadLEDSetting(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1570
  Hal_EfuseParseAntennaDiversity(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1573
  Hal_EfuseParseEEPROMVer(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1574
  Hal_EfuseParseCustomerID(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1576
  Hal_EfuseParseRateIndicationOption(padapter, (u8 *)(& hwinfo), (unsigned int )pEEPROM->bautoload_fail_flag != 0U);
#line 1578
  Hal_EfuseParseXtal_8723A(padapter, (u8 *)(& hwinfo), (int )pEEPROM->bautoload_fail_flag);
#line 1583
  Hal_InitChannelPlan23a(padapter);
#line 1588
  if (GlobalDebugLevel23A > 3U) {
#line 1588
    printk("\016RTL8723AU: %s(): REPLACEMENT = %x\n", "readAdapterInfo", padapter->bDongle);
  } else {

  }
#line 1589
  return;
}
}
#line 1591 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _ReadPROMContent(struct rtw_adapter *Adapter ) 
{ 
  struct eeprom_priv *pEEPROM ;
  u8 eeValue ;

  {
#line 1593
  pEEPROM = & Adapter->eeprompriv;
#line 1596
  eeValue = rtl8723au_read8(Adapter, 10U);
#line 1598
  pEEPROM->EepromOrEfuse = ((unsigned long )eeValue & 16UL) != 0UL;
#line 1599
  pEEPROM->bautoload_fail_flag = ((unsigned long )eeValue & 32UL) == 0UL;
#line 1601
  if (GlobalDebugLevel23A > 3U) {
#line 1601
    printk("\016RTL8723AU: Boot from %s, Autoload %s !\n", (unsigned int )pEEPROM->EepromOrEfuse != 0U ? (char *)"EEPROM" : (char *)"EFUSE",
           (unsigned int )pEEPROM->bautoload_fail_flag != 0U ? (char *)"Fail" : (char *)"OK");
  } else {

  }
#line 1605
  readAdapterInfo(Adapter);
#line 1606
  return;
}
}
#line 1608 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _ReadRFType(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1610
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1612
  pHalData->rf_chip = 4U;
#line 1613
  return;
}
}
#line 1615 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void _ReadSilmComboMode(struct rtw_adapter *Adapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 1617
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1619
  pHalData->SlimComboDbg = 0;
#line 1620
  return;
}
}
#line 1631 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
static void hal_EfuseCellSel(struct rtw_adapter *Adapter ) 
{ 
  u32 value32 ;

  {
#line 1635
  value32 = rtl8723au_read32(Adapter, 52U);
#line 1636
  value32 = value32 & 4294966527U;
#line 1637
  rtl8723au_write32(Adapter, 52U, value32);
#line 1638
  return;
}
}
#line 1640 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
void rtl8723a_read_adapter_info(struct rtw_adapter *Adapter ) 
{ 
  unsigned long start ;
  unsigned int tmp ;

  {
#line 1642
  start = jiffies;
#line 1645
  Adapter->EepromAddressSize = GetEEPROMSize8723A(Adapter);
#line 1647
  if (GlobalDebugLevel23A > 3U) {
#line 1647
    printk("\016RTL8723AU: ====> _ReadAdapterInfo8723AU\n");
  } else {

  }
#line 1649
  hal_EfuseCellSel(Adapter);
#line 1651
  _ReadRFType(Adapter);
#line 1652
  _ReadPROMContent(Adapter);
#line 1656
  _ReadSilmComboMode(Adapter);
#line 1661
  if (GlobalDebugLevel23A > 3U) {
#line 1661
    tmp = jiffies_to_msecs((unsigned long )jiffies - start);
#line 1661
    printk("\016RTL8723AU: <==== _ReadAdapterInfo8723AU in %d ms\n", tmp);
  } else {

  }
#line 1662
  return;
}
}
#line 1669 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
int GetHalDefVar8192CUsb(struct rtw_adapter *Adapter , enum hal_def_variable eVariable ,
                         void *pValue ) 
{ 
  struct hal_data_8723a *pHalData ;
  int bResult ;
  struct dm_odm_t *pDM_Odm ;

  {
#line 1672
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 1673
  bResult = 1;
#line 1675
  switch ((unsigned int )eVariable) {
  case 0U: 
#line 1677
  *((int *)pValue) = pHalData->dmpriv.UndecoratedSmoothedPWDB;
#line 1678
  goto ldv_54619;
  case 1U: ;
#line 1680
  goto ldv_54619;
  case 2U: ;
#line 1682
  goto ldv_54619;
  case 3U: 
#line 1684
  *((u32 *)pValue) = 4U;
#line 1685
  goto ldv_54619;
  case 4U: 
#line 1687
  *((u32 *)pValue) = 15360U;
#line 1688
  goto ldv_54619;
  case 5U: 
#line 1690
  *((u32 *)pValue) = 28U;
#line 1691
  goto ldv_54619;
  case 6U: 
#line 1693
  *((u8 *)pValue) = pHalData->bDumpRxPkt;
#line 1694
  goto ldv_54619;
  case 7U: 
#line 1696
  *((u32 *)pValue) = pHalData->odmpriv.SupportAbility;
#line 1697
  goto ldv_54619;
  case 11U: 
#line 1699
  *((u32 *)pValue) = 3U;
#line 1700
  goto ldv_54619;
  case 15U: 
#line 1703
  pDM_Odm = & pHalData->odmpriv;
#line 1704
  printk("pDM_Odm->DebugComponents = 0x%llx\n", pDM_Odm->DebugComponents);
#line 1707
  goto ldv_54619;
  default: 
#line 1711
  bResult = 0;
#line 1712
  goto ldv_54619;
  }
  ldv_54619: ;
#line 1715
  return (bResult);
}
}
#line 1718 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
void rtl8723a_update_ramask(struct rtw_adapter *padapter , u32 mac_id , u8 rssi_level ) 
{ 
  u8 init_rate ;
  u8 networkType ;
  u8 raid ;
  u32 mask ;
  u32 rate_bitmap ;
  u8 shortGIrate ;
  int supportRateNum ;
  struct sta_info *psta ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  uint tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  uint tmp___4 ;
  uint tmp___5 ;
  u8 tmp___6 ;
  unsigned char tmp___7 ;
  u8 arg ;

  {
#line 1721
  init_rate = 0U;
#line 1724
  shortGIrate = 0U;
#line 1725
  supportRateNum = 0;
#line 1727
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 1728
  pdmpriv = & pHalData->dmpriv;
#line 1729
  pmlmeext = & padapter->mlmeextpriv;
#line 1730
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1731
  cur_network = & pmlmeinfo->network;
#line 1733
  if (mac_id > 31U) {
#line 1734
    return;
  } else {

  }
#line 1736
  psta = pmlmeinfo->FW_sta_info[mac_id].psta;
#line 1737
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1738
    return;
  } else {

  }
#line 1740
  switch (mac_id) {
  case 0U: 
#line 1742
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 1742
  supportRateNum = (int )tmp;
#line 1744
  tmp___0 = judge_network_type23a(padapter, (unsigned char *)(& cur_network->SupportedRates),
                                  supportRateNum);
#line 1744
  networkType = (unsigned int )tmp___0 & 15U;
#line 1748
  raid = networktype_to_raid23a((int )networkType);
#line 1750
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
#line 1752
  if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 1752
    tmp___1 = update_MSC_rate23a(& pmlmeinfo->HT_caps);
#line 1752
    tmp___2 = tmp___1;
  } else {
#line 1752
    tmp___2 = 0U;
  }
#line 1752
  mask = tmp___2 | mask;
#line 1755
  tmp___3 = support_short_GI23a(padapter, & pmlmeinfo->HT_caps);
#line 1755
  if (tmp___3 != 0) {
#line 1756
    shortGIrate = 1U;
  } else {

  }
#line 1757
  goto ldv_54650;
  case 1U: 
#line 1760
  tmp___4 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
#line 1760
  supportRateNum = (int )tmp___4;
#line 1762
  if ((int )pmlmeext->cur_wireless_mode & 1) {
#line 1763
    networkType = 1U;
  } else {
#line 1765
    networkType = 2U;
  }
#line 1766
  raid = networktype_to_raid23a((int )networkType);
#line 1768
  mask = update_basic_rate23a((unsigned char *)(& cur_network->SupportedRates), (unsigned int )supportRateNum);
#line 1770
  goto ldv_54650;
  default: 
#line 1773
  tmp___5 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
#line 1773
  supportRateNum = (int )tmp___5;
#line 1775
  tmp___6 = judge_network_type23a(padapter, (unsigned char *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates),
                                  supportRateNum);
#line 1775
  networkType = (unsigned int )tmp___6 & 15U;
#line 1779
  raid = networktype_to_raid23a((int )networkType);
#line 1781
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
#line 1785
  goto ldv_54650;
  }
  ldv_54650: 
#line 1789
  rate_bitmap = 268435455U;
#line 1790
  rate_bitmap = ODM_Get_Rate_Bitmap23a(& pHalData->odmpriv, mac_id, mask, (int )rssi_level);
#line 1792
  if (GlobalDebugLevel23A > 3U) {
#line 1792
    printk("\016RTL8723AU: %s => mac_id:%d, networkType:0x%02x, mask:0x%08x\n\t ==> rssi_level:%d, rate_bitmap:0x%08x\n",
           "rtl8723a_update_ramask", mac_id, (int )networkType, mask, (int )rssi_level,
           rate_bitmap);
  } else {

  }
#line 1796
  mask = mask & rate_bitmap;
#line 1797
  mask = (u32 )((int )raid << 28) | mask;
#line 1799
  tmp___7 = get_highest_rate_idx23a(mask);
#line 1799
  init_rate = (unsigned int )tmp___7 & 63U;
#line 1801
  if ((unsigned int )pHalData->fw_ractrl == 1U) {
#line 1802
    arg = 0U;
#line 1805
    arg = (unsigned int )((u8 )mac_id) & 31U;
#line 1807
    arg = (u8 )((unsigned int )arg | 128U);
#line 1809
    if ((unsigned int )shortGIrate == 1U) {
#line 1810
      arg = (u8 )((unsigned int )arg | 32U);
    } else {

    }
#line 1812
    if (GlobalDebugLevel23A > 3U) {
#line 1812
      printk("\016RTL8723AU: update raid entry, mask = 0x%x, arg = 0x%x\n", mask,
             (int )arg);
    } else {

    }
#line 1815
    rtl8723a_set_raid_cmd(padapter, mask, (int )arg);
  } else {
#line 1817
    if ((unsigned int )shortGIrate == 1U) {
#line 1818
      init_rate = (u8 )((unsigned int )init_rate | 64U);
    } else {

    }
#line 1820
    rtl8723au_write8(padapter, mac_id + 1156U, (int )init_rate);
  }
#line 1825
  psta->raid = raid;
#line 1826
  psta->init_rate = init_rate;
#line 1829
  pdmpriv->INIDATA_RATE[mac_id] = init_rate;
#line 1830
  return;
}
}
#line 1832 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
int rtw_hal_init23a(struct rtw_adapter *padapter ) 
{ 
  int status ;

  {
#line 1836
  padapter->hw_init_completed = 0U;
#line 1838
  status = rtl8723au_hal_init(padapter);
#line 1840
  if (status == 1) {
#line 1841
    padapter->hw_init_completed = 1U;
#line 1843
    if ((unsigned int )padapter->registrypriv.notch_filter == 1U) {
#line 1844
      rtl8723a_notch_filter(padapter, 1);
    } else {

    }
  } else {
#line 1846
    padapter->hw_init_completed = 0U;
#line 1847
    if (GlobalDebugLevel23A > 3U) {
#line 1847
      printk("\016RTL8723AU: rtw_hal_init23a: hal__init fail\n");
    } else {

    }
  }
#line 1850
  if (GlobalDebugLevel23A > 3U) {
#line 1850
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 4);
#line 1850
    printk("\016-rtl871x_hal_init:status = 0x%x\n", status);
  } else {

  }
#line 1853
  return (status);
}
}
#line 1856 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
int rtw_hal_deinit23a(struct rtw_adapter *padapter ) 
{ 
  int status ;

  {
#line 1860
  status = rtl8723au_hal_deinit(padapter);
#line 1862
  if (status == 1) {
#line 1863
    padapter->hw_init_completed = 0U;
  } else
#line 1865
  if (GlobalDebugLevel23A > 3U) {
#line 1865
    printk("\016RTL8723AU: \n rtw_hal_deinit23a: hal_init fail\n");
  } else {

  }
#line 1866
  return (status);
}
}
#line 1996 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
void *ldv_kmem_cache_alloc_1970(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1999
  ldv_check_alloc_flags(flags);
#line 2001
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2002
  return ((void *)0);
}
}
#line 2040 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
int ldv_pskb_expand_head_1976(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2043
  ldv_check_alloc_flags(flags);
#line 2045
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2045
  return (tmp);
}
}
#line 2056 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
struct sk_buff *ldv_skb_clone_1978(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2059
  ldv_check_alloc_flags(flags);
#line 2061
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2061
  return (tmp);
}
}
#line 2072 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
struct sk_buff *ldv_skb_copy_1980(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2075
  ldv_check_alloc_flags(flags);
#line 2077
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2077
  return (tmp);
}
}
#line 2080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1981(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2083
  ldv_check_alloc_flags(flags);
#line 2085
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2085
  return (tmp);
}
}
#line 2088 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1982(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2091
  ldv_check_alloc_flags(flags);
#line 2093
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2093
  return (tmp);
}
}
#line 2096 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_1983(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2099
  ldv_check_alloc_flags(flags);
#line 2101
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2101
  return (tmp);
}
}
#line 2104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
int ldv_pskb_expand_head_1984(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2107
  ldv_check_alloc_flags(flags);
#line 2109
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2109
  return (tmp);
}
}
#line 2112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
int ldv_pskb_expand_head_1985(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2115
  ldv_check_alloc_flags(flags);
#line 2117
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2117
  return (tmp);
}
}
#line 2120 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_halinit.o.c.prepared"
struct sk_buff *ldv_skb_clone_1986(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2123
  ldv_check_alloc_flags(flags);
#line 2125
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2125
  return (tmp);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2012(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_2020(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2028(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 767
struct sk_buff *ldv_skb_clone_2031(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 772
struct sk_buff *ldv_skb_copy_2022(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2018(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2026(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 793
int ldv_pskb_expand_head_2027(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 1413
extern struct sk_buff *skb_dequeue(struct sk_buff_head * ) ;
#line 1532 "include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb ) 
{ 


  {
#line 1534
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
#line 1535
  return;
}
}
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2023(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2024(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2025(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2032 "include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb(struct net_device *dev , unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2035
  tmp = ldv___netdev_alloc_skb_2023(dev, length, 32U);
#line 2035
  return (tmp);
}
}
#line 514 "include/linux/interrupt.h"
extern void __tasklet_schedule(struct tasklet_struct * ) ;
#line 516 "include/linux/interrupt.h"
__inline static void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
#line 518
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& t->state));
#line 518
  if (tmp == 0) {
#line 519
    __tasklet_schedule(t);
  } else {

  }
#line 520
  return;
}
}
#line 1511 "include/linux/usb.h"
__inline static void usb_fill_bulk_urb(struct urb *urb , struct usb_device *dev ,
                                       unsigned int pipe , void *transfer_buffer ,
                                       int buffer_length , void (*complete_fn)(struct urb * ) ,
                                       void *context ) 
{ 


  {
#line 1519
  urb->dev = dev;
#line 1520
  urb->pipe = pipe;
#line 1521
  urb->transfer_buffer = transfer_buffer;
#line 1522
  urb->transfer_buffer_length = (u32 )buffer_length;
#line 1523
  urb->complete = complete_fn;
#line 1524
  urb->context = context;
#line 1525
  return;
}
}
#line 1552 "include/linux/usb.h"
__inline static void usb_fill_int_urb(struct urb *urb , struct usb_device *dev , unsigned int pipe ,
                                      void *transfer_buffer , int buffer_length ,
                                      void (*complete_fn)(struct urb * ) , void *context ,
                                      int interval ) 
{ 
  int __val ;
  int __min ;
  int __max ;

  {
#line 1561
  urb->dev = dev;
#line 1562
  urb->pipe = pipe;
#line 1563
  urb->transfer_buffer = transfer_buffer;
#line 1564
  urb->transfer_buffer_length = (u32 )buffer_length;
#line 1565
  urb->complete = complete_fn;
#line 1566
  urb->context = context;
#line 1568
  if ((unsigned int )dev->speed == 3U || (unsigned int )dev->speed == 5U) {
#line 1570
    __val = interval;
#line 1570
    __min = 1;
#line 1570
    __max = 16;
#line 1570
    __val = __min > __val ? __min : __val;
#line 1570
    interval = __max < __val ? __max : __val;
#line 1572
    urb->interval = 1 << (interval + -1);
  } else {
#line 1574
    urb->interval = interval;
  }
#line 1577
  urb->start_frame = -1;
#line 1578
  return;
}
}
#line 1585
extern int usb_submit_urb(struct urb * , gfp_t  ) ;
#line 1588
int ldv_usb_submit_urb_2029(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1592
int ldv_usb_submit_urb_2030(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1596
int ldv_usb_submit_urb_2032(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1656
extern int usb_control_msg(struct usb_device * , unsigned int  , __u8  , __u8  , __u16  ,
                           __u16  , void * , __u16  , int  ) ;
#line 1784 "include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 


  {
#line 1787
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 37 "drivers/staging/rtl8723au/include/usb_ops.h"
void rtl8723au_set_hw_type(struct rtw_adapter *padapter ) ;
#line 46 "drivers/staging/rtl8723au/include/usb_ops.h"
__inline static int rtw_inc_and_chk_continual_urb_error(struct dvobj_priv *dvobj ) 
{ 
  int ret ;
  int value ;

  {
#line 48
  ret = 0;
#line 51
  value = atomic_add_return(1, & dvobj->continual_urb_error);
#line 52
  if (value > 4) {
#line 53
    if (GlobalDebugLevel23A > 3U) {
#line 53
      printk("\016RTL8723AU: [dvobj:%p][OLD_ERROR] continual_urb_error:%d > %d\n", dvobj,
             value, 4);
    } else {

    }
#line 55
    ret = 1;
  } else {

  }
#line 57
  return (ret);
}
}
#line 61 "drivers/staging/rtl8723au/include/usb_ops.h"
__inline static void rtw_reset_continual_urb_error(struct dvobj_priv *dvobj ) 
{ 


  {
#line 63
  atomic_set(& dvobj->continual_urb_error, 0);
#line 64
  return;
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
static int usbctrl_vendorreq(struct rtw_adapter *padapter , u8 request , u16 value ,
                             u16 index , void *pdata , u16 len , u8 requesttype ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device *udev ;
  unsigned int pipe ;
  int status ;
  u8 reqtype ;
  u8 *pIo_buf ;
  int vendorreq_times ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct hal_data_8723a *pHalData ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___1 ;

  {
#line 247
  pdvobjpriv = padapter->dvobj;
#line 248
  udev = pdvobjpriv->pusbdev;
#line 251
  status = 0;
#line 254
  vendorreq_times = 0;
#line 256
  if (padapter->bSurpriseRemoved != 0 || (unsigned int )padapter->pwrctrlpriv.pnp_bstop_trx != 0U) {
#line 257
    if (GlobalDebugLevel23A > 3U) {
#line 257
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 257
      printk("\016usbctrl_vendorreq:(padapter->bSurpriseRemoved||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n");
    } else {

    }
#line 260
    status = -1;
#line 261
    goto exit;
  } else {

  }
#line 264
  if ((unsigned int )len > 254U) {
#line 265
    if (GlobalDebugLevel23A > 3U) {
#line 265
      printk("\016RTL8723AU: [%s] Buffer len error , vendor request failed\n", "usbctrl_vendorreq");
    } else {

    }
#line 267
    status = -22;
#line 268
    goto exit;
  } else {

  }
#line 271
  mutex_lock_nested(& pdvobjpriv->usb_vendor_req_mutex, 0U);
#line 274
  pIo_buf = pdvobjpriv->usb_vendor_req_buf;
#line 276
  if ((unsigned long )pIo_buf == (unsigned long )((u8 *)0U)) {
#line 277
    if (GlobalDebugLevel23A > 3U) {
#line 277
      printk("\016RTL8723AU: [%s] pIo_buf == NULL \n", "usbctrl_vendorreq");
    } else {

    }
#line 278
    status = -12;
#line 279
    goto release_mutex;
  } else {

  }
#line 282
  goto ldv_54340;
  ldv_54339: 
#line 283
  memset((void *)pIo_buf, 0, (size_t )len);
#line 285
  if ((unsigned int )requesttype == 1U) {
#line 286
    tmp = __create_pipe(udev, 0U);
#line 286
    pipe = tmp | 2147483776U;
#line 287
    reqtype = 192U;
  } else {
#line 289
    tmp___0 = __create_pipe(udev, 0U);
#line 289
    pipe = tmp___0 | 2147483648U;
#line 290
    reqtype = 64U;
#line 291
    __len = (size_t )len;
#line 291
    __ret = __builtin_memcpy((void *)pIo_buf, (void const   *)pdata, __len);
  }
#line 294
  status = usb_control_msg(udev, pipe, (int )request, (int )reqtype, (int )value,
                           (int )index, (void *)pIo_buf, (int )len, 500);
#line 298
  if ((int )len == status) {
#line 299
    rtw_reset_continual_urb_error(pdvobjpriv);
#line 300
    if ((unsigned int )requesttype == 1U) {
#line 304
      __len___0 = (size_t )len;
#line 304
      __ret___0 = __builtin_memcpy(pdata, (void const   *)pIo_buf, __len___0);
    } else {

    }
  } else {
#line 307
    if (GlobalDebugLevel23A > 3U) {
#line 307
      printk("\016RTL8723AU: reg 0x%x, usb %s %u fail, status:%d value = 0x%x, vendorreq_times:%d\n",
             (int )value, (unsigned int )requesttype == 1U ? (char *)"read" : (char *)"write",
             (int )len, status, *((u32 *)pdata), vendorreq_times);
    } else {

    }
#line 313
    if (status < 0) {
#line 314
      if (status == -108 || status == -19) {
#line 315
        padapter->bSurpriseRemoved = 1;
      } else {
#line 318
        pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 319
        pHalData->srestpriv.Wifi_Error_Status = 1U;
      }
    } else
#line 323
    if (status > 0) {
#line 324
      if ((unsigned int )requesttype == 1U) {
#line 330
        __len___1 = (size_t )len;
#line 330
        __ret___1 = __builtin_memcpy(pdata, (void const   *)pIo_buf, __len___1);
      } else {

      }
    } else {

    }
#line 335
    tmp___1 = rtw_inc_and_chk_continual_urb_error(pdvobjpriv);
#line 335
    if (tmp___1 != 0) {
#line 336
      padapter->bSurpriseRemoved = 1;
#line 337
      goto ldv_54338;
    } else {

    }
  }
#line 342
  if (((unsigned int )value > 4095U && (unsigned int )value <= 8191U) || (int )len == status) {
#line 344
    goto ldv_54338;
  } else {

  }
  ldv_54340: 
#line 282
  vendorreq_times = vendorreq_times + 1;
#line 282
  if (vendorreq_times <= 10) {
#line 284
    goto ldv_54339;
  } else {

  }
  ldv_54338: ;
  release_mutex: 
#line 348
  mutex_unlock(& pdvobjpriv->usb_vendor_req_mutex);
  exit: ;
#line 350
  return (status);
}
}
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
u8 rtl8723au_read8(struct rtw_adapter *padapter , u32 addr ) 
{ 
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  u8 data ;

  {
#line 360
  data = 0U;
#line 362
  request = 5U;
#line 363
  requesttype = 1U;
#line 364
  index = 0U;
#line 366
  wvalue = (unsigned short )addr;
#line 367
  len = 1U;
#line 369
  usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                    (int )len, (int )requesttype);
#line 372
  return (data);
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
u16 rtl8723au_read16(struct rtw_adapter *padapter , u32 addr ) 
{ 
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  __le16 data ;

  {
#line 384
  request = 5U;
#line 385
  requesttype = 1U;
#line 386
  index = 0U;
#line 388
  wvalue = (unsigned short )addr;
#line 389
  len = 2U;
#line 391
  usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                    (int )len, (int )requesttype);
#line 394
  return (data);
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
u32 rtl8723au_read32(struct rtw_adapter *padapter , u32 addr ) 
{ 
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  __le32 data ;

  {
#line 406
  request = 5U;
#line 407
  requesttype = 1U;
#line 408
  index = 0U;
#line 410
  wvalue = (unsigned short )addr;
#line 411
  len = 4U;
#line 413
  usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                    (int )len, (int )requesttype);
#line 416
  return (data);
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int rtl8723au_write8(struct rtw_adapter *padapter , u32 addr , u8 val ) 
{ 
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  u8 data ;
  int ret ;

  {
#line 429
  request = 5U;
#line 430
  requesttype = 0U;
#line 431
  index = 0U;
#line 433
  wvalue = (unsigned short )addr;
#line 434
  len = 1U;
#line 436
  data = val;
#line 438
  ret = usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                          (int )len, (int )requesttype);
#line 441
  return (ret);
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int rtl8723au_write16(struct rtw_adapter *padapter , u32 addr , u16 val ) 
{ 
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  __le16 data ;
  int ret ;

  {
#line 454
  request = 5U;
#line 455
  requesttype = 0U;
#line 456
  index = 0U;
#line 458
  wvalue = (unsigned short )addr;
#line 459
  len = 2U;
#line 461
  data = val;
#line 463
  ret = usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                          (int )len, (int )requesttype);
#line 465
  return (ret);
}
}
#line 468 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int rtl8723au_write32(struct rtw_adapter *padapter , u32 addr , u32 val ) 
{ 
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  __le32 data ;
  int ret ;

  {
#line 478
  request = 5U;
#line 479
  requesttype = 0U;
#line 480
  index = 0U;
#line 482
  wvalue = (unsigned short )addr;
#line 483
  len = 4U;
#line 484
  data = val;
#line 486
  ret = usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& data),
                          (int )len, (int )requesttype);
#line 489
  return (ret);
}
}
#line 492 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int rtl8723au_writeN(struct rtw_adapter *padapter , u32 addr , u32 length , u8 *pdata ) 
{ 
  u8 request ;
  u8 requesttype ;
  u16 wvalue ;
  u16 index ;
  u16 len ;
  u8 buf[254U] ;
  unsigned int tmp ;
  int ret ;
  size_t __len ;
  void *__ret ;

  {
#line 500
  buf[0] = 0U;
#line 500
  tmp = 1U;
#line 500
  while (1) {
#line 500
    if (tmp >= 254U) {
#line 500
      break;
    } else {

    }
#line 500
    buf[tmp] = (unsigned char)0;
#line 500
    tmp = tmp + 1U;
  }
#line 503
  request = 5U;
#line 504
  requesttype = 0U;
#line 505
  index = 0U;
#line 507
  wvalue = (unsigned short )addr;
#line 508
  len = (u16 )length;
#line 509
  __len = (size_t )len;
#line 509
  __ret = __builtin_memcpy((void *)(& buf), (void const   *)pdata, __len);
#line 511
  ret = usbctrl_vendorreq(padapter, (int )request, (int )wvalue, (int )index, (void *)(& buf),
                          (int )len, (int )requesttype);
#line 514
  return (ret);
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
static bool InterruptRecognized8723AU(struct rtw_adapter *Adapter , void *pContent ,
                                      u32 ContentLen ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 *buffer ;
  struct reportpwrstate_parm report ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 542
  pHalData = (struct hal_data_8723a *)Adapter->HalData;
#line 543
  buffer = (u8 *)pContent;
#line 546
  __len = 4UL;
#line 546
  if (__len > 63UL) {
#line 546
    __ret = __memcpy((void *)(& pHalData->IntArray), (void const   *)buffer + 48U,
                     __len);
  } else {
#line 546
    __ret = __builtin_memcpy((void *)(& pHalData->IntArray), (void const   *)buffer + 48U,
                             __len);
  }
#line 548
  pHalData->IntArray[0] = pHalData->IntArray[0] & pHalData->IntrMask[0];
#line 551
  __len___0 = 4UL;
#line 551
  if (__len___0 > 63UL) {
#line 551
    __ret___0 = __memcpy((void *)(& pHalData->IntArray) + 1U, (void const   *)buffer + 52U,
                         __len___0);
  } else {
#line 551
    __ret___0 = __builtin_memcpy((void *)(& pHalData->IntArray) + 1U, (void const   *)buffer + 52U,
                                 __len___0);
  }
#line 553
  pHalData->IntArray[1] = pHalData->IntArray[1] & pHalData->IntrMask[1];
#line 558
  __len___1 = 1UL;
#line 558
  if (__len___1 > 63UL) {
#line 558
    __ret___1 = __memcpy((void *)(& report.state), (void const   *)buffer + 16U, __len___1);
  } else {
#line 558
    __ret___1 = __builtin_memcpy((void *)(& report.state), (void const   *)buffer + 16U,
                                 __len___1);
  }
#line 560
  return ((bool )((pHalData->IntArray[0] & pHalData->IntrMask[0]) != 0U || (pHalData->IntArray[1] & pHalData->IntrMask[1]) != 0U));
}
}
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
static void usb_read_interrupt_complete(struct urb *purb ) 
{ 
  int err ;
  struct rtw_adapter *padapter ;
  struct c2h_evt_hdr *c2h_evt ;
  struct evt_work *c2w ;
  int res ;
  void *tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  size_t __len ;
  void *__ret ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
#line 567
  padapter = (struct rtw_adapter *)purb->context;
#line 569
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bReadPortCancel != 0U) {
#line 571
    if (GlobalDebugLevel23A > 3U) {
#line 571
      printk("\016RTL8723AU: %s() RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
             "usb_read_interrupt_complete", padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel);
    } else {

    }
#line 576
    return;
  } else {

  }
#line 579
  if (purb->status == 0) {
#line 582
    c2h_evt = (struct c2h_evt_hdr *)purb->transfer_buffer;
#line 584
    if (purb->actual_length > 56U) {
#line 585
      if (GlobalDebugLevel23A > 3U) {
#line 585
        printk("\016RTL8723AU: usb_read_interrupt_complete: purb->actual_length > USB_INTR_CONTENT_LENGTH\n");
      } else {

      }
#line 587
      goto urb_submit;
    } else {

    }
#line 590
    InterruptRecognized8723AU(padapter, purb->transfer_buffer, purb->actual_length);
#line 593
    if ((unsigned int )*((unsigned char *)c2h_evt + 0UL) != 0U || (unsigned int )*((unsigned char *)c2h_evt + 0UL) != 0U) {
#line 594
      tmp___1 = c2h_id_filter_ccx_8723a((int )c2h_evt->id);
#line 594
      if ((int )tmp___1) {
#line 596
        handle_txrpt_ccx_8723a(padapter, (void *)(& c2h_evt->payload));
#line 598
        schedule_work(& padapter->evtpriv.irq_wk);
      } else {
#line 603
        tmp = kmalloc(104UL, 32U);
#line 603
        c2w = (struct evt_work *)tmp;
#line 606
        if ((unsigned long )c2w == (unsigned long )((struct evt_work *)0)) {
#line 607
          printk("\f%s: unable to allocate work buffer\n", "usb_read_interrupt_complete");
#line 610
          goto urb_submit;
        } else {

        }
#line 613
        c2w->adapter = padapter;
#line 614
        __init_work(& c2w->work, 0);
#line 614
        __constr_expr_0.counter = 137438953408L;
#line 614
        c2w->work.data = __constr_expr_0;
#line 614
        lockdep_init_map(& c2w->work.lockdep_map, "(&c2w->work)", & __key, 0);
#line 614
        INIT_LIST_HEAD(& c2w->work.entry);
#line 614
        c2w->work.func = & rtw_evt_work;
#line 615
        __len = 16UL;
#line 615
        if (__len > 63UL) {
#line 615
          __ret = __memcpy((void *)(& c2w->u.buf), (void const   *)purb->transfer_buffer,
                           __len);
        } else {
#line 615
          __ret = __builtin_memcpy((void *)(& c2w->u.buf), (void const   *)purb->transfer_buffer,
                                   __len);
        }
#line 617
        tmp___0 = queue_work(padapter->evtpriv.wq, & c2w->work);
#line 617
        res = (int )tmp___0;
#line 620
        if (res == 0) {
#line 621
          printk("\v%s: Call to queue_work() failed\n", "usb_read_interrupt_complete");
#line 624
          kfree((void const   *)c2w);
#line 625
          goto urb_submit;
        } else {

        }
      }
    } else {

    }
    urb_submit: 
#line 631
    err = ldv_usb_submit_urb_2029(purb, 32U);
#line 632
    if (err != 0 && err != -1) {
#line 633
      if (GlobalDebugLevel23A > 3U) {
#line 633
        printk("\016RTL8723AU: cannot submit interrupt in-token(err = 0x%08x), urb_status = %d\n",
               err, purb->status);
      } else {

      }
    } else {

    }
  } else {
#line 638
    if (GlobalDebugLevel23A > 3U) {
#line 638
      printk("\016RTL8723AU: ###=> usb_read_interrupt_complete => urb status(%d)\n",
             purb->status);
    } else {

    }
#line 641
    switch (purb->status) {
    case -22: ;
    case -32: ;
    case -19: ;
    case -108: ;
#line 646
    if (GlobalDebugLevel23A > 3U) {
#line 646
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 646
      printk("\016usb_read_port_complete:bSurpriseRemoved =true\n");
    } else {

    }
    case -2: 
#line 651
    padapter->bDriverStopped = 1;
#line 652
    if (GlobalDebugLevel23A > 3U) {
#line 652
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 652
      printk("\016usb_read_port_complete:bDriverStopped =true\n");
    } else {

    }
#line 655
    goto ldv_54460;
    case -71: ;
#line 657
    goto ldv_54460;
    case -115: ;
#line 659
    if (GlobalDebugLevel23A > 3U) {
#line 659
      printk("\016RTL8723AU: OLD_ERROR: URB IS IN PROGRESS!\n");
    } else {

    }
#line 660
    goto ldv_54460;
    default: ;
#line 662
    goto ldv_54460;
    }
    ldv_54460: ;
  }
#line 666
  return;
}
}
#line 667 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int rtl8723au_read_interrupt(struct rtw_adapter *adapter , u32 addr ) 
{ 
  int err ;
  unsigned int pipe ;
  int ret ;
  struct dvobj_priv *pdvobj ;
  struct recv_priv *precvpriv ;
  struct usb_device *pusbd ;
  unsigned int tmp ;

  {
#line 671
  ret = 1;
#line 672
  pdvobj = adapter->dvobj;
#line 673
  precvpriv = & adapter->recvpriv;
#line 674
  pusbd = pdvobj->pusbdev;
#line 677
  tmp = __create_pipe(pusbd, (unsigned int )pdvobj->RtInPipe[1]);
#line 677
  pipe = tmp | 1073741952U;
#line 679
  usb_fill_int_urb(precvpriv->int_in_urb, pusbd, pipe, (void *)precvpriv->int_in_buf,
                   56, & usb_read_interrupt_complete, (void *)adapter, 1);
#line 683
  err = ldv_usb_submit_urb_2030(precvpriv->int_in_urb, 32U);
#line 684
  if (err != 0 && err != -1) {
#line 685
    if (GlobalDebugLevel23A > 3U) {
#line 685
      printk("\016RTL8723AU: cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",
             err, (precvpriv->int_in_urb)->status);
    } else {

    }
#line 688
    ret = 0;
  } else {

  }
#line 691
  return (ret);
}
}
#line 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
static int recvbuf2recvframe(struct rtw_adapter *padapter , struct sk_buff *pskb ) 
{ 
  u8 *pbuf ;
  u8 shift_sz ;
  u16 pkt_cnt ;
  u32 pkt_offset ;
  u32 skb_len ;
  u32 alloc_sz ;
  int transfer_len ;
  struct recv_stat *prxstat ;
  struct phy_stat *pphy_info ;
  struct sk_buff *pkt_copy ;
  struct recv_frame *precvframe ;
  struct rx_pkt_attrib *pattrib ;
  struct recv_priv *precvpriv ;
  struct rtw_queue *pfree_recv_queue ;
  size_t __len ;
  void *__ret ;
  int tmp ;

  {
#line 697
  shift_sz = 0U;
#line 706
  precvpriv = & padapter->recvpriv;
#line 707
  pfree_recv_queue = & precvpriv->free_recv_queue;
#line 709
  transfer_len = (int )pskb->len;
#line 710
  pbuf = pskb->data;
#line 712
  prxstat = (struct recv_stat *)pbuf;
#line 713
  pkt_cnt = (unsigned int )((u16 )(prxstat->rxdw2 >> 16)) & 255U;
  ldv_54497: ;
#line 716
  if (GlobalDebugLevel23A > 6U) {
#line 716
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 716
    printk("\016recvbuf2recvframe: rxdesc = offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
           prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4);
  } else {

  }
#line 721
  prxstat = (struct recv_stat *)pbuf;
#line 723
  precvframe = rtw_alloc_recvframe23a(pfree_recv_queue);
#line 724
  if ((unsigned long )precvframe == (unsigned long )((struct recv_frame *)0)) {
#line 725
    if (GlobalDebugLevel23A > 3U) {
#line 725
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 725
      printk("\016recvbuf2recvframe: precvframe == NULL\n");
    } else {

    }
#line 727
    if (GlobalDebugLevel23A > 3U) {
#line 727
      printk("\016RTL8723AU: %s()-%d: rtw_alloc_recvframe23a() failed! RX Drop!\n",
             "recvbuf2recvframe", 728);
    } else {

    }
#line 729
    goto _exit_recvbuf2recvframe;
  } else {

  }
#line 732
  INIT_LIST_HEAD(& precvframe->list);
#line 734
  update_recvframe_attrib(precvframe, prxstat);
#line 736
  pattrib = & precvframe->attrib;
#line 738
  if ((unsigned int )pattrib->crc_err != 0U) {
#line 739
    if (GlobalDebugLevel23A > 3U) {
#line 739
      printk("\016RTL8723AU: %s()-%d: RX Warning! rx CRC OLD_ERROR !!\n", "recvbuf2recvframe",
             740);
    } else {

    }
#line 741
    rtw_free_recvframe23a(precvframe);
#line 742
    goto _exit_recvbuf2recvframe;
  } else {

  }
#line 745
  pkt_offset = (u32 )((((int )pattrib->drvinfo_sz + 24) + (int )pattrib->shift_sz) + (int )pattrib->pkt_len);
#line 748
  if ((unsigned int )pattrib->pkt_len == 0U || (u32 )transfer_len < pkt_offset) {
#line 749
    if (GlobalDebugLevel23A > 6U) {
#line 749
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 7);
#line 749
      printk("\016recvbuf2recvframe: pkt_len<= 0\n");
    } else {

    }
#line 751
    if (GlobalDebugLevel23A > 3U) {
#line 751
      printk("\016RTL8723AU: %s()-%d: RX Warning!\n", "recvbuf2recvframe", 752);
    } else {

    }
#line 753
    rtw_free_recvframe23a(precvframe);
#line 754
    goto _exit_recvbuf2recvframe;
  } else {

  }
#line 760
  if ((unsigned int )pattrib->qos != 0U) {
#line 761
    shift_sz = 6U;
  } else {
#line 763
    shift_sz = 0U;
  }
#line 765
  skb_len = (u32 )pattrib->pkt_len;
#line 771
  if ((unsigned int )pattrib->mfrag == 1U && (unsigned int )pattrib->frag_num == 0U) {
#line 773
    if (skb_len <= 1650U) {
#line 774
      alloc_sz = 1664U;
    } else {
#line 776
      alloc_sz = skb_len + 14U;
    }
  } else {
#line 778
    alloc_sz = skb_len;
#line 781
    alloc_sz = alloc_sz + 14U;
  }
#line 784
  pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
#line 785
  if ((unsigned long )pkt_copy != (unsigned long )((struct sk_buff *)0)) {
#line 786
    pkt_copy->dev = padapter->pnetdev;
#line 787
    precvframe->pkt = pkt_copy;
#line 789
    skb_reserve(pkt_copy, (int )(8U - ((unsigned int )((long )pkt_copy->data) & 7U)));
#line 793
    skb_reserve(pkt_copy, (int )shift_sz);
#line 794
    __len = (size_t )skb_len;
#line 794
    __ret = __builtin_memcpy((void *)pkt_copy->data, (void const   *)(pbuf + (((unsigned long )pattrib->shift_sz + (unsigned long )pattrib->drvinfo_sz) + 24UL)),
                             __len);
#line 796
    skb_put(pkt_copy, skb_len);
  } else {
#line 798
    if ((unsigned int )pattrib->mfrag == 1U && (unsigned int )pattrib->frag_num == 0U) {
#line 799
      if (GlobalDebugLevel23A > 3U) {
#line 799
        printk("\016RTL8723AU: recvbuf2recvframe: alloc_skb fail, drop frag frame \n");
      } else {

      }
#line 801
      rtw_free_recvframe23a(precvframe);
#line 802
      goto _exit_recvbuf2recvframe;
    } else {

    }
#line 805
    precvframe->pkt = ldv_skb_clone_2031(pskb, 32U);
#line 806
    if ((unsigned long )precvframe->pkt == (unsigned long )((struct sk_buff *)0)) {
#line 807
      if (GlobalDebugLevel23A > 3U) {
#line 807
        printk("\016RTL8723AU: recvbuf2recvframe: skb_clone fail\n");
      } else {

      }
#line 809
      rtw_free_recvframe23a(precvframe);
#line 810
      goto _exit_recvbuf2recvframe;
    } else {

    }
  }
#line 814
  if ((unsigned int )pattrib->physt != 0U) {
#line 815
    pphy_info = (struct phy_stat *)pbuf + 24U;
#line 816
    update_recvframe_phyinfo(precvframe, pphy_info);
  } else {

  }
#line 819
  tmp = rtw_recv_entry23a(precvframe);
#line 819
  if (tmp != 1) {
#line 820
    if (GlobalDebugLevel23A > 3U) {
#line 820
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4U, 4);
#line 820
      printk("\016recvbuf2recvframe: rtw_recv_entry23a(precvframe) != _SUCCESS\n");
    } else {

    }
  } else {

  }
#line 824
  pkt_cnt = (u16 )((int )pkt_cnt - 1);
#line 825
  transfer_len = (int )((u32 )transfer_len - pkt_offset);
#line 826
  pbuf = pbuf + (unsigned long )pkt_offset;
#line 827
  precvframe = (struct recv_frame *)0;
#line 828
  pkt_copy = (struct sk_buff *)0;
#line 830
  if (transfer_len > 0 && (unsigned int )pkt_cnt == 0U) {
#line 831
    pkt_cnt = (unsigned int )((u16 )(prxstat->rxdw2 >> 16)) & 255U;
  } else {

  }
#line 833
  if (transfer_len > 0 && (unsigned int )pkt_cnt != 0U) {
#line 835
    goto ldv_54497;
  } else {

  }

  _exit_recvbuf2recvframe: ;
#line 837
  return (1);
}
}
#line 840 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void rtl8723au_recv_tasklet(void *priv ) 
{ 
  struct sk_buff *pskb ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;

  {
#line 843
  padapter = (struct rtw_adapter *)priv;
#line 844
  precvpriv = & padapter->recvpriv;
#line 846
  goto ldv_54507;
  ldv_54506: ;
#line 847
  if (padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) {
#line 848
    if (GlobalDebugLevel23A > 3U) {
#line 848
      printk("\016RTL8723AU: recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
    } else {

    }
#line 850
    dev_kfree_skb_any(pskb);
#line 851
    goto ldv_54505;
  } else {

  }
#line 854
  recvbuf2recvframe(padapter, pskb);
#line 855
  skb_reset_tail_pointer(pskb);
#line 857
  pskb->len = 0U;
#line 859
  skb_queue_tail(& precvpriv->free_recv_skb_queue, pskb);
  ldv_54507: 
#line 846
  pskb = skb_dequeue(& precvpriv->rx_skb_queue);
#line 846
  if ((unsigned long )pskb != (unsigned long )((struct sk_buff *)0)) {
#line 848
    goto ldv_54506;
  } else {

  }
  ldv_54505: ;
#line 853
  return;
}
}
#line 863 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
static void usb_read_port_complete(struct urb *purb ) 
{ 
  struct recv_buf *precvbuf ;
  struct rtw_adapter *padapter ;
  struct recv_priv *precvpriv ;
  struct hal_data_8723a *pHalData ;
  __u32 tmp ;
  int tmp___0 ;

  {
#line 865
  precvbuf = (struct recv_buf *)purb->context;
#line 866
  padapter = precvbuf->adapter;
#line 867
  precvpriv = & padapter->recvpriv;
#line 870
  if (GlobalDebugLevel23A > 3U) {
#line 870
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 870
    printk("\016usb_read_port_complete!!!\n");
  } else {

  }
#line 873
  precvpriv->rx_pending_cnt = (u8 )((int )precvpriv->rx_pending_cnt - 1);
#line 875
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bReadPortCancel != 0U) {
#line 877
    if (GlobalDebugLevel23A > 3U) {
#line 877
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 877
      printk("\016usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n",
             padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
#line 882
    if (GlobalDebugLevel23A > 3U) {
#line 882
      printk("\016RTL8723AU: %s()-%d: RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
             "usb_read_port_complete", 885, padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel);
    } else {

    }
#line 886
    return;
  } else {

  }
#line 889
  if (purb->status == 0) {
#line 890
    if (purb->actual_length > 15360U || purb->actual_length <= 23U) {
#line 892
      if (GlobalDebugLevel23A > 3U) {
#line 892
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 892
        printk("\016usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n");
      } else {

      }
#line 896
      rtl8723au_read_port(padapter, 128U, 0U, precvbuf);
#line 898
      if (GlobalDebugLevel23A > 3U) {
#line 898
        printk("\016RTL8723AU: %s()-%d: RX Warning!\n", "usb_read_port_complete",
               899);
      } else {

      }
    } else {
#line 901
      rtw_reset_continual_urb_error(padapter->dvobj);
#line 904
      skb_put(precvbuf->pskb, purb->actual_length);
#line 905
      skb_queue_tail(& precvpriv->rx_skb_queue, precvbuf->pskb);
#line 908
      tmp = skb_queue_len((struct sk_buff_head  const  *)(& precvpriv->rx_skb_queue));
#line 908
      if (tmp <= 1U) {
#line 909
        tasklet_schedule(& precvpriv->recv_tasklet);
      } else {

      }
#line 911
      precvbuf->pskb = (struct sk_buff *)0;
#line 912
      rtl8723au_read_port(padapter, 128U, 0U, precvbuf);
    }
  } else {
#line 916
    if (GlobalDebugLevel23A > 3U) {
#line 916
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 916
      printk("\016usb_read_port_complete : purb->status(%d) != 0 \n", purb->status);
    } else {

    }
#line 919
    skb_put(precvbuf->pskb, purb->actual_length);
#line 920
    precvbuf->pskb = (struct sk_buff *)0;
#line 922
    if (GlobalDebugLevel23A > 3U) {
#line 922
      printk("\016RTL8723AU: ###=> usb_read_port_complete => urb status(%d)\n", purb->status);
    } else {

    }
#line 925
    tmp___0 = rtw_inc_and_chk_continual_urb_error(padapter->dvobj);
#line 925
    if (tmp___0 != 0) {
#line 927
      padapter->bSurpriseRemoved = 1;
    } else {

    }
#line 930
    switch (purb->status) {
    case -22: ;
    case -32: ;
    case -19: ;
    case -108: ;
#line 935
    if (GlobalDebugLevel23A > 3U) {
#line 935
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 935
      printk("\016usb_read_port_complete:bSurpriseRemoved = true\n");
    } else {

    }
    case -2: 
#line 940
    padapter->bDriverStopped = 1;
#line 941
    if (GlobalDebugLevel23A > 3U) {
#line 941
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 941
      printk("\016usb_read_port_complete:bDriverStopped = true\n");
    } else {

    }
#line 944
    goto ldv_54521;
    case -71: ;
    case -75: 
#line 947
    pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 948
    pHalData->srestpriv.Wifi_Error_Status = 2U;
#line 950
    rtl8723au_read_port(padapter, 128U, 0U, precvbuf);
#line 952
    goto ldv_54521;
    case -115: ;
#line 954
    if (GlobalDebugLevel23A > 3U) {
#line 954
      printk("\016RTL8723AU: OLD_ERROR: URB IS IN PROGRESS!\n");
    } else {

    }
#line 955
    goto ldv_54521;
    default: ;
#line 957
    goto ldv_54521;
    }
    ldv_54521: ;
  }
#line 961
  return;
}
}
#line 962 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int rtl8723au_read_port(struct rtw_adapter *adapter , u32 addr , u32 cnt , struct recv_buf *precvbuf ) 
{ 
  int err ;
  unsigned int pipe ;
  unsigned long tmpaddr ;
  unsigned long alignment ;
  int ret ;
  struct urb *purb ;
  struct dvobj_priv *pdvobj ;
  struct recv_priv *precvpriv ;
  struct usb_device *pusbd ;
  unsigned int tmp ;

  {
#line 969
  ret = 1;
#line 971
  pdvobj = adapter->dvobj;
#line 972
  precvpriv = & adapter->recvpriv;
#line 973
  pusbd = pdvobj->pusbdev;
#line 975
  if ((adapter->bDriverStopped != 0 || adapter->bSurpriseRemoved != 0) || (unsigned int )adapter->pwrctrlpriv.pnp_bstop_trx != 0U) {
#line 977
    if (GlobalDebugLevel23A > 3U) {
#line 977
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 977
      printk("\016usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n");
    } else {

    }
#line 981
    return (0);
  } else {

  }
#line 984
  if ((unsigned long )precvbuf == (unsigned long )((struct recv_buf *)0)) {
#line 985
    if (GlobalDebugLevel23A > 3U) {
#line 985
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 985
      printk("\016usb_read_port:precvbuf == NULL\n");
    } else {

    }
#line 987
    return (0);
  } else {

  }
#line 990
  if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
#line 991
    precvbuf->pskb = skb_dequeue(& precvpriv->free_recv_skb_queue);
  } else {

  }
#line 994
  if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
#line 995
    precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, 15368U);
#line 996
    if ((unsigned long )precvbuf->pskb == (unsigned long )((struct sk_buff *)0)) {
#line 997
      if (GlobalDebugLevel23A > 3U) {
#line 997
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 997
        printk("\016init_recvbuf(): alloc_skb fail!\n");
      } else {

      }
#line 998
      return (0);
    } else {

    }
#line 1001
    tmpaddr = (unsigned long )(precvbuf->pskb)->data;
#line 1002
    alignment = tmpaddr & 7UL;
#line 1003
    skb_reserve(precvbuf->pskb, (int )(8U - (unsigned int )alignment));
  } else {

  }
#line 1006
  precvpriv->rx_pending_cnt = (u8 )((int )precvpriv->rx_pending_cnt + 1);
#line 1008
  purb = precvbuf->purb;
#line 1011
  tmp = __create_pipe(pusbd, (unsigned int )pdvobj->RtInPipe[0]);
#line 1011
  pipe = tmp | 3221225600U;
#line 1013
  usb_fill_bulk_urb(purb, pusbd, pipe, (void *)(precvbuf->pskb)->data, 15360, & usb_read_port_complete,
                    (void *)precvbuf);
#line 1017
  err = ldv_usb_submit_urb_2032(purb, 32U);
#line 1018
  if (err != 0 && err != -1) {
#line 1019
    if (GlobalDebugLevel23A > 3U) {
#line 1019
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 1019
      printk("\016cannot submit rx in-token(err = 0x%.8x), URB_STATUS = 0x%.8x", err,
             purb->status);
    } else {

    }
#line 1022
    if (GlobalDebugLevel23A > 3U) {
#line 1022
      printk("\016RTL8723AU: cannot submit rx in-token(err = 0x%08x), urb_status = %d\n",
             err, purb->status);
    } else {

    }
#line 1024
    ret = 0;
  } else {

  }
#line 1026
  return (ret);
}
}
#line 1029 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void rtl8723au_xmit_tasklet(void *priv ) 
{ 
  int ret ;
  struct rtw_adapter *padapter ;
  struct xmit_priv *pxmitpriv ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 1032
  padapter = (struct rtw_adapter *)priv;
#line 1033
  pxmitpriv = & padapter->xmitpriv;
#line 1035
  tmp = check_fwstate(& padapter->mlmepriv, 2048);
#line 1035
  if ((int )tmp) {
#line 1036
    return;
  } else {

  }
  ldv_54548: ;
#line 1039
  if ((padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) || (unsigned int )padapter->bWritePortCancel != 0U) {
#line 1041
    if (GlobalDebugLevel23A > 3U) {
#line 1041
      printk("\016RTL8723AU: xmit_tasklet => bDriverStopped or bSurpriseRemoved or bWritePortCancel\n");
    } else {

    }
#line 1043
    goto ldv_54547;
  } else {

  }
#line 1046
  tmp___0 = rtl8723au_xmitframe_complete(padapter, pxmitpriv, (struct xmit_buf *)0);
#line 1046
  ret = (int )tmp___0;
#line 1048
  if (ret == 0) {
#line 1049
    goto ldv_54547;
  } else {

  }
#line 1050
  goto ldv_54548;
  ldv_54547: ;
#line 1052
  return;
}
}
#line 1053 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void rtl8723au_set_hw_type(struct rtw_adapter *padapter ) 
{ 


  {
#line 1055
  padapter->chip_type = 4U;
#line 1056
  padapter->HardwareType = 14U;
#line 1057
  if (GlobalDebugLevel23A > 3U) {
#line 1057
    printk("\016RTL8723AU: CHIP TYPE: RTL8723A\n");
  } else {

  }
#line 1058
  return;
}
}
#line 1187 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
void *ldv_kmem_cache_alloc_2012(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1190
  ldv_check_alloc_flags(flags);
#line 1192
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1193
  return ((void *)0);
}
}
#line 1231 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int ldv_pskb_expand_head_2018(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1234
  ldv_check_alloc_flags(flags);
#line 1236
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1236
  return (tmp);
}
}
#line 1247 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2020(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1250
  ldv_check_alloc_flags(flags);
#line 1252
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1252
  return (tmp);
}
}
#line 1263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv_skb_copy_2022(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1266
  ldv_check_alloc_flags(flags);
#line 1268
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1268
  return (tmp);
}
}
#line 1271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2023(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1274
  ldv_check_alloc_flags(flags);
#line 1276
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1276
  return (tmp);
}
}
#line 1279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2024(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1282
  ldv_check_alloc_flags(flags);
#line 1284
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1284
  return (tmp);
}
}
#line 1287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2025(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1290
  ldv_check_alloc_flags(flags);
#line 1292
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1292
  return (tmp);
}
}
#line 1295 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int ldv_pskb_expand_head_2026(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1298
  ldv_check_alloc_flags(flags);
#line 1300
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1300
  return (tmp);
}
}
#line 1303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int ldv_pskb_expand_head_2027(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1306
  ldv_check_alloc_flags(flags);
#line 1308
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1308
  return (tmp);
}
}
#line 1311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2028(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1314
  ldv_check_alloc_flags(flags);
#line 1316
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1316
  return (tmp);
}
}
#line 1319 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int ldv_usb_submit_urb_2029(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1322
  ldv_check_alloc_flags(flags);
#line 1324
  tmp = usb_submit_urb(ldv_func_arg1, flags);
#line 1324
  return (tmp);
}
}
#line 1327 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int ldv_usb_submit_urb_2030(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1330
  ldv_check_alloc_flags(flags);
#line 1332
  tmp = usb_submit_urb(ldv_func_arg1, flags);
#line 1332
  return (tmp);
}
}
#line 1335 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2031(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1338
  ldv_check_alloc_flags(flags);
#line 1340
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1340
  return (tmp);
}
}
#line 1343 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/usb_ops_linux.o.c.prepared"
int ldv_usb_submit_urb_2032(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1346
  ldv_check_alloc_flags(flags);
#line 1348
  tmp = usb_submit_urb(ldv_func_arg1, flags);
#line 1348
  return (tmp);
}
}
#line 64 "./arch/x86/include/asm/string_64.h"
extern int strcmp(char const   * , char const   * ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 


  {
#line 25
  return ((void *)error);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2062(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 21 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/sv-comp.h"
extern u32 __VERIFIER_nondet_u32(void) ;
#line 22
extern u16 __VERIFIER_nondet_u16(void) ;
#line 23
extern u8 __VERIFIER_nondet_u8(void) ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct wiphy *rtw_cfg80211_ops_group1 ;
#line 32
int ldv_state_variable_14 ;
#line 46
int ref_cnt ;
#line 50
struct station_parameters *rtw_cfg80211_ops_group2 ;
#line 63
struct station_info *rtw_cfg80211_ops_group3 ;
#line 65
int usb_counter ;
#line 71
struct vif_params *rtw_cfg80211_ops_group5 ;
#line 87
int ldv_state_variable_15 ;
#line 105
struct net_device *rtw_cfg80211_ops_group6 ;
#line 111
struct wireless_dev *rtw_cfg80211_ops_group0 ;
#line 118
struct net_device *rtw_cfg80211_monitor_if_ops_group1 ;
#line 129
struct cfg80211_pmksa *rtw_cfg80211_ops_group4 ;
#line 150
void ldv_net_device_ops_15(void) ;
#line 162
void ldv_initialize_cfg80211_ops_14(void) ;
#line 806 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 809
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 810
    return ((char const   *)dev->init_name);
  } else {

  }
#line 812
  tmp = kobject_name(& dev->kobj);
#line 812
  return (tmp);
}
}
#line 717 "include/linux/skbuff.h"
extern void consume_skb(struct sk_buff * ) ;
#line 759
struct sk_buff *ldv_skb_clone_2070(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2078(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_2072(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_2068(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2076(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2077(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2073(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2074(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2075(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 1687 "include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1689
  return ((void *)dev + 3264U);
}
}
#line 1966
extern int register_netdevice(struct net_device * ) ;
#line 1967
extern void unregister_netdevice_queue(struct net_device * , struct list_head * ) ;
#line 1969 "include/linux/netdevice.h"
__inline static void unregister_netdevice(struct net_device *dev ) 
{ 


  {
#line 1971
  unregister_netdevice_queue(dev, (struct list_head *)0);
#line 1972
  return;
}
}
#line 1975
extern void free_netdev(struct net_device * ) ;
#line 1978
void ldv_free_netdev_2079(struct net_device *dev ) ;
#line 2999
extern void unregister_netdev(struct net_device * ) ;
#line 3002
void ldv_unregister_netdev_2080(struct net_device *dev ) ;
#line 49 "include/linux/etherdevice.h"
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
#line 189 "include/linux/etherdevice.h"
__inline static void eth_broadcast_addr(u8 *addr ) 
{ 


  {
#line 191
  memset((void *)addr, 255, 6UL);
#line 192
  return;
}
}
#line 200 "include/linux/etherdevice.h"
__inline static void eth_zero_addr(u8 *addr ) 
{ 


  {
#line 202
  memset((void *)addr, 0, 6UL);
#line 203
  return;
}
}
#line 325 "include/net/ieee80211_radiotap.h"
__inline static int ieee80211_get_radiotap_len(unsigned char *data ) 
{ 
  struct ieee80211_radiotap_header *hdr ;
  u16 tmp ;

  {
#line 327
  hdr = (struct ieee80211_radiotap_header *)data;
#line 330
  tmp = get_unaligned_le16((void const   *)(& hdr->it_len));
#line 330
  return ((int )tmp);
}
}
#line 497 "include/linux/ieee80211.h"
__inline static int ieee80211_is_action(__le16 fc ) 
{ 


  {
#line 499
  return (((int )fc & 252) == 208);
}
}
#line 3109 "include/net/cfg80211.h"
__inline static void *wiphy_priv___1(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
#line 3111
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
#line 3111
  if (tmp != 0L) {
#line 3111
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3111), "i" (12UL));
    ldv_45899: ;
#line 3111
    goto ldv_45899;
  } else {

  }
#line 3112
  return ((void *)(& wiphy->priv));
}
}
#line 3133 "include/net/cfg80211.h"
__inline static void set_wiphy_dev(struct wiphy *wiphy , struct device *dev ) 
{ 


  {
#line 3135
  wiphy->dev.parent = dev;
#line 3136
  return;
}
}
#line 3155 "include/net/cfg80211.h"
__inline static char const   *wiphy_name(struct wiphy  const  *wiphy ) 
{ 
  char const   *tmp ;

  {
#line 3157
  tmp = dev_name(& wiphy->dev);
#line 3157
  return (tmp);
}
}
#line 3172
extern struct wiphy *wiphy_new(struct cfg80211_ops  const  * , int  ) ;
#line 3181
extern int wiphy_register(struct wiphy * ) ;
#line 3192
extern void wiphy_unregister(struct wiphy * ) ;
#line 3199
extern void wiphy_free(struct wiphy * ) ;
#line 3341 "include/net/cfg80211.h"
__inline static void *wdev_priv___1(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 3343
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
#line 3343
  if (tmp != 0L) {
#line 3343
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3343), "i" (12UL));
    ldv_45979: ;
#line 3343
    goto ldv_45979;
  } else {

  }
#line 3344
  tmp___0 = wiphy_priv___1(wdev->wiphy);
#line 3344
  return (tmp___0);
}
}
#line 3359
extern int ieee80211_channel_to_frequency(int  , enum ieee80211_band  ) ;
#line 3366
extern int ieee80211_frequency_to_channel(int  ) ;
#line 3375
extern struct ieee80211_channel *__ieee80211_get_channel(struct wiphy * , int  ) ;
#line 3384 "include/net/cfg80211.h"
__inline static struct ieee80211_channel *ieee80211_get_channel(struct wiphy *wiphy ,
                                                                int freq ) 
{ 
  struct ieee80211_channel *tmp ;

  {
#line 3386
  tmp = __ieee80211_get_channel(wiphy, freq);
#line 3386
  return (tmp);
}
}
#line 3720
extern void cfg80211_scan_done(struct cfg80211_scan_request * , bool  ) ;
#line 3770
extern struct cfg80211_bss *cfg80211_inform_bss_width_frame(struct wiphy * , struct ieee80211_channel * ,
                                                            enum nl80211_bss_scan_width  ,
                                                            struct ieee80211_mgmt * ,
                                                            size_t  , s32  , gfp_t  ) ;
#line 3777 "include/net/cfg80211.h"
__inline static struct cfg80211_bss *cfg80211_inform_bss_frame(struct wiphy *wiphy ,
                                                               struct ieee80211_channel *rx_channel ,
                                                               struct ieee80211_mgmt *mgmt ,
                                                               size_t len , s32 signal ,
                                                               gfp_t gfp ) 
{ 
  struct cfg80211_bss *tmp ;

  {
#line 3782
  tmp = cfg80211_inform_bss_width_frame(wiphy, rx_channel, 0, mgmt, len, signal, gfp);
#line 3782
  return (tmp);
}
}
#line 3860
extern void cfg80211_put_bss(struct wiphy * , struct cfg80211_bss * ) ;
#line 4296
extern void cfg80211_connect_result(struct net_device * , u8 const   * , u8 const   * ,
                                    size_t  , u8 const   * , size_t  , u16  , gfp_t  ) ;
#line 4316
extern void cfg80211_roamed(struct net_device * , struct ieee80211_channel * , u8 const   * ,
                            u8 const   * , size_t  , u8 const   * , size_t  , gfp_t  ) ;
#line 4360
extern void cfg80211_disconnected(struct net_device * , u16  , u8 const   * , size_t  ,
                                  gfp_t  ) ;
#line 4445
extern bool cfg80211_rx_mgmt(struct wireless_dev * , int  , int  , u8 const   * ,
                             size_t  , u32  , gfp_t  ) ;
#line 4461
extern void cfg80211_mgmt_tx_status(struct wireless_dev * , u64  , u8 const   * ,
                                    size_t  , bool  , gfp_t  ) ;
#line 24 "drivers/staging/rtl8723au/include/xmit_osdep.h"
int rtw_xmit23a_entry23a(struct sk_buff *skb , struct net_device *pnetdev ) ;
#line 42 "drivers/staging/rtl8723au/include/osdep_intf.h"
void rtw_ndev_destructor(struct net_device *ndev ) ;
#line 35 "drivers/staging/rtl8723au/include/rtw_ap.h"
int rtw_check_beacon_data23a(struct rtw_adapter *padapter , u8 *pbuf , unsigned int len ) ;
#line 47
int rtw_sta_flush23a(struct rtw_adapter *padapter ) ;
#line 49
void start_ap_mode23a(struct rtw_adapter *padapter ) ;
#line 50
void stop_ap_mode23a(struct rtw_adapter *padapter ) ;
#line 44 "drivers/staging/rtl8723au/include/ioctl_cfg80211.h"
int rtw_wdev_alloc(struct rtw_adapter *padapter , struct device *dev ) ;
#line 45
void rtw_wdev_free(struct wireless_dev *wdev ) ;
#line 46
void rtw_wdev_unregister(struct wireless_dev *wdev ) ;
#line 48
void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter ) ;
#line 60
void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter , unsigned char *da ,
                                        unsigned short reason ) ;
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static u32 const   rtw_cipher_suites[4U]  = {      1027073U,      1027077U,      1027074U,      1027076U};
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static struct ieee80211_rate rtw_rates[12U]  = 
#line 280
  {      {0U, 10U, 1U, (unsigned short)0}, 
        {0U, 20U, 2U, (unsigned short)0}, 
        {0U, 55U, 4U, (unsigned short)0}, 
        {0U, 110U, 8U, (unsigned short)0}, 
        {0U, 60U, 16U, (unsigned short)0}, 
        {0U, 90U, 32U, (unsigned short)0}, 
        {0U, 120U, 64U, (unsigned short)0}, 
        {0U, 180U, 128U, (unsigned short)0}, 
        {0U, 240U, 256U, (unsigned short)0}, 
        {0U, 360U, 512U, (unsigned short)0}, 
        {0U, 480U, 1024U, (unsigned short)0}, 
        {0U, 540U, 2048U, (unsigned short)0}};
#line 303 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static struct ieee80211_channel rtw_2ghz_channels[14U]  = 
#line 303
  {      {0, 2412U, 1U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2417U, 2U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2422U, 3U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2427U, 4U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2432U, 5U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2437U, 6U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2442U, 7U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2447U, 8U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2452U, 9U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2457U, 10U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2462U, 11U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2467U, 12U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2472U, 13U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {0, 2484U, 14U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}};
#line 320 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static struct ieee80211_channel rtw_5ghz_a_channels[37U]  = 
#line 320
  {      {1, 5170U, 34U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5180U, 36U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5190U, 38U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5200U, 40U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5210U, 42U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5220U, 44U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5230U, 46U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5240U, 48U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5260U, 52U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5280U, 56U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5300U, 60U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5320U, 64U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5500U, 100U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5520U, 104U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5540U, 108U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5560U, 112U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5580U, 116U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5600U, 120U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5620U, 124U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5640U, 128U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5660U, 132U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5680U, 136U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5700U, 140U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5745U, 149U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5765U, 153U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5785U, 157U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5805U, 161U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5825U, 165U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5920U, 184U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5940U, 188U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5960U, 192U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 5980U, 196U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6000U, 200U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6020U, 204U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6040U, 208U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6060U, 212U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}, 
        {1, 6080U, 216U, 0U, 0, 30, 0, (_Bool)0, 0U, 0, 0, 0, 0UL, 0U}};
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static void rtw_2g_channels_init(struct ieee80211_channel *channels ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 344
  __len = 896UL;
#line 344
  if (__len > 63UL) {
#line 344
    __ret = __memcpy((void *)channels, (void const   *)(& rtw_2ghz_channels), __len);
  } else {
#line 344
    __ret = __builtin_memcpy((void *)channels, (void const   *)(& rtw_2ghz_channels),
                             __len);
  }
#line 346
  return;
}
}
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static void rtw_5g_channels_init(struct ieee80211_channel *channels ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 350
  __len = 2368UL;
#line 350
  if (__len > 63UL) {
#line 350
    __ret = __memcpy((void *)channels, (void const   *)(& rtw_5ghz_a_channels), __len);
  } else {
#line 350
    __ret = __builtin_memcpy((void *)channels, (void const   *)(& rtw_5ghz_a_channels),
                             __len);
  }
#line 352
  return;
}
}
#line 354 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static void rtw_2g_rates_init(struct ieee80211_rate *rates ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 356
  __len = 144UL;
#line 356
  if (__len > 63UL) {
#line 356
    __ret = __memcpy((void *)rates, (void const   *)(& rtw_rates), __len);
  } else {
#line 356
    __ret = __builtin_memcpy((void *)rates, (void const   *)(& rtw_rates), __len);
  }
#line 358
  return;
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static void rtw_5g_rates_init(struct ieee80211_rate *rates ) 
{ 
  size_t __len ;
  void *__ret ;

  {
#line 362
  __len = 96UL;
#line 362
  if (__len > 63UL) {
#line 362
    __ret = __memcpy((void *)rates, (void const   *)(& rtw_rates) + 4U, __len);
  } else {
#line 362
    __ret = __builtin_memcpy((void *)rates, (void const   *)(& rtw_rates) + 4U, __len);
  }
#line 364
  return;
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static struct ieee80211_supported_band *rtw_spt_band_alloc(enum ieee80211_band band ) 
{ 
  struct ieee80211_supported_band *spt_band ;
  int n_channels ;
  int n_bitrates ;
  void *tmp ;

  {
#line 369
  spt_band = (struct ieee80211_supported_band *)0;
#line 372
  if ((unsigned int )band == 0U) {
#line 373
    n_channels = 14;
#line 374
    n_bitrates = 12;
  } else
#line 375
  if ((unsigned int )band == 1U) {
#line 376
    n_channels = 37;
#line 377
    n_bitrates = 8;
  } else {
#line 379
    goto exit;
  }
#line 381
  tmp = kzalloc(((unsigned long )n_channels * 64UL + (unsigned long )n_bitrates * 12UL) + 72UL,
                208U);
#line 381
  spt_band = (struct ieee80211_supported_band *)tmp;
#line 385
  if ((unsigned long )spt_band == (unsigned long )((struct ieee80211_supported_band *)0)) {
#line 386
    goto exit;
  } else {

  }
#line 388
  spt_band->channels = (struct ieee80211_channel *)spt_band + 72U;
#line 392
  spt_band->bitrates = (struct ieee80211_rate *)spt_band->channels + (unsigned long )n_channels * 64UL;
#line 396
  spt_band->band = band;
#line 397
  spt_band->n_channels = n_channels;
#line 398
  spt_band->n_bitrates = n_bitrates;
#line 400
  if ((unsigned int )band == 0U) {
#line 401
    rtw_2g_channels_init(spt_band->channels);
#line 402
    rtw_2g_rates_init(spt_band->bitrates);
  } else
#line 403
  if ((unsigned int )band == 1U) {
#line 404
    rtw_5g_channels_init(spt_band->channels);
#line 405
    rtw_5g_rates_init(spt_band->bitrates);
  } else {

  }
  exit: ;
#line 411
  return (spt_band);
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static struct ieee80211_txrx_stypes  const  rtw_cfg80211_default_mgmt_stypes[11U]  = 
#line 415
  {      {(unsigned short)0, (unsigned short)0}, 
        {65535U, 8192U}, 
        {65535U, 8208U}, 
        {65535U, 15381U}, 
        {65535U, 15381U}, 
        {(unsigned short)0, (unsigned short)0}, 
        {(unsigned short)0, (unsigned short)0}, 
        {(unsigned short)0, (unsigned short)0}, 
        {65535U, 8208U}, 
        {65535U, 15381U}};
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_inform_bss(struct rtw_adapter *padapter , struct wlan_network *pnetwork ) 
{ 
  int ret ;
  struct ieee80211_channel *notify_channel ;
  struct cfg80211_bss *bss ;
  u16 channel ;
  u32 freq ;
  u64 notify_timestamp ;
  u16 notify_capability ;
  u16 notify_interval ;
  u8 *notify_ie ;
  size_t notify_ielen ;
  s32 notify_signal ;
  u8 buf[1000U] ;
  u8 *pbuf ;
  size_t len ;
  struct ieee80211_hdr *pwlanhdr ;
  struct wireless_dev *wdev ;
  struct wiphy *wiphy ;
  struct mlme_priv *pmlmepriv ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  __le16 *tmp___2 ;
  __le16 *tmp___3 ;
  s32 tmp___4 ;
  s32 tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  u8 *tmp___8 ;
  size_t __len ;
  void *__ret ;
  long tmp___9 ;

  {
#line 467
  ret = 0;
#line 482
  wdev = padapter->rtw_wdev;
#line 483
  wiphy = wdev->wiphy;
#line 484
  pmlmepriv = & padapter->mlmepriv;
#line 488
  if (pnetwork->network.IELength > 768U) {
#line 489
    if (GlobalDebugLevel23A > 3U) {
#line 489
      printk("\016RTL8723AU: %s IE Length too long > %d byte\n", "rtw_cfg80211_inform_bss",
             768);
    } else {

    }
#line 491
    goto exit;
  } else {

  }
#line 494
  channel = (u16 )pnetwork->network.DSConfig;
#line 495
  if ((unsigned int )channel <= 14U) {
#line 496
    tmp = ieee80211_channel_to_frequency((int )channel, 0);
#line 496
    freq = (u32 )tmp;
  } else {
#line 499
    tmp___0 = ieee80211_channel_to_frequency((int )channel, 1);
#line 499
    freq = (u32 )tmp___0;
  }
#line 502
  notify_channel = ieee80211_get_channel(wiphy, (int )freq);
#line 504
  tmp___1 = jiffies_to_msecs(jiffies);
#line 504
  notify_timestamp = (u64 )(tmp___1 * 1000U);
#line 506
  tmp___2 = rtw_get_beacon_interval23a_from_ie((u8 *)(& pnetwork->network.IEs));
#line 506
  notify_interval = get_unaligned_le16((void const   *)tmp___2);
#line 509
  tmp___3 = rtw_get_capability23a_from_ie((u8 *)(& pnetwork->network.IEs));
#line 509
  notify_capability = get_unaligned_le16((void const   *)tmp___3);
#line 513
  notify_ie = (u8 *)(& pnetwork->network.IEs) + 12UL;
#line 514
  notify_ielen = (size_t )(pnetwork->network.IELength - 12U);
#line 519
  tmp___6 = check_fwstate(pmlmepriv, 1);
#line 519
  if ((int )tmp___6) {
#line 519
    tmp___7 = is_same_network23a(& pmlmepriv->cur_network.network, & pnetwork->network);
#line 519
    if (tmp___7 != 0) {
#line 522
      tmp___4 = translate_percentage_to_dbm((u32 )padapter->recvpriv.signal_strength);
#line 522
      notify_signal = tmp___4 * 100;
    } else {
#line 524
      tmp___5 = translate_percentage_to_dbm((u32 )pnetwork->network.PhyInfo.SignalStrength);
#line 524
      notify_signal = tmp___5 * 100;
    }
  } else {
#line 524
    tmp___5 = translate_percentage_to_dbm((u32 )pnetwork->network.PhyInfo.SignalStrength);
#line 524
    notify_signal = tmp___5 * 100;
  }
#line 526
  pbuf = (u8 *)(& buf);
#line 528
  pwlanhdr = (struct ieee80211_hdr *)pbuf;
#line 530
  pwlanhdr->seq_ctrl = 0U;
#line 532
  if ((unsigned int )pnetwork->network.reserved == 1U) {
#line 533
    eth_broadcast_addr((u8 *)(& pwlanhdr->addr1));
#line 534
    pwlanhdr->frame_control = 128U;
  } else {
#line 537
    tmp___8 = myid(& padapter->eeprompriv);
#line 537
    ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)tmp___8);
#line 538
    pwlanhdr->frame_control = 80U;
  }
#line 543
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)(& pnetwork->network.MacAddress));
#line 544
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)(& pnetwork->network.MacAddress));
#line 546
  pbuf = pbuf + 24UL;
#line 547
  len = 24UL;
#line 549
  __len = (size_t )pnetwork->network.IELength;
#line 549
  __ret = __builtin_memcpy((void *)pbuf, (void const   *)(& pnetwork->network.IEs),
                           __len);
#line 550
  len = (size_t )pnetwork->network.IELength + len;
#line 552
  bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)(& buf),
                                  len, notify_signal, 32U);
#line 556
  tmp___9 = ldv__builtin_expect((unsigned long )bss == (unsigned long )((struct cfg80211_bss *)0),
                             0L);
#line 556
  if (tmp___9 != 0L) {
#line 557
    if (GlobalDebugLevel23A > 3U) {
#line 557
      printk("\016RTL8723AU: rtw_cfg80211_inform_bss error\n");
    } else {

    }
#line 558
    return (-22);
  } else {

  }
#line 561
  cfg80211_put_bss(wiphy, bss);
  exit: ;
#line 564
  return (ret);
}
}
#line 567 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  struct wireless_dev *pwdev ;
  bool tmp ;
  struct wiphy *wiphy ;
  struct ieee80211_channel *notify_channel ;
  u32 freq ;
  u16 channel ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 569
  pmlmepriv = & padapter->mlmepriv;
#line 570
  cur_network = & pmlmepriv->cur_network;
#line 571
  pwdev = padapter->rtw_wdev;
#line 573
  if (GlobalDebugLevel23A > 3U) {
#line 573
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_cfg80211_indicate_connect", padapter);
  } else {

  }
#line 575
  if ((unsigned int )pwdev->iftype != 2U && (unsigned int )pwdev->iftype != 8U) {
#line 577
    return;
  } else {

  }
#line 579
  tmp = check_fwstate(pmlmepriv, 16);
#line 579
  if ((int )tmp) {
#line 580
    return;
  } else {

  }
#line 582
  if ((unsigned int )padapter->mlmepriv.to_roaming != 0U) {
#line 583
    wiphy = pwdev->wiphy;
#line 586
    channel = (u16 )cur_network->network.DSConfig;
#line 588
    if ((unsigned int )channel <= 14U) {
#line 589
      tmp___0 = ieee80211_channel_to_frequency((int )channel, 0);
#line 589
      freq = (u32 )tmp___0;
    } else {
#line 593
      tmp___1 = ieee80211_channel_to_frequency((int )channel, 1);
#line 593
      freq = (u32 )tmp___1;
    }
#line 597
    notify_channel = ieee80211_get_channel(wiphy, (int )freq);
#line 599
    if (GlobalDebugLevel23A > 3U) {
#line 599
      printk("\016RTL8723AU: %s call cfg80211_roamed\n", "rtw_cfg80211_indicate_connect");
    } else {

    }
#line 600
    cfg80211_roamed(padapter->pnetdev, notify_channel, (u8 const   *)(& cur_network->network.MacAddress),
                    (u8 const   *)pmlmepriv->assoc_req + 26U, (unsigned long )pmlmepriv->assoc_req_len - 26UL,
                    (u8 const   *)pmlmepriv->assoc_rsp + 30U, (unsigned long )pmlmepriv->assoc_rsp_len - 30UL,
                    32U);
  } else {
#line 612
    cfg80211_connect_result(padapter->pnetdev, (u8 const   *)(& cur_network->network.MacAddress),
                            (u8 const   *)pmlmepriv->assoc_req + 26U, (unsigned long )pmlmepriv->assoc_req_len - 26UL,
                            (u8 const   *)pmlmepriv->assoc_rsp + 30U, (unsigned long )pmlmepriv->assoc_rsp_len - 30UL,
                            0, 32U);
  }
#line 622
  return;
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wireless_dev *pwdev ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 628
  pmlmepriv = & padapter->mlmepriv;
#line 629
  pwdev = padapter->rtw_wdev;
#line 631
  if (GlobalDebugLevel23A > 3U) {
#line 631
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_cfg80211_indicate_disconnect",
           padapter);
  } else {

  }
#line 633
  if ((unsigned int )pwdev->iftype != 2U && (unsigned int )pwdev->iftype != 8U) {
#line 635
    return;
  } else {

  }
#line 637
  tmp = check_fwstate(pmlmepriv, 16);
#line 637
  if ((int )tmp) {
#line 638
    return;
  } else {

  }
#line 640
  if ((unsigned int )padapter->mlmepriv.not_indic_disco == 0U) {
#line 641
    tmp___0 = check_fwstate(& padapter->mlmepriv, 128);
#line 641
    if ((int )tmp___0) {
#line 642
      cfg80211_connect_result(padapter->pnetdev, (u8 const   *)0U, (u8 const   *)0U,
                              0UL, (u8 const   *)0U, 0UL, 1, 32U);
    } else {
#line 647
      cfg80211_disconnected(padapter->pnetdev, 0, (u8 const   *)0U, 0UL, 32U);
    }
  } else {

  }
#line 648
  return;
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int set_pairwise_key(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct cmd_obj *ph2c ;
  struct set_stakey_parm *psetstakey_para ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 658
  pcmdpriv = & padapter->cmdpriv;
#line 659
  res = 1;
#line 661
  tmp = kzalloc(128UL, 208U);
#line 661
  ph2c = (struct cmd_obj *)tmp;
#line 662
  if ((unsigned long )ph2c == (unsigned long )((struct cmd_obj *)0)) {
#line 663
    res = 0;
#line 664
    goto exit;
  } else {

  }
#line 667
  tmp___0 = kzalloc(28UL, 208U);
#line 667
  psetstakey_para = (struct set_stakey_parm *)tmp___0;
#line 668
  if ((unsigned long )psetstakey_para == (unsigned long )((struct set_stakey_parm *)0)) {
#line 669
    kfree((void const   *)ph2c);
#line 670
    res = 0;
#line 671
    goto exit;
  } else {

  }
#line 674
  ph2c->cmdcode = 21U;
#line 674
  ph2c->parmbuf = (u8 *)psetstakey_para;
#line 674
  ph2c->cmdsz = 28U;
#line 674
  ph2c->rsp = (u8 *)0U;
#line 674
  ph2c->rspsz = 0U;
#line 676
  psetstakey_para->algorithm = psta->dot118021XPrivacy;
#line 678
  ether_addr_copy((u8 *)(& psetstakey_para->addr), (u8 const   *)(& psta->hwaddr));
#line 680
  __len = 16UL;
#line 680
  if (__len > 63UL) {
#line 680
    __ret = __memcpy((void *)(& psetstakey_para->key), (void const   *)(& psta->dot118021x_UncstKey),
                     __len);
  } else {
#line 680
    __ret = __builtin_memcpy((void *)(& psetstakey_para->key), (void const   *)(& psta->dot118021x_UncstKey),
                             __len);
  }
#line 682
  res = rtw_enqueue_cmd23a(pcmdpriv, ph2c);
  exit: ;
#line 685
  return (res);
}
}
#line 688 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int set_group_key(struct rtw_adapter *padapter , u8 *key , u32 alg , u8 keyid ) 
{ 
  u8 keylen ;
  struct cmd_obj *pcmd ;
  struct setkey_parm *psetkeyparm ;
  struct cmd_priv *pcmdpriv ;
  int res ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
#line 694
  pcmdpriv = & padapter->cmdpriv;
#line 695
  res = 1;
#line 697
  if (GlobalDebugLevel23A > 3U) {
#line 697
    printk("\016RTL8723AU: %s\n", "set_group_key");
  } else {

  }
#line 699
  if ((unsigned int )keyid > 3U) {
#line 700
    res = 0;
#line 701
    goto exit;
  } else {

  }
#line 704
  tmp = kzalloc(128UL, 208U);
#line 704
  pcmd = (struct cmd_obj *)tmp;
#line 705
  if ((unsigned long )pcmd == (unsigned long )((struct cmd_obj *)0)) {
#line 706
    res = 0;
#line 707
    goto exit;
  } else {

  }
#line 709
  tmp___0 = kzalloc(24UL, 208U);
#line 709
  psetkeyparm = (struct setkey_parm *)tmp___0;
#line 710
  if ((unsigned long )psetkeyparm == (unsigned long )((struct setkey_parm *)0)) {
#line 711
    kfree((void const   *)pcmd);
#line 712
    res = 0;
#line 713
    goto exit;
  } else {

  }
#line 716
  psetkeyparm->keyid = keyid;
#line 717
  if (alg == 1027073U || alg == 1027077U) {
#line 718
    padapter->mlmepriv.key_mask = (int )padapter->mlmepriv.key_mask | (int )((u8 )(1UL << (int )psetkeyparm->keyid));
  } else {

  }
#line 720
  psetkeyparm->algorithm = alg;
#line 722
  psetkeyparm->set_tx = 1U;
#line 724
  switch (alg) {
  case 1027073U: 
#line 726
  keylen = 5U;
#line 727
  goto ldv_51540;
  case 1027077U: 
#line 729
  keylen = 13U;
#line 730
  goto ldv_51540;
  case 1027074U: ;
  case 1027076U: ;
  default: 
#line 734
  keylen = 16U;
  }
  ldv_51540: 
#line 737
  __len = (size_t )keylen;
#line 737
  __ret = __builtin_memcpy((void *)(& psetkeyparm->key), (void const   *)key, __len);
#line 739
  pcmd->cmdcode = 20U;
#line 740
  pcmd->parmbuf = (u8 *)psetkeyparm;
#line 741
  pcmd->cmdsz = 24U;
#line 742
  pcmd->rsp = (u8 *)0U;
#line 743
  pcmd->rspsz = 0U;
#line 745
  res = rtw_enqueue_cmd23a(pcmdpriv, pcmd);
  exit: ;
#line 748
  return (res);
}
}
#line 751 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int set_wep_key(struct rtw_adapter *padapter , u8 *key , u16 keylen , u8 keyid ) 
{ 
  u32 alg ;
  int tmp ;

  {
#line 756
  switch ((int )keylen) {
  case 5: 
#line 758
  alg = 1027073U;
#line 759
  goto ldv_51556;
  case 13: 
#line 761
  alg = 1027077U;
#line 762
  goto ldv_51556;
  default: 
#line 764
  alg = 0U;
  }
  ldv_51556: 
#line 767
  tmp = set_group_key(padapter, key, alg, (int )keyid);
#line 767
  return (tmp);
}
}
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_ap_set_encryption(struct net_device *dev , struct ieee_param *param ,
                                          u32 param_len ) 
{ 
  int ret ;
  u16 wep_key_len ;
  u8 wep_key_idx ;
  struct sta_info *psta ;
  struct sta_info *pbcmc_sta ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct sta_priv *pstapriv ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  int tmp___2 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  size_t __len___5 ;
  void *__ret___5 ;
  size_t __len___6 ;
  void *__ret___6 ;
  size_t __len___7 ;
  void *__ret___7 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __len___8 ;
  void *__ret___8 ;
  size_t __len___9 ;
  void *__ret___9 ;
  size_t __len___10 ;
  void *__ret___10 ;
  size_t __len___11 ;
  void *__ret___11 ;
  size_t __len___12 ;
  void *__ret___12 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;

  {
#line 774
  ret = 0;
#line 777
  psta = (struct sta_info *)0;
#line 777
  pbcmc_sta = (struct sta_info *)0;
#line 778
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 778
  padapter = (struct rtw_adapter *)tmp;
#line 779
  pmlmepriv = & padapter->mlmepriv;
#line 780
  psecuritypriv = & padapter->securitypriv;
#line 781
  pstapriv = & padapter->stapriv;
#line 783
  if (GlobalDebugLevel23A > 3U) {
#line 783
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_ap_set_encryption");
  } else {

  }
#line 785
  param->u.crypt.err = 0U;
#line 786
  param->u.crypt.alg[15] = 0U;
#line 791
  if ((unsigned long )param_len != (unsigned long )param->u.crypt.key_len + 64UL) {
#line 792
    ret = -22;
#line 793
    goto exit;
  } else {

  }
#line 796
  tmp___0 = is_broadcast_ether_addr((u8 const   *)(& param->sta_addr));
#line 796
  if ((int )tmp___0) {
#line 797
    if ((unsigned int )param->u.crypt.idx > 3U) {
#line 798
      ret = -22;
#line 799
      goto exit;
    } else {

    }
  } else {
#line 802
    psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& param->sta_addr));
#line 803
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 805
      if (GlobalDebugLevel23A > 3U) {
#line 805
        printk("\016RTL8723AU: rtw_set_encryption(), sta has already been removed or never been added\n");
      } else {

      }
#line 807
      goto exit;
    } else {

    }
  }
#line 811
  tmp___1 = strcmp((char const   *)(& param->u.crypt.alg), "none");
#line 811
  if (tmp___1 == 0 && (unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 814
    if (GlobalDebugLevel23A > 3U) {
#line 814
      printk("\016RTL8723AU: clear default encryption keys, keyid =%d\n", (int )param->u.crypt.idx);
    } else {

    }
#line 817
    goto exit;
  } else {

  }
#line 820
  tmp___2 = strcmp((char const   *)(& param->u.crypt.alg), "WEP");
#line 820
  if (tmp___2 == 0 && (unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 821
    if (GlobalDebugLevel23A > 3U) {
#line 821
      printk("\016RTL8723AU: r871x_set_encryption, crypt.alg = WEP\n");
    } else {

    }
#line 823
    wep_key_idx = param->u.crypt.idx;
#line 824
    wep_key_len = param->u.crypt.key_len;
#line 826
    if (GlobalDebugLevel23A > 3U) {
#line 826
      printk("\016RTL8723AU: r871x_set_encryption, wep_key_idx =%d, len =%d\n", (int )wep_key_idx,
             (int )wep_key_len);
    } else {

    }
#line 829
    if ((unsigned int )wep_key_idx > 3U || (unsigned int )wep_key_len == 0U) {
#line 830
      ret = -22;
#line 831
      goto exit;
    } else {

    }
#line 834
    if ((unsigned int )wep_key_len != 0U) {
#line 835
      wep_key_len = (unsigned int )wep_key_len <= 5U ? 5U : 13U;
    } else {

    }
#line 838
    if ((unsigned int )psecuritypriv->bWepDefaultKeyIdxSet == 0U) {
#line 842
      psecuritypriv->ndisencryptstatus = 0U;
#line 844
      psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
#line 845
      psecuritypriv->dot118021XGrpPrivacy = 1027073U;
#line 847
      if ((unsigned int )wep_key_len == 13U) {
#line 848
        psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
#line 849
        psecuritypriv->dot118021XGrpPrivacy = 1027077U;
      } else {

      }
#line 852
      psecuritypriv->dot11PrivacyKeyIndex = (u32 )wep_key_idx;
    } else {

    }
#line 855
    __len = (size_t )wep_key_len;
#line 855
    __ret = __builtin_memcpy((void *)(& psecuritypriv->wep_key[(int )wep_key_idx].key),
                             (void const   *)(& param->u.crypt.key), __len);
#line 858
    psecuritypriv->wep_key[(int )wep_key_idx].keylen = wep_key_len;
#line 860
    set_wep_key(padapter, (u8 *)(& param->u.crypt.key), (int )wep_key_len, (int )wep_key_idx);
#line 863
    goto exit;
  } else {

  }
#line 867
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 867
    tmp___6 = check_fwstate(pmlmepriv, 16);
#line 867
    if ((int )tmp___6) {
#line 868
      if ((unsigned int )param->u.crypt.set_tx == 0U) {
#line 869
        tmp___5 = strcmp((char const   *)(& param->u.crypt.alg), "WEP");
#line 869
        if (tmp___5 == 0) {
#line 870
          if (GlobalDebugLevel23A > 3U) {
#line 870
            printk("\016RTL8723AU: %s, set group_key, WEP\n", "rtw_cfg80211_ap_set_encryption");
          } else {

          }
#line 872
          __len___0 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
#line 872
          __ret___0 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                       (void const   *)(& param->u.crypt.key), __len___0);
#line 878
          psecuritypriv->dot118021XGrpPrivacy = 1027073U;
#line 879
          if ((unsigned int )param->u.crypt.key_len == 13U) {
#line 880
            psecuritypriv->dot118021XGrpPrivacy = 1027077U;
          } else {

          }
        } else {
#line 884
          tmp___4 = strcmp((char const   *)(& param->u.crypt.alg), "TKIP");
#line 884
          if (tmp___4 == 0) {
#line 885
            if (GlobalDebugLevel23A > 3U) {
#line 885
              printk("\016RTL8723AU: %s, set group_key, TKIP\n", "rtw_cfg80211_ap_set_encryption");
            } else {

            }
#line 888
            psecuritypriv->dot118021XGrpPrivacy = 1027074U;
#line 890
            __len___1 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
#line 890
            __ret___1 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                         (void const   *)(& param->u.crypt.key), __len___1);
#line 898
            __len___2 = 8UL;
#line 898
            if (__len___2 > 63UL) {
#line 898
              __ret___2 = __memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                   (void const   *)(& param->u.crypt.key) + 16U, __len___2);
            } else {
#line 898
              __ret___2 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                           (void const   *)(& param->u.crypt.key) + 16U,
                                           __len___2);
            }
#line 902
            __len___3 = 8UL;
#line 902
            if (__len___3 > 63UL) {
#line 902
              __ret___3 = __memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                   (void const   *)(& param->u.crypt.key) + 24U, __len___3);
            } else {
#line 902
              __ret___3 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                           (void const   *)(& param->u.crypt.key) + 24U,
                                           __len___3);
            }
#line 907
            psecuritypriv->busetkipkey = 1U;
          } else {
#line 909
            tmp___3 = strcmp((char const   *)(& param->u.crypt.alg), "CCMP");
#line 909
            if (tmp___3 == 0) {
#line 910
              if (GlobalDebugLevel23A > 3U) {
#line 910
                printk("\016RTL8723AU: %s, set group_key, CCMP\n", "rtw_cfg80211_ap_set_encryption");
              } else {

              }
#line 913
              psecuritypriv->dot118021XGrpPrivacy = 1027076U;
#line 915
              __len___4 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
#line 915
              __ret___4 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                           (void const   *)(& param->u.crypt.key),
                                           __len___4);
            } else {
#line 921
              if (GlobalDebugLevel23A > 3U) {
#line 921
                printk("\016RTL8723AU: %s, set group_key, none\n", "rtw_cfg80211_ap_set_encryption");
              } else {

              }
#line 924
              psecuritypriv->dot118021XGrpPrivacy = 0U;
            }
          }
        }
#line 928
        psecuritypriv->dot118021XGrpKeyid = (u32 )param->u.crypt.idx;
#line 930
        psecuritypriv->binstallGrpkey = 1U;
#line 932
        psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;
#line 935
        set_group_key(padapter, (u8 *)(& param->u.crypt.key), psecuritypriv->dot118021XGrpPrivacy,
                      (int )param->u.crypt.idx);
#line 939
        pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
#line 940
        if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
#line 941
          pbcmc_sta->ieee8021x_blocked = 0U;
#line 943
          pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;
        } else {

        }
      } else {

      }
#line 950
      goto exit;
    } else {

    }
  } else {

  }
#line 953
  if (psecuritypriv->dot11AuthAlgrthm == 2U && (unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 955
    tmp___13 = check_fwstate(pmlmepriv, 16);
#line 955
    if ((int )tmp___13) {
#line 956
      if ((unsigned int )param->u.crypt.set_tx == 1U) {
#line 958
        __len___5 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
#line 958
        __ret___5 = __builtin_memcpy((void *)(& psta->dot118021x_UncstKey.skey), (void const   *)(& param->u.crypt.key),
                                     __len___5);
#line 963
        tmp___9 = strcmp((char const   *)(& param->u.crypt.alg), "WEP");
#line 963
        if (tmp___9 == 0) {
#line 964
          if (GlobalDebugLevel23A > 3U) {
#line 964
            printk("\016RTL8723AU: %s, set pairwise key, WEP\n", "rtw_cfg80211_ap_set_encryption");
          } else {

          }
#line 967
          psta->dot118021XPrivacy = 1027073U;
#line 968
          if ((unsigned int )param->u.crypt.key_len == 13U) {
#line 969
            psta->dot118021XPrivacy = 1027077U;
          } else {

          }
        } else {
#line 972
          tmp___8 = strcmp((char const   *)(& param->u.crypt.alg), "TKIP");
#line 972
          if (tmp___8 == 0) {
#line 973
            if (GlobalDebugLevel23A > 3U) {
#line 973
              printk("\016RTL8723AU: %s, set pairwise key, TKIP\n", "rtw_cfg80211_ap_set_encryption");
            } else {

            }
#line 976
            psta->dot118021XPrivacy = 1027074U;
#line 980
            __len___6 = 8UL;
#line 980
            if (__len___6 > 63UL) {
#line 980
              __ret___6 = __memcpy((void *)(& psta->dot11tkiptxmickey.skey), (void const   *)(& param->u.crypt.key) + 16U,
                                   __len___6);
            } else {
#line 980
              __ret___6 = __builtin_memcpy((void *)(& psta->dot11tkiptxmickey.skey),
                                           (void const   *)(& param->u.crypt.key) + 16U,
                                           __len___6);
            }
#line 982
            __len___7 = 8UL;
#line 982
            if (__len___7 > 63UL) {
#line 982
              __ret___7 = __memcpy((void *)(& psta->dot11tkiprxmickey.skey), (void const   *)(& param->u.crypt.key) + 24U,
                                   __len___7);
            } else {
#line 982
              __ret___7 = __builtin_memcpy((void *)(& psta->dot11tkiprxmickey.skey),
                                           (void const   *)(& param->u.crypt.key) + 24U,
                                           __len___7);
            }
#line 985
            psecuritypriv->busetkipkey = 1U;
          } else {
#line 987
            tmp___7 = strcmp((char const   *)(& param->u.crypt.alg), "CCMP");
#line 987
            if (tmp___7 == 0) {
#line 989
              if (GlobalDebugLevel23A > 3U) {
#line 989
                printk("\016RTL8723AU: %s, set pairwise key, CCMP\n", "rtw_cfg80211_ap_set_encryption");
              } else {

              }
#line 992
              psta->dot118021XPrivacy = 1027076U;
            } else {
#line 994
              if (GlobalDebugLevel23A > 3U) {
#line 994
                printk("\016RTL8723AU: %s, set pairwise key, none\n", "rtw_cfg80211_ap_set_encryption");
              } else {

              }
#line 997
              psta->dot118021XPrivacy = 0U;
            }
          }
        }
#line 1000
        set_pairwise_key(padapter, psta);
#line 1002
        psta->ieee8021x_blocked = 0U;
#line 1004
        psta->bpairwise_key_installed = 1U;
      } else {
#line 1006
        tmp___12 = strcmp((char const   *)(& param->u.crypt.alg), "WEP");
#line 1006
        if (tmp___12 == 0) {
#line 1007
          __len___8 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
#line 1007
          __ret___8 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                       (void const   *)(& param->u.crypt.key), __len___8);
#line 1015
          psecuritypriv->dot118021XGrpPrivacy = 1027073U;
#line 1017
          if ((unsigned int )param->u.crypt.key_len == 13U) {
#line 1018
            psecuritypriv->dot118021XGrpPrivacy = 1027077U;
          } else {

          }
        } else {
#line 1022
          tmp___11 = strcmp((char const   *)(& param->u.crypt.alg), "TKIP");
#line 1022
          if (tmp___11 == 0) {
#line 1023
            psecuritypriv->dot118021XGrpPrivacy = 1027074U;
#line 1026
            __len___9 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
#line 1026
            __ret___9 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                         (void const   *)(& param->u.crypt.key), __len___9);
#line 1038
            __len___10 = 8UL;
#line 1038
            if (__len___10 > 63UL) {
#line 1038
              __ret___10 = __memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                    (void const   *)(& param->u.crypt.key) + 16U,
                                    __len___10);
            } else {
#line 1038
              __ret___10 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                            (void const   *)(& param->u.crypt.key) + 16U,
                                            __len___10);
            }
#line 1043
            __len___11 = 8UL;
#line 1043
            if (__len___11 > 63UL) {
#line 1043
              __ret___11 = __memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                    (void const   *)(& param->u.crypt.key) + 24U,
                                    __len___11);
            } else {
#line 1043
              __ret___11 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                            (void const   *)(& param->u.crypt.key) + 24U,
                                            __len___11);
            }
#line 1049
            psecuritypriv->busetkipkey = 1U;
          } else {
#line 1051
            tmp___10 = strcmp((char const   *)(& param->u.crypt.alg), "CCMP");
#line 1051
            if (tmp___10 == 0) {
#line 1052
              psecuritypriv->dot118021XGrpPrivacy = 1027076U;
#line 1055
              __len___12 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
#line 1055
              __ret___12 = __builtin_memcpy((void *)(& psecuritypriv->dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                            (void const   *)(& param->u.crypt.key),
                                            __len___12);
            } else {
#line 1063
              psecuritypriv->dot118021XGrpPrivacy = 0U;
            }
          }
        }
#line 1067
        psecuritypriv->dot118021XGrpKeyid = (u32 )param->u.crypt.idx;
#line 1070
        psecuritypriv->binstallGrpkey = 1U;
#line 1072
        psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;
#line 1075
        set_group_key(padapter, (u8 *)(& param->u.crypt.key), psecuritypriv->dot118021XGrpPrivacy,
                      (int )param->u.crypt.idx);
#line 1080
        pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
#line 1081
        if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
#line 1084
          pbcmc_sta->ieee8021x_blocked = 0U;
#line 1085
          pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;
        } else {

        }
      }
    } else {

    }
  } else {

  }
  exit: ;
#line 1093
  return (ret);
}
}
#line 1098 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_set_encryption(struct net_device *dev , struct ieee_param *param ,
                                       u32 param_len ) 
{ 
  int ret ;
  u32 wep_key_idx ;
  u16 wep_key_len ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;
  struct sta_info *psta ;
  struct sta_info *pbcmc_sta ;
  struct sta_priv *pstapriv ;
  u8 *tmp___2 ;
  int tmp___3 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  int tmp___4 ;
  size_t __len___3 ;
  void *__ret___3 ;
  size_t __len___4 ;
  void *__ret___4 ;
  size_t __len___5 ;
  void *__ret___5 ;
  int tmp___5 ;
  bool tmp___6 ;

  {
#line 1101
  ret = 0;
#line 1104
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 1104
  padapter = (struct rtw_adapter *)tmp;
#line 1105
  pmlmepriv = & padapter->mlmepriv;
#line 1106
  psecuritypriv = & padapter->securitypriv;
#line 1108
  if (GlobalDebugLevel23A > 3U) {
#line 1108
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_set_encryption");
  } else {

  }
#line 1110
  param->u.crypt.err = 0U;
#line 1111
  param->u.crypt.alg[15] = 0U;
#line 1113
  if (((unsigned int )((long )(& param->u.crypt.key)) - (unsigned int )((long )param)) + (unsigned int )param->u.crypt.key_len > param_len) {
#line 1116
    ret = -22;
#line 1117
    goto exit;
  } else {

  }
#line 1120
  tmp___0 = is_broadcast_ether_addr((u8 const   *)(& param->sta_addr));
#line 1120
  if ((int )tmp___0) {
#line 1121
    if ((unsigned int )param->u.crypt.idx > 3U) {
#line 1122
      ret = -22;
#line 1123
      goto exit;
    } else {

    }
  } else {
#line 1126
    ret = -22;
#line 1127
    goto exit;
  }
#line 1130
  tmp___1 = strcmp((char const   *)(& param->u.crypt.alg), "WEP");
#line 1130
  if (tmp___1 == 0) {
#line 1131
    if (GlobalDebugLevel23A > 3U) {
#line 1131
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 33554432U, 4);
#line 1131
      printk("\016wpa_set_encryption, crypt.alg = WEP\n");
    } else {

    }
#line 1133
    if (GlobalDebugLevel23A > 3U) {
#line 1133
      printk("\016RTL8723AU: wpa_set_encryption, crypt.alg = WEP\n");
    } else {

    }
#line 1135
    wep_key_idx = (u32 )param->u.crypt.idx;
#line 1136
    wep_key_len = param->u.crypt.key_len;
#line 1138
    if (wep_key_idx > 4U || (unsigned int )wep_key_len == 0U) {
#line 1139
      ret = -22;
#line 1140
      goto exit;
    } else {

    }
#line 1143
    if ((unsigned int )psecuritypriv->bWepDefaultKeyIdxSet == 0U) {
#line 1147
      wep_key_len = (unsigned int )wep_key_len <= 5U ? 5U : 13U;
#line 1149
      psecuritypriv->ndisencryptstatus = 0U;
#line 1151
      psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
#line 1152
      psecuritypriv->dot118021XGrpPrivacy = 1027073U;
#line 1154
      if ((unsigned int )wep_key_len == 13U) {
#line 1155
        psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
#line 1156
        psecuritypriv->dot118021XGrpPrivacy = 1027077U;
      } else {

      }
#line 1159
      psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
    } else {

    }
#line 1162
    __len = (size_t )wep_key_len;
#line 1162
    __ret = __builtin_memcpy((void *)(& psecuritypriv->wep_key[wep_key_idx].key),
                             (void const   *)(& param->u.crypt.key), __len);
#line 1165
    psecuritypriv->wep_key[wep_key_idx].keylen = wep_key_len;
#line 1167
    rtw_set_key23a(padapter, psecuritypriv, (int )wep_key_idx, 0);
#line 1169
    goto exit;
  } else {

  }
#line 1172
  if (padapter->securitypriv.dot11AuthAlgrthm == 2U) {
#line 1175
    pstapriv = & padapter->stapriv;
#line 1177
    tmp___6 = check_fwstate(pmlmepriv, 65544);
#line 1177
    if ((int )tmp___6) {
#line 1180
      tmp___2 = get_bssid(pmlmepriv);
#line 1180
      psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)tmp___2);
#line 1181
      if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1182
        if (GlobalDebugLevel23A > 3U) {
#line 1182
          printk("\016RTL8723AU: %s, : Obtain Sta_info fail\n", "rtw_cfg80211_set_encryption");
        } else {

        }
      } else {
#line 1187
        tmp___3 = strcmp((char const   *)(& param->u.crypt.alg), "none");
#line 1187
        if (tmp___3 != 0) {
#line 1188
          psta->ieee8021x_blocked = 0U;
        } else {

        }
#line 1190
        if (padapter->securitypriv.ndisencryptstatus == 4U || padapter->securitypriv.ndisencryptstatus == 6U) {
#line 1194
          psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
        } else {

        }
#line 1199
        if ((unsigned int )param->u.crypt.set_tx == 1U) {
#line 1201
          if (GlobalDebugLevel23A > 3U) {
#line 1201
            printk("\016RTL8723AU: %s, : param->u.crypt.set_tx == 1\n", "rtw_cfg80211_set_encryption");
          } else {

          }
#line 1204
          __len___0 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
#line 1204
          __ret___0 = __builtin_memcpy((void *)(& psta->dot118021x_UncstKey.skey),
                                       (void const   *)(& param->u.crypt.key), __len___0);
#line 1210
          tmp___4 = strcmp((char const   *)(& param->u.crypt.alg), "TKIP");
#line 1210
          if (tmp___4 == 0) {
#line 1212
            __len___1 = 8UL;
#line 1212
            if (__len___1 > 63UL) {
#line 1212
              __ret___1 = __memcpy((void *)(& psta->dot11tkiptxmickey.skey), (void const   *)(& param->u.crypt.key) + 16U,
                                   __len___1);
            } else {
#line 1212
              __ret___1 = __builtin_memcpy((void *)(& psta->dot11tkiptxmickey.skey),
                                           (void const   *)(& param->u.crypt.key) + 16U,
                                           __len___1);
            }
#line 1216
            __len___2 = 8UL;
#line 1216
            if (__len___2 > 63UL) {
#line 1216
              __ret___2 = __memcpy((void *)(& psta->dot11tkiprxmickey.skey), (void const   *)(& param->u.crypt.key) + 24U,
                                   __len___2);
            } else {
#line 1216
              __ret___2 = __builtin_memcpy((void *)(& psta->dot11tkiprxmickey.skey),
                                           (void const   *)(& param->u.crypt.key) + 24U,
                                           __len___2);
            }
#line 1221
            padapter->securitypriv.busetkipkey = 0U;
          } else {

          }
#line 1224
          if (GlobalDebugLevel23A > 3U) {
#line 1224
            printk("\016RTL8723AU:  ~~~~set sta key:unicastkey\n");
          } else {

          }
#line 1226
          rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
        } else {
#line 1230
          __len___3 = (unsigned int )param->u.crypt.key_len <= 16U ? (size_t )param->u.crypt.key_len : 16UL;
#line 1230
          __ret___3 = __builtin_memcpy((void *)(& padapter->securitypriv.dot118021XGrpKey[(int )param->u.crypt.idx].skey),
                                       (void const   *)(& param->u.crypt.key), __len___3);
#line 1237
          __len___4 = 8UL;
#line 1237
          if (__len___4 > 63UL) {
#line 1237
            __ret___4 = __memcpy((void *)(& padapter->securitypriv.dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                 (void const   *)(& param->u.crypt.key) + 16U, __len___4);
          } else {
#line 1237
            __ret___4 = __builtin_memcpy((void *)(& padapter->securitypriv.dot118021XGrptxmickey[(int )param->u.crypt.idx].skey),
                                         (void const   *)(& param->u.crypt.key) + 16U,
                                         __len___4);
          }
#line 1242
          __len___5 = 8UL;
#line 1242
          if (__len___5 > 63UL) {
#line 1242
            __ret___5 = __memcpy((void *)(& padapter->securitypriv.dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                 (void const   *)(& param->u.crypt.key) + 24U, __len___5);
          } else {
#line 1242
            __ret___5 = __builtin_memcpy((void *)(& padapter->securitypriv.dot118021XGrprxmickey[(int )param->u.crypt.idx].skey),
                                         (void const   *)(& param->u.crypt.key) + 24U,
                                         __len___5);
          }
#line 1247
          padapter->securitypriv.binstallGrpkey = 1U;
#line 1251
          if (GlobalDebugLevel23A > 3U) {
#line 1251
            printk("\016RTL8723AU:  ~~~~set sta key:groupkey\n");
          } else {

          }
#line 1254
          padapter->securitypriv.dot118021XGrpKeyid = (u32 )param->u.crypt.idx;
#line 1258
          rtw_set_key23a(padapter, & padapter->securitypriv, (int )param->u.crypt.idx,
                         1);
        }
      }
#line 1264
      pbcmc_sta = rtw_get_bcmc_stainfo23a(padapter);
#line 1265
      if ((unsigned long )pbcmc_sta != (unsigned long )((struct sta_info *)0)) {
#line 1268
        tmp___5 = strcmp((char const   *)(& param->u.crypt.alg), "none");
#line 1268
        if (tmp___5 != 0) {
#line 1269
          pbcmc_sta->ieee8021x_blocked = 0U;
        } else {

        }
#line 1271
        if (padapter->securitypriv.ndisencryptstatus == 4U || padapter->securitypriv.ndisencryptstatus == 6U) {
#line 1275
          pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
        } else {

        }
      } else {

      }
    } else {
#line 1280
      check_fwstate(pmlmepriv, 32);
    }
  } else {

  }
  exit: ;
#line 1286
  if (GlobalDebugLevel23A > 3U) {
#line 1286
    printk("\016RTL8723AU: %s, ret =%d\n", "rtw_cfg80211_set_encryption", ret);
  } else {

  }
#line 1290
  return (ret);
}
}
#line 1293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_add_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const   *mac_addr , struct key_params *params ) 
{ 
  char *alg_name ;
  u32 param_len ;
  struct ieee_param *param ;
  int ret ;
  struct wireless_dev *rtw_wdev ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  void *tmp___0 ;
  struct mlme_priv *pmlmepriv ;
  void *tmp___1 ;
  bool tmp___2 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
#line 1300
  ret = 0;
#line 1301
  tmp = wiphy_priv___1(wiphy);
#line 1301
  rtw_wdev = ((struct rtw_wdev_priv *)tmp)->rtw_wdev;
#line 1302
  tmp___0 = wiphy_priv___1(wiphy);
#line 1302
  padapter = ((struct rtw_wdev_priv *)tmp___0)->padapter;
#line 1303
  pmlmepriv = & padapter->mlmepriv;
#line 1305
  if (GlobalDebugLevel23A > 3U) {
#line 1305
    printk("\016RTL8723AU: %s(%s): adding key for %pM\n", "cfg80211_rtw_add_key",
           (char *)(& ndev->name), mac_addr);
  } else {

  }
#line 1307
  if (GlobalDebugLevel23A > 3U) {
#line 1307
    printk("\016RTL8723AU: cipher = 0x%x\n", params->cipher);
  } else {

  }
#line 1308
  if (GlobalDebugLevel23A > 3U) {
#line 1308
    printk("\016RTL8723AU: key_len = 0x%x\n", params->key_len);
  } else {

  }
#line 1309
  if (GlobalDebugLevel23A > 3U) {
#line 1309
    printk("\016RTL8723AU: seq_len = 0x%x\n", params->seq_len);
  } else {

  }
#line 1310
  if (GlobalDebugLevel23A > 3U) {
#line 1310
    printk("\016RTL8723AU: key_index =%d\n", (int )key_index);
  } else {

  }
#line 1311
  if (GlobalDebugLevel23A > 3U) {
#line 1311
    printk("\016RTL8723AU: pairwise =%d\n", (int )pairwise);
  } else {

  }
#line 1313
  param_len = (u32 )params->key_len + 64U;
#line 1314
  tmp___1 = kzalloc((size_t )param_len, 208U);
#line 1314
  param = (struct ieee_param *)tmp___1;
#line 1315
  if ((unsigned long )param == (unsigned long )((struct ieee_param *)0)) {
#line 1316
    return (-12);
  } else {

  }
#line 1318
  param->cmd = 3U;
#line 1319
  eth_broadcast_addr((u8 *)(& param->sta_addr));
#line 1321
  switch (params->cipher) {
  case 1U: 
#line 1325
  alg_name = (char *)"none";
#line 1326
  goto ldv_51671;
  case 1027073U: ;
  case 1027077U: 
#line 1329
  alg_name = (char *)"WEP";
#line 1330
  goto ldv_51671;
  case 1027074U: 
#line 1332
  alg_name = (char *)"TKIP";
#line 1333
  goto ldv_51671;
  case 1027076U: 
#line 1335
  alg_name = (char *)"CCMP";
#line 1336
  goto ldv_51671;
  default: 
#line 1339
  ret = -524;
#line 1340
  goto addkey_end;
  }
  ldv_51671: 
#line 1343
  strncpy((char *)(& param->u.crypt.alg), (char const   *)alg_name, 16UL);
#line 1345
  if ((unsigned long )mac_addr == (unsigned long )((u8 const   *)0U)) {
#line 1346
    param->u.crypt.set_tx = 0U;
  } else {
#line 1345
    tmp___2 = is_broadcast_ether_addr(mac_addr);
#line 1345
    if ((int )tmp___2) {
#line 1346
      param->u.crypt.set_tx = 0U;
    } else {
#line 1348
      param->u.crypt.set_tx = 1U;
    }
  }
#line 1352
  param->u.crypt.idx = key_index;
#line 1354
  if (params->seq_len != 0 && (unsigned long )params->seq != (unsigned long )((u8 const   *)0U)) {
#line 1355
    __len = (size_t )params->seq_len;
#line 1355
    __ret = __builtin_memcpy((void *)(& param->u.crypt.seq), (void const   *)params->seq,
                             __len);
  } else {

  }
#line 1358
  if (params->key_len != 0 && (unsigned long )params->key != (unsigned long )((u8 const   *)0U)) {
#line 1359
    param->u.crypt.key_len = (u16 )params->key_len;
#line 1360
    __len___0 = (size_t )params->key_len;
#line 1360
    __ret___0 = __builtin_memcpy((void *)(& param->u.crypt.key), (void const   *)params->key,
                                 __len___0);
  } else {

  }
#line 1363
  tmp___4 = check_fwstate(pmlmepriv, 8);
#line 1363
  if ((int )tmp___4) {
#line 1364
    ret = rtw_cfg80211_set_encryption(ndev, param, param_len);
  } else {
#line 1365
    tmp___3 = check_fwstate(pmlmepriv, 16);
#line 1365
    if ((int )tmp___3) {
#line 1367
      if ((unsigned long )mac_addr != (unsigned long )((u8 const   *)0U)) {
#line 1368
        ether_addr_copy((u8 *)(& param->sta_addr), mac_addr);
      } else {

      }
#line 1370
      ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
    } else
#line 1373
    if (GlobalDebugLevel23A > 3U) {
#line 1373
      printk("\016RTL8723AU: error! fw_state = 0x%x, iftype =%d\n", pmlmepriv->fw_state,
             (unsigned int )rtw_wdev->iftype);
    } else {

    }
  }
  addkey_end: 
#line 1379
  kfree((void const   *)param);
#line 1381
  return (ret);
}
}
#line 1385 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_get_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const   *mac_addr , void *cookie ,
                                void (*callback)(void * , struct key_params * ) ) 
{ 


  {
#line 1390
  if (GlobalDebugLevel23A > 3U) {
#line 1390
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_get_key", (char *)(& ndev->name));
  } else {

  }
#line 1391
  return (0);
}
}
#line 1394 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_del_key(struct wiphy *wiphy , struct net_device *ndev , u8 key_index ,
                                bool pairwise , u8 const   *mac_addr ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;

  {
#line 1398
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1398
  padapter = (struct rtw_adapter *)tmp;
#line 1399
  psecuritypriv = & padapter->securitypriv;
#line 1401
  if (GlobalDebugLevel23A > 3U) {
#line 1401
    printk("\016RTL8723AU: %s(%s): key_index =%d\n", "cfg80211_rtw_del_key", (char *)(& ndev->name),
           (int )key_index);
  } else {

  }
#line 1403
  if ((u32 )key_index == psecuritypriv->dot11PrivacyKeyIndex) {
#line 1405
    psecuritypriv->bWepDefaultKeyIdxSet = 0U;
  } else {

  }
#line 1408
  return (0);
}
}
#line 1411 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_set_default_key(struct wiphy *wiphy , struct net_device *ndev ,
                                        u8 key_index , bool unicast , bool multicast ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;

  {
#line 1415
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 1415
  padapter = (struct rtw_adapter *)tmp;
#line 1416
  psecuritypriv = & padapter->securitypriv;
#line 1418
  if (GlobalDebugLevel23A > 3U) {
#line 1418
    printk("\016RTL8723AU: %s(%s): key_index =%d, unicast =%d, multicast =%d.\n",
           "cfg80211_rtw_set_default_key", (char *)(& ndev->name), (int )key_index,
           (int )unicast, (int )multicast);
  } else {

  }
#line 1421
  if ((unsigned int )key_index <= 3U && (psecuritypriv->dot11PrivacyAlgrthm == 1027073U || psecuritypriv->dot11PrivacyAlgrthm == 1027077U)) {
#line 1425
    psecuritypriv->ndisencryptstatus = 0U;
#line 1427
    psecuritypriv->dot11PrivacyKeyIndex = (u32 )key_index;
#line 1429
    psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
#line 1430
    psecuritypriv->dot118021XGrpPrivacy = 1027073U;
#line 1431
    if ((unsigned int )psecuritypriv->wep_key[(int )key_index].keylen == 13U) {
#line 1432
      psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
#line 1434
      psecuritypriv->dot118021XGrpPrivacy = 1027077U;
    } else {

    }
#line 1440
    psecuritypriv->bWepDefaultKeyIdxSet = 1U;
  } else {

  }
#line 1443
  return (0);
}
}
#line 1446 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_get_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const   *mac , struct station_info *sinfo ) 
{ 
  int ret ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct wlan_network *cur_network ;
  bool tmp___0 ;
  int tmp___1 ;
  s32 tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;

  {
#line 1450
  ret = 0;
#line 1451
  tmp = wiphy_priv___1(wiphy);
#line 1451
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 1452
  pmlmepriv = & padapter->mlmepriv;
#line 1453
  psta = (struct sta_info *)0;
#line 1454
  pstapriv = & padapter->stapriv;
#line 1456
  sinfo->filled = 0U;
#line 1458
  if ((unsigned long )mac == (unsigned long )((u8 const   *)0U)) {
#line 1459
    if (GlobalDebugLevel23A > 3U) {
#line 1459
      printk("\016RTL8723AU: %s(%s): mac ==%p\n", "cfg80211_rtw_get_station", (char *)(& ndev->name),
             mac);
    } else {

    }
#line 1460
    ret = -2;
#line 1461
    goto exit;
  } else {

  }
#line 1464
  psta = rtw_get_stainfo23a(pstapriv, mac);
#line 1465
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1466
    if (GlobalDebugLevel23A > 3U) {
#line 1466
      printk("\016RTL8723AU: %s, sta_info is null\n", "cfg80211_rtw_get_station");
    } else {

    }
#line 1467
    ret = -2;
#line 1468
    goto exit;
  } else {

  }
#line 1470
  if (GlobalDebugLevel23A > 3U) {
#line 1470
    printk("\016RTL8723AU: %s(%s): mac =%02x:%02x:%02x:%02x:%02x:%02x\n", "cfg80211_rtw_get_station",
           (char *)(& ndev->name), (int )*((u8 *)mac), (int )*((u8 *)mac + 1UL), (int )*((u8 *)mac + 2UL),
           (int )*((u8 *)mac + 3UL), (int )*((u8 *)mac + 4UL), (int )*((u8 *)mac + 5UL));
  } else {

  }
#line 1474
  tmp___3 = check_fwstate(pmlmepriv, 8);
#line 1474
  if ((int )tmp___3) {
#line 1474
    tmp___4 = check_fwstate(pmlmepriv, 1);
#line 1474
    if ((int )tmp___4) {
#line 1476
      cur_network = & pmlmepriv->cur_network;
#line 1478
      tmp___0 = ether_addr_equal(mac, (u8 const   *)(& cur_network->network.MacAddress));
#line 1478
      if (tmp___0) {
#line 1478
        tmp___1 = 0;
      } else {
#line 1478
        tmp___1 = 1;
      }
#line 1478
      if (tmp___1) {
#line 1479
        if (GlobalDebugLevel23A > 3U) {
#line 1479
          printk("\016RTL8723AU: %s, mismatch bssid =%02x:%02x:%02x:%02x:%02x:%02x\n",
                 "cfg80211_rtw_get_station", (int )*((u8 *)(& cur_network->network.MacAddress)),
                 (int )*((u8 *)(& cur_network->network.MacAddress) + 1UL), (int )*((u8 *)(& cur_network->network.MacAddress) + 2UL),
                 (int )*((u8 *)(& cur_network->network.MacAddress) + 3UL), (int )*((u8 *)(& cur_network->network.MacAddress) + 4UL),
                 (int )*((u8 *)(& cur_network->network.MacAddress) + 5UL));
        } else {

        }
#line 1481
        ret = -2;
#line 1482
        goto exit;
      } else {

      }
#line 1485
      sinfo->filled = sinfo->filled | 64U;
#line 1486
      tmp___2 = translate_percentage_to_dbm((u32 )padapter->recvpriv.signal_strength);
#line 1486
      sinfo->signal = (s8 )tmp___2;
#line 1489
      sinfo->filled = sinfo->filled | 128U;
#line 1490
      sinfo->txrate.legacy = rtw_get_cur_max_rate23a(padapter);
#line 1492
      sinfo->filled = sinfo->filled | 256U;
#line 1493
      sinfo->rx_packets = (u32 )psta->sta_stats.rx_data_pkts;
#line 1495
      sinfo->filled = sinfo->filled | 512U;
#line 1496
      sinfo->tx_packets = (u32 )psta->sta_stats.tx_pkts;
    } else {

    }
  } else {

  }
#line 1500
  tmp___5 = check_fwstate(pmlmepriv, 32);
#line 1500
  if ((int )tmp___5) {
#line 1500
    goto _L;
  } else {
#line 1500
    tmp___6 = check_fwstate(pmlmepriv, 64);
#line 1500
    if ((int )tmp___6) {
#line 1500
      goto _L;
    } else {
#line 1500
      tmp___7 = check_fwstate(pmlmepriv, 16);
#line 1500
      if ((int )tmp___7) {
        _L: /* CIL Label */ 
#line 1500
        tmp___8 = check_fwstate(pmlmepriv, 1);
#line 1500
        if ((int )tmp___8) {
#line 1500
          tmp___9 = 1;
        } else {
#line 1500
          tmp___9 = 0;
        }
      } else {
#line 1500
        tmp___9 = 0;
      }
    }
  }
  exit: ;
#line 1509
  return (ret);
}
}
#line 1512 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int cfg80211_infrastructure_mode(struct rtw_adapter *padapter , enum nl80211_iftype ifmode ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct wlan_network *cur_network ;
  enum nl80211_iftype old_mode ;
  int tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
#line 1515
  pmlmepriv = & padapter->mlmepriv;
#line 1516
  cur_network = & pmlmepriv->cur_network;
#line 1519
  old_mode = cur_network->network.ifmode;
#line 1521
  if (GlobalDebugLevel23A > 5U) {
#line 1521
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 6);
#line 1521
    tmp = get_fwstate(pmlmepriv);
#line 1521
    printk("\016+%s: old =%d new =%d fw_state = 0x%08x\n", "cfg80211_infrastructure_mode",
           (unsigned int )old_mode, (unsigned int )ifmode, tmp);
  } else {

  }
#line 1525
  if ((unsigned int )old_mode != (unsigned int )ifmode) {
#line 1526
    spin_lock_bh(& pmlmepriv->lock);
#line 1528
    if (GlobalDebugLevel23A > 6U) {
#line 1528
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 1528
      printk("\016 change mode!");
    } else {

    }
#line 1531
    if ((unsigned int )old_mode == 3U || (unsigned int )old_mode == 9U) {
#line 1534
      cur_network->join_res = -1;
#line 1537
      stop_ap_mode23a(padapter);
    } else {

    }
#line 1541
    tmp___0 = check_fwstate(pmlmepriv, 1);
#line 1541
    if ((int )tmp___0 || (unsigned int )old_mode == 1U) {
#line 1543
      rtw_disassoc_cmd23a(padapter, 0U, 1);
    } else {

    }
#line 1545
    tmp___1 = check_fwstate(pmlmepriv, 1);
#line 1545
    if ((int )tmp___1) {
#line 1547
      rtw_free_assoc_resources23a(padapter, 1);
    } else {
#line 1545
      tmp___2 = check_fwstate(pmlmepriv, 64);
#line 1545
      if ((int )tmp___2) {
#line 1547
        rtw_free_assoc_resources23a(padapter, 1);
      } else {

      }
    }
#line 1549
    if (((unsigned int )old_mode == 2U || (unsigned int )old_mode == 8U) || (unsigned int )old_mode == 1U) {
#line 1552
      tmp___3 = check_fwstate(pmlmepriv, 1);
#line 1552
      if ((int )tmp___3) {
#line 1556
        rtw_indicate_disconnect23a(padapter);
      } else {

      }
    } else {

    }
#line 1560
    cur_network->network.ifmode = ifmode;
#line 1562
    _clr_fwstate_(pmlmepriv, -1);
#line 1564
    switch ((unsigned int )ifmode) {
    case 1U: 
#line 1566
    set_fwstate(pmlmepriv, 32);
#line 1567
    goto ldv_51739;
    case 8U: ;
    case 2U: 
#line 1571
    set_fwstate(pmlmepriv, 8);
#line 1572
    goto ldv_51739;
    case 9U: ;
    case 3U: 
#line 1576
    set_fwstate(pmlmepriv, 16);
#line 1578
    start_ap_mode23a(padapter);
#line 1581
    goto ldv_51739;
    default: ;
#line 1584
    goto ldv_51739;
    }
    ldv_51739: 
#line 1593
    spin_unlock_bh(& pmlmepriv->lock);
  } else {

  }
#line 1596
  return (1);
}
}
#line 1599 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_change_iface(struct wiphy *wiphy , struct net_device *ndev ,
                                     enum nl80211_iftype type , u32 *flags , struct vif_params *params ) 
{ 
  enum nl80211_iftype old_type ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_ext_priv *pmlmeext ;
  struct wireless_dev *rtw_wdev ;
  void *tmp___0 ;
  int ret ;
  int tmp___1 ;

  {
#line 1605
  tmp = wiphy_priv___1(wiphy);
#line 1605
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 1606
  pmlmeext = & padapter->mlmeextpriv;
#line 1607
  tmp___0 = wiphy_priv___1(wiphy);
#line 1607
  rtw_wdev = ((struct rtw_wdev_priv *)tmp___0)->rtw_wdev;
#line 1608
  ret = 0;
#line 1610
  if (GlobalDebugLevel23A > 3U) {
#line 1610
    printk("\016RTL8723AU: %s(%s): call netdev_open23a\n", "cfg80211_rtw_change_iface",
           (char *)(& ndev->name));
  } else {

  }
#line 1612
  old_type = rtw_wdev->iftype;
#line 1613
  if (GlobalDebugLevel23A > 3U) {
#line 1613
    printk("\016RTL8723AU: %s(%s): old_iftype =%d, new_iftype =%d\n", "cfg80211_rtw_change_iface",
           (char *)(& ndev->name), (unsigned int )old_type, (unsigned int )type);
  } else {

  }
#line 1616
  if ((unsigned int )old_type != (unsigned int )type) {
#line 1617
    pmlmeext->action_public_rxseq = 65535U;
#line 1618
    pmlmeext->action_public_dialog_token = 255U;
  } else {

  }
#line 1621
  switch ((unsigned int )type) {
  case 1U: ;
  case 8U: ;
  case 2U: ;
  case 9U: ;
  case 3U: ;
  case 0U: ;
#line 1628
  goto ldv_51764;
  default: ;
#line 1630
  return (-95);
  }
  ldv_51764: 
#line 1633
  rtw_wdev->iftype = type;
#line 1635
  tmp___1 = cfg80211_infrastructure_mode(padapter, type);
#line 1635
  if (tmp___1 != 1) {
#line 1636
    rtw_wdev->iftype = old_type;
#line 1637
    ret = -1;
#line 1638
    goto exit;
  } else {

  }
#line 1641
  rtw_setopmode_cmd23a(padapter, type);
  exit: ;
#line 1644
  return (ret);
}
}
#line 1647 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv , bool aborted ) 
{ 


  {
#line 1650
  spin_lock_bh(& pwdev_priv->scan_req_lock);
#line 1651
  if ((unsigned long )pwdev_priv->scan_request != (unsigned long )((struct cfg80211_scan_request *)0)) {
#line 1652
    if (GlobalDebugLevel23A > 3U) {
#line 1652
      printk("\016RTL8723AU: %s with scan req\n", "rtw_cfg80211_indicate_scan_done");
    } else {

    }
#line 1654
    if ((unsigned long )(pwdev_priv->scan_request)->wiphy != (unsigned long )(pwdev_priv->rtw_wdev)->wiphy) {
#line 1656
      if (GlobalDebugLevel23A > 3U) {
#line 1656
        printk("\016RTL8723AU: error wiphy compare\n");
      } else {

      }
    } else {
#line 1658
      cfg80211_scan_done(pwdev_priv->scan_request, (int )aborted);
    }
#line 1660
    pwdev_priv->scan_request = (struct cfg80211_scan_request *)0;
  } else
#line 1662
  if (GlobalDebugLevel23A > 3U) {
#line 1662
    printk("\016RTL8723AU: %s without scan req\n", "rtw_cfg80211_indicate_scan_done");
  } else {

  }
#line 1664
  spin_unlock_bh(& pwdev_priv->scan_req_lock);
#line 1665
  return;
}
}
#line 1667 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct mlme_priv *pmlmepriv ;
  struct rtw_queue *queue ;
  struct wlan_network *pnetwork ;
  struct list_head  const  *__mptr ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1670
  pmlmepriv = & padapter->mlmepriv;
#line 1671
  queue = & pmlmepriv->scanned_queue;
#line 1674
  spin_lock_bh(& pmlmepriv->scanned_queue.lock);
#line 1676
  phead = get_list_head(queue);
#line 1678
  plist = phead->next;
#line 1678
  ptmp = plist->next;
#line 1678
  goto ldv_51784;
  ldv_51783: 
#line 1679
  __mptr = (struct list_head  const  *)plist;
#line 1679
  pnetwork = (struct wlan_network *)__mptr;
#line 1683
  tmp = rtw_ch_set_search_ch23a((struct rt_channel_info *)(& padapter->mlmeextpriv.channel_set),
                                pnetwork->network.DSConfig);
#line 1683
  if (tmp >= 0) {
#line 1686
    rtw_cfg80211_inform_bss(padapter, pnetwork);
  } else {

  }
#line 1678
  plist = ptmp;
#line 1678
  ptmp = plist->next;
  ldv_51784: ;
#line 1678
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1680
    goto ldv_51783;
  } else {

  }
#line 1689
  spin_unlock_bh(& pmlmepriv->scanned_queue.lock);
#line 1692
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
#line 1692
  rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___0, 0);
#line 1693
  return;
}
}
#line 1696 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_set_probe_req_wpsp2pie(struct rtw_adapter *padapter , char *buf ,
                                               int len ) 
{ 
  int ret ;
  uint wps_ielen ;
  u8 *wps_ie ;
  struct mlme_priv *pmlmepriv ;
  void *tmp ;

  {
#line 1699
  ret = 0;
#line 1700
  wps_ielen = 0U;
#line 1702
  pmlmepriv = & padapter->mlmepriv;
#line 1704
  if (GlobalDebugLevel23A > 3U) {
#line 1704
    printk("\016RTL8723AU: %s, ielen =%d\n", "rtw_cfg80211_set_probe_req_wpsp2pie",
           len);
  } else {

  }
#line 1706
  if (len > 0) {
#line 1707
    wps_ie = rtw_get_wps_ie23a((u8 *)buf, (uint )len, (u8 *)0U, & wps_ielen);
#line 1708
    if ((unsigned long )wps_ie != (unsigned long )((u8 *)0U)) {
#line 1709
      if (GlobalDebugLevel23A > 3U) {
#line 1709
        printk("\016RTL8723AU: probe_req_wps_ielen =%d\n", wps_ielen);
      } else {

      }
#line 1711
      if ((unsigned long )pmlmepriv->wps_probe_req_ie != (unsigned long )((u8 *)0U)) {
#line 1712
        pmlmepriv->wps_probe_req_ie_len = 0U;
#line 1713
        kfree((void const   *)pmlmepriv->wps_probe_req_ie);
#line 1714
        pmlmepriv->wps_probe_req_ie = (u8 *)0U;
      } else {

      }
#line 1717
      tmp = kmemdup((void const   *)wps_ie, (size_t )wps_ielen, 208U);
#line 1717
      pmlmepriv->wps_probe_req_ie = (u8 *)tmp;
#line 1720
      if ((unsigned long )pmlmepriv->wps_probe_req_ie == (unsigned long )((u8 *)0U)) {
#line 1721
        if (GlobalDebugLevel23A > 3U) {
#line 1721
          printk("\016RTL8723AU: %s()-%d: kmalloc() OLD_ERROR!\n", "rtw_cfg80211_set_probe_req_wpsp2pie",
                 1722);
        } else {

        }
#line 1723
        return (-22);
      } else {

      }
#line 1725
      pmlmepriv->wps_probe_req_ie_len = wps_ielen;
    } else {

    }
  } else {

  }
#line 1729
  return (ret);
}
}
#line 1732 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_scan(struct wiphy *wiphy , struct cfg80211_scan_request *request ) 
{ 
  int i ;
  u8 _status ;
  int ret ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct cfg80211_ssid ssid[9U] ;
  struct rtw_ieee80211_channel ch[51U] ;
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp___0 ;
  struct cfg80211_ssid *ssids ;
  bool need_indicate_scan_done ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1736
  _status = 0U;
#line 1737
  ret = 0;
#line 1738
  tmp = wiphy_priv___1(wiphy);
#line 1738
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 1739
  pmlmepriv = & padapter->mlmepriv;
#line 1742
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
#line 1742
  pwdev_priv = (struct rtw_wdev_priv *)tmp___0;
#line 1743
  ssids = request->ssids;
#line 1744
  need_indicate_scan_done = 0;
#line 1746
  if (GlobalDebugLevel23A > 3U) {
#line 1746
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_scan", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
#line 1748
  spin_lock_bh(& pwdev_priv->scan_req_lock);
#line 1749
  pwdev_priv->scan_request = request;
#line 1750
  spin_unlock_bh(& pwdev_priv->scan_req_lock);
#line 1752
  tmp___1 = check_fwstate(pmlmepriv, 16);
#line 1752
  if ((int )tmp___1) {
#line 1753
    if (GlobalDebugLevel23A > 3U) {
#line 1753
      printk("\016RTL8723AU: %s under WIFI_AP_STATE\n", "cfg80211_rtw_scan");
    } else {

    }
  } else {

  }
#line 1758
  tmp___2 = _rtw_pwr_wakeup23a(padapter, 2000U, "cfg80211_rtw_scan");
#line 1758
  if (tmp___2 == 0) {
#line 1759
    need_indicate_scan_done = 1;
#line 1760
    goto check_need_indicate_scan_done;
  } else {

  }
#line 1763
  if ((unsigned long )request->ie != (unsigned long )((u8 const   *)0U) && request->ie_len != 0UL) {
#line 1764
    rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (char *)request->ie, (int )request->ie_len);
  } else {

  }
#line 1769
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
#line 1770
    if (GlobalDebugLevel23A > 3U) {
#line 1770
      printk("\016RTL8723AU: %s, bBusyTraffic == true\n", "cfg80211_rtw_scan");
    } else {

    }
#line 1771
    need_indicate_scan_done = 1;
#line 1772
    goto check_need_indicate_scan_done;
  } else {

  }
#line 1774
  tmp___3 = rtw_is_scan_deny(padapter);
#line 1774
  if ((int )tmp___3) {
#line 1775
    if (GlobalDebugLevel23A > 3U) {
#line 1775
      printk("\016RTL8723AU: %s(%s): scan deny\n", "cfg80211_rtw_scan", (char *)(& (padapter->pnetdev)->name));
    } else {

    }
#line 1777
    need_indicate_scan_done = 1;
#line 1778
    goto check_need_indicate_scan_done;
  } else {

  }
#line 1781
  tmp___4 = check_fwstate(pmlmepriv, 2176);
#line 1781
  if ((int )tmp___4) {
#line 1783
    if (GlobalDebugLevel23A > 3U) {
#line 1783
      printk("\016RTL8723AU: %s, fwstate = 0x%x\n", "cfg80211_rtw_scan", pmlmepriv->fw_state);
    } else {

    }
#line 1784
    need_indicate_scan_done = 1;
#line 1785
    goto check_need_indicate_scan_done;
  } else {

  }
#line 1788
  memset((void *)(& ssid), 0, 297UL);
#line 1790
  i = 0;
#line 1790
  goto ldv_51816;
  ldv_51815: ;
#line 1791
  if (GlobalDebugLevel23A > 3U) {
#line 1791
    printk("\016RTL8723AU: ssid =%s, len =%d\n", (u8 *)(& (ssids + (unsigned long )i)->ssid),
           (int )(ssids + (unsigned long )i)->ssid_len);
  } else {

  }
#line 1793
  __len = (size_t )(ssids + (unsigned long )i)->ssid_len;
#line 1793
  __ret = __builtin_memcpy((void *)(& ssid[i].ssid), (void const   *)(& (ssids + (unsigned long )i)->ssid),
                           __len);
#line 1794
  ssid[i].ssid_len = (ssids + (unsigned long )i)->ssid_len;
#line 1790
  i = i + 1;
  ldv_51816: ;
#line 1790
  if (request->n_ssids > i && i <= 8) {
#line 1792
    goto ldv_51815;
  } else {

  }
#line 1798
  memset((void *)(& ch), 0, 408UL);
#line 1801
  if (request->n_channels == 1U) {
#line 1802
    i = 0;
#line 1802
    goto ldv_51819;
    ldv_51818: ;
#line 1804
    if (GlobalDebugLevel23A > 3U) {
#line 1804
      printk("\016RTL8723AU: %s:(%s):hw_value:%u, flags:0x%08x\n", "cfg80211_rtw_scan",
             (char *)(& (padapter->pnetdev)->name), (int )(request->channels[i])->hw_value,
             (request->channels[i])->flags);
    } else {

    }
#line 1807
    ch[i].hw_value = (request->channels[i])->hw_value;
#line 1808
    ch[i].flags = (request->channels[i])->flags;
#line 1803
    i = i + 1;
    ldv_51819: ;
#line 1802
    if ((u32 )i < request->n_channels && i <= 50) {
#line 1805
      goto ldv_51818;
    } else {

    }

  } else {

  }
#line 1812
  spin_lock_bh(& pmlmepriv->lock);
#line 1813
  if (request->n_channels == 1U) {
#line 1814
    __len___0 = 8UL;
#line 1814
    if (__len___0 > 63UL) {
#line 1814
      __ret___0 = __memcpy((void *)(& ch) + 1U, (void const   *)(& ch), __len___0);
    } else {
#line 1814
      __ret___0 = __builtin_memcpy((void *)(& ch) + 1U, (void const   *)(& ch), __len___0);
    }
#line 1815
    __len___1 = 8UL;
#line 1815
    if (__len___1 > 63UL) {
#line 1815
      __ret___1 = __memcpy((void *)(& ch) + 2U, (void const   *)(& ch), __len___1);
    } else {
#line 1815
      __ret___1 = __builtin_memcpy((void *)(& ch) + 2U, (void const   *)(& ch), __len___1);
    }
#line 1816
    tmp___5 = rtw_sitesurvey_cmd23a(padapter, (struct cfg80211_ssid *)(& ssid), 9,
                                    (struct rtw_ieee80211_channel *)(& ch), 3);
#line 1816
    _status = (u8 )tmp___5;
  } else {
#line 1819
    tmp___6 = rtw_sitesurvey_cmd23a(padapter, (struct cfg80211_ssid *)(& ssid), 9,
                                    (struct rtw_ieee80211_channel *)0, 0);
#line 1819
    _status = (u8 )tmp___6;
  }
#line 1822
  spin_unlock_bh(& pmlmepriv->lock);
#line 1824
  if ((unsigned int )_status == 0U) {
#line 1825
    ret = -1;
  } else {

  }
  check_need_indicate_scan_done: ;
#line 1828
  if ((int )need_indicate_scan_done) {
#line 1829
    rtw_cfg80211_surveydone_event_callback(padapter);
  } else {

  }
#line 1830
  return (ret);
}
}
#line 1833 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy , u32 changed ) 
{ 


  {
#line 1835
  if (GlobalDebugLevel23A > 3U) {
#line 1835
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_set_wiphy_params");
  } else {

  }
#line 1836
  return (0);
}
}
#line 1839 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_join_ibss(struct wiphy *wiphy , struct net_device *ndev ,
                                  struct cfg80211_ibss_params *params ) 
{ 


  {
#line 1842
  if (GlobalDebugLevel23A > 3U) {
#line 1842
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_join_ibss", (char *)(& ndev->name));
  } else {

  }
#line 1843
  return (0);
}
}
#line 1846 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_leave_ibss(struct wiphy *wiphy , struct net_device *ndev ) 
{ 


  {
#line 1848
  if (GlobalDebugLevel23A > 3U) {
#line 1848
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_leave_ibss", (char *)(& ndev->name));
  } else {

  }
#line 1849
  return (0);
}
}
#line 1852 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv , u32 wpa_version ) 
{ 


  {
#line 1855
  if (GlobalDebugLevel23A > 3U) {
#line 1855
    printk("\016RTL8723AU: %s, wpa_version =%d\n", "rtw_cfg80211_set_wpa_version",
           wpa_version);
  } else {

  }
#line 1857
  if (wpa_version == 0U) {
#line 1858
    psecuritypriv->ndisauthtype = 0U;
#line 1859
    return (0);
  } else {

  }
#line 1862
  if ((wpa_version & 3U) != 0U) {
#line 1863
    psecuritypriv->ndisauthtype = 4U;
  } else {

  }
#line 1873
  return (0);
}
}
#line 1876 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv , enum nl80211_auth_type sme_auth_type ) 
{ 


  {
#line 1879
  if (GlobalDebugLevel23A > 3U) {
#line 1879
    printk("\016RTL8723AU: %s, nl80211_auth_type =%d\n", "rtw_cfg80211_set_auth_type",
           (unsigned int )sme_auth_type);
  } else {

  }
#line 1881
  switch ((unsigned int )sme_auth_type) {
  case 5U: 
#line 1883
  psecuritypriv->dot11AuthAlgrthm = 3U;
#line 1885
  goto ldv_51854;
  case 0U: 
#line 1887
  psecuritypriv->dot11AuthAlgrthm = 0U;
#line 1889
  if (psecuritypriv->ndisauthtype > 3U) {
#line 1890
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else {

  }
#line 1892
  goto ldv_51854;
  case 1U: 
#line 1894
  psecuritypriv->dot11AuthAlgrthm = 1U;
#line 1896
  psecuritypriv->ndisencryptstatus = 0U;
#line 1897
  goto ldv_51854;
  default: 
#line 1899
  psecuritypriv->dot11AuthAlgrthm = 0U;
  }
  ldv_51854: ;
#line 1903
  return (0);
}
}
#line 1906 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv , u32 cipher ,
                                   bool ucast ) 
{ 
  u32 ndisencryptstatus ;
  u32 *profile_cipher ;

  {
#line 1909
  ndisencryptstatus = 1U;
#line 1911
  profile_cipher = (int )ucast ? & psecuritypriv->dot11PrivacyAlgrthm : & psecuritypriv->dot118021XGrpPrivacy;
#line 1914
  if (GlobalDebugLevel23A > 3U) {
#line 1914
    printk("\016RTL8723AU: %s, ucast =%d, cipher = 0x%x\n", "rtw_cfg80211_set_cipher",
           (int )ucast, cipher);
  } else {

  }
#line 1916
  if (cipher == 0U) {
#line 1917
    *profile_cipher = 0U;
#line 1918
    psecuritypriv->ndisencryptstatus = ndisencryptstatus;
#line 1919
    return (0);
  } else {

  }
#line 1922
  switch (cipher) {
  case 1U: 
#line 1924
  *profile_cipher = 0U;
#line 1925
  ndisencryptstatus = 1U;
#line 1926
  goto ldv_51867;
  case 1027073U: 
#line 1928
  *profile_cipher = 1027073U;
#line 1929
  ndisencryptstatus = 0U;
#line 1930
  goto ldv_51867;
  case 1027077U: 
#line 1932
  *profile_cipher = 1027077U;
#line 1933
  ndisencryptstatus = 0U;
#line 1934
  goto ldv_51867;
  case 1027074U: 
#line 1936
  *profile_cipher = 1027074U;
#line 1937
  ndisencryptstatus = 4U;
#line 1938
  goto ldv_51867;
  case 1027076U: 
#line 1940
  *profile_cipher = 1027076U;
#line 1941
  ndisencryptstatus = 6U;
#line 1942
  goto ldv_51867;
  default: ;
#line 1944
  if (GlobalDebugLevel23A > 3U) {
#line 1944
    printk("\016RTL8723AU: Unsupported cipher: 0x%x\n", cipher);
  } else {

  }
#line 1945
  return (-524);
  }
  ldv_51867: ;
#line 1948
  if ((int )ucast) {
#line 1949
    psecuritypriv->ndisencryptstatus = ndisencryptstatus;
  } else {

  }
#line 1951
  return (0);
}
}
#line 1954 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv , u32 key_mgt ) 
{ 


  {
#line 1957
  if (GlobalDebugLevel23A > 3U) {
#line 1957
    printk("\016RTL8723AU: %s, key_mgt = 0x%x\n", "rtw_cfg80211_set_key_mgt", key_mgt);
  } else {

  }
#line 1959
  if (key_mgt == 1027073U) {
#line 1960
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else
#line 1961
  if (key_mgt == 1027074U) {
#line 1962
    psecuritypriv->dot11AuthAlgrthm = 2U;
  } else
#line 1964
  if (GlobalDebugLevel23A > 3U) {
#line 1964
    printk("\016RTL8723AU: Invalid key mgt: 0x%x\n", key_mgt);
  } else {

  }
#line 1966
  return (0);
}
}
#line 1969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_set_wpa_ie(struct rtw_adapter *padapter , u8 const   *pie ,
                                   size_t ielen ) 
{ 
  u8 *buf ;
  int group_cipher ;
  int pairwise_cipher ;
  int ret ;
  u8 const   *pwpa ;
  u8 const   *pwpa2 ;
  int i ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  int tmp___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  int tmp___1 ;
  uint wps_ielen ;
  u8 *wps_ie ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 1972
  buf = (u8 *)0U;
#line 1973
  group_cipher = 0;
#line 1973
  pairwise_cipher = 0;
#line 1974
  ret = 0;
#line 1978
  if ((unsigned long )pie == (unsigned long )((u8 const   *)0U) || ielen == 0UL) {
#line 1981
    _clr_fwstate_(& padapter->mlmepriv, 256);
#line 1982
    goto exit;
  } else {

  }
#line 1984
  if (ielen > 1024UL) {
#line 1985
    ret = -22;
#line 1986
    goto exit;
  } else {

  }
#line 1988
  tmp = kmemdup((void const   *)pie, ielen, 208U);
#line 1988
  buf = (u8 *)tmp;
#line 1989
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
#line 1990
    ret = -12;
#line 1991
    goto exit;
  } else {

  }
#line 1995
  if (GlobalDebugLevel23A > 3U) {
#line 1995
    printk("\016RTL8723AU: set wpa_ie(length:%zu):\n", ielen);
  } else {

  }
#line 1996
  i = 0;
#line 1996
  goto ldv_51892;
  ldv_51891: ;
#line 1997
  if (GlobalDebugLevel23A > 3U) {
#line 1997
    printk("\016RTL8723AU: 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",
           (int )*(buf + (unsigned long )i), (int )*(buf + ((unsigned long )i + 1UL)),
           (int )*(buf + ((unsigned long )i + 2UL)), (int )*(buf + ((unsigned long )i + 3UL)),
           (int )*(buf + ((unsigned long )i + 4UL)), (int )*(buf + ((unsigned long )i + 5UL)),
           (int )*(buf + ((unsigned long )i + 6UL)), (int )*(buf + ((unsigned long )i + 7UL)));
  } else {

  }
#line 1996
  i = i + 8;
  ldv_51892: ;
#line 1996
  if ((size_t )i < ielen) {
#line 1998
    goto ldv_51891;
  } else {

  }

#line 2001
  if (ielen <= 3UL) {
#line 2002
    if (GlobalDebugLevel23A > 3U) {
#line 2002
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 33554432U, 4);
#line 2002
      printk("\016Ie len too short %d\n", (int )ielen);
    } else {

    }
#line 2004
    ret = -1;
#line 2005
    goto exit;
  } else {

  }
#line 2008
  pwpa = cfg80211_find_vendor_ie(20722U, 1, (u8 const   *)buf, (int )ielen);
#line 2011
  if ((unsigned long )pwpa != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pwpa + 1UL)) != 0U) {
#line 2012
    tmp___0 = rtw_parse_wpa_ie23a(pwpa, (int )*(pwpa + 1UL) + 2, & group_cipher, & pairwise_cipher,
                                  (int *)0);
#line 2012
    if (tmp___0 == 1) {
#line 2014
      padapter->securitypriv.dot11AuthAlgrthm = 2U;
#line 2016
      padapter->securitypriv.ndisauthtype = 4U;
#line 2018
      __len = (size_t )((int )*(pwpa + 1UL) + 2);
#line 2018
      __ret = __builtin_memcpy((void *)(& padapter->securitypriv.supplicant_ie), (void const   *)pwpa,
                               __len);
#line 2021
      if (GlobalDebugLevel23A > 3U) {
#line 2021
        printk("\016RTL8723AU: got wpa_ie, wpa_ielen:%u\n", (int )*(pwpa + 1UL));
      } else {

      }
    } else {

    }
  } else {

  }
#line 2025
  pwpa2 = cfg80211_find_ie(48, (u8 const   *)buf, (int )ielen);
#line 2026
  if ((unsigned long )pwpa2 != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(pwpa2 + 1UL)) != 0U) {
#line 2027
    tmp___1 = rtw_parse_wpa2_ie23a(pwpa2, (int )*(pwpa2 + 1UL) + 2, & group_cipher,
                                   & pairwise_cipher, (int *)0);
#line 2027
    if (tmp___1 == 1) {
#line 2029
      padapter->securitypriv.dot11AuthAlgrthm = 2U;
#line 2031
      padapter->securitypriv.ndisauthtype = 7U;
#line 2033
      __len___0 = (size_t )((int )*(pwpa2 + 1UL) + 2);
#line 2033
      __ret___0 = __builtin_memcpy((void *)(& padapter->securitypriv.supplicant_ie),
                                   (void const   *)pwpa2, __len___0);
#line 2036
      if (GlobalDebugLevel23A > 3U) {
#line 2036
        printk("\016RTL8723AU: got wpa2_ie, wpa2_ielen:%u\n", (int )*(pwpa2 + 1UL));
      } else {

      }
    } else {

    }
  } else {

  }
#line 2040
  if (group_cipher == 0) {
#line 2041
    group_cipher = 1;
  } else {

  }
#line 2043
  if (pairwise_cipher == 0) {
#line 2044
    pairwise_cipher = 1;
  } else {

  }
#line 2047
  switch (group_cipher) {
  case 1: 
#line 2049
  padapter->securitypriv.dot118021XGrpPrivacy = 0U;
#line 2050
  padapter->securitypriv.ndisencryptstatus = 1U;
#line 2052
  goto ldv_51901;
  case 2: 
#line 2054
  padapter->securitypriv.dot118021XGrpPrivacy = 1027073U;
#line 2055
  padapter->securitypriv.ndisencryptstatus = 0U;
#line 2057
  goto ldv_51901;
  case 8: 
#line 2059
  padapter->securitypriv.dot118021XGrpPrivacy = 1027074U;
#line 2060
  padapter->securitypriv.ndisencryptstatus = 4U;
#line 2062
  goto ldv_51901;
  case 16: 
#line 2064
  padapter->securitypriv.dot118021XGrpPrivacy = 1027076U;
#line 2065
  padapter->securitypriv.ndisencryptstatus = 6U;
#line 2067
  goto ldv_51901;
  case 4: 
#line 2069
  padapter->securitypriv.dot118021XGrpPrivacy = 1027077U;
#line 2070
  padapter->securitypriv.ndisencryptstatus = 0U;
#line 2072
  goto ldv_51901;
  }
  ldv_51901: ;
#line 2075
  switch (pairwise_cipher) {
  case 1: 
#line 2077
  padapter->securitypriv.dot11PrivacyAlgrthm = 0U;
#line 2078
  padapter->securitypriv.ndisencryptstatus = 1U;
#line 2080
  goto ldv_51907;
  case 2: 
#line 2082
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027073U;
#line 2083
  padapter->securitypriv.ndisencryptstatus = 0U;
#line 2085
  goto ldv_51907;
  case 8: 
#line 2087
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027074U;
#line 2088
  padapter->securitypriv.ndisencryptstatus = 4U;
#line 2090
  goto ldv_51907;
  case 16: 
#line 2092
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027076U;
#line 2093
  padapter->securitypriv.ndisencryptstatus = 6U;
#line 2095
  goto ldv_51907;
  case 4: 
#line 2097
  padapter->securitypriv.dot11PrivacyAlgrthm = 1027077U;
#line 2098
  padapter->securitypriv.ndisencryptstatus = 0U;
#line 2100
  goto ldv_51907;
  }
  ldv_51907: 
#line 2107
  wps_ie = rtw_get_wps_ie23a(buf, (uint )ielen, (u8 *)0U, & wps_ielen);
#line 2108
  if ((unsigned long )wps_ie != (unsigned long )((u8 *)0U) && wps_ielen != 0U) {
#line 2109
    if (GlobalDebugLevel23A > 3U) {
#line 2109
      printk("\016RTL8723AU: got wps_ie, wps_ielen:%u\n", wps_ielen);
    } else {

    }
#line 2110
    padapter->securitypriv.wps_ie_len = (int )(512U < wps_ielen ? 512U : wps_ielen);
#line 2113
    __len___1 = (size_t )padapter->securitypriv.wps_ie_len;
#line 2113
    __ret___1 = __builtin_memcpy((void *)(& padapter->securitypriv.wps_ie), (void const   *)wps_ie,
                                 __len___1);
#line 2115
    set_fwstate(& padapter->mlmepriv, 256);
  } else {
#line 2117
    _clr_fwstate_(& padapter->mlmepriv, 256);
  }
#line 2122
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 2128
    rtl8723a_off_rcr_am(padapter);
  } else {

  }
#line 2130
  if (GlobalDebugLevel23A > 6U) {
#line 2130
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 33554432U, 7);
#line 2130
    printk("\016rtw_set_wpa_ie: pairwise_cipher = 0x%08x padapter->securitypriv.ndisencryptstatus =%d padapter->securitypriv.ndisauthtype =%d\n",
           pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype);
  } else {

  }
  exit: 
#line 2138
  kfree((void const   *)buf);
#line 2139
  if (ret != 0) {
#line 2140
    _clr_fwstate_(& padapter->mlmepriv, 256);
  } else {

  }
#line 2141
  return (ret);
}
}
#line 2144 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_add_wep(struct rtw_adapter *padapter , struct rtw_wep_key *wep ,
                                u8 keyid ) 
{ 
  int res ;
  struct security_priv *psecuritypriv ;
  size_t __len ;
  void *__ret ;

  {
#line 2148
  psecuritypriv = & padapter->securitypriv;
#line 2150
  if ((unsigned int )keyid > 3U) {
#line 2151
    if (GlobalDebugLevel23A > 3U) {
#line 2151
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 4);
#line 2151
      printk("\016%s:keyid>4 =>fail\n", "rtw_cfg80211_add_wep");
    } else {

    }
#line 2153
    res = 0;
#line 2154
    goto exit;
  } else {

  }
#line 2157
  switch ((int )wep->keylen) {
  case 5: 
#line 2159
  psecuritypriv->dot11PrivacyAlgrthm = 1027073U;
#line 2160
  if (GlobalDebugLevel23A > 6U) {
#line 2160
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 2160
    printk("\016%s:wep->KeyLength = 5\n", "rtw_cfg80211_add_wep");
  } else {

  }
#line 2162
  goto ldv_51927;
  case 13: 
#line 2164
  psecuritypriv->dot11PrivacyAlgrthm = 1027077U;
#line 2165
  if (GlobalDebugLevel23A > 6U) {
#line 2165
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 2165
    printk("\016%s:wep->KeyLength = 13\n", "rtw_cfg80211_add_wep");
  } else {

  }
#line 2167
  goto ldv_51927;
  default: 
#line 2169
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
#line 2170
  if (GlobalDebugLevel23A > 6U) {
#line 2170
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 2170
    printk("\016%s:wep->KeyLength!= 5 or 13\n", "rtw_cfg80211_add_wep");
  } else {

  }
#line 2172
  res = 0;
#line 2173
  goto exit;
  }
  ldv_51927: ;
#line 2176
  if (GlobalDebugLevel23A > 6U) {
#line 2176
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 2176
    printk("\016%s:before memcpy, wep->KeyLength = 0x%x keyid =%x\n", "rtw_cfg80211_add_wep",
           (int )wep->keylen, (int )keyid);
  } else {

  }
#line 2180
  __len = 16UL;
#line 2180
  if (__len > 63UL) {
#line 2180
    __ret = __memcpy((void *)(& psecuritypriv->wep_key) + (unsigned long )keyid, (void const   *)wep,
                     __len);
  } else {
#line 2180
    __ret = __builtin_memcpy((void *)(& psecuritypriv->wep_key) + (unsigned long )keyid,
                             (void const   *)wep, __len);
  }
#line 2182
  psecuritypriv->dot11PrivacyKeyIndex = (u32 )keyid;
#line 2184
  if (GlobalDebugLevel23A > 6U) {
#line 2184
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 131072U, 7);
#line 2184
    printk("\016%s:security key material : %x %x %x %x %x %x %x %x %x %x %x %x %x\n",
           "rtw_cfg80211_add_wep", (int )psecuritypriv->wep_key[(int )keyid].key[0],
           (int )psecuritypriv->wep_key[(int )keyid].key[1], (int )psecuritypriv->wep_key[(int )keyid].key[2],
           (int )psecuritypriv->wep_key[(int )keyid].key[3], (int )psecuritypriv->wep_key[(int )keyid].key[4],
           (int )psecuritypriv->wep_key[(int )keyid].key[5], (int )psecuritypriv->wep_key[(int )keyid].key[6],
           (int )psecuritypriv->wep_key[(int )keyid].key[7], (int )psecuritypriv->wep_key[(int )keyid].key[8],
           (int )psecuritypriv->wep_key[(int )keyid].key[9], (int )psecuritypriv->wep_key[(int )keyid].key[10],
           (int )psecuritypriv->wep_key[(int )keyid].key[11], (int )psecuritypriv->wep_key[(int )keyid].key[12]);
  } else {

  }
#line 2201
  res = rtw_set_key23a(padapter, psecuritypriv, (int )keyid, 1);
  exit: ;
#line 2205
  return (res);
}
}
#line 2208 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_connect(struct wiphy *wiphy , struct net_device *ndev , struct cfg80211_connect_params *sme ) 
{ 
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct wlan_network *pnetwork ;
  enum ndis_802_11_auth_mode authmode ;
  struct cfg80211_ssid ndis_ssid ;
  u8 *dst_ssid ;
  u8 *src_ssid ;
  u8 *dst_bssid ;
  u8 const   *src_bssid ;
  u8 matched ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct rtw_queue *queue ;
  int tmp___0 ;
  bool tmp___1 ;
  size_t __len ;
  void *__ret ;
  bool tmp___2 ;
  bool tmp___3 ;
  struct list_head  const  *__mptr ;
  bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __len___0 ;
  void *__ret___0 ;
  bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct rtw_wep_key wep_key ;
  u8 wep_key_idx ;
  u8 wep_key_len ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 2211
  ret = 0;
#line 2213
  pnetwork = (struct wlan_network *)0;
#line 2222
  matched = 0U;
#line 2223
  tmp = wiphy_priv___1(wiphy);
#line 2223
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2224
  pmlmepriv = & padapter->mlmepriv;
#line 2225
  psecuritypriv = & padapter->securitypriv;
#line 2226
  queue = & pmlmepriv->scanned_queue;
#line 2228
  if (GlobalDebugLevel23A > 3U) {
#line 2228
    printk("\016RTL8723AU: =>%s(%s)\n", "cfg80211_rtw_connect", (char *)(& ndev->name));
  } else {

  }
#line 2229
  if (GlobalDebugLevel23A > 3U) {
#line 2229
    printk("\016RTL8723AU: privacy =%d, key =%p, key_len =%d, key_idx =%d\n", (int )sme->privacy,
           sme->key, (int )sme->key_len, (int )sme->key_idx);
  } else {

  }
#line 2232
  tmp___0 = _rtw_pwr_wakeup23a(padapter, 2000U, "cfg80211_rtw_connect");
#line 2232
  if (tmp___0 == 0) {
#line 2233
    ret = -1;
#line 2234
    goto exit;
  } else {

  }
#line 2237
  tmp___1 = check_fwstate(pmlmepriv, 16);
#line 2237
  if ((int )tmp___1) {
#line 2238
    ret = -1;
#line 2239
    goto exit;
  } else {

  }
#line 2242
  if ((unsigned long )sme->ssid == (unsigned long )((u8 const   *)0U) || sme->ssid_len == 0UL) {
#line 2243
    ret = -22;
#line 2244
    goto exit;
  } else {

  }
#line 2247
  if (sme->ssid_len > 32UL) {
#line 2248
    ret = -7;
#line 2249
    goto exit;
  } else {

  }
#line 2252
  memset((void *)(& ndis_ssid), 0, 33UL);
#line 2253
  ndis_ssid.ssid_len = (u8 )sme->ssid_len;
#line 2254
  __len = sme->ssid_len;
#line 2254
  __ret = __builtin_memcpy((void *)(& ndis_ssid.ssid), (void const   *)sme->ssid,
                           __len);
#line 2256
  if (GlobalDebugLevel23A > 3U) {
#line 2256
    printk("\016RTL8723AU: ssid =%s, len =%zu\n", (u8 *)(& ndis_ssid.ssid), sme->ssid_len);
  } else {

  }
#line 2258
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const   *)0U)) {
#line 2259
    if (GlobalDebugLevel23A > 3U) {
#line 2259
      printk("\016RTL8723AU: bssid =%02x:%02x:%02x:%02x:%02x:%02x\n", (int )*((u8 *)sme->bssid),
             (int )*((u8 *)sme->bssid + 1UL), (int )*((u8 *)sme->bssid + 2UL), (int )*((u8 *)sme->bssid + 3UL),
             (int )*((u8 *)sme->bssid + 4UL), (int )*((u8 *)sme->bssid + 5UL));
    } else {

    }
  } else {

  }
#line 2261
  tmp___2 = check_fwstate(pmlmepriv, 128);
#line 2261
  if ((int )tmp___2) {
#line 2262
    ret = -16;
#line 2263
    if (GlobalDebugLevel23A > 3U) {
#line 2263
      printk("\016RTL8723AU: %s, fw_state = 0x%x, goto exit\n", "cfg80211_rtw_connect",
             pmlmepriv->fw_state);
    } else {

    }
#line 2265
    goto exit;
  } else {

  }
#line 2267
  tmp___3 = check_fwstate(pmlmepriv, 2048);
#line 2267
  if ((int )tmp___3) {
#line 2268
    rtw_scan_abort23a(padapter);
  } else {

  }
#line 2271
  spin_lock_bh(& queue->lock);
#line 2273
  phead = get_list_head(queue);
#line 2275
  plist = phead->next;
#line 2275
  ptmp = plist->next;
#line 2275
  goto ldv_51967;
  ldv_51966: 
#line 2276
  __mptr = (struct list_head  const  *)plist;
#line 2276
  pnetwork = (struct wlan_network *)__mptr;
#line 2278
  dst_ssid = (u8 *)(& pnetwork->network.Ssid.ssid);
#line 2279
  dst_bssid = (u8 *)(& pnetwork->network.MacAddress);
#line 2281
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const   *)0U)) {
#line 2282
    tmp___4 = ether_addr_equal((u8 const   *)(& pnetwork->network.MacAddress), sme->bssid);
#line 2282
    if (tmp___4) {
#line 2282
      tmp___5 = 0;
    } else {
#line 2282
      tmp___5 = 1;
    }
#line 2282
    if (tmp___5) {
#line 2284
      goto ldv_51961;
    } else {

    }
  } else {

  }
#line 2287
  if ((unsigned long )sme->ssid != (unsigned long )((u8 const   *)0U) && sme->ssid_len != 0UL) {
#line 2288
    if ((size_t )pnetwork->network.Ssid.ssid_len != sme->ssid_len) {
#line 2291
      goto ldv_51961;
    } else {
#line 2288
      tmp___6 = memcmp((void const   *)(& pnetwork->network.Ssid.ssid), (void const   *)sme->ssid,
                       sme->ssid_len);
#line 2288
      if (tmp___6 != 0) {
#line 2291
        goto ldv_51961;
      } else {

      }
    }
  } else {

  }
#line 2294
  if ((unsigned long )sme->bssid != (unsigned long )((u8 const   *)0U)) {
#line 2295
    src_bssid = sme->bssid;
#line 2297
    tmp___7 = ether_addr_equal((u8 const   *)dst_bssid, src_bssid);
#line 2297
    if ((int )tmp___7) {
#line 2298
      if (GlobalDebugLevel23A > 3U) {
#line 2298
        printk("\016RTL8723AU: matched by bssid\n");
      } else {

      }
#line 2300
      ndis_ssid.ssid_len = pnetwork->network.Ssid.ssid_len;
#line 2302
      __len___0 = (size_t )pnetwork->network.Ssid.ssid_len;
#line 2302
      __ret___0 = __builtin_memcpy((void *)(& ndis_ssid.ssid), (void const   *)(& pnetwork->network.Ssid.ssid),
                                   __len___0);
#line 2306
      matched = 1U;
#line 2307
      goto ldv_51965;
    } else {

    }
  } else
#line 2310
  if ((unsigned long )sme->ssid != (unsigned long )((u8 const   *)0U) && sme->ssid_len != 0UL) {
#line 2311
    src_ssid = (u8 *)(& ndis_ssid.ssid);
#line 2313
    tmp___8 = memcmp((void const   *)dst_ssid, (void const   *)src_ssid, (size_t )ndis_ssid.ssid_len);
#line 2313
    if (tmp___8 == 0 && (int )pnetwork->network.Ssid.ssid_len == (int )ndis_ssid.ssid_len) {
#line 2316
      if (GlobalDebugLevel23A > 3U) {
#line 2316
        printk("\016RTL8723AU: matched by ssid\n");
      } else {

      }
#line 2317
      matched = 1U;
#line 2318
      goto ldv_51965;
    } else {

    }
  } else {

  }
  ldv_51961: 
#line 2275
  plist = ptmp;
#line 2275
  ptmp = plist->next;
  ldv_51967: ;
#line 2275
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2277
    goto ldv_51966;
  } else {

  }
  ldv_51965: 
#line 2323
  spin_unlock_bh(& queue->lock);
#line 2325
  if ((unsigned int )matched == 0U || (unsigned long )pnetwork == (unsigned long )((struct wlan_network *)0)) {
#line 2326
    ret = -2;
#line 2327
    if (GlobalDebugLevel23A > 3U) {
#line 2327
      printk("\016RTL8723AU: connect, matched == false, goto exit\n");
    } else {

    }
#line 2328
    goto exit;
  } else {

  }
#line 2331
  tmp___9 = cfg80211_infrastructure_mode(padapter, pnetwork->network.ifmode);
#line 2331
  if (tmp___9 != 1) {
#line 2333
    ret = -1;
#line 2334
    goto exit;
  } else {

  }
#line 2337
  psecuritypriv->ndisencryptstatus = 1U;
#line 2338
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
#line 2339
  psecuritypriv->dot118021XGrpPrivacy = 0U;
#line 2340
  psecuritypriv->dot11AuthAlgrthm = 0U;
#line 2341
  psecuritypriv->ndisauthtype = 0U;
#line 2343
  ret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);
#line 2346
  if (ret < 0) {
#line 2347
    goto exit;
  } else {

  }
#line 2349
  ret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);
#line 2351
  if (ret < 0) {
#line 2352
    goto exit;
  } else {

  }
#line 2354
  if (GlobalDebugLevel23A > 3U) {
#line 2354
    printk("\016RTL8723AU: %s, ie_len =%zu\n", "cfg80211_rtw_connect", sme->ie_len);
  } else {

  }
#line 2356
  ret = rtw_cfg80211_set_wpa_ie(padapter, sme->ie, sme->ie_len);
#line 2357
  if (ret < 0) {
#line 2358
    goto exit;
  } else {

  }
#line 2360
  if (sme->crypto.n_ciphers_pairwise != 0) {
#line 2361
    ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0],
                                  1);
#line 2364
    if (ret < 0) {
#line 2365
      goto exit;
    } else {

    }
  } else {

  }
#line 2369
  if ((psecuritypriv->dot11AuthAlgrthm == 1U || psecuritypriv->dot11AuthAlgrthm == 3U) && (unsigned long )sme->key != (unsigned long )((u8 const   *)0U)) {
#line 2374
    if (GlobalDebugLevel23A > 3U) {
#line 2374
      printk("\016RTL8723AU: %s(): Shared/Auto WEP\n", "cfg80211_rtw_connect");
    } else {

    }
#line 2376
    wep_key_idx = sme->key_idx;
#line 2377
    wep_key_len = sme->key_len;
#line 2379
    if (((unsigned int )wep_key_idx > 4U || (unsigned int )wep_key_len == 0U) || (unsigned int )wep_key_len > 13U) {
#line 2381
      ret = -22;
#line 2382
      goto exit;
    } else {

    }
#line 2385
    wep_key_len = (unsigned int )wep_key_len <= 5U ? 5U : 13U;
#line 2387
    memset((void *)(& wep_key), 0, 16UL);
#line 2389
    wep_key.keylen = (u16 )wep_key_len;
#line 2391
    if ((unsigned int )wep_key_len == 13U) {
#line 2392
      padapter->securitypriv.dot11PrivacyAlgrthm = 1027077U;
#line 2394
      padapter->securitypriv.dot118021XGrpPrivacy = 1027077U;
    } else {
#line 2397
      padapter->securitypriv.dot11PrivacyAlgrthm = 1027073U;
#line 2399
      padapter->securitypriv.dot118021XGrpPrivacy = 1027073U;
    }
#line 2403
    __len___1 = (size_t )wep_key.keylen;
#line 2403
    __ret___1 = __builtin_memcpy((void *)(& wep_key.key), (void const   *)sme->key,
                                 __len___1);
#line 2405
    tmp___10 = rtw_cfg80211_add_wep(padapter, & wep_key, (int )wep_key_idx);
#line 2405
    if (tmp___10 != 1) {
#line 2407
      ret = -95;
    } else {

    }
#line 2409
    if (ret < 0) {
#line 2410
      goto exit;
    } else {

    }
  } else {

  }
#line 2413
  ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, 0);
#line 2415
  if (ret < 0) {
#line 2416
    return (ret);
  } else {

  }
#line 2418
  if (sme->crypto.n_akm_suites != 0) {
#line 2419
    ret = rtw_cfg80211_set_key_mgt(psecuritypriv, sme->crypto.akm_suites[0]);
#line 2421
    if (ret < 0) {
#line 2422
      goto exit;
    } else {

    }
  } else {

  }
#line 2425
  authmode = (enum ndis_802_11_auth_mode )psecuritypriv->ndisauthtype;
#line 2426
  rtw_set_802_11_authentication_mode23a(padapter, authmode);
#line 2431
  tmp___11 = rtw_set_802_11_ssid23a(padapter, & ndis_ssid);
#line 2431
  if (tmp___11 == 0) {
#line 2432
    ret = -1;
#line 2433
    goto exit;
  } else {

  }
#line 2436
  if (GlobalDebugLevel23A > 3U) {
#line 2436
    printk("\016RTL8723AU: set ssid:dot11AuthAlgrthm =%d, dot11PrivacyAlgrthm =%d, dot118021XGrpPrivacy =%d\n",
           psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy);
  } else {

  }
  exit: ;
#line 2443
  if (GlobalDebugLevel23A > 3U) {
#line 2443
    printk("\016RTL8723AU: <=%s, ret %d\n", "cfg80211_rtw_connect", ret);
  } else {

  }
#line 2445
  return (ret);
}
}
#line 2448 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_disconnect(struct wiphy *wiphy , struct net_device *ndev ,
                                   u16 reason_code ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  bool tmp___0 ;

  {
#line 2451
  tmp = wiphy_priv___1(wiphy);
#line 2451
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2453
  if (GlobalDebugLevel23A > 3U) {
#line 2453
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_disconnect", (char *)(& ndev->name));
  } else {

  }
#line 2455
  rtw_set_roaming(padapter, 0);
#line 2457
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 2457
  if ((int )tmp___0) {
#line 2458
    rtw_scan_abort23a(padapter);
#line 2459
    LeaveAllPowerSaveMode23a(padapter);
#line 2460
    rtw_disassoc_cmd23a(padapter, 500U, 0);
#line 2462
    if (GlobalDebugLevel23A > 3U) {
#line 2462
      printk("\016RTL8723AU: %s...call rtw_indicate_disconnect23a\n", "cfg80211_rtw_disconnect");
    } else {

    }
#line 2464
    padapter->mlmepriv.not_indic_disco = 1U;
#line 2465
    rtw_indicate_disconnect23a(padapter);
#line 2466
    padapter->mlmepriv.not_indic_disco = 0U;
#line 2468
    rtw_free_assoc_resources23a(padapter, 1);
  } else {

  }
#line 2471
  return (0);
}
}
#line 2474 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_set_txpower(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                    enum nl80211_tx_power_setting type , int mbm ) 
{ 


  {
#line 2478
  if (GlobalDebugLevel23A > 3U) {
#line 2478
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_set_txpower");
  } else {

  }
#line 2479
  return (0);
}
}
#line 2482 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_get_txpower(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                    int *dbm ) 
{ 


  {
#line 2485
  if (GlobalDebugLevel23A > 3U) {
#line 2485
    printk("\016RTL8723AU: %s\n", "cfg80211_rtw_get_txpower");
  } else {

  }
#line 2486
  *dbm = 12;
#line 2487
  return (0);
}
}
#line 2496 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy , struct net_device *ndev ,
                                       bool enabled , int timeout ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct rtw_wdev_priv *rtw_wdev_priv ;
  void *tmp___0 ;

  {
#line 2500
  tmp = wiphy_priv___1(wiphy);
#line 2500
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2501
  tmp___0 = wdev_priv___1(padapter->rtw_wdev);
#line 2501
  rtw_wdev_priv = (struct rtw_wdev_priv *)tmp___0;
#line 2503
  if (GlobalDebugLevel23A > 3U) {
#line 2503
    printk("\016RTL8723AU: %s(%s): enabled:%u, timeout:%d\n", "cfg80211_rtw_set_power_mgmt",
           (char *)(& ndev->name), (int )enabled, timeout);
  } else {

  }
#line 2506
  rtw_wdev_priv->power_mgmt = enabled;
#line 2508
  if (! enabled) {
#line 2509
    LPS_Leave23a(padapter);
  } else {

  }
#line 2511
  return (0);
}
}
#line 2514 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy , struct net_device *netdev ,
                                  struct cfg80211_pmksa *pmksa ) 
{ 
  u8 index ;
  u8 blInserted ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;
  size_t __len ;
  void *__ret ;
  bool tmp___1 ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 2518
  blInserted = 0U;
#line 2519
  tmp = wiphy_priv___1(wiphy);
#line 2519
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2520
  psecuritypriv = & padapter->securitypriv;
#line 2522
  if (GlobalDebugLevel23A > 3U) {
#line 2522
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_set_pmksa", (char *)(& netdev->name));
  } else {

  }
#line 2524
  tmp___0 = is_zero_ether_addr(pmksa->bssid);
#line 2524
  if ((int )tmp___0) {
#line 2525
    return (-22);
  } else {

  }
#line 2527
  blInserted = 0U;
#line 2530
  index = 0U;
#line 2530
  goto ldv_52022;
  ldv_52021: 
#line 2531
  tmp___1 = ether_addr_equal((u8 const   *)(& psecuritypriv->PMKIDList[(int )index].Bssid),
                             pmksa->bssid);
#line 2531
  if ((int )tmp___1) {
#line 2535
    if (GlobalDebugLevel23A > 3U) {
#line 2535
      printk("\016RTL8723AU: %s(%s):  BSSID exists in the PMKList.\n", "cfg80211_rtw_set_pmksa",
             (char *)(& netdev->name));
    } else {

    }
#line 2538
    __len = 16UL;
#line 2538
    if (__len > 63UL) {
#line 2538
      __ret = __memcpy((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID), (void const   *)pmksa->pmkid,
                       __len);
    } else {
#line 2538
      __ret = __builtin_memcpy((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID),
                               (void const   *)pmksa->pmkid, __len);
    }
#line 2540
    psecuritypriv->PMKIDList[(int )index].bUsed = 1U;
#line 2541
    psecuritypriv->PMKIDIndex = (unsigned int )index + 1U;
#line 2542
    blInserted = 1U;
#line 2543
    goto ldv_52020;
  } else {

  }
#line 2530
  index = (u8 )((int )index + 1);
  ldv_52022: ;
#line 2530
  if ((unsigned int )index <= 15U) {
#line 2532
    goto ldv_52021;
  } else {

  }
  ldv_52020: ;
#line 2547
  if ((unsigned int )blInserted == 0U) {
#line 2549
    if (GlobalDebugLevel23A > 3U) {
#line 2549
      printk("\016RTL8723AU: %s(%s): Use new entry index = %d for this PMKID\n", "cfg80211_rtw_set_pmksa",
             (char *)(& netdev->name), (int )psecuritypriv->PMKIDIndex);
    } else {

    }
#line 2552
    ether_addr_copy((u8 *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].Bssid),
                    pmksa->bssid);
#line 2555
    __len___0 = 16UL;
#line 2555
    if (__len___0 > 63UL) {
#line 2555
      __ret___0 = __memcpy((void *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].PMKID),
                           (void const   *)pmksa->pmkid, __len___0);
    } else {
#line 2555
      __ret___0 = __builtin_memcpy((void *)(& psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].PMKID),
                                   (void const   *)pmksa->pmkid, __len___0);
    }
#line 2558
    psecuritypriv->PMKIDList[(int )psecuritypriv->PMKIDIndex].bUsed = 1U;
#line 2560
    psecuritypriv->PMKIDIndex = (u8 )((int )psecuritypriv->PMKIDIndex + 1);
#line 2561
    if ((unsigned int )psecuritypriv->PMKIDIndex == 16U) {
#line 2562
      psecuritypriv->PMKIDIndex = 0U;
    } else {

    }
  } else {

  }
#line 2566
  return (0);
}
}
#line 2569 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy , struct net_device *netdev ,
                                  struct cfg80211_pmksa *pmksa ) 
{ 
  u8 index ;
  u8 bMatched ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;
  bool tmp___0 ;

  {
#line 2573
  bMatched = 0U;
#line 2574
  tmp = wiphy_priv___1(wiphy);
#line 2574
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2575
  psecuritypriv = & padapter->securitypriv;
#line 2577
  if (GlobalDebugLevel23A > 3U) {
#line 2577
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_del_pmksa", (char *)(& netdev->name));
  } else {

  }
#line 2579
  index = 0U;
#line 2579
  goto ldv_52038;
  ldv_52037: 
#line 2580
  tmp___0 = ether_addr_equal((u8 const   *)(& psecuritypriv->PMKIDList[(int )index].Bssid),
                             pmksa->bssid);
#line 2580
  if ((int )tmp___0) {
#line 2584
    eth_zero_addr((u8 *)(& psecuritypriv->PMKIDList[(int )index].Bssid));
#line 2585
    memset((void *)(& psecuritypriv->PMKIDList[(int )index].PMKID), 0, 16UL);
#line 2587
    psecuritypriv->PMKIDList[(int )index].bUsed = 0U;
#line 2588
    bMatched = 1U;
#line 2589
    goto ldv_52036;
  } else {

  }
#line 2579
  index = (u8 )((int )index + 1);
  ldv_52038: ;
#line 2579
  if ((unsigned int )index <= 15U) {
#line 2581
    goto ldv_52037;
  } else {

  }
  ldv_52036: ;
#line 2593
  if ((unsigned int )bMatched == 0U) {
#line 2594
    if (GlobalDebugLevel23A > 3U) {
#line 2594
      printk("\016RTL8723AU: %s(%s): do not have matched BSSID\n", "cfg80211_rtw_del_pmksa",
             (char *)(& netdev->name));
    } else {

    }
#line 2596
    return (-22);
  } else {

  }
#line 2599
  return (0);
}
}
#line 2602 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy , struct net_device *netdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct security_priv *psecuritypriv ;

  {
#line 2605
  tmp = wiphy_priv___1(wiphy);
#line 2605
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2606
  psecuritypriv = & padapter->securitypriv;
#line 2608
  if (GlobalDebugLevel23A > 3U) {
#line 2608
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_flush_pmksa", (char *)(& netdev->name));
  } else {

  }
#line 2610
  memset((void *)(& psecuritypriv->PMKIDList), 0, 1152UL);
#line 2612
  psecuritypriv->PMKIDIndex = 0U;
#line 2614
  return (0);
}
}
#line 2618 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter , u8 *pmgmt_frame ,
                                     uint frame_len ) 
{ 
  s32 freq ;
  int channel ;
  struct mlme_ext_priv *pmlmeext ;
  struct net_device *ndev ;

  {
#line 2623
  pmlmeext = & padapter->mlmeextpriv;
#line 2624
  ndev = padapter->pnetdev;
#line 2626
  if (GlobalDebugLevel23A > 3U) {
#line 2626
    printk("\016RTL8723AU: %s(padapter =%p,%s)\n", "rtw_cfg80211_indicate_sta_assoc",
           padapter, (char *)(& ndev->name));
  } else {

  }
#line 2645
  channel = (int )pmlmeext->cur_channel;
#line 2646
  if (channel <= 14) {
#line 2647
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
#line 2650
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
#line 2653
  cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const   *)pmgmt_frame, (size_t )frame_len,
                   0U, 32U);
#line 2654
  return;
}
}
#line 2658 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter , unsigned char *da ,
                                        unsigned short reason ) 
{ 
  s32 freq ;
  int channel ;
  u8 *pmgmt_frame ;
  uint frame_len ;
  struct ieee80211_hdr *pwlanhdr ;
  u8 mgmt_buf[128U] ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct net_device *ndev ;
  u8 *tmp ;
  u8 *tmp___0 ;

  {
#line 2668
  pmlmeext = & padapter->mlmeextpriv;
#line 2669
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2670
  ndev = padapter->pnetdev;
#line 2672
  if (GlobalDebugLevel23A > 3U) {
#line 2672
    printk("\016RTL8723AU: %s(padapter =%p,%s)\n", "rtw_cfg80211_indicate_sta_disassoc",
           padapter, (char *)(& ndev->name));
  } else {

  }
#line 2674
  memset((void *)(& mgmt_buf), 0, 128UL);
#line 2679
  channel = (int )pmlmeext->cur_channel;
#line 2680
  if (channel <= 14) {
#line 2681
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
#line 2684
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
#line 2687
  pmgmt_frame = (u8 *)(& mgmt_buf);
#line 2688
  pwlanhdr = (struct ieee80211_hdr *)pmgmt_frame;
#line 2690
  pwlanhdr->frame_control = 192U;
#line 2693
  tmp = myid(& padapter->eeprompriv);
#line 2693
  ether_addr_copy((u8 *)(& pwlanhdr->addr1), (u8 const   *)tmp);
#line 2694
  ether_addr_copy((u8 *)(& pwlanhdr->addr2), (u8 const   *)da);
#line 2695
  tmp___0 = get_my_bssid23a(& pmlmeinfo->network);
#line 2695
  ether_addr_copy((u8 *)(& pwlanhdr->addr3), (u8 const   *)tmp___0);
#line 2697
  pwlanhdr->seq_ctrl = (unsigned int )((unsigned short )((int )pmlmeext->mgnt_seq << 4)) & 65520U;
#line 2699
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 2701
  pmgmt_frame = pmgmt_frame + 24UL;
#line 2702
  frame_len = 24U;
#line 2704
  reason = reason;
#line 2705
  pmgmt_frame = rtw_set_fixed_ie23a(pmgmt_frame, 2U, (unsigned char *)(& reason),
                                    & frame_len);
#line 2709
  cfg80211_rx_mgmt(padapter->rtw_wdev, freq, 0, (u8 const   *)(& mgmt_buf), (size_t )frame_len,
                   0U, 32U);
#line 2710
  return;
}
}
#line 2714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_monitor_if_open(struct net_device *ndev ) 
{ 
  int ret ;

  {
#line 2716
  ret = 0;
#line 2718
  if (GlobalDebugLevel23A > 3U) {
#line 2718
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_open");
  } else {

  }
#line 2720
  return (ret);
}
}
#line 2723 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_monitor_if_close(struct net_device *ndev ) 
{ 
  int ret ;

  {
#line 2725
  ret = 0;
#line 2727
  if (GlobalDebugLevel23A > 3U) {
#line 2727
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_close");
  } else {

  }
#line 2729
  return (ret);
}
}
#line 2732 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb , struct net_device *ndev ) 
{ 
  int ret ;
  int rtap_len ;
  int qos_len ;
  int dot11_hdr_len ;
  int snap_len ;
  unsigned char *pdata ;
  unsigned char src_mac_addr[6U] ;
  unsigned char dst_mac_addr[6U] ;
  struct ieee80211_hdr *dot11_hdr ;
  struct ieee80211_radiotap_header *rtap_hdr ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct ieee80211_mgmt *mgmt ;
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  u32 len ;
  u8 category ;
  u8 action ;
  char const   *tmp___5 ;
  size_t __len___1 ;
  void *__ret___1 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 2735
  ret = 0;
#line 2737
  qos_len = 0;
#line 2738
  dot11_hdr_len = 24;
#line 2739
  snap_len = 6;
#line 2745
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 2745
  padapter = (struct rtw_adapter *)tmp;
#line 2747
  if (GlobalDebugLevel23A > 3U) {
#line 2747
    printk("\016RTL8723AU: %s(%s)\n", "rtw_cfg80211_monitor_if_xmit_entry", (char *)(& ndev->name));
  } else {

  }
#line 2749
  tmp___0 = ldv__builtin_expect(skb->len <= 7U, 0L);
#line 2749
  if (tmp___0 != 0L) {
#line 2750
    goto fail;
  } else {

  }
#line 2752
  rtap_hdr = (struct ieee80211_radiotap_header *)skb->data;
#line 2753
  tmp___1 = ldv__builtin_expect((unsigned int )rtap_hdr->it_version != 0U, 0L);
#line 2753
  if (tmp___1 != 0L) {
#line 2754
    goto fail;
  } else {

  }
#line 2756
  rtap_len = ieee80211_get_radiotap_len(skb->data);
#line 2757
  tmp___2 = ldv__builtin_expect(skb->len < (unsigned int )rtap_len, 0L);
#line 2757
  if (tmp___2 != 0L) {
#line 2758
    goto fail;
  } else {

  }
#line 2760
  if (rtap_len != 14) {
#line 2761
    if (GlobalDebugLevel23A > 3U) {
#line 2761
      printk("\016RTL8723AU: radiotap len (should be 14): %d\n", rtap_len);
    } else {

    }
#line 2762
    goto fail;
  } else {

  }
#line 2766
  skb_pull(skb, (unsigned int )rtap_len);
#line 2768
  dot11_hdr = (struct ieee80211_hdr *)skb->data;
#line 2770
  tmp___7 = ieee80211_is_data((int )dot11_hdr->frame_control);
#line 2770
  if (tmp___7 != 0) {
#line 2774
    tmp___3 = ieee80211_is_data_qos((int )dot11_hdr->frame_control);
#line 2774
    if (tmp___3 != 0) {
#line 2775
      qos_len = 2;
    } else {

    }
#line 2776
    tmp___4 = ieee80211_has_a4((int )dot11_hdr->frame_control);
#line 2776
    if (tmp___4 != 0) {
#line 2777
      dot11_hdr_len = dot11_hdr_len + 6;
    } else {

    }
#line 2779
    __len = 6UL;
#line 2779
    if (__len > 63UL) {
#line 2779
      __ret = __memcpy((void *)(& dst_mac_addr), (void const   *)(& dot11_hdr->addr1),
                       __len);
    } else {
#line 2779
      __ret = __builtin_memcpy((void *)(& dst_mac_addr), (void const   *)(& dot11_hdr->addr1),
                               __len);
    }
#line 2780
    __len___0 = 6UL;
#line 2780
    if (__len___0 > 63UL) {
#line 2780
      __ret___0 = __memcpy((void *)(& src_mac_addr), (void const   *)(& dot11_hdr->addr2),
                           __len___0);
    } else {
#line 2780
      __ret___0 = __builtin_memcpy((void *)(& src_mac_addr), (void const   *)(& dot11_hdr->addr2),
                                   __len___0);
    }
#line 2786
    skb_pull(skb, (unsigned int )(((dot11_hdr_len + qos_len) + snap_len) + -12));
#line 2788
    pdata = skb->data;
#line 2789
    ether_addr_copy(pdata, (u8 const   *)(& dst_mac_addr));
#line 2790
    ether_addr_copy(pdata + 6U, (u8 const   *)(& src_mac_addr));
#line 2792
    if (GlobalDebugLevel23A > 3U) {
#line 2792
      printk("\016RTL8723AU: should be eapol packet\n");
    } else {

    }
#line 2795
    ret = rtw_xmit23a_entry23a(skb, padapter->pnetdev);
#line 2797
    return (ret);
  } else {
#line 2799
    tmp___6 = ieee80211_is_action((int )dot11_hdr->frame_control);
#line 2799
    if (tmp___6 != 0) {
#line 2807
      pxmitpriv = & padapter->xmitpriv;
#line 2808
      pmlmeext = & padapter->mlmeextpriv;
#line 2809
      len = skb->len;
#line 2812
      mgmt = (struct ieee80211_mgmt *)dot11_hdr;
#line 2814
      if (GlobalDebugLevel23A > 3U) {
#line 2814
        printk("\016RTL8723AU: RTW_Tx:da =%02x:%02x:%02x:%02x:%02x:%02x via %s(%s)\n",
               (int )*((u8 *)(& mgmt->da)), (int )*((u8 *)(& mgmt->da) + 1UL), (int )*((u8 *)(& mgmt->da) + 2UL),
               (int )*((u8 *)(& mgmt->da) + 3UL), (int )*((u8 *)(& mgmt->da) + 4UL),
               (int )*((u8 *)(& mgmt->da) + 5UL), "rtw_cfg80211_monitor_if_xmit_entry",
               (char *)(& ndev->name));
      } else {

      }
#line 2816
      category = mgmt->u.action.category;
#line 2817
      action = mgmt->u.action.u.wme_action.action_code;
#line 2818
      if ((unsigned int )mgmt->u.action.category == 4U) {
#line 2819
        if (GlobalDebugLevel23A > 3U) {
#line 2819
          tmp___5 = action_public_str23a((int )action);
#line 2819
          printk("\016RTL8723AU: RTW_Tx:%s\n", tmp___5);
        } else {

        }
      } else
#line 2821
      if (GlobalDebugLevel23A > 3U) {
#line 2821
        printk("\016RTL8723AU: RTW_Tx:category(%u), action(%u)\n", (int )category,
               (int )action);
      } else {

      }
#line 2825
      pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 2826
      if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 2827
        goto fail;
      } else {

      }
#line 2830
      pattrib = & pmgntframe->attrib;
#line 2831
      update_mgntframe_attrib23a(padapter, pattrib);
#line 2832
      pattrib->retry_ctrl = 0U;
#line 2834
      memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 2836
      pframe = pmgntframe->buf_addr + 40U;
#line 2838
      __len___1 = (size_t )len;
#line 2838
      __ret___1 = __builtin_memcpy((void *)pframe, (void const   *)skb->data, __len___1);
#line 2839
      pattrib->pktlen = len;
#line 2842
      pmlmeext->mgnt_seq = (u16 )((int )dot11_hdr->seq_ctrl >> 4);
#line 2843
      pattrib->seqnum = pmlmeext->mgnt_seq;
#line 2844
      pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 2846
      pattrib->last_txcmdsz = pattrib->pktlen;
#line 2848
      dump_mgntframe23a(padapter, pmgntframe);
    } else {

    }
  }
  fail: 
#line 2853
  consume_skb(skb);
#line 2855
  return (0);
}
}
#line 2859 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev , void *addr ) 
{ 
  int ret ;

  {
#line 2861
  ret = 0;
#line 2863
  if (GlobalDebugLevel23A > 3U) {
#line 2863
    printk("\016RTL8723AU: %s\n", "rtw_cfg80211_monitor_if_set_mac_address");
  } else {

  }
#line 2865
  return (ret);
}
}
#line 2868 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static struct net_device_ops  const  rtw_cfg80211_monitor_if_ops  = 
#line 2868
     {0, 0, & rtw_cfg80211_monitor_if_open, & rtw_cfg80211_monitor_if_close, (netdev_tx_t (*)(struct sk_buff * ,
                                                                                            struct net_device * ))(& rtw_cfg80211_monitor_if_xmit_entry),
    0, 0, 0, & rtw_cfg80211_monitor_if_set_mac_address, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 2875 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_cfg80211_add_monitor_if(struct rtw_adapter *padapter , char *name ,
                                       struct net_device **ndev ) 
{ 
  int ret ;
  struct net_device *mon_ndev ;
  struct wireless_dev *mon_wdev ;
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;
  void *tmp___0 ;
  struct net_device *tmp___1 ;
  size_t __len ;
  void *__ret ;

  {
#line 2878
  ret = 0;
#line 2879
  mon_ndev = (struct net_device *)0;
#line 2880
  mon_wdev = (struct wireless_dev *)0;
#line 2881
  tmp = wdev_priv___1(padapter->rtw_wdev);
#line 2881
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
#line 2883
  if ((unsigned long )name == (unsigned long )((char *)0)) {
#line 2884
    if (GlobalDebugLevel23A > 3U) {
#line 2884
      printk("\016RTL8723AU: %s(%s): without specific name\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {

    }
#line 2886
    ret = -22;
#line 2887
    goto out;
  } else {

  }
#line 2890
  if ((unsigned long )pwdev_priv->pmon_ndev != (unsigned long )((struct net_device *)0)) {
#line 2891
    if (GlobalDebugLevel23A > 3U) {
#line 2891
      printk("\016RTL8723AU: %s(%s): monitor interface exist: %s\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name), (char *)(& (pwdev_priv->pmon_ndev)->name));
    } else {

    }
#line 2893
    ret = -16;
#line 2894
    goto out;
  } else {

  }
#line 2897
  mon_ndev = alloc_etherdev_mqs(18136, 1U, 1U);
#line 2898
  if ((unsigned long )mon_ndev == (unsigned long )((struct net_device *)0)) {
#line 2899
    if (GlobalDebugLevel23A > 3U) {
#line 2899
      printk("\016RTL8723AU: %s(%s): allocate ndev fail\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {

    }
#line 2901
    ret = -12;
#line 2902
    goto out;
  } else {

  }
#line 2905
  mon_ndev->type = 803U;
#line 2906
  strncpy((char *)(& mon_ndev->name), (char const   *)name, 16UL);
#line 2907
  mon_ndev->name[15] = 0;
#line 2908
  mon_ndev->destructor = & rtw_ndev_destructor;
#line 2910
  mon_ndev->netdev_ops = & rtw_cfg80211_monitor_if_ops;
#line 2913
  tmp___0 = kzalloc(984UL, 208U);
#line 2913
  mon_wdev = (struct wireless_dev *)tmp___0;
#line 2914
  if ((unsigned long )mon_wdev == (unsigned long )((struct wireless_dev *)0)) {
#line 2915
    if (GlobalDebugLevel23A > 3U) {
#line 2915
      printk("\016RTL8723AU: %s(%s): allocate mon_wdev fail\n", "rtw_cfg80211_add_monitor_if",
             (char *)(& (padapter->pnetdev)->name));
    } else {

    }
#line 2917
    ret = -12;
#line 2918
    goto out;
  } else {

  }
#line 2921
  mon_wdev->wiphy = (padapter->rtw_wdev)->wiphy;
#line 2922
  mon_wdev->netdev = mon_ndev;
#line 2923
  mon_wdev->iftype = 6;
#line 2924
  mon_ndev->ieee80211_ptr = mon_wdev;
#line 2926
  ret = register_netdevice(mon_ndev);
#line 2927
  if (ret != 0) {
#line 2928
    goto out;
  } else {

  }
#line 2931
  tmp___1 = mon_ndev;
#line 2931
  pwdev_priv->pmon_ndev = tmp___1;
#line 2931
  *ndev = tmp___1;
#line 2932
  __len = 17UL;
#line 2932
  if (__len > 63UL) {
#line 2932
    __ret = __memcpy((void *)(& pwdev_priv->ifname_mon), (void const   *)name, __len);
  } else {
#line 2932
    __ret = __builtin_memcpy((void *)(& pwdev_priv->ifname_mon), (void const   *)name,
                             __len);
  }
  out: ;
#line 2935
  if (ret != 0) {
#line 2936
    kfree((void const   *)mon_wdev);
#line 2937
    mon_wdev = (struct wireless_dev *)0;
  } else {

  }
#line 2940
  if (ret != 0 && (unsigned long )mon_ndev != (unsigned long )((struct net_device *)0)) {
#line 2941
    ldv_free_netdev_2079(mon_ndev);
#line 2942
    mon_ndev = (struct net_device *)0;
#line 2942
    *ndev = mon_ndev;
  } else {

  }
#line 2945
  return (ret);
}
}
#line 2949 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static struct wireless_dev *cfg80211_rtw_add_virtual_intf(struct wiphy *wiphy , char const   *name ,
                                                          enum nl80211_iftype type ,
                                                          u32 *flags , struct vif_params *params ) 
{ 
  int ret ;
  struct net_device *ndev ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  struct wireless_dev *tmp___2 ;

  {
#line 2953
  ret = 0;
#line 2954
  ndev = (struct net_device *)0;
#line 2955
  tmp = wiphy_priv___1(wiphy);
#line 2955
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 2957
  if (GlobalDebugLevel23A > 3U) {
#line 2957
    tmp___0 = wiphy_name((struct wiphy  const  *)wiphy);
#line 2957
    printk("\016RTL8723AU: %s(%s): wiphy:%s, name:%s, type:%d\n", "cfg80211_rtw_add_virtual_intf",
           (char *)(& (padapter->pnetdev)->name), tmp___0, name, (unsigned int )type);
  } else {

  }
#line 2960
  switch ((unsigned int )type) {
  case 1U: ;
  case 4U: ;
  case 5U: ;
  case 7U: 
#line 2965
  ret = -19;
#line 2966
  goto ldv_52152;
  case 6U: 
#line 2968
  ret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, & ndev);
#line 2970
  goto ldv_52152;
  case 8U: ;
  case 2U: 
#line 2974
  ret = -19;
#line 2975
  goto ldv_52152;
  case 9U: ;
  case 3U: 
#line 2979
  ret = -19;
#line 2980
  goto ldv_52152;
  default: 
#line 2982
  ret = -19;
#line 2983
  if (GlobalDebugLevel23A > 3U) {
#line 2983
    printk("\016RTL8723AU: Unsupported interface type\n");
  } else {

  }
#line 2984
  goto ldv_52152;
  }
  ldv_52152: ;
#line 2987
  if (GlobalDebugLevel23A > 3U) {
#line 2987
    printk("\016RTL8723AU: %s(%s): ndev:%p, ret:%d\n", "cfg80211_rtw_add_virtual_intf",
           (char *)(& (padapter->pnetdev)->name), ndev, ret);
  } else {

  }
#line 2991
  if ((unsigned long )ndev != (unsigned long )((struct net_device *)0)) {
#line 2991
    tmp___2 = ndev->ieee80211_ptr;
  } else {
#line 2991
    tmp___1 = ERR_PTR((long )ret);
#line 2991
    tmp___2 = (struct wireless_dev *)tmp___1;
  }
#line 2991
  return (tmp___2);
}
}
#line 2994 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy , struct wireless_dev *wdev ) 
{ 
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;
  struct net_device *ndev ;

  {
#line 2997
  tmp = wiphy_priv___1(wiphy);
#line 2997
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
#line 3000
  ndev = (unsigned long )wdev != (unsigned long )((struct wireless_dev *)0) ? wdev->netdev : (struct net_device *)0;
#line 3002
  if ((unsigned long )ndev == (unsigned long )((struct net_device *)0)) {
#line 3003
    goto exit;
  } else {

  }
#line 3005
  unregister_netdevice(ndev);
#line 3007
  if ((unsigned long )pwdev_priv->pmon_ndev == (unsigned long )ndev) {
#line 3008
    pwdev_priv->pmon_ndev = (struct net_device *)0;
#line 3009
    pwdev_priv->ifname_mon[0] = 0;
#line 3010
    if (GlobalDebugLevel23A > 3U) {
#line 3010
      printk("\016RTL8723AU: %s(%s): remove monitor interface\n", "cfg80211_rtw_del_virtual_intf",
             (char *)(& ndev->name));
    } else {

    }
  } else {

  }
  exit: ;
#line 3015
  return (0);
}
}
#line 3018 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int rtw_add_beacon(struct rtw_adapter *adapter , u8 const   *head , size_t head_len ,
                          u8 const   *tail , size_t tail_len ) 
{ 
  int ret ;
  u8 *pbuf ;
  uint len ;
  uint wps_ielen ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp___2 ;
  int tmp___3 ;

  {
#line 3021
  ret = 0;
#line 3022
  pbuf = (u8 *)0U;
#line 3023
  wps_ielen = 0U;
#line 3024
  pmlmepriv = & adapter->mlmepriv;
#line 3027
  if (GlobalDebugLevel23A > 3U) {
#line 3027
    printk("\016RTL8723AU: %s beacon_head_len =%zu, beacon_tail_len =%zu\n", "rtw_add_beacon",
           head_len, tail_len);
  } else {

  }
#line 3030
  tmp = check_fwstate(pmlmepriv, 16);
#line 3030
  if (tmp) {
#line 3030
    tmp___0 = 0;
  } else {
#line 3030
    tmp___0 = 1;
  }
#line 3030
  if (tmp___0) {
#line 3031
    return (-22);
  } else {

  }
#line 3033
  if (head_len <= 23UL) {
#line 3034
    return (-22);
  } else {

  }
#line 3036
  tmp___1 = kzalloc(head_len + tail_len, 208U);
#line 3036
  pbuf = (u8 *)tmp___1;
#line 3037
  if ((unsigned long )pbuf == (unsigned long )((u8 *)0U)) {
#line 3038
    return (-12);
  } else {

  }
#line 3040
  __len = head_len - 24UL;
#line 3040
  __ret = __builtin_memcpy((void *)pbuf, (void const   *)head + 24U, __len);
#line 3041
  __len___0 = tail_len;
#line 3041
  __ret___0 = __builtin_memcpy((void *)(pbuf + (head_len + 0xffffffffffffffe8UL)),
                               (void const   *)tail, __len___0);
#line 3043
  len = ((uint )head_len + (uint )tail_len) - 24U;
#line 3046
  tmp___2 = rtw_get_wps_ie23a(pbuf + 12UL, len - 12U, (u8 *)0U, & wps_ielen);
#line 3046
  if ((unsigned long )tmp___2 != (unsigned long )((u8 *)0U)) {
#line 3049
    if (GlobalDebugLevel23A > 3U) {
#line 3049
      printk("\016RTL8723AU: add bcn, wps_ielen =%d\n", wps_ielen);
    } else {

    }
  } else {

  }
#line 3052
  rtw_ies_remove_ie23a(pbuf, & len, 12U, 221, (u8 *)(& P2P_OUI23A), 4);
#line 3054
  rtw_ies_remove_ie23a(pbuf, & len, 12U, 221, (u8 *)(& WFD_OUI23A), 4);
#line 3057
  tmp___3 = rtw_check_beacon_data23a(adapter, pbuf, len);
#line 3057
  if (tmp___3 == 1) {
#line 3058
    ret = 0;
  } else {
#line 3060
    ret = -22;
  }
#line 3063
  kfree((void const   *)pbuf);
#line 3065
  return (ret);
}
}
#line 3068 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_start_ap(struct wiphy *wiphy , struct net_device *ndev , struct cfg80211_ap_settings *settings ) 
{ 
  int ret ;
  struct rtw_adapter *adapter ;
  void *tmp ;
  struct wlan_bssid_ex *pbss_network ;
  struct wlan_bssid_ex *pbss_network_ext ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 3071
  ret = 0;
#line 3072
  tmp = wiphy_priv___1(wiphy);
#line 3072
  adapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 3074
  if (GlobalDebugLevel23A > 3U) {
#line 3074
    printk("\016RTL8723AU: %s(%s): hidden_ssid:%d, auth_type:%d\n", "cfg80211_rtw_start_ap",
           (char *)(& ndev->name), (unsigned int )settings->hidden_ssid, (unsigned int )settings->auth_type);
  } else {

  }
#line 3078
  ret = rtw_add_beacon(adapter, settings->beacon.head, settings->beacon.head_len,
                       settings->beacon.tail, settings->beacon.tail_len);
#line 3082
  adapter->mlmeextpriv.mlmext_info.hidden_ssid_mode = (u8 )settings->hidden_ssid;
#line 3085
  if ((unsigned long )settings->ssid != (unsigned long )((u8 const   *)0U) && settings->ssid_len != 0UL) {
#line 3086
    pbss_network = & adapter->mlmepriv.cur_network.network;
#line 3088
    pbss_network_ext = & adapter->mlmeextpriv.mlmext_info.network;
#line 3091
    __len = settings->ssid_len;
#line 3091
    __ret = __builtin_memcpy((void *)(& pbss_network->Ssid.ssid), (void const   *)settings->ssid,
                             __len);
#line 3093
    pbss_network->Ssid.ssid_len = (u8 )settings->ssid_len;
#line 3094
    __len___0 = settings->ssid_len;
#line 3094
    __ret___0 = __builtin_memcpy((void *)(& pbss_network_ext->Ssid.ssid), (void const   *)settings->ssid,
                                 __len___0);
#line 3096
    pbss_network_ext->Ssid.ssid_len = (u8 )settings->ssid_len;
  } else {

  }
#line 3099
  return (ret);
}
}
#line 3102 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_change_beacon(struct wiphy *wiphy , struct net_device *ndev ,
                                      struct cfg80211_beacon_data *info ) 
{ 
  int ret ;
  struct rtw_adapter *adapter ;
  void *tmp ;

  {
#line 3106
  ret = 0;
#line 3107
  tmp = wiphy_priv___1(wiphy);
#line 3107
  adapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 3109
  if (GlobalDebugLevel23A > 3U) {
#line 3109
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_beacon", (char *)(& ndev->name));
  } else {

  }
#line 3111
  ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
#line 3114
  return (ret);
}
}
#line 3117 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_stop_ap(struct wiphy *wiphy , struct net_device *ndev ) 
{ 


  {
#line 3119
  if (GlobalDebugLevel23A > 3U) {
#line 3119
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_stop_ap", (char *)(& ndev->name));
  } else {

  }
#line 3120
  return (0);
}
}
#line 3123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_add_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const   *mac , struct station_parameters *params ) 
{ 


  {
#line 3127
  if (GlobalDebugLevel23A > 3U) {
#line 3127
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_add_station", (char *)(& ndev->name));
  } else {

  }
#line 3129
  return (0);
}
}
#line 3132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_del_station(struct wiphy *wiphy , struct net_device *ndev ,
                                    u8 const   *mac ) 
{ 
  int ret ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 updated ;
  struct sta_info *psta ;
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  struct list_head  const  *__mptr ;
  bool tmp___3 ;

  {
#line 3135
  ret = 0;
#line 3137
  updated = 0U;
#line 3139
  tmp = netdev_priv((struct net_device  const  *)ndev);
#line 3139
  padapter = (struct rtw_adapter *)tmp;
#line 3140
  pmlmepriv = & padapter->mlmepriv;
#line 3141
  pstapriv = & padapter->stapriv;
#line 3143
  if (GlobalDebugLevel23A > 3U) {
#line 3143
    printk("\016RTL8723AU: +%s(%s)\n", "cfg80211_rtw_del_station", (char *)(& ndev->name));
  } else {

  }
#line 3145
  tmp___0 = check_fwstate(pmlmepriv, 17);
#line 3145
  if (tmp___0) {
#line 3145
    tmp___1 = 0;
  } else {
#line 3145
    tmp___1 = 1;
  }
#line 3145
  if (tmp___1) {
#line 3146
    if (GlobalDebugLevel23A > 3U) {
#line 3146
      printk("\016RTL8723AU: %s, fw_state != FW_LINKED|WIFI_AP_STATE\n", "cfg80211_rtw_del_station");
    } else {

    }
#line 3148
    return (-22);
  } else {

  }
#line 3151
  if ((unsigned long )mac == (unsigned long )((u8 const   *)0U)) {
#line 3152
    if (GlobalDebugLevel23A > 3U) {
#line 3152
      printk("\016RTL8723AU: flush all sta, and cam_entry\n");
    } else {

    }
#line 3154
    flush_all_cam_entry23a(padapter);
#line 3156
    ret = rtw_sta_flush23a(padapter);
#line 3158
    return (ret);
  } else {

  }
#line 3161
  if (GlobalDebugLevel23A > 3U) {
#line 3161
    printk("\016RTL8723AU: free sta macaddr =%02x:%02x:%02x:%02x:%02x:%02x\n", (int )*((u8 *)mac),
           (int )*((u8 *)mac + 1UL), (int )*((u8 *)mac + 2UL), (int )*((u8 *)mac + 3UL),
           (int )*((u8 *)mac + 4UL), (int )*((u8 *)mac + 5UL));
  } else {

  }
#line 3163
  tmp___2 = is_broadcast_ether_addr(mac);
#line 3163
  if ((int )tmp___2) {
#line 3164
    return (-22);
  } else {

  }
#line 3166
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 3168
  phead = & pstapriv->asoc_list;
#line 3171
  plist = phead->next;
#line 3171
  ptmp = plist->next;
#line 3171
  goto ldv_52241;
  ldv_52240: 
#line 3172
  __mptr = (struct list_head  const  *)plist;
#line 3172
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 3174
  tmp___3 = ether_addr_equal(mac, (u8 const   *)(& psta->hwaddr));
#line 3174
  if ((int )tmp___3) {
#line 3175
    if (psta->dot8021xalg == 1 && (unsigned int )psta->bpairwise_key_installed == 0U) {
#line 3177
      if (GlobalDebugLevel23A > 3U) {
#line 3177
        printk("\016RTL8723AU: %s, sta\'s dot8021xalg = 1 and key_installed = false\n",
               "cfg80211_rtw_del_station");
      } else {

      }
    } else {
#line 3180
      if (GlobalDebugLevel23A > 3U) {
#line 3180
        printk("\016RTL8723AU: free psta =%p, aid =%d\n", psta, psta->aid);
      } else {

      }
#line 3183
      list_del_init(& psta->asoc_list);
#line 3184
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 3187
      updated = ap_free_sta23a(padapter, psta, 1, 3);
#line 3192
      psta = (struct sta_info *)0;
#line 3194
      goto ldv_52239;
    }
  } else {

  }
#line 3171
  plist = ptmp;
#line 3171
  ptmp = plist->next;
  ldv_52241: ;
#line 3171
  if ((unsigned long )plist != (unsigned long )phead) {
#line 3173
    goto ldv_52240;
  } else {

  }
  ldv_52239: 
#line 3199
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 3201
  associated_clients_update23a(padapter, (int )updated);
#line 3203
  if (GlobalDebugLevel23A > 3U) {
#line 3203
    printk("\016RTL8723AU: -%s(%s)\n", "cfg80211_rtw_del_station", (char *)(& ndev->name));
  } else {

  }
#line 3205
  return (ret);
}
}
#line 3208 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_change_station(struct wiphy *wiphy , struct net_device *ndev ,
                                       u8 const   *mac , struct station_parameters *params ) 
{ 


  {
#line 3212
  if (GlobalDebugLevel23A > 3U) {
#line 3212
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_station", (char *)(& ndev->name));
  } else {

  }
#line 3213
  return (0);
}
}
#line 3216 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_dump_station(struct wiphy *wiphy , struct net_device *ndev ,
                                     int idx , u8 *mac , struct station_info *sinfo ) 
{ 


  {
#line 3220
  if (GlobalDebugLevel23A > 3U) {
#line 3220
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_dump_station", (char *)(& ndev->name));
  } else {

  }
#line 3224
  return (-2);
}
}
#line 3227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_change_bss(struct wiphy *wiphy , struct net_device *ndev ,
                                   struct bss_parameters *params ) 
{ 


  {
#line 3230
  if (GlobalDebugLevel23A > 3U) {
#line 3230
    printk("\016RTL8723AU: %s(%s)\n", "cfg80211_rtw_change_bss", (char *)(& ndev->name));
  } else {

  }
#line 3231
  return (0);
}
}
#line 3235 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_cfg80211_rx_action(struct rtw_adapter *adapter , u8 *frame , uint frame_len ,
                            char const   *msg ) 
{ 
  struct ieee80211_mgmt *hdr ;
  s32 freq ;
  int channel ;
  u8 tmp ;

  {
#line 3238
  hdr = (struct ieee80211_mgmt *)frame;
#line 3242
  tmp = rtw_get_oper_ch23a(adapter);
#line 3242
  channel = (int )tmp;
#line 3244
  if (GlobalDebugLevel23A > 3U) {
#line 3244
    printk("\016RTL8723AU: RTW_Rx:cur_ch =%d\n", channel);
  } else {

  }
#line 3245
  if ((unsigned long )msg != (unsigned long )((char const   *)0)) {
#line 3246
    if (GlobalDebugLevel23A > 3U) {
#line 3246
      printk("\016RTL8723AU: RTW_Rx:%s\n", msg);
    } else {

    }
  } else
#line 3248
  if (GlobalDebugLevel23A > 3U) {
#line 3248
    printk("\016RTL8723AU: RTW_Rx:category(%u), action(%u)\n", (int )hdr->u.action.category,
           (int )hdr->u.action.u.wme_action.action_code);
  } else {

  }
#line 3252
  if (channel <= 14) {
#line 3253
    freq = ieee80211_channel_to_frequency(channel, 0);
  } else {
#line 3256
    freq = ieee80211_channel_to_frequency(channel, 1);
  }
#line 3259
  cfg80211_rx_mgmt(adapter->rtw_wdev, freq, 0, (u8 const   *)frame, (size_t )frame_len,
                   0U, 32U);
#line 3260
  return;
}
}
#line 3263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int _cfg80211_rtw_mgmt_tx(struct rtw_adapter *padapter , u8 tx_ch , u8 const   *buf ,
                                 size_t len ) 
{ 
  struct xmit_frame *pmgntframe ;
  struct pkt_attrib *pattrib ;
  unsigned char *pframe ;
  int ret ;
  struct ieee80211_hdr *pwlanhdr ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u8 tmp___2 ;
  size_t __len ;
  void *__ret ;

  {
#line 3269
  ret = 0;
#line 3271
  pxmitpriv = & padapter->xmitpriv;
#line 3272
  pmlmeext = & padapter->mlmeextpriv;
#line 3274
  tmp = _rtw_pwr_wakeup23a(padapter, 2000U, "_cfg80211_rtw_mgmt_tx");
#line 3274
  if (tmp == 0) {
#line 3275
    ret = -14;
#line 3276
    goto exit;
  } else {

  }
#line 3279
  rtw_set_scan_deny(padapter, 1000U);
#line 3281
  rtw_scan_abort23a(padapter);
#line 3283
  tmp___2 = rtw_get_oper_ch23a(padapter);
#line 3283
  if ((int )tmp___2 != (int )tx_ch) {
#line 3284
    tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 3284
    if (tmp___0) {
#line 3284
      tmp___1 = 0;
    } else {
#line 3284
      tmp___1 = 1;
    }
#line 3284
    if (tmp___1) {
#line 3285
      pmlmeext->cur_channel = tx_ch;
    } else {

    }
#line 3286
    set_channel_bwmode23a(padapter, (int )tx_ch, 0, 0);
  } else {

  }
#line 3292
  pmgntframe = alloc_mgtxmitframe23a(pxmitpriv);
#line 3293
  if ((unsigned long )pmgntframe == (unsigned long )((struct xmit_frame *)0)) {
#line 3295
    ret = 0;
#line 3296
    goto exit;
  } else {

  }
#line 3300
  pattrib = & pmgntframe->attrib;
#line 3301
  update_mgntframe_attrib23a(padapter, pattrib);
#line 3302
  pattrib->retry_ctrl = 0U;
#line 3304
  memset((void *)pmgntframe->buf_addr, 0, 104UL);
#line 3306
  pframe = pmgntframe->buf_addr + 40U;
#line 3308
  __len = len;
#line 3308
  __ret = __builtin_memcpy((void *)pframe, (void const   *)buf, __len);
#line 3309
  pattrib->pktlen = (u32 )len;
#line 3311
  pwlanhdr = (struct ieee80211_hdr *)pframe;
#line 3313
  pmlmeext->mgnt_seq = (u16 )((int )pwlanhdr->seq_ctrl >> 4);
#line 3314
  pattrib->seqnum = pmlmeext->mgnt_seq;
#line 3315
  pmlmeext->mgnt_seq = (u16 )((int )pmlmeext->mgnt_seq + 1);
#line 3317
  pattrib->last_txcmdsz = pattrib->pktlen;
#line 3319
  ret = dump_mgntframe23a_and_wait_ack23a(padapter, pmgntframe);
#line 3321
  if (ret != 1) {
#line 3322
    if (GlobalDebugLevel23A > 3U) {
#line 3322
      printk("\016RTL8723AU: %s, ack == false\n", "_cfg80211_rtw_mgmt_tx");
    } else {

    }
  } else
#line 3324
  if (GlobalDebugLevel23A > 3U) {
#line 3324
    printk("\016RTL8723AU: %s, ack == true\n", "_cfg80211_rtw_mgmt_tx");
  } else {

  }
  exit: ;
#line 3328
  if (GlobalDebugLevel23A > 3U) {
#line 3328
    printk("\016RTL8723AU: %s, ret =%d\n", "_cfg80211_rtw_mgmt_tx", ret);
  } else {

  }
#line 3330
  return (ret);
}
}
#line 3333 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                struct cfg80211_mgmt_tx_params *params , u64 *cookie ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  int ret ;
  int tx_ret ;
  u32 dump_limit ;
  u32 dump_cnt ;
  bool ack ;
  u8 category ;
  u8 action ;
  unsigned long start ;
  size_t len ;
  struct ieee80211_channel *chan ;
  u8 const   *buf ;
  struct ieee80211_mgmt *hdr ;
  u8 tx_ch ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 3337
  tmp = wiphy_priv___1(wiphy);
#line 3337
  padapter = ((struct rtw_wdev_priv *)tmp)->padapter;
#line 3339
  ret = 0;
#line 3341
  dump_limit = 8U;
#line 3342
  dump_cnt = 0U;
#line 3343
  ack = 1;
#line 3345
  start = jiffies;
#line 3346
  len = params->len;
#line 3347
  chan = params->chan;
#line 3348
  buf = params->buf;
#line 3349
  hdr = (struct ieee80211_mgmt *)buf;
#line 3350
  tmp___0 = ieee80211_frequency_to_channel((int )chan->center_freq);
#line 3350
  tx_ch = (unsigned char )tmp___0;
#line 3352
  tmp___1 = ieee80211_is_action((int )hdr->frame_control);
#line 3352
  if (tmp___1 == 0) {
#line 3353
    return (-22);
  } else {

  }
#line 3356
  *cookie = (u64 )buf;
#line 3358
  if (GlobalDebugLevel23A > 3U) {
#line 3358
    printk("\016RTL8723AU: %s(%s): len =%zu, ch =%d\n", "cfg80211_rtw_mgmt_tx", (char *)(& (padapter->pnetdev)->name),
           len, (int )tx_ch);
  } else {

  }
#line 3362
  cfg80211_mgmt_tx_status(padapter->rtw_wdev, *cookie, buf, len, (int )ack, 208U);
#line 3365
  if (GlobalDebugLevel23A > 3U) {
#line 3365
    printk("\016RTL8723AU: RTW_Tx:tx_ch =%d, da =%02x:%02x:%02x:%02x:%02x:%02x\n",
           (int )tx_ch, (int )*((u8 *)(& hdr->da)), (int )*((u8 *)(& hdr->da) + 1UL),
           (int )*((u8 *)(& hdr->da) + 2UL), (int )*((u8 *)(& hdr->da) + 3UL), (int )*((u8 *)(& hdr->da) + 4UL),
           (int )*((u8 *)(& hdr->da) + 5UL));
  } else {

  }
#line 3367
  category = hdr->u.action.category;
#line 3368
  action = hdr->u.action.u.wme_action.action_code;
#line 3369
  if ((unsigned int )category == 4U) {
#line 3370
    if (GlobalDebugLevel23A > 3U) {
#line 3370
      tmp___2 = action_public_str23a((int )action);
#line 3370
      printk("\016RTL8723AU: RTW_Tx:%s\n", tmp___2);
    } else {

    }
  } else
#line 3372
  if (GlobalDebugLevel23A > 3U) {
#line 3372
    printk("\016RTL8723AU: RTW_Tx:category(%u), action(%u)\n", (int )category, (int )action);
  } else {

  }
  ldv_52311: 
#line 3376
  dump_cnt = dump_cnt + 1U;
#line 3377
  tx_ret = _cfg80211_rtw_mgmt_tx(padapter, (int )tx_ch, buf, len);
#line 3378
  if (dump_cnt < dump_limit && tx_ret != 1) {
#line 3380
    goto ldv_52311;
  } else {

  }

#line 3380
  if (tx_ret != 1 || dump_cnt > 1U) {
#line 3381
    if (GlobalDebugLevel23A > 3U) {
#line 3381
      tmp___3 = jiffies_to_msecs((unsigned long )jiffies - start);
#line 3381
      printk("\016RTL8723AU: %s(%s): %s (%d/%d) in %d ms\n", "cfg80211_rtw_mgmt_tx",
             (char *)(& (padapter->pnetdev)->name), tx_ret == 1 ? (char *)"OK" : (char *)"FAIL",
             dump_cnt, dump_limit, tmp___3);
    } else {

    }
  } else {

  }
#line 3387
  return (ret);
}
}
#line 3390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy , struct wireless_dev *wdev ,
                                             u16 frame_type , bool reg ) 
{ 


  {
#line 3394
  if ((unsigned int )frame_type != 64U) {
#line 3395
    return;
  } else {

  }
#line 3397
  return;
}
}
#line 3400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static struct cfg80211_ops rtw_cfg80211_ops  = 
#line 3400
     {0, 0, 0, & cfg80211_rtw_add_virtual_intf, & cfg80211_rtw_del_virtual_intf, & cfg80211_rtw_change_iface,
    & cfg80211_rtw_add_key, & cfg80211_rtw_get_key, & cfg80211_rtw_del_key, & cfg80211_rtw_set_default_key,
    0, & cfg80211_rtw_start_ap, & cfg80211_rtw_change_beacon, & cfg80211_rtw_stop_ap,
    & cfg80211_rtw_add_station, & cfg80211_rtw_del_station, & cfg80211_rtw_change_station,
    & cfg80211_rtw_get_station, & cfg80211_rtw_dump_station, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & cfg80211_rtw_change_bss, 0, 0, 0, & cfg80211_rtw_scan, 0, 0, 0, 0, & cfg80211_rtw_connect,
    & cfg80211_rtw_disconnect, & cfg80211_rtw_join_ibss, & cfg80211_rtw_leave_ibss,
    0, & cfg80211_rtw_set_wiphy_params, & cfg80211_rtw_set_txpower, & cfg80211_rtw_get_txpower,
    0, 0, 0, 0, 0, 0, & cfg80211_rtw_set_pmksa, & cfg80211_rtw_del_pmksa, & cfg80211_rtw_flush_pmksa,
    0, 0, & cfg80211_rtw_mgmt_tx, 0, & cfg80211_rtw_set_power_mgmt, 0, 0, & cfg80211_rtw_mgmt_frame_register,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 3439 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap , enum ieee80211_band band ,
                                       u8 rf_type ) 
{ 


  {
#line 3446
  ht_cap->ht_supported = 1;
#line 3448
  ht_cap->cap = 6242U;
#line 3456
  ht_cap->ampdu_factor = 3U;
#line 3459
  ht_cap->ampdu_density = 7U;
#line 3461
  ht_cap->mcs.tx_params = 1U;
#line 3473
  if ((unsigned int )rf_type == 3U) {
#line 3474
    ht_cap->mcs.rx_mask[0] = 255U;
#line 3475
    ht_cap->mcs.rx_mask[1] = 0U;
#line 3476
    ht_cap->mcs.rx_mask[4] = 1U;
#line 3478
    ht_cap->mcs.rx_highest = 150U;
  } else
#line 3479
  if ((unsigned int )rf_type == 0U || (unsigned int )rf_type == 2U) {
#line 3480
    ht_cap->mcs.rx_mask[0] = 255U;
#line 3481
    ht_cap->mcs.rx_mask[1] = 255U;
#line 3482
    ht_cap->mcs.rx_mask[4] = 1U;
#line 3484
    ht_cap->mcs.rx_highest = 300U;
  } else
#line 3486
  if (GlobalDebugLevel23A > 3U) {
#line 3486
    printk("\016RTL8723AU: %s, error rf_type =%d\n", "rtw_cfg80211_init_ht_capab",
           (int )rf_type);
  } else {

  }
#line 3487
  return;
}
}
#line 3491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter ) 
{ 
  u8 rf_type ;
  struct ieee80211_supported_band *bands ;
  struct wireless_dev *pwdev ;
  struct wiphy *wiphy ;

  {
#line 3495
  pwdev = padapter->rtw_wdev;
#line 3496
  wiphy = pwdev->wiphy;
#line 3498
  rf_type = rtl8723a_get_rf_type(padapter);
#line 3500
  if (GlobalDebugLevel23A > 3U) {
#line 3500
    printk("\016RTL8723AU: %s:rf_type =%d\n", "rtw_cfg80211_init_wiphy", (int )rf_type);
  } else {

  }
#line 3504
  bands = wiphy->bands[0];
#line 3505
  if ((unsigned long )bands != (unsigned long )((struct ieee80211_supported_band *)0)) {
#line 3506
    rtw_cfg80211_init_ht_capab(& bands->ht_cap, 0, (int )rf_type);
  } else {

  }
#line 3513
  bands = wiphy->bands[1];
#line 3514
  if ((unsigned long )bands != (unsigned long )((struct ieee80211_supported_band *)0)) {
#line 3515
    rtw_cfg80211_init_ht_capab(& bands->ht_cap, 1, (int )rf_type);
  } else {

  }
#line 3516
  return;
}
}
#line 3521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
static void rtw_cfg80211_preinit_wiphy(struct rtw_adapter *padapter , struct wiphy *wiphy ) 
{ 


  {
#line 3524
  wiphy->signal_type = 1;
#line 3526
  wiphy->max_scan_ssids = 9U;
#line 3527
  wiphy->max_scan_ie_len = 2304U;
#line 3528
  wiphy->max_num_pmkids = 4U;
#line 3530
  wiphy->max_remain_on_channel_duration = 65535U;
#line 3533
  wiphy->interface_modes = 78U;
#line 3541
  wiphy->mgmt_stypes = (struct ieee80211_txrx_stypes  const  *)(& rtw_cfg80211_default_mgmt_stypes);
#line 3544
  wiphy->software_iftypes = (u16 )((unsigned int )wiphy->software_iftypes | 64U);
#line 3551
  wiphy->cipher_suites = (u32 const   *)(& rtw_cipher_suites);
#line 3552
  wiphy->n_cipher_suites = 4;
#line 3555
  wiphy->bands[0] = rtw_spt_band_alloc(0);
#line 3558
  wiphy->bands[1] = rtw_spt_band_alloc(1);
#line 3561
  wiphy->flags = wiphy->flags | 2097152U;
#line 3562
  wiphy->flags = wiphy->flags | 1179648U;
#line 3564
  if ((unsigned int )padapter->registrypriv.power_mgnt != 0U) {
#line 3565
    wiphy->flags = wiphy->flags | 16U;
  } else {
#line 3567
    wiphy->flags = wiphy->flags & 4294967279U;
  }
#line 3568
  return;
}
}
#line 3570 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int rtw_wdev_alloc(struct rtw_adapter *padapter , struct device *dev ) 
{ 
  int ret ;
  struct wiphy *wiphy ;
  struct wireless_dev *wdev ;
  struct rtw_wdev_priv *pwdev_priv ;
  struct net_device *pnetdev ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;

  {
#line 3572
  ret = 0;
#line 3576
  pnetdev = padapter->pnetdev;
#line 3578
  if (GlobalDebugLevel23A > 3U) {
#line 3578
    printk("\016RTL8723AU: %s(padapter =%p)\n", "rtw_wdev_alloc", padapter);
  } else {

  }
#line 3581
  wiphy = wiphy_new((struct cfg80211_ops  const  *)(& rtw_cfg80211_ops), 128);
#line 3582
  if ((unsigned long )wiphy == (unsigned long )((struct wiphy *)0)) {
#line 3583
    if (GlobalDebugLevel23A > 3U) {
#line 3583
      printk("\016RTL8723AU: Couldn\'t allocate wiphy device\n");
    } else {

    }
#line 3584
    ret = -12;
#line 3585
    goto exit;
  } else {

  }
#line 3589
  tmp = kzalloc(984UL, 208U);
#line 3589
  wdev = (struct wireless_dev *)tmp;
#line 3590
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
#line 3591
    if (GlobalDebugLevel23A > 3U) {
#line 3591
      printk("\016RTL8723AU: Couldn\'t allocate wireless device\n");
    } else {

    }
#line 3592
    ret = -12;
#line 3593
    goto free_wiphy;
  } else {

  }
#line 3596
  set_wiphy_dev(wiphy, dev);
#line 3597
  rtw_cfg80211_preinit_wiphy(padapter, wiphy);
#line 3599
  ret = wiphy_register(wiphy);
#line 3600
  if (ret < 0) {
#line 3601
    if (GlobalDebugLevel23A > 3U) {
#line 3601
      printk("\016RTL8723AU: Couldn\'t register wiphy device\n");
    } else {

    }
#line 3602
    goto free_wdev;
  } else {

  }
#line 3605
  wdev->wiphy = wiphy;
#line 3606
  wdev->netdev = pnetdev;
#line 3609
  wdev->iftype = 6;
#line 3610
  padapter->rtw_wdev = wdev;
#line 3611
  pnetdev->ieee80211_ptr = wdev;
#line 3614
  tmp___0 = wdev_priv___1(wdev);
#line 3614
  pwdev_priv = (struct rtw_wdev_priv *)tmp___0;
#line 3615
  pwdev_priv->rtw_wdev = wdev;
#line 3616
  pwdev_priv->pmon_ndev = (struct net_device *)0;
#line 3617
  pwdev_priv->ifname_mon[0] = 0;
#line 3618
  pwdev_priv->padapter = padapter;
#line 3619
  pwdev_priv->scan_request = (struct cfg80211_scan_request *)0;
#line 3620
  spinlock_check(& pwdev_priv->scan_req_lock);
#line 3620
  __raw_spin_lock_init(& pwdev_priv->scan_req_lock.ldv_6347.rlock, "&(&pwdev_priv->scan_req_lock)->rlock",
                       & __key);
#line 3622
  pwdev_priv->p2p_enabled = 0U;
#line 3624
  if ((unsigned int )padapter->registrypriv.power_mgnt != 0U) {
#line 3625
    pwdev_priv->power_mgmt = 1;
  } else {
#line 3627
    pwdev_priv->power_mgmt = 0;
  }
#line 3629
  return (ret);
  free_wdev: 
#line 3631
  kfree((void const   *)wdev);
  free_wiphy: 
#line 3633
  wiphy_free(wiphy);
  exit: ;
#line 3635
  return (ret);
}
}
#line 3638 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_wdev_free(struct wireless_dev *wdev ) 
{ 


  {
#line 3640
  if (GlobalDebugLevel23A > 3U) {
#line 3640
    printk("\016RTL8723AU: %s(wdev =%p)\n", "rtw_wdev_free", wdev);
  } else {

  }
#line 3642
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
#line 3643
    return;
  } else {

  }
#line 3645
  kfree((void const   *)(wdev->wiphy)->bands[0]);
#line 3646
  kfree((void const   *)(wdev->wiphy)->bands[1]);
#line 3648
  wiphy_free(wdev->wiphy);
#line 3650
  kfree((void const   *)wdev);
#line 3651
  return;
}
}
#line 3653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void rtw_wdev_unregister(struct wireless_dev *wdev ) 
{ 
  struct rtw_wdev_priv *pwdev_priv ;
  void *tmp ;

  {
#line 3657
  if (GlobalDebugLevel23A > 3U) {
#line 3657
    printk("\016RTL8723AU: %s(wdev =%p)\n", "rtw_wdev_unregister", wdev);
  } else {

  }
#line 3659
  if ((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0)) {
#line 3660
    return;
  } else {

  }
#line 3662
  tmp = wdev_priv___1(wdev);
#line 3662
  pwdev_priv = (struct rtw_wdev_priv *)tmp;
#line 3664
  rtw_cfg80211_indicate_scan_done(pwdev_priv, 1);
#line 3666
  if ((unsigned long )pwdev_priv->pmon_ndev != (unsigned long )((struct net_device *)0)) {
#line 3667
    if (GlobalDebugLevel23A > 3U) {
#line 3667
      printk("\016RTL8723AU: %s, unregister monitor interface\n", "rtw_wdev_unregister");
    } else {

    }
#line 3668
    ldv_unregister_netdev_2080(pwdev_priv->pmon_ndev);
  } else {

  }
#line 3671
  wiphy_unregister(wdev->wiphy);
#line 3672
  return;
}
}
#line 3674
extern int ldv_release_14(void) ;
#line 3675 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void (*ldvarg32)(void * , struct key_params * )  ;
#line 3676
extern int ldv_ndo_init_15(void) ;
#line 3677
extern int ldv_bind_14(void) ;
#line 3678 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int ldv_retval_5  ;
#line 3679 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int ldv_retval_4  ;
#line 3680 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int ldv_retval_6  ;
#line 3681
extern int ldv_ndo_uninit_15(void) ;
#line 3684 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_net_device_ops_15(void) 
{ 
  void *tmp ;

  {
#line 3685
  tmp = ldv_zalloc(3264UL);
#line 3685
  rtw_cfg80211_monitor_if_ops_group1 = (struct net_device *)tmp;
#line 3686
  return;
}
}
#line 3689 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_initialize_cfg80211_ops_14(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 3690
  tmp = ldv_zalloc(1760UL);
#line 3690
  rtw_cfg80211_ops_group1 = (struct wiphy *)tmp;
#line 3691
  tmp___0 = ldv_zalloc(12UL);
#line 3691
  rtw_cfg80211_ops_group5 = (struct vif_params *)tmp___0;
#line 3692
  tmp___1 = ldv_zalloc(120UL);
#line 3692
  rtw_cfg80211_ops_group2 = (struct station_parameters *)tmp___1;
#line 3693
  tmp___2 = ldv_zalloc(16UL);
#line 3693
  rtw_cfg80211_ops_group4 = (struct cfg80211_pmksa *)tmp___2;
#line 3694
  tmp___3 = ldv_zalloc(984UL);
#line 3694
  rtw_cfg80211_ops_group0 = (struct wireless_dev *)tmp___3;
#line 3695
  tmp___4 = ldv_zalloc(3264UL);
#line 3695
  rtw_cfg80211_ops_group6 = (struct net_device *)tmp___4;
#line 3696
  tmp___5 = ldv_zalloc(144UL);
#line 3696
  rtw_cfg80211_ops_group3 = (struct station_info *)tmp___5;
#line 3697
  return;
}
}
#line 3699 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_main_exported_15(void) 
{ 
  void *ldvarg2 ;
  void *tmp ;
  struct sk_buff *ldvarg3 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 3700
  tmp = ldv_zalloc(1UL);
#line 3700
  ldvarg2 = tmp;
#line 3701
  tmp___0 = ldv_zalloc(232UL);
#line 3701
  ldvarg3 = (struct sk_buff *)tmp___0;
#line 3703
  tmp___1 = __VERIFIER_nondet_int();
#line 3703
  switch (tmp___1) {
  case 0: ;
#line 3706
  if (ldv_state_variable_15 == 3) {
#line 3708
    rtw_cfg80211_monitor_if_close(rtw_cfg80211_monitor_if_ops_group1);
#line 3709
    ldv_state_variable_15 = 2;
  } else {

  }
#line 3712
  goto ldv_52389;
  case 1: ;
#line 3715
  if (ldv_state_variable_15 == 2) {
#line 3717
    ldv_retval_5 = rtw_cfg80211_monitor_if_open(rtw_cfg80211_monitor_if_ops_group1);
#line 3718
    if (ldv_retval_5 == 0) {
#line 3719
      ldv_state_variable_15 = 3;
    } else {

    }
  } else {

  }
#line 3723
  goto ldv_52389;
  case 2: ;
#line 3726
  if (ldv_state_variable_15 == 3) {
#line 3728
    rtw_cfg80211_monitor_if_xmit_entry(ldvarg3, rtw_cfg80211_monitor_if_ops_group1);
#line 3730
    ldv_state_variable_15 = 3;
  } else {

  }
#line 3733
  goto ldv_52389;
  case 3: ;
#line 3736
  if (ldv_state_variable_15 == 1) {
#line 3738
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg2);
#line 3740
    ldv_state_variable_15 = 1;
  } else {

  }
#line 3743
  if (ldv_state_variable_15 == 3) {
#line 3745
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg2);
#line 3747
    ldv_state_variable_15 = 3;
  } else {

  }
#line 3750
  if (ldv_state_variable_15 == 2) {
#line 3752
    rtw_cfg80211_monitor_if_set_mac_address(rtw_cfg80211_monitor_if_ops_group1, ldvarg2);
#line 3754
    ldv_state_variable_15 = 2;
  } else {

  }
#line 3757
  goto ldv_52389;
  case 4: ;
#line 3760
  if (ldv_state_variable_15 == 1) {
#line 3762
    ldv_retval_4 = ldv_ndo_init_15();
#line 3763
    if (ldv_retval_4 == 0) {
#line 3764
      ldv_state_variable_15 = 2;
#line 3765
      usb_counter = usb_counter + 1;
#line 3766
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 3770
  goto ldv_52389;
  case 5: ;
#line 3773
  if (ldv_state_variable_15 == 2) {
#line 3775
    ldv_ndo_uninit_15();
#line 3776
    ldv_state_variable_15 = 1;
#line 3777
    usb_counter = usb_counter - 1;
#line 3778
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 3781
  goto ldv_52389;
  default: 
#line 3782
  ldv_stop();
  }
  ldv_52389: ;
#line 3786
  return;
}
}
#line 3788 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_main_exported_14(void) 
{ 
  u16 ldvarg19 ;
  u16 tmp ;
  bool ldvarg22 ;
  u32 *ldvarg25 ;
  void *tmp___0 ;
  struct cfg80211_ap_settings *ldvarg17 ;
  void *tmp___1 ;
  int ldvarg21 ;
  int tmp___2 ;
  bool ldvarg30 ;
  int ldvarg15 ;
  int tmp___3 ;
  char *ldvarg27 ;
  void *tmp___4 ;
  enum nl80211_iftype ldvarg26 ;
  int ldvarg45 ;
  int tmp___5 ;
  u32 ldvarg9 ;
  u32 tmp___6 ;
  enum nl80211_iftype ldvarg40 ;
  bool ldvarg36 ;
  u8 *ldvarg10 ;
  void *tmp___7 ;
  u8 *ldvarg13 ;
  void *tmp___8 ;
  struct cfg80211_mgmt_tx_params *ldvarg8 ;
  void *tmp___9 ;
  struct key_params *ldvarg41 ;
  void *tmp___10 ;
  u8 ldvarg31 ;
  u8 tmp___11 ;
  u8 *ldvarg20 ;
  void *tmp___12 ;
  u32 *ldvarg39 ;
  void *tmp___13 ;
  u8 *ldvarg28 ;
  void *tmp___14 ;
  bool ldvarg34 ;
  struct cfg80211_connect_params *ldvarg14 ;
  void *tmp___15 ;
  struct bss_parameters *ldvarg4 ;
  void *tmp___16 ;
  enum nl80211_tx_power_setting ldvarg16 ;
  u16 ldvarg6 ;
  u16 tmp___17 ;
  u8 *ldvarg33 ;
  void *tmp___18 ;
  struct cfg80211_ibss_params *ldvarg5 ;
  void *tmp___19 ;
  struct cfg80211_beacon_data *ldvarg38 ;
  void *tmp___20 ;
  u8 ldvarg35 ;
  u8 tmp___21 ;
  u8 *ldvarg24 ;
  void *tmp___22 ;
  u8 *ldvarg44 ;
  void *tmp___23 ;
  void *ldvarg29 ;
  void *tmp___24 ;
  struct cfg80211_scan_request *ldvarg37 ;
  void *tmp___25 ;
  bool ldvarg46 ;
  int *ldvarg12 ;
  void *tmp___26 ;
  bool ldvarg42 ;
  u8 ldvarg43 ;
  u8 tmp___27 ;
  u8 ldvarg23 ;
  u8 tmp___28 ;
  u64 *ldvarg7 ;
  void *tmp___29 ;
  u8 *ldvarg11 ;
  void *tmp___30 ;
  bool ldvarg18 ;
  int tmp___31 ;

  {
#line 3789
  tmp = __VERIFIER_nondet_u16();
#line 3789
  ldvarg19 = tmp;
#line 3791
  tmp___0 = ldv_zalloc(4UL);
#line 3791
  ldvarg25 = (u32 *)tmp___0;
#line 3792
  tmp___1 = ldv_zalloc(224UL);
#line 3792
  ldvarg17 = (struct cfg80211_ap_settings *)tmp___1;
#line 3793
  tmp___2 = __VERIFIER_nondet_int();
#line 3793
  ldvarg21 = tmp___2;
#line 3795
  tmp___3 = __VERIFIER_nondet_int();
#line 3795
  ldvarg15 = tmp___3;
#line 3796
  tmp___4 = ldv_zalloc(1UL);
#line 3796
  ldvarg27 = (char *)tmp___4;
#line 3798
  tmp___5 = __VERIFIER_nondet_int();
#line 3798
  ldvarg45 = tmp___5;
#line 3799
  tmp___6 = __VERIFIER_nondet_u32();
#line 3799
  ldvarg9 = tmp___6;
#line 3802
  tmp___7 = ldv_zalloc(1UL);
#line 3802
  ldvarg10 = (u8 *)tmp___7;
#line 3803
  tmp___8 = ldv_zalloc(1UL);
#line 3803
  ldvarg13 = (u8 *)tmp___8;
#line 3804
  tmp___9 = ldv_zalloc(48UL);
#line 3804
  ldvarg8 = (struct cfg80211_mgmt_tx_params *)tmp___9;
#line 3805
  tmp___10 = ldv_zalloc(32UL);
#line 3805
  ldvarg41 = (struct key_params *)tmp___10;
#line 3806
  tmp___11 = __VERIFIER_nondet_u8();
#line 3806
  ldvarg31 = tmp___11;
#line 3807
  tmp___12 = ldv_zalloc(1UL);
#line 3807
  ldvarg20 = (u8 *)tmp___12;
#line 3808
  tmp___13 = ldv_zalloc(4UL);
#line 3808
  ldvarg39 = (u32 *)tmp___13;
#line 3809
  tmp___14 = ldv_zalloc(1UL);
#line 3809
  ldvarg28 = (u8 *)tmp___14;
#line 3811
  tmp___15 = ldv_zalloc(232UL);
#line 3811
  ldvarg14 = (struct cfg80211_connect_params *)tmp___15;
#line 3812
  tmp___16 = ldv_zalloc(40UL);
#line 3812
  ldvarg4 = (struct bss_parameters *)tmp___16;
#line 3814
  tmp___17 = __VERIFIER_nondet_u16();
#line 3814
  ldvarg6 = tmp___17;
#line 3815
  tmp___18 = ldv_zalloc(1UL);
#line 3815
  ldvarg33 = (u8 *)tmp___18;
#line 3816
  tmp___19 = ldv_zalloc(128UL);
#line 3816
  ldvarg5 = (struct cfg80211_ibss_params *)tmp___19;
#line 3817
  tmp___20 = ldv_zalloc(96UL);
#line 3817
  ldvarg38 = (struct cfg80211_beacon_data *)tmp___20;
#line 3818
  tmp___21 = __VERIFIER_nondet_u8();
#line 3818
  ldvarg35 = tmp___21;
#line 3819
  tmp___22 = ldv_zalloc(1UL);
#line 3819
  ldvarg24 = (u8 *)tmp___22;
#line 3820
  tmp___23 = ldv_zalloc(1UL);
#line 3820
  ldvarg44 = (u8 *)tmp___23;
#line 3821
  tmp___24 = ldv_zalloc(1UL);
#line 3821
  ldvarg29 = tmp___24;
#line 3822
  tmp___25 = ldv_zalloc(88UL);
#line 3822
  ldvarg37 = (struct cfg80211_scan_request *)tmp___25;
#line 3824
  tmp___26 = ldv_zalloc(4UL);
#line 3824
  ldvarg12 = (int *)tmp___26;
#line 3826
  tmp___27 = __VERIFIER_nondet_u8();
#line 3826
  ldvarg43 = tmp___27;
#line 3827
  tmp___28 = __VERIFIER_nondet_u8();
#line 3827
  ldvarg23 = tmp___28;
#line 3828
  tmp___29 = ldv_zalloc(8UL);
#line 3828
  ldvarg7 = (u64 *)tmp___29;
#line 3829
  tmp___30 = ldv_zalloc(1UL);
#line 3829
  ldvarg11 = (u8 *)tmp___30;
#line 3790
  memset((void *)(& ldvarg22), 0, 1UL);
#line 3794
  memset((void *)(& ldvarg30), 0, 1UL);
#line 3797
  memset((void *)(& ldvarg26), 0, 4UL);
#line 3800
  memset((void *)(& ldvarg40), 0, 4UL);
#line 3801
  memset((void *)(& ldvarg36), 0, 1UL);
#line 3810
  memset((void *)(& ldvarg34), 0, 1UL);
#line 3813
  memset((void *)(& ldvarg16), 0, 4UL);
#line 3823
  memset((void *)(& ldvarg46), 0, 1UL);
#line 3825
  memset((void *)(& ldvarg42), 0, 1UL);
#line 3830
  memset((void *)(& ldvarg18), 0, 1UL);
#line 3832
  tmp___31 = __VERIFIER_nondet_int();
#line 3832
  switch (tmp___31) {
  case 0: ;
#line 3835
  if (ldv_state_variable_14 == 1) {
#line 3837
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (int )ldvarg46, ldvarg45);
#line 3839
    ldv_state_variable_14 = 1;
  } else {

  }
#line 3842
  if (ldv_state_variable_14 == 3) {
#line 3844
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (int )ldvarg46, ldvarg45);
#line 3846
    ldv_state_variable_14 = 3;
  } else {

  }
#line 3849
  if (ldv_state_variable_14 == 2) {
#line 3851
    cfg80211_rtw_set_power_mgmt(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (int )ldvarg46, ldvarg45);
#line 3853
    ldv_state_variable_14 = 2;
  } else {

  }
#line 3856
  goto ldv_52442;
  case 1: ;
#line 3859
  if (ldv_state_variable_14 == 1) {
#line 3861
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg43,
                         (int )ldvarg42, (u8 const   *)ldvarg44, ldvarg41);
#line 3863
    ldv_state_variable_14 = 1;
  } else {

  }
#line 3866
  if (ldv_state_variable_14 == 3) {
#line 3868
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg43,
                         (int )ldvarg42, (u8 const   *)ldvarg44, ldvarg41);
#line 3870
    ldv_state_variable_14 = 3;
  } else {

  }
#line 3873
  if (ldv_state_variable_14 == 2) {
#line 3875
    cfg80211_rtw_add_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg43,
                         (int )ldvarg42, (u8 const   *)ldvarg44, ldvarg41);
#line 3877
    ldv_state_variable_14 = 2;
  } else {

  }
#line 3880
  goto ldv_52442;
  case 2: ;
#line 3883
  if (ldv_state_variable_14 == 1) {
#line 3885
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg40,
                              ldvarg39, rtw_cfg80211_ops_group5);
#line 3887
    ldv_state_variable_14 = 1;
  } else {

  }
#line 3890
  if (ldv_state_variable_14 == 3) {
#line 3892
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg40,
                              ldvarg39, rtw_cfg80211_ops_group5);
#line 3894
    ldv_state_variable_14 = 3;
  } else {

  }
#line 3897
  if (ldv_state_variable_14 == 2) {
#line 3899
    cfg80211_rtw_change_iface(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg40,
                              ldvarg39, rtw_cfg80211_ops_group5);
#line 3901
    ldv_state_variable_14 = 2;
  } else {

  }
#line 3904
  goto ldv_52442;
  case 3: ;
#line 3907
  if (ldv_state_variable_14 == 1) {
#line 3909
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg38);
#line 3911
    ldv_state_variable_14 = 1;
  } else {

  }
#line 3914
  if (ldv_state_variable_14 == 3) {
#line 3916
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg38);
#line 3918
    ldv_state_variable_14 = 3;
  } else {

  }
#line 3921
  if (ldv_state_variable_14 == 2) {
#line 3923
    cfg80211_rtw_change_beacon(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg38);
#line 3925
    ldv_state_variable_14 = 2;
  } else {

  }
#line 3928
  goto ldv_52442;
  case 4: ;
#line 3931
  if (ldv_state_variable_14 == 1) {
#line 3933
    cfg80211_rtw_scan(rtw_cfg80211_ops_group1, ldvarg37);
#line 3935
    ldv_state_variable_14 = 1;
  } else {

  }
#line 3938
  if (ldv_state_variable_14 == 3) {
#line 3940
    cfg80211_rtw_scan(rtw_cfg80211_ops_group1, ldvarg37);
#line 3942
    ldv_state_variable_14 = 3;
  } else {

  }
#line 3945
  if (ldv_state_variable_14 == 2) {
#line 3947
    cfg80211_rtw_scan(rtw_cfg80211_ops_group1, ldvarg37);
#line 3949
    ldv_state_variable_14 = 2;
  } else {

  }
#line 3952
  goto ldv_52442;
  case 5: ;
#line 3955
  if (ldv_state_variable_14 == 1) {
#line 3957
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                 (int )ldvarg35, (int )ldvarg34, (int )ldvarg36);
#line 3959
    ldv_state_variable_14 = 1;
  } else {

  }
#line 3962
  if (ldv_state_variable_14 == 3) {
#line 3964
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                 (int )ldvarg35, (int )ldvarg34, (int )ldvarg36);
#line 3966
    ldv_state_variable_14 = 3;
  } else {

  }
#line 3969
  if (ldv_state_variable_14 == 2) {
#line 3971
    cfg80211_rtw_set_default_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                 (int )ldvarg35, (int )ldvarg34, (int )ldvarg36);
#line 3973
    ldv_state_variable_14 = 2;
  } else {

  }
#line 3976
  goto ldv_52442;
  case 6: ;
#line 3979
  if (ldv_state_variable_14 == 1) {
#line 3981
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg31,
                         (int )ldvarg30, (u8 const   *)ldvarg33, ldvarg29, ldvarg32);
#line 3983
    ldv_state_variable_14 = 1;
  } else {

  }
#line 3986
  if (ldv_state_variable_14 == 3) {
#line 3988
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg31,
                         (int )ldvarg30, (u8 const   *)ldvarg33, ldvarg29, ldvarg32);
#line 3990
    ldv_state_variable_14 = 3;
  } else {

  }
#line 3993
  if (ldv_state_variable_14 == 2) {
#line 3995
    cfg80211_rtw_get_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg31,
                         (int )ldvarg30, (u8 const   *)ldvarg33, ldvarg29, ldvarg32);
#line 3997
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4000
  goto ldv_52442;
  case 7: ;
#line 4003
  if (ldv_state_variable_14 == 1) {
#line 4005
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
#line 4007
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4010
  if (ldv_state_variable_14 == 3) {
#line 4012
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
#line 4014
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4017
  if (ldv_state_variable_14 == 2) {
#line 4019
    cfg80211_rtw_del_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
#line 4021
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4024
  goto ldv_52442;
  case 8: ;
#line 4027
  if (ldv_state_variable_14 == 1) {
#line 4029
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0);
#line 4031
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4034
  if (ldv_state_variable_14 == 3) {
#line 4036
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0);
#line 4038
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4041
  if (ldv_state_variable_14 == 2) {
#line 4043
    cfg80211_rtw_del_virtual_intf(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0);
#line 4045
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4048
  goto ldv_52442;
  case 9: ;
#line 4051
  if (ldv_state_variable_14 == 1) {
#line 4053
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg28,
                             rtw_cfg80211_ops_group2);
#line 4055
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4058
  if (ldv_state_variable_14 == 3) {
#line 4060
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg28,
                             rtw_cfg80211_ops_group2);
#line 4062
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4065
  if (ldv_state_variable_14 == 2) {
#line 4067
    cfg80211_rtw_add_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg28,
                             rtw_cfg80211_ops_group2);
#line 4069
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4072
  goto ldv_52442;
  case 10: ;
#line 4075
  if (ldv_state_variable_14 == 1) {
#line 4077
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group1, (char const   *)ldvarg27,
                                  ldvarg26, ldvarg25, rtw_cfg80211_ops_group5);
#line 4079
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4082
  if (ldv_state_variable_14 == 3) {
#line 4084
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group1, (char const   *)ldvarg27,
                                  ldvarg26, ldvarg25, rtw_cfg80211_ops_group5);
#line 4086
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4089
  if (ldv_state_variable_14 == 2) {
#line 4091
    cfg80211_rtw_add_virtual_intf(rtw_cfg80211_ops_group1, (char const   *)ldvarg27,
                                  ldvarg26, ldvarg25, rtw_cfg80211_ops_group5);
#line 4093
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4096
  goto ldv_52442;
  case 11: ;
#line 4099
  if (ldv_state_variable_14 == 1) {
#line 4101
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg23,
                         (int )ldvarg22, (u8 const   *)ldvarg24);
#line 4103
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4106
  if (ldv_state_variable_14 == 3) {
#line 4108
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg23,
                         (int )ldvarg22, (u8 const   *)ldvarg24);
#line 4110
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4113
  if (ldv_state_variable_14 == 2) {
#line 4115
    cfg80211_rtw_del_key(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg23,
                         (int )ldvarg22, (u8 const   *)ldvarg24);
#line 4117
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4120
  goto ldv_52442;
  case 12: ;
#line 4123
  if (ldv_state_variable_14 == 1) {
#line 4125
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg21,
                              ldvarg20, rtw_cfg80211_ops_group3);
#line 4127
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4130
  if (ldv_state_variable_14 == 3) {
#line 4132
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg21,
                              ldvarg20, rtw_cfg80211_ops_group3);
#line 4134
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4137
  if (ldv_state_variable_14 == 2) {
#line 4139
    cfg80211_rtw_dump_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg21,
                              ldvarg20, rtw_cfg80211_ops_group3);
#line 4141
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4144
  goto ldv_52442;
  case 13: ;
#line 4147
  if (ldv_state_variable_14 == 1) {
#line 4149
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0,
                                     (int )ldvarg19, (int )ldvarg18);
#line 4151
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4154
  if (ldv_state_variable_14 == 3) {
#line 4156
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0,
                                     (int )ldvarg19, (int )ldvarg18);
#line 4158
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4161
  if (ldv_state_variable_14 == 2) {
#line 4163
    cfg80211_rtw_mgmt_frame_register(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0,
                                     (int )ldvarg19, (int )ldvarg18);
#line 4165
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4168
  goto ldv_52442;
  case 14: ;
#line 4171
  if (ldv_state_variable_14 == 1) {
#line 4173
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg17);
#line 4175
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4178
  if (ldv_state_variable_14 == 3) {
#line 4180
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg17);
#line 4182
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4185
  if (ldv_state_variable_14 == 2) {
#line 4187
    cfg80211_rtw_start_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg17);
#line 4189
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4192
  goto ldv_52442;
  case 15: ;
#line 4195
  if (ldv_state_variable_14 == 1) {
#line 4197
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg16,
                             ldvarg15);
#line 4199
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4202
  if (ldv_state_variable_14 == 3) {
#line 4204
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg16,
                             ldvarg15);
#line 4206
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4209
  if (ldv_state_variable_14 == 2) {
#line 4211
    cfg80211_rtw_set_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg16,
                             ldvarg15);
#line 4213
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4216
  goto ldv_52442;
  case 16: ;
#line 4219
  if (ldv_state_variable_14 == 2) {
#line 4221
    ldv_retval_6 = cfg80211_rtw_connect(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                        ldvarg14);
#line 4223
    if (ldv_retval_6 == 0) {
#line 4224
      ldv_state_variable_14 = 3;
    } else {

    }
  } else {

  }
#line 4228
  goto ldv_52442;
  case 17: ;
#line 4231
  if (ldv_state_variable_14 == 1) {
#line 4233
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
#line 4235
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4238
  if (ldv_state_variable_14 == 3) {
#line 4240
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
#line 4242
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4245
  if (ldv_state_variable_14 == 2) {
#line 4247
    cfg80211_rtw_flush_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
#line 4249
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4252
  goto ldv_52442;
  case 18: ;
#line 4255
  if (ldv_state_variable_14 == 1) {
#line 4257
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg13);
#line 4259
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4262
  if (ldv_state_variable_14 == 3) {
#line 4264
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg13);
#line 4266
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4269
  if (ldv_state_variable_14 == 2) {
#line 4271
    cfg80211_rtw_del_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg13);
#line 4273
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4276
  goto ldv_52442;
  case 19: ;
#line 4279
  if (ldv_state_variable_14 == 1) {
#line 4281
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg12);
#line 4283
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4286
  if (ldv_state_variable_14 == 3) {
#line 4288
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg12);
#line 4290
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4293
  if (ldv_state_variable_14 == 2) {
#line 4295
    cfg80211_rtw_get_txpower(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg12);
#line 4297
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4300
  goto ldv_52442;
  case 20: ;
#line 4303
  if (ldv_state_variable_14 == 1) {
#line 4305
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
#line 4307
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4310
  if (ldv_state_variable_14 == 3) {
#line 4312
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
#line 4314
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4317
  if (ldv_state_variable_14 == 2) {
#line 4319
    cfg80211_rtw_leave_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
#line 4321
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4324
  goto ldv_52442;
  case 21: ;
#line 4327
  if (ldv_state_variable_14 == 1) {
#line 4329
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg11,
                             rtw_cfg80211_ops_group3);
#line 4331
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4334
  if (ldv_state_variable_14 == 3) {
#line 4336
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg11,
                             rtw_cfg80211_ops_group3);
#line 4338
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4341
  if (ldv_state_variable_14 == 2) {
#line 4343
    cfg80211_rtw_get_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (u8 const   *)ldvarg11,
                             rtw_cfg80211_ops_group3);
#line 4345
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4348
  goto ldv_52442;
  case 22: ;
#line 4351
  if (ldv_state_variable_14 == 1) {
#line 4353
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (u8 const   *)ldvarg10, rtw_cfg80211_ops_group2);
#line 4355
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4358
  if (ldv_state_variable_14 == 3) {
#line 4360
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (u8 const   *)ldvarg10, rtw_cfg80211_ops_group2);
#line 4362
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4365
  if (ldv_state_variable_14 == 2) {
#line 4367
    cfg80211_rtw_change_station(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6,
                                (u8 const   *)ldvarg10, rtw_cfg80211_ops_group2);
#line 4369
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4372
  goto ldv_52442;
  case 23: ;
#line 4375
  if (ldv_state_variable_14 == 1) {
#line 4377
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group1, ldvarg9);
#line 4379
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4382
  if (ldv_state_variable_14 == 3) {
#line 4384
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group1, ldvarg9);
#line 4386
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4389
  if (ldv_state_variable_14 == 2) {
#line 4391
    cfg80211_rtw_set_wiphy_params(rtw_cfg80211_ops_group1, ldvarg9);
#line 4393
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4396
  goto ldv_52442;
  case 24: ;
#line 4399
  if (ldv_state_variable_14 == 1) {
#line 4401
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg8,
                         ldvarg7);
#line 4403
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4406
  if (ldv_state_variable_14 == 3) {
#line 4408
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg8,
                         ldvarg7);
#line 4410
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4413
  if (ldv_state_variable_14 == 2) {
#line 4415
    cfg80211_rtw_mgmt_tx(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group0, ldvarg8,
                         ldvarg7);
#line 4417
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4420
  goto ldv_52442;
  case 25: ;
#line 4423
  if (ldv_state_variable_14 == 3) {
#line 4425
    cfg80211_rtw_disconnect(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, (int )ldvarg6);
#line 4426
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4429
  goto ldv_52442;
  case 26: ;
#line 4432
  if (ldv_state_variable_14 == 1) {
#line 4434
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
#line 4436
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4439
  if (ldv_state_variable_14 == 3) {
#line 4441
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
#line 4443
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4446
  if (ldv_state_variable_14 == 2) {
#line 4448
    cfg80211_rtw_set_pmksa(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, rtw_cfg80211_ops_group4);
#line 4450
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4453
  goto ldv_52442;
  case 27: ;
#line 4456
  if (ldv_state_variable_14 == 1) {
#line 4458
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg5);
#line 4460
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4463
  if (ldv_state_variable_14 == 3) {
#line 4465
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg5);
#line 4467
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4470
  if (ldv_state_variable_14 == 2) {
#line 4472
    cfg80211_rtw_join_ibss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg5);
#line 4474
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4477
  goto ldv_52442;
  case 28: ;
#line 4480
  if (ldv_state_variable_14 == 1) {
#line 4482
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg4);
#line 4484
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4487
  if (ldv_state_variable_14 == 3) {
#line 4489
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg4);
#line 4491
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4494
  if (ldv_state_variable_14 == 2) {
#line 4496
    cfg80211_rtw_change_bss(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6, ldvarg4);
#line 4498
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4501
  goto ldv_52442;
  case 29: ;
#line 4504
  if (ldv_state_variable_14 == 1) {
#line 4506
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
#line 4508
    ldv_state_variable_14 = 1;
  } else {

  }
#line 4511
  if (ldv_state_variable_14 == 3) {
#line 4513
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
#line 4515
    ldv_state_variable_14 = 3;
  } else {

  }
#line 4518
  if (ldv_state_variable_14 == 2) {
#line 4520
    cfg80211_rtw_stop_ap(rtw_cfg80211_ops_group1, rtw_cfg80211_ops_group6);
#line 4522
    ldv_state_variable_14 = 2;
  } else {

  }
#line 4525
  goto ldv_52442;
  case 30: ;
#line 4528
  if (ldv_state_variable_14 == 2) {
#line 4530
    ldv_release_14();
#line 4531
    ldv_state_variable_14 = 1;
#line 4532
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 4535
  goto ldv_52442;
  case 31: ;
#line 4538
  if (ldv_state_variable_14 == 1) {
#line 4540
    ldv_bind_14();
#line 4541
    ldv_state_variable_14 = 2;
#line 4542
    ref_cnt = ref_cnt + 1;
  } else {

  }
#line 4545
  goto ldv_52442;
  default: 
#line 4546
  ldv_stop();
  }
  ldv_52442: ;
#line 4550
  return;
}
}
#line 4678 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void *ldv_kmem_cache_alloc_2062(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 4681
  ldv_check_alloc_flags(flags);
#line 4683
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 4684
  return ((void *)0);
}
}
#line 4722 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int ldv_pskb_expand_head_2068(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 4725
  ldv_check_alloc_flags(flags);
#line 4727
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 4727
  return (tmp);
}
}
#line 4738 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct sk_buff *ldv_skb_clone_2070(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4741
  ldv_check_alloc_flags(flags);
#line 4743
  tmp = skb_clone(ldv_func_arg1, flags);
#line 4743
  return (tmp);
}
}
#line 4754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct sk_buff *ldv_skb_copy_2072(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4757
  ldv_check_alloc_flags(flags);
#line 4759
  tmp = skb_copy(ldv_func_arg1, flags);
#line 4759
  return (tmp);
}
}
#line 4762 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2073(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4765
  ldv_check_alloc_flags(flags);
#line 4767
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 4767
  return (tmp);
}
}
#line 4770 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2074(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4773
  ldv_check_alloc_flags(flags);
#line 4775
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 4775
  return (tmp);
}
}
#line 4778 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2075(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4781
  ldv_check_alloc_flags(flags);
#line 4783
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 4783
  return (tmp);
}
}
#line 4786 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int ldv_pskb_expand_head_2076(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 4789
  ldv_check_alloc_flags(flags);
#line 4791
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 4791
  return (tmp);
}
}
#line 4794 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
int ldv_pskb_expand_head_2077(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 4797
  ldv_check_alloc_flags(flags);
#line 4799
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 4799
  return (tmp);
}
}
#line 4802 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
struct sk_buff *ldv_skb_clone_2078(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 4805
  ldv_check_alloc_flags(flags);
#line 4807
  tmp = skb_clone(ldv_func_arg1, flags);
#line 4807
  return (tmp);
}
}
#line 4810 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_free_netdev_2079(struct net_device *dev ) 
{ 


  {
#line 4813
  free_netdev(dev);
#line 4815
  ldv_state_variable_15 = 0;
#line 4816
  return;
}
}
#line 4818 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/ioctl_cfg80211.o.c.prepared"
void ldv_unregister_netdev_2080(struct net_device *dev ) 
{ 


  {
#line 4821
  unregister_netdev(dev);
#line 4823
  ldv_state_variable_15 = 0;
#line 4824
  return;
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2108(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_2116(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2124(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_2118(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_2114(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2122(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2123(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2119(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2120(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2121(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2697 "include/linux/netdevice.h"
extern void netif_carrier_off(struct net_device * ) ;
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
static struct rt_pmkid_list backupPMKIDList[16U]  ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
void rtw_reset_securitypriv23a(struct rtw_adapter *adapter ) 
{ 
  u8 backupPMKIDIndex ;
  u8 backupTKIPCountermeasure ;
  unsigned long backupTKIPcountermeasure_time ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  struct security_priv *psec_priv ;

  {
#line 245
  backupPMKIDIndex = 0U;
#line 246
  backupTKIPCountermeasure = 0U;
#line 247
  backupTKIPcountermeasure_time = 0UL;
#line 249
  if (adapter->securitypriv.dot11AuthAlgrthm == 2U) {
#line 257
    __len = 1152UL;
#line 257
    if (__len > 63UL) {
#line 257
      __ret = __memcpy((void *)(& backupPMKIDList), (void const   *)(& adapter->securitypriv.PMKIDList),
                       __len);
    } else {
#line 257
      __ret = __builtin_memcpy((void *)(& backupPMKIDList), (void const   *)(& adapter->securitypriv.PMKIDList),
                               __len);
    }
#line 259
    backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
#line 260
    backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
#line 261
    backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;
#line 263
    memset((void *)(& adapter->securitypriv), 0, 4776UL);
#line 268
    __len___0 = 1152UL;
#line 268
    if (__len___0 > 63UL) {
#line 268
      __ret___0 = __memcpy((void *)(& adapter->securitypriv.PMKIDList), (void const   *)(& backupPMKIDList),
                           __len___0);
    } else {
#line 268
      __ret___0 = __builtin_memcpy((void *)(& adapter->securitypriv.PMKIDList), (void const   *)(& backupPMKIDList),
                                   __len___0);
    }
#line 270
    adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
#line 271
    adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
#line 272
    adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;
#line 274
    adapter->securitypriv.ndisauthtype = 0U;
#line 275
    adapter->securitypriv.ndisencryptstatus = 1U;
  } else {
#line 277
    psec_priv = & adapter->securitypriv;
#line 280
    psec_priv->dot11AuthAlgrthm = 0U;
#line 281
    psec_priv->dot11PrivacyAlgrthm = 0U;
#line 282
    psec_priv->dot11PrivacyKeyIndex = 0U;
#line 284
    psec_priv->dot118021XGrpPrivacy = 0U;
#line 285
    psec_priv->dot118021XGrpKeyid = 1U;
#line 287
    psec_priv->ndisauthtype = 0U;
#line 288
    psec_priv->ndisencryptstatus = 1U;
  }
#line 290
  return;
}
}
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
void rtw_os_indicate_disconnect23a(struct rtw_adapter *adapter ) 
{ 


  {
#line 295
  netif_carrier_off(adapter->pnetdev);
#line 297
  rtw_cfg80211_indicate_disconnect(adapter);
#line 299
  rtw_reset_securitypriv23a(adapter);
#line 300
  return;
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
void *ldv_kmem_cache_alloc_2108(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 432
  ldv_check_alloc_flags(flags);
#line 434
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 435
  return ((void *)0);
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
int ldv_pskb_expand_head_2114(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 476
  ldv_check_alloc_flags(flags);
#line 478
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 478
  return (tmp);
}
}
#line 489 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2116(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 492
  ldv_check_alloc_flags(flags);
#line 494
  tmp = skb_clone(ldv_func_arg1, flags);
#line 494
  return (tmp);
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
struct sk_buff *ldv_skb_copy_2118(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 508
  ldv_check_alloc_flags(flags);
#line 510
  tmp = skb_copy(ldv_func_arg1, flags);
#line 510
  return (tmp);
}
}
#line 513 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2119(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 516
  ldv_check_alloc_flags(flags);
#line 518
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 518
  return (tmp);
}
}
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2120(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 524
  ldv_check_alloc_flags(flags);
#line 526
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 526
  return (tmp);
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2121(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 532
  ldv_check_alloc_flags(flags);
#line 534
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 534
  return (tmp);
}
}
#line 537 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
int ldv_pskb_expand_head_2122(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 540
  ldv_check_alloc_flags(flags);
#line 542
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 542
  return (tmp);
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
int ldv_pskb_expand_head_2123(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 548
  ldv_check_alloc_flags(flags);
#line 550
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 550
  return (tmp);
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/mlme_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2124(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 556
  ldv_check_alloc_flags(flags);
#line 558
  tmp = skb_clone(ldv_func_arg1, flags);
#line 558
  return (tmp);
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 391 "include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 179 "include/linux/timer.h"
int ldv_mod_timer_2167(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 183
int ldv_mod_timer_2176(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 187
int ldv_mod_timer_2177(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 191
int ldv_mod_timer_2178(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 195
int ldv_mod_timer_2179(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 248
int ldv_del_timer_sync_2168(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_2169(struct timer_list *ldv_func_arg1 ) ;
#line 256
int ldv_del_timer_sync_2170(struct timer_list *ldv_func_arg1 ) ;
#line 260
int ldv_del_timer_sync_2171(struct timer_list *ldv_func_arg1 ) ;
#line 264
int ldv_del_timer_sync_2172(struct timer_list *ldv_func_arg1 ) ;
#line 268
int ldv_del_timer_sync_2173(struct timer_list *ldv_func_arg1 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2150(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
struct net_device *rtw_netdev_ops_group1 ;
#line 93
int ldv_state_variable_13 ;
#line 210
void ldv_net_device_ops_13(void) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_2158(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2166(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_2160(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_2156(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2164(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2165(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 1757 "include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1759
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2161(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2162(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2163(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 1959 "include/linux/netdevice.h"
extern int dev_alloc_name(struct net_device * , char const   * ) ;
#line 1978
void ldv_free_netdev_2175(struct net_device *dev ) ;
#line 1982
void ldv_free_netdev_2180(struct net_device *dev ) ;
#line 2164 "include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
#line 2166
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
#line 2167
  return;
}
}
#line 2180 "include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2184
  i = 0U;
#line 2184
  goto ldv_40936;
  ldv_40935: 
#line 2185
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2185
  txq = tmp;
#line 2186
  netif_tx_start_queue(txq);
#line 2184
  i = i + 1U;
  ldv_40936: ;
#line 2184
  if (dev->num_tx_queues > i) {
#line 2186
    goto ldv_40935;
  } else {

  }

#line 2191
  return;
}
}
#line 2200 "include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues___0(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2204
  i = 0U;
#line 2204
  goto ldv_40950;
  ldv_40949: 
#line 2205
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2205
  txq = tmp;
#line 2206
  netif_tx_wake_queue(txq);
#line 2204
  i = i + 1U;
  ldv_40950: ;
#line 2204
  if (dev->num_tx_queues > i) {
#line 2206
    goto ldv_40949;
  } else {

  }

#line 2211
  return;
}
}
#line 2231 "include/linux/netdevice.h"
__inline static void netif_tx_stop_all_queues___0(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2235
  i = 0U;
#line 2235
  goto ldv_40966;
  ldv_40965: 
#line 2236
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2236
  txq = tmp;
#line 2237
  netif_tx_stop_queue(txq);
#line 2235
  i = i + 1U;
  ldv_40966: ;
#line 2235
  if (dev->num_tx_queues > i) {
#line 2237
    goto ldv_40965;
  } else {

  }

#line 2242
  return;
}
}
#line 2998
extern int register_netdev(struct net_device * ) ;
#line 3001
int ldv_register_netdev_2174(struct net_device *dev ) ;
#line 23 "include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 25
  tmp = skb_network_header(skb);
#line 25
  return ((struct iphdr *)tmp);
}
}
#line 36 "drivers/staging/rtl8723au/include/xmit_osdep.h"
int netdev_open23a(struct net_device *pnetdev ) ;
#line 103 "drivers/staging/rtl8723au/include/hal_intf.h"
int pm_netdev_open23a(struct net_device *pnetdev , u8 bnormal ) ;
#line 25 "drivers/staging/rtl8723au/include/osdep_intf.h"
int rtw_init_drv_sw23a(struct rtw_adapter *padapter ) ;
#line 26
int rtw_free_drv_sw23a(struct rtw_adapter *padapter ) ;
#line 27
int rtw_reset_drv_sw23a(struct rtw_adapter *padapter ) ;
#line 31
int rtw_init_netdev23a_name23a(struct net_device *pnetdev , char const   *ifname___0 ) ;
#line 32
struct net_device *rtw_init_netdev23a(struct rtw_adapter *old_padapter ) ;
#line 34
u16 rtw_recv_select_queue23a(struct sk_buff *skb ) ;
#line 36
void rtw_ips_dev_unload23a(struct rtw_adapter *padapter ) ;
#line 41
int rtw_drv_register_netdev(struct rtw_adapter *if1 ) ;
#line 46
void rtl8723a_usb_intf_stop(struct rtw_adapter *padapter ) ;
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_chip_version  =    0;
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_rfintfs  =    2;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_debug  =    1;
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_channel  =    1;
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_wireless_mode  =    11;
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_vrtl_carrier_sense  =    2;
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_vcs_type  =    1;
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_rts_thresh  =    2347;
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_frag_thresh  =    2346;
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_preamble  =    1;
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_scan_mode  =    1;
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_adhoc_tx_pwr  =    1;
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_soft_ap  ;
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_power_mgnt  =    1;
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_ips_mode  =    1;
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_smart_ps  =    2;
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_long_retry_lmt  =    7;
#line 276 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_short_retry_lmt  =    7;
#line 277 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_busy_thresh  =    40;
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_ack_policy  =    0;
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_acm_method  ;
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_wmm_enable  =    1;
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_uapsd_enable  ;
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_ht_enable  =    1;
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_cbw40_enable  =    3;
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_ampdu_enable  =    1;
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_rx_stbc  =    1;
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_ampdu_amsdu  ;
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_lowrate_two_xmit  =    1;
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_rf_config  =    5;
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_low_power  ;
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_wifi_spec  ;
#line 302 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_channel_plan  =    66;
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_btcoex_enable  =    1;
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_bt_iso  =    2;
#line 308 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_bt_sco  =    3;
#line 310 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_bt_ampdu  =    1;
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_AcceptAddbaReq  =    1;
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_antdiv_cfg  =    2;
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_antdiv_type  ;
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_hwpdn_mode  =    2;
#line 323 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_hwpwrp_detect  ;
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_hw_wps_pbc  =    1;
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_80211d  ;
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_regulatory_id  =    255;
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static char *ifname  =    (char *)"wlan%d";
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static char *if2name  =    (char *)"wlan%d";
#line 371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static uint rtw_max_roaming_times  =    2U;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static uint rtw_notch_filter  ;
#line 389
static int netdev_close(struct net_device *pnetdev ) ;
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int loadparam(struct rtw_adapter *padapter , struct net_device *pnetdev ) 
{ 
  struct registry_priv *registry_par ;
  int status ;
  size_t __len ;
  void *__ret ;

  {
#line 393
  registry_par = & padapter->registrypriv;
#line 394
  status = 1;
#line 396
  GlobalDebugLevel23A = (u32 )rtw_debug;
#line 397
  registry_par->chip_version = (unsigned char )rtw_chip_version;
#line 398
  registry_par->rfintfs = (unsigned char )rtw_rfintfs;
#line 399
  __len = 3UL;
#line 399
  if (__len > 63UL) {
#line 399
    __ret = __memcpy((void *)(& registry_par->ssid.ssid), (void const   *)"ANY", __len);
  } else {
#line 399
    __ret = __builtin_memcpy((void *)(& registry_par->ssid.ssid), (void const   *)"ANY",
                             __len);
  }
#line 400
  registry_par->ssid.ssid_len = 3U;
#line 401
  registry_par->channel = (unsigned char )rtw_channel;
#line 402
  registry_par->wireless_mode = (unsigned char )rtw_wireless_mode;
#line 403
  registry_par->vrtl_carrier_sense = (unsigned char )rtw_vrtl_carrier_sense;
#line 404
  registry_par->vcs_type = (unsigned char )rtw_vcs_type;
#line 405
  registry_par->rts_thresh = (unsigned short )rtw_rts_thresh;
#line 406
  registry_par->frag_thresh = (unsigned short )rtw_frag_thresh;
#line 407
  registry_par->preamble = (unsigned char )rtw_preamble;
#line 408
  registry_par->scan_mode = (unsigned char )rtw_scan_mode;
#line 409
  registry_par->adhoc_tx_pwr = (unsigned char )rtw_adhoc_tx_pwr;
#line 410
  registry_par->soft_ap = (unsigned char )rtw_soft_ap;
#line 411
  registry_par->smart_ps = (unsigned char )rtw_smart_ps;
#line 412
  registry_par->power_mgnt = (unsigned char )rtw_power_mgnt;
#line 413
  registry_par->ips_mode = (unsigned char )rtw_ips_mode;
#line 414
  registry_par->long_retry_lmt = (unsigned char )rtw_long_retry_lmt;
#line 415
  registry_par->short_retry_lmt = (unsigned char )rtw_short_retry_lmt;
#line 416
  registry_par->busy_thresh = (unsigned short )rtw_busy_thresh;
#line 417
  registry_par->ack_policy = (unsigned char )rtw_ack_policy;
#line 418
  registry_par->acm_method = (unsigned char )rtw_acm_method;
#line 420
  registry_par->wmm_enable = (unsigned char )rtw_wmm_enable;
#line 421
  registry_par->uapsd_enable = (unsigned char )rtw_uapsd_enable;
#line 422
  registry_par->ht_enable = (unsigned char )rtw_ht_enable;
#line 423
  registry_par->cbw40_enable = (unsigned char )rtw_cbw40_enable;
#line 424
  registry_par->ampdu_enable = (unsigned char )rtw_ampdu_enable;
#line 425
  registry_par->rx_stbc = (unsigned char )rtw_rx_stbc;
#line 426
  registry_par->ampdu_amsdu = (unsigned char )rtw_ampdu_amsdu;
#line 427
  registry_par->lowrate_two_xmit = (unsigned char )rtw_lowrate_two_xmit;
#line 428
  registry_par->rf_config = (unsigned char )rtw_rf_config;
#line 429
  registry_par->low_power = (unsigned char )rtw_low_power;
#line 430
  registry_par->wifi_spec = (unsigned char )rtw_wifi_spec;
#line 431
  registry_par->channel_plan = (unsigned char )rtw_channel_plan;
#line 433
  registry_par->btcoex = (unsigned char )rtw_btcoex_enable;
#line 434
  registry_par->bt_iso = (unsigned char )rtw_bt_iso;
#line 435
  registry_par->bt_sco = (unsigned char )rtw_bt_sco;
#line 436
  registry_par->bt_ampdu = (unsigned char )rtw_bt_ampdu;
#line 438
  registry_par->bAcceptAddbaReq = (unsigned int )((unsigned char )rtw_AcceptAddbaReq) != 0U;
#line 439
  registry_par->antdiv_cfg = (unsigned char )rtw_antdiv_cfg;
#line 440
  registry_par->antdiv_type = (unsigned char )rtw_antdiv_type;
#line 443
  registry_par->hwpdn_mode = (unsigned char )rtw_hwpdn_mode;
#line 445
  registry_par->hwpwrp_detect = (unsigned char )rtw_hwpwrp_detect;
#line 446
  registry_par->hw_wps_pbc = (unsigned char )rtw_hw_wps_pbc;
#line 447
  registry_par->max_roaming_times = (unsigned char )rtw_max_roaming_times;
#line 448
  registry_par->enable80211d = (unsigned char )rtw_80211d;
#line 449
  snprintf((char *)(& registry_par->ifname), 16UL, "%s", ifname);
#line 450
  snprintf((char *)(& registry_par->if2name), 16UL, "%s", if2name);
#line 451
  registry_par->notch_filter = (unsigned char )rtw_notch_filter;
#line 452
  registry_par->regulatory_tid = (unsigned char )rtw_regulatory_id;
#line 453
  return (status);
}
}
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_net_set_mac_address(struct net_device *pnetdev , void *p ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct sockaddr *addr ;

  {
#line 458
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 458
  padapter = (struct rtw_adapter *)tmp;
#line 459
  addr = (struct sockaddr *)p;
#line 461
  if (padapter->bup == 0) {
#line 462
    ether_addr_copy((u8 *)(& padapter->eeprompriv.mac_addr), (u8 const   *)(& addr->sa_data));
  } else {

  }
#line 463
  return (0);
}
}
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static struct net_device_stats *rtw_net_get_stats(struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct xmit_priv *pxmitpriv ;
  struct recv_priv *precvpriv ;

  {
#line 468
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 468
  padapter = (struct rtw_adapter *)tmp;
#line 469
  pxmitpriv = & padapter->xmitpriv;
#line 470
  precvpriv = & padapter->recvpriv;
#line 472
  padapter->stats.tx_packets = (unsigned long )pxmitpriv->tx_pkts;
#line 473
  padapter->stats.rx_packets = (unsigned long )precvpriv->rx_pkts;
#line 474
  padapter->stats.tx_dropped = (unsigned long )pxmitpriv->tx_drop;
#line 475
  padapter->stats.rx_dropped = (unsigned long )precvpriv->rx_drop;
#line 476
  padapter->stats.tx_bytes = (unsigned long )pxmitpriv->tx_bytes;
#line 477
  padapter->stats.rx_bytes = (unsigned long )precvpriv->rx_bytes;
#line 479
  return (& padapter->stats);
}
}
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static u16 const   rtw_1d_to_queue[8U]  = 
#line 490
  {      2U,      3U,      3U,      2U, 
        1U,      1U,      0U,      0U};
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static u32 rtw_classify8021d(struct sk_buff *skb ) 
{ 
  u32 dscp ;
  struct iphdr *tmp ;

  {
#line 502
  if (skb->priority > 255U && skb->priority <= 263U) {
#line 503
    return (skb->priority - 256U);
  } else {

  }
#line 504
  switch ((int )skb->protocol) {
  case 8: 
#line 506
  tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 506
  dscp = (u32 )tmp->tos & 252U;
#line 507
  goto ldv_54845;
  default: ;
#line 509
  return (0U);
  }
  ldv_54845: ;
#line 511
  return (dscp >> 5);
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static u16 rtw_select_queue(struct net_device *dev , struct sk_buff *skb , void *accel_priv ,
                            u16 (*fallback)(struct net_device * , struct sk_buff * ) ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct mlme_priv *pmlmepriv ;
  u8 tmp___0 ;

  {
#line 518
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 518
  padapter = (struct rtw_adapter *)tmp;
#line 519
  pmlmepriv = & padapter->mlmepriv;
#line 521
  skb->priority = rtw_classify8021d(skb);
#line 523
  if ((unsigned int )pmlmepriv->acm_mask != 0U) {
#line 524
    tmp___0 = qos_acm23a((int )pmlmepriv->acm_mask, (int )((u8 )skb->priority));
#line 524
    skb->priority = (__u32 )tmp___0;
  } else {

  }
#line 525
  return ((u16 )rtw_1d_to_queue[skb->priority]);
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
u16 rtw_recv_select_queue23a(struct sk_buff *skb ) 
{ 
  struct iphdr *piphdr ;
  struct ethhdr *eth ;
  unsigned int dscp ;
  u16 eth_type ;
  u16 tmp ;
  u32 priority ;
  u8 *pdata ;

  {
#line 531
  eth = (struct ethhdr *)skb->data;
#line 533
  tmp = get_unaligned_be16((void const   *)(& eth->h_proto));
#line 533
  eth_type = tmp;
#line 535
  pdata = skb->data;
#line 537
  switch ((int )eth_type) {
  case 2048: 
#line 539
  piphdr = (struct iphdr *)pdata + 14U;
#line 540
  dscp = (unsigned int )piphdr->tos & 252U;
#line 541
  priority = dscp >> 5;
#line 542
  goto ldv_54865;
  default: 
#line 544
  priority = 0U;
  }
  ldv_54865: ;
#line 546
  return ((u16 )rtw_1d_to_queue[priority]);
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static struct net_device_ops  const  rtw_netdev_ops  = 
#line 549
     {0, 0, & netdev_open23a, & netdev_close, (netdev_tx_t (*)(struct sk_buff * , struct net_device * ))(& rtw_xmit23a_entry23a),
    & rtw_select_queue, 0, 0, & rtw_net_set_mac_address, 0, 0, 0, 0, 0, 0, 0, & rtw_net_get_stats,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 558 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int rtw_init_netdev23a_name23a(struct net_device *pnetdev , char const   *ifname___0 ) 
{ 
  int tmp ;

  {
#line 560
  tmp = dev_alloc_name(pnetdev, ifname___0);
#line 560
  if (tmp < 0) {
#line 561
    if (GlobalDebugLevel23A > 3U) {
#line 561
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
#line 561
      printk("\016dev_alloc_name, fail!\n");
    } else {

    }
  } else {

  }
#line 564
  netif_carrier_off(pnetdev);
#line 565
  return (0);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static struct device_type  const  wlan_type  =    {"wlan", 0, 0, 0, 0, 0};
#line 572 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
struct net_device *rtw_init_netdev23a(struct rtw_adapter *old_padapter ) 
{ 
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  void *tmp ;

  {
#line 577
  if (GlobalDebugLevel23A > 6U) {
#line 577
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 577
    printk("\016+init_net_dev\n");
  } else {

  }
#line 579
  pnetdev = alloc_etherdev_mqs(18136, 4U, 4U);
#line 580
  if ((unsigned long )pnetdev == (unsigned long )((struct net_device *)0)) {
#line 581
    return ((struct net_device *)0);
  } else {

  }
#line 583
  pnetdev->dev.type = & wlan_type;
#line 584
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 584
  padapter = (struct rtw_adapter *)tmp;
#line 585
  padapter->pnetdev = pnetdev;
#line 587
  if (GlobalDebugLevel23A > 3U) {
#line 587
    printk("\016RTL8723AU: register rtw_netdev_ops to netdev_ops\n");
  } else {

  }
#line 588
  pnetdev->netdev_ops = & rtw_netdev_ops;
#line 590
  pnetdev->watchdog_timeo = 750;
#line 593
  loadparam(padapter, pnetdev);
#line 594
  return (pnetdev);
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int rtw_init_default_value(struct rtw_adapter *padapter ) 
{ 
  struct registry_priv *pregistrypriv ;
  struct xmit_priv *pxmitpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  int ret ;

  {
#line 599
  pregistrypriv = & padapter->registrypriv;
#line 600
  pxmitpriv = & padapter->xmitpriv;
#line 601
  pmlmepriv = & padapter->mlmepriv;
#line 602
  psecuritypriv = & padapter->securitypriv;
#line 603
  ret = 1;
#line 606
  pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
#line 607
  pxmitpriv->vcs = pregistrypriv->vcs_type;
#line 608
  pxmitpriv->vcs_type = pregistrypriv->vcs_type;
#line 610
  pxmitpriv->frag_len = (uint )pregistrypriv->frag_thresh;
#line 613
  pmlmepriv->scan_interval = 30U;
#line 614
  pmlmepriv->scan_mode = 1;
#line 617
  pmlmepriv->htpriv.ampdu_enable = 0U;
#line 620
  psecuritypriv->binstallGrpkey = 0U;
#line 623
  psecuritypriv->dot11AuthAlgrthm = 0U;
#line 624
  psecuritypriv->dot11PrivacyAlgrthm = 0U;
#line 626
  psecuritypriv->dot11PrivacyKeyIndex = 0U;
#line 628
  psecuritypriv->dot118021XGrpPrivacy = 0U;
#line 629
  psecuritypriv->dot118021XGrpKeyid = 1U;
#line 631
  psecuritypriv->ndisauthtype = 0U;
#line 632
  psecuritypriv->ndisencryptstatus = 1U;
#line 635
  rtw_init_registrypriv_dev_network23a(padapter);
#line 636
  rtw_update_registrypriv_dev_network23a(padapter);
#line 639
  rtl8723a_init_default_value(padapter);
#line 642
  padapter->bReadPortCancel = 0U;
#line 643
  padapter->bWritePortCancel = 0U;
#line 644
  padapter->bNotifyChannelChange = 0U;
#line 645
  return (ret);
}
}
#line 648 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int rtw_reset_drv_sw23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrctrlpriv ;
  unsigned long tmp ;

  {
#line 650
  pmlmepriv = & padapter->mlmepriv;
#line 651
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 654
  rtl8723a_init_default_value(padapter);
#line 655
  padapter->bReadPortCancel = 0U;
#line 656
  padapter->bWritePortCancel = 0U;
#line 657
  pmlmepriv->scan_interval = 30U;
#line 659
  padapter->xmitpriv.tx_pkts = 0ULL;
#line 660
  padapter->recvpriv.rx_pkts = 0ULL;
#line 662
  pmlmepriv->LinkDetectInfo.bBusyTraffic = 0;
#line 664
  _clr_fwstate_(pmlmepriv, 2176);
#line 666
  rtw_sreset_reset_value(padapter);
#line 667
  pwrctrlpriv->pwr_state_check_cnts = 0U;
#line 670
  padapter->mlmeextpriv.sitesurvey_res.state = 0;
#line 672
  tmp = msecs_to_jiffies(padapter->recvpriv.signal_stat_sampling_interval);
#line 672
  ldv_mod_timer_2167(& padapter->recvpriv.signal_stat_timer, tmp + (unsigned long )jiffies);
#line 673
  return (1);
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int rtw_init_drv_sw23a(struct rtw_adapter *padapter ) 
{ 
  int ret8 ;
  int tmp ;
  u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 678
  ret8 = 1;
#line 680
  if (GlobalDebugLevel23A > 6U) {
#line 680
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 680
    printk("\016+rtw_init_drv_sw23a\n");
  } else {

  }
#line 682
  tmp = rtw_init_cmd_priv23a(& padapter->cmdpriv);
#line 682
  if (tmp == 0) {
#line 683
    if (GlobalDebugLevel23A > 3U) {
#line 683
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
#line 683
      printk("\016\n Can\'t init cmd_priv\n");
    } else {

    }
#line 685
    ret8 = 0;
#line 686
    goto exit;
  } else {

  }
#line 689
  padapter->cmdpriv.padapter = padapter;
#line 691
  tmp___0 = rtw_init_evt_priv23a(& padapter->evtpriv);
#line 691
  if (tmp___0 == 0U) {
#line 692
    if (GlobalDebugLevel23A > 3U) {
#line 692
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
#line 692
      printk("\016\n Can\'t init evt_priv\n");
    } else {

    }
#line 694
    ret8 = 0;
#line 695
    goto exit;
  } else {

  }
#line 698
  tmp___1 = rtw_init_mlme_priv23a(padapter);
#line 698
  if (tmp___1 == 0) {
#line 699
    if (GlobalDebugLevel23A > 3U) {
#line 699
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
#line 699
      printk("\016\n Can\'t init mlme_priv\n");
    } else {

    }
#line 701
    ret8 = 0;
#line 702
    goto exit;
  } else {

  }
#line 706
  tmp___2 = init_mlme_ext_priv23a(padapter);
#line 706
  if (tmp___2 == 0) {
#line 707
    if (GlobalDebugLevel23A > 3U) {
#line 707
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
#line 707
      printk("\016\n Can\'t init mlme_ext_priv\n");
    } else {

    }
#line 709
    ret8 = 0;
#line 710
    goto exit;
  } else {

  }
#line 713
  tmp___3 = _rtw_init_xmit_priv23a(& padapter->xmitpriv, padapter);
#line 713
  if (tmp___3 == 0) {
#line 714
    if (GlobalDebugLevel23A > 3U) {
#line 714
      printk("\016RTL8723AU: Can\'t _rtw_init_xmit_priv23a\n");
    } else {

    }
#line 715
    ret8 = 0;
#line 716
    goto exit;
  } else {

  }
#line 719
  tmp___4 = _rtw_init_recv_priv23a(& padapter->recvpriv, padapter);
#line 719
  if (tmp___4 == 0) {
#line 720
    if (GlobalDebugLevel23A > 3U) {
#line 720
      printk("\016RTL8723AU: Can\'t _rtw_init_recv_priv23a\n");
    } else {

    }
#line 721
    ret8 = 0;
#line 722
    goto exit;
  } else {

  }
#line 725
  tmp___5 = _rtw_init_sta_priv23a(& padapter->stapriv);
#line 725
  if (tmp___5 == 0) {
#line 726
    if (GlobalDebugLevel23A > 3U) {
#line 726
      printk("\016RTL8723AU: Can\'t _rtw_init_sta_priv23a\n");
    } else {

    }
#line 727
    ret8 = 0;
#line 728
    goto exit;
  } else {

  }
#line 731
  padapter->stapriv.padapter = padapter;
#line 732
  padapter->setband = 0U;
#line 733
  rtw_init_bcmc_stainfo23a(padapter);
#line 735
  rtw_init_pwrctrl_priv23a(padapter);
#line 737
  ret8 = rtw_init_default_value(padapter);
#line 739
  rtl8723a_init_dm_priv(padapter);
#line 741
  rtw_sreset_init(padapter);
  exit: ;
#line 745
  if (GlobalDebugLevel23A > 6U) {
#line 745
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 745
    printk("\016-rtw_init_drv_sw23a\n");
  } else {

  }
#line 746
  return (ret8);
}
}
#line 749 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void rtw_cancel_all_timer23a(struct rtw_adapter *padapter ) 
{ 


  {
#line 751
  if (GlobalDebugLevel23A > 6U) {
#line 751
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 751
    printk("\016+rtw_cancel_all_timer23a\n");
  } else {

  }
#line 754
  ldv_del_timer_sync_2168(& padapter->mlmepriv.assoc_timer);
#line 755
  if (GlobalDebugLevel23A > 6U) {
#line 755
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 755
    printk("\016%s:cancel association timer complete!\n", "rtw_cancel_all_timer23a");
  } else {

  }
#line 758
  ldv_del_timer_sync_2169(& padapter->mlmepriv.scan_to_timer);
#line 759
  if (GlobalDebugLevel23A > 6U) {
#line 759
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 759
    printk("\016%s:cancel scan_to_timer!\n", "rtw_cancel_all_timer23a");
  } else {

  }
#line 762
  ldv_del_timer_sync_2170(& padapter->mlmepriv.dynamic_chk_timer);
#line 763
  if (GlobalDebugLevel23A > 6U) {
#line 763
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 763
    printk("\016%s:cancel dynamic_chk_timer!\n", "rtw_cancel_all_timer23a");
  } else {

  }
#line 766
  if (GlobalDebugLevel23A > 6U) {
#line 766
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 766
    printk("\016%s:cancel DeInitSwLeds!\n", "rtw_cancel_all_timer23a");
  } else {

  }
#line 769
  ldv_del_timer_sync_2171(& padapter->pwrctrlpriv.pwr_state_check_timer);
#line 771
  ldv_del_timer_sync_2172(& padapter->mlmepriv.set_scan_deny_timer);
#line 772
  rtw_clear_scan_deny(padapter);
#line 773
  if (GlobalDebugLevel23A > 6U) {
#line 773
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 773
    printk("\016%s:cancel set_scan_deny_timer!\n", "rtw_cancel_all_timer23a");
  } else {

  }
#line 776
  ldv_del_timer_sync_2173(& padapter->recvpriv.signal_stat_timer);
#line 778
  rtl8723a_deinit_dm_priv(padapter);
#line 779
  return;
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int rtw_free_drv_sw23a(struct rtw_adapter *padapter ) 
{ 


  {
#line 783
  if (GlobalDebugLevel23A > 6U) {
#line 783
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 783
    printk("\016==>rtw_free_drv_sw23a");
  } else {

  }
#line 785
  free_mlme_ext_priv23a(& padapter->mlmeextpriv);
#line 787
  rtw_free_evt_priv23a(& padapter->evtpriv);
#line 789
  rtw_free_mlme_priv23a(& padapter->mlmepriv);
#line 791
  _rtw_free_xmit_priv23a(& padapter->xmitpriv);
#line 794
  _rtw_free_sta_priv23a(& padapter->stapriv);
#line 796
  _rtw_free_recv_priv23a(& padapter->recvpriv);
#line 798
  rtw_free_pwrctrl_priv(padapter);
#line 800
  kfree((void const   *)padapter->HalData);
#line 801
  padapter->HalData = (void *)0;
#line 803
  if (GlobalDebugLevel23A > 6U) {
#line 803
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 803
    printk("\016<== rtw_free_drv_sw23a\n");
  } else {

  }
#line 806
  if ((unsigned long )padapter->pbuddy_adapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 807
    (padapter->pbuddy_adapter)->pbuddy_adapter = (struct rtw_adapter *)0;
  } else {

  }
#line 808
  if (GlobalDebugLevel23A > 6U) {
#line 808
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 808
    printk("\016-rtw_free_drv_sw23a\n");
  } else {

  }
#line 809
  return (1);
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int _rtw_drv_register_netdev(struct rtw_adapter *padapter , char *name ) 
{ 
  struct net_device *pnetdev ;
  int ret ;
  int tmp ;

  {
#line 814
  pnetdev = padapter->pnetdev;
#line 815
  ret = 1;
#line 818
  rtw_init_netdev23a_name23a(pnetdev, (char const   *)name);
#line 820
  ether_addr_copy(pnetdev->dev_addr, (u8 const   *)(& padapter->eeprompriv.mac_addr));
#line 823
  tmp = ldv_register_netdev_2174(pnetdev);
#line 823
  if (tmp != 0) {
#line 824
    if (GlobalDebugLevel23A > 3U) {
#line 824
      printk("\016RTL8723AU: %s(%s): Failed!\n", "_rtw_drv_register_netdev", (char *)(& pnetdev->name));
    } else {

    }
#line 825
    ret = 0;
#line 826
    goto error_register_netdev;
  } else {

  }
#line 828
  if (GlobalDebugLevel23A > 3U) {
#line 828
    printk("\016RTL8723AU: %s, MAC Address (if%d) = %02x:%02x:%02x:%02x:%02x:%02x\n",
           "_rtw_drv_register_netdev", (int )padapter->iface_id + 1, (int )*(pnetdev->dev_addr),
           (int )*(pnetdev->dev_addr + 1UL), (int )*(pnetdev->dev_addr + 2UL), (int )*(pnetdev->dev_addr + 3UL),
           (int )*(pnetdev->dev_addr + 4UL), (int )*(pnetdev->dev_addr + 5UL));
  } else {

  }
#line 830
  return (ret);
  error_register_netdev: ;
#line 834
  if ((unsigned int )padapter->iface_id != 0U) {
#line 835
    rtw_free_drv_sw23a(padapter);
#line 837
    ldv_free_netdev_2175(pnetdev);
  } else {

  }
#line 839
  return (ret);
}
}
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int rtw_drv_register_netdev(struct rtw_adapter *if1 ) 
{ 
  struct dvobj_priv *dvobj ;
  int i ;
  int status ;
  struct rtw_adapter *padapter ;
  char *name ;

  {
#line 844
  dvobj = if1->dvobj;
#line 845
  status = 1;
#line 847
  if ((unsigned int )dvobj->iface_nums > 3U) {
#line 848
    status = 0;
#line 849
    goto exit;
  } else {

  }
#line 852
  i = 0;
#line 852
  goto ldv_54922;
  ldv_54921: 
#line 853
  padapter = dvobj->padapters[i];
#line 855
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 858
    if ((unsigned int )padapter->iface_id == 0U) {
#line 859
      name = (char *)(& if1->registrypriv.ifname);
    } else
#line 860
    if ((unsigned int )padapter->iface_id == 1U) {
#line 861
      name = (char *)(& if1->registrypriv.if2name);
    } else {
#line 863
      name = (char *)"wlan%d";
    }
#line 864
    status = _rtw_drv_register_netdev(padapter, name);
#line 865
    if (status != 1) {
#line 866
      goto ldv_54920;
    } else {

    }
  } else {

  }
#line 852
  i = i + 1;
  ldv_54922: ;
#line 852
  if ((int )dvobj->iface_nums > i) {
#line 854
    goto ldv_54921;
  } else {

  }
  ldv_54920: ;
  exit: ;
#line 871
  return (status);
}
}
#line 874 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int netdev_open23a(struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct pwrctrl_priv *pwrctrlpriv ;
  int ret ;
  int status ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 876
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 876
  padapter = (struct rtw_adapter *)tmp;
#line 878
  ret = 0;
#line 881
  if (GlobalDebugLevel23A > 6U) {
#line 881
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 881
    printk("\016+871x_drv - dev_open\n");
  } else {

  }
#line 882
  if (GlobalDebugLevel23A > 3U) {
#line 882
    printk("\016RTL8723AU: +871x_drv - drv_open, bup =%d\n", padapter->bup);
  } else {

  }
#line 884
  mutex_lock_nested(& (padapter->dvobj)->hw_init_mutex, 0U);
#line 886
  pwrctrlpriv = & padapter->pwrctrlpriv;
#line 887
  if (pwrctrlpriv->ps_flag != 0) {
#line 888
    padapter->net_closed = 0;
#line 889
    goto netdev_open23a_normal_process;
  } else {

  }
#line 892
  if (padapter->bup == 0) {
#line 893
    padapter->bDriverStopped = 0;
#line 894
    padapter->bSurpriseRemoved = 0;
#line 895
    padapter->bCardDisableWOHSM = 0;
#line 897
    status = rtw_hal_init23a(padapter);
#line 898
    if (status == 0) {
#line 899
      if (GlobalDebugLevel23A > 3U) {
#line 899
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
#line 899
        printk("\016rtl871x_hal_init(): Can\'t init h/w!\n");
      } else {

      }
#line 901
      goto netdev_open23a_error;
    } else {

    }
#line 904
    if (GlobalDebugLevel23A > 3U) {
#line 904
      printk("\016RTL8723AU: MAC Address = %02x:%02x:%02x:%02x:%02x:%02x\n", (int )*(pnetdev->dev_addr),
             (int )*(pnetdev->dev_addr + 1UL), (int )*(pnetdev->dev_addr + 2UL), (int )*(pnetdev->dev_addr + 3UL),
             (int )*(pnetdev->dev_addr + 4UL), (int )*(pnetdev->dev_addr + 5UL));
    } else {

    }
#line 907
    tmp___0 = init_hw_mlme_ext23a(padapter);
#line 907
    if (tmp___0 == 0) {
#line 908
      if (GlobalDebugLevel23A > 3U) {
#line 908
        printk("\016RTL8723AU: can\'t init mlme_ext_priv\n");
      } else {

      }
#line 909
      goto netdev_open23a_error;
    } else {

    }
#line 912
    rtl8723au_inirp_init(padapter);
#line 914
    rtw_cfg80211_init_wiphy(padapter);
#line 918
    padapter->bup = 1;
  } else {

  }
#line 920
  padapter->net_closed = 0;
#line 922
  tmp___1 = msecs_to_jiffies(2000U);
#line 922
  ldv_mod_timer_2176(& padapter->mlmepriv.dynamic_chk_timer, tmp___1 + (unsigned long )jiffies);
#line 925
  padapter->pwrctrlpriv.bips_processing = 0U;
#line 926
  tmp___2 = msecs_to_jiffies((unsigned int const   )padapter->pwrctrlpriv.pwr_state_check_interval);
#line 926
  ldv_mod_timer_2177(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp___2 + (unsigned long )jiffies);
#line 930
  tmp___3 = rtw_netif_queue_stopped(pnetdev);
#line 930
  if (tmp___3 == 0) {
#line 931
    netif_tx_start_all_queues(pnetdev);
  } else {
#line 933
    netif_tx_wake_all_queues___0(pnetdev);
  }
  netdev_open23a_normal_process: ;
#line 936
  if (GlobalDebugLevel23A > 6U) {
#line 936
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 936
    printk("\016-871x_drv - dev_open\n");
  } else {

  }
#line 937
  if (GlobalDebugLevel23A > 3U) {
#line 937
    printk("\016RTL8723AU: -871x_drv - drv_open, bup =%d\n", padapter->bup);
  } else {

  }
  exit: 
#line 939
  mutex_unlock(& (padapter->dvobj)->hw_init_mutex);
#line 940
  return (ret);
  netdev_open23a_error: 
#line 943
  padapter->bup = 0;
#line 945
  netif_carrier_off(pnetdev);
#line 946
  netif_tx_stop_all_queues___0(pnetdev);
#line 948
  if (GlobalDebugLevel23A > 3U) {
#line 948
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
#line 948
    printk("\016-871x_drv - dev_open, fail!\n");
  } else {

  }
#line 950
  if (GlobalDebugLevel23A > 3U) {
#line 950
    printk("\016RTL8723AU: -871x_drv - drv_open fail, bup =%d\n", padapter->bup);
  } else {

  }
#line 952
  ret = -1;
#line 953
  goto exit;
}
}
#line 956 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int ips_netdrv_open(struct rtw_adapter *padapter ) 
{ 
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 958
  status = 1;
#line 960
  padapter->net_closed = 0;
#line 961
  if (GlobalDebugLevel23A > 3U) {
#line 961
    printk("\016RTL8723AU: ===> %s.........\n", "ips_netdrv_open");
  } else {

  }
#line 963
  padapter->bDriverStopped = 0;
#line 964
  padapter->bSurpriseRemoved = 0;
#line 965
  padapter->bCardDisableWOHSM = 0;
#line 967
  status = rtw_hal_init23a(padapter);
#line 968
  if (status == 0) {
#line 969
    if (GlobalDebugLevel23A > 3U) {
#line 969
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
#line 969
      printk("\016ips_netdrv_open(): Can\'t init h/w!\n");
    } else {

    }
#line 971
    goto netdev_open23a_error;
  } else {

  }
#line 974
  rtl8723au_inirp_init(padapter);
#line 976
  tmp = msecs_to_jiffies((unsigned int const   )padapter->pwrctrlpriv.pwr_state_check_interval);
#line 976
  ldv_mod_timer_2178(& padapter->pwrctrlpriv.pwr_state_check_timer, tmp + (unsigned long )jiffies);
#line 977
  tmp___0 = msecs_to_jiffies(5000U);
#line 977
  ldv_mod_timer_2179(& padapter->mlmepriv.dynamic_chk_timer, tmp___0 + (unsigned long )jiffies);
#line 980
  return (1);
  netdev_open23a_error: ;
#line 984
  if (GlobalDebugLevel23A > 3U) {
#line 984
    printk("\016RTL8723AU: -ips_netdrv_open - drv_open failure, bup =%d\n", padapter->bup);
  } else {

  }
#line 987
  return (0);
}
}
#line 990 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int rtw_ips_pwr_up23a(struct rtw_adapter *padapter ) 
{ 
  int result ;
  unsigned long start_time ;
  unsigned int tmp ;

  {
#line 993
  start_time = jiffies;
#line 995
  if (GlobalDebugLevel23A > 3U) {
#line 995
    printk("\016RTL8723AU: ===>  rtw_ips_pwr_up23a..............\n");
  } else {

  }
#line 996
  rtw_reset_drv_sw23a(padapter);
#line 998
  result = ips_netdrv_open(padapter);
#line 1002
  if (GlobalDebugLevel23A > 3U) {
#line 1002
    tmp = jiffies_to_msecs((unsigned long )jiffies - start_time);
#line 1002
    printk("\016RTL8723AU: <===  rtw_ips_pwr_up23a.............. in %dms\n", tmp);
  } else {

  }
#line 1004
  return (result);
}
}
#line 1007 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void rtw_ips_pwr_down23a(struct rtw_adapter *padapter ) 
{ 
  unsigned long start_time ;
  unsigned int tmp ;

  {
#line 1009
  start_time = jiffies;
#line 1011
  if (GlobalDebugLevel23A > 3U) {
#line 1011
    printk("\016RTL8723AU: ===> rtw_ips_pwr_down23a...................\n");
  } else {

  }
#line 1013
  padapter->bCardDisableWOHSM = 1;
#line 1014
  padapter->net_closed = 1;
#line 1018
  rtw_ips_dev_unload23a(padapter);
#line 1019
  padapter->bCardDisableWOHSM = 0;
#line 1020
  if (GlobalDebugLevel23A > 3U) {
#line 1020
    tmp = jiffies_to_msecs((unsigned long )jiffies - start_time);
#line 1020
    printk("\016RTL8723AU: <=== rtw_ips_pwr_down23a..................... in %dms\n",
           tmp);
  } else {

  }
#line 1021
  return;
}
}
#line 1024 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void rtw_ips_dev_unload23a(struct rtw_adapter *padapter ) 
{ 


  {
#line 1026
  rtl8723a_fifo_cleanup(padapter);
#line 1028
  rtl8723a_usb_intf_stop(padapter);
#line 1031
  if (padapter->bSurpriseRemoved == 0) {
#line 1032
    rtw_hal_deinit23a(padapter);
  } else {

  }
#line 1033
  return;
}
}
#line 1035 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int pm_netdev_open23a(struct net_device *pnetdev , u8 bnormal ) 
{ 
  int status ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1039
  if ((unsigned int )bnormal != 0U) {
#line 1040
    status = netdev_open23a(pnetdev);
  } else {
#line 1042
    tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 1042
    tmp___0 = ips_netdrv_open((struct rtw_adapter *)tmp);
#line 1042
    status = tmp___0 == 1 ? 0 : -1;
  }
#line 1045
  return (status);
}
}
#line 1048 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
static int netdev_close(struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1050
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 1050
  padapter = (struct rtw_adapter *)tmp;
#line 1052
  if (GlobalDebugLevel23A > 6U) {
#line 1052
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 1052
    printk("\016+871x_drv - drv_close\n");
  } else {

  }
#line 1054
  padapter->net_closed = 1;
#line 1056
  if ((unsigned int )padapter->pwrctrlpriv.rf_pwrstate == 0U) {
#line 1057
    if (GlobalDebugLevel23A > 3U) {
#line 1057
      printk("\016RTL8723AU: (2)871x_drv - drv_close, bup =%d, hw_init_completed =%d\n",
             padapter->bup, (int )padapter->hw_init_completed);
    } else {

    }
#line 1062
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 1063
      tmp___0 = rtw_netif_queue_stopped(pnetdev);
#line 1063
      if (tmp___0 == 0) {
#line 1064
        netif_tx_stop_all_queues___0(pnetdev);
      } else {

      }
    } else {

    }
#line 1068
    LeaveAllPowerSaveMode23a(padapter);
#line 1069
    rtw_disassoc_cmd23a(padapter, 500U, 0);
#line 1071
    rtw_indicate_disconnect23a(padapter);
#line 1073
    rtw_free_assoc_resources23a(padapter, 1);
#line 1075
    rtw_free_network_queue23a(padapter);
  } else {

  }
#line 1080
  rtw_scan_abort23a(padapter);
#line 1082
  if (GlobalDebugLevel23A > 6U) {
#line 1082
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 7);
#line 1082
    printk("\016-871x_drv - drv_close\n");
  } else {

  }
#line 1083
  if (GlobalDebugLevel23A > 3U) {
#line 1083
    printk("\016RTL8723AU: -871x_drv - drv_close, bup =%d\n", padapter->bup);
  } else {

  }
#line 1085
  return (0);
}
}
#line 1088 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void rtw_ndev_destructor(struct net_device *ndev ) 
{ 


  {
#line 1090
  if (GlobalDebugLevel23A > 3U) {
#line 1090
    printk("\016RTL8723AU: %s(%s)\n", "rtw_ndev_destructor", (char *)(& ndev->name));
  } else {

  }
#line 1091
  kfree((void const   *)ndev->ieee80211_ptr);
#line 1092
  ldv_free_netdev_2180(ndev);
#line 1093
  return;
}
}
#line 1095 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void _rtw_init_queue23a(struct rtw_queue *pqueue ) 
{ 
  struct lock_class_key __key ;

  {
#line 1097
  INIT_LIST_HEAD(& pqueue->queue);
#line 1098
  spinlock_check(& pqueue->lock);
#line 1098
  __raw_spin_lock_init(& pqueue->lock.ldv_6347.rlock, "&(&pqueue->lock)->rlock", & __key);
#line 1100
  return;
}
}
#line 1101 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
u16 (*ldvarg48)(struct net_device * , struct sk_buff * )  ;
#line 1102
extern int ldv_ndo_init_13(void) ;
#line 1103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_retval_8  ;
#line 1104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_retval_9  ;
#line 1105
extern int ldv_ndo_uninit_13(void) ;
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void ldv_net_device_ops_13(void) 
{ 
  void *tmp ;

  {
#line 1109
  tmp = ldv_zalloc(3264UL);
#line 1109
  rtw_netdev_ops_group1 = (struct net_device *)tmp;
#line 1110
  return;
}
}
#line 1113 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void ldv_main_exported_13(void) 
{ 
  void *ldvarg47 ;
  void *tmp ;
  struct sk_buff *ldvarg50 ;
  void *tmp___0 ;
  void *ldvarg49 ;
  void *tmp___1 ;
  struct sk_buff *ldvarg51 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1114
  tmp = ldv_zalloc(1UL);
#line 1114
  ldvarg47 = tmp;
#line 1115
  tmp___0 = ldv_zalloc(232UL);
#line 1115
  ldvarg50 = (struct sk_buff *)tmp___0;
#line 1116
  tmp___1 = ldv_zalloc(1UL);
#line 1116
  ldvarg49 = tmp___1;
#line 1117
  tmp___2 = ldv_zalloc(232UL);
#line 1117
  ldvarg51 = (struct sk_buff *)tmp___2;
#line 1119
  tmp___3 = __VERIFIER_nondet_int();
#line 1119
  switch (tmp___3) {
  case 0: ;
#line 1122
  if (ldv_state_variable_13 == 1) {
#line 1124
    rtw_net_get_stats(rtw_netdev_ops_group1);
#line 1126
    ldv_state_variable_13 = 1;
  } else {

  }
#line 1129
  if (ldv_state_variable_13 == 3) {
#line 1131
    rtw_net_get_stats(rtw_netdev_ops_group1);
#line 1133
    ldv_state_variable_13 = 3;
  } else {

  }
#line 1136
  if (ldv_state_variable_13 == 2) {
#line 1138
    rtw_net_get_stats(rtw_netdev_ops_group1);
#line 1140
    ldv_state_variable_13 = 2;
  } else {

  }
#line 1143
  goto ldv_54988;
  case 1: ;
#line 1146
  if (ldv_state_variable_13 == 2) {
#line 1148
    ldv_retval_9 = netdev_open23a(rtw_netdev_ops_group1);
#line 1149
    if (ldv_retval_9 == 0) {
#line 1150
      ldv_state_variable_13 = 3;
    } else {

    }
  } else {

  }
#line 1154
  goto ldv_54988;
  case 2: ;
#line 1157
  if (ldv_state_variable_13 == 3) {
#line 1159
    rtw_xmit23a_entry23a(ldvarg51, rtw_netdev_ops_group1);
#line 1161
    ldv_state_variable_13 = 3;
  } else {

  }
#line 1164
  goto ldv_54988;
  case 3: ;
#line 1167
  if (ldv_state_variable_13 == 3) {
#line 1169
    netdev_close(rtw_netdev_ops_group1);
#line 1170
    ldv_state_variable_13 = 2;
  } else {

  }
#line 1173
  goto ldv_54988;
  case 4: ;
#line 1176
  if (ldv_state_variable_13 == 1) {
#line 1178
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg50, ldvarg49, ldvarg48);
#line 1180
    ldv_state_variable_13 = 1;
  } else {

  }
#line 1183
  if (ldv_state_variable_13 == 3) {
#line 1185
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg50, ldvarg49, ldvarg48);
#line 1187
    ldv_state_variable_13 = 3;
  } else {

  }
#line 1190
  if (ldv_state_variable_13 == 2) {
#line 1192
    rtw_select_queue(rtw_netdev_ops_group1, ldvarg50, ldvarg49, ldvarg48);
#line 1194
    ldv_state_variable_13 = 2;
  } else {

  }
#line 1197
  goto ldv_54988;
  case 5: ;
#line 1200
  if (ldv_state_variable_13 == 1) {
#line 1202
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg47);
#line 1204
    ldv_state_variable_13 = 1;
  } else {

  }
#line 1207
  if (ldv_state_variable_13 == 3) {
#line 1209
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg47);
#line 1211
    ldv_state_variable_13 = 3;
  } else {

  }
#line 1214
  if (ldv_state_variable_13 == 2) {
#line 1216
    rtw_net_set_mac_address(rtw_netdev_ops_group1, ldvarg47);
#line 1218
    ldv_state_variable_13 = 2;
  } else {

  }
#line 1221
  goto ldv_54988;
  case 6: ;
#line 1224
  if (ldv_state_variable_13 == 1) {
#line 1226
    ldv_retval_8 = ldv_ndo_init_13();
#line 1227
    if (ldv_retval_8 == 0) {
#line 1228
      ldv_state_variable_13 = 2;
#line 1229
      usb_counter = usb_counter + 1;
#line 1230
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 1234
  goto ldv_54988;
  case 7: ;
#line 1237
  if (ldv_state_variable_13 == 2) {
#line 1239
    ldv_ndo_uninit_13();
#line 1240
    ldv_state_variable_13 = 1;
#line 1241
    usb_counter = usb_counter - 1;
#line 1242
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 1245
  goto ldv_54988;
  default: 
#line 1246
  ldv_stop();
  }
  ldv_54988: ;
#line 1250
  return;
}
}
#line 1378 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void *ldv_kmem_cache_alloc_2150(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1381
  ldv_check_alloc_flags(flags);
#line 1383
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1384
  return ((void *)0);
}
}
#line 1422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_pskb_expand_head_2156(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1425
  ldv_check_alloc_flags(flags);
#line 1427
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1427
  return (tmp);
}
}
#line 1438 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
struct sk_buff *ldv_skb_clone_2158(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1441
  ldv_check_alloc_flags(flags);
#line 1443
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1443
  return (tmp);
}
}
#line 1454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
struct sk_buff *ldv_skb_copy_2160(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1457
  ldv_check_alloc_flags(flags);
#line 1459
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1459
  return (tmp);
}
}
#line 1462 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2161(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1465
  ldv_check_alloc_flags(flags);
#line 1467
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1467
  return (tmp);
}
}
#line 1470 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2162(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1473
  ldv_check_alloc_flags(flags);
#line 1475
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1475
  return (tmp);
}
}
#line 1478 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2163(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1481
  ldv_check_alloc_flags(flags);
#line 1483
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1483
  return (tmp);
}
}
#line 1486 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_pskb_expand_head_2164(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1489
  ldv_check_alloc_flags(flags);
#line 1491
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1491
  return (tmp);
}
}
#line 1494 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_pskb_expand_head_2165(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1497
  ldv_check_alloc_flags(flags);
#line 1499
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1499
  return (tmp);
}
}
#line 1502 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
struct sk_buff *ldv_skb_clone_2166(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1505
  ldv_check_alloc_flags(flags);
#line 1507
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1507
  return (tmp);
}
}
#line 1510 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_2167(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 1514
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1514
  ldv_func_res = tmp;
#line 1516
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 1518
  return (ldv_func_res);
}
}
#line 1521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_2168(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 1525
  tmp = del_timer_sync(ldv_func_arg1);
#line 1525
  ldv_func_res = tmp;
#line 1527
  disable_suitable_timer_6(ldv_func_arg1);
#line 1529
  return (ldv_func_res);
}
}
#line 1532 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_2169(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 1536
  tmp = del_timer_sync(ldv_func_arg1);
#line 1536
  ldv_func_res = tmp;
#line 1538
  disable_suitable_timer_6(ldv_func_arg1);
#line 1540
  return (ldv_func_res);
}
}
#line 1543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_2170(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 1547
  tmp = del_timer_sync(ldv_func_arg1);
#line 1547
  ldv_func_res = tmp;
#line 1549
  disable_suitable_timer_6(ldv_func_arg1);
#line 1551
  return (ldv_func_res);
}
}
#line 1554 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_2171(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 1558
  tmp = del_timer_sync(ldv_func_arg1);
#line 1558
  ldv_func_res = tmp;
#line 1560
  disable_suitable_timer_6(ldv_func_arg1);
#line 1562
  return (ldv_func_res);
}
}
#line 1565 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_2172(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 1569
  tmp = del_timer_sync(ldv_func_arg1);
#line 1569
  ldv_func_res = tmp;
#line 1571
  disable_suitable_timer_6(ldv_func_arg1);
#line 1573
  return (ldv_func_res);
}
}
#line 1576 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_del_timer_sync_2173(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 1580
  tmp = del_timer_sync(ldv_func_arg1);
#line 1580
  ldv_func_res = tmp;
#line 1582
  disable_suitable_timer_6(ldv_func_arg1);
#line 1584
  return (ldv_func_res);
}
}
#line 1587 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_register_netdev_2174(struct net_device *dev ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 1591
  tmp = register_netdev(dev);
#line 1591
  ldv_func_res = tmp;
#line 1593
  ldv_state_variable_15 = 1;
#line 1594
  ldv_net_device_ops_15();
#line 1597
  return (ldv_func_res);
}
}
#line 1600 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void ldv_free_netdev_2175(struct net_device *dev ) 
{ 


  {
#line 1603
  free_netdev(dev);
#line 1605
  ldv_state_variable_15 = 0;
#line 1606
  return;
}
}
#line 1608 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_2176(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 1612
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1612
  ldv_func_res = tmp;
#line 1614
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 1616
  return (ldv_func_res);
}
}
#line 1619 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_2177(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 1623
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1623
  ldv_func_res = tmp;
#line 1625
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 1627
  return (ldv_func_res);
}
}
#line 1630 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_2178(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 1634
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1634
  ldv_func_res = tmp;
#line 1636
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 1638
  return (ldv_func_res);
}
}
#line 1641 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
int ldv_mod_timer_2179(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 1645
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 1645
  ldv_func_res = tmp;
#line 1647
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 1649
  return (ldv_func_res);
}
}
#line 1652 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/os_intfs.o.c.prepared"
void ldv_free_netdev_2180(struct net_device *dev ) 
{ 


  {
#line 1655
  free_netdev(dev);
#line 1657
  ldv_state_variable_15 = 0;
#line 1658
  return;
}
}
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2220(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
int ldv_timer_11_0 ;
#line 45
struct timer_list *ldv_timer_list_11_1 ;
#line 59
int ldv_timer_11_2 ;
#line 92
int ldv_timer_11_1 ;
#line 94
struct timer_list *ldv_timer_list_11_2 ;
#line 103
struct timer_list *ldv_timer_list_11_0 ;
#line 115
int ldv_timer_11_3 ;
#line 131
struct timer_list *ldv_timer_list_11_3 ;
#line 161
void disable_suitable_timer_11(struct timer_list *timer ) ;
#line 181
void ldv_timer_11(int state , struct timer_list *timer ) ;
#line 187
void choose_timer_11(void) ;
#line 192
void timer_init_11(void) ;
#line 199
int reg_timer_11(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 203
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 204
void activate_suitable_timer_11(struct timer_list *timer , unsigned long data ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_2228(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2236(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 767
struct sk_buff *ldv_skb_clone_2237(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 772
struct sk_buff *ldv_skb_copy_2230(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2226(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 793
int ldv_pskb_expand_head_2235(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 869 "include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 871
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2231(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2232(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2233(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2978 "include/linux/skbuff.h"
__inline static void skb_set_queue_mapping(struct sk_buff *skb , u16 queue_mapping ) 
{ 


  {
#line 2980
  skb->queue_mapping = queue_mapping;
#line 2981
  return;
}
}
#line 3983 "include/net/cfg80211.h"
extern void cfg80211_michael_mic_failure(struct net_device * , u8 const   * , enum nl80211_key_type  ,
                                         int  , u8 const   * , gfp_t  ) ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void rtw_handle_tkip_mic_err23a(struct rtw_adapter *padapter , u8 bgroup ) 
{ 
  enum nl80211_key_type key_type ;
  union iwreq_data wrqu ;
  struct iw_michaelmicfailure ev ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  unsigned long cur_time ;

  {
#line 247
  key_type = 0;
#line 250
  pmlmepriv = & padapter->mlmepriv;
#line 251
  psecuritypriv = & padapter->securitypriv;
#line 254
  if (psecuritypriv->last_mic_err_time == 0UL) {
#line 255
    psecuritypriv->last_mic_err_time = jiffies;
  } else {
#line 257
    cur_time = jiffies;
#line 259
    if (cur_time - psecuritypriv->last_mic_err_time <= 14999UL) {
#line 260
      psecuritypriv->btkip_countermeasure = 1U;
#line 261
      psecuritypriv->last_mic_err_time = 0UL;
#line 262
      psecuritypriv->btkip_countermeasure_time = cur_time;
    } else {
#line 264
      psecuritypriv->last_mic_err_time = jiffies;
    }
  }
#line 268
  if ((unsigned int )bgroup != 0U) {
#line 269
    key_type = key_type;
  } else {
#line 271
    key_type = (enum nl80211_key_type )((unsigned int )key_type | 1U);
  }
#line 273
  cfg80211_michael_mic_failure(padapter->pnetdev, (u8 const   *)(& pmlmepriv->assoc_bssid),
                               key_type, -1, (u8 const   *)0U, 32U);
#line 277
  memset((void *)(& ev), 0, 28UL);
#line 278
  if ((unsigned int )bgroup != 0U) {
#line 279
    ev.flags = ev.flags | 4U;
  } else {
#line 281
    ev.flags = ev.flags | 8U;
  }
#line 283
  ev.src_addr.sa_family = 1U;
#line 284
  ether_addr_copy((u8 *)(& ev.src_addr.sa_data), (u8 const   *)(& pmlmepriv->assoc_bssid));
#line 286
  memset((void *)(& wrqu), 0, 16UL);
#line 287
  wrqu.data.length = 28U;
#line 288
  return;
}
}
#line 290 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
int rtw_recv_indicatepkt23a(struct rtw_adapter *padapter , struct recv_frame *precv_frame ) 
{ 
  struct recv_priv *precvpriv ;
  struct sk_buff *skb ;
  struct mlme_priv *pmlmepriv ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  struct sk_buff *pskb2 ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct rx_pkt_attrib *pattrib ;
  int bmcast ;
  bool tmp___1 ;
  struct net_device *pnetdev ;
  u16 tmp___2 ;
  u8 *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;

  {
#line 295
  pmlmepriv = & padapter->mlmepriv;
#line 297
  precvpriv = & padapter->recvpriv;
#line 299
  skb = precv_frame->pkt;
#line 300
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 301
    if (GlobalDebugLevel23A > 3U) {
#line 301
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 4);
#line 301
      printk("\016rtw_recv_indicatepkt23a():skb == NULL!!!!\n");
    } else {

    }
#line 303
    goto _recv_indicatepkt_drop;
  } else {

  }
#line 306
  if (GlobalDebugLevel23A > 6U) {
#line 306
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 7);
#line 306
    printk("\016rtw_recv_indicatepkt23a():skb != NULL !!!\n");
  } else {

  }
#line 308
  if (GlobalDebugLevel23A > 6U) {
#line 308
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 7);
#line 308
    printk("\016rtw_recv_indicatepkt23a():precv_frame->hdr.rx_data =%p\n", (precv_frame->pkt)->data);
  } else {

  }
#line 311
  if (GlobalDebugLevel23A > 6U) {
#line 311
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 7);
#line 311
    tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 311
    tmp___0 = skb_tail_pointer((struct sk_buff  const  *)skb);
#line 311
    printk("\016\n skb->head =%p skb->data =%p skb->tail =%p skb->end =%p skb->len =%d\n",
           skb->head, skb->data, tmp___0, tmp, skb->len);
  } else {

  }
#line 316
  tmp___6 = check_fwstate(pmlmepriv, 16);
#line 316
  if ((int )tmp___6) {
#line 317
    pskb2 = (struct sk_buff *)0;
#line 318
    psta = (struct sta_info *)0;
#line 319
    pstapriv = & padapter->stapriv;
#line 320
    pattrib = & precv_frame->attrib;
#line 321
    tmp___1 = is_multicast_ether_addr((u8 const   *)(& pattrib->dst));
#line 321
    bmcast = (int )tmp___1;
#line 325
    tmp___3 = myid(& padapter->eeprompriv);
#line 325
    tmp___4 = ether_addr_equal((u8 const   *)(& pattrib->dst), (u8 const   *)tmp___3);
#line 325
    if (tmp___4) {
#line 325
      tmp___5 = 0;
    } else {
#line 325
      tmp___5 = 1;
    }
#line 325
    if (tmp___5) {
#line 328
      if (bmcast != 0) {
#line 329
        psta = rtw_get_bcmc_stainfo23a(padapter);
#line 330
        pskb2 = ldv_skb_clone_2237(skb, 32U);
      } else {
#line 332
        psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& pattrib->dst));
      }
#line 335
      if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 336
        pnetdev = padapter->pnetdev;
#line 341
        skb->dev = pnetdev;
#line 342
        tmp___2 = rtw_recv_select_queue23a(skb);
#line 342
        skb_set_queue_mapping(skb, (int )tmp___2);
#line 344
        rtw_xmit23a_entry23a(skb, pnetdev);
#line 346
        if (bmcast != 0) {
#line 347
          skb = pskb2;
        } else {
#line 349
          goto _recv_indicatepkt_end;
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 356
  skb->ip_summed = 0U;
#line 357
  skb->dev = padapter->pnetdev;
#line 358
  skb->protocol = eth_type_trans(skb, padapter->pnetdev);
#line 360
  netif_rx(skb);
  _recv_indicatepkt_end: 
#line 364
  precv_frame->pkt = (struct sk_buff *)0;
#line 366
  rtw_free_recvframe23a(precv_frame);
#line 368
  if (GlobalDebugLevel23A > 6U) {
#line 368
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 8U, 7);
#line 368
    printk("\016\n rtw_recv_indicatepkt23a :after netif_rx!!!!\n");
  } else {

  }
#line 370
  return (1);
  _recv_indicatepkt_drop: 
#line 374
  rtw_free_recvframe23a(precv_frame);
#line 375
  return (0);
}
}
#line 378 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void rtw_init_recv_timer23a(struct recv_reorder_ctrl *preorder_ctrl ) 
{ 


  {
#line 380
  reg_timer_6(& preorder_ctrl->reordering_ctrl_timer, & rtw_reordering_ctrl_timeout_handler23a,
              (unsigned long )preorder_ctrl);
#line 381
  return;
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void disable_suitable_timer_11(struct timer_list *timer ) 
{ 


  {
#line 387
  if (ldv_timer_11_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_0) {
#line 388
    ldv_timer_11_0 = 0;
#line 389
    return;
  } else {

  }
#line 391
  if (ldv_timer_11_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_1) {
#line 392
    ldv_timer_11_1 = 0;
#line 393
    return;
  } else {

  }
#line 395
  if (ldv_timer_11_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_2) {
#line 396
    ldv_timer_11_2 = 0;
#line 397
    return;
  } else {

  }
#line 399
  if (ldv_timer_11_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_11_3) {
#line 400
    ldv_timer_11_3 = 0;
#line 401
    return;
  } else {

  }
#line 403
  return;
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void ldv_timer_11(int state , struct timer_list *timer ) 
{ 


  {
#line 408
  LDV_IN_INTERRUPT = 2;
#line 409
  rtw_reordering_ctrl_timeout_handler23a(timer->data);
#line 410
  LDV_IN_INTERRUPT = 1;
#line 411
  return;
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void choose_timer_11(void) 
{ 
  int tmp ;

  {
#line 415
  tmp = __VERIFIER_nondet_int();
#line 415
  switch (tmp) {
  case 0: ;
#line 417
  if (ldv_timer_11_0 == 1) {
#line 418
    ldv_timer_11_0 = 2;
#line 419
    ldv_timer_11(ldv_timer_11_0, ldv_timer_list_11_0);
  } else {

  }
#line 422
  goto ldv_51537;
  case 1: ;
#line 424
  if (ldv_timer_11_1 == 1) {
#line 425
    ldv_timer_11_1 = 2;
#line 426
    ldv_timer_11(ldv_timer_11_1, ldv_timer_list_11_1);
  } else {

  }
#line 429
  goto ldv_51537;
  case 2: ;
#line 431
  if (ldv_timer_11_2 == 1) {
#line 432
    ldv_timer_11_2 = 2;
#line 433
    ldv_timer_11(ldv_timer_11_2, ldv_timer_list_11_2);
  } else {

  }
#line 436
  goto ldv_51537;
  case 3: ;
#line 438
  if (ldv_timer_11_3 == 1) {
#line 439
    ldv_timer_11_3 = 2;
#line 440
    ldv_timer_11(ldv_timer_11_3, ldv_timer_list_11_3);
  } else {

  }
#line 443
  goto ldv_51537;
  default: 
#line 444
  ldv_stop();
  }
  ldv_51537: ;
#line 446
  return;
}
}
#line 450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void timer_init_11(void) 
{ 


  {
#line 451
  ldv_timer_11_0 = 0;
#line 452
  ldv_timer_11_1 = 0;
#line 453
  ldv_timer_11_2 = 0;
#line 454
  ldv_timer_11_3 = 0;
#line 455
  return;
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
int reg_timer_11(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 459
  if ((unsigned long )function == (unsigned long )(& rtw_reordering_ctrl_timeout_handler23a)) {
#line 460
    activate_suitable_timer_11(timer, data);
  } else {

  }
#line 461
  return (0);
}
}
#line 465 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void activate_pending_timer_11(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 466
  if ((unsigned long )ldv_timer_list_11_0 == (unsigned long )timer) {
#line 467
    if (ldv_timer_11_0 == 2 || pending_flag != 0) {
#line 468
      ldv_timer_list_11_0 = timer;
#line 469
      ldv_timer_list_11_0->data = data;
#line 470
      ldv_timer_11_0 = 1;
    } else {

    }
#line 472
    return;
  } else {

  }
#line 475
  if ((unsigned long )ldv_timer_list_11_1 == (unsigned long )timer) {
#line 476
    if (ldv_timer_11_1 == 2 || pending_flag != 0) {
#line 477
      ldv_timer_list_11_1 = timer;
#line 478
      ldv_timer_list_11_1->data = data;
#line 479
      ldv_timer_11_1 = 1;
    } else {

    }
#line 481
    return;
  } else {

  }
#line 484
  if ((unsigned long )ldv_timer_list_11_2 == (unsigned long )timer) {
#line 485
    if (ldv_timer_11_2 == 2 || pending_flag != 0) {
#line 486
      ldv_timer_list_11_2 = timer;
#line 487
      ldv_timer_list_11_2->data = data;
#line 488
      ldv_timer_11_2 = 1;
    } else {

    }
#line 490
    return;
  } else {

  }
#line 493
  if ((unsigned long )ldv_timer_list_11_3 == (unsigned long )timer) {
#line 494
    if (ldv_timer_11_3 == 2 || pending_flag != 0) {
#line 495
      ldv_timer_list_11_3 = timer;
#line 496
      ldv_timer_list_11_3->data = data;
#line 497
      ldv_timer_11_3 = 1;
    } else {

    }
#line 499
    return;
  } else {

  }
#line 501
  activate_suitable_timer_11(timer, data);
#line 502
  return;
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void activate_suitable_timer_11(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 506
  if (ldv_timer_11_0 == 0 || ldv_timer_11_0 == 2) {
#line 507
    ldv_timer_list_11_0 = timer;
#line 508
    ldv_timer_list_11_0->data = data;
#line 509
    ldv_timer_11_0 = 1;
#line 510
    return;
  } else {

  }
#line 512
  if (ldv_timer_11_1 == 0 || ldv_timer_11_1 == 2) {
#line 513
    ldv_timer_list_11_1 = timer;
#line 514
    ldv_timer_list_11_1->data = data;
#line 515
    ldv_timer_11_1 = 1;
#line 516
    return;
  } else {

  }
#line 518
  if (ldv_timer_11_2 == 0 || ldv_timer_11_2 == 2) {
#line 519
    ldv_timer_list_11_2 = timer;
#line 520
    ldv_timer_list_11_2->data = data;
#line 521
    ldv_timer_11_2 = 1;
#line 522
    return;
  } else {

  }
#line 524
  if (ldv_timer_11_3 == 0 || ldv_timer_11_3 == 2) {
#line 525
    ldv_timer_list_11_3 = timer;
#line 526
    ldv_timer_list_11_3->data = data;
#line 527
    ldv_timer_11_3 = 1;
#line 528
    return;
  } else {

  }
#line 530
  return;
}
}
#line 660 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
void *ldv_kmem_cache_alloc_2220(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 663
  ldv_check_alloc_flags(flags);
#line 665
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 666
  return ((void *)0);
}
}
#line 704 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
int ldv_pskb_expand_head_2226(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 707
  ldv_check_alloc_flags(flags);
#line 709
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 709
  return (tmp);
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2228(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 723
  ldv_check_alloc_flags(flags);
#line 725
  tmp = skb_clone(ldv_func_arg1, flags);
#line 725
  return (tmp);
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
struct sk_buff *ldv_skb_copy_2230(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 739
  ldv_check_alloc_flags(flags);
#line 741
  tmp = skb_copy(ldv_func_arg1, flags);
#line 741
  return (tmp);
}
}
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2231(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 747
  ldv_check_alloc_flags(flags);
#line 749
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 749
  return (tmp);
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2232(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 755
  ldv_check_alloc_flags(flags);
#line 757
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 757
  return (tmp);
}
}
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2233(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 763
  ldv_check_alloc_flags(flags);
#line 765
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 765
  return (tmp);
}
}
#line 768 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
int ldv_pskb_expand_head_2234(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 771
  ldv_check_alloc_flags(flags);
#line 773
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 773
  return (tmp);
}
}
#line 776 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
int ldv_pskb_expand_head_2235(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 779
  ldv_check_alloc_flags(flags);
#line 781
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 781
  return (tmp);
}
}
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2236(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 787
  ldv_check_alloc_flags(flags);
#line 789
  tmp = skb_clone(ldv_func_arg1, flags);
#line 789
  return (tmp);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/recv_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2237(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 795
  ldv_check_alloc_flags(flags);
#line 797
  tmp = skb_clone(ldv_func_arg1, flags);
#line 797
  return (tmp);
}
}
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 88 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3067;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3067: ;
#line 14
  return (pfo_ret__);
}
}
#line 438 "include/linux/workqueue.h"
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2264(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_7_1  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_11_0  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_1_3  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_2_0  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_0  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_9_3  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_10_2  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_8_1  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_5_2  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_12  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_5_0  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct wiphy *rtw_cfg80211_ops_group1  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_14  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_9_1  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_3_2  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_6_2  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_2_2  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_3_3  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_9_0  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_5_3  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_9_3  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_4_3  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_9  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_6_0  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_5_1  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_11_1  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ref_cnt  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_7  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_10_0  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_6_3  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct station_parameters *rtw_cfg80211_ops_group2  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_8_2  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_6_2  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_9_2  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_9_2  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_4_0  ;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_1_1  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_7_3  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_2_1  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_11_2  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_6  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_2_0  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_1_1  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct station_info *rtw_cfg80211_ops_group3  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_6_0  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int usb_counter  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_8_3  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_7_1  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_10_2  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_4_3  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct vif_params *rtw_cfg80211_ops_group5  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_5_3  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_7_0  ;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_3_2  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_10_1  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_3  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_3_0  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_4_1  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_4_1  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_2_2  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct net_device *rtw_netdev_ops_group1  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_9_0  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_8_3  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_4  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_7_3  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_8  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_15  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_4_0  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_2_1  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_5_2  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_5  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_11_1  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_13  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_11_2  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_3_1  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_5_1  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_7_2  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_2_3  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_1_0  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_3_3  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_6_1  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_7_0  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_11_0  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_3_1  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct net_device *rtw_cfg80211_ops_group6  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_1  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_6_3  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_8_0  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_10_0  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_4_2  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct wireless_dev *rtw_cfg80211_ops_group0  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_1_3  ;
#line 113 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_10  ;
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_1_0  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_11_3  ;
#line 116 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_1_2  ;
#line 117 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_8_1  ;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct net_device *rtw_cfg80211_monitor_if_ops_group1  ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_2  ;
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_1_2  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_10_1  ;
#line 122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_5_0  ;
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct usb_interface *rtl8723a_usb_drv_group1  ;
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_state_variable_11  ;
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_7_2  ;
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_4_2  ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_8_0  ;
#line 129 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_10_3  ;
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct cfg80211_pmksa *rtw_cfg80211_ops_group4  ;
#line 131 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_6_1  ;
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_11_3  ;
#line 133 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_2_3  ;
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_3_0  ;
#line 135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_timer_10_3  ;
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_8_2  ;
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct timer_list *ldv_timer_list_9_1  ;
#line 185
void ldv_usb_driver_12(void) ;
#line 77 "include/linux/pm_wakeup.h"
__inline static bool device_may_wakeup(struct device *dev ) 
{ 


  {
#line 79
  return ((bool )((unsigned int )*((unsigned char *)dev + 532UL) != 0U && (unsigned long )dev->power.wakeup != (unsigned long )((struct wakeup_source *)0)));
}
}
#line 94
extern int device_init_wakeup(struct device * , bool  ) ;
#line 837 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 839
  return ((void *)dev->driver_data);
}
}
#line 842 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 844
  dev->driver_data = data;
#line 845
  return;
}
}
#line 16 "include/linux/random.h"
extern void get_random_bytes(void * , int  ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_2272(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2280(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_2274(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_2270(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2278(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2279(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2275(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2276(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2277(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 1978 "include/linux/netdevice.h"
void ldv_free_netdev_2281(struct net_device *dev ) ;
#line 1982
void ldv_free_netdev_2283(struct net_device *dev ) ;
#line 2180 "include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues___0(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2184
  i = 0U;
#line 2184
  goto ldv_40884;
  ldv_40883: 
#line 2185
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2185
  txq = tmp;
#line 2186
  netif_tx_start_queue(txq);
#line 2184
  i = i + 1U;
  ldv_40884: ;
#line 2184
  if (dev->num_tx_queues > i) {
#line 2186
    goto ldv_40883;
  } else {

  }

#line 2191
  return;
}
}
#line 2200 "include/linux/netdevice.h"
__inline static void netif_tx_wake_all_queues___1(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2204
  i = 0U;
#line 2204
  goto ldv_40898;
  ldv_40897: 
#line 2205
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2205
  txq = tmp;
#line 2206
  netif_tx_wake_queue(txq);
#line 2204
  i = i + 1U;
  ldv_40898: ;
#line 2204
  if (dev->num_tx_queues > i) {
#line 2206
    goto ldv_40897;
  } else {

  }

#line 2211
  return;
}
}
#line 2231 "include/linux/netdevice.h"
__inline static void netif_tx_stop_all_queues___1(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2235
  i = 0U;
#line 2235
  goto ldv_40914;
  ldv_40913: 
#line 2236
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2236
  txq = tmp;
#line 2237
  netif_tx_stop_queue(txq);
#line 2235
  i = i + 1U;
  ldv_40914: ;
#line 2235
  if (dev->num_tx_queues > i) {
#line 2237
    goto ldv_40913;
  } else {

  }

#line 2242
  return;
}
}
#line 2767
extern void netif_device_attach(struct net_device * ) ;
#line 3002
void ldv_unregister_netdev_2282(struct net_device *dev ) ;
#line 174 "include/linux/etherdevice.h"
__inline static void eth_random_addr(u8 *addr ) 
{ 


  {
#line 176
  get_random_bytes((void *)addr, 6);
#line 177
  *addr = (unsigned int )*addr & 254U;
#line 178
  *addr = (u8 )((unsigned int )*addr | 2U);
#line 179
  return;
}
}
#line 3109 "include/net/cfg80211.h"
__inline static void *wiphy_priv___2(struct wiphy *wiphy ) 
{ 
  long tmp ;

  {
#line 3111
  tmp = ldv__builtin_expect((unsigned long )wiphy == (unsigned long )((struct wiphy *)0),
                         0L);
#line 3111
  if (tmp != 0L) {
#line 3111
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3111), "i" (12UL));
    ldv_45905: ;
#line 3111
    goto ldv_45905;
  } else {

  }
#line 3112
  return ((void *)(& wiphy->priv));
}
}
#line 3341 "include/net/cfg80211.h"
__inline static void *wdev_priv___2(struct wireless_dev *wdev ) 
{ 
  long tmp ;
  void *tmp___0 ;

  {
#line 3343
  tmp = ldv__builtin_expect((unsigned long )wdev == (unsigned long )((struct wireless_dev *)0),
                         0L);
#line 3343
  if (tmp != 0L) {
#line 3343
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/net/cfg80211.h"),
                         "i" (3343), "i" (12UL));
    ldv_45985: ;
#line 3343
    goto ldv_45985;
  } else {

  }
#line 3344
  tmp___0 = wiphy_priv___2(wdev->wiphy);
#line 3344
  return (tmp___0);
}
}
#line 104 "drivers/staging/rtl8723au/include/hal_intf.h"
int rtw_resume_process23a(struct rtw_adapter *padapter ) ;
#line 194 "include/linux/usb.h"
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
#line 196
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
#line 196
  return (tmp);
}
}
#line 199 "include/linux/usb.h"
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 


  {
#line 201
  dev_set_drvdata(& intf->dev, data);
#line 202
  return;
}
}
#line 595 "include/linux/usb.h"
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) 
{ 
  struct device  const  *__mptr ;

  {
#line 597
  __mptr = (struct device  const  *)intf->dev.parent;
#line 597
  return ((struct usb_device *)__mptr + 0xffffffffffffff70UL);
}
}
#line 600
extern struct usb_device *usb_get_dev(struct usb_device * ) ;
#line 601
extern void usb_put_dev(struct usb_device * ) ;
#line 625
extern int usb_reset_device(struct usb_device * ) ;
#line 644
extern int usb_autopm_get_interface(struct usb_interface * ) ;
#line 645
extern void usb_autopm_put_interface(struct usb_interface * ) ;
#line 1148
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
#line 1152
int ldv_usb_register_driver_2284(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
#line 1159
extern void usb_deregister(struct usb_driver * ) ;
#line 1162
void ldv_usb_deregister_2285(struct usb_driver *arg ) ;
#line 27 "drivers/staging/rtl8723au/include/rtw_ap.h"
void free_mlme_ap_info23a(struct rtw_adapter *padapter ) ;
#line 29 "drivers/staging/rtl8723au/include/usb_ops_linux.h"
void rtl8723au_write_port_cancel(struct rtw_adapter *padapter ) ;
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static int rtw_suspend(struct usb_interface *pusb_intf , pm_message_t message ) ;
#line 247
static int rtw_resume(struct usb_interface *pusb_intf ) ;
#line 248
static int rtw_drv_init(struct usb_interface *pusb_intf , struct usb_device_id  const  *pdid ) ;
#line 250
static void rtw_disconnect(struct usb_interface *pusb_intf ) ;
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static struct usb_device_id rtl8723a_usb_id_tbl[4U]  = {      {899U, 3034U, 34596U, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}, 
        {899U,
      3034U, 5924U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}, 
        {899U, 3034U, 1828U, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, 255U, 255U, 255U, (unsigned char)0, 0UL}};
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct usb_device_id  const  __mod_usb__rtl8723a_usb_id_tbl_device_table  ;
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static struct usb_driver rtl8723a_usb_drv  = 
#line 269
     {"rtl8723au", & rtw_drv_init, & rtw_disconnect, 0, & rtw_suspend, & rtw_resume,
    & rtw_resume, 0, 0, (struct usb_device_id  const  *)(& rtl8723a_usb_id_tbl), {{{{{{0U}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0}},
    {{0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0};
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static struct usb_driver *usb_drv  =    & rtl8723a_usb_drv;
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
__inline static int RT_usb_endpoint_dir_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 283
  return ((int )((signed char )epd->bEndpointAddress) < 0);
}
}
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
__inline static int RT_usb_endpoint_dir_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 288
  return ((int )((signed char )epd->bEndpointAddress) >= 0);
}
}
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
__inline static int RT_usb_endpoint_xfer_int(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 293
  return (((int )epd->bmAttributes & 3) == 3);
}
}
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
__inline static int RT_usb_endpoint_xfer_bulk(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 298
  return (((int )epd->bmAttributes & 3) == 2);
}
}
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
__inline static int RT_usb_endpoint_is_bulk_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 303
  tmp = RT_usb_endpoint_xfer_bulk(epd);
#line 303
  if (tmp != 0) {
#line 303
    tmp___0 = RT_usb_endpoint_dir_in(epd);
#line 303
    if (tmp___0 != 0) {
#line 303
      tmp___1 = 1;
    } else {
#line 303
      tmp___1 = 0;
    }
  } else {
#line 303
    tmp___1 = 0;
  }
#line 303
  return (tmp___1);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
__inline static int RT_usb_endpoint_is_bulk_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 308
  tmp = RT_usb_endpoint_xfer_bulk(epd);
#line 308
  if (tmp != 0) {
#line 308
    tmp___0 = RT_usb_endpoint_dir_out(epd);
#line 308
    if (tmp___0 != 0) {
#line 308
      tmp___1 = 1;
    } else {
#line 308
      tmp___1 = 0;
    }
  } else {
#line 308
    tmp___1 = 0;
  }
#line 308
  return (tmp___1);
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
__inline static int RT_usb_endpoint_is_int_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 313
  tmp = RT_usb_endpoint_xfer_int(epd);
#line 313
  if (tmp != 0) {
#line 313
    tmp___0 = RT_usb_endpoint_dir_in(epd);
#line 313
    if (tmp___0 != 0) {
#line 313
      tmp___1 = 1;
    } else {
#line 313
      tmp___1 = 0;
    }
  } else {
#line 313
    tmp___1 = 0;
  }
#line 313
  return (tmp___1);
}
}
#line 316 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
__inline static int RT_usb_endpoint_num(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 318
  return ((int )epd->bEndpointAddress & 15);
}
}
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static int rtw_init_intf_priv(struct dvobj_priv *dvobj ) 
{ 
  int rst ;
  struct lock_class_key __key ;
  void *tmp ;

  {
#line 323
  rst = 1;
#line 325
  __mutex_init(& dvobj->usb_vendor_req_mutex, "&dvobj->usb_vendor_req_mutex", & __key);
#line 326
  tmp = kzalloc(270UL, 208U);
#line 326
  dvobj->usb_alloc_vendor_req_buf = (u8 *)tmp;
#line 328
  if ((unsigned long )dvobj->usb_alloc_vendor_req_buf == (unsigned long )((u8 *)0U)) {
#line 329
    if (GlobalDebugLevel23A > 3U) {
#line 329
      printk("\016RTL8723AU: alloc usb_vendor_req_buf failed...\n");
    } else {

    }
#line 330
    rst = 0;
#line 331
    goto exit;
  } else {

  }
#line 333
  dvobj->usb_vendor_req_buf = (u8 *)(((unsigned long )dvobj->usb_alloc_vendor_req_buf + 15UL) & 0xfffffffffffffff0UL);
  exit: ;
#line 336
  return (rst);
}
}
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static int rtw_deinit_intf_priv(struct dvobj_priv *dvobj ) 
{ 
  int rst ;

  {
#line 341
  rst = 1;
#line 343
  kfree((void const   *)dvobj->usb_alloc_vendor_req_buf);
#line 345
  mutex_destroy(& dvobj->usb_vendor_req_mutex);
#line 347
  return (rst);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static struct dvobj_priv *usb_dvobj_init(struct usb_interface *usb_intf ) 
{ 
  struct dvobj_priv *pdvobjpriv ;
  struct usb_device_descriptor *pdev_desc ;
  struct usb_host_config *phost_conf ;
  struct usb_config_descriptor *pconf_desc ;
  struct usb_host_interface *phost_iface ;
  struct usb_interface_descriptor *piface_desc ;
  struct usb_host_endpoint *phost_endp ;
  struct usb_endpoint_descriptor *pendp_desc ;
  struct usb_device *pusbd ;
  int i ;
  int status ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 362
  status = 0;
#line 364
  tmp = kzalloc(992UL, 208U);
#line 364
  pdvobjpriv = (struct dvobj_priv *)tmp;
#line 365
  if ((unsigned long )pdvobjpriv == (unsigned long )((struct dvobj_priv *)0)) {
#line 366
    goto exit;
  } else {

  }
#line 368
  __mutex_init(& pdvobjpriv->hw_init_mutex, "&pdvobjpriv->hw_init_mutex", & __key);
#line 369
  __mutex_init(& pdvobjpriv->h2c_fwcmd_mutex, "&pdvobjpriv->h2c_fwcmd_mutex", & __key___0);
#line 370
  __mutex_init(& pdvobjpriv->setch_mutex, "&pdvobjpriv->setch_mutex", & __key___1);
#line 371
  __mutex_init(& pdvobjpriv->setbw_mutex, "&pdvobjpriv->setbw_mutex", & __key___2);
#line 373
  pdvobjpriv->pusbintf = usb_intf;
#line 374
  pusbd = interface_to_usbdev(usb_intf);
#line 375
  pdvobjpriv->pusbdev = pusbd;
#line 376
  usb_set_intfdata(usb_intf, (void *)pdvobjpriv);
#line 378
  pdvobjpriv->RtNumInPipes = 0U;
#line 379
  pdvobjpriv->RtNumOutPipes = 0U;
#line 381
  pdev_desc = & pusbd->descriptor;
#line 383
  phost_conf = pusbd->actconfig;
#line 384
  pconf_desc = & phost_conf->desc;
#line 386
  phost_iface = usb_intf->altsetting;
#line 387
  piface_desc = & phost_iface->desc;
#line 389
  pdvobjpriv->NumInterfaces = pconf_desc->bNumInterfaces;
#line 390
  pdvobjpriv->InterfaceNumber = piface_desc->bInterfaceNumber;
#line 391
  pdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;
#line 393
  i = 0;
#line 393
  goto ldv_54379;
  ldv_54378: 
#line 394
  phost_endp = phost_iface->endpoint + (unsigned long )i;
#line 395
  if ((unsigned long )phost_endp != (unsigned long )((struct usb_host_endpoint *)0)) {
#line 396
    pendp_desc = & phost_endp->desc;
#line 398
    if (GlobalDebugLevel23A > 3U) {
#line 398
      printk("\016RTL8723AU: \nusb_endpoint_descriptor(%d):\n", i);
    } else {

    }
#line 399
    if (GlobalDebugLevel23A > 3U) {
#line 399
      printk("\016RTL8723AU: bLength =%x\n", (int )pendp_desc->bLength);
    } else {

    }
#line 400
    if (GlobalDebugLevel23A > 3U) {
#line 400
      printk("\016RTL8723AU: bDescriptorType =%x\n", (int )pendp_desc->bDescriptorType);
    } else {

    }
#line 402
    if (GlobalDebugLevel23A > 3U) {
#line 402
      printk("\016RTL8723AU: bEndpointAddress =%x\n", (int )pendp_desc->bEndpointAddress);
    } else {

    }
#line 404
    if (GlobalDebugLevel23A > 3U) {
#line 404
      printk("\016RTL8723AU: wMaxPacketSize =%d\n", (int )pendp_desc->wMaxPacketSize);
    } else {

    }
#line 406
    if (GlobalDebugLevel23A > 3U) {
#line 406
      printk("\016RTL8723AU: bInterval =%x\n", (int )pendp_desc->bInterval);
    } else {

    }
#line 408
    tmp___5 = RT_usb_endpoint_is_bulk_in((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 408
    if (tmp___5 != 0) {
#line 409
      if (GlobalDebugLevel23A > 3U) {
#line 409
        tmp___0 = RT_usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 409
        printk("\016RTL8723AU: RT_usb_endpoint_is_bulk_in = %x\n", tmp___0);
      } else {

      }
#line 411
      pdvobjpriv->RtInPipe[(int )pdvobjpriv->RtNumInPipes] = RT_usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 413
      pdvobjpriv->RtNumInPipes = (u8 )((int )pdvobjpriv->RtNumInPipes + 1);
    } else {
#line 414
      tmp___4 = RT_usb_endpoint_is_int_in((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 414
      if (tmp___4 != 0) {
#line 415
        if (GlobalDebugLevel23A > 3U) {
#line 415
          tmp___1 = RT_usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 415
          printk("\016RTL8723AU: RT_usb_endpoint_is_int_in = %x, Interval = %x\n",
                 tmp___1, (int )pendp_desc->bInterval);
        } else {

        }
#line 418
        pdvobjpriv->RtInPipe[(int )pdvobjpriv->RtNumInPipes] = RT_usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 420
        pdvobjpriv->RtNumInPipes = (u8 )((int )pdvobjpriv->RtNumInPipes + 1);
      } else {
#line 421
        tmp___3 = RT_usb_endpoint_is_bulk_out((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 421
        if (tmp___3 != 0) {
#line 422
          if (GlobalDebugLevel23A > 3U) {
#line 422
            tmp___2 = RT_usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 422
            printk("\016RTL8723AU: RT_usb_endpoint_is_bulk_out = %x\n", tmp___2);
          } else {

          }
#line 424
          pdvobjpriv->RtOutPipe[(int )pdvobjpriv->RtNumOutPipes] = RT_usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
#line 426
          pdvobjpriv->RtNumOutPipes = (u8 )((int )pdvobjpriv->RtNumOutPipes + 1);
        } else {

        }
      }
    }
#line 428
    pdvobjpriv->ep_num[i] = RT_usb_endpoint_num((struct usb_endpoint_descriptor  const  *)pendp_desc);
  } else {

  }
#line 393
  i = i + 1;
  ldv_54379: ;
#line 393
  if ((int )pdvobjpriv->nr_endpoint > i) {
#line 395
    goto ldv_54378;
  } else {

  }

#line 431
  if (GlobalDebugLevel23A > 3U) {
#line 431
    printk("\016RTL8723AU: nr_endpoint =%d, in_num =%d, out_num =%d\n\n", (int )pdvobjpriv->nr_endpoint,
           (int )pdvobjpriv->RtNumInPipes, (int )pdvobjpriv->RtNumOutPipes);
  } else {

  }
#line 435
  if ((unsigned int )pusbd->speed == 3U) {
#line 436
    pdvobjpriv->ishighspeed = 1U;
#line 437
    if (GlobalDebugLevel23A > 3U) {
#line 437
      printk("\016RTL8723AU: USB_SPEED_HIGH\n");
    } else {

    }
  } else {
#line 439
    pdvobjpriv->ishighspeed = 0U;
#line 440
    if (GlobalDebugLevel23A > 3U) {
#line 440
      printk("\016RTL8723AU: NON USB_SPEED_HIGH\n");
    } else {

    }
  }
#line 443
  tmp___6 = rtw_init_intf_priv(pdvobjpriv);
#line 443
  if (tmp___6 == 0) {
#line 444
    if (GlobalDebugLevel23A > 3U) {
#line 444
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2048U, 4);
#line 444
      printk("\016\n Can\'t INIT rtw_init_intf_priv\n");
    } else {

    }
#line 446
    goto free_dvobj;
  } else {

  }
#line 449
  rtw_reset_continual_urb_error(pdvobjpriv);
#line 450
  usb_get_dev(pusbd);
#line 451
  status = 1;
  free_dvobj: ;
#line 453
  if (status != 1 && (unsigned long )pdvobjpriv != (unsigned long )((struct dvobj_priv *)0)) {
#line 454
    usb_set_intfdata(usb_intf, (void *)0);
#line 455
    mutex_destroy(& pdvobjpriv->hw_init_mutex);
#line 456
    mutex_destroy(& pdvobjpriv->h2c_fwcmd_mutex);
#line 457
    mutex_destroy(& pdvobjpriv->setch_mutex);
#line 458
    mutex_destroy(& pdvobjpriv->setbw_mutex);
#line 459
    kfree((void const   *)pdvobjpriv);
#line 460
    pdvobjpriv = (struct dvobj_priv *)0;
  } else {

  }
  exit: ;
#line 463
  return (pdvobjpriv);
}
}
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static void usb_dvobj_deinit(struct usb_interface *usb_intf ) 
{ 
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct usb_device *tmp___0 ;
  struct usb_device *tmp___1 ;
  struct usb_device *tmp___2 ;

  {
#line 468
  tmp = usb_get_intfdata(usb_intf);
#line 468
  dvobj = (struct dvobj_priv *)tmp;
#line 470
  usb_set_intfdata(usb_intf, (void *)0);
#line 471
  if ((unsigned long )dvobj != (unsigned long )((struct dvobj_priv *)0)) {
#line 473
    if (((unsigned int )dvobj->NumInterfaces != 2U && (unsigned int )dvobj->NumInterfaces != 3U) || (unsigned int )dvobj->InterfaceNumber == 1U) {
#line 475
      tmp___1 = interface_to_usbdev(usb_intf);
#line 475
      if ((unsigned int )tmp___1->state != 0U) {
#line 483
        if (GlobalDebugLevel23A > 3U) {
#line 483
          printk("\016RTL8723AU: usb attached..., try to reset usb device\n");
        } else {

        }
#line 484
        tmp___0 = interface_to_usbdev(usb_intf);
#line 484
        usb_reset_device(tmp___0);
      } else {

      }
    } else {

    }
#line 487
    rtw_deinit_intf_priv(dvobj);
#line 488
    mutex_destroy(& dvobj->hw_init_mutex);
#line 489
    mutex_destroy(& dvobj->h2c_fwcmd_mutex);
#line 490
    mutex_destroy(& dvobj->setch_mutex);
#line 491
    mutex_destroy(& dvobj->setbw_mutex);
#line 492
    kfree((void const   *)dvobj);
  } else {

  }
#line 494
  tmp___2 = interface_to_usbdev(usb_intf);
#line 494
  usb_put_dev(tmp___2);
#line 495
  return;
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void rtl8723a_usb_intf_stop(struct rtw_adapter *padapter ) 
{ 


  {
#line 499
  if (GlobalDebugLevel23A > 3U) {
#line 499
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 499
    printk("\016+usb_intf_stop\n");
  } else {

  }
#line 502
  if (padapter->bSurpriseRemoved == 0) {
#line 506
    if (GlobalDebugLevel23A > 3U) {
#line 506
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 506
      printk("\016SurpriseRemoved == false\n");
    } else {

    }
  } else {

  }
#line 511
  rtl8723au_inirp_deinit(padapter);
#line 514
  rtl8723au_write_port_cancel(padapter);
#line 517
  if (GlobalDebugLevel23A > 3U) {
#line 517
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 517
    printk("\016-usb_intf_stop\n");
  } else {

  }
#line 519
  return;
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static void rtw_dev_unload(struct rtw_adapter *padapter ) 
{ 


  {
#line 522
  if (GlobalDebugLevel23A > 3U) {
#line 522
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 522
    printk("\016+rtw_dev_unload\n");
  } else {

  }
#line 524
  if (padapter->bup != 0) {
#line 525
    if (GlobalDebugLevel23A > 3U) {
#line 525
      printk("\016RTL8723AU: ===> rtw_dev_unload\n");
    } else {

    }
#line 527
    padapter->bDriverStopped = 1;
#line 528
    if (padapter->xmitpriv.ack_tx != 0) {
#line 529
      rtw_ack_tx_done23a(& padapter->xmitpriv, 9);
    } else {

    }
#line 533
    rtl8723a_usb_intf_stop(padapter);
#line 536
    flush_workqueue(padapter->cmdpriv.wq);
#line 539
    if (padapter->bSurpriseRemoved == 0) {
#line 540
      rtw_hal_deinit23a(padapter);
#line 541
      padapter->bSurpriseRemoved = 1;
    } else {

    }
#line 543
    padapter->bup = 0;
  } else
#line 545
  if (GlobalDebugLevel23A > 3U) {
#line 545
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 545
    printk("\016r871x_dev_unload():padapter->bup == false\n");
  } else {

  }
#line 548
  if (GlobalDebugLevel23A > 3U) {
#line 548
    printk("\016RTL8723AU: <=== rtw_dev_unload\n");
  } else {

  }
#line 549
  if (GlobalDebugLevel23A > 3U) {
#line 549
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 549
    printk("\016-rtw_dev_unload\n");
  } else {

  }
#line 551
  return;
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int rtw_hw_suspend23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
#line 554
  pwrpriv = & padapter->pwrctrlpriv;
#line 555
  pnetdev = padapter->pnetdev;
#line 556
  pmlmepriv = & padapter->mlmepriv;
#line 558
  if ((padapter->bup == 0 || padapter->bDriverStopped != 0) || padapter->bSurpriseRemoved != 0) {
#line 560
    if (GlobalDebugLevel23A > 3U) {
#line 560
      printk("\016RTL8723AU: padapter->bup =%d bDriverStopped =%d bSurpriseRemoved = %d\n",
             padapter->bup, padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
#line 563
    goto error_exit;
  } else {

  }
#line 566
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 567
    LeaveAllPowerSaveMode23a(padapter);
#line 569
    if (GlobalDebugLevel23A > 3U) {
#line 569
      printk("\016RTL8723AU: ==> rtw_hw_suspend23a\n");
    } else {

    }
#line 570
    down(& pwrpriv->lock);
#line 571
    pwrpriv->bips_processing = 1U;
#line 574
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 575
      netif_carrier_off(pnetdev);
#line 576
      netif_tx_stop_all_queues___1(pnetdev);
    } else {

    }
#line 580
    rtw_disassoc_cmd23a(padapter, 500U, 0);
#line 584
    tmp = check_fwstate(pmlmepriv, 1);
#line 584
    if ((int )tmp) {
#line 585
      _clr_fwstate_(pmlmepriv, 1);
#line 589
      rtw_os_indicate_disconnect23a(padapter);
#line 592
      rtw_lps_ctrl_wk_cmd23a(padapter, 3, 0);
    } else {

    }
#line 596
    rtw_free_assoc_resources23a(padapter, 1);
#line 599
    rtw_free_network_queue23a(padapter);
#line 600
    rtw_ips_dev_unload23a(padapter);
#line 601
    pwrpriv->rf_pwrstate = 2;
#line 602
    pwrpriv->bips_processing = 0U;
#line 603
    up(& pwrpriv->lock);
  } else {
#line 605
    goto error_exit;
  }
#line 607
  return (0);
  error_exit: ;
#line 609
  if (GlobalDebugLevel23A > 3U) {
#line 609
    printk("\016RTL8723AU: %s, failed\n", "rtw_hw_suspend23a");
  } else {

  }
#line 610
  return (-1);
}
}
#line 613 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int rtw_hw_resume23a(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *pwrpriv ;
  struct net_device *pnetdev ;
  int tmp ;
  int tmp___0 ;

  {
#line 615
  pwrpriv = & padapter->pwrctrlpriv;
#line 616
  pnetdev = padapter->pnetdev;
#line 618
  if ((unsigned long )padapter != (unsigned long )((struct rtw_adapter *)0)) {
#line 619
    if (GlobalDebugLevel23A > 3U) {
#line 619
      printk("\016RTL8723AU: ==> rtw_hw_resume23a\n");
    } else {

    }
#line 620
    down(& pwrpriv->lock);
#line 621
    pwrpriv->bips_processing = 1U;
#line 622
    rtw_reset_drv_sw23a(padapter);
#line 624
    tmp = pm_netdev_open23a(pnetdev, 0);
#line 624
    if (tmp != 0) {
#line 625
      up(& pwrpriv->lock);
#line 626
      goto error_exit;
    } else {

    }
#line 629
    netif_device_attach(pnetdev);
#line 630
    netif_carrier_on(pnetdev);
#line 632
    tmp___0 = rtw_netif_queue_stopped(pnetdev);
#line 632
    if (tmp___0 == 0) {
#line 633
      netif_tx_start_all_queues___0(pnetdev);
    } else {
#line 635
      netif_tx_wake_all_queues___1(pnetdev);
    }
#line 637
    pwrpriv->bkeepfwalive = 0U;
#line 638
    pwrpriv->brfoffbyhw = 0U;
#line 640
    pwrpriv->rf_pwrstate = 0;
#line 641
    pwrpriv->bips_processing = 0U;
#line 643
    up(& pwrpriv->lock);
  } else {
#line 645
    goto error_exit;
  }
#line 647
  return (0);
  error_exit: ;
#line 649
  if (GlobalDebugLevel23A > 3U) {
#line 649
    printk("\016RTL8723AU: %s, Open net dev failed\n", "rtw_hw_resume23a");
  } else {

  }
#line 650
  return (-1);
}
}
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static int rtw_suspend(struct usb_interface *pusb_intf , pm_message_t message ) 
{ 
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  struct pwrctrl_priv *pwrpriv ;
  int ret ;
  unsigned long start_time ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 655
  tmp = usb_get_intfdata(pusb_intf);
#line 655
  dvobj = (struct dvobj_priv *)tmp;
#line 656
  padapter = dvobj->if1;
#line 657
  pnetdev = padapter->pnetdev;
#line 658
  pmlmepriv = & padapter->mlmepriv;
#line 659
  pwrpriv = & padapter->pwrctrlpriv;
#line 660
  ret = 0;
#line 661
  start_time = jiffies;
#line 663
  if (GlobalDebugLevel23A > 3U) {
#line 663
    tmp___0 = get_current();
#line 663
    tmp___1 = get_current();
#line 663
    printk("\016RTL8723AU: ==> %s (%s:%d)\n", "rtw_suspend", (char *)(& tmp___1->comm),
           tmp___0->pid);
  } else {

  }
#line 665
  if ((padapter->bup == 0 || padapter->bDriverStopped != 0) || padapter->bSurpriseRemoved != 0) {
#line 667
    if (GlobalDebugLevel23A > 3U) {
#line 667
      printk("\016RTL8723AU: padapter->bup =%d bDriverStopped =%d bSurpriseRemoved = %d\n",
             padapter->bup, padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
#line 670
    goto exit;
  } else {

  }
#line 672
  pwrpriv->bInSuspend = 1U;
#line 673
  rtw_cancel_all_timer23a(padapter);
#line 674
  LeaveAllPowerSaveMode23a(padapter);
#line 676
  down(& pwrpriv->lock);
#line 679
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 680
    netif_carrier_off(pnetdev);
#line 681
    netif_tx_stop_all_queues___1(pnetdev);
  } else {

  }
#line 685
  rtw_disassoc_cmd23a(padapter, 0U, 0);
#line 687
  tmp___2 = check_fwstate(pmlmepriv, 8);
#line 687
  if ((int )tmp___2) {
#line 687
    tmp___3 = check_fwstate(pmlmepriv, 1);
#line 687
    if ((int )tmp___3) {
#line 689
      if (GlobalDebugLevel23A > 3U) {
#line 689
        printk("\016RTL8723AU: %s:%d %s(%pM), length:%d assoc_ssid.length:%d\n", "rtw_suspend",
               694, (u8 *)(& pmlmepriv->cur_network.network.Ssid.ssid), (u8 *)(& pmlmepriv->cur_network.network.MacAddress),
               (int )pmlmepriv->cur_network.network.Ssid.ssid_len, (int )pmlmepriv->assoc_ssid.ssid_len);
      } else {

      }
#line 696
      rtw_set_roaming(padapter, 1);
    } else {

    }
  } else {

  }
#line 699
  rtw_indicate_disconnect23a(padapter);
#line 701
  rtw_free_assoc_resources23a(padapter, 1);
#line 703
  rtw_free_network_queue23a(padapter);
#line 705
  rtw_dev_unload(padapter);
#line 706
  up(& pwrpriv->lock);
#line 708
  tmp___5 = check_fwstate(pmlmepriv, 2048);
#line 708
  if ((int )tmp___5) {
#line 709
    tmp___4 = wdev_priv___2(padapter->rtw_wdev);
#line 709
    rtw_cfg80211_indicate_scan_done((struct rtw_wdev_priv *)tmp___4, 1);
  } else {

  }
#line 712
  tmp___6 = check_fwstate(pmlmepriv, 128);
#line 712
  if ((int )tmp___6) {
#line 713
    rtw_indicate_disconnect23a(padapter);
  } else {

  }
  exit: ;
#line 716
  if (GlobalDebugLevel23A > 3U) {
#line 716
    tmp___7 = jiffies_to_msecs((unsigned long )jiffies - start_time);
#line 716
    printk("\016RTL8723AU: <===  %s return %d.............. in %dms\n", "rtw_suspend",
           ret, tmp___7);
  } else {

  }
#line 719
  return (ret);
}
}
#line 722 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static int rtw_resume(struct usb_interface *pusb_intf ) 
{ 
  struct dvobj_priv *dvobj ;
  void *tmp ;
  struct rtw_adapter *padapter ;
  int ret ;

  {
#line 724
  tmp = usb_get_intfdata(pusb_intf);
#line 724
  dvobj = (struct dvobj_priv *)tmp;
#line 725
  padapter = dvobj->if1;
#line 728
  ret = rtw_resume_process23a(padapter);
#line 730
  return (ret);
}
}
#line 733 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int rtw_resume_process23a(struct rtw_adapter *padapter ) 
{ 
  struct net_device *pnetdev ;
  struct pwrctrl_priv *pwrpriv ;
  int ret ;
  unsigned long start_time ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  struct pid *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 736
  pwrpriv = (struct pwrctrl_priv *)0;
#line 737
  ret = -1;
#line 738
  start_time = jiffies;
#line 740
  if (GlobalDebugLevel23A > 3U) {
#line 740
    tmp = get_current();
#line 740
    tmp___0 = get_current();
#line 740
    printk("\016RTL8723AU: ==> %s (%s:%d)\n", "rtw_resume_process23a", (char *)(& tmp___0->comm),
           tmp->pid);
  } else {

  }
#line 742
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 743
    goto exit;
  } else {

  }
#line 744
  pnetdev = padapter->pnetdev;
#line 745
  pwrpriv = & padapter->pwrctrlpriv;
#line 747
  down(& pwrpriv->lock);
#line 748
  rtw_reset_drv_sw23a(padapter);
#line 749
  pwrpriv->bkeepfwalive = 0U;
#line 751
  if (GlobalDebugLevel23A > 3U) {
#line 751
    printk("\016RTL8723AU: bkeepfwalive(%x)\n", (int )pwrpriv->bkeepfwalive);
  } else {

  }
#line 752
  tmp___1 = pm_netdev_open23a(pnetdev, 1);
#line 752
  if (tmp___1 != 0) {
#line 753
    goto exit;
  } else {

  }
#line 755
  netif_device_attach(pnetdev);
#line 756
  netif_carrier_on(pnetdev);
#line 758
  up(& pwrpriv->lock);
#line 760
  if (padapter->pid[1] != 0) {
#line 761
    if (GlobalDebugLevel23A > 3U) {
#line 761
      printk("\016RTL8723AU: pid[1]:%d\n", padapter->pid[1]);
    } else {

    }
#line 762
    tmp___2 = find_vpid(padapter->pid[1]);
#line 762
    kill_pid(tmp___2, 12, 1);
  } else {

  }
#line 765
  rtw23a_roaming(padapter, (struct wlan_network *)0);
#line 767
  ret = 0;
  exit: ;
#line 769
  if ((unsigned long )pwrpriv != (unsigned long )((struct pwrctrl_priv *)0)) {
#line 770
    pwrpriv->bInSuspend = 0U;
  } else {

  }
#line 771
  if (GlobalDebugLevel23A > 3U) {
#line 771
    tmp___3 = jiffies_to_msecs((unsigned long )jiffies - start_time);
#line 771
    printk("\016RTL8723AU: <===  %s return %d.............. in %dms\n", "rtw_resume_process23a",
           ret, tmp___3);
  } else {

  }
#line 774
  return (ret);
}
}
#line 784 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static struct rtw_adapter *rtw_usb_if1_init(struct dvobj_priv *dvobj , struct usb_interface *pusb_intf ,
                                            struct usb_device_id  const  *pdid ) 
{ 
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  int status ;
  void *tmp ;
  u8 tmp___0 ;
  int tmp___1 ;
  struct device *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;

  {
#line 788
  padapter = (struct rtw_adapter *)0;
#line 789
  pnetdev = (struct net_device *)0;
#line 790
  status = 0;
#line 792
  pnetdev = rtw_init_netdev23a(padapter);
#line 793
  if ((unsigned long )pnetdev == (unsigned long )((struct net_device *)0)) {
#line 794
    goto handle_dualmac;
  } else {

  }
#line 795
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 795
  padapter = (struct rtw_adapter *)tmp;
#line 797
  padapter->dvobj = dvobj;
#line 798
  padapter->bDriverStopped = 1;
#line 799
  dvobj->if1 = padapter;
#line 800
  tmp___0 = dvobj->iface_nums;
#line 800
  dvobj->iface_nums = (u8 )((int )dvobj->iface_nums + 1);
#line 800
  dvobj->padapters[(int )tmp___0] = padapter;
#line 801
  padapter->iface_id = 0U;
#line 803
  rtl8723au_set_hw_type(padapter);
#line 805
  tmp___1 = rtw_handle_dualmac23a(padapter, 1);
#line 805
  if (tmp___1 != 1) {
#line 806
    goto free_adapter;
  } else {

  }
#line 808
  pnetdev->dev.parent = dvobj_to_dev(dvobj);
#line 810
  tmp___2 = dvobj_to_dev(dvobj);
#line 810
  tmp___3 = rtw_wdev_alloc(padapter, tmp___2);
#line 810
  if (tmp___3 != 0) {
#line 811
    goto handle_dualmac;
  } else {

  }
#line 814
  padapter->HalData = kzalloc(9096UL, 208U);
#line 815
  if ((unsigned long )padapter->HalData == (unsigned long )((void *)0)) {
#line 816
    goto free_wdev;
  } else {

  }
#line 819
  rtl8723a_read_chip_version(padapter);
#line 822
  rtl8723au_chip_configure(padapter);
#line 825
  rtl8723a_read_adapter_info(padapter);
#line 828
  tmp___4 = rtw_init_drv_sw23a(padapter);
#line 828
  if (tmp___4 == 0) {
#line 829
    if (GlobalDebugLevel23A > 3U) {
#line 829
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 829
      printk("\016Initialize driver software resource Failed!\n");
    } else {

    }
#line 831
    goto free_hal_data;
  } else {

  }
#line 835
  if ((unsigned int )padapter->pwrctrlpriv.bSupportRemoteWakeup != 0U) {
#line 836
    (dvobj->pusbdev)->do_remote_wakeup = 1U;
#line 837
    pusb_intf->needs_remote_wakeup = 1U;
#line 838
    device_init_wakeup(& pusb_intf->dev, 1);
#line 839
    if (GlobalDebugLevel23A > 3U) {
#line 839
      printk("\016RTL8723AU: \n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~~~~\n");
    } else {

    }
#line 840
    if (GlobalDebugLevel23A > 3U) {
#line 840
      tmp___5 = device_may_wakeup(& pusb_intf->dev);
#line 840
      printk("\016RTL8723AU: \n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~[%d]~~~\n",
             (int )tmp___5);
    } else {

    }
  } else {

  }
#line 847
  tmp___6 = usb_autopm_get_interface(pusb_intf);
#line 847
  if (tmp___6 < 0) {
#line 848
    if (GlobalDebugLevel23A > 3U) {
#line 848
      printk("\016RTL8723AU: can\'t get autopm:\n");
    } else {

    }
  } else {

  }
#line 850
  padapter->pwrctrlpriv.autopm_cnt = 1U;
#line 854
  tmp___7 = is_broadcast_ether_addr((u8 const   *)(& padapter->eeprompriv.mac_addr));
#line 854
  if ((int )tmp___7) {
#line 856
    eth_random_addr((u8 *)(& padapter->eeprompriv.mac_addr));
  } else {
#line 854
    tmp___8 = is_zero_ether_addr((u8 const   *)(& padapter->eeprompriv.mac_addr));
#line 854
    if ((int )tmp___8) {
#line 856
      eth_random_addr((u8 *)(& padapter->eeprompriv.mac_addr));
    } else {

    }
  }
#line 858
  if (GlobalDebugLevel23A > 3U) {
#line 858
    printk("\016RTL8723AU: bDriverStopped:%d, bSurpriseRemoved:%d, bup:%d, hw_init_completed:%d\n",
           padapter->bDriverStopped, padapter->bSurpriseRemoved, padapter->bup, (int )padapter->hw_init_completed);
  } else {

  }
#line 862
  status = 1;
  free_hal_data: ;
#line 865
  if (status != 1) {
#line 866
    kfree((void const   *)padapter->HalData);
  } else {

  }
  free_wdev: ;
#line 868
  if (status != 1) {
#line 869
    rtw_wdev_unregister(padapter->rtw_wdev);
#line 870
    rtw_wdev_free(padapter->rtw_wdev);
  } else {

  }
  handle_dualmac: ;
#line 873
  if (status != 1) {
#line 874
    rtw_handle_dualmac23a(padapter, 0);
  } else {

  }
  free_adapter: ;
#line 876
  if (status != 1) {
#line 877
    if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 878
      ldv_free_netdev_2281(pnetdev);
    } else {

    }
#line 879
    padapter = (struct rtw_adapter *)0;
  } else {

  }
#line 881
  return (padapter);
}
}
#line 884 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static void rtw_usb_if1_deinit(struct rtw_adapter *if1 ) 
{ 
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  bool tmp ;

  {
#line 886
  pnetdev = if1->pnetdev;
#line 887
  pmlmepriv = & if1->mlmepriv;
#line 889
  tmp = check_fwstate(pmlmepriv, 1);
#line 889
  if ((int )tmp) {
#line 890
    rtw_disassoc_cmd23a(if1, 0U, 0);
  } else {

  }
#line 893
  free_mlme_ap_info23a(if1);
#line 896
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 897
    ldv_unregister_netdev_2282(pnetdev);
  } else {

  }
#line 899
  rtw_cancel_all_timer23a(if1);
#line 901
  rtw_dev_unload(if1);
#line 903
  if (GlobalDebugLevel23A > 3U) {
#line 903
    printk("\016RTL8723AU: +r871xu_dev_remove, hw_init_completed =%d\n", (int )if1->hw_init_completed);
  } else {

  }
#line 906
  rtw_handle_dualmac23a(if1, 0);
#line 908
  if ((unsigned long )if1->rtw_wdev != (unsigned long )((struct wireless_dev *)0)) {
#line 909
    rtw_wdev_unregister(if1->rtw_wdev);
#line 910
    rtw_wdev_free(if1->rtw_wdev);
  } else {

  }
#line 914
  if ((unsigned int )if1->pwrctrlpriv.autopm_cnt == 1U) {
#line 915
    usb_autopm_put_interface((if1->dvobj)->pusbintf);
#line 916
    if1->pwrctrlpriv.autopm_cnt = (u8 )((int )if1->pwrctrlpriv.autopm_cnt - 1);
  } else {

  }
#line 920
  rtw_free_drv_sw23a(if1);
#line 922
  if ((unsigned long )pnetdev != (unsigned long )((struct net_device *)0)) {
#line 923
    ldv_free_netdev_2283(pnetdev);
  } else {

  }
#line 924
  return;
}
}
#line 926 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static int rtw_drv_init(struct usb_interface *pusb_intf , struct usb_device_id  const  *pdid ) 
{ 
  struct rtw_adapter *if1 ;
  struct dvobj_priv *dvobj ;
  int status ;

  {
#line 929
  if1 = (struct rtw_adapter *)0;
#line 931
  status = 0;
#line 933
  if (GlobalDebugLevel23A > 3U) {
#line 933
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 933
    printk("\016+rtw_drv_init\n");
  } else {

  }
#line 936
  dvobj = usb_dvobj_init(pusb_intf);
#line 937
  if ((unsigned long )dvobj == (unsigned long )((struct dvobj_priv *)0)) {
#line 938
    if (GlobalDebugLevel23A > 3U) {
#line 938
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 938
      printk("\016initialize device object priv Failed!\n");
    } else {

    }
#line 940
    goto exit;
  } else {

  }
#line 943
  if1 = rtw_usb_if1_init(dvobj, pusb_intf, pdid);
#line 944
  if ((unsigned long )if1 == (unsigned long )((struct rtw_adapter *)0)) {
#line 945
    if (GlobalDebugLevel23A > 3U) {
#line 945
      printk("\016RTL8723AU: rtw_init_primary_adapter Failed!\n");
    } else {

    }
#line 946
    goto free_dvobj;
  } else {

  }
#line 950
  status = rtw_drv_register_netdev(if1);
#line 951
  if (status != 1) {
#line 952
    goto free_if1;
  } else {

  }
#line 953
  if (GlobalDebugLevel23A > 3U) {
#line 953
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 953
    printk("\016-871x_drv - drv_init, success!\n");
  } else {

  }
#line 956
  status = 1;
  free_if1: ;
#line 959
  if (status != 1 && (unsigned long )if1 != (unsigned long )((struct rtw_adapter *)0)) {
#line 960
    rtw_usb_if1_deinit(if1);
  } else {

  }
  free_dvobj: ;
#line 962
  if (status != 1) {
#line 963
    usb_dvobj_deinit(pusb_intf);
  } else {

  }
  exit: ;
#line 965
  return (status == 1 ? 0 : -19);
}
}
#line 969 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static void rtw_disconnect(struct usb_interface *pusb_intf ) 
{ 
  struct dvobj_priv *dvobj ;
  struct rtw_adapter *padapter ;
  struct net_device *pnetdev ;
  struct mlme_priv *pmlmepriv ;
  void *tmp ;

  {
#line 976
  tmp = usb_get_intfdata(pusb_intf);
#line 976
  dvobj = (struct dvobj_priv *)tmp;
#line 977
  if ((unsigned long )dvobj == (unsigned long )((struct dvobj_priv *)0)) {
#line 978
    return;
  } else {

  }
#line 980
  padapter = dvobj->if1;
#line 981
  pnetdev = padapter->pnetdev;
#line 982
  pmlmepriv = & padapter->mlmepriv;
#line 984
  usb_set_intfdata(pusb_intf, (void *)0);
#line 986
  if (GlobalDebugLevel23A > 3U) {
#line 986
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 986
    printk("\016+dev_remove()\n");
  } else {

  }
#line 988
  rtw_pm_set_ips23a(padapter, 0);
#line 989
  rtw_pm_set_lps23a(padapter, 0);
#line 991
  LeaveAllPowerSaveMode23a(padapter);
#line 993
  rtw_usb_if1_deinit(padapter);
#line 995
  usb_dvobj_deinit(pusb_intf);
#line 997
  if (GlobalDebugLevel23A > 3U) {
#line 997
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 997
    printk("\016-dev_remove()\n");
  } else {

  }
#line 998
  if (GlobalDebugLevel23A > 3U) {
#line 998
    printk("\016RTL8723AU: -r871xu_dev_remove, done\n");
  } else {

  }
#line 1000
  return;
}
}
#line 1003 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static int rtw_drv_entry(void) 
{ 
  int tmp ;

  {
#line 1005
  if (GlobalDebugLevel23A > 3U) {
#line 1005
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 1005
    printk("\016+rtw_drv_entry\n");
  } else {

  }
#line 1006
  tmp = ldv_usb_register_driver_2284(usb_drv, & __this_module, "r8723au");
#line 1006
  return (tmp);
}
}
#line 1009 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
static void rtw_drv_halt(void) 
{ 


  {
#line 1011
  if (GlobalDebugLevel23A > 3U) {
#line 1011
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 1048576U, 4);
#line 1011
    printk("\016+rtw_drv_halt\n");
  } else {

  }
#line 1012
  if (GlobalDebugLevel23A > 3U) {
#line 1012
    printk("\016RTL8723AU: +rtw_drv_halt\n");
  } else {

  }
#line 1014
  ldv_usb_deregister_2285(usb_drv);
#line 1016
  if (GlobalDebugLevel23A > 3U) {
#line 1016
    printk("\016RTL8723AU: -rtw_drv_halt\n");
  } else {

  }
#line 1017
  return;
}
}
#line 1022 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_retval_0  ;
#line 1023 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_retval_1  ;
#line 1024
extern void ldv_initialize(void) ;
#line 1025
extern void ldv_check_final_state(void) ;
#line 1026 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_retval_3  ;
#line 1027 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_retval_2  ;
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_retval_7  ;
#line 1031 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_usb_driver_12(void) 
{ 
  void *tmp ;

  {
#line 1032
  tmp = ldv_zalloc(1560UL);
#line 1032
  rtl8723a_usb_drv_group1 = (struct usb_interface *)tmp;
#line 1033
  return;
}
}
#line 1046 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void main(void) 
{ 
  struct usb_device_id *ldvarg1 ;
  void *tmp ;
  pm_message_t ldvarg0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1049
  tmp = ldv_zalloc(32UL);
#line 1049
  ldvarg1 = (struct usb_device_id *)tmp;
#line 1047
  ldv_initialize();
#line 1050
  memset((void *)(& ldvarg0), 0, 4UL);
#line 1053
  timer_init_6();
#line 1055
  ldv_state_variable_6 = 1;
#line 1057
  timer_init_11();
#line 1059
  ldv_state_variable_11 = 1;
#line 1061
  timer_init_3();
#line 1063
  ldv_state_variable_3 = 1;
#line 1065
  timer_init_7();
#line 1067
  ldv_state_variable_7 = 1;
#line 1069
  timer_init_9();
#line 1071
  ldv_state_variable_9 = 1;
#line 1072
  ldv_state_variable_12 = 0;
#line 1074
  timer_init_2();
#line 1076
  ldv_state_variable_2 = 1;
#line 1077
  ldv_state_variable_15 = 0;
#line 1078
  ldv_state_variable_14 = 0;
#line 1080
  timer_init_8();
#line 1082
  ldv_state_variable_8 = 1;
#line 1084
  timer_init_1();
#line 1086
  ldv_state_variable_1 = 1;
#line 1088
  timer_init_4();
#line 1090
  ldv_state_variable_4 = 1;
#line 1091
  ref_cnt = 0;
#line 1092
  ldv_state_variable_0 = 1;
#line 1093
  ldv_state_variable_13 = 0;
#line 1095
  timer_init_10();
#line 1097
  ldv_state_variable_10 = 1;
#line 1099
  timer_init_5();
#line 1101
  ldv_state_variable_5 = 1;
  ldv_54544: 
#line 1103
  tmp___0 = __VERIFIER_nondet_int();
#line 1103
  switch (tmp___0) {
  case 0: ;
#line 1110
  goto ldv_54515;
  case 1: ;
#line 1117
  goto ldv_54515;
  case 2: ;
#line 1124
  goto ldv_54515;
  case 3: ;
#line 1131
  goto ldv_54515;
  case 4: ;
#line 1138
  goto ldv_54515;
  case 5: ;
#line 1142
  if (ldv_state_variable_12 != 0) {
#line 1143
    tmp___1 = __VERIFIER_nondet_int();
#line 1143
    switch (tmp___1) {
    case 0: ;
#line 1146
    if (ldv_state_variable_12 == 1) {
#line 1148
      ldv_retval_3 = rtw_drv_init(rtl8723a_usb_drv_group1, (struct usb_device_id  const  *)ldvarg1);
#line 1149
      if (ldv_retval_3 == 0) {
#line 1150
        ldv_state_variable_12 = 2;
#line 1151
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 1155
    goto ldv_54522;
    case 1: ;
#line 1158
    if (ldv_state_variable_12 == 2) {
#line 1160
      ldv_retval_2 = rtw_suspend(rtl8723a_usb_drv_group1, ldvarg0);
#line 1161
      if (ldv_retval_2 == 0) {
#line 1162
        ldv_state_variable_12 = 3;
      } else {

      }
    } else {

    }
#line 1166
    goto ldv_54522;
    case 2: ;
#line 1169
    if (ldv_state_variable_12 == 3) {
#line 1171
      ldv_retval_1 = rtw_resume(rtl8723a_usb_drv_group1);
#line 1172
      if (ldv_retval_1 == 0) {
#line 1173
        ldv_state_variable_12 = 2;
      } else {

      }
    } else {

    }
#line 1177
    goto ldv_54522;
    case 3: ;
#line 1180
    if (ldv_state_variable_12 == 3) {
#line 1182
      ldv_retval_0 = rtw_resume(rtl8723a_usb_drv_group1);
#line 1183
      if (ldv_retval_0 == 0) {
#line 1184
        ldv_state_variable_12 = 2;
      } else {

      }
    } else {

    }
#line 1188
    goto ldv_54522;
    case 4: ;
#line 1191
    if (ldv_state_variable_12 == 3 && usb_counter == 0) {
#line 1193
      rtw_disconnect(rtl8723a_usb_drv_group1);
#line 1194
      ldv_state_variable_12 = 1;
#line 1195
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1198
    if (ldv_state_variable_12 == 2 && usb_counter == 0) {
#line 1200
      rtw_disconnect(rtl8723a_usb_drv_group1);
#line 1201
      ldv_state_variable_12 = 1;
#line 1202
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 1205
    goto ldv_54522;
    default: 
#line 1206
    ldv_stop();
    }
    ldv_54522: ;
  } else {

  }
#line 1210
  goto ldv_54515;
  case 6: ;
#line 1217
  goto ldv_54515;
  case 7: ;
#line 1221
  if (ldv_state_variable_15 != 0) {
#line 1222
    ldv_main_exported_15();
  } else {

  }
#line 1225
  goto ldv_54515;
  case 8: ;
#line 1229
  if (ldv_state_variable_14 != 0) {
#line 1230
    ldv_main_exported_14();
  } else {

  }
#line 1233
  goto ldv_54515;
  case 9: ;
#line 1240
  goto ldv_54515;
  case 10: ;
#line 1247
  goto ldv_54515;
  case 11: ;
#line 1254
  goto ldv_54515;
  case 12: ;
#line 1258
  if (ldv_state_variable_0 != 0) {
#line 1259
    tmp___2 = __VERIFIER_nondet_int();
#line 1259
    switch (tmp___2) {
    case 0: ;
#line 1262
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
#line 1264
      rtw_drv_halt();
#line 1265
      ldv_state_variable_0 = 3;
#line 1266
      goto ldv_final;
    } else {

    }
#line 1269
    goto ldv_54537;
    case 1: ;
#line 1272
    if (ldv_state_variable_0 == 1) {
#line 1274
      ldv_retval_7 = rtw_drv_entry();
#line 1275
      if (ldv_retval_7 != 0) {
#line 1276
        ldv_state_variable_0 = 3;
#line 1277
        goto ldv_final;
      } else {

      }
#line 1280
      if (ldv_retval_7 == 0) {
#line 1281
        ldv_state_variable_0 = 2;
#line 1282
        ldv_state_variable_14 = 1;
#line 1283
        ldv_initialize_cfg80211_ops_14();
      } else {

      }
    } else {

    }
#line 1287
    goto ldv_54537;
    default: 
#line 1288
    ldv_stop();
    }
    ldv_54537: ;
  } else {

  }
#line 1292
  goto ldv_54515;
  case 13: ;
#line 1296
  if (ldv_state_variable_13 != 0) {
#line 1297
    ldv_main_exported_13();
  } else {

  }
#line 1300
  goto ldv_54515;
  case 14: ;
#line 1307
  goto ldv_54515;
  case 15: ;
#line 1314
  goto ldv_54515;
  default: 
#line 1315
  ldv_stop();
  }
  ldv_54515: ;
#line 1317
  goto ldv_54544;
  ldv_final: 
#line 1319
  ldv_check_final_state();
#line 1320
  return;
}
}
#line 1450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void *ldv_kmem_cache_alloc_2264(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 1453
  ldv_check_alloc_flags(flags);
#line 1455
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 1456
  return ((void *)0);
}
}
#line 1494 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_pskb_expand_head_2270(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1497
  ldv_check_alloc_flags(flags);
#line 1499
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1499
  return (tmp);
}
}
#line 1510 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct sk_buff *ldv_skb_clone_2272(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1513
  ldv_check_alloc_flags(flags);
#line 1515
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1515
  return (tmp);
}
}
#line 1526 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct sk_buff *ldv_skb_copy_2274(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1529
  ldv_check_alloc_flags(flags);
#line 1531
  tmp = skb_copy(ldv_func_arg1, flags);
#line 1531
  return (tmp);
}
}
#line 1534 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2275(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1537
  ldv_check_alloc_flags(flags);
#line 1539
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1539
  return (tmp);
}
}
#line 1542 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2276(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1545
  ldv_check_alloc_flags(flags);
#line 1547
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1547
  return (tmp);
}
}
#line 1550 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2277(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1553
  ldv_check_alloc_flags(flags);
#line 1555
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 1555
  return (tmp);
}
}
#line 1558 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_pskb_expand_head_2278(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1561
  ldv_check_alloc_flags(flags);
#line 1563
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1563
  return (tmp);
}
}
#line 1566 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_pskb_expand_head_2279(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 1569
  ldv_check_alloc_flags(flags);
#line 1571
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 1571
  return (tmp);
}
}
#line 1574 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
struct sk_buff *ldv_skb_clone_2280(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1577
  ldv_check_alloc_flags(flags);
#line 1579
  tmp = skb_clone(ldv_func_arg1, flags);
#line 1579
  return (tmp);
}
}
#line 1582 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_free_netdev_2281(struct net_device *dev ) 
{ 


  {
#line 1585
  free_netdev(dev);
#line 1587
  ldv_state_variable_15 = 0;
#line 1588
  return;
}
}
#line 1590 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_unregister_netdev_2282(struct net_device *dev ) 
{ 


  {
#line 1593
  unregister_netdev(dev);
#line 1595
  ldv_state_variable_15 = 0;
#line 1596
  return;
}
}
#line 1598 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_free_netdev_2283(struct net_device *dev ) 
{ 


  {
#line 1601
  free_netdev(dev);
#line 1603
  ldv_state_variable_15 = 0;
#line 1604
  return;
}
}
#line 1606 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
int ldv_usb_register_driver_2284(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 1610
  tmp = usb_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1610
  ldv_func_res = tmp;
#line 1612
  ldv_state_variable_12 = 1;
#line 1613
  usb_counter = 0;
#line 1614
  ldv_usb_driver_12();
#line 1617
  return (ldv_func_res);
}
}
#line 1620 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_intf.o.c.prepared"
void ldv_usb_deregister_2285(struct usb_driver *arg ) 
{ 


  {
#line 1623
  usb_deregister(arg);
#line 1625
  ldv_state_variable_12 = 0;
#line 1626
  return;
}
}
#line 372 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2316(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_2324(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2332(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_2326(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_2322(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2330(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2331(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2327(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2328(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2329(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 1588 "include/linux/usb.h"
int ldv_usb_submit_urb_2333(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1591
extern void usb_kill_urb(struct urb * ) ;
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
void rtl8723au_read_port_cancel(struct rtw_adapter *padapter ) 
{ 
  struct recv_buf *precvbuf ;
  int i ;

  {
#line 251
  precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
#line 253
  if (GlobalDebugLevel23A > 3U) {
#line 253
    printk("\016RTL8723AU: %s\n", "rtl8723au_read_port_cancel");
  } else {

  }
#line 255
  padapter->bReadPortCancel = 1U;
#line 257
  i = 0;
#line 257
  goto ldv_54261;
  ldv_54260: ;
#line 258
  if ((unsigned long )precvbuf->purb != (unsigned long )((struct urb *)0)) {
#line 259
    usb_kill_urb(precvbuf->purb);
  } else {

  }
#line 260
  precvbuf = precvbuf + 1;
#line 257
  i = i + 1;
  ldv_54261: ;
#line 257
  if (i <= 3) {
#line 259
    goto ldv_54260;
  } else {

  }
#line 262
  usb_kill_urb(padapter->recvpriv.int_in_urb);
#line 263
  return;
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
static void usb_write_port23a_complete(struct urb *purb ) 
{ 
  struct xmit_buf *pxmitbuf ;
  struct rtw_adapter *padapter ;
  struct xmit_priv *pxmitpriv ;
  struct hal_data_8723a *phaldata ;
  unsigned long irqL ;

  {
#line 267
  pxmitbuf = (struct xmit_buf *)purb->context;
#line 268
  padapter = pxmitbuf->padapter;
#line 269
  pxmitpriv = & padapter->xmitpriv;
#line 273
  switch ((int )pxmitbuf->flags) {
  case 0: 
#line 275
  pxmitpriv->voq_cnt = pxmitpriv->voq_cnt - 1;
#line 276
  goto ldv_54272;
  case 1: 
#line 278
  pxmitpriv->viq_cnt = pxmitpriv->viq_cnt - 1;
#line 279
  goto ldv_54272;
  case 2: 
#line 281
  pxmitpriv->beq_cnt = pxmitpriv->beq_cnt - 1;
#line 282
  goto ldv_54272;
  case 3: 
#line 284
  pxmitpriv->bkq_cnt = pxmitpriv->bkq_cnt - 1;
#line 285
  goto ldv_54272;
  case 6: 
#line 288
  rtw_chk_hi_queue_cmd23a(padapter);
#line 290
  goto ldv_54272;
  default: ;
#line 292
  goto ldv_54272;
  }
  ldv_54272: ;
#line 295
  if ((padapter->bSurpriseRemoved != 0 || padapter->bDriverStopped != 0) || (unsigned int )padapter->bWritePortCancel != 0U) {
#line 297
    if (GlobalDebugLevel23A > 3U) {
#line 297
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 297
      printk("\016usb_write_port23a_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
             padapter->bDriverStopped, padapter->bSurpriseRemoved);
    } else {

    }
#line 301
    if (GlobalDebugLevel23A > 3U) {
#line 301
      printk("\016RTL8723AU: %s(): TX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bWritePortCancel(%d) pxmitbuf->ext_tag(%x)\n",
             "usb_write_port23a_complete", padapter->bDriverStopped, padapter->bSurpriseRemoved,
             (int )padapter->bReadPortCancel, (int )pxmitbuf->ext_tag);
    } else {

    }
#line 307
    goto check_completion;
  } else {

  }
#line 310
  if (purb->status != 0) {
#line 311
    if (GlobalDebugLevel23A > 3U) {
#line 311
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 311
      printk("\016usb_write_port23a_complete : purb->status(%d) != 0\n", purb->status);
    } else {

    }
#line 314
    if (GlobalDebugLevel23A > 3U) {
#line 314
      printk("\016RTL8723AU: ###=> urb_write_port_complete status(%d)\n", purb->status);
    } else {

    }
#line 316
    if (purb->status == -32 || purb->status == -71) {
#line 317
      sreset_set_wifi_error_status23a(padapter, 4U);
    } else
#line 319
    if (purb->status == -115) {
#line 320
      if (GlobalDebugLevel23A > 3U) {
#line 320
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 320
        printk("\016usb_write_port23a_complete: EINPROGESS\n");
      } else {

      }
#line 322
      goto check_completion;
    } else
#line 323
    if (purb->status == -2) {
#line 324
      if (GlobalDebugLevel23A > 3U) {
#line 324
        printk("\016RTL8723AU: %s: -ENOENT\n", "usb_write_port23a_complete");
      } else {

      }
#line 325
      goto check_completion;
    } else
#line 326
    if (purb->status == -104) {
#line 327
      if (GlobalDebugLevel23A > 3U) {
#line 327
        printk("\016RTL8723AU: %s: -ECONNRESET\n", "usb_write_port23a_complete");
      } else {

      }
#line 328
      goto check_completion;
    } else
#line 329
    if (purb->status == -108) {
#line 330
      if (GlobalDebugLevel23A > 3U) {
#line 330
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 330
        printk("\016usb_write_port23a_complete: ESHUTDOWN\n");
      } else {

      }
#line 332
      padapter->bDriverStopped = 1;
#line 333
      if (GlobalDebugLevel23A > 3U) {
#line 333
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 333
        printk("\016usb_write_port23a_complete:bDriverStopped = true\n");
      } else {

      }
#line 336
      goto check_completion;
    } else {
#line 338
      padapter->bSurpriseRemoved = 1;
#line 339
      if (GlobalDebugLevel23A > 3U) {
#line 339
        printk("\016RTL8723AU: bSurpriseRemoved = true\n");
      } else {

      }
#line 340
      if (GlobalDebugLevel23A > 3U) {
#line 340
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 340
        printk("\016usb_write_port23a_complete:bSurpriseRemoved = true\n");
      } else {

      }
#line 343
      goto check_completion;
    }
  } else {

  }
#line 346
  phaldata = (struct hal_data_8723a *)padapter->HalData;
#line 347
  phaldata->srestpriv.last_tx_complete_time = jiffies;
  check_completion: 
#line 350
  ldv_spin_lock();
#line 351
  rtw23a_sctx_done_err(& pxmitbuf->sctx, purb->status != 0 ? 5 : 0);
#line 354
  spin_unlock_irqrestore(& pxmitpriv->lock_sctx, irqL);
#line 356
  rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
#line 358
  tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
#line 359
  return;
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
int rtl8723au_write_port(struct rtw_adapter *padapter , u32 addr , u32 cnt , struct xmit_buf *pxmitbuf ) 
{ 
  struct urb *purb ;
  struct dvobj_priv *pdvobj ;
  struct xmit_priv *pxmitpriv ;
  struct xmit_frame *pxmitframe ;
  struct usb_device *pusbd ;
  unsigned long irqL ;
  unsigned int pipe ;
  unsigned int ep_num ;
  int status ;
  int ret ;
  unsigned int tmp ;
  struct hal_data_8723a *phaldata ;

  {
#line 364
  purb = (struct urb *)0;
#line 365
  pdvobj = padapter->dvobj;
#line 366
  pxmitpriv = & padapter->xmitpriv;
#line 368
  pusbd = pdvobj->pusbdev;
#line 372
  ret = 0;
#line 374
  if (GlobalDebugLevel23A > 3U) {
#line 374
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 374
    printk("\016+usb_write_port23a\n");
  } else {

  }
#line 376
  if ((padapter->bDriverStopped != 0 || padapter->bSurpriseRemoved != 0) || (unsigned int )padapter->pwrctrlpriv.pnp_bstop_trx != 0U) {
#line 378
    if (GlobalDebugLevel23A > 3U) {
#line 378
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 378
      printk("\016usb_write_port23a:( padapter->bDriverStopped || padapter->bSurpriseRemoved || adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n");
    } else {

    }
#line 382
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 7);
#line 383
    goto exit;
  } else {

  }
#line 386
  pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
#line 387
  ldv_spin_lock();
#line 389
  switch (addr) {
  case 0U: 
#line 391
  pxmitpriv->voq_cnt = pxmitpriv->voq_cnt + 1;
#line 392
  pxmitbuf->flags = 0U;
#line 393
  goto ldv_54298;
  case 1U: 
#line 395
  pxmitpriv->viq_cnt = pxmitpriv->viq_cnt + 1;
#line 396
  pxmitbuf->flags = 1U;
#line 397
  goto ldv_54298;
  case 2U: 
#line 399
  pxmitpriv->beq_cnt = pxmitpriv->beq_cnt + 1;
#line 400
  pxmitbuf->flags = 2U;
#line 401
  goto ldv_54298;
  case 3U: 
#line 403
  pxmitpriv->bkq_cnt = pxmitpriv->bkq_cnt + 1;
#line 404
  pxmitbuf->flags = 3U;
#line 405
  goto ldv_54298;
  case 6U: 
#line 407
  pxmitbuf->flags = 6U;
#line 408
  goto ldv_54298;
  default: 
#line 410
  pxmitbuf->flags = 5U;
#line 411
  goto ldv_54298;
  }
  ldv_54298: 
#line 414
  spin_unlock_irqrestore(& pxmitpriv->lock, irqL);
#line 416
  purb = pxmitbuf->pxmit_urb[0];
#line 419
  ep_num = (unsigned int )pdvobj->Queue2Pipe[addr];
#line 420
  tmp = __create_pipe(pusbd, ep_num);
#line 420
  pipe = tmp | 3221225472U;
#line 422
  usb_fill_bulk_urb(purb, pusbd, pipe, (void *)pxmitframe->buf_addr, (int )cnt, & usb_write_port23a_complete,
                    (void *)pxmitbuf);
#line 427
  status = ldv_usb_submit_urb_2333(purb, 32U);
#line 428
  if (status == 0) {
#line 429
    phaldata = (struct hal_data_8723a *)padapter->HalData;
#line 430
    phaldata->srestpriv.last_tx_time = jiffies;
  } else {
#line 432
    rtw23a_sctx_done_err(& pxmitbuf->sctx, 5);
#line 434
    if (GlobalDebugLevel23A > 3U) {
#line 434
      printk("\016RTL8723AU: usb_write_port23a, status =%d\n", status);
    } else {

    }
#line 435
    if (GlobalDebugLevel23A > 3U) {
#line 435
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 435
      printk("\016usb_write_port23a(): usb_submit_urb, status =%x\n", status);
    } else {

    }
#line 439
    switch (status) {
    case -19: 
#line 441
    padapter->bDriverStopped = 1;
#line 442
    goto ldv_54306;
    default: ;
#line 444
    goto ldv_54306;
    }
    ldv_54306: ;
#line 446
    goto exit;
  }
#line 448
  ret = 1;
#line 449
  if (GlobalDebugLevel23A > 3U) {
#line 449
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16777216U, 4);
#line 449
    printk("\016-usb_write_port23a\n");
  } else {

  }
  exit: ;
#line 452
  if (ret != 1) {
#line 453
    rtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);
  } else {

  }
#line 455
  return (ret);
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
void rtl8723au_write_port_cancel(struct rtw_adapter *padapter ) 
{ 
  struct xmit_buf *pxmitbuf ;
  struct list_head *plist ;
  int j ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 464
  if (GlobalDebugLevel23A > 3U) {
#line 464
    printk("\016RTL8723AU: %s\n", "rtl8723au_write_port_cancel");
  } else {

  }
#line 466
  padapter->bWritePortCancel = 1U;
#line 468
  plist = padapter->xmitpriv.xmitbuf_list.next;
#line 468
  goto ldv_54321;
  ldv_54320: 
#line 469
  __mptr = (struct list_head  const  *)plist;
#line 469
  pxmitbuf = (struct xmit_buf *)__mptr + 0xfffffffffffffff0UL;
#line 470
  j = 0;
#line 470
  goto ldv_54318;
  ldv_54317: ;
#line 471
  if ((unsigned long )pxmitbuf->pxmit_urb[j] != (unsigned long )((struct urb *)0)) {
#line 472
    usb_kill_urb(pxmitbuf->pxmit_urb[j]);
  } else {

  }
#line 470
  j = j + 1;
  ldv_54318: ;
#line 470
  if (j <= 7) {
#line 472
    goto ldv_54317;
  } else {

  }
#line 468
  plist = plist->next;
  ldv_54321: ;
#line 468
  if ((unsigned long )(& padapter->xmitpriv.xmitbuf_list) != (unsigned long )plist) {
#line 470
    goto ldv_54320;
  } else {

  }
#line 475
  plist = padapter->xmitpriv.xmitextbuf_list.next;
#line 475
  goto ldv_54329;
  ldv_54328: 
#line 476
  __mptr___0 = (struct list_head  const  *)plist;
#line 476
  pxmitbuf = (struct xmit_buf *)__mptr___0 + 0xfffffffffffffff0UL;
#line 477
  j = 0;
#line 477
  goto ldv_54326;
  ldv_54325: ;
#line 478
  if ((unsigned long )pxmitbuf->pxmit_urb[j] != (unsigned long )((struct urb *)0)) {
#line 479
    usb_kill_urb(pxmitbuf->pxmit_urb[j]);
  } else {

  }
#line 477
  j = j + 1;
  ldv_54326: ;
#line 477
  if (j <= 7) {
#line 479
    goto ldv_54325;
  } else {

  }
#line 475
  plist = plist->next;
  ldv_54329: ;
#line 475
  if ((unsigned long )(& padapter->xmitpriv.xmitextbuf_list) != (unsigned long )plist) {
#line 477
    goto ldv_54328;
  } else {

  }

#line 482
  return;
}
}
#line 611 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
void *ldv_kmem_cache_alloc_2316(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 614
  ldv_check_alloc_flags(flags);
#line 616
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 617
  return ((void *)0);
}
}
#line 655 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
int ldv_pskb_expand_head_2322(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 658
  ldv_check_alloc_flags(flags);
#line 660
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 660
  return (tmp);
}
}
#line 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2324(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 674
  ldv_check_alloc_flags(flags);
#line 676
  tmp = skb_clone(ldv_func_arg1, flags);
#line 676
  return (tmp);
}
}
#line 687 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv_skb_copy_2326(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 690
  ldv_check_alloc_flags(flags);
#line 692
  tmp = skb_copy(ldv_func_arg1, flags);
#line 692
  return (tmp);
}
}
#line 695 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2327(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 698
  ldv_check_alloc_flags(flags);
#line 700
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 700
  return (tmp);
}
}
#line 703 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2328(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 706
  ldv_check_alloc_flags(flags);
#line 708
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 708
  return (tmp);
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2329(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 714
  ldv_check_alloc_flags(flags);
#line 716
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 716
  return (tmp);
}
}
#line 719 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
int ldv_pskb_expand_head_2330(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 722
  ldv_check_alloc_flags(flags);
#line 724
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 724
  return (tmp);
}
}
#line 727 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
int ldv_pskb_expand_head_2331(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 730
  ldv_check_alloc_flags(flags);
#line 732
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 732
  return (tmp);
}
}
#line 735 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2332(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 738
  ldv_check_alloc_flags(flags);
#line 740
  tmp = skb_clone(ldv_func_arg1, flags);
#line 740
  return (tmp);
}
}
#line 743 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/usb_ops_linux.o.c.prepared"
int ldv_usb_submit_urb_2333(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 746
  ldv_check_alloc_flags(flags);
#line 748
  tmp = usb_submit_urb(ldv_func_arg1, flags);
#line 748
  return (tmp);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2360(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 641
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_2368(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2376(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_2370(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_2366(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2374(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2375(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2371(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2372(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2373(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2983 "include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff  const  *skb ) 
{ 


  {
#line 2985
  return ((u16 )skb->queue_mapping);
}
}
#line 2431 "include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2433
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2433
  txq = tmp;
#line 2434
  netif_tx_stop_queue(txq);
#line 2435
  return;
}
}
#line 2444 "include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device  const  *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
#line 2447
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
#line 2447
  txq = tmp;
#line 2449
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)txq);
#line 2449
  return (tmp___0);
}
}
#line 2465 "include/linux/netdevice.h"
__inline static void netif_wake_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  int tmp___0 ;

  {
#line 2467
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2467
  txq = tmp;
#line 2468
  tmp___0 = test_and_clear_bit(0L, (unsigned long volatile   *)(& txq->state));
#line 2468
  if (tmp___0 != 0) {
#line 2469
    __netif_schedule(txq->qdisc);
  } else {

  }
#line 2470
  return;
}
}
#line 1584 "include/linux/usb.h"
struct urb *ldv_usb_alloc_urb_2377(int ldv_func_arg1 , gfp_t flags ) ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
int rtw_os_xmit_resource_alloc23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ,
                                  u32 alloc_sz ) 
{ 
  int i ;
  void *tmp ;

  {
#line 250
  tmp = kzalloc((size_t )alloc_sz, 208U);
#line 250
  pxmitbuf->pallocated_buf = (u8 *)tmp;
#line 251
  if ((unsigned long )pxmitbuf->pallocated_buf == (unsigned long )((u8 *)0U)) {
#line 252
    return (0);
  } else {

  }
#line 254
  pxmitbuf->pbuf = (u8 *)(((unsigned long )pxmitbuf->pallocated_buf + 511UL) & 0xfffffffffffffe00UL);
#line 256
  i = 0;
#line 256
  goto ldv_51420;
  ldv_51419: 
#line 257
  pxmitbuf->pxmit_urb[i] = ldv_usb_alloc_urb_2377(0, 208U);
#line 258
  if ((unsigned long )pxmitbuf->pxmit_urb[i] == (unsigned long )((struct urb *)0)) {
#line 259
    if (GlobalDebugLevel23A > 3U) {
#line 259
      printk("\016RTL8723AU: pxmitbuf->pxmit_urb[i]==NULL");
    } else {

    }
#line 260
    return (0);
  } else {

  }
#line 256
  i = i + 1;
  ldv_51420: ;
#line 256
  if (i <= 7) {
#line 258
    goto ldv_51419;
  } else {

  }

#line 263
  return (1);
}
}
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
void rtw_os_xmit_resource_free23a(struct rtw_adapter *padapter , struct xmit_buf *pxmitbuf ) 
{ 
  int i ;

  {
#line 271
  i = 0;
#line 271
  goto ldv_51428;
  ldv_51427: 
#line 272
  usb_free_urb(pxmitbuf->pxmit_urb[i]);
#line 271
  i = i + 1;
  ldv_51428: ;
#line 271
  if (i <= 7) {
#line 273
    goto ldv_51427;
  } else {

  }
#line 273
  kfree((void const   *)pxmitbuf->pallocated_buf);
#line 274
  return;
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
void rtw_os_pkt_complete23a(struct rtw_adapter *padapter , struct sk_buff *pkt ) 
{ 
  struct xmit_priv *pxmitpriv ;
  u16 queue ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 280
  pxmitpriv = & padapter->xmitpriv;
#line 283
  queue = skb_get_queue_mapping((struct sk_buff  const  *)pkt);
#line 284
  if ((unsigned int )padapter->registrypriv.wifi_spec != 0U) {
#line 285
    tmp = __netif_subqueue_stopped((struct net_device  const  *)padapter->pnetdev,
                                   (int )queue);
#line 285
    if ((int )tmp && (pxmitpriv->hwxmits + (unsigned long )queue)->accnt <= 101) {
#line 287
      netif_wake_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  } else {
#line 289
    tmp___0 = __netif_subqueue_stopped((struct net_device  const  *)padapter->pnetdev,
                                       (int )queue);
#line 289
    if ((int )tmp___0) {
#line 290
      netif_wake_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  }
#line 292
  dev_kfree_skb_any(pkt);
#line 293
  return;
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
void rtw_os_xmit_complete23a(struct rtw_adapter *padapter , struct xmit_frame *pxframe ) 
{ 


  {
#line 298
  if ((unsigned long )pxframe->pkt != (unsigned long )((struct sk_buff *)0)) {
#line 299
    rtw_os_pkt_complete23a(padapter, pxframe->pkt);
  } else {

  }
#line 301
  pxframe->pkt = (struct sk_buff *)0;
#line 302
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
void rtw_os_xmit_schedule23a(struct rtw_adapter *padapter ) 
{ 
  struct xmit_priv *pxmitpriv ;
  s32 tmp ;

  {
#line 308
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 309
    return;
  } else {

  }
#line 310
  pxmitpriv = & padapter->xmitpriv;
#line 312
  spin_lock_bh(& pxmitpriv->lock);
#line 314
  tmp = rtw_txframes_pending23a(padapter);
#line 314
  if (tmp != 0) {
#line 315
    tasklet_hi_schedule(& pxmitpriv->xmit_tasklet);
  } else {

  }
#line 316
  spin_unlock_bh(& pxmitpriv->lock);
#line 317
  return;
}
}
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
static void rtw_check_xmit_resource(struct rtw_adapter *padapter , struct sk_buff *pkt ) 
{ 
  struct xmit_priv *pxmitpriv ;
  u16 queue ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 322
  pxmitpriv = & padapter->xmitpriv;
#line 325
  queue = skb_get_queue_mapping((struct sk_buff  const  *)pkt);
#line 326
  if ((unsigned int )padapter->registrypriv.wifi_spec != 0U) {
#line 328
    if ((pxmitpriv->hwxmits + (unsigned long )queue)->accnt > 102) {
#line 329
      netif_stop_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  } else
#line 331
  if (pxmitpriv->free_xmitframe_cnt <= 4) {
#line 332
    tmp = netdev_get_tx_queue((struct net_device  const  *)padapter->pnetdev, (unsigned int )queue);
#line 332
    tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)tmp);
#line 332
    if (tmp___0) {
#line 332
      tmp___1 = 0;
    } else {
#line 332
      tmp___1 = 1;
    }
#line 332
    if (tmp___1) {
#line 333
      netif_stop_subqueue(padapter->pnetdev, (int )queue);
    } else {

    }
  } else {

  }
#line 334
  return;
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
int rtw_xmit23a_entry23a(struct sk_buff *skb , struct net_device *pnetdev ) 
{ 
  struct rtw_adapter *padapter ;
  void *tmp ;
  struct xmit_priv *pxmitpriv ;
  int res ;
  int tmp___0 ;

  {
#line 340
  tmp = netdev_priv((struct net_device  const  *)pnetdev);
#line 340
  padapter = (struct rtw_adapter *)tmp;
#line 341
  pxmitpriv = & padapter->xmitpriv;
#line 342
  res = 0;
#line 344
  if (GlobalDebugLevel23A > 6U) {
#line 344
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16U, 7);
#line 344
    printk("\016+xmit_enry\n");
  } else {

  }
#line 346
  tmp___0 = rtw_if_up23a(padapter);
#line 346
  if (tmp___0 == 0) {
#line 347
    if (GlobalDebugLevel23A > 3U) {
#line 347
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 4);
#line 347
      printk("\016rtw_xmit23a_entry23a: rtw_if_up23a fail\n");
    } else {

    }
#line 349
    goto drop_packet;
  } else {

  }
#line 352
  rtw_check_xmit_resource(padapter, skb);
#line 354
  res = rtw_xmit23a(padapter, skb);
#line 355
  if (res < 0) {
#line 356
    goto drop_packet;
  } else {

  }
#line 358
  pxmitpriv->tx_pkts = pxmitpriv->tx_pkts + 1ULL;
#line 359
  if (GlobalDebugLevel23A > 6U) {
#line 359
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 7);
#line 359
    printk("\016rtw_xmit23a_entry23a: tx_pkts=%d\n", (unsigned int )pxmitpriv->tx_pkts);
  } else {

  }
#line 362
  goto exit;
  drop_packet: 
#line 365
  pxmitpriv->tx_drop = pxmitpriv->tx_drop + 1ULL;
#line 366
  dev_kfree_skb_any(skb);
#line 367
  if (GlobalDebugLevel23A > 5U) {
#line 367
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 2U, 6);
#line 367
    printk("\016rtw_xmit23a_entry23a: drop, tx_drop=%d\n", (unsigned int )pxmitpriv->tx_drop);
  } else {

  }
  exit: ;
#line 371
  return (0);
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
void *ldv_kmem_cache_alloc_2360(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 504
  ldv_check_alloc_flags(flags);
#line 506
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 507
  return ((void *)0);
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
int ldv_pskb_expand_head_2366(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 548
  ldv_check_alloc_flags(flags);
#line 550
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 550
  return (tmp);
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2368(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 564
  ldv_check_alloc_flags(flags);
#line 566
  tmp = skb_clone(ldv_func_arg1, flags);
#line 566
  return (tmp);
}
}
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
struct sk_buff *ldv_skb_copy_2370(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 580
  ldv_check_alloc_flags(flags);
#line 582
  tmp = skb_copy(ldv_func_arg1, flags);
#line 582
  return (tmp);
}
}
#line 585 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2371(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 588
  ldv_check_alloc_flags(flags);
#line 590
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 590
  return (tmp);
}
}
#line 593 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2372(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 596
  ldv_check_alloc_flags(flags);
#line 598
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 598
  return (tmp);
}
}
#line 601 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2373(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 604
  ldv_check_alloc_flags(flags);
#line 606
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 606
  return (tmp);
}
}
#line 609 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
int ldv_pskb_expand_head_2374(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 612
  ldv_check_alloc_flags(flags);
#line 614
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 614
  return (tmp);
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
int ldv_pskb_expand_head_2375(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 620
  ldv_check_alloc_flags(flags);
#line 622
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 622
  return (tmp);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
struct sk_buff *ldv_skb_clone_2376(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 628
  ldv_check_alloc_flags(flags);
#line 630
  tmp = skb_clone(ldv_func_arg1, flags);
#line 630
  return (tmp);
}
}
#line 633 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/os_dep/xmit_linux.o.c.prepared"
struct urb *ldv_usb_alloc_urb_2377(int ldv_func_arg1 , gfp_t flags ) 
{ 
  struct urb *tmp ;

  {
#line 636
  ldv_check_alloc_flags(flags);
#line 638
  tmp = usb_alloc_urb(ldv_func_arg1, flags);
#line 638
  return (tmp);
}
}
#line 179 "include/linux/timer.h"
int ldv_mod_timer_2421(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 183
int ldv_mod_timer_2426(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 187
int ldv_mod_timer_2428(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 191
int ldv_mod_timer_2436(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 248
int ldv_del_timer_sync_2422(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_2423(struct timer_list *ldv_func_arg1 ) ;
#line 256
int ldv_del_timer_sync_2424(struct timer_list *ldv_func_arg1 ) ;
#line 260
int ldv_del_timer_sync_2425(struct timer_list *ldv_func_arg1 ) ;
#line 264
int ldv_del_timer_sync_2427(struct timer_list *ldv_func_arg1 ) ;
#line 268
int ldv_del_timer_sync_2429(struct timer_list *ldv_func_arg1 ) ;
#line 272
int ldv_del_timer_sync_2430(struct timer_list *ldv_func_arg1 ) ;
#line 276
int ldv_del_timer_sync_2431(struct timer_list *ldv_func_arg1 ) ;
#line 280
int ldv_del_timer_sync_2432(struct timer_list *ldv_func_arg1 ) ;
#line 284
int ldv_del_timer_sync_2433(struct timer_list *ldv_func_arg1 ) ;
#line 288
int ldv_del_timer_sync_2434(struct timer_list *ldv_func_arg1 ) ;
#line 292
int ldv_del_timer_sync_2435(struct timer_list *ldv_func_arg1 ) ;
#line 296
int ldv_del_timer_sync_2437(struct timer_list *ldv_func_arg1 ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2404(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_2412(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2420(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_2414(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_2410(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2418(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2419(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2415(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2416(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2417(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 32 "drivers/staging/rtl8723au/include/rtl8723a_bt-coexist.h"
void BT_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
#line 1095
void BTHCI_EventParse(struct rtw_adapter *padapter , void *pEvntData , u32 dataLen ) ;
#line 1097
u8 BTHCI_HsConnectionEstablished(struct rtw_adapter *padapter ) ;
#line 1098
void BTHCI_UpdateBTProfileRTKToMoto(struct rtw_adapter *padapter ) ;
#line 1099
void BTHCI_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) ;
#line 1100
void BTHCI_StateMachine(struct rtw_adapter *padapter , u8 StateToEnter , enum hci_state_with_cmd StateCmd ,
                        u8 EntryNum ) ;
#line 1101
void BTHCI_DisconnectPeer(struct rtw_adapter *padapter , u8 EntryNum ) ;
#line 1102
void BTHCI_EventNumOfCompletedDataBlocks(struct rtw_adapter *padapter ) ;
#line 1103
void BTHCI_EventAMPStatusChange(struct rtw_adapter *padapter , u8 AMP_Status ) ;
#line 1104
void BTHCI_DisconnectAll(struct rtw_adapter *padapter ) ;
#line 1105
enum hci_status BTHCI_HandleHCICMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) ;
#line 1160
void BTDM_1AntSignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
#line 1161
void BTDM_1AntForDhcp(struct rtw_adapter *padapter ) ;
#line 1162
void BTDM_1AntBtCoexist8723A(struct rtw_adapter *padapter ) ;
#line 1244
void BTDM_2AntBtCoexist8723A(struct rtw_adapter *padapter ) ;
#line 1313
void BTDM_SetFwChnlInfo(struct rtw_adapter *padapter , enum rt_media_status mstatus ) ;
#line 1314
u8 BTDM_IsWifiConnectionExist(struct rtw_adapter *padapter ) ;
#line 1315
void BTDM_SetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 , u8 byte3 ,
                  u8 byte4 , u8 byte5 ) ;
#line 1316
void BTDM_QueryBtInformation(struct rtw_adapter *padapter ) ;
#line 1317
void BTDM_SetSwRfRxLpfCorner(struct rtw_adapter *padapter , u8 type ) ;
#line 1318
void BTDM_SetSwPenaltyTxRateAdaptive(struct rtw_adapter *padapter , u8 raType ) ;
#line 1319
void BTDM_SetFwDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) ;
#line 1320
u8 BTDM_BtProfileSupport(struct rtw_adapter *padapter ) ;
#line 1343
void BTDM_SingleAnt(struct rtw_adapter *padapter , u8 bSingleAntOn , u8 bInterruptOn ,
                    u8 bMultiNAVOn ) ;
#line 1344
void BTDM_CheckBTIdleChange1Ant(struct rtw_adapter *padapter ) ;
#line 1364
void BTDM_DiminishWiFi(struct rtw_adapter *padapter , u8 bDACOn , u8 bInterruptOn ,
                       u8 DACSwingLevel , u8 bNAVOn ) ;
#line 1537
void BTDM_CheckAntSelMode(struct rtw_adapter *padapter ) ;
#line 1538
void BTDM_FwC2hBtRssi(struct rtw_adapter *padapter , u8 *tmpBuf ) ;
#line 1540
void BTDM_DisplayBtCoexInfo(struct rtw_adapter *padapter ) ;
#line 1542
void BTDM_RejectAPAggregatedPacket(struct rtw_adapter *padapter , u8 bReject ) ;
#line 1543
u8 BTDM_IsHT40(struct rtw_adapter *padapter ) ;
#line 1544
u8 BTDM_Legacy(struct rtw_adapter *padapter ) ;
#line 1545
void BTDM_CheckWiFiState(struct rtw_adapter *padapter ) ;
#line 1546
s32 BTDM_GetRxSS(struct rtw_adapter *padapter ) ;
#line 1547
u8 BTDM_CheckCoexBcnRssiState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                              u8 RssiThresh1 ) ;
#line 1548
u8 BTDM_CheckCoexRSSIState1(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                            u8 RssiThresh1 ) ;
#line 1549
u8 BTDM_CheckCoexRSSIState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                           u8 RssiThresh1 ) ;
#line 1550
void BTDM_Balance(struct rtw_adapter *padapter , u8 bBalanceOn , u8 ms0 , u8 ms1 ) ;
#line 1551
void BTDM_AGCTable(struct rtw_adapter *padapter , u8 type ) ;
#line 1552
void BTDM_BBBackOffLevel(struct rtw_adapter *padapter , u8 type ) ;
#line 1553
void BTDM_FWCoexAllOff(struct rtw_adapter *padapter ) ;
#line 1554
void BTDM_SWCoexAllOff(struct rtw_adapter *padapter ) ;
#line 1555
void BTDM_HWCoexAllOff(struct rtw_adapter *padapter ) ;
#line 1556
void BTDM_CoexAllOff(struct rtw_adapter *padapter ) ;
#line 1558
void BTDM_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) ;
#line 1559
void BTDM_UpdateCoexState(struct rtw_adapter *padapter ) ;
#line 1560
u8 BTDM_IsSameCoexistState(struct rtw_adapter *padapter ) ;
#line 1561
void BTDM_PWDBMonitor(struct rtw_adapter *padapter ) ;
#line 1562
u8 BTDM_IsBTBusy(struct rtw_adapter *padapter ) ;
#line 1564
u8 BTDM_IsWifiBusy(struct rtw_adapter *padapter ) ;
#line 1565
u8 BTDM_IsCoexistStateChanged(struct rtw_adapter *padapter ) ;
#line 1566
u8 BTDM_IsWifiUplink(struct rtw_adapter *padapter ) ;
#line 1567
u8 BTDM_IsWifiDownlink(struct rtw_adapter *padapter ) ;
#line 1568
u8 BTDM_IsBTHSMode(struct rtw_adapter *padapter ) ;
#line 1569
u8 BTDM_IsBTUplink(struct rtw_adapter *padapter ) ;
#line 1570
u8 BTDM_IsBTDownlink(struct rtw_adapter *padapter ) ;
#line 1571
void BTDM_AdjustForBtOperation(struct rtw_adapter *padapter ) ;
#line 1572
void BTDM_ForHalt(struct rtw_adapter *padapter ) ;
#line 1573
void BTDM_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) ;
#line 1574
void BTDM_WifiAssociateNotify(struct rtw_adapter *padapter , u8 action ) ;
#line 1577
void BTDM_ResetActionProfileState(struct rtw_adapter *padapter ) ;
#line 1578
void BTDM_SetBtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) ;
#line 1580
u8 BTDM_IsActionSCO(struct rtw_adapter *padapter ) ;
#line 1581
u8 BTDM_IsActionHID(struct rtw_adapter *padapter ) ;
#line 1582
u8 BTDM_IsActionA2DP(struct rtw_adapter *padapter ) ;
#line 1583
u8 BTDM_IsActionPAN(struct rtw_adapter *padapter ) ;
#line 1584
u8 BTDM_IsActionHIDA2DP(struct rtw_adapter *padapter ) ;
#line 1585
u8 BTDM_IsActionHIDPAN(struct rtw_adapter *padapter ) ;
#line 1586
u8 BTDM_IsActionPANA2DP(struct rtw_adapter *padapter ) ;
#line 1587
u32 BTDM_BtTxRxCounterH(struct rtw_adapter *padapter ) ;
#line 1588
u32 BTDM_BtTxRxCounterL(struct rtw_adapter *padapter ) ;
#line 1596
u8 HALBT_GetPGAntNum(struct rtw_adapter *padapter ) ;
#line 1598
void HALBT_SetKey(struct rtw_adapter *padapter , u8 EntryNum ) ;
#line 1599
void HALBT_RemoveKey(struct rtw_adapter *padapter , u8 EntryNum ) ;
#line 1602
u8 HALBT_BTChipType(struct rtw_adapter *padapter ) ;
#line 1603
void HALBT_SetRtsCtsNoLenLimit(struct rtw_adapter *padapter ) ;
#line 1610
u32 BTCoexDbgLevel ;
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u32 BTCoexDbgLevel  =    0U;
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 BT_Operation(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 323
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 324
  pBtMgnt = & pBTInfo->BtMgnt;
#line 326
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
#line 327
    return (1U);
  } else {
#line 329
    return (0U);
  }
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 BT_IsLegalChannel(struct rtw_adapter *padapter , u8 channel ) 
{ 
  struct rt_channel_info *pChanneList ;
  u8 channelLen ;
  u8 i ;

  {
#line 334
  pChanneList = (struct rt_channel_info *)0;
#line 337
  pChanneList = (struct rt_channel_info *)(& padapter->mlmeextpriv.channel_set);
#line 338
  channelLen = padapter->mlmeextpriv.max_chan_nums;
#line 340
  i = 0U;
#line 340
  goto ldv_54357;
  ldv_54356: ;
#line 341
  if (BTCoexDbgLevel == 1U) {
#line 341
    printk("Check if chnl(%d) in channel plan contains bt target chnl(%d) for BT connection\n",
           (int )(pChanneList + (unsigned long )i)->ChannelNum, (int )channel);
  } else {

  }
#line 344
  if ((int )(pChanneList + (unsigned long )i)->ChannelNum == (int )channel || (int )channel == (int )(pChanneList + (unsigned long )i)->ChannelNum + 2) {
#line 346
    return (channel);
  } else {

  }
#line 340
  i = (u8 )((int )i + 1);
  ldv_54357: ;
#line 340
  if ((int )i < (int )channelLen) {
#line 342
    goto ldv_54356;
  } else {

  }

#line 348
  return (0U);
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BT_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) 
{ 


  {
#line 353
  BTDM_SignalCompensation(padapter, rssi_wifi, rssi_bt);
#line 354
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_BT_wifiscan_notify(struct rtw_adapter *padapter , u8 scanType ) 
{ 


  {
#line 358
  BTHCI_WifiScanNotify(padapter, (int )scanType);
#line 359
  BTDM_CheckAntSelMode(padapter);
#line 360
  BTDM_WifiScanNotify(padapter, (int )scanType);
#line 361
  return;
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_BT_wifiassociate_notify(struct rtw_adapter *padapter , u8 action ) 
{ 


  {
#line 368
  if ((unsigned int )action != 0U) {
#line 369
    BTDM_CheckAntSelMode(padapter);
  } else {

  }
#line 371
  BTDM_WifiAssociateNotify(padapter, (int )action);
#line 372
  return;
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BT_HaltProcess(struct rtw_adapter *padapter ) 
{ 


  {
#line 376
  BTDM_ForHalt(padapter);
#line 377
  return;
}
}
#line 388 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum rt_status PlatformIndicateBTEvent(struct rtw_adapter *padapter , void *pEvntData ,
                                              u32 dataLen ) 
{ 
  enum rt_status rt_status ;
  u32 __i ;
  u8 *ptr ;

  {
#line 394
  rt_status = 1;
#line 396
  if (BTCoexDbgLevel == 1U) {
#line 396
    printk("BT event start, %d bytes data to Transferred!!\n", dataLen);
  } else {

  }
#line 397
  if (BTCoexDbgLevel == 1U) {
#line 397
    ptr = (u8 *)pEvntData;
#line 397
    printk("To transfer Hex Data :\n");
#line 397
    __i = 0U;
#line 397
    goto ldv_54384;
    ldv_54383: 
#line 397
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 397
    if (((__i + 1U) & 15U) == 0U) {
#line 397
      printk("\n");
    } else {

    }
#line 397
    __i = __i + 1U;
    ldv_54384: ;
#line 397
    if (__i < dataLen) {
#line 399
      goto ldv_54383;
    } else {

    }
#line 397
    printk("\n");
  } else {

  }
#line 400
  BTHCI_EventParse(padapter, pEvntData, dataLen);
#line 402
  printk("\f%s: Linux has no way to report BT event!!\n", "PlatformIndicateBTEvent");
#line 404
  if (BTCoexDbgLevel == 1U) {
#line 404
    printk("BT event end, %s\n", (unsigned int )rt_status == 0U ? (char *)"SUCCESS" : (char *)"FAIL");
  } else {

  }
#line 407
  return (rt_status);
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_GetLocalChannel(struct rtw_adapter *padapter ) 
{ 


  {
#line 414
  return (padapter->mlmeextpriv.cur_channel);
}
}
#line 417 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_GetCurrentEntryNum(struct rtw_adapter *padapter , u8 PhyHandle ) 
{ 
  struct bt_30info *pBTInfo ;
  u8 i ;

  {
#line 419
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 422
  i = 0U;
#line 422
  goto ldv_54397;
  ldv_54396: ;
#line 423
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U && (int )pBTInfo->BtAsocEntry[(int )i].PhyLinkCmdData.BtPhyLinkhandle == (int )PhyHandle) {
#line 425
    return (i);
  } else {

  }
#line 422
  i = (u8 )((int )i + 1);
  ldv_54397: ;
#line 422
  if ((unsigned int )i <= 1U) {
#line 424
    goto ldv_54396;
  } else {

  }

#line 428
  return (255U);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_DecideBTChannel(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct chnl_txpower_triple *pTriple_subband ;
  struct common_triple *pTriple ;
  u8 i ;
  u8 j ;
  u8 localchnl ;
  u8 firstRemoteLegalChnlInTriplet ;
  u8 regulatory_skipLen ;
  u8 subbandTripletCnt ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;

  {
#line 438
  pTriple_subband = (struct chnl_txpower_triple *)0;
#line 440
  firstRemoteLegalChnlInTriplet = 0U;
#line 441
  regulatory_skipLen = 0U;
#line 442
  subbandTripletCnt = 0U;
#line 444
  pmlmepriv = & padapter->mlmepriv;
#line 445
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 446
  pBtMgnt = & pBTInfo->BtMgnt;
#line 447
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 449
  pBtMgnt->CheckChnlIsSuit = 1U;
#line 450
  localchnl = bthci_GetLocalChannel(padapter);
#line 452
  pTriple = (struct common_triple *)(& pBtHciInfo->BTPreChnllist) + 3U;
#line 456
  i = 0U;
#line 456
  goto ldv_54420;
  ldv_54419: ;
#line 461
  if ((unsigned int )pTriple->byte_1st == 201U) {
#line 463
    if (BTCoexDbgLevel == 1U) {
#line 463
      printk("Find Regulatory ID, regulatory class = %d\n", (int )pTriple->byte_2nd);
    } else {

    }
#line 465
    regulatory_skipLen = (unsigned int )regulatory_skipLen + 3U;
#line 466
    pTriple_subband = (struct chnl_txpower_triple *)0;
#line 467
    goto ldv_54415;
  } else {
#line 469
    if (BTCoexDbgLevel == 1U) {
#line 469
      printk("Find Sub-band triplet \n");
    } else {

    }
#line 470
    subbandTripletCnt = (u8 )((int )subbandTripletCnt + 1);
#line 471
    pTriple_subband = (struct chnl_txpower_triple *)pTriple;
#line 476
    j = pTriple_subband->FirstChnl;
#line 476
    goto ldv_54418;
    ldv_54417: ;
#line 477
    if (BTCoexDbgLevel == 1U) {
#line 477
      printk(" Check if chnl(%d) is legal\n", (int )j);
    } else {

    }
#line 478
    tmp___2 = BT_IsLegalChannel(padapter, (int )j);
#line 478
    if ((unsigned int )tmp___2 != 0U) {
#line 480
      firstRemoteLegalChnlInTriplet = j;
#line 481
      if (BTCoexDbgLevel == 1U) {
#line 481
        printk("Find first remote legal channel : %d\n", (int )firstRemoteLegalChnlInTriplet);
      } else {

      }
#line 488
      tmp = check_fwstate(pmlmepriv, 49);
#line 488
      if (tmp) {
#line 488
        tmp___0 = 0;
      } else {
#line 488
        tmp___0 = 1;
      }
#line 488
      if (tmp___0) {
#line 488
        tmp___1 = BTHCI_HsConnectionEstablished(padapter);
#line 488
        if ((unsigned int )tmp___1 == 0U) {
#line 490
          pBtMgnt->BTChannel = firstRemoteLegalChnlInTriplet;
#line 491
          if (BTCoexDbgLevel == 1U) {
#line 491
            printk("Remote legal channel (%d) is selected, Local not connect to any!!\n",
                   (int )pBtMgnt->BTChannel);
          } else {

          }
#line 492
          return;
        } else {
#line 488
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 494
      if ((int )localchnl >= (int )firstRemoteLegalChnlInTriplet && (int )localchnl < (int )pTriple_subband->FirstChnl + (int )pTriple_subband->NumChnls) {
#line 496
        pBtMgnt->BTChannel = localchnl;
#line 497
        if (BTCoexDbgLevel == 1U) {
#line 497
          printk("Local channel (%d) is selected, wifi or BT connection exists\n",
                 (int )pBtMgnt->BTChannel);
        } else {

        }
#line 498
        return;
      } else {

      }
#line 501
      goto ldv_54416;
    } else {

    }
#line 476
    j = (u8 )((int )j + 1);
    ldv_54418: ;
#line 476
    if ((int )j < (int )pTriple_subband->FirstChnl + (int )pTriple_subband->NumChnls) {
#line 478
      goto ldv_54417;
    } else {

    }
    ldv_54416: ;
  }
  ldv_54415: 
#line 456
  i = (unsigned int )i + 3U;
#line 456
  pTriple = pTriple + 1;
  ldv_54420: ;
#line 456
  if ((int )i < (int )pBtHciInfo->BtPreChnlListLen + -3) {
#line 458
    goto ldv_54419;
  } else {

  }

#line 507
  if ((unsigned int )subbandTripletCnt != 0U) {
#line 509
    if (BTCoexDbgLevel == 1U) {
#line 509
      printk("There are %d sub band triplet exists, ", (int )subbandTripletCnt);
    } else {

    }
#line 510
    if ((unsigned int )firstRemoteLegalChnlInTriplet == 0U) {
#line 512
      if (BTCoexDbgLevel == 1U) {
#line 512
        printk("no legal channel is found!!\n");
      } else {

      }
    } else
#line 516
    if (BTCoexDbgLevel == 1U) {
#line 516
      printk("Remote Legal channel is found but not match to local(wifi connection exists)!!\n");
    } else {

    }
#line 519
    pBtMgnt->CheckChnlIsSuit = 0U;
  } else
#line 523
  if (BTCoexDbgLevel == 1U) {
#line 523
    printk("No sub band triplet exists!!\n");
  } else {

  }
#line 525
  pBtMgnt->BTChannel = localchnl;
#line 526
  if (BTCoexDbgLevel == 1U) {
#line 526
    printk("Local channel (%d) is selected!!\n", (int )pBtMgnt->BTChannel);
  } else {

  }
#line 527
  return;
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_GetAssocInfo(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 tempBuf[256U] ;
  u8 i ;
  u8 BaseMemoryShift ;
  u16 TotalLen ;
  struct amp_assoc_structure *pAmpAsoc ;
  size_t __len ;
  void *__ret ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;
  size_t __len___0 ;
  void *__ret___0 ;
  u32 __i___1 ;
  u8 *ptr___1 ;
  size_t __len___1 ;
  void *__ret___1 ;
  u32 __i___2 ;
  u8 *ptr___2 ;
  size_t __len___2 ;
  void *__ret___2 ;

  {
#line 536
  i = 0U;
#line 537
  BaseMemoryShift = 0U;
#line 538
  TotalLen = 0U;
#line 541
  if (BTCoexDbgLevel == 1U) {
#line 541
    printk("GetAssocInfo start\n");
  } else {

  }
#line 542
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 543
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 545
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar == 0U) {
#line 546
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen <= 247U) {
#line 547
      TotalLen = pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen;
    } else
#line 548
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen == 248U) {
#line 549
      TotalLen = 248U;
    } else {

    }
  } else
#line 550
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar != 0U) {
#line 551
    TotalLen = pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar;
  } else {

  }
#line 553
  goto ldv_54473;
  ldv_54472: ;
#line 554
  if (BTCoexDbgLevel == 1U) {
#line 554
    printk("GetAssocInfo, TotalLen =%d, BaseMemoryShift =%d\n", (int )TotalLen, (int )BaseMemoryShift);
  } else {

  }
#line 555
  __len = (size_t )((int )TotalLen - (int )BaseMemoryShift);
#line 555
  __ret = __builtin_memcpy((void *)(& tempBuf), (void const   *)pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )BaseMemoryShift,
                           __len);
#line 558
  if (BTCoexDbgLevel == 1U) {
#line 558
    ptr = (u8 *)(& tempBuf);
#line 558
    printk("GetAssocInfo :\n");
#line 558
    __i = 0U;
#line 558
    goto ldv_54439;
    ldv_54438: 
#line 558
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 558
    if (((__i + 1U) & 15U) == 0U) {
#line 558
      printk("\n");
    } else {

    }
#line 558
    __i = __i + 1U;
    ldv_54439: ;
#line 558
    if ((unsigned int )TotalLen - (unsigned int )BaseMemoryShift > __i) {
#line 560
      goto ldv_54438;
    } else {

    }
#line 558
    printk("\n");
  } else {

  }
#line 561
  pAmpAsoc = (struct amp_assoc_structure *)(& tempBuf);
#line 562
  pAmpAsoc->Length = pAmpAsoc->Length;
#line 563
  BaseMemoryShift = (unsigned int )((int )((u8 )pAmpAsoc->Length) + (int )BaseMemoryShift) + 3U;
#line 565
  if (BTCoexDbgLevel == 1U) {
#line 565
    printk("TypeID = 0x%x, ", (int )pAmpAsoc->TypeID);
  } else {

  }
#line 566
  if (BTCoexDbgLevel == 1U) {
#line 566
    ptr___0 = (u8 *)(& pAmpAsoc->Data);
#line 566
    printk("Hex Data: \n");
#line 566
    __i___0 = 0U;
#line 566
    goto ldv_54444;
    ldv_54443: 
#line 566
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 566
    if (((__i___0 + 1U) & 15U) == 0U) {
#line 566
      printk("\n");
    } else {

    }
#line 566
    __i___0 = __i___0 + 1U;
    ldv_54444: ;
#line 566
    if ((u32 )pAmpAsoc->Length > __i___0) {
#line 568
      goto ldv_54443;
    } else {

    }
#line 566
    printk("\n");
  } else {

  }
#line 567
  switch ((int )pAmpAsoc->TypeID) {
  case 1: ;
#line 569
  if (BTCoexDbgLevel == 1U) {
#line 569
    printk("==> AMP_MAC_ADDR\n");
  } else {

  }
#line 570
  if ((unsigned int )pAmpAsoc->Length > 6U) {
#line 571
    return (0U);
  } else {

  }
#line 572
  __len___0 = 6UL;
#line 572
  if (__len___0 > 63UL) {
#line 572
    __ret___0 = __memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr),
                         (void const   *)(& pAmpAsoc->Data), __len___0);
  } else {
#line 572
    __ret___0 = __builtin_memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr),
                                 (void const   *)(& pAmpAsoc->Data), __len___0);
  }
#line 573
  if (BTCoexDbgLevel == 1U) {
#line 573
    ptr___1 = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].BTRemoteMACAddr);
#line 573
    printk("Remote Mac address \n");
#line 573
    printk(" ");
#line 573
    __i___1 = 0U;
#line 573
    goto ldv_54453;
    ldv_54452: 
#line 573
    printk("%02X%s", (int )*(ptr___1 + (unsigned long )__i___1), __i___1 == 5U ? (char *)"" : (char *)"-");
#line 573
    __i___1 = __i___1 + 1U;
    ldv_54453: ;
#line 573
    if (__i___1 <= 5U) {
#line 575
      goto ldv_54452;
    } else {

    }
#line 573
    printk("\n");
  } else {

  }
#line 574
  goto ldv_54455;
  case 2: ;
#line 576
  if (BTCoexDbgLevel == 1U) {
#line 576
    printk("==> AMP_PREFERRED_CHANNEL_LIST\n");
  } else {

  }
#line 577
  pBtHciInfo->BtPreChnlListLen = pAmpAsoc->Length;
#line 578
  __len___1 = (size_t )pBtHciInfo->BtPreChnlListLen;
#line 578
  __ret___1 = __builtin_memcpy((void *)(& pBtHciInfo->BTPreChnllist), (void const   *)(& pAmpAsoc->Data),
                               __len___1);
#line 581
  if (BTCoexDbgLevel == 1U) {
#line 581
    ptr___2 = (u8 *)(& pBtHciInfo->BTPreChnllist);
#line 581
    printk("Preferred channel list : \n");
#line 581
    __i___2 = 0U;
#line 581
    goto ldv_54463;
    ldv_54462: 
#line 581
    printk("%02X%s", (int )*(ptr___2 + (unsigned long )__i___2), ((__i___2 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 581
    if (((__i___2 + 1U) & 15U) == 0U) {
#line 581
      printk("\n");
    } else {

    }
#line 581
    __i___2 = __i___2 + 1U;
    ldv_54463: ;
#line 581
    if ((u32 )pBtHciInfo->BtPreChnlListLen > __i___2) {
#line 583
      goto ldv_54462;
    } else {

    }
#line 581
    printk("\n");
  } else {

  }
#line 582
  bthci_DecideBTChannel(padapter, (int )EntryNum);
#line 583
  goto ldv_54455;
  case 3: ;
#line 585
  if (BTCoexDbgLevel == 1U) {
#line 585
    printk("==> AMP_CONNECTED_CHANNEL\n");
  } else {

  }
#line 586
  pBtHciInfo->BTConnectChnlListLen = pAmpAsoc->Length;
#line 587
  __len___2 = (size_t )pBtHciInfo->BTConnectChnlListLen;
#line 587
  __ret___2 = __builtin_memcpy((void *)(& pBtHciInfo->BTConnectChnllist), (void const   *)(& pAmpAsoc->Data),
                               __len___2);
#line 590
  goto ldv_54455;
  case 4: ;
#line 592
  if (BTCoexDbgLevel == 1U) {
#line 592
    printk("==> AMP_80211_PAL_CAP_LIST\n");
  } else {

  }
#line 593
  pBTInfo->BtAsocEntry[(int )EntryNum].BTCapability = *((u32 *)(& pAmpAsoc->Data));
#line 603
  goto ldv_54455;
  case 5: 
#line 605
  pBtHciInfo->BTPalVersion = *((u8 *)(& pAmpAsoc->Data));
#line 606
  pBtHciInfo->BTPalCompanyID = *((u16 *)(& pAmpAsoc->Data) + 1U);
#line 607
  pBtHciInfo->BTPalsubversion = *((u16 *)(& pAmpAsoc->Data) + 3U);
#line 608
  if (BTCoexDbgLevel == 1U) {
#line 608
    printk("==> AMP_80211_PAL_VISION PalVersion  0x%x, PalCompanyID  0x%x, Palsubversion 0x%x\n",
           (int )pBtHciInfo->BTPalVersion, (int )pBtHciInfo->BTPalCompanyID, (int )pBtHciInfo->BTPalsubversion);
  } else {

  }
#line 612
  goto ldv_54455;
  default: ;
#line 614
  if (BTCoexDbgLevel == 1U) {
#line 614
    printk("==> Unsupport TypeID !!\n");
  } else {

  }
#line 615
  goto ldv_54455;
  }
  ldv_54455: 
#line 617
  i = (u8 )((int )i + 1);
  ldv_54473: ;
#line 553
  if ((int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar >= (int )((unsigned short )BaseMemoryShift) || (int )((unsigned short )BaseMemoryShift) < (int )TotalLen) {
#line 555
    goto ldv_54472;
  } else {

  }

#line 619
  if (BTCoexDbgLevel == 1U) {
#line 619
    printk("GetAssocInfo end\n");
  } else {

  }
#line 621
  return (1U);
}
}
#line 624 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_AddEntry(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;

  {
#line 630
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 631
  pBtMgnt = & pBTInfo->BtMgnt;
#line 633
  i = 0U;
#line 633
  goto ldv_54483;
  ldv_54482: ;
#line 634
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed == 0U) {
#line 635
    pBTInfo->BtAsocEntry[(int )i].bUsed = 1U;
#line 636
    pBtMgnt->CurrentConnectEntryNum = i;
#line 637
    goto ldv_54481;
  } else {

  }
#line 633
  i = (u8 )((int )i + 1);
  ldv_54483: ;
#line 633
  if ((unsigned int )i <= 1U) {
#line 635
    goto ldv_54482;
  } else {

  }
  ldv_54481: ;
#line 641
  if ((unsigned int )i == 2U) {
#line 642
    if (BTCoexDbgLevel == 1U) {
#line 642
      printk("bthci_AddEntry(), Add entry fail!!\n");
    } else {

    }
#line 643
    return (0U);
  } else {

  }
#line 645
  return (1U);
}
}
#line 648 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_DiscardTxPackets(struct rtw_adapter *padapter , u16 LLH ) 
{ 


  {
#line 650
  return (0U);
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_CheckLogLinkBehavior(struct rtw_adapter *padapter , struct hci_flow_spec TxFlowSpec ) 
{ 
  u8 ID ;
  u8 ServiceType ;
  u16 MaxSDUSize ;
  u32 SDUInterArrivatime ;
  u8 match ;

  {
#line 659
  ID = TxFlowSpec.Identifier;
#line 660
  ServiceType = TxFlowSpec.ServiceType;
#line 661
  MaxSDUSize = TxFlowSpec.MaximumSDUSize;
#line 662
  SDUInterArrivatime = TxFlowSpec.SDUInterArrivalTime;
#line 663
  match = 0U;
#line 665
  switch ((int )ID) {
  case 1: ;
#line 667
  if ((unsigned int )ServiceType == 1U) {
#line 668
    match = 1U;
#line 669
    if (BTCoexDbgLevel == 1U) {
#line 669
      printk("Logical Link Type =  TX best effort flowspec\n");
    } else {

    }
  } else
#line 670
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 65535U) {
#line 671
    match = 1U;
#line 672
    if (BTCoexDbgLevel == 1U) {
#line 672
      printk("Logical Link Type =  RX guaranteed latency flowspec\n");
    } else {

    }
  } else
#line 673
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 2500U) {
#line 674
    if (BTCoexDbgLevel == 1U) {
#line 674
      printk("Logical Link Type =  RX guaranteed Large latency flowspec\n");
    } else {

    }
  } else {

  }
#line 676
  goto ldv_54498;
  case 2: ;
#line 678
  if ((unsigned int )ServiceType == 1U) {
#line 679
    match = 1U;
#line 680
    if (BTCoexDbgLevel == 1U) {
#line 680
      printk("Logical Link Type =  RX best effort flowspec\n");
    } else {

    }
  } else {

  }
#line 683
  goto ldv_54498;
  case 3: ;
#line 685
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 1492U) {
#line 686
    match = 1U;
#line 687
    if (BTCoexDbgLevel == 1U) {
#line 687
      printk("Logical Link Type =  TX guaranteed latency flowspec\n");
    } else {

    }
  } else
#line 688
  if ((unsigned int )ServiceType == 2U && (unsigned int )MaxSDUSize == 2500U) {
#line 689
    if (BTCoexDbgLevel == 1U) {
#line 689
      printk("Logical Link Type =  TX guaranteed Large latency flowspec\n");
    } else {

    }
  } else {

  }
#line 691
  goto ldv_54498;
  case 4: ;
#line 693
  if ((unsigned int )ServiceType == 1U) {
#line 694
    if ((SDUInterArrivatime == 4294967295U && (unsigned int )ServiceType == 1U) && (unsigned int )MaxSDUSize == 1492U) {
#line 695
      match = 1U;
#line 696
      if (BTCoexDbgLevel == 1U) {
#line 696
        printk("Logical Link Type =  TX/RX aggregated best effort flowspec\n");
      } else {

      }
    } else {

    }
  } else
#line 698
  if ((unsigned int )ServiceType == 2U) {
#line 699
    if (SDUInterArrivatime == 100U) {
#line 700
      match = 1U;
#line 701
      if (BTCoexDbgLevel == 1U) {
#line 701
        printk("Logical Link Type =  TX/RX guaranteed bandwidth flowspec\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 704
  goto ldv_54498;
  default: ;
#line 706
  if (BTCoexDbgLevel == 1U) {
#line 706
    printk("Logical Link Type =  Unknow Type !!!!!!!!\n");
  } else {

  }
#line 707
  goto ldv_54498;
  }
  ldv_54498: ;
#line 710
  if (BTCoexDbgLevel == 1U) {
#line 710
    printk("ID = 0x%x, ServiceType = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, AccessLatency = 0x%x, FlushTimeout = 0x%x\n",
           (int )TxFlowSpec.Identifier, (int )TxFlowSpec.ServiceType, (int )MaxSDUSize,
           SDUInterArrivatime, TxFlowSpec.AccessLatency, TxFlowSpec.FlushTimeout);
  } else {

  }
#line 714
  return (match);
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u16 bthci_AssocMACAddr(struct rtw_adapter *padapter , void *pbuf ) 
{ 
  struct amp_assoc_structure *pAssoStrc ;
  size_t __len ;
  void *__ret ;
  u32 __i ;
  u8 *ptr ;

  {
#line 719
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
#line 720
  pAssoStrc->TypeID = 1U;
#line 721
  pAssoStrc->Length = 6U;
#line 722
  __len = 6UL;
#line 722
  if (__len > 63UL) {
#line 722
    __ret = __memcpy((void *)(& pAssoStrc->Data), (void const   *)(& padapter->eeprompriv.mac_addr),
                     __len);
  } else {
#line 722
    __ret = __builtin_memcpy((void *)(& pAssoStrc->Data), (void const   *)(& padapter->eeprompriv.mac_addr),
                             __len);
  }
#line 723
  if (BTCoexDbgLevel == 1U) {
#line 723
    ptr = (u8 *)pAssoStrc;
#line 723
    printk("AssocMACAddr : \n");
#line 723
    __i = 0U;
#line 723
    goto ldv_54514;
    ldv_54513: 
#line 723
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 723
    if (((__i + 1U) & 15U) == 0U) {
#line 723
      printk("\n");
    } else {

    }
#line 723
    __i = __i + 1U;
    ldv_54514: ;
#line 723
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
#line 725
      goto ldv_54513;
    } else {

    }
#line 723
    printk("\n");
  } else {

  }
#line 726
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
#line 730 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u16 bthci_PALCapabilities(struct rtw_adapter *padapter , void *pbuf ) 
{ 
  struct amp_assoc_structure *pAssoStrc ;
  u32 __i ;
  u8 *ptr ;

  {
#line 735
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
#line 737
  pAssoStrc->TypeID = 4U;
#line 738
  pAssoStrc->Length = 4U;
#line 740
  pAssoStrc->Data[0] = 0U;
#line 741
  pAssoStrc->Data[1] = 0U;
#line 743
  if (BTCoexDbgLevel == 1U) {
#line 743
    ptr = (u8 *)pAssoStrc;
#line 743
    printk("PALCapabilities:\n");
#line 743
    __i = 0U;
#line 743
    goto ldv_54524;
    ldv_54523: 
#line 743
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 743
    if (((__i + 1U) & 15U) == 0U) {
#line 743
      printk("\n");
    } else {

    }
#line 743
    __i = __i + 1U;
    ldv_54524: ;
#line 743
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
#line 745
      goto ldv_54523;
    } else {

    }
#line 743
    printk("\n");
  } else {

  }
#line 744
  if (BTCoexDbgLevel == 1U) {
#line 744
    printk("PALCapabilities \n");
  } else {

  }
#line 746
  if (BTCoexDbgLevel == 1U) {
#line 746
    printk(" TypeID = 0x%x,\n Length = 0x%x,\n Content = 0x0000\n", (int )pAssoStrc->TypeID,
           (int )pAssoStrc->Length);
  } else {

  }
#line 750
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u16 bthci_AssocPreferredChannelList(struct rtw_adapter *padapter , void *pbuf ,
                                           u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct amp_assoc_structure *pAssoStrc ;
  struct amp_pref_chnl_regulatory *pReg ;
  struct chnl_txpower_triple *pTriple ;
  char ctrString[3U] ;
  u32 len ;
  u8 preferredChnl ;
  size_t __len ;
  void *__ret ;
  bool tmp ;
  u8 tmp___0 ;
  u32 __i ;
  u8 *ptr ;

  {
#line 760
  ctrString[0] = 88;
#line 760
  ctrString[1] = 88;
#line 760
  ctrString[2] = 88;
#line 761
  len = 0U;
#line 764
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 765
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
#line 766
  pReg = (struct amp_pref_chnl_regulatory *)(& pAssoStrc->Data) + 3U;
#line 768
  preferredChnl = bthci_GetLocalChannel(padapter);
#line 769
  pAssoStrc->TypeID = 2U;
#line 772
  __len = 3UL;
#line 772
  if (__len > 63UL) {
#line 772
    __ret = __memcpy((void *)(& pAssoStrc->Data), (void const   *)(& ctrString), __len);
  } else {
#line 772
    __ret = __builtin_memcpy((void *)(& pAssoStrc->Data), (void const   *)(& ctrString),
                             __len);
  }
#line 773
  pReg->reXId = 201U;
#line 774
  pReg->regulatoryClass = 254U;
#line 775
  pReg->coverageClass = 0U;
#line 776
  len = len + 6U;
#line 777
  if (BTCoexDbgLevel == 1U) {
#line 777
    printk("PREFERRED_CHNL_LIST\n");
  } else {

  }
#line 778
  if (BTCoexDbgLevel == 1U) {
#line 778
    printk("XXX, 201, 254, 0\n");
  } else {

  }
#line 780
  pTriple = (struct chnl_txpower_triple *)(& pAssoStrc->Data) + (unsigned long )len;
#line 783
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 1U) {
#line 783
    goto _L;
  } else {
#line 783
    tmp = check_fwstate(& padapter->mlmepriv, 113);
#line 783
    if ((int )tmp) {
#line 783
      goto _L;
    } else {
#line 783
      tmp___0 = BTHCI_HsConnectionEstablished(padapter);
#line 783
      if ((unsigned int )tmp___0 != 0U) {
        _L: /* CIL Label */ 
#line 788
        pTriple->FirstChnl = preferredChnl;
#line 789
        pTriple->NumChnls = 1U;
#line 790
        pTriple->MaxTxPowerInDbm = 20;
#line 791
        len = len + 3U;
#line 792
        if (BTCoexDbgLevel == 1U) {
#line 792
          printk("First Channel = %d, Channel Num = %d, MaxDbm = %d\n", (int )pTriple->FirstChnl,
                 (int )pTriple->NumChnls, (int )pTriple->MaxTxPowerInDbm);
        } else {

        }
      } else {

      }
    }
  }
#line 798
  pAssoStrc->Length = (unsigned short )len;
#line 799
  if (BTCoexDbgLevel == 1U) {
#line 799
    ptr = (u8 *)pAssoStrc;
#line 799
    printk("AssocPreferredChannelList : \n");
#line 799
    __i = 0U;
#line 799
    goto ldv_54544;
    ldv_54543: 
#line 799
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 799
    if (((__i + 1U) & 15U) == 0U) {
#line 799
      printk("\n");
    } else {

    }
#line 799
    __i = __i + 1U;
    ldv_54544: ;
#line 799
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
#line 801
      goto ldv_54543;
    } else {

    }
#line 799
    printk("\n");
  } else {

  }
#line 801
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u16 bthci_AssocPALVer(struct rtw_adapter *padapter , void *pbuf ) 
{ 
  struct amp_assoc_structure *pAssoStrc ;
  u8 *pu1Tmp ;
  u16 *pu2Tmp ;
  u32 __i ;
  u8 *ptr ;

  {
#line 806
  pAssoStrc = (struct amp_assoc_structure *)pbuf;
#line 810
  pAssoStrc->TypeID = 5U;
#line 811
  pAssoStrc->Length = 5U;
#line 812
  pu1Tmp = (u8 *)(& pAssoStrc->Data);
#line 813
  *pu1Tmp = 1U;
#line 814
  pu2Tmp = (u16 *)(& pAssoStrc->Data) + 1U;
#line 815
  *pu2Tmp = 93U;
#line 816
  pu2Tmp = (u16 *)(& pAssoStrc->Data) + 3U;
#line 817
  *pu2Tmp = 1U;
#line 819
  if (BTCoexDbgLevel == 1U) {
#line 819
    ptr = (u8 *)pAssoStrc;
#line 819
    printk("AssocPALVer : \n");
#line 819
    __i = 0U;
#line 819
    goto ldv_54556;
    ldv_54555: 
#line 819
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 819
    if (((__i + 1U) & 15U) == 0U) {
#line 819
      printk("\n");
    } else {

    }
#line 819
    __i = __i + 1U;
    ldv_54556: ;
#line 819
    if ((unsigned int )pAssoStrc->Length + 3U > __i) {
#line 821
      goto ldv_54555;
    } else {

    }
#line 819
    printk("\n");
  } else {

  }
#line 820
  if (BTCoexDbgLevel == 1U) {
#line 820
    printk("AssocPALVer \n");
  } else {

  }
#line 822
  if (BTCoexDbgLevel == 1U) {
#line 822
    printk(" TypeID = 0x%x,\n Length = 0x%x,\n PAL Version = 0x01,\n PAL vendor = 0x01,\n PAL Sub-version specifier = 0x01\n",
           (int )pAssoStrc->TypeID, (int )pAssoStrc->Length);
  } else {

  }
#line 825
  return ((unsigned int )pAssoStrc->Length + 3U);
}
}
#line 828 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_CheckRfStateBeforeConnect(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  enum rt_rf_power_state RfState ;
  unsigned long tmp ;

  {
#line 833
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 835
  RfState = padapter->pwrctrlpriv.rf_pwrstate;
#line 837
  if ((unsigned int )RfState != 0U) {
#line 838
    tmp = msecs_to_jiffies(50U);
#line 838
    ldv_mod_timer_2421(& pBTInfo->BTPsDisableTimer, tmp + (unsigned long )jiffies);
#line 840
    return (0U);
  } else {

  }
#line 842
  return (1U);
}
}
#line 845 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_ResponderStartToScan(struct rtw_adapter *padapter ) 
{ 


  {
#line 847
  return;
}
}
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_PhyLinkConnectionInProgress(struct rtw_adapter *padapter , u8 PhyLinkHandle ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 854
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 855
  pBtMgnt = & pBTInfo->BtMgnt;
#line 857
  if ((unsigned int )pBtMgnt->bPhyLinkInProgress != 0U && (int )pBtMgnt->BtCurrentPhyLinkhandle == (int )PhyLinkHandle) {
#line 859
    return (1U);
  } else {

  }
#line 860
  return (0U);
}
}
#line 863 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_ResetFlowSpec(struct rtw_adapter *padapter , u8 EntryNum , u8 index ) 
{ 
  struct bt_30info *pBTinfo ;

  {
#line 867
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 869
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtLogLinkhandle = 0U;
#line 870
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtPhyLinkhandle = 0U;
#line 871
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].bLLCompleteEventIsSet = 0U;
#line 872
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].bLLCancelCMDIsSetandComplete = 0U;
#line 873
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].BtTxFlowSpecID = 0U;
#line 874
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].TxPacketCount = 0U;
#line 876
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.Identifier = 1U;
#line 877
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.ServiceType = 1U;
#line 878
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.MaximumSDUSize = 65535U;
#line 879
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.SDUInterArrivalTime = 4294967295U;
#line 880
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.AccessLatency = 4294967295U;
#line 881
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Tx_Flow_Spec.FlushTimeout = 4294967295U;
#line 883
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.Identifier = 1U;
#line 884
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.ServiceType = 1U;
#line 885
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.MaximumSDUSize = 65535U;
#line 886
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.SDUInterArrivalTime = 4294967295U;
#line 887
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.AccessLatency = 4294967295U;
#line 888
  pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )index].Rx_Flow_Spec.FlushTimeout = 4294967295U;
#line 889
  return;
}
}
#line 891 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_ResetEntry(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 j ;

  {
#line 897
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 898
  pBtMgnt = & pBTinfo->BtMgnt;
#line 900
  pBTinfo->BtAsocEntry[(int )EntryNum].bUsed = 0U;
#line 901
  pBTinfo->BtAsocEntry[(int )EntryNum].BtCurrentState = 32U;
#line 902
  pBTinfo->BtAsocEntry[(int )EntryNum].BtNextState = 32U;
#line 904
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocRemLen = 0U;
#line 905
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.BtPhyLinkhandle = 0U;
#line 906
  if ((unsigned long )pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment != (unsigned long )((void *)0)) {
#line 907
    memset(pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment, 0,
           1000UL);
  } else {

  }
#line 908
  pBTinfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar = 0U;
#line 910
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType = 0U;
#line 911
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle = 0U;
#line 912
  memset((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
         0, (size_t )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen);
#line 914
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen = 0U;
#line 917
  pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = 16000U;
#line 919
  pBTinfo->BtAsocEntry[(int )EntryNum].AMPRole = 0;
#line 921
  pBTinfo->BtAsocEntry[(int )EntryNum].mAssoc = 0U;
#line 922
  pBTinfo->BtAsocEntry[(int )EntryNum].b4waySuccess = 0U;
#line 925
  pBTinfo->BtAsocEntry[(int )EntryNum].KeyReplayCounter = 0ULL;
#line 926
  pBTinfo->BtAsocEntry[(int )EntryNum].BTWPAAuthState = 0;
#line 928
  pBTinfo->BtAsocEntry[(int )EntryNum].bSendSupervisionPacket = 0U;
#line 929
  pBTinfo->BtAsocEntry[(int )EntryNum].NoRxPktCnt = 0U;
#line 930
  pBTinfo->BtAsocEntry[(int )EntryNum].ShortRangeMode = 0U;
#line 931
  pBTinfo->BtAsocEntry[(int )EntryNum].rxSuvpPktCnt = 0U;
#line 933
  j = 0U;
#line 933
  goto ldv_54586;
  ldv_54585: 
#line 934
  bthci_ResetFlowSpec(padapter, (int )EntryNum, (int )j);
#line 933
  j = (u8 )((int )j + 1);
  ldv_54586: ;
#line 933
  if ((unsigned int )j <= 1U) {
#line 935
    goto ldv_54585;
  } else {

  }
#line 936
  pBtMgnt->BTAuthCount = 0U;
#line 937
  pBtMgnt->BTAsocCount = 0U;
#line 938
  pBtMgnt->BTCurrentConnectType = 4;
#line 939
  pBtMgnt->BTReceiveConnectPkt = 4;
#line 941
  HALBT_RemoveKey(padapter, (int )EntryNum);
#line 942
  return;
}
}
#line 944 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_RemoveEntryByEntryNum(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 946
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 947
  pBtMgnt = & pBTInfo->BtMgnt;
#line 949
  bthci_ResetEntry(padapter, (int )EntryNum);
#line 951
  if ((unsigned int )pBtMgnt->CurrentBTConnectionCnt != 0U) {
#line 952
    pBtMgnt->CurrentBTConnectionCnt = (u8 )((int )pBtMgnt->CurrentBTConnectionCnt - 1);
  } else {

  }
#line 954
  if (BTCoexDbgLevel == 1U) {
#line 954
    printk("[BT Flag], CurrentBTConnectionCnt = %d!!\n", (int )pBtMgnt->CurrentBTConnectionCnt);
  } else {

  }
#line 957
  if ((unsigned int )pBtMgnt->CurrentBTConnectionCnt != 0U) {
#line 958
    pBtMgnt->BtOperationOn = 1U;
  } else {
#line 960
    pBtMgnt->BtOperationOn = 0U;
#line 961
    if (BTCoexDbgLevel == 1U) {
#line 961
      printk("[BT Flag], Bt Operation OFF!!\n");
    } else {

    }
  }
#line 964
  if ((unsigned int )pBtMgnt->BtOperationOn == 0U) {
#line 965
    ldv_del_timer_sync_2422(& pBTInfo->BTHCIDiscardAclDataTimer);
#line 966
    ldv_del_timer_sync_2423(& pBTInfo->BTBeaconTimer);
#line 967
    pBtMgnt->bStartSendSupervisionPkt = 0U;
  } else {

  }
#line 969
  return;
}
}
#line 972 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_CommandCompleteHeader(u8 *pbuf , u16 OGF , u16 OCF , enum hci_status status ) 
{ 
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 NumHCI_Comm ;

  {
#line 979
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;
#line 980
  NumHCI_Comm = 1U;
#line 982
  PPacketIrpEvent->EventCode = 14U;
#line 983
  PPacketIrpEvent->Data[0] = NumHCI_Comm;
#line 984
  PPacketIrpEvent->Data[1] = (unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF));
#line 985
  PPacketIrpEvent->Data[2] = (unsigned char )((((int )OGF << 10) | (int )OCF) >> 8);
#line 987
  if ((unsigned int )OGF == 63U) {
#line 988
    if ((unsigned int )OCF == 64U) {
#line 989
      if (BTCoexDbgLevel == 1U) {
#line 989
        printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
               (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
               (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
               (unsigned int )status, (int )OGF, (int )OCF);
      } else {

      }
    } else
#line 993
    if (BTCoexDbgLevel == 1U) {
#line 993
      printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
             (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
             (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
             (unsigned int )status, (int )OGF, (int )OCF);
    } else {

    }
  } else
#line 998
  if (BTCoexDbgLevel == 1U) {
#line 998
    printk("[BT event], CommandComplete, Num_HCI_Comm = 0x%x, Opcode = 0x%02x%02x, status = 0x%x, OGF = 0x%x, OCF = 0x%x\n",
           (int )NumHCI_Comm, (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)),
           (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
           (unsigned int )status, (int )OGF, (int )OCF);
  } else {

  }
#line 1002
  return (3U);
}
}
#line 1005 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 bthci_ExtensionEventHeaderRtk(u8 *pbuf , u8 extensionEvent ) 
{ 
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1007
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)pbuf;
#line 1008
  PPacketIrpEvent->EventCode = 254U;
#line 1009
  PPacketIrpEvent->Data[0] = extensionEvent;
#line 1011
  return (1U);
}
}
#line 1015 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum rt_status bthci_IndicateEvent(struct rtw_adapter *padapter , void *pEvntData ,
                                          u32 dataLen ) 
{ 
  enum rt_status rt_status ;

  {
#line 1023
  rt_status = PlatformIndicateBTEvent(padapter, pEvntData, dataLen);
#line 1025
  return (rt_status);
}
}
#line 1029 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventWriteRemoteAmpAssoc(struct rtw_adapter *padapter , enum hci_status status ,
                                           u8 PLHandle ) 
{ 
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 1035
  localBuf[0] = '\000';
#line 1035
  tmp = 1U;
#line 1035
  while (1) {
#line 1035
    if (tmp >= 256U) {
#line 1035
      break;
    } else {

    }
#line 1035
    localBuf[tmp] = (unsigned char)0;
#line 1035
    tmp = tmp + 1U;
  }
#line 1037
  len = 0U;
#line 1040
  memset((void *)(& localBuf), 0, 256UL);
#line 1041
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1043
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 11, status);
#line 1043
  len = (int )tmp___0 + (int )len;
#line 1047
  if (BTCoexDbgLevel == 1U) {
#line 1047
    printk("PhyLinkHandle = 0x%x, status = %d\n", (int )PLHandle, (unsigned int )status);
  } else {

  }
#line 1049
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1050
  *pRetPar = (u8 )status;
#line 1051
  *(pRetPar + 1UL) = PLHandle;
#line 1052
  len = (unsigned int )len + 2U;
#line 1053
  PPacketIrpEvent->Length = len;
#line 1055
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 1056
  return;
}
}
#line 1059 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventEnhancedFlushComplete(struct rtw_adapter *padapter , u16 LLH ) 
{ 
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1064
  localBuf[0] = '\000';
#line 1064
  tmp = 1U;
#line 1064
  while (1) {
#line 1064
    if (tmp >= 4U) {
#line 1064
      break;
    } else {

    }
#line 1064
    localBuf[tmp] = (unsigned char)0;
#line 1064
    tmp = tmp + 1U;
  }
#line 1067
  if (BTCoexDbgLevel == 1U) {
#line 1067
    printk("EventEnhancedFlushComplete, LLH = 0x%x\n", (int )LLH);
  } else {

  }
#line 1069
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1070
  PPacketIrpEvent->EventCode = 57U;
#line 1071
  PPacketIrpEvent->Length = 2U;
#line 1073
  PPacketIrpEvent->Data[0] = (unsigned char )LLH;
#line 1074
  PPacketIrpEvent->Data[1] = (unsigned char )((int )LLH >> 8);
#line 1076
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 1077
  return;
}
}
#line 1080 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventShortRangeModeChangeComplete(struct rtw_adapter *padapter ,
                                                    enum hci_status HciStatus , u8 ShortRangeState ,
                                                    u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1087
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1088
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1089
  localBuf[0] = '\000';
#line 1089
  tmp = 1U;
#line 1089
  while (1) {
#line 1089
    if (tmp >= 5U) {
#line 1089
      break;
    } else {

    }
#line 1089
    localBuf[tmp] = (unsigned char)0;
#line 1089
    tmp = tmp + 1U;
  }
#line 1092
  if ((pBtHciInfo->BTEventMaskPage2 & 4096ULL) == 0ULL) {
#line 1093
    if (BTCoexDbgLevel == 1U) {
#line 1093
      printk("[BT event], Short Range Mode Change Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1095
    return;
  } else {

  }
#line 1097
  if (BTCoexDbgLevel == 1U) {
#line 1097
    printk("[BT event], Short Range Mode Change Complete, Status = %d\n , PLH = 0x%x\n, Short_Range_Mode_State = 0x%x\n",
           (unsigned int )HciStatus, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (int )ShortRangeState);
  } else {

  }
#line 1100
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1101
  PPacketIrpEvent->EventCode = 76U;
#line 1102
  PPacketIrpEvent->Length = 3U;
#line 1103
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1104
  PPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 1105
  PPacketIrpEvent->Data[2] = ShortRangeState;
#line 1106
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
#line 1107
  return;
}
}
#line 1109 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventSendFlowSpecModifyComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                                  u16 logicHandle ) 
{ 
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;

  {
#line 1113
  localBuf[0] = '\000';
#line 1113
  tmp = 1U;
#line 1113
  while (1) {
#line 1113
    if (tmp >= 5U) {
#line 1113
      break;
    } else {

    }
#line 1113
    localBuf[tmp] = (unsigned char)0;
#line 1113
    tmp = tmp + 1U;
  }
#line 1115
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1116
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1118
  if ((pBtHciInfo->BTEventMaskPage2 & 128ULL) == 0ULL) {
#line 1119
    if (BTCoexDbgLevel == 1U) {
#line 1119
      printk("[BT event], Flow Spec Modify Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1121
    return;
  } else {

  }
#line 1123
  if (BTCoexDbgLevel == 1U) {
#line 1123
    printk("[BT event], Flow Spec Modify Complete, status = 0x%x, LLH = 0x%x\n", (unsigned int )HciStatus,
           (int )logicHandle);
  } else {

  }
#line 1125
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1126
  PPacketIrpEvent->EventCode = 71U;
#line 1127
  PPacketIrpEvent->Length = 3U;
#line 1129
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1131
  PPacketIrpEvent->Data[1] = (unsigned char )logicHandle;
#line 1132
  PPacketIrpEvent->Data[2] = (unsigned char )((int )logicHandle >> 8);
#line 1134
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
#line 1135
  return;
}
}
#line 1138 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventExtWifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 len ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pu1Temp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  enum rt_status tmp___1 ;

  {
#line 1143
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1144
  pBtMgnt = & pBTInfo->BtMgnt;
#line 1145
  len = 0U;
#line 1146
  localBuf[0] = '\000';
#line 1146
  tmp = 1U;
#line 1146
  while (1) {
#line 1146
    if (tmp >= 7U) {
#line 1146
      break;
    } else {

    }
#line 1146
    localBuf[tmp] = (unsigned char)0;
#line 1146
    tmp = tmp + 1U;
  }
#line 1151
  if ((unsigned int )pBtMgnt->BtOperationOn == 0U) {
#line 1152
    return;
  } else {

  }
#line 1154
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1156
  tmp___0 = bthci_ExtensionEventHeaderRtk((u8 *)(& localBuf), 1);
#line 1156
  len = (int )tmp___0 + (int )len;
#line 1159
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1160
  pu1Temp = pRetPar;
#line 1161
  *pu1Temp = scanType;
#line 1162
  len = (unsigned int )len + 1U;
#line 1164
  PPacketIrpEvent->Length = len;
#line 1166
  tmp___1 = bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 1166
  if ((unsigned int )tmp___1 == 0U) {
#line 1167
    if (BTCoexDbgLevel == 1U) {
#line 1167
      printk("[BT event], Wifi scan notify, scan type = %d\n", (int )scanType);
    } else {

    }
  } else {

  }
#line 1168
  return;
}
}
#line 1173 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventAMPReceiverReport(struct rtw_adapter *padapter , u8 Reason ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[20U] ;
  unsigned int tmp ;
  u32 *pu4Temp ;
  u16 *pu2Temp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1178
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1179
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1181
  if ((unsigned int )pBtHciInfo->bTestNeedReport != 0U) {
#line 1182
    localBuf[0] = '\000';
#line 1182
    tmp = 1U;
#line 1182
    while (1) {
#line 1182
      if (tmp >= 20U) {
#line 1182
        break;
      } else {

      }
#line 1182
      localBuf[tmp] = (unsigned char)0;
#line 1182
      tmp = tmp + 1U;
    }
#line 1187
    if (BTCoexDbgLevel == 1U) {
#line 1187
      printk(" HCI_EVENT_AMP_RECEIVER_REPORT\n");
    } else {

    }
#line 1188
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1189
    PPacketIrpEvent->EventCode = 75U;
#line 1190
    PPacketIrpEvent->Length = 2U;
#line 1192
    PPacketIrpEvent->Data[0] = pBtHciInfo->TestCtrType;
#line 1194
    PPacketIrpEvent->Data[1] = Reason;
#line 1196
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 2U;
#line 1197
    *pu4Temp = pBtHciInfo->TestEventType;
#line 1199
    pu2Temp = (u16 *)(& PPacketIrpEvent->Data) + 6U;
#line 1200
    *pu2Temp = pBtHciInfo->TestNumOfFrame;
#line 1202
    pu2Temp = (u16 *)(& PPacketIrpEvent->Data) + 8U;
#line 1203
    *pu2Temp = pBtHciInfo->TestNumOfErrFrame;
#line 1205
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 10U;
#line 1206
    *pu4Temp = (u32 )pBtHciInfo->TestNumOfBits;
#line 1208
    pu4Temp = (u32 *)(& PPacketIrpEvent->Data) + 14U;
#line 1209
    *pu4Temp = (u32 )pBtHciInfo->TestNumOfErrBits;
#line 1211
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 20U);
  } else {

  }
#line 1217
  pBtHciInfo->TestNumOfFrame = 0U;
#line 1218
  return;
}
}
#line 1221 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventChannelSelected(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[3U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1226
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1227
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1228
  localBuf[0] = '\000';
#line 1228
  tmp = 1U;
#line 1228
  while (1) {
#line 1228
    if (tmp >= 3U) {
#line 1228
      break;
    } else {

    }
#line 1228
    localBuf[tmp] = (unsigned char)0;
#line 1228
    tmp = tmp + 1U;
  }
#line 1231
  if ((pBtHciInfo->BTEventMaskPage2 & 2ULL) == 0ULL) {
#line 1232
    if (BTCoexDbgLevel == 1U) {
#line 1232
      printk("[BT event], Channel Selected, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1234
    return;
  } else {

  }
#line 1237
  if (BTCoexDbgLevel == 1U) {
#line 1237
    printk("[BT event], Channel Selected, PhyLinkHandle %d\n", (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle);
  } else {

  }
#line 1241
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1242
  PPacketIrpEvent->EventCode = 65U;
#line 1243
  PPacketIrpEvent->Length = 1U;
#line 1244
  PPacketIrpEvent->Data[0] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 1245
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 3U);
#line 1246
  return;
}
}
#line 1249 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventDisconnectPhyLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                                 enum hci_status Reason , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1256
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1257
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1258
  localBuf[0] = '\000';
#line 1258
  tmp = 1U;
#line 1258
  while (1) {
#line 1258
    if (tmp >= 5U) {
#line 1258
      break;
    } else {

    }
#line 1258
    localBuf[tmp] = (unsigned char)0;
#line 1258
    tmp = tmp + 1U;
  }
#line 1261
  if ((pBtHciInfo->BTEventMaskPage2 & 4ULL) == 0ULL) {
#line 1262
    if (BTCoexDbgLevel == 1U) {
#line 1262
      printk("[BT event], Disconnect Physical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1264
    return;
  } else {

  }
#line 1266
  if (BTCoexDbgLevel == 1U) {
#line 1266
    printk("[BT event], Disconnect Physical Link Complete, Status = 0x%x, PLH = 0x%x Reason = 0x%x\n",
           (unsigned int )HciStatus, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (unsigned int )Reason);
  } else {

  }
#line 1269
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1270
  PPacketIrpEvent->EventCode = 66U;
#line 1271
  PPacketIrpEvent->Length = 3U;
#line 1272
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1273
  PPacketIrpEvent->Data[1] = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 1274
  PPacketIrpEvent->Data[2] = (u8 )Reason;
#line 1275
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 5U);
#line 1276
  return;
}
}
#line 1279 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventPhysicalLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                            u8 EntryNum , u8 PLHandle ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_dgb *pBtDbg ;
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 PL_handle ;

  {
#line 1286
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1287
  pBtMgnt = & pBTInfo->BtMgnt;
#line 1288
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1289
  pBtDbg = & pBTInfo->BtDbg;
#line 1290
  localBuf[0] = '\000';
#line 1290
  tmp = 1U;
#line 1290
  while (1) {
#line 1290
    if (tmp >= 4U) {
#line 1290
      break;
    } else {

    }
#line 1290
    localBuf[tmp] = (unsigned char)0;
#line 1290
    tmp = tmp + 1U;
  }
#line 1294
  pBtMgnt->bPhyLinkInProgress = 0U;
#line 1295
  pBtDbg->dbgHciInfo.hciCmdPhyLinkStatus = (u32 )HciStatus;
#line 1296
  if ((pBtHciInfo->BTEventMaskPage2 & 1ULL) == 0ULL) {
#line 1297
    if (BTCoexDbgLevel == 1U) {
#line 1297
      printk("[BT event], Physical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1299
    return;
  } else {

  }
#line 1302
  if ((unsigned int )EntryNum == 255U) {
#line 1304
    PL_handle = PLHandle;
  } else {
#line 1307
    PL_handle = pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 1308
    pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent = 0U;
  }
#line 1311
  if (BTCoexDbgLevel == 1U) {
#line 1311
    printk("[BT event], Physical Link Complete, Status = 0x%x PhyLinkHandle = 0x%x\n",
           (unsigned int )HciStatus, (int )PL_handle);
  } else {

  }
#line 1314
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1315
  PPacketIrpEvent->EventCode = 64U;
#line 1316
  PPacketIrpEvent->Length = 2U;
#line 1318
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1319
  PPacketIrpEvent->Data[1] = PL_handle;
#line 1320
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 1321
  return;
}
}
#line 1325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventCommandStatus(struct rtw_adapter *padapter , u8 OGF , u16 OCF ,
                                     enum hci_status HciStatus ) 
{ 
  u8 localBuf[6U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 Num_Hci_Comm ;

  {
#line 1333
  localBuf[0] = '\000';
#line 1333
  tmp = 1U;
#line 1333
  while (1) {
#line 1333
    if (tmp >= 6U) {
#line 1333
      break;
    } else {

    }
#line 1333
    localBuf[tmp] = (unsigned char)0;
#line 1333
    tmp = tmp + 1U;
  }
#line 1335
  Num_Hci_Comm = 1U;
#line 1336
  if (BTCoexDbgLevel == 1U) {
#line 1336
    printk("[BT event], CommandStatus, Opcode = 0x%02x%02x, OGF = 0x%x,  OCF = 0x%x, Status = 0x%x, Num_HCI_COMM = 0x%x\n",
           (int )((unsigned char )((((int )OGF << 10) | (int )OCF) >> 8)), (int )((unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF))),
           (int )OGF, (int )OCF, (unsigned int )HciStatus, (int )Num_Hci_Comm);
  } else {

  }
#line 1340
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1341
  PPacketIrpEvent->EventCode = 15U;
#line 1342
  PPacketIrpEvent->Length = 4U;
#line 1343
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1344
  PPacketIrpEvent->Data[1] = Num_Hci_Comm;
#line 1345
  PPacketIrpEvent->Data[2] = (unsigned char )((int )((signed char )((int )OGF << 10)) | (int )((signed char )OCF));
#line 1346
  PPacketIrpEvent->Data[3] = (unsigned char )((((int )OGF << 10) | (int )OCF) >> 8);
#line 1348
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 6U);
#line 1349
  return;
}
}
#line 1353 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventLogicalLinkComplete(struct rtw_adapter *padapter , enum hci_status HciStatus ,
                                           u8 PhyLinkHandle , u16 LogLinkHandle ,
                                           u8 LogLinkIndex , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1363
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1364
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1365
  localBuf[0] = '\000';
#line 1365
  tmp = 1U;
#line 1365
  while (1) {
#line 1365
    if (tmp >= 7U) {
#line 1365
      break;
    } else {

    }
#line 1365
    localBuf[tmp] = (unsigned char)0;
#line 1365
    tmp = tmp + 1U;
  }
#line 1368
  if ((pBtHciInfo->BTEventMaskPage2 & 32ULL) == 0ULL) {
#line 1369
    if (BTCoexDbgLevel == 1U) {
#line 1369
      printk("[BT event], Logical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1371
    return;
  } else {

  }
#line 1373
  if (BTCoexDbgLevel == 1U) {
#line 1373
    printk("[BT event], Logical Link Complete, PhyLinkHandle = 0x%x,  LogLinkHandle = 0x%x, Status = 0x%x\n",
           (int )PhyLinkHandle, (int )LogLinkHandle, (unsigned int )HciStatus);
  } else {

  }
#line 1376
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1377
  PPacketIrpEvent->EventCode = 69U;
#line 1378
  PPacketIrpEvent->Length = 5U;
#line 1380
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1382
  PPacketIrpEvent->Data[1] = (unsigned char )LogLinkHandle;
#line 1383
  PPacketIrpEvent->Data[2] = (unsigned char )((int )LogLinkHandle >> 8);
#line 1385
  PPacketIrpEvent->Data[3] = PhyLinkHandle;
#line 1387
  if ((unsigned int )HciStatus == 0U) {
#line 1388
    PPacketIrpEvent->Data[4] = pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )LogLinkIndex].Tx_Flow_Spec.Identifier;
  } else {
#line 1391
    PPacketIrpEvent->Data[4] = 0U;
  }
#line 1394
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 7U);
#line 1395
  return;
}
}
#line 1398 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventDisconnectLogicalLinkComplete(struct rtw_adapter *padapter ,
                                                     enum hci_status HciStatus , u16 LogLinkHandle ,
                                                     enum hci_status Reason ) 
{ 
  u8 localBuf[6U] ;
  unsigned int tmp ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1405
  localBuf[0] = '\000';
#line 1405
  tmp = 1U;
#line 1405
  while (1) {
#line 1405
    if (tmp >= 6U) {
#line 1405
      break;
    } else {

    }
#line 1405
    localBuf[tmp] = (unsigned char)0;
#line 1405
    tmp = tmp + 1U;
  }
#line 1406
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1407
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1410
  if ((pBtHciInfo->BTEventMaskPage2 & 64ULL) == 0ULL) {
#line 1411
    if (BTCoexDbgLevel == 1U) {
#line 1411
      printk("[BT event], Disconnect Logical Link Complete, Ignore to send this event due to event mask page 2\n");
    } else {

    }
#line 1412
    return;
  } else {

  }
#line 1414
  if (BTCoexDbgLevel == 1U) {
#line 1414
    printk("[BT event], Disconnect Logical Link Complete, Status = 0x%x, LLH = 0x%x Reason = 0x%x\n",
           (unsigned int )HciStatus, (int )LogLinkHandle, (unsigned int )Reason);
  } else {

  }
#line 1416
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1417
  PPacketIrpEvent->EventCode = 70U;
#line 1418
  PPacketIrpEvent->Length = 4U;
#line 1420
  PPacketIrpEvent->Data[0] = (u8 )HciStatus;
#line 1422
  PPacketIrpEvent->Data[1] = (unsigned char )LogLinkHandle;
#line 1423
  PPacketIrpEvent->Data[2] = (unsigned char )((int )LogLinkHandle >> 8);
#line 1425
  PPacketIrpEvent->Data[3] = (u8 )Reason;
#line 1427
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 6U);
#line 1428
  return;
}
}
#line 1431 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_EventFlushOccurred(struct rtw_adapter *padapter , u16 LogLinkHandle ) 
{ 
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 1436
  localBuf[0] = '\000';
#line 1436
  tmp = 1U;
#line 1436
  while (1) {
#line 1436
    if (tmp >= 4U) {
#line 1436
      break;
    } else {

    }
#line 1436
    localBuf[tmp] = (unsigned char)0;
#line 1436
    tmp = tmp + 1U;
  }
#line 1438
  if (BTCoexDbgLevel == 1U) {
#line 1438
    printk("bthci_EventFlushOccurred(), LLH = 0x%x\n", (int )LogLinkHandle);
  } else {

  }
#line 1440
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1441
  PPacketIrpEvent->EventCode = 17U;
#line 1442
  PPacketIrpEvent->Length = 2U;
#line 1444
  PPacketIrpEvent->Data[0] = (unsigned char )LogLinkHandle;
#line 1445
  PPacketIrpEvent->Data[1] = (unsigned char )((int )LogLinkHandle >> 8);
#line 1447
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 1448
  return;
}
}
#line 1451 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_BuildPhysicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                               u16 OCF ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 EntryNum ;
  u8 PLH ;
  u8 tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u32 __i ;
  u8 *ptr ;
  u32 __i___0 ;
  u8 *ptr___0 ;

  {
#line 1457
  status = 0;
#line 1458
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1459
  pBtMgnt = & pBTInfo->BtMgnt;
#line 1463
  bthci_EventCommandStatus(padapter, 1, (int )OCF, 0);
#line 1468
  PLH = *((u8 *)(& pHciCmd->Data));
#line 1471
  tmp = bthci_AddEntry(padapter);
#line 1471
  if ((unsigned int )tmp == 0U) {
#line 1472
    status = 13;
#line 1473
    bthci_EventPhysicalLinkComplete(padapter, status, 255, (int )PLH);
#line 1474
    return (status);
  } else {

  }
#line 1477
  EntryNum = pBtMgnt->CurrentConnectEntryNum;
#line 1478
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle = PLH;
#line 1479
  pBtMgnt->BtCurrentPhyLinkhandle = PLH;
#line 1481
  if ((unsigned long )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.AMPAssocfragment == (unsigned long )((void *)0)) {
#line 1482
    if (BTCoexDbgLevel == 1U) {
#line 1482
      printk("Create/Accept PhysicalLink, AMP controller is busy\n");
    } else {

    }
#line 1483
    status = 58;
#line 1484
    bthci_EventPhysicalLinkComplete(padapter, status, 255, (int )PLH);
#line 1485
    return (status);
  } else {

  }
#line 1489
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen = *((u8 *)(& pHciCmd->Data) + 1UL);
#line 1490
  pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType = *((u8 *)(& pHciCmd->Data) + 2UL);
#line 1491
  __len = (size_t )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen;
#line 1491
  __ret = __builtin_memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
                           (void const   *)(& pHciCmd->Data) + 3U, __len);
#line 1493
  __len___0 = 32UL;
#line 1493
  if (__len___0 > 63UL) {
#line 1493
    __ret___0 = __memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK), (void const   *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
                         __len___0);
  } else {
#line 1493
    __ret___0 = __builtin_memcpy((void *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK),
                                 (void const   *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey),
                                 __len___0);
  }
#line 1494
  if (BTCoexDbgLevel == 1U) {
#line 1494
    printk("BuildPhysicalLink, EntryNum = %d, PLH = 0x%x  KeyLen = 0x%x, KeyType = 0x%x\n",
           (int )EntryNum, (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyType);
  } else {

  }
#line 1498
  if (BTCoexDbgLevel == 1U) {
#line 1498
    ptr = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKey);
#line 1498
    printk("BtAMPKey\n");
#line 1498
    __i = 0U;
#line 1498
    goto ldv_54755;
    ldv_54754: 
#line 1498
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 1498
    if (((__i + 1U) & 15U) == 0U) {
#line 1498
      printk("\n");
    } else {

    }
#line 1498
    __i = __i + 1U;
    ldv_54755: ;
#line 1498
    if ((u32 )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtAMPKeyLen > __i) {
#line 1500
      goto ldv_54754;
    } else {

    }
#line 1498
    printk("\n");
  } else {

  }
#line 1500
  if (BTCoexDbgLevel == 1U) {
#line 1500
    ptr___0 = (u8 *)(& pBTInfo->BtAsocEntry[(int )EntryNum].PMK);
#line 1500
    printk("PMK\n");
#line 1500
    __i___0 = 0U;
#line 1500
    goto ldv_54760;
    ldv_54759: 
#line 1500
    printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 1500
    if (((__i___0 + 1U) & 15U) == 0U) {
#line 1500
      printk("\n");
    } else {

    }
#line 1500
    __i___0 = __i___0 + 1U;
    ldv_54760: ;
#line 1500
    if (__i___0 <= 31U) {
#line 1502
      goto ldv_54759;
    } else {

    }
#line 1500
    printk("\n");
  } else {

  }
#line 1503
  if ((unsigned int )OCF == 53U) {
#line 1505
    if (BTCoexDbgLevel == 1U) {
#line 1505
      printk("[BT state change] caused by %s, line =%d\n", "bthci_BuildPhysicalLink",
             1505);
    } else {

    }
#line 1505
    BTHCI_StateMachine(padapter, 32, 0, (int )EntryNum);
  } else
#line 1506
  if ((unsigned int )OCF == 54U) {
#line 1507
    if (BTCoexDbgLevel == 1U) {
#line 1507
      printk("[BT state change] caused by %s, line =%d\n", "bthci_BuildPhysicalLink",
             1507);
    } else {

    }
#line 1507
    BTHCI_StateMachine(padapter, 32, 1, (int )EntryNum);
  } else {

  }
#line 1510
  return (status);
}
}
#line 1514 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_BuildLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                   u16 OCF ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  u16 AssignLogHandle ;
  struct hci_flow_spec TxFlowSpec ;
  struct hci_flow_spec RxFlowSpec ;
  u32 MaxSDUSize ;
  u32 ArriveTime ;
  u32 Bandwidth ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 i ;
  u8 find ;
  enum hci_status LogCompEventstatus ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;

  {
#line 1520
  status = 0;
#line 1521
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1522
  pBtMgnt = & pBTinfo->BtMgnt;
#line 1524
  AssignLogHandle = 1U;
#line 1530
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 1532
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
#line 1534
  __len = 16UL;
#line 1534
  if (__len > 63UL) {
#line 1534
    __ret = __memcpy((void *)(& TxFlowSpec), (void const   *)(& pHciCmd->Data) + 1U,
                     __len);
  } else {
#line 1534
    __ret = __builtin_memcpy((void *)(& TxFlowSpec), (void const   *)(& pHciCmd->Data) + 1U,
                             __len);
  }
#line 1536
  __len___0 = 16UL;
#line 1536
  if (__len___0 > 63UL) {
#line 1536
    __ret___0 = __memcpy((void *)(& RxFlowSpec), (void const   *)(& pHciCmd->Data) + 17U,
                         __len___0);
  } else {
#line 1536
    __ret___0 = __builtin_memcpy((void *)(& RxFlowSpec), (void const   *)(& pHciCmd->Data) + 17U,
                                 __len___0);
  }
#line 1539
  MaxSDUSize = (u32 )TxFlowSpec.MaximumSDUSize;
#line 1540
  ArriveTime = TxFlowSpec.SDUInterArrivalTime;
#line 1542
  tmp = bthci_CheckLogLinkBehavior(padapter, TxFlowSpec);
#line 1542
  if ((unsigned int )tmp != 0U) {
#line 1542
    tmp___0 = bthci_CheckLogLinkBehavior(padapter, RxFlowSpec);
#line 1542
    if ((unsigned int )tmp___0 != 0U) {
#line 1543
      Bandwidth = 30000U;
    } else {
#line 1542
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1544
  if (MaxSDUSize == 65535U && ArriveTime == 4294967295U) {
#line 1545
    Bandwidth = 30000U;
  } else {
#line 1547
    Bandwidth = (MaxSDUSize * 8000U) / (ArriveTime + 244U);
  }
#line 1549
  if (BTCoexDbgLevel == 1U) {
#line 1549
    printk("BuildLogicalLink, PhyLinkHandle = 0x%x, MaximumSDUSize = 0x%x, SDUInterArrivalTime = 0x%x, Bandwidth = 0x%x\n",
           (int )PhyLinkHandle, MaxSDUSize, ArriveTime, Bandwidth);
  } else {

  }
#line 1553
  if ((unsigned int )EntryNum == 255U) {
#line 1554
    if (BTCoexDbgLevel == 1U) {
#line 1554
      printk("Invalid Physical Link handle = 0x%x, status = HCI_STATUS_UNKNOW_CONNECT_ID, return\n",
             (int )PhyLinkHandle);
    } else {

    }
#line 1555
    status = 2;
#line 1558
    bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
#line 1562
    return;
  } else {

  }
#line 1565
  if ((unsigned int )pBtMgnt->bLogLinkInProgress == 0U) {
#line 1566
    tmp___1 = bthci_PhyLinkConnectionInProgress(padapter, (int )PhyLinkHandle);
#line 1566
    if ((unsigned int )tmp___1 != 0U) {
#line 1567
      if (BTCoexDbgLevel == 1U) {
#line 1567
        printk("Physical link connection in progress, status = HCI_STATUS_CMD_DISALLOW, return\n");
      } else {

      }
#line 1568
      status = 12;
#line 1570
      pBtMgnt->bPhyLinkInProgressStartLL = 1U;
#line 1572
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
#line 1577
      return;
    } else {

    }
#line 1580
    if (Bandwidth > 30000U) {
#line 1581
      if (BTCoexDbgLevel == 1U) {
#line 1581
        printk("status = HCI_STATUS_QOS_REJECT, Bandwidth = 0x%x, return\n", Bandwidth);
      } else {

      }
#line 1582
      status = 45;
#line 1585
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    } else {
#line 1590
      if (BTCoexDbgLevel == 1U) {
#line 1590
        printk("status = HCI_STATUS_SUCCESS\n");
      } else {

      }
#line 1591
      status = 0;
#line 1594
      bthci_EventCommandStatus(padapter, 1, (int )OCF, status);
    }
#line 1601
    if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].BtCurrentState != 8U) {
#line 1602
      bthci_EventLogicalLinkComplete(padapter, 12, 0, 0, 0, (int )EntryNum);
    } else {
#line 1605
      find = 0U;
#line 1607
      pBtMgnt->bLogLinkInProgress = 1U;
#line 1610
      i = 0U;
#line 1610
      goto ldv_54796;
      ldv_54795: ;
#line 1611
      if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle == 0U) {
#line 1612
        LogCompEventstatus = 0;
#line 1614
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle = *((u8 *)(& pHciCmd->Data));
#line 1615
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle = AssignLogHandle;
#line 1616
        if (BTCoexDbgLevel == 1U) {
#line 1616
          printk("BuildLogicalLink, EntryNum = %d, physical link handle = 0x%x, logical link handle = 0x%x\n",
                 (int )EntryNum, (int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle,
                 (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle);
        } else {

        }
#line 1619
        __len___1 = 16UL;
#line 1619
        if (__len___1 > 63UL) {
#line 1619
          __ret___1 = __memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                               (void const   *)(& TxFlowSpec), __len___1);
        } else {
#line 1619
          __ret___1 = __builtin_memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                                       (void const   *)(& TxFlowSpec), __len___1);
        }
#line 1621
        __len___2 = 16UL;
#line 1621
        if (__len___2 > 63UL) {
#line 1621
          __ret___2 = __memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                               (void const   *)(& RxFlowSpec), __len___2);
        } else {
#line 1621
          __ret___2 = __builtin_memcpy((void *)(& pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                                       (void const   *)(& RxFlowSpec), __len___2);
        }
#line 1624
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCompleteEventIsSet = 0U;
#line 1626
        if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCancelCMDIsSetandComplete != 0U) {
#line 1627
          LogCompEventstatus = 2;
        } else {

        }
#line 1628
        bthci_EventLogicalLinkComplete(padapter, LogCompEventstatus, (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle,
                                       (int )pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle,
                                       (int )i, (int )EntryNum);
#line 1633
        pBTinfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData[(int )i].bLLCompleteEventIsSet = 1U;
#line 1635
        find = 1U;
#line 1636
        pBtMgnt->BtCurrentLogLinkhandle = AssignLogHandle;
#line 1637
        AssignLogHandle = (u16 )((int )AssignLogHandle + 1);
#line 1638
        goto ldv_54794;
      } else {

      }
#line 1610
      i = (u8 )((int )i + 1);
      ldv_54796: ;
#line 1610
      if ((unsigned int )i <= 1U) {
#line 1612
        goto ldv_54795;
      } else {

      }
      ldv_54794: ;
#line 1642
      if ((unsigned int )find == 0U) {
#line 1643
        bthci_EventLogicalLinkComplete(padapter, 13, 0, 0, 0, (int )EntryNum);
      } else {

      }
#line 1646
      pBtMgnt->bLogLinkInProgress = 0U;
    }
  } else {
#line 1649
    bthci_EventLogicalLinkComplete(padapter, 58, 0, 0, 0, (int )EntryNum);
  }
#line 1650
  return;
}
}
#line 1656 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_StartBeaconAndConnect(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ,
                                        u8 CurrentAssocNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  u32 __i ;
  u8 buffer[64U] ;
  u32 length ;
  size_t __len ;
  void *__ret ;

  {
#line 1663
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1664
  pBtMgnt = & pBTInfo->BtMgnt;
#line 1666
  if (BTCoexDbgLevel == 1U) {
#line 1666
    printk("StartBeaconAndConnect, CurrentAssocNum =%d, AMPRole =%d\n", (int )CurrentAssocNum,
           (unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole);
  } else {

  }
#line 1670
  if ((unsigned int )pBtMgnt->CheckChnlIsSuit == 0U) {
#line 1671
    bthci_EventPhysicalLinkComplete(padapter, 57, (int )CurrentAssocNum, 255);
#line 1672
    bthci_RemoveEntryByEntryNum(padapter, (int )CurrentAssocNum);
#line 1673
    return;
  } else {

  }
#line 1676
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 1U) {
#line 1677
    snprintf((char *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf), 32UL,
             "AMP-%02x-%02x-%02x-%02x-%02x-%02x", (int )padapter->eeprompriv.mac_addr[0],
             (int )padapter->eeprompriv.mac_addr[1], (int )padapter->eeprompriv.mac_addr[2],
             (int )padapter->eeprompriv.mac_addr[3], (int )padapter->eeprompriv.mac_addr[4],
             (int )padapter->eeprompriv.mac_addr[5]);
  } else
#line 1684
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 2U) {
#line 1685
    snprintf((char *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf), 32UL,
             "AMP-%02x-%02x-%02x-%02x-%02x-%02x", (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[0],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[1],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[2],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[3],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[4],
             (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTRemoteMACAddr[5]);
  } else {

  }
#line 1694
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Octet = (u8 *)(& pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsidBuf);
#line 1694
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Length = 21U;
#line 1695
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].BTSsid.Length = 21U;
#line 1698
  if ((unsigned int )pBtMgnt->bBTConnectInProgress == 0U) {
#line 1699
    pBtMgnt->bBTConnectInProgress = 1U;
#line 1700
    if (BTCoexDbgLevel == 1U) {
#line 1700
      printk("[BT Flag], BT Connect in progress ON!!\n");
    } else {

    }
#line 1701
    if (BTCoexDbgLevel == 1U) {
#line 1701
      printk("[BT state change] caused by %s, line =%d\n", "bthci_StartBeaconAndConnect",
             1701);
    } else {

    }
#line 1701
    BTHCI_StateMachine(padapter, 1, 4, (int )CurrentAssocNum);
#line 1705
    tmp = bthci_CheckRfStateBeforeConnect(padapter);
#line 1705
    if ((unsigned int )tmp == 0U) {
#line 1706
      return;
    } else {

    }
#line 1708
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 1U) {
#line 1710
      if (BTCoexDbgLevel == 1U) {
#line 1710
        printk("[BT state change] caused by %s, line =%d\n", "bthci_StartBeaconAndConnect",
               1710);
      } else {

      }
#line 1710
      BTHCI_StateMachine(padapter, 2, 6, (int )CurrentAssocNum);
    } else
#line 1711
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AMPRole == 2U) {
#line 1712
      bthci_ResponderStartToScan(padapter);
    } else {

    }
  } else {

  }
#line 1715
  length = (unsigned int )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length <= 63U ? (u32 )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length : 63U;
#line 1715
  memset((void *)(& buffer), 0, 64UL);
#line 1715
  __len = (size_t )length;
#line 1715
  __ret = __builtin_memcpy((void *)(& buffer), (void const   *)pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Octet,
                           __len);
#line 1715
  __i = 0U;
#line 1715
  goto ldv_54812;
  ldv_54811: ;
#line 1715
  if ((unsigned int )buffer[__i] <= 31U || (unsigned int )buffer[__i] > 126U) {
#line 1715
    buffer[__i] = 63U;
  } else {

  }
#line 1715
  __i = __i + 1U;
  ldv_54812: ;
#line 1715
  if (__i < length) {
#line 1717
    goto ldv_54811;
  } else {

  }
#line 1715
  buffer[length] = 0U;
#line 1715
  printk("StartBeaconAndConnect, SSID:\n");
#line 1715
  printk(": %d, <%s>\n", (int )pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].BTSsid.Length,
         (u8 *)(& buffer));
#line 1717
  return;
}
}
#line 1721 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_ResetBtMgnt(struct bt_mgnt *pBtMgnt ) 
{ 


  {
#line 1723
  pBtMgnt->BtOperationOn = 0U;
#line 1724
  pBtMgnt->bBTConnectInProgress = 0U;
#line 1725
  pBtMgnt->bLogLinkInProgress = 0U;
#line 1726
  pBtMgnt->bPhyLinkInProgress = 0U;
#line 1727
  pBtMgnt->bPhyLinkInProgressStartLL = 0U;
#line 1728
  pBtMgnt->DisconnectEntryNum = 255U;
#line 1729
  pBtMgnt->bStartSendSupervisionPkt = 0U;
#line 1730
  pBtMgnt->JoinerNeedSendAuth = 0U;
#line 1731
  pBtMgnt->CurrentBTConnectionCnt = 0U;
#line 1732
  pBtMgnt->BTCurrentConnectType = 4;
#line 1733
  pBtMgnt->BTReceiveConnectPkt = 4;
#line 1734
  pBtMgnt->BTAuthCount = 0U;
#line 1735
  pBtMgnt->btLogoTest = 0U;
#line 1736
  return;
}
}
#line 1738 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_ResetBtHciInfo(struct bt_hci_info *pBtHciInfo ) 
{ 


  {
#line 1740
  pBtHciInfo->BTEventMask = 0ULL;
#line 1741
  pBtHciInfo->BTEventMaskPage2 = 0ULL;
#line 1742
  pBtHciInfo->ConnAcceptTimeout = 10000U;
#line 1743
  pBtHciInfo->PageTimeout = 48U;
#line 1744
  pBtHciInfo->LocationDomainAware = 0U;
#line 1745
  pBtHciInfo->LocationDomain = 22616U;
#line 1746
  pBtHciInfo->LocationDomainOptions = 88U;
#line 1747
  pBtHciInfo->LocationOptions = 0U;
#line 1748
  pBtHciInfo->FlowControlMode = 1U;
#line 1750
  pBtHciInfo->enFlush_LLH = 0U;
#line 1751
  pBtHciInfo->FLTO_LLH = 0U;
#line 1754
  pBtHciInfo->bTestIsEnd = 1U;
#line 1755
  pBtHciInfo->bInTestMode = 0U;
#line 1756
  pBtHciInfo->bTestNeedReport = 0U;
#line 1757
  pBtHciInfo->TestScenario = 255U;
#line 1758
  pBtHciInfo->TestReportInterval = 1U;
#line 1759
  pBtHciInfo->TestCtrType = 93U;
#line 1760
  pBtHciInfo->TestEventType = 0U;
#line 1761
  pBtHciInfo->TestNumOfFrame = 0U;
#line 1762
  pBtHciInfo->TestNumOfErrFrame = 0U;
#line 1763
  pBtHciInfo->TestNumOfBits = 0U;
#line 1764
  pBtHciInfo->TestNumOfErrBits = 0U;
#line 1765
  return;
}
}
#line 1767 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_ResetBtSec(struct rtw_adapter *padapter , struct bt_security *pBtSec ) 
{ 


  {
#line 1772
  if ((unsigned int )((struct hal_data_8723a *)padapter->HalData)->bBTMode != 0U) {
#line 1773
    pBtSec->bUsedHwEncrypt = 1U;
  } else {
#line 1775
    pBtSec->bUsedHwEncrypt = 0U;
  }
#line 1776
  if (GlobalDebugLevel23A > 6U) {
#line 1776
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 7);
#line 1776
    printk("\016%s: bUsedHwEncrypt =%d\n", "bthci_ResetBtSec", (int )pBtSec->bUsedHwEncrypt);
  } else {

  }
#line 1778
  pBtSec->RSNIE.Octet = (u8 *)(& pBtSec->RSNIEBuf);
#line 1779
  return;
}
}
#line 1781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_ResetBtExtInfo(struct bt_mgnt *pBtMgnt ) 
{ 
  u8 i ;

  {
#line 1785
  i = 0U;
#line 1785
  goto ldv_54830;
  ldv_54829: 
#line 1786
  pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = 0U;
#line 1787
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 0U;
#line 1788
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
#line 1789
  pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = 0U;
#line 1790
  pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = 4U;
#line 1791
  pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI = 0;
#line 1792
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = 0U;
#line 1793
  pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole = 0U;
#line 1785
  i = (u8 )((int )i + 1);
  ldv_54830: ;
#line 1785
  if ((unsigned int )i <= 1U) {
#line 1787
    goto ldv_54829;
  } else {

  }
#line 1796
  pBtMgnt->ExtConfig.CurrentConnectHandle = 0U;
#line 1797
  pBtMgnt->ExtConfig.CurrentIncomingTrafficMode = 0U;
#line 1798
  pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = 0U;
#line 1799
  pBtMgnt->ExtConfig.MIN_BT_RSSI = 0;
#line 1800
  pBtMgnt->ExtConfig.NumberOfHandle = 0U;
#line 1801
  pBtMgnt->ExtConfig.NumberOfSCO = 0U;
#line 1802
  pBtMgnt->ExtConfig.CurrentBTStatus = 0U;
#line 1803
  pBtMgnt->ExtConfig.HCIExtensionVer = 0U;
#line 1805
  pBtMgnt->ExtConfig.bManualControl = 0U;
#line 1806
  pBtMgnt->ExtConfig.bBTBusy = 0U;
#line 1807
  pBtMgnt->ExtConfig.bBTA2DPBusy = 0U;
#line 1808
  return;
}
}
#line 1810 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReset(struct rtw_adapter *_padapter , u8 bNeedSendEvent ) 
{ 
  enum hci_status status ;
  struct rtw_adapter *padapter ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_security *pBtSec ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 1812
  status = 0;
#line 1822
  if (BTCoexDbgLevel == 1U) {
#line 1822
    printk("bthci_CmdReset()\n");
  } else {

  }
#line 1824
  padapter = _padapter;
#line 1825
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1826
  pBtMgnt = & pBTInfo->BtMgnt;
#line 1827
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1828
  pBtSec = & pBTInfo->BtSec;
#line 1829
  pBtDbg = & pBTInfo->BtDbg;
#line 1831
  pBTInfo->padapter = padapter;
#line 1833
  i = 0U;
#line 1833
  goto ldv_54845;
  ldv_54844: 
#line 1834
  bthci_ResetEntry(padapter, (int )i);
#line 1833
  i = (u8 )((int )i + 1);
  ldv_54845: ;
#line 1833
  if ((unsigned int )i <= 1U) {
#line 1835
    goto ldv_54844;
  } else {

  }
#line 1836
  bthci_ResetBtMgnt(pBtMgnt);
#line 1837
  bthci_ResetBtHciInfo(pBtHciInfo);
#line 1838
  bthci_ResetBtSec(padapter, pBtSec);
#line 1840
  pBtMgnt->BTChannel = 10U;
#line 1841
  pBtMgnt->CheckChnlIsSuit = 1U;
#line 1843
  pBTInfo->BTBeaconTmrOn = 0U;
#line 1845
  pBtMgnt->bCreateSpportQos = 1U;
#line 1847
  ldv_del_timer_sync_2424(& pBTInfo->BTHCIDiscardAclDataTimer);
#line 1848
  ldv_del_timer_sync_2425(& pBTInfo->BTBeaconTimer);
#line 1850
  HALBT_SetRtsCtsNoLenLimit(padapter);
#line 1855
  bthci_ResetBtExtInfo(pBtMgnt);
#line 1858
  if ((unsigned int )bNeedSendEvent != 0U) {
#line 1859
    localBuf[0] = '\000';
#line 1859
    tmp = 1U;
#line 1859
    while (1) {
#line 1859
      if (tmp >= 6U) {
#line 1859
        break;
      } else {

      }
#line 1859
      localBuf[tmp] = (unsigned char)0;
#line 1859
      tmp = tmp + 1U;
    }
#line 1861
    len = 0U;
#line 1864
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1866
    tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 3, status);
#line 1866
    len = (int )tmp___0 + (int )len;
#line 1872
    pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1873
    *pRetPar = (u8 )status;
#line 1874
    len = (unsigned int )len + 1U;
#line 1875
    PPacketIrpEvent->Length = len;
#line 1877
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  } else {

  }
#line 1880
  return (status);
}
}
#line 1884 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWriteRemoteAMPAssoc(struct rtw_adapter *padapter ,
                                                    struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 CurrentAssocNum ;
  u8 PhyLinkHandle ;
  u32 __i ;
  u8 *ptr ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u32 __i___0 ;
  u8 *ptr___0 ;
  u8 tmp ;

  {
#line 1889
  status = 0;
#line 1890
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1891
  pBtDbg = & pBTInfo->BtDbg;
#line 1895
  pBtDbg->dbgHciInfo.hciCmdCntWriteRemoteAmpAssoc = pBtDbg->dbgHciInfo.hciCmdCntWriteRemoteAmpAssoc + 1U;
#line 1896
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 1897
  CurrentAssocNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
#line 1899
  if ((unsigned int )CurrentAssocNum == 255U) {
#line 1900
    if (BTCoexDbgLevel == 1U) {
#line 1900
      printk("WriteRemoteAMPAssoc, No such Handle in the Entry\n");
    } else {

    }
#line 1901
    status = 2;
#line 1902
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
#line 1903
    return (status);
  } else {

  }
#line 1906
  if ((unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment == (unsigned long )((void *)0)) {
#line 1907
    if (BTCoexDbgLevel == 1U) {
#line 1907
      printk("WriteRemoteAMPAssoc, AMP controller is busy\n");
    } else {

    }
#line 1908
    status = 58;
#line 1909
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
#line 1910
    return (status);
  } else {

  }
#line 1913
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.BtPhyLinkhandle = PhyLinkHandle;
#line 1914
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar = *((u16 *)(& pHciCmd->Data) + 1U);
#line 1915
  pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen = *((u16 *)(& pHciCmd->Data) + 3U);
#line 1917
  if (BTCoexDbgLevel == 1U) {
#line 1917
    printk("WriteRemoteAMPAssoc, LenSoFar = 0x%x, AssocRemLen = 0x%x\n", (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
           (int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen);
  } else {

  }
#line 1921
  if (BTCoexDbgLevel == 1U) {
#line 1921
    ptr = (u8 *)(& pHciCmd->Data);
#line 1921
    printk("WriteRemoteAMPAssoc fragment \n");
#line 1921
    __i = 0U;
#line 1921
    goto ldv_54863;
    ldv_54862: 
#line 1921
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 1921
    if (((__i + 1U) & 15U) == 0U) {
#line 1921
      printk("\n");
    } else {

    }
#line 1921
    __i = __i + 1U;
    ldv_54863: ;
#line 1921
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen + 5U > __i) {
#line 1923
      goto ldv_54862;
    } else {

    }
#line 1921
    printk("\n");
  } else {

  }
#line 1925
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen > 248U) {
#line 1926
    __len = 248UL;
#line 1926
    if (__len > 63UL) {
#line 1926
      __ret = __memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
                       (void const   *)(& pHciCmd->Data) + 5U, __len);
    } else {
#line 1926
      __ret = __builtin_memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
                               (void const   *)(& pHciCmd->Data) + 5U, __len);
    }
  } else {
#line 1930
    __len___0 = (size_t )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen;
#line 1930
    __ret___0 = __builtin_memcpy(pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocfragment + (unsigned long )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.LenSoFar,
                                 (void const   *)(& pHciCmd->Data) + 5U, __len___0);
#line 1934
    if (BTCoexDbgLevel == 1U) {
#line 1934
      ptr___0 = (u8 *)(& pHciCmd->Data) + 5UL;
#line 1934
      printk("WriteRemoteAMPAssoc :\n");
#line 1934
      __i___0 = 0U;
#line 1934
      goto ldv_54874;
      ldv_54873: 
#line 1934
      printk("%02X%s", (int )*(ptr___0 + (unsigned long )__i___0), ((__i___0 + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 1934
      if (((__i___0 + 1U) & 15U) == 0U) {
#line 1934
        printk("\n");
      } else {

      }
#line 1934
      __i___0 = __i___0 + 1U;
      ldv_54874: ;
#line 1934
      if ((u32 )pBTInfo->BtAsocEntry[(int )CurrentAssocNum].AmpAsocCmdData.AMPAssocRemLen > __i___0) {
#line 1936
        goto ldv_54873;
      } else {

      }
#line 1934
      printk("\n");
    } else {

    }
#line 1937
    tmp = bthci_GetAssocInfo(padapter, (int )CurrentAssocNum);
#line 1937
    if ((unsigned int )tmp == 0U) {
#line 1938
      status = 18;
    } else {

    }
#line 1940
    bthci_EventWriteRemoteAmpAssoc(padapter, status, (int )PhyLinkHandle);
#line 1942
    bthci_StartBeaconAndConnect(padapter, pHciCmd, (int )CurrentAssocNum);
  }
#line 1945
  return (status);
}
}
#line 1949 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadConnectionAcceptTimeout(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 1951
  status = 0;
#line 1953
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 1954
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 1955
  localBuf[0] = '\000';
#line 1955
  tmp = 1U;
#line 1955
  while (1) {
#line 1955
    if (tmp >= 8U) {
#line 1955
      break;
    } else {

    }
#line 1955
    localBuf[tmp] = (unsigned char)0;
#line 1955
    tmp = tmp + 1U;
  }
#line 1957
  len = 0U;
#line 1961
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 1963
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 21, status);
#line 1963
  len = (int )tmp___0 + (int )len;
#line 1969
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 1970
  *pRetPar = (u8 )status;
#line 1971
  pu2Temp = (u16 *)pRetPar + 1U;
#line 1972
  *pu2Temp = pBtHciInfo->ConnAcceptTimeout;
#line 1973
  len = (unsigned int )len + 3U;
#line 1974
  PPacketIrpEvent->Length = len;
#line 1976
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 1978
  return (status);
}
}
#line 1983 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdSetEventFilter(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 1988
  status = 0;
#line 1990
  return (status);
}
}
#line 1995 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWriteConnectionAcceptTimeout(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2000
  status = 0;
#line 2001
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2002
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2004
  localBuf[0] = '\000';
#line 2004
  tmp = 1U;
#line 2004
  while (1) {
#line 2004
    if (tmp >= 6U) {
#line 2004
      break;
    } else {

    }
#line 2004
    localBuf[tmp] = (unsigned char)0;
#line 2004
    tmp = tmp + 1U;
  }
#line 2006
  len = 0U;
#line 2009
  pu2Temp = (u16 *)(& pHciCmd->Data);
#line 2010
  pBtHciInfo->ConnAcceptTimeout = *pu2Temp;
#line 2011
  if (BTCoexDbgLevel == 1U) {
#line 2011
    printk("ConnAcceptTimeout = 0x%x", (int )pBtHciInfo->ConnAcceptTimeout);
  } else {

  }
#line 2015
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2017
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 22, status);
#line 2017
  len = (int )tmp___0 + (int )len;
#line 2023
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2024
  *pRetPar = (u8 )status;
#line 2025
  len = (unsigned int )len + 1U;
#line 2026
  PPacketIrpEvent->Length = len;
#line 2028
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2030
  return (status);
}
}
#line 2034 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadPageTimeout(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2039
  status = 0;
#line 2040
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2041
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2042
  localBuf[0] = '\000';
#line 2042
  tmp = 1U;
#line 2042
  while (1) {
#line 2042
    if (tmp >= 8U) {
#line 2042
      break;
    } else {

    }
#line 2042
    localBuf[tmp] = (unsigned char)0;
#line 2042
    tmp = tmp + 1U;
  }
#line 2044
  len = 0U;
#line 2048
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2050
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 23, status);
#line 2050
  len = (int )tmp___0 + (int )len;
#line 2055
  if (BTCoexDbgLevel == 1U) {
#line 2055
    printk("Read PageTimeout = 0x%x\n", (int )pBtHciInfo->PageTimeout);
  } else {

  }
#line 2057
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2058
  *pRetPar = (u8 )status;
#line 2059
  pu2Temp = (u16 *)pRetPar + 1U;
#line 2060
  *pu2Temp = pBtHciInfo->PageTimeout;
#line 2061
  len = (unsigned int )len + 3U;
#line 2062
  PPacketIrpEvent->Length = len;
#line 2064
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2066
  return (status);
}
}
#line 2070 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWritePageTimeout(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2075
  status = 0;
#line 2076
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2077
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2080
  pu2Temp = (u16 *)(& pHciCmd->Data);
#line 2081
  pBtHciInfo->PageTimeout = *pu2Temp;
#line 2082
  if (BTCoexDbgLevel == 1U) {
#line 2082
    printk("Write PageTimeout = 0x%x\n", (int )pBtHciInfo->PageTimeout);
  } else {

  }
#line 2087
  localBuf[0] = '\000';
#line 2087
  tmp = 1U;
#line 2087
  while (1) {
#line 2087
    if (tmp >= 6U) {
#line 2087
      break;
    } else {

    }
#line 2087
    localBuf[tmp] = (unsigned char)0;
#line 2087
    tmp = tmp + 1U;
  }
#line 2089
  len = 0U;
#line 2092
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2094
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 24, status);
#line 2094
  len = (int )tmp___0 + (int )len;
#line 2100
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2101
  *pRetPar = (u8 )status;
#line 2102
  len = (unsigned int )len + 1U;
#line 2103
  PPacketIrpEvent->Length = len;
#line 2105
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2108
  return (status);
}
}
#line 2112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadLinkSupervisionTimeout(struct rtw_adapter *padapter ,
                                                           struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 physicalLinkHandle ;
  u8 EntryNum ;
  u8 localBuf[10U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2117
  status = 0;
#line 2118
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2121
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 2123
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )physicalLinkHandle);
#line 2125
  if ((unsigned int )EntryNum == 255U) {
#line 2126
    if (BTCoexDbgLevel == 1U) {
#line 2126
      printk("ReadLinkSupervisionTimeout, No such Handle in the Entry\n");
    } else {

    }
#line 2127
    status = 2;
#line 2128
    return (status);
  } else {

  }
#line 2131
  if ((int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle != (int )physicalLinkHandle) {
#line 2132
    status = 2;
  } else {

  }
#line 2135
  localBuf[0] = '\000';
#line 2135
  tmp = 1U;
#line 2135
  while (1) {
#line 2135
    if (tmp >= 10U) {
#line 2135
      break;
    } else {

    }
#line 2135
    localBuf[tmp] = (unsigned char)0;
#line 2135
    tmp = tmp + 1U;
  }
#line 2137
  len = 0U;
#line 2141
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2143
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 54, status);
#line 2143
  len = (int )tmp___0 + (int )len;
#line 2149
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2150
  *pRetPar = (u8 )status;
#line 2151
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 2152
  *(pRetPar + 2UL) = 0U;
#line 2153
  pu2Temp = (u16 *)pRetPar + 3U;
#line 2154
  *pu2Temp = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout;
#line 2155
  len = (unsigned int )len + 5U;
#line 2156
  PPacketIrpEvent->Length = len;
#line 2158
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2161
  return (status);
}
}
#line 2165 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWriteLinkSupervisionTimeout(struct rtw_adapter *padapter ,
                                                            struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 physicalLinkHandle ;
  u8 EntryNum ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2170
  status = 0;
#line 2171
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2174
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 2176
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )physicalLinkHandle);
#line 2178
  if ((unsigned int )EntryNum == 255U) {
#line 2179
    if (BTCoexDbgLevel == 1U) {
#line 2179
      printk("WriteLinkSupervisionTimeout, No such Handle in the Entry\n");
    } else {

    }
#line 2180
    status = 2;
  } else
#line 2182
  if ((int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle != (int )physicalLinkHandle) {
#line 2183
    status = 2;
  } else {
#line 2185
    pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout = *((u16 *)(& pHciCmd->Data) + 2U);
#line 2186
    if (BTCoexDbgLevel == 1U) {
#line 2186
      printk("BT Write LinkSuperversionTimeout[%d] = 0x%x\n", (int )EntryNum, (int )pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.LinkSuperversionTimeout);
    } else {

    }
  }
#line 2192
  localBuf[0] = '\000';
#line 2192
  tmp = 1U;
#line 2192
  while (1) {
#line 2192
    if (tmp >= 8U) {
#line 2192
      break;
    } else {

    }
#line 2192
    localBuf[tmp] = (unsigned char)0;
#line 2192
    tmp = tmp + 1U;
  }
#line 2194
  len = 0U;
#line 2197
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2199
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 55, status);
#line 2199
  len = (int )tmp___0 + (int )len;
#line 2205
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2206
  *pRetPar = (u8 )status;
#line 2207
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 2208
  *(pRetPar + 2UL) = 0U;
#line 2209
  len = (unsigned int )len + 3U;
#line 2210
  PPacketIrpEvent->Length = len;
#line 2212
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2215
  return (status);
}
}
#line 2219 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdEnhancedFlush(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 logicHandle ;
  u8 Packet_Type ;
  u8 tmp ;

  {
#line 2224
  status = 0;
#line 2225
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2226
  pBtHciInfo = & pBTinfo->BtHciInfo;
#line 2230
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 2231
  Packet_Type = pHciCmd->Data[2];
#line 2233
  if ((unsigned int )Packet_Type != 0U) {
#line 2234
    status = 18;
  } else {
#line 2236
    pBtHciInfo->enFlush_LLH = logicHandle;
  }
#line 2238
  tmp = bthci_DiscardTxPackets(padapter, (int )pBtHciInfo->enFlush_LLH);
#line 2238
  if ((unsigned int )tmp != 0U) {
#line 2239
    bthci_EventFlushOccurred(padapter, (int )pBtHciInfo->enFlush_LLH);
  } else {

  }
#line 2242
  bthci_EventCommandStatus(padapter, 3, 95, status);
#line 2247
  if ((unsigned int )pBtHciInfo->enFlush_LLH != 0U) {
#line 2248
    bthci_EventEnhancedFlushComplete(padapter, (int )pBtHciInfo->enFlush_LLH);
#line 2249
    pBtHciInfo->enFlush_LLH = 0U;
  } else {

  }
#line 2252
  return (status);
}
}
#line 2256 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadLogicalLinkAcceptTimeout(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2261
  status = 0;
#line 2263
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2264
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2265
  localBuf[0] = '\000';
#line 2265
  tmp = 1U;
#line 2265
  while (1) {
#line 2265
    if (tmp >= 8U) {
#line 2265
      break;
    } else {

    }
#line 2265
    localBuf[tmp] = (unsigned char)0;
#line 2265
    tmp = tmp + 1U;
  }
#line 2267
  len = 0U;
#line 2271
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2273
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 97, status);
#line 2273
  len = (int )tmp___0 + (int )len;
#line 2279
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2280
  *pRetPar = (u8 )status;
#line 2282
  pu2Temp = (u16 *)pRetPar + 1U;
#line 2283
  *pu2Temp = pBtHciInfo->LogicalAcceptTimeout;
#line 2284
  len = (unsigned int )len + 3U;
#line 2285
  PPacketIrpEvent->Length = len;
#line 2287
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2289
  return (status);
}
}
#line 2293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWriteLogicalLinkAcceptTimeout(struct rtw_adapter *padapter ,
                                                              struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2298
  status = 0;
#line 2300
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2301
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2302
  localBuf[0] = '\000';
#line 2302
  tmp = 1U;
#line 2302
  while (1) {
#line 2302
    if (tmp >= 6U) {
#line 2302
      break;
    } else {

    }
#line 2302
    localBuf[tmp] = (unsigned char)0;
#line 2302
    tmp = tmp + 1U;
  }
#line 2304
  len = 0U;
#line 2307
  pBtHciInfo->LogicalAcceptTimeout = *((u16 *)(& pHciCmd->Data));
#line 2309
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2311
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 98, status);
#line 2311
  len = (int )tmp___0 + (int )len;
#line 2317
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2318
  *pRetPar = (u8 )status;
#line 2320
  len = (unsigned int )len + 1U;
#line 2321
  PPacketIrpEvent->Length = len;
#line 2323
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2324
  return (status);
}
}
#line 2328 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdSetEventMask(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 *pu8Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2333
  status = 0;
#line 2335
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2336
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2338
  localBuf[0] = '\000';
#line 2338
  tmp = 1U;
#line 2338
  while (1) {
#line 2338
    if (tmp >= 6U) {
#line 2338
      break;
    } else {

    }
#line 2338
    localBuf[tmp] = (unsigned char)0;
#line 2338
    tmp = tmp + 1U;
  }
#line 2340
  len = 0U;
#line 2343
  pu8Temp = (u8 *)(& pHciCmd->Data);
#line 2344
  pBtHciInfo->BTEventMask = (u64 )*pu8Temp;
#line 2345
  if (BTCoexDbgLevel == 1U) {
#line 2345
    printk("BTEventMask = 0x%llx\n", pBtHciInfo->BTEventMask);
  } else {

  }
#line 2349
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2351
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 1, status);
#line 2351
  len = (int )tmp___0 + (int )len;
#line 2357
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2358
  *pRetPar = (u8 )status;
#line 2359
  len = (unsigned int )len + 1U;
#line 2360
  PPacketIrpEvent->Length = len;
#line 2362
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2364
  return (status);
}
}
#line 2369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdSetEventMaskPage2(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 *pu8Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2374
  status = 0;
#line 2375
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2376
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2378
  localBuf[0] = '\000';
#line 2378
  tmp = 1U;
#line 2378
  while (1) {
#line 2378
    if (tmp >= 6U) {
#line 2378
      break;
    } else {

    }
#line 2378
    localBuf[tmp] = (unsigned char)0;
#line 2378
    tmp = tmp + 1U;
  }
#line 2380
  len = 0U;
#line 2383
  pu8Temp = (u8 *)(& pHciCmd->Data);
#line 2384
  pBtHciInfo->BTEventMaskPage2 = (u64 )*pu8Temp;
#line 2385
  if (BTCoexDbgLevel == 1U) {
#line 2385
    printk("BTEventMaskPage2 = 0x%llx\n", pBtHciInfo->BTEventMaskPage2);
  } else {

  }
#line 2389
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2391
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 99, status);
#line 2391
  len = (int )tmp___0 + (int )len;
#line 2397
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2398
  *pRetPar = (u8 )status;
#line 2399
  len = (unsigned int )len + 1U;
#line 2400
  PPacketIrpEvent->Length = len;
#line 2402
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2404
  return (status);
}
}
#line 2408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadLocationData(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[12U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2413
  status = 0;
#line 2414
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2415
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2416
  localBuf[0] = '\000';
#line 2416
  tmp = 1U;
#line 2416
  while (1) {
#line 2416
    if (tmp >= 12U) {
#line 2416
      break;
    } else {

    }
#line 2416
    localBuf[tmp] = (unsigned char)0;
#line 2416
    tmp = tmp + 1U;
  }
#line 2418
  len = 0U;
#line 2422
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2424
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 100, status);
#line 2424
  len = (int )tmp___0 + (int )len;
#line 2428
  if (BTCoexDbgLevel == 1U) {
#line 2428
    printk("DomainAware = 0x%x\n", (int )pBtHciInfo->LocationDomainAware);
  } else {

  }
#line 2429
  if (BTCoexDbgLevel == 1U) {
#line 2429
    printk("Domain = 0x%x\n", (int )pBtHciInfo->LocationDomain);
  } else {

  }
#line 2430
  if (BTCoexDbgLevel == 1U) {
#line 2430
    printk("DomainOptions = 0x%x\n", (int )pBtHciInfo->LocationDomainOptions);
  } else {

  }
#line 2431
  if (BTCoexDbgLevel == 1U) {
#line 2431
    printk("Options = 0x%x\n", (int )pBtHciInfo->LocationOptions);
  } else {

  }
#line 2434
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2435
  *pRetPar = (u8 )status;
#line 2437
  *(pRetPar + 1UL) = pBtHciInfo->LocationDomainAware;
#line 2438
  pu2Temp = (u16 *)pRetPar + 2U;
#line 2439
  *pu2Temp = pBtHciInfo->LocationDomain;
#line 2440
  *(pRetPar + 4UL) = pBtHciInfo->LocationDomainOptions;
#line 2441
  *(pRetPar + 5UL) = pBtHciInfo->LocationOptions;
#line 2442
  len = (unsigned int )len + 6U;
#line 2443
  PPacketIrpEvent->Length = len;
#line 2445
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2446
  return (status);
}
}
#line 2450 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWriteLocationData(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 *pu2Temp ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2455
  status = 0;
#line 2456
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2457
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2459
  localBuf[0] = '\000';
#line 2459
  tmp = 1U;
#line 2459
  while (1) {
#line 2459
    if (tmp >= 6U) {
#line 2459
      break;
    } else {

    }
#line 2459
    localBuf[tmp] = (unsigned char)0;
#line 2459
    tmp = tmp + 1U;
  }
#line 2461
  len = 0U;
#line 2464
  pBtHciInfo->LocationDomainAware = pHciCmd->Data[0];
#line 2465
  pu2Temp = (u16 *)(& pHciCmd->Data) + 1U;
#line 2466
  pBtHciInfo->LocationDomain = *pu2Temp;
#line 2467
  pBtHciInfo->LocationDomainOptions = pHciCmd->Data[3];
#line 2468
  pBtHciInfo->LocationOptions = pHciCmd->Data[4];
#line 2469
  if (BTCoexDbgLevel == 1U) {
#line 2469
    printk("DomainAware = 0x%x\n", (int )pBtHciInfo->LocationDomainAware);
  } else {

  }
#line 2470
  if (BTCoexDbgLevel == 1U) {
#line 2470
    printk("Domain = 0x%x\n", (int )pBtHciInfo->LocationDomain);
  } else {

  }
#line 2471
  if (BTCoexDbgLevel == 1U) {
#line 2471
    printk("DomainOptions = 0x%x\n", (int )pBtHciInfo->LocationDomainOptions);
  } else {

  }
#line 2472
  if (BTCoexDbgLevel == 1U) {
#line 2472
    printk("Options = 0x%x\n", (int )pBtHciInfo->LocationOptions);
  } else {

  }
#line 2475
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2477
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 101, status);
#line 2477
  len = (int )tmp___0 + (int )len;
#line 2483
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2484
  *pRetPar = (u8 )status;
#line 2485
  len = (unsigned int )len + 1U;
#line 2486
  PPacketIrpEvent->Length = len;
#line 2488
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2490
  return (status);
}
}
#line 2494 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadFlowControlMode(struct rtw_adapter *padapter ,
                                                    struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2499
  status = 0;
#line 2500
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2501
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2502
  localBuf[0] = '\000';
#line 2502
  tmp = 1U;
#line 2502
  while (1) {
#line 2502
    if (tmp >= 7U) {
#line 2502
      break;
    } else {

    }
#line 2502
    localBuf[tmp] = (unsigned char)0;
#line 2502
    tmp = tmp + 1U;
  }
#line 2504
  len = 0U;
#line 2507
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2509
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 102, status);
#line 2509
  len = (int )tmp___0 + (int )len;
#line 2515
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2516
  *pRetPar = (u8 )status;
#line 2517
  *(pRetPar + 1UL) = pBtHciInfo->FlowControlMode;
#line 2518
  len = (unsigned int )len + 2U;
#line 2519
  PPacketIrpEvent->Length = len;
#line 2521
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2522
  return (status);
}
}
#line 2526 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWriteFlowControlMode(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2531
  status = 0;
#line 2532
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2533
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2534
  localBuf[0] = '\000';
#line 2534
  tmp = 1U;
#line 2534
  while (1) {
#line 2534
    if (tmp >= 6U) {
#line 2534
      break;
    } else {

    }
#line 2534
    localBuf[tmp] = (unsigned char)0;
#line 2534
    tmp = tmp + 1U;
  }
#line 2536
  len = 0U;
#line 2539
  pBtHciInfo->FlowControlMode = pHciCmd->Data[0];
#line 2542
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2544
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 103, status);
#line 2544
  len = (int )tmp___0 + (int )len;
#line 2550
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2551
  *pRetPar = (u8 )status;
#line 2552
  len = (unsigned int )len + 1U;
#line 2553
  PPacketIrpEvent->Length = len;
#line 2555
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2557
  return (status);
}
}
#line 2561 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadBestEffortFlushTimeout(struct rtw_adapter *padapter ,
                                                           struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u16 i ;
  u16 j ;
  u16 logicHandle ;
  u32 BestEffortFlushTimeout ;
  u8 find ;
  u8 localBuf[10U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u32 *pu4Temp ;
  u8 tmp___0 ;

  {
#line 2566
  status = 0;
#line 2567
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2569
  BestEffortFlushTimeout = 4294967295U;
#line 2570
  find = 0U;
#line 2572
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 2574
  j = 0U;
#line 2574
  goto ldv_55070;
  ldv_55069: 
#line 2575
  i = 0U;
#line 2575
  goto ldv_55068;
  ldv_55067: ;
#line 2576
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
#line 2577
    BestEffortFlushTimeout = pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BestEffortFlushTimeout;
#line 2578
    find = 1U;
#line 2579
    goto ldv_55066;
  } else {

  }
#line 2575
  i = (u16 )((int )i + 1);
  ldv_55068: ;
#line 2575
  if ((unsigned int )i <= 1U) {
#line 2577
    goto ldv_55067;
  } else {

  }
  ldv_55066: 
#line 2574
  j = (u16 )((int )j + 1);
  ldv_55070: ;
#line 2574
  if ((unsigned int )j <= 1U) {
#line 2576
    goto ldv_55069;
  } else {

  }

#line 2584
  if ((unsigned int )find == 0U) {
#line 2585
    status = 2;
  } else {

  }
#line 2588
  localBuf[0] = '\000';
#line 2588
  tmp = 1U;
#line 2588
  while (1) {
#line 2588
    if (tmp >= 10U) {
#line 2588
      break;
    } else {

    }
#line 2588
    localBuf[tmp] = (unsigned char)0;
#line 2588
    tmp = tmp + 1U;
  }
#line 2590
  len = 0U;
#line 2594
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2596
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 105, status);
#line 2596
  len = (int )tmp___0 + (int )len;
#line 2602
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2603
  *pRetPar = (u8 )status;
#line 2604
  pu4Temp = (u32 *)pRetPar + 1U;
#line 2605
  *pu4Temp = BestEffortFlushTimeout;
#line 2606
  len = (unsigned int )len + 5U;
#line 2607
  PPacketIrpEvent->Length = len;
#line 2609
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2611
  return (status);
}
}
#line 2615 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWriteBestEffortFlushTimeout(struct rtw_adapter *padapter ,
                                                            struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u16 i ;
  u16 j ;
  u16 logicHandle ;
  u32 BestEffortFlushTimeout ;
  u8 find ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2620
  status = 0;
#line 2621
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2623
  BestEffortFlushTimeout = 4294967295U;
#line 2624
  find = 0U;
#line 2626
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 2627
  BestEffortFlushTimeout = *((u32 *)(& pHciCmd->Data) + 1U);
#line 2630
  j = 0U;
#line 2630
  goto ldv_55092;
  ldv_55091: 
#line 2631
  i = 0U;
#line 2631
  goto ldv_55090;
  ldv_55089: ;
#line 2632
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
#line 2633
    pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BestEffortFlushTimeout = BestEffortFlushTimeout;
#line 2634
    find = 1U;
#line 2635
    goto ldv_55088;
  } else {

  }
#line 2631
  i = (u16 )((int )i + 1);
  ldv_55090: ;
#line 2631
  if ((unsigned int )i <= 1U) {
#line 2633
    goto ldv_55089;
  } else {

  }
  ldv_55088: 
#line 2630
  j = (u16 )((int )j + 1);
  ldv_55092: ;
#line 2630
  if ((unsigned int )j <= 1U) {
#line 2632
    goto ldv_55091;
  } else {

  }

#line 2640
  if ((unsigned int )find == 0U) {
#line 2641
    status = 2;
  } else {

  }
#line 2644
  localBuf[0] = '\000';
#line 2644
  tmp = 1U;
#line 2644
  while (1) {
#line 2644
    if (tmp >= 6U) {
#line 2644
      break;
    } else {

    }
#line 2644
    localBuf[tmp] = (unsigned char)0;
#line 2644
    tmp = tmp + 1U;
  }
#line 2646
  len = 0U;
#line 2649
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2651
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 106, status);
#line 2651
  len = (int )tmp___0 + (int )len;
#line 2657
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2658
  *pRetPar = (u8 )status;
#line 2659
  len = (unsigned int )len + 1U;
#line 2660
  PPacketIrpEvent->Length = len;
#line 2662
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2664
  return (status);
}
}
#line 2668 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdShortRangeMode(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  u8 ShortRangeMode ;

  {
#line 2673
  status = 0;
#line 2674
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2677
  PhyLinkHandle = pHciCmd->Data[0];
#line 2678
  ShortRangeMode = pHciCmd->Data[1];
#line 2679
  if (BTCoexDbgLevel == 1U) {
#line 2679
    printk("PLH = 0x%x, Short_Range_Mode = 0x%x\n", (int )PhyLinkHandle, (int )ShortRangeMode);
  } else {

  }
#line 2681
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
#line 2682
  if ((unsigned int )EntryNum != 255U) {
#line 2683
    pBTInfo->BtAsocEntry[(int )EntryNum].ShortRangeMode = ShortRangeMode;
  } else {
#line 2685
    if (BTCoexDbgLevel == 1U) {
#line 2685
      printk("No such PLH(0x%x)\n", (int )PhyLinkHandle);
    } else {

    }
#line 2686
    status = 2;
  }
#line 2689
  bthci_EventCommandStatus(padapter, 3, 107, status);
#line 2694
  bthci_EventShortRangeModeChangeComplete(padapter, status, (int )ShortRangeMode,
                                          (int )EntryNum);
#line 2696
  return (status);
}
}
#line 2699 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadLocalSupportedCommands(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pSupportedCmds ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2701
  status = 0;
#line 2702
  localBuf[0] = '\000';
#line 2702
  tmp = 1U;
#line 2702
  while (1) {
#line 2702
    if (tmp >= 256U) {
#line 2702
      break;
    } else {

    }
#line 2702
    localBuf[tmp] = (unsigned char)0;
#line 2702
    tmp = tmp + 1U;
  }
#line 2704
  len = 0U;
#line 2708
  memset((void *)(& localBuf), 0, 256UL);
#line 2709
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2711
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 2, status);
#line 2711
  len = (int )tmp___0 + (int )len;
#line 2717
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2718
  *pRetPar = (u8 )status;
#line 2719
  len = (unsigned int )len + 1U;
#line 2720
  pSupportedCmds = pRetPar + 1UL;
#line 2721
  if (BTCoexDbgLevel == 1U) {
#line 2721
    printk("Octet[5]= 0xc0\nBit [6]= Set Event Mask, [7]= Reset\n");
  } else {

  }
#line 2722
  *(pSupportedCmds + 5UL) = 192U;
#line 2723
  if (BTCoexDbgLevel == 1U) {
#line 2723
    printk("Octet[6]= 0x01\nBit [0]= Set Event Filter\n");
  } else {

  }
#line 2724
  *(pSupportedCmds + 6UL) = 1U;
#line 2725
  if (BTCoexDbgLevel == 1U) {
#line 2725
    printk("Octet[7]= 0x0c\nBit [2]= Read Connection Accept Timeout, [3]= Write Connection Accept Timeout\n");
  } else {

  }
#line 2726
  *(pSupportedCmds + 7UL) = 12U;
#line 2727
  if (BTCoexDbgLevel == 1U) {
#line 2727
    printk("Octet[10]= 0x80\nBit [7]= Host Number Of Completed Packets\n");
  } else {

  }
#line 2728
  *(pSupportedCmds + 10UL) = 128U;
#line 2729
  if (BTCoexDbgLevel == 1U) {
#line 2729
    printk("Octet[11]= 0x03\nBit [0]= Read Link Supervision Timeout, [1]= Write Link Supervision Timeout\n");
  } else {

  }
#line 2730
  *(pSupportedCmds + 11UL) = 3U;
#line 2731
  if (BTCoexDbgLevel == 1U) {
#line 2731
    printk("Octet[14]= 0xa8\nBit [3]= Read Local Version Information, [5]= Read Local Supported Features, [7]= Read Buffer Size\n");
  } else {

  }
#line 2732
  *(pSupportedCmds + 14UL) = 168U;
#line 2733
  if (BTCoexDbgLevel == 1U) {
#line 2733
    printk("Octet[15]= 0x1c\nBit [2]= Read Failed Contact Count, [3]= Reset Failed Contact Count, [4]= Get Link Quality\n");
  } else {

  }
#line 2734
  *(pSupportedCmds + 15UL) = 28U;
#line 2736
  if (BTCoexDbgLevel == 1U) {
#line 2736
    printk("Octet[19]= 0x40\nBit [6]= Enhanced Flush\n");
  } else {

  }
#line 2737
  *(pSupportedCmds + 19UL) = 64U;
#line 2738
  if (BTCoexDbgLevel == 1U) {
#line 2738
    printk("Octet[21]= 0xff\nBit [0]= Create Physical Link, [1]= Accept Physical Link, [2]= Disconnect Physical Link, [3]= Create Logical Link\n");
  } else {

  }
#line 2739
  if (BTCoexDbgLevel == 1U) {
#line 2739
    printk("\t[4]= Accept Logical Link, [5]= Disconnect Logical Link, [6]= Logical Link Cancel, [7]= Flow Spec Modify\n");
  } else {

  }
#line 2740
  *(pSupportedCmds + 21UL) = 255U;
#line 2741
  if (BTCoexDbgLevel == 1U) {
#line 2741
    printk("Octet[22]= 0xff\nBit [0]= Read Logical Link Accept Timeout, [1]= Write Logical Link Accept Timeout, [2]= Set Event Mask Page 2, [3]= Read Location Data\n");
  } else {

  }
#line 2742
  if (BTCoexDbgLevel == 1U) {
#line 2742
    printk("\t[4]= Write Location Data, [5]= Read Local AMP Info, [6]= Read Local AMP_ASSOC, [7]= Write Remote AMP_ASSOC\n");
  } else {

  }
#line 2743
  *(pSupportedCmds + 22UL) = 255U;
#line 2744
  if (BTCoexDbgLevel == 1U) {
#line 2744
    printk("Octet[23]= 0x07\nBit [0]= Read Flow Control Mode, [1]= Write Flow Control Mode, [2]= Read Data Block Size\n");
  } else {

  }
#line 2745
  *(pSupportedCmds + 23UL) = 7U;
#line 2746
  if (BTCoexDbgLevel == 1U) {
#line 2746
    printk("Octet[24]= 0x1c\nBit [2]= Read Best Effort Flush Timeout, [3]= Write Best Effort Flush Timeout, [4]= Short Range Mode\n");
  } else {

  }
#line 2747
  *(pSupportedCmds + 24UL) = 28U;
#line 2748
  len = (unsigned int )len + 64U;
#line 2749
  PPacketIrpEvent->Length = len;
#line 2751
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2753
  return (status);
}
}
#line 2756 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadLocalSupportedFeatures(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2758
  status = 0;
#line 2759
  localBuf[0] = '\000';
#line 2759
  tmp = 1U;
#line 2759
  while (1) {
#line 2759
    if (tmp >= 256U) {
#line 2759
      break;
    } else {

    }
#line 2759
    localBuf[tmp] = (unsigned char)0;
#line 2759
    tmp = tmp + 1U;
  }
#line 2761
  len = 0U;
#line 2765
  memset((void *)(& localBuf), 0, 256UL);
#line 2766
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2768
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 3, status);
#line 2768
  len = (int )tmp___0 + (int )len;
#line 2774
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2775
  *pRetPar = (u8 )status;
#line 2776
  len = (unsigned int )len + 9U;
#line 2777
  PPacketIrpEvent->Length = len;
#line 2779
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2780
  return (status);
}
}
#line 2783 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadLocalAMPAssoc(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 PhyLinkHandle ;
  u8 EntryNum ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u16 *pRemainLen ;
  u32 totalLen ;
  u16 typeLen ;
  u16 remainLen ;
  u16 ret_index ;
  u8 *pRetPar ;
  u8 tmp___0 ;
  u32 __i ;
  u8 *ptr ;

  {
#line 2786
  status = 0;
#line 2787
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2788
  pBtMgnt = & pBTInfo->BtMgnt;
#line 2789
  pBtDbg = & pBTInfo->BtDbg;
#line 2792
  pBtDbg->dbgHciInfo.hciCmdCntReadLocalAmpAssoc = pBtDbg->dbgHciInfo.hciCmdCntReadLocalAmpAssoc + 1U;
#line 2793
  PhyLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 2794
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )PhyLinkHandle);
#line 2796
  if ((unsigned int )EntryNum == 255U && (unsigned int )PhyLinkHandle != 0U) {
#line 2797
    if (BTCoexDbgLevel == 1U) {
#line 2797
      printk("ReadLocalAMPAssoc, EntryNum = %d  !!!!!, physical link handle = 0x%x\n",
             (int )EntryNum, (int )PhyLinkHandle);
    } else {

    }
#line 2799
    status = 2;
  } else
#line 2800
  if ((unsigned int )pBtMgnt->bPhyLinkInProgressStartLL != 0U) {
#line 2801
    status = 2;
#line 2802
    pBtMgnt->bPhyLinkInProgressStartLL = 0U;
  } else {
#line 2804
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.BtPhyLinkhandle = *((u8 *)(& pHciCmd->Data));
#line 2805
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar = *((u16 *)(& pHciCmd->Data) + 1U);
#line 2806
    pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen = *((u16 *)(& pHciCmd->Data) + 3U);
#line 2807
    if (BTCoexDbgLevel == 1U) {
#line 2807
      printk("ReadLocalAMPAssoc, LenSoFar =%d, MaxRemoteASSOCLen =%d\n", (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar,
             (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.MaxRemoteASSOCLen);
    } else {

    }
  }
#line 2812
  if (BTCoexDbgLevel == 1U) {
#line 2812
    printk("ReadLocalAMPAssoc, EntryNum = %d  !!!!!, physical link handle = 0x%x, LengthSoFar = %x  \n",
           (int )EntryNum, (int )PhyLinkHandle, (int )pBTInfo->BtAsocEntry[(int )EntryNum].AmpAsocCmdData.LenSoFar);
  } else {

  }
#line 2820
  localBuf[0] = '\000';
#line 2820
  tmp = 1U;
#line 2820
  while (1) {
#line 2820
    if (tmp >= 256U) {
#line 2820
      break;
    } else {

    }
#line 2820
    localBuf[tmp] = (unsigned char)0;
#line 2820
    tmp = tmp + 1U;
  }
#line 2822
  totalLen = 0U;
#line 2823
  typeLen = 0U;
#line 2823
  remainLen = 0U;
#line 2823
  ret_index = 0U;
#line 2826
  memset((void *)(& localBuf), 0, 256UL);
#line 2828
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2830
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 10, status);
#line 2830
  totalLen = (u32 )tmp___0 + totalLen;
#line 2834
  if (BTCoexDbgLevel == 1U) {
#line 2834
    printk("ReadLocalAMPAssoc, Remaining_Len =%d  \n", (int )remainLen);
  } else {

  }
#line 2836
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )totalLen;
#line 2837
  *pRetPar = (u8 )status;
#line 2838
  *(pRetPar + 1UL) = *((u8 *)(& pHciCmd->Data));
#line 2839
  pRemainLen = (u16 *)pRetPar + 2U;
#line 2840
  totalLen = totalLen + 4U;
#line 2841
  ret_index = 4U;
#line 2843
  typeLen = bthci_AssocMACAddr(padapter, (void *)pRetPar + (unsigned long )ret_index);
#line 2844
  totalLen = (u32 )typeLen + totalLen;
#line 2845
  remainLen = (int )remainLen + (int )typeLen;
#line 2846
  ret_index = (int )ret_index + (int )typeLen;
#line 2847
  typeLen = bthci_AssocPreferredChannelList(padapter, (void *)pRetPar + (unsigned long )ret_index,
                                            (int )EntryNum);
#line 2848
  totalLen = (u32 )typeLen + totalLen;
#line 2849
  remainLen = (int )remainLen + (int )typeLen;
#line 2850
  ret_index = (int )ret_index + (int )typeLen;
#line 2851
  typeLen = bthci_PALCapabilities(padapter, (void *)pRetPar + (unsigned long )ret_index);
#line 2852
  totalLen = (u32 )typeLen + totalLen;
#line 2853
  remainLen = (int )remainLen + (int )typeLen;
#line 2854
  ret_index = (int )ret_index + (int )typeLen;
#line 2855
  typeLen = bthci_AssocPALVer(padapter, (void *)pRetPar + (unsigned long )ret_index);
#line 2856
  totalLen = (u32 )typeLen + totalLen;
#line 2857
  remainLen = (int )remainLen + (int )typeLen;
#line 2858
  PPacketIrpEvent->Length = (unsigned char )totalLen;
#line 2859
  *pRemainLen = remainLen;
#line 2860
  if (BTCoexDbgLevel == 1U) {
#line 2860
    printk("ReadLocalAMPAssoc, Remaining_Len =%d  \n", (int )remainLen);
  } else {

  }
#line 2861
  if (BTCoexDbgLevel == 1U) {
#line 2861
    ptr = (u8 *)(& PPacketIrpEvent->Data);
#line 2861
    printk("AMP_ASSOC_fragment : \n");
#line 2861
    __i = 0U;
#line 2861
    goto ldv_55145;
    ldv_55144: 
#line 2861
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 2861
    if (((__i + 1U) & 15U) == 0U) {
#line 2861
      printk("\n");
    } else {

    }
#line 2861
    __i = __i + 1U;
    ldv_55145: ;
#line 2861
    if (__i < totalLen) {
#line 2863
      goto ldv_55144;
    } else {

    }
#line 2861
    printk("\n");
  } else {

  }
#line 2863
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, totalLen + 2U);
#line 2866
  return (status);
}
}
#line 2869 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadFailedContactCounter(struct rtw_adapter *padapter ,
                                                         struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 handle ;
  u8 tmp___0 ;

  {
#line 2873
  status = 0;
#line 2874
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2875
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2876
  localBuf[0] = '\000';
#line 2876
  tmp = 1U;
#line 2876
  while (1) {
#line 2876
    if (tmp >= 256U) {
#line 2876
      break;
    } else {

    }
#line 2876
    localBuf[tmp] = (unsigned char)0;
#line 2876
    tmp = tmp + 1U;
  }
#line 2878
  len = 0U;
#line 2882
  handle = *((u16 *)(& pHciCmd->Data));
#line 2884
  memset((void *)(& localBuf), 0, 256UL);
#line 2885
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2887
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 1, status);
#line 2887
  len = (int )tmp___0 + (int )len;
#line 2893
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2894
  *pRetPar = (u8 )status;
#line 2895
  *(pRetPar + 1UL) = (unsigned char )handle;
#line 2896
  *(pRetPar + 2UL) = (unsigned char )((int )handle >> 8);
#line 2897
  *(pRetPar + 3UL) = (unsigned char )pBtHciInfo->FailContactCount;
#line 2898
  *(pRetPar + 4UL) = (unsigned char )((int )pBtHciInfo->FailContactCount >> 8);
#line 2899
  len = (unsigned int )len + 5U;
#line 2900
  PPacketIrpEvent->Length = len;
#line 2902
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2904
  return (status);
}
}
#line 2908 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdResetFailedContactCounter(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u16 handle ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 2913
  status = 0;
#line 2915
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 2916
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 2918
  localBuf[0] = '\000';
#line 2918
  tmp = 1U;
#line 2918
  while (1) {
#line 2918
    if (tmp >= 256U) {
#line 2918
      break;
    } else {

    }
#line 2918
    localBuf[tmp] = (unsigned char)0;
#line 2918
    tmp = tmp + 1U;
  }
#line 2920
  len = 0U;
#line 2923
  handle = *((u16 *)(& pHciCmd->Data));
#line 2924
  pBtHciInfo->FailContactCount = 0U;
#line 2927
  memset((void *)(& localBuf), 0, 256UL);
#line 2929
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2931
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 2, status);
#line 2931
  len = (int )tmp___0 + (int )len;
#line 2937
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2938
  *pRetPar = (u8 )status;
#line 2939
  *(pRetPar + 1UL) = (unsigned char )handle;
#line 2940
  *(pRetPar + 2UL) = (unsigned char )((int )handle >> 8);
#line 2941
  len = (unsigned int )len + 3U;
#line 2942
  PPacketIrpEvent->Length = len;
#line 2944
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2945
  return (status);
}
}
#line 2952 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadLocalVersionInformation(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 2956
  status = 0;
#line 2958
  localBuf[0] = '\000';
#line 2958
  tmp = 1U;
#line 2958
  while (1) {
#line 2958
    if (tmp >= 256U) {
#line 2958
      break;
    } else {

    }
#line 2958
    localBuf[tmp] = (unsigned char)0;
#line 2958
    tmp = tmp + 1U;
  }
#line 2960
  len = 0U;
#line 2964
  memset((void *)(& localBuf), 0, 256UL);
#line 2965
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 2967
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 1, status);
#line 2967
  len = (int )tmp___0 + (int )len;
#line 2973
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 2974
  *pRetPar = (u8 )status;
#line 2975
  *(pRetPar + 1UL) = 5U;
#line 2976
  pu2Temp = (u16 *)pRetPar + 2U;
#line 2977
  *pu2Temp = 1U;
#line 2978
  *(pRetPar + 4UL) = 5U;
#line 2979
  pu2Temp = (u16 *)pRetPar + 5U;
#line 2980
  *pu2Temp = 93U;
#line 2981
  pu2Temp = (u16 *)pRetPar + 7U;
#line 2982
  *pu2Temp = 1U;
#line 2983
  len = (unsigned int )len + 9U;
#line 2984
  PPacketIrpEvent->Length = len;
#line 2986
  if (BTCoexDbgLevel == 1U) {
#line 2986
    printk("LOCAL_VERSION_INFORMATION\n");
  } else {

  }
#line 2987
  if (BTCoexDbgLevel == 1U) {
#line 2987
    printk("Status  %x\n", (unsigned int )status);
  } else {

  }
#line 2988
  if (BTCoexDbgLevel == 1U) {
#line 2988
    printk("HCI_Version = 0x05\n");
  } else {

  }
#line 2989
  if (BTCoexDbgLevel == 1U) {
#line 2989
    printk("HCI_Revision = 0x0001\n");
  } else {

  }
#line 2990
  if (BTCoexDbgLevel == 1U) {
#line 2990
    printk("LMP/PAL_Version = 0x05\n");
  } else {

  }
#line 2991
  if (BTCoexDbgLevel == 1U) {
#line 2991
    printk("Manufacturer_Name = 0x0001\n");
  } else {

  }
#line 2992
  if (BTCoexDbgLevel == 1U) {
#line 2992
    printk("LMP/PAL_Subversion = 0x0001\n");
  } else {

  }
#line 2994
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 2996
  return (status);
}
}
#line 3000 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadDataBlockSize(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 3002
  status = 0;
#line 3003
  localBuf[0] = '\000';
#line 3003
  tmp = 1U;
#line 3003
  while (1) {
#line 3003
    if (tmp >= 256U) {
#line 3003
      break;
    } else {

    }
#line 3003
    localBuf[tmp] = (unsigned char)0;
#line 3003
    tmp = tmp + 1U;
  }
#line 3005
  len = 0U;
#line 3009
  memset((void *)(& localBuf), 0, 256UL);
#line 3010
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3012
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 10, status);
#line 3012
  len = (int )tmp___0 + (int )len;
#line 3018
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3019
  *pRetPar = 0U;
#line 3020
  pu2Temp = (u16 *)pRetPar + 1U;
#line 3021
  *pu2Temp = 1492U;
#line 3023
  pu2Temp = (u16 *)pRetPar + 3U;
#line 3024
  *pu2Temp = 1492U;
#line 3025
  pu2Temp = (u16 *)pRetPar + 5U;
#line 3026
  *pu2Temp = 256U;
#line 3027
  len = (unsigned int )len + 7U;
#line 3028
  PPacketIrpEvent->Length = len;
#line 3030
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3032
  return (status);
}
}
#line 3036 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadBufferSize(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 3038
  status = 0;
#line 3039
  localBuf[0] = '\000';
#line 3039
  tmp = 1U;
#line 3039
  while (1) {
#line 3039
    if (tmp >= 256U) {
#line 3039
      break;
    } else {

    }
#line 3039
    localBuf[tmp] = (unsigned char)0;
#line 3039
    tmp = tmp + 1U;
  }
#line 3041
  len = 0U;
#line 3045
  memset((void *)(& localBuf), 0, 256UL);
#line 3047
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3049
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 4, 5, status);
#line 3049
  len = (int )tmp___0 + (int )len;
#line 3053
  if (BTCoexDbgLevel == 1U) {
#line 3053
    printk("Synchronous_Data_Packet_Length = 0x%x\n", 255);
  } else {

  }
#line 3054
  if (BTCoexDbgLevel == 1U) {
#line 3054
    printk("Total_Num_ACL_Data_Packets = 0x%x\n", 256);
  } else {

  }
#line 3055
  if (BTCoexDbgLevel == 1U) {
#line 3055
    printk("Total_Num_Synchronous_Data_Packets = 0x%x\n", 256);
  } else {

  }
#line 3057
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3058
  *pRetPar = (u8 )status;
#line 3059
  pu2Temp = (u16 *)pRetPar + 1U;
#line 3060
  *pu2Temp = 1492U;
#line 3062
  *(pRetPar + 3UL) = 255U;
#line 3063
  pu2Temp = (u16 *)pRetPar + 4U;
#line 3064
  *pu2Temp = 256U;
#line 3065
  pu2Temp = (u16 *)pRetPar + 6U;
#line 3066
  *pu2Temp = 256U;
#line 3067
  len = (unsigned int )len + 8U;
#line 3068
  PPacketIrpEvent->Length = len;
#line 3070
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3072
  return (status);
}
}
#line 3075 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadLocalAMPInfo(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;
  struct pwrctrl_priv *ppwrctrl ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u32 *pu4Temp ;
  u32 TotalBandwidth ;
  u32 MaxBandGUBandwidth ;
  u8 ControlType ;
  u8 AmpStatus ;
  u32 MaxFlushTimeout ;
  u32 BestEffortFlushTimeout ;
  u16 MaxPDUSize ;
  u16 PalCap ;
  u16 AmpAssocLen ;
  u16 MinLatency ;
  u8 tmp___0 ;

  {
#line 3077
  status = 0;
#line 3078
  ppwrctrl = & padapter->pwrctrlpriv;
#line 3079
  localBuf[0] = '\000';
#line 3079
  tmp = 1U;
#line 3079
  while (1) {
#line 3079
    if (tmp >= 256U) {
#line 3079
      break;
    } else {

    }
#line 3079
    localBuf[tmp] = (unsigned char)0;
#line 3079
    tmp = tmp + 1U;
  }
#line 3081
  len = 0U;
#line 3085
  TotalBandwidth = 30000U;
#line 3085
  MaxBandGUBandwidth = 20000U;
#line 3086
  ControlType = 1U;
#line 3086
  AmpStatus = 1U;
#line 3087
  MaxFlushTimeout = 10000U;
#line 3087
  BestEffortFlushTimeout = 5000U;
#line 3088
  MaxPDUSize = 1492U;
#line 3088
  PalCap = 1U;
#line 3088
  AmpAssocLen = 672U;
#line 3088
  MinLatency = 20U;
#line 3090
  if (((unsigned long )ppwrctrl->rfoff_reason & 1073741824UL) != 0UL || (int )ppwrctrl->rfoff_reason < 0) {
#line 3092
    AmpStatus = 2U;
  } else {

  }
#line 3095
  memset((void *)(& localBuf), 0, 256UL);
#line 3097
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3099
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 9, status);
#line 3099
  len = (int )tmp___0 + (int )len;
#line 3105
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3106
  *pRetPar = (u8 )status;
#line 3107
  *(pRetPar + 1UL) = AmpStatus;
#line 3108
  pu4Temp = (u32 *)pRetPar + 2U;
#line 3109
  *pu4Temp = TotalBandwidth;
#line 3110
  pu4Temp = (u32 *)pRetPar + 6U;
#line 3111
  *pu4Temp = MaxBandGUBandwidth;
#line 3112
  pu4Temp = (u32 *)pRetPar + 10U;
#line 3113
  *pu4Temp = (u32 )MinLatency;
#line 3114
  pu4Temp = (u32 *)pRetPar + 14U;
#line 3115
  *pu4Temp = (u32 )MaxPDUSize;
#line 3116
  *(pRetPar + 18UL) = ControlType;
#line 3117
  pu2Temp = (u16 *)pRetPar + 19U;
#line 3118
  *pu2Temp = PalCap;
#line 3119
  pu2Temp = (u16 *)pRetPar + 21U;
#line 3120
  *pu2Temp = AmpAssocLen;
#line 3121
  pu4Temp = (u32 *)pRetPar + 23U;
#line 3122
  *pu4Temp = MaxFlushTimeout;
#line 3123
  pu4Temp = (u32 *)pRetPar + 27U;
#line 3124
  *pu4Temp = BestEffortFlushTimeout;
#line 3125
  len = (unsigned int )len + 31U;
#line 3126
  PPacketIrpEvent->Length = len;
#line 3127
  if (BTCoexDbgLevel == 1U) {
#line 3127
    printk("AmpStatus = 0x%x\n", (int )AmpStatus);
  } else {

  }
#line 3129
  if (BTCoexDbgLevel == 1U) {
#line 3129
    printk("TotalBandwidth = 0x%x, MaxBandGUBandwidth = 0x%x, MinLatency = 0x%x, \n MaxPDUSize = 0x%x, ControlType = 0x%x\n",
           TotalBandwidth, MaxBandGUBandwidth, (int )MinLatency, (int )MaxPDUSize,
           (int )ControlType);
  } else {

  }
#line 3131
  if (BTCoexDbgLevel == 1U) {
#line 3131
    printk("PalCap = 0x%x, AmpAssocLen = 0x%x, MaxFlushTimeout = 0x%x, BestEffortFlushTimeout = 0x%x\n",
           (int )PalCap, (int )AmpAssocLen, MaxFlushTimeout, BestEffortFlushTimeout);
  } else {

  }
#line 3133
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3134
  return (status);
}
}
#line 3138 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdCreatePhysicalLink(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 3144
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3145
  pBtDbg = & pBTInfo->BtDbg;
#line 3147
  pBtDbg->dbgHciInfo.hciCmdCntCreatePhyLink = pBtDbg->dbgHciInfo.hciCmdCntCreatePhyLink + 1U;
#line 3149
  status = bthci_BuildPhysicalLink(padapter, pHciCmd, 53);
#line 3152
  return (status);
}
}
#line 3156 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadLinkQuality(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  u16 PLH ;
  u8 EntryNum ;
  u8 LinkQuality ;
  u8 localBuf[11U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3161
  status = 0;
#line 3162
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3164
  LinkQuality = 85U;
#line 3166
  PLH = *((u16 *)(& pHciCmd->Data));
#line 3167
  if (BTCoexDbgLevel == 1U) {
#line 3167
    printk("PLH = 0x%x\n", (int )PLH);
  } else {

  }
#line 3169
  EntryNum = bthci_GetCurrentEntryNum(padapter, (int )((unsigned char )PLH));
#line 3170
  if ((unsigned int )EntryNum == 255U) {
#line 3171
    if (BTCoexDbgLevel == 1U) {
#line 3171
      printk("No such PLH(0x%x)\n", (int )PLH);
    } else {

    }
#line 3172
    status = 2;
  } else {

  }
#line 3176
  localBuf[0] = '\000';
#line 3176
  tmp = 1U;
#line 3176
  while (1) {
#line 3176
    if (tmp >= 11U) {
#line 3176
      break;
    } else {

    }
#line 3176
    localBuf[tmp] = (unsigned char)0;
#line 3176
    tmp = tmp + 1U;
  }
#line 3178
  len = 0U;
#line 3181
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3183
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 5, 3, status);
#line 3183
  len = (int )tmp___0 + (int )len;
#line 3188
  if (BTCoexDbgLevel == 1U) {
#line 3188
    printk(" PLH = 0x%x\n Link Quality = 0x%x\n", (int )PLH, (int )LinkQuality);
  } else {

  }
#line 3191
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3192
  *pRetPar = (u8 )status;
#line 3193
  *((u16 *)pRetPar + 1U) = (u16 )pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkCmdData.BtPhyLinkhandle;
#line 3194
  *(pRetPar + 3UL) = 85U;
#line 3195
  len = (unsigned int )len + 4U;
#line 3196
  PPacketIrpEvent->Length = len;
#line 3198
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3201
  return (status);
}
}
#line 3204 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdReadRSSI(struct rtw_adapter *padapter ) 
{ 
  enum hci_status status ;

  {
#line 3206
  status = 0;
#line 3207
  return (status);
}
}
#line 3211 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdCreateLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 3216
  status = 0;
#line 3217
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3218
  pBtDbg = & pBTInfo->BtDbg;
#line 3220
  pBtDbg->dbgHciInfo.hciCmdCntCreateLogLink = pBtDbg->dbgHciInfo.hciCmdCntCreateLogLink + 1U;
#line 3222
  bthci_BuildLogicalLink(padapter, pHciCmd, 56);
#line 3225
  return (status);
}
}
#line 3229 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdAcceptLogicalLink(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 3234
  status = 0;
#line 3235
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3236
  pBtDbg = & pBTInfo->BtDbg;
#line 3238
  pBtDbg->dbgHciInfo.hciCmdCntAcceptLogLink = pBtDbg->dbgHciInfo.hciCmdCntAcceptLogLink + 1U;
#line 3240
  bthci_BuildLogicalLink(padapter, pHciCmd, 57);
#line 3243
  return (status);
}
}
#line 3247 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdDisconnectLogicalLink(struct rtw_adapter *padapter ,
                                                      struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u16 logicHandle ;
  u8 i ;
  u8 j ;
  u8 find ;
  u8 LogLinkCount ;
  unsigned long tmp ;

  {
#line 3252
  status = 0;
#line 3254
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3255
  pBtMgnt = & pBTinfo->BtMgnt;
#line 3256
  pBtDbg = & pBTinfo->BtDbg;
#line 3258
  find = 0U;
#line 3258
  LogLinkCount = 0U;
#line 3260
  pBtDbg->dbgHciInfo.hciCmdCntDisconnectLogLink = pBtDbg->dbgHciInfo.hciCmdCntDisconnectLogLink + 1U;
#line 3262
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 3263
  if (BTCoexDbgLevel == 1U) {
#line 3263
    printk("DisconnectLogicalLink, logicHandle = 0x%x\n", (int )logicHandle);
  } else {

  }
#line 3266
  j = 0U;
#line 3266
  goto ldv_55274;
  ldv_55273: 
#line 3267
  i = 0U;
#line 3267
  goto ldv_55272;
  ldv_55271: ;
#line 3268
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
#line 3269
    if (BTCoexDbgLevel == 1U) {
#line 3269
      printk("DisconnectLogicalLink, logicHandle is matched  0x%x\n", (int )logicHandle);
    } else {

    }
#line 3270
    bthci_ResetFlowSpec(padapter, (int )j, (int )i);
#line 3271
    find = 1U;
#line 3272
    pBtMgnt->DisconnectEntryNum = j;
#line 3273
    goto ldv_55270;
  } else {

  }
#line 3267
  i = (u8 )((int )i + 1);
  ldv_55272: ;
#line 3267
  if ((unsigned int )i <= 1U) {
#line 3269
    goto ldv_55271;
  } else {

  }
  ldv_55270: 
#line 3266
  j = (u8 )((int )j + 1);
  ldv_55274: ;
#line 3266
  if ((unsigned int )j <= 1U) {
#line 3268
    goto ldv_55273;
  } else {

  }

#line 3278
  if ((unsigned int )find == 0U) {
#line 3279
    status = 2;
  } else {

  }
#line 3282
  i = 0U;
#line 3282
  goto ldv_55277;
  ldv_55276: ;
#line 3283
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )pBtMgnt->DisconnectEntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle != 0U) {
#line 3284
    LogLinkCount = (u8 )((int )LogLinkCount + 1);
  } else {

  }
#line 3282
  i = (u8 )((int )i + 1);
  ldv_55277: ;
#line 3282
  if ((unsigned int )i <= 1U) {
#line 3284
    goto ldv_55276;
  } else {

  }
#line 3288
  bthci_EventCommandStatus(padapter, 1, 58, status);
#line 3295
  if ((unsigned int )status == 0U) {
#line 3296
    bthci_EventDisconnectLogicalLinkComplete(padapter, status, (int )logicHandle,
                                             22);
  } else {

  }
#line 3300
  if ((unsigned int )LogLinkCount == 0U) {
#line 3301
    tmp = msecs_to_jiffies(100U);
#line 3301
    ldv_mod_timer_2426(& pBTinfo->BTDisconnectPhyLinkTimer, tmp + (unsigned long )jiffies);
  } else {

  }
#line 3304
  return (status);
}
}
#line 3308 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdLogicalLinkCancel(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 CurrentEntryNum ;
  u8 CurrentLogEntryNum ;
  u8 physicalLinkHandle ;
  u8 TxFlowSpecID ;
  u8 i ;
  u16 CurrentLogicalHandle ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3311
  status = 0;
#line 3312
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3313
  pBtMgnt = & pBTinfo->BtMgnt;
#line 3319
  physicalLinkHandle = *((u8 *)(& pHciCmd->Data));
#line 3320
  TxFlowSpecID = *((u8 *)(& pHciCmd->Data) + 1UL);
#line 3322
  if (BTCoexDbgLevel == 1U) {
#line 3322
    printk("LogicalLinkCancel, physicalLinkHandle = 0x%x, TxFlowSpecID = 0x%x\n",
           (int )physicalLinkHandle, (int )TxFlowSpecID);
  } else {

  }
#line 3325
  CurrentEntryNum = pBtMgnt->CurrentConnectEntryNum;
#line 3326
  CurrentLogicalHandle = pBtMgnt->BtCurrentLogLinkhandle;
#line 3328
  if (BTCoexDbgLevel == 1U) {
#line 3328
    printk("CurrentEntryNum = 0x%x, CurrentLogicalHandle = 0x%x\n", (int )CurrentEntryNum,
           (int )CurrentLogicalHandle);
  } else {

  }
#line 3331
  CurrentLogEntryNum = 255U;
#line 3332
  i = 0U;
#line 3332
  goto ldv_55294;
  ldv_55293: ;
#line 3333
  if ((int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )CurrentLogicalHandle && (int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )i].BtPhyLinkhandle == (int )physicalLinkHandle) {
#line 3335
    CurrentLogEntryNum = i;
#line 3336
    goto ldv_55292;
  } else {

  }
#line 3332
  i = (u8 )((int )i + 1);
  ldv_55294: ;
#line 3332
  if ((unsigned int )i <= 1U) {
#line 3334
    goto ldv_55293;
  } else {

  }
  ldv_55292: ;
#line 3340
  if ((unsigned int )CurrentLogEntryNum == 255U) {
#line 3341
    if (BTCoexDbgLevel == 1U) {
#line 3341
      printk("LogicalLinkCancel, CurrentLogEntryNum == 0xff !!!!\n");
    } else {

    }
#line 3342
    status = 2;
#line 3343
    return (status);
  } else
#line 3345
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].bLLCompleteEventIsSet != 0U) {
#line 3346
    if (BTCoexDbgLevel == 1U) {
#line 3346
      printk("LogicalLinkCancel, LLCompleteEventIsSet!!!!\n");
    } else {

    }
#line 3347
    status = 11;
  } else {

  }
#line 3352
  localBuf[0] = '\000';
#line 3352
  tmp = 1U;
#line 3352
  while (1) {
#line 3352
    if (tmp >= 8U) {
#line 3352
      break;
    } else {

    }
#line 3352
    localBuf[tmp] = (unsigned char)0;
#line 3352
    tmp = tmp + 1U;
  }
#line 3354
  len = 0U;
#line 3357
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3359
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 1, 59, status);
#line 3359
  len = (int )tmp___0 + (int )len;
#line 3365
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3366
  *pRetPar = (u8 )status;
#line 3367
  *(pRetPar + 1UL) = pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].BtPhyLinkhandle;
#line 3368
  *(pRetPar + 2UL) = pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].BtTxFlowSpecID;
#line 3369
  len = (unsigned int )len + 3U;
#line 3370
  PPacketIrpEvent->Length = len;
#line 3372
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3375
  pBTinfo->BtAsocEntry[(int )CurrentEntryNum].LogLinkCmdData[(int )CurrentLogEntryNum].bLLCancelCMDIsSetandComplete = 1U;
#line 3377
  return (status);
}
}
#line 3381 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdFlowSpecModify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTinfo ;
  u8 i ;
  u8 j ;
  u8 find ;
  u16 logicHandle ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;

  {
#line 3384
  status = 0;
#line 3386
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3387
  find = 0U;
#line 3390
  logicHandle = *((u16 *)(& pHciCmd->Data));
#line 3392
  j = 0U;
#line 3392
  goto ldv_55319;
  ldv_55318: 
#line 3393
  i = 0U;
#line 3393
  goto ldv_55317;
  ldv_55316: ;
#line 3394
  if ((int )pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle == (int )logicHandle) {
#line 3395
    __len = 16UL;
#line 3395
    if (__len > 63UL) {
#line 3395
      __ret = __memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                       (void const   *)(& pHciCmd->Data) + 2U, __len);
    } else {
#line 3395
      __ret = __builtin_memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec),
                               (void const   *)(& pHciCmd->Data) + 2U, __len);
    }
#line 3397
    __len___0 = 16UL;
#line 3397
    if (__len___0 > 63UL) {
#line 3397
      __ret___0 = __memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                           (void const   *)(& pHciCmd->Data) + 18U, __len___0);
    } else {
#line 3397
      __ret___0 = __builtin_memcpy((void *)(& pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Rx_Flow_Spec),
                                   (void const   *)(& pHciCmd->Data) + 18U, __len___0);
    }
#line 3400
    bthci_CheckLogLinkBehavior(padapter, pBTinfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].Tx_Flow_Spec);
#line 3401
    find = 1U;
#line 3402
    goto ldv_55315;
  } else {

  }
#line 3393
  i = (u8 )((int )i + 1);
  ldv_55317: ;
#line 3393
  if ((unsigned int )i <= 1U) {
#line 3395
    goto ldv_55316;
  } else {

  }
  ldv_55315: 
#line 3392
  j = (u8 )((int )j + 1);
  ldv_55319: ;
#line 3392
  if ((unsigned int )j <= 1U) {
#line 3394
    goto ldv_55318;
  } else {

  }

#line 3406
  if (BTCoexDbgLevel == 1U) {
#line 3406
    printk("FlowSpecModify, LLH = 0x%x, \n", (int )logicHandle);
  } else {

  }
#line 3409
  bthci_EventCommandStatus(padapter, 1, 60, 0);
#line 3414
  if ((unsigned int )find == 0U) {
#line 3415
    status = 2;
  } else {

  }
#line 3417
  bthci_EventSendFlowSpecModifyComplete(padapter, status, (int )logicHandle);
#line 3419
  return (status);
}
}
#line 3423 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdAcceptPhysicalLink(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 3427
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3428
  pBtDbg = & pBTInfo->BtDbg;
#line 3430
  pBtDbg->dbgHciInfo.hciCmdCntAcceptPhyLink = pBtDbg->dbgHciInfo.hciCmdCntAcceptPhyLink + 1U;
#line 3432
  status = bthci_BuildPhysicalLink(padapter, pHciCmd, 54);
#line 3435
  return (status);
}
}
#line 3439 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdDisconnectPhysicalLink(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 PLH ;
  u8 CurrentEntryNum ;
  u8 PhysLinkDisconnectReason ;

  {
#line 3442
  status = 0;
#line 3443
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3444
  pBtDbg = & pBTInfo->BtDbg;
#line 3447
  pBtDbg->dbgHciInfo.hciCmdCntDisconnectPhyLink = pBtDbg->dbgHciInfo.hciCmdCntDisconnectPhyLink + 1U;
#line 3449
  PLH = *((u8 *)(& pHciCmd->Data));
#line 3450
  PhysLinkDisconnectReason = *((u8 *)(& pHciCmd->Data) + 1UL);
#line 3451
  if (BTCoexDbgLevel == 1U) {
#line 3451
    printk("HCI_DISCONNECT_PHYSICAL_LINK  PhyHandle = 0x%x, Reason = 0x%x\n", (int )PLH,
           (int )PhysLinkDisconnectReason);
  } else {

  }
#line 3454
  CurrentEntryNum = bthci_GetCurrentEntryNum(padapter, (int )PLH);
#line 3456
  if ((unsigned int )CurrentEntryNum == 255U) {
#line 3457
    if (BTCoexDbgLevel == 1U) {
#line 3457
      printk("DisconnectPhysicalLink, No such Handle in the Entry\n");
    } else {

    }
#line 3459
    status = 2;
  } else {
#line 3461
    pBTInfo->BtAsocEntry[(int )CurrentEntryNum].PhyLinkDisconnectReason = (enum hci_status )PhysLinkDisconnectReason;
  }
#line 3465
  bthci_EventCommandStatus(padapter, 1, 55, status);
#line 3468
  if ((unsigned int )status != 0U) {
#line 3469
    return (status);
  } else {

  }
#line 3472
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )CurrentEntryNum].BtCurrentState == 32U) {
#line 3473
    if (BTCoexDbgLevel == 1U) {
#line 3473
      printk("[BT state change] caused by %s, line =%d\n", "bthci_CmdDisconnectPhysicalLink",
             3473);
    } else {

    }
#line 3473
    BTHCI_StateMachine(padapter, 32, 2, (int )CurrentEntryNum);
  } else {
#line 3475
    if (BTCoexDbgLevel == 1U) {
#line 3475
      printk("[BT state change] caused by %s, line =%d\n", "bthci_CmdDisconnectPhysicalLink",
             3475);
    } else {

    }
#line 3475
    BTHCI_StateMachine(padapter, 16, 2, (int )CurrentEntryNum);
  }
#line 3477
  return (status);
}
}
#line 3481 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdSetACLLinkDataFlowMode(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u8 tmp___0 ;

  {
#line 3484
  status = 0;
#line 3485
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3486
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3487
  localBuf[0] = '\000';
#line 3487
  tmp = 1U;
#line 3487
  while (1) {
#line 3487
    if (tmp >= 8U) {
#line 3487
      break;
    } else {

    }
#line 3487
    localBuf[tmp] = (unsigned char)0;
#line 3487
    tmp = tmp + 1U;
  }
#line 3489
  len = 0U;
#line 3493
  pBtMgnt->ExtConfig.CurrentConnectHandle = *((u16 *)(& pHciCmd->Data));
#line 3494
  pBtMgnt->ExtConfig.CurrentIncomingTrafficMode = (unsigned int )*((u8 *)(& pHciCmd->Data)) + 2U;
#line 3495
  pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode = (unsigned int )*((u8 *)(& pHciCmd->Data)) + 3U;
#line 3496
  if (BTCoexDbgLevel == 1U) {
#line 3496
    printk("Connection Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic mode = 0x%x",
           (int )pBtMgnt->ExtConfig.CurrentConnectHandle, (int )pBtMgnt->ExtConfig.CurrentIncomingTrafficMode,
           (int )pBtMgnt->ExtConfig.CurrentOutgoingTrafficMode);
  } else {

  }
#line 3502
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3504
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 16, status);
#line 3504
  len = (int )tmp___0 + (int )len;
#line 3510
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3511
  *pRetPar = (u8 )status;
#line 3513
  pu2Temp = (u16 *)pRetPar + 1U;
#line 3514
  *pu2Temp = pBtMgnt->ExtConfig.CurrentConnectHandle;
#line 3515
  len = (unsigned int )len + 3U;
#line 3516
  PPacketIrpEvent->Length = len;
#line 3518
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3519
  return (status);
}
}
#line 3523 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdSetACLLinkStatus(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 *pTriple ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3526
  status = 0;
#line 3527
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3528
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3529
  pBtDbg = & pBTInfo->BtDbg;
#line 3533
  pBtDbg->dbgHciInfo.hciCmdCntSetAclLinkStatus = pBtDbg->dbgHciInfo.hciCmdCntSetAclLinkStatus + 1U;
#line 3534
  if (BTCoexDbgLevel == 1U) {
#line 3534
    ptr = (u8 *)(& pHciCmd->Data);
#line 3534
    printk("SetACLLinkStatus, Hex Data :\n");
#line 3534
    __i = 0U;
#line 3534
    goto ldv_55364;
    ldv_55363: 
#line 3534
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3534
    if (((__i + 1U) & 15U) == 0U) {
#line 3534
      printk("\n");
    } else {

    }
#line 3534
    __i = __i + 1U;
    ldv_55364: ;
#line 3534
    if ((u32 )pHciCmd->Length > __i) {
#line 3536
      goto ldv_55363;
    } else {

    }
#line 3534
    printk("\n");
  } else {

  }
#line 3538
  pBtMgnt->bSupportProfile = 1U;
#line 3540
  pBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)(& pHciCmd->Data));
#line 3541
  if (BTCoexDbgLevel == 1U) {
#line 3541
    printk("NumberOfHandle = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
  } else {

  }
#line 3543
  pTriple = (u8 *)(& pHciCmd->Data) + 1UL;
#line 3544
  i = 0U;
#line 3544
  goto ldv_55367;
  ldv_55366: 
#line 3545
  pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
#line 3546
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = *(pTriple + 2UL);
#line 3547
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = *(pTriple + 3UL);
#line 3548
  if (BTCoexDbgLevel == 1U) {
#line 3548
    printk("Connection_Handle = 0x%x, Incoming Traffic mode = 0x%x, Outgoing Traffic Mode = 0x%x\n",
           (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode,
           (int )pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode);
  } else {

  }
#line 3553
  pTriple = pTriple + 4UL;
#line 3544
  i = (u8 )((int )i + 1);
  ldv_55367: ;
#line 3544
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 3546
    goto ldv_55366;
  } else {

  }
#line 3557
  localBuf[0] = '\000';
#line 3557
  tmp = 1U;
#line 3557
  while (1) {
#line 3557
    if (tmp >= 6U) {
#line 3557
      break;
    } else {

    }
#line 3557
    localBuf[tmp] = (unsigned char)0;
#line 3557
    tmp = tmp + 1U;
  }
#line 3559
  len = 0U;
#line 3562
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3564
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 32, status);
#line 3564
  len = (int )tmp___0 + (int )len;
#line 3570
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3571
  *pRetPar = (u8 )status;
#line 3573
  len = (unsigned int )len + 1U;
#line 3574
  PPacketIrpEvent->Length = len;
#line 3576
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3579
  return (status);
}
}
#line 3583 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdSetSCOLinkStatus(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3588
  status = 0;
#line 3589
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3590
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3591
  pBtDbg = & pBTInfo->BtDbg;
#line 3593
  pBtDbg->dbgHciInfo.hciCmdCntSetScoLinkStatus = pBtDbg->dbgHciInfo.hciCmdCntSetScoLinkStatus + 1U;
#line 3594
  pBtMgnt->ExtConfig.NumberOfSCO = *((u8 *)(& pHciCmd->Data));
#line 3595
  if (BTCoexDbgLevel == 1U) {
#line 3595
    printk("NumberOfSCO = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfSCO);
  } else {

  }
#line 3599
  localBuf[0] = '\000';
#line 3599
  tmp = 1U;
#line 3599
  while (1) {
#line 3599
    if (tmp >= 6U) {
#line 3599
      break;
    } else {

    }
#line 3599
    localBuf[tmp] = (unsigned char)0;
#line 3599
    tmp = tmp + 1U;
  }
#line 3601
  len = 0U;
#line 3604
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3606
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 48, status);
#line 3606
  len = (int )tmp___0 + (int )len;
#line 3612
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3613
  *pRetPar = (u8 )status;
#line 3615
  len = (unsigned int )len + 1U;
#line 3616
  PPacketIrpEvent->Length = len;
#line 3618
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3621
  return (status);
}
}
#line 3625 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdSetRSSIValue(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  s8 min_bt_rssi ;
  u8 i ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3630
  status = 0;
#line 3631
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3632
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3633
  min_bt_rssi = 0;
#line 3635
  i = 0U;
#line 3635
  goto ldv_55395;
  ldv_55394: ;
#line 3636
  if ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle == (int )*((u16 *)(& pHciCmd->Data))) {
#line 3637
    pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI = (signed char )pHciCmd->Data[2];
#line 3638
    if (BTCoexDbgLevel == 1U) {
#line 3638
      printk("Connection_Handle = 0x%x, RSSI = %d \n", (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI);
    } else {

    }
  } else {

  }
#line 3644
  if ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI <= (int )min_bt_rssi) {
#line 3645
    min_bt_rssi = pBtMgnt->ExtConfig.linkInfo[(int )i].BT_RSSI;
  } else {

  }
#line 3635
  i = (u8 )((int )i + 1);
  ldv_55395: ;
#line 3635
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 3637
    goto ldv_55394;
  } else {

  }
#line 3648
  pBtMgnt->ExtConfig.MIN_BT_RSSI = min_bt_rssi;
#line 3649
  if (BTCoexDbgLevel == 1U) {
#line 3649
    printk("[bt rssi], the min rssi is %d\n", (int )min_bt_rssi);
  } else {

  }
#line 3652
  localBuf[0] = '\000';
#line 3652
  tmp = 1U;
#line 3652
  while (1) {
#line 3652
    if (tmp >= 6U) {
#line 3652
      break;
    } else {

    }
#line 3652
    localBuf[tmp] = (unsigned char)0;
#line 3652
    tmp = tmp + 1U;
  }
#line 3654
  len = 0U;
#line 3657
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3659
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 64, status);
#line 3659
  len = (int )tmp___0 + (int )len;
#line 3665
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3666
  *pRetPar = (u8 )status;
#line 3668
  len = (unsigned int )len + 1U;
#line 3669
  PPacketIrpEvent->Length = len;
#line 3671
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3674
  return (status);
}
}
#line 3678 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdSetCurrentBluetoothStatus(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3683
  status = 0;
#line 3685
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3686
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3688
  pBtMgnt->ExtConfig.CurrentBTStatus = *((u8 *)(& pHciCmd->Data));
#line 3689
  if (BTCoexDbgLevel == 1U) {
#line 3689
    printk("SetCurrentBluetoothStatus, CurrentBTStatus = 0x%x\n", (int )pBtMgnt->ExtConfig.CurrentBTStatus);
  } else {

  }
#line 3693
  localBuf[0] = '\000';
#line 3693
  tmp = 1U;
#line 3693
  while (1) {
#line 3693
    if (tmp >= 6U) {
#line 3693
      break;
    } else {

    }
#line 3693
    localBuf[tmp] = (unsigned char)0;
#line 3693
    tmp = tmp + 1U;
  }
#line 3695
  len = 0U;
#line 3698
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3700
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 65, status);
#line 3700
  len = (int )tmp___0 + (int )len;
#line 3706
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3707
  *pRetPar = (u8 )status;
#line 3708
  len = (unsigned int )len + 1U;
#line 3710
  PPacketIrpEvent->Length = len;
#line 3712
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3715
  return (status);
}
}
#line 3719 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdExtensionVersionNotify(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3724
  status = 0;
#line 3725
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3726
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3727
  pBtDbg = & pBTInfo->BtDbg;
#line 3729
  pBtDbg->dbgHciInfo.hciCmdCntExtensionVersionNotify = pBtDbg->dbgHciInfo.hciCmdCntExtensionVersionNotify + 1U;
#line 3730
  if (BTCoexDbgLevel == 1U) {
#line 3730
    ptr = (u8 *)(& pHciCmd->Data);
#line 3730
    printk("ExtensionVersionNotify, Hex Data :\n");
#line 3730
    __i = 0U;
#line 3730
    goto ldv_55423;
    ldv_55422: 
#line 3730
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3730
    if (((__i + 1U) & 15U) == 0U) {
#line 3730
      printk("\n");
    } else {

    }
#line 3730
    __i = __i + 1U;
    ldv_55423: ;
#line 3730
    if ((u32 )pHciCmd->Length > __i) {
#line 3732
      goto ldv_55422;
    } else {

    }
#line 3730
    printk("\n");
  } else {

  }
#line 3733
  pBtMgnt->ExtConfig.HCIExtensionVer = *((u16 *)(& pHciCmd->Data));
#line 3734
  if (BTCoexDbgLevel == 1U) {
#line 3734
    printk("HCIExtensionVer = 0x%x\n", (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  } else {

  }
#line 3737
  localBuf[0] = '\000';
#line 3737
  tmp = 1U;
#line 3737
  while (1) {
#line 3737
    if (tmp >= 6U) {
#line 3737
      break;
    } else {

    }
#line 3737
    localBuf[tmp] = (unsigned char)0;
#line 3737
    tmp = tmp + 1U;
  }
#line 3739
  len = 0U;
#line 3742
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3744
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 256, status);
#line 3744
  len = (int )tmp___0 + (int )len;
#line 3750
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3751
  *pRetPar = (u8 )status;
#line 3753
  len = (unsigned int )len + 1U;
#line 3754
  PPacketIrpEvent->Length = len;
#line 3756
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3759
  return (status);
}
}
#line 3763 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdLinkStatusNotify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 i ;
  u8 *pTriple ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3768
  status = 0;
#line 3769
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3770
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3771
  pBtDbg = & pBTInfo->BtDbg;
#line 3775
  pBtDbg->dbgHciInfo.hciCmdCntLinkStatusNotify = pBtDbg->dbgHciInfo.hciCmdCntLinkStatusNotify + 1U;
#line 3776
  if (BTCoexDbgLevel == 1U) {
#line 3776
    ptr = (u8 *)(& pHciCmd->Data);
#line 3776
    printk("LinkStatusNotify, Hex Data :\n");
#line 3776
    __i = 0U;
#line 3776
    goto ldv_55442;
    ldv_55441: 
#line 3776
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3776
    if (((__i + 1U) & 15U) == 0U) {
#line 3776
      printk("\n");
    } else {

    }
#line 3776
    __i = __i + 1U;
    ldv_55442: ;
#line 3776
    if ((u32 )pHciCmd->Length > __i) {
#line 3778
      goto ldv_55441;
    } else {

    }
#line 3776
    printk("\n");
  } else {

  }
#line 3780
  pBtMgnt->bSupportProfile = 1U;
#line 3782
  pBtMgnt->ExtConfig.NumberOfHandle = *((u8 *)(& pHciCmd->Data));
#line 3783
  if (BTCoexDbgLevel == 1U) {
#line 3783
    printk("NumberOfHandle = 0x%x\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
  } else {

  }
#line 3784
  if (BTCoexDbgLevel == 1U) {
#line 3784
    printk("HCIExtensionVer = %d\n", (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  } else {

  }
#line 3786
  pTriple = (u8 *)(& pHciCmd->Data) + 1UL;
#line 3787
  i = 0U;
#line 3787
  goto ldv_55445;
  ldv_55444: ;
#line 3788
  if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer == 0U) {
#line 3789
    pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
#line 3790
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = *(pTriple + 2UL);
#line 3791
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = *(pTriple + 3UL);
#line 3792
    if (BTCoexDbgLevel == 1U) {
#line 3792
      printk("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d\n", (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec);
    } else {

    }
#line 3797
    pTriple = pTriple + 4UL;
  } else
#line 3798
  if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer != 0U) {
#line 3799
    pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle = *((u16 *)pTriple);
#line 3800
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile = *(pTriple + 2UL);
#line 3801
    pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec = *(pTriple + 3UL);
#line 3802
    pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole = *(pTriple + 4UL);
#line 3803
    if (BTCoexDbgLevel == 1U) {
#line 3803
      printk("Connection_Handle = 0x%x, BTProfile =%d, BTSpec =%d, LinkRole =%d\n",
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].ConnectHandle, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile,
             (int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec, (int )pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole);
    } else {

    }
#line 3809
    pTriple = pTriple + 5UL;
  } else {

  }
#line 3787
  i = (u8 )((int )i + 1);
  ldv_55445: ;
#line 3787
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 3789
    goto ldv_55444;
  } else {

  }
#line 3813
  BTHCI_UpdateBTProfileRTKToMoto(padapter);
#line 3815
  localBuf[0] = '\000';
#line 3815
  tmp = 1U;
#line 3815
  while (1) {
#line 3815
    if (tmp >= 6U) {
#line 3815
      break;
    } else {

    }
#line 3815
    localBuf[tmp] = (unsigned char)0;
#line 3815
    tmp = tmp + 1U;
  }
#line 3817
  len = 0U;
#line 3820
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3822
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 257, status);
#line 3822
  len = (int )tmp___0 + (int )len;
#line 3828
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3829
  *pRetPar = (u8 )status;
#line 3831
  len = (unsigned int )len + 1U;
#line 3832
  PPacketIrpEvent->Length = len;
#line 3834
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3837
  return (status);
}
}
#line 3841 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdBtOperationNotify(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3846
  status = 0;
#line 3847
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3848
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3850
  if (BTCoexDbgLevel == 1U) {
#line 3850
    ptr = (u8 *)(& pHciCmd->Data);
#line 3850
    printk("Bt Operation notify, Hex Data :\n");
#line 3850
    __i = 0U;
#line 3850
    goto ldv_55461;
    ldv_55460: 
#line 3850
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3850
    if (((__i + 1U) & 15U) == 0U) {
#line 3850
      printk("\n");
    } else {

    }
#line 3850
    __i = __i + 1U;
    ldv_55461: ;
#line 3850
    if ((u32 )pHciCmd->Length > __i) {
#line 3852
      goto ldv_55460;
    } else {

    }
#line 3850
    printk("\n");
  } else {

  }
#line 3853
  pBtMgnt->ExtConfig.btOperationCode = *((u8 *)(& pHciCmd->Data));
#line 3854
  if (BTCoexDbgLevel == 1U) {
#line 3854
    printk("btOperationCode = 0x%x\n", (int )pBtMgnt->ExtConfig.btOperationCode);
  } else {

  }
#line 3855
  switch ((int )pBtMgnt->ExtConfig.btOperationCode) {
  case 0: ;
#line 3857
  if (BTCoexDbgLevel == 1U) {
#line 3857
    printk("[bt operation] : Operation None!!\n");
  } else {

  }
#line 3858
  goto ldv_55464;
  case 1: ;
#line 3860
  if (BTCoexDbgLevel == 1U) {
#line 3860
    printk("[bt operation] : Inquire start!!\n");
  } else {

  }
#line 3861
  goto ldv_55464;
  case 2: ;
#line 3863
  if (BTCoexDbgLevel == 1U) {
#line 3863
    printk("[bt operation] : Inquire finished!!\n");
  } else {

  }
#line 3864
  goto ldv_55464;
  case 3: ;
#line 3866
  if (BTCoexDbgLevel == 1U) {
#line 3866
    printk("[bt operation] : Paging is started!!\n");
  } else {

  }
#line 3867
  goto ldv_55464;
  case 4: ;
#line 3869
  if (BTCoexDbgLevel == 1U) {
#line 3869
    printk("[bt operation] : Paging complete successfully!!\n");
  } else {

  }
#line 3870
  goto ldv_55464;
  case 5: ;
#line 3872
  if (BTCoexDbgLevel == 1U) {
#line 3872
    printk("[bt operation] : Paging complete unsuccessfully!!\n");
  } else {

  }
#line 3873
  goto ldv_55464;
  case 6: ;
#line 3875
  if (BTCoexDbgLevel == 1U) {
#line 3875
    printk("[bt operation] : Pairing start!!\n");
  } else {

  }
#line 3876
  goto ldv_55464;
  case 7: ;
#line 3878
  if (BTCoexDbgLevel == 1U) {
#line 3878
    printk("[bt operation] : Pairing finished!!\n");
  } else {

  }
#line 3879
  goto ldv_55464;
  case 8: ;
#line 3881
  if (BTCoexDbgLevel == 1U) {
#line 3881
    printk("[bt operation] : BT Device is enabled!!\n");
  } else {

  }
#line 3882
  goto ldv_55464;
  case 9: ;
#line 3884
  if (BTCoexDbgLevel == 1U) {
#line 3884
    printk("[bt operation] : BT Device is disabled!!\n");
  } else {

  }
#line 3885
  goto ldv_55464;
  default: ;
#line 3887
  if (BTCoexDbgLevel == 1U) {
#line 3887
    printk("[bt operation] : Unknown, error!!\n");
  } else {

  }
#line 3888
  goto ldv_55464;
  }
  ldv_55464: 
#line 3890
  BTDM_AdjustForBtOperation(padapter);
#line 3892
  localBuf[0] = '\000';
#line 3892
  tmp = 1U;
#line 3892
  while (1) {
#line 3892
    if (tmp >= 6U) {
#line 3892
      break;
    } else {

    }
#line 3892
    localBuf[tmp] = (unsigned char)0;
#line 3892
    tmp = tmp + 1U;
  }
#line 3894
  len = 0U;
#line 3897
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3899
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 258, status);
#line 3899
  len = (int )tmp___0 + (int )len;
#line 3905
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3906
  *pRetPar = (u8 )status;
#line 3908
  len = (unsigned int )len + 1U;
#line 3909
  PPacketIrpEvent->Length = len;
#line 3911
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3914
  return (status);
}
}
#line 3918 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdEnableWifiScanNotify(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u32 __i ;
  u8 *ptr ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3921
  status = 0;
#line 3922
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 3923
  pBtMgnt = & pBTInfo->BtMgnt;
#line 3925
  if (BTCoexDbgLevel == 1U) {
#line 3925
    ptr = (u8 *)(& pHciCmd->Data);
#line 3925
    printk("Enable Wifi scan notify, Hex Data :\n");
#line 3925
    __i = 0U;
#line 3925
    goto ldv_55489;
    ldv_55488: 
#line 3925
    printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 3925
    if (((__i + 1U) & 15U) == 0U) {
#line 3925
      printk("\n");
    } else {

    }
#line 3925
    __i = __i + 1U;
    ldv_55489: ;
#line 3925
    if ((u32 )pHciCmd->Length > __i) {
#line 3927
      goto ldv_55488;
    } else {

    }
#line 3925
    printk("\n");
  } else {

  }
#line 3928
  pBtMgnt->ExtConfig.bEnableWifiScanNotify = *((u8 *)(& pHciCmd->Data));
#line 3929
  if (BTCoexDbgLevel == 1U) {
#line 3929
    printk("bEnableWifiScanNotify = %d\n", (int )pBtMgnt->ExtConfig.bEnableWifiScanNotify);
  } else {

  }
#line 3932
  localBuf[0] = '\000';
#line 3932
  tmp = 1U;
#line 3932
  while (1) {
#line 3932
    if (tmp >= 6U) {
#line 3932
      break;
    } else {

    }
#line 3932
    localBuf[tmp] = (unsigned char)0;
#line 3932
    tmp = tmp + 1U;
  }
#line 3934
  len = 0U;
#line 3937
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3939
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 259, status);
#line 3939
  len = (int )tmp___0 + (int )len;
#line 3945
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3946
  *pRetPar = (u8 )status;
#line 3948
  len = (unsigned int )len + 1U;
#line 3949
  PPacketIrpEvent->Length = len;
#line 3951
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3954
  return (status);
}
}
#line 3958 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWIFICurrentChannel(struct rtw_adapter *padapter ,
                                                   struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct mlme_ext_priv *pmlmeext ;
  u8 chnl ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 3961
  status = 0;
#line 3962
  pmlmeext = & padapter->mlmeextpriv;
#line 3963
  chnl = pmlmeext->cur_channel;
#line 3965
  if ((unsigned int )pmlmeext->cur_bwmode == 1U) {
#line 3966
    if ((unsigned int )pmlmeext->cur_ch_offset == 2U) {
#line 3967
      chnl = (unsigned int )chnl + 2U;
    } else
#line 3968
    if ((unsigned int )pmlmeext->cur_ch_offset == 1U) {
#line 3969
      chnl = (unsigned int )chnl + 254U;
    } else {

    }
  } else {

  }
#line 3972
  if (BTCoexDbgLevel == 1U) {
#line 3972
    printk("Current Channel  = 0x%x\n", (int )chnl);
  } else {

  }
#line 3975
  localBuf[0] = '\000';
#line 3975
  tmp = 1U;
#line 3975
  while (1) {
#line 3975
    if (tmp >= 8U) {
#line 3975
      break;
    } else {

    }
#line 3975
    localBuf[tmp] = (unsigned char)0;
#line 3975
    tmp = tmp + 1U;
  }
#line 3977
  len = 0U;
#line 3980
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 3982
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 768, status);
#line 3982
  len = (int )tmp___0 + (int )len;
#line 3988
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 3989
  *pRetPar = (u8 )status;
#line 3990
  *(pRetPar + 1UL) = chnl;
#line 3991
  len = (unsigned int )len + 2U;
#line 3992
  PPacketIrpEvent->Length = len;
#line 3994
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 3997
  return (status);
}
}
#line 4001 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWIFICurrentBandwidth(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  enum ht_channel_width bw ;
  u8 CurrentBW ;
  u8 localBuf[8U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 4004
  status = 0;
#line 4006
  CurrentBW = 0U;
#line 4008
  bw = (enum ht_channel_width )padapter->mlmeextpriv.cur_bwmode;
#line 4010
  if ((unsigned int )bw == 0U) {
#line 4011
    CurrentBW = 0U;
  } else
#line 4012
  if ((unsigned int )bw == 1U) {
#line 4013
    CurrentBW = 1U;
  } else {

  }
#line 4015
  if (BTCoexDbgLevel == 1U) {
#line 4015
    printk("Current BW = 0x%x\n", (int )CurrentBW);
  } else {

  }
#line 4019
  localBuf[0] = '\000';
#line 4019
  tmp = 1U;
#line 4019
  while (1) {
#line 4019
    if (tmp >= 8U) {
#line 4019
      break;
    } else {

    }
#line 4019
    localBuf[tmp] = (unsigned char)0;
#line 4019
    tmp = tmp + 1U;
  }
#line 4021
  len = 0U;
#line 4024
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4026
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 769, status);
#line 4026
  len = (int )tmp___0 + (int )len;
#line 4032
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 4033
  *pRetPar = (u8 )status;
#line 4034
  *(pRetPar + 1UL) = CurrentBW;
#line 4035
  len = (unsigned int )len + 2U;
#line 4036
  PPacketIrpEvent->Length = len;
#line 4038
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 4041
  return (status);
}
}
#line 4045 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdWIFIConnectionStatus(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  u8 connectStatus ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  u8 localBuf[8U] ;
  unsigned int tmp___2 ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___3 ;

  {
#line 4050
  status = 0;
#line 4051
  connectStatus = 0U;
#line 4053
  tmp___1 = check_fwstate(& padapter->mlmepriv, 16);
#line 4053
  if ((int )tmp___1) {
#line 4054
    if (padapter->stapriv.asoc_sta_count > 2) {
#line 4055
      connectStatus = 1U;
    } else {
#line 4057
      connectStatus = 0U;
    }
  } else {
#line 4058
    tmp___0 = check_fwstate(& padapter->mlmepriv, 97);
#line 4058
    if ((int )tmp___0) {
#line 4059
      connectStatus = 1U;
    } else {
#line 4060
      tmp = check_fwstate(& padapter->mlmepriv, 128);
#line 4060
      if ((int )tmp) {
#line 4061
        connectStatus = 2U;
      } else {
#line 4063
        connectStatus = 0U;
      }
    }
  }
#line 4067
  localBuf[0] = '\000';
#line 4067
  tmp___2 = 1U;
#line 4067
  while (1) {
#line 4067
    if (tmp___2 >= 8U) {
#line 4067
      break;
    } else {

    }
#line 4067
    localBuf[tmp___2] = (unsigned char)0;
#line 4067
    tmp___2 = tmp___2 + 1U;
  }
#line 4069
  len = 0U;
#line 4072
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4074
  tmp___3 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 63, 770, status);
#line 4074
  len = (int )tmp___3 + (int )len;
#line 4080
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 4081
  *pRetPar = (u8 )status;
#line 4082
  *(pRetPar + 1UL) = connectStatus;
#line 4083
  len = (unsigned int )len + 2U;
#line 4084
  PPacketIrpEvent->Length = len;
#line 4086
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 4089
  return (status);
}
}
#line 4093 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdEnableDeviceUnderTestMode(struct rtw_adapter *padapter ,
                                                          struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;

  {
#line 4098
  status = 0;
#line 4099
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4100
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 4102
  pBtHciInfo->bInTestMode = 1U;
#line 4103
  pBtHciInfo->bTestIsEnd = 0U;
#line 4107
  localBuf[0] = '\000';
#line 4107
  tmp = 1U;
#line 4107
  while (1) {
#line 4107
    if (tmp >= 6U) {
#line 4107
      break;
    } else {

    }
#line 4107
    localBuf[tmp] = (unsigned char)0;
#line 4107
    tmp = tmp + 1U;
  }
#line 4109
  len = 0U;
#line 4112
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4114
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 6, 3, status);
#line 4114
  len = (int )tmp___0 + (int )len;
#line 4120
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 4121
  *pRetPar = (u8 )status;
#line 4122
  len = (unsigned int )len + 1U;
#line 4123
  PPacketIrpEvent->Length = len;
#line 4125
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 4128
  return (status);
}
}
#line 4132 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdAMPTestEnd(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[4U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;

  {
#line 4135
  status = 0;
#line 4136
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4137
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 4139
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
#line 4140
    if (BTCoexDbgLevel == 1U) {
#line 4140
      printk("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n");
    } else {

    }
#line 4141
    status = 12;
#line 4142
    return (status);
  } else {

  }
#line 4145
  pBtHciInfo->bTestIsEnd = 1U;
#line 4147
  ldv_del_timer_sync_2427(& pBTInfo->BTTestSendPacketTimer);
#line 4149
  rtl8723a_check_bssid(padapter, 1);
#line 4153
  localBuf[0] = '\000';
#line 4153
  tmp = 1U;
#line 4153
  while (1) {
#line 4153
    if (tmp >= 4U) {
#line 4153
      break;
    } else {

    }
#line 4153
    localBuf[tmp] = (unsigned char)0;
#line 4153
    tmp = tmp + 1U;
  }
#line 4156
  if (BTCoexDbgLevel == 1U) {
#line 4156
    printk("AMP Test End Event \n");
  } else {

  }
#line 4157
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4158
  PPacketIrpEvent->EventCode = 74U;
#line 4159
  PPacketIrpEvent->Length = 2U;
#line 4161
  PPacketIrpEvent->Data[0] = (u8 )status;
#line 4162
  PPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario;
#line 4164
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 4167
  bthci_EventAMPReceiverReport(padapter, 1);
#line 4169
  return (status);
}
}
#line 4173 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdAMPTestCommand(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[5U] ;
  unsigned int tmp ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 localBuf___0[5U] ;
  unsigned int tmp___0 ;
  struct packet_irp_hcievent_data *PPacketIrpEvent___0 ;
  unsigned long tmp___1 ;

  {
#line 4176
  status = 0;
#line 4177
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4178
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 4180
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
#line 4181
    if (BTCoexDbgLevel == 1U) {
#line 4181
      printk("Not in Test mode, return status = HCI_STATUS_CMD_DISALLOW\n");
    } else {

    }
#line 4182
    status = 12;
#line 4183
    return (status);
  } else {

  }
#line 4186
  pBtHciInfo->TestScenario = *((u8 *)(& pHciCmd->Data));
#line 4188
  if ((unsigned int )pBtHciInfo->TestScenario == 1U) {
#line 4189
    if (BTCoexDbgLevel == 1U) {
#line 4189
      printk("TX Single Test \n");
    } else {

    }
  } else
#line 4190
  if ((unsigned int )pBtHciInfo->TestScenario == 2U) {
#line 4191
    if (BTCoexDbgLevel == 1U) {
#line 4191
      printk("Receive Frame Test \n");
    } else {

    }
  } else
#line 4193
  if (BTCoexDbgLevel == 1U) {
#line 4193
    printk("No Such Test !!!!!!!!!!!!!!!!!! \n");
  } else {

  }
#line 4195
  if ((unsigned int )pBtHciInfo->bTestIsEnd != 0U) {
#line 4196
    localBuf[0] = '\000';
#line 4196
    tmp = 1U;
#line 4196
    while (1) {
#line 4196
      if (tmp >= 5U) {
#line 4196
        break;
      } else {

      }
#line 4196
      localBuf[tmp] = (unsigned char)0;
#line 4196
      tmp = tmp + 1U;
    }
#line 4199
    if (BTCoexDbgLevel == 1U) {
#line 4199
      printk("AMP Test End Event \n");
    } else {

    }
#line 4200
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4201
    PPacketIrpEvent->EventCode = 74U;
#line 4202
    PPacketIrpEvent->Length = 2U;
#line 4204
    PPacketIrpEvent->Data[0] = (u8 )status;
#line 4205
    PPacketIrpEvent->Data[1] = pBtHciInfo->TestScenario;
#line 4207
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, 4U);
#line 4211
    return (status);
  } else {

  }
#line 4215
  bthci_EventCommandStatus(padapter, 6, 9, status);
#line 4225
  localBuf___0[0] = '\000';
#line 4225
  tmp___0 = 1U;
#line 4225
  while (1) {
#line 4225
    if (tmp___0 >= 5U) {
#line 4225
      break;
    } else {

    }
#line 4225
    localBuf___0[tmp___0] = (unsigned char)0;
#line 4225
    tmp___0 = tmp___0 + 1U;
  }
#line 4228
  if (BTCoexDbgLevel == 1U) {
#line 4228
    printk(" HCI_AMP_Start Test Event \n");
  } else {

  }
#line 4229
  PPacketIrpEvent___0 = (struct packet_irp_hcievent_data *)(& localBuf___0);
#line 4230
  PPacketIrpEvent___0->EventCode = 73U;
#line 4231
  PPacketIrpEvent___0->Length = 2U;
#line 4233
  PPacketIrpEvent___0->Data[0] = (u8 )status;
#line 4234
  PPacketIrpEvent___0->Data[1] = pBtHciInfo->TestScenario;
#line 4236
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent___0, 4U);
#line 4241
  if ((unsigned int )pBtHciInfo->TestScenario == 1U) {
#line 4246
    tmp___1 = msecs_to_jiffies(50U);
#line 4246
    ldv_mod_timer_2428(& pBTInfo->BTTestSendPacketTimer, tmp___1 + (unsigned long )jiffies);
#line 4248
    if (BTCoexDbgLevel == 1U) {
#line 4248
      printk("TX Single Test \n");
    } else {

    }
  } else
#line 4249
  if ((unsigned int )pBtHciInfo->TestScenario == 2U) {
#line 4250
    rtl8723a_check_bssid(padapter, 0);
#line 4251
    if (BTCoexDbgLevel == 1U) {
#line 4251
      printk("Receive Frame Test \n");
    } else {

    }
  } else {

  }
#line 4254
  return (status);
}
}
#line 4258 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdEnableAMPReceiverReports(struct rtw_adapter *padapter ,
                                                         struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 tmp___0 ;
  u8 localBuf___0[6U] ;
  unsigned int tmp___1 ;
  u8 *pRetPar___0 ;
  u8 len___0 ;
  struct packet_irp_hcievent_data *PPacketIrpEvent___0 ;
  u8 tmp___2 ;

  {
#line 4261
  status = 0;
#line 4262
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4263
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 4265
  if ((unsigned int )pBtHciInfo->bInTestMode == 0U) {
#line 4266
    status = 12;
#line 4269
    localBuf[0] = '\000';
#line 4269
    tmp = 1U;
#line 4269
    while (1) {
#line 4269
      if (tmp >= 6U) {
#line 4269
        break;
      } else {

      }
#line 4269
      localBuf[tmp] = (unsigned char)0;
#line 4269
      tmp = tmp + 1U;
    }
#line 4271
    len = 0U;
#line 4274
    PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4276
    tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 6, 7, status);
#line 4276
    len = (int )tmp___0 + (int )len;
#line 4282
    pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 4283
    *pRetPar = (u8 )status;
#line 4284
    len = (unsigned int )len + 1U;
#line 4285
    PPacketIrpEvent->Length = len;
#line 4287
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 4289
    return (status);
  } else {

  }
#line 4292
  pBtHciInfo->bTestNeedReport = *((u8 *)(& pHciCmd->Data));
#line 4293
  pBtHciInfo->TestReportInterval = *((u8 *)(& pHciCmd->Data) + 2UL);
#line 4295
  bthci_EventAMPReceiverReport(padapter, 0);
#line 4299
  localBuf___0[0] = '\000';
#line 4299
  tmp___1 = 1U;
#line 4299
  while (1) {
#line 4299
    if (tmp___1 >= 6U) {
#line 4299
      break;
    } else {

    }
#line 4299
    localBuf___0[tmp___1] = (unsigned char)0;
#line 4299
    tmp___1 = tmp___1 + 1U;
  }
#line 4301
  len___0 = 0U;
#line 4304
  PPacketIrpEvent___0 = (struct packet_irp_hcievent_data *)(& localBuf___0);
#line 4306
  tmp___2 = bthci_CommandCompleteHeader((u8 *)(& localBuf___0), 6, 7, status);
#line 4306
  len___0 = (int )tmp___2 + (int )len___0;
#line 4312
  pRetPar___0 = (u8 *)(& PPacketIrpEvent___0->Data) + (unsigned long )len___0;
#line 4313
  *pRetPar___0 = (u8 )status;
#line 4314
  len___0 = (unsigned int )len___0 + 1U;
#line 4315
  PPacketIrpEvent___0->Length = len___0;
#line 4317
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent___0, (u32 )((int )len___0 + 2));
#line 4320
  return (status);
}
}
#line 4324 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdHostBufferSize(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  enum hci_status status ;
  u8 localBuf[6U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 len ;
  u8 tmp___0 ;

  {
#line 4327
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4328
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4330
  status = 0;
#line 4331
  localBuf[0] = '\000';
#line 4331
  tmp = 1U;
#line 4331
  while (1) {
#line 4331
    if (tmp >= 6U) {
#line 4331
      break;
    } else {

    }
#line 4331
    localBuf[tmp] = (unsigned char)0;
#line 4331
    tmp = tmp + 1U;
  }
#line 4333
  len = 0U;
#line 4335
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].ACLPacketsData.ACLDataPacketLen = *((u16 *)(& pHciCmd->Data));
#line 4336
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].SyncDataPacketLen = *((u8 *)(& pHciCmd->Data) + 2UL);
#line 4337
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].TotalNumACLDataPackets = *((u16 *)(& pHciCmd->Data) + 3U);
#line 4338
  pBTInfo->BtAsocEntry[(int )pBtMgnt->CurrentConnectEntryNum].TotalSyncNumDataPackets = *((u16 *)(& pHciCmd->Data) + 5U);
#line 4341
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 4343
  tmp___0 = bthci_CommandCompleteHeader((u8 *)(& localBuf), 3, 51, status);
#line 4343
  len = (int )tmp___0 + (int )len;
#line 4349
  pRetPar = (u8 *)(& PPacketIrpEvent->Data) + (unsigned long )len;
#line 4350
  *pRetPar = (u8 )status;
#line 4351
  len = (unsigned int )len + 1U;
#line 4352
  PPacketIrpEvent->Length = len;
#line 4354
  bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 4356
  return (status);
}
}
#line 4360 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_CmdHostNumberOfCompletedPackets(struct rtw_adapter *padapter ,
                                                             struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4363
  status = 0;
#line 4365
  return (status);
}
}
#line 4369 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_UnknownCMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;

  {
#line 4371
  status = 1;
#line 4372
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4373
  pBtDbg = & pBTInfo->BtDbg;
#line 4375
  pBtDbg->dbgHciInfo.hciCmdCntUnknown = pBtDbg->dbgHciInfo.hciCmdCntUnknown + 1U;
#line 4376
  bthci_EventCommandStatus(padapter, (int )pHciCmd->OGF, (int )pHciCmd->OCF, status);
#line 4381
  return (status);
}
}
#line 4385 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_HandleOGFInformationalParameters(struct rtw_adapter *padapter ,
                                                              struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4388
  status = 0;
#line 4390
  switch ((int )pHciCmd->OCF) {
  case 1: ;
#line 4392
  if (BTCoexDbgLevel == 1U) {
#line 4392
    printk("HCI_READ_LOCAL_VERSION_INFORMATION\n");
  } else {

  }
#line 4393
  status = bthci_CmdReadLocalVersionInformation(padapter);
#line 4394
  goto ldv_55602;
  case 2: ;
#line 4396
  if (BTCoexDbgLevel == 1U) {
#line 4396
    printk("HCI_READ_LOCAL_SUPPORTED_COMMANDS\n");
  } else {

  }
#line 4397
  status = bthci_CmdReadLocalSupportedCommands(padapter);
#line 4398
  goto ldv_55602;
  case 3: ;
#line 4400
  if (BTCoexDbgLevel == 1U) {
#line 4400
    printk("HCI_READ_LOCAL_SUPPORTED_FEATURES\n");
  } else {

  }
#line 4401
  status = bthci_CmdReadLocalSupportedFeatures(padapter);
#line 4402
  goto ldv_55602;
  case 5: ;
#line 4404
  if (BTCoexDbgLevel == 1U) {
#line 4404
    printk("HCI_READ_BUFFER_SIZE\n");
  } else {

  }
#line 4405
  status = bthci_CmdReadBufferSize(padapter);
#line 4406
  goto ldv_55602;
  case 10: ;
#line 4408
  if (BTCoexDbgLevel == 1U) {
#line 4408
    printk("HCI_READ_DATA_BLOCK_SIZE\n");
  } else {

  }
#line 4409
  status = bthci_CmdReadDataBlockSize(padapter);
#line 4410
  goto ldv_55602;
  default: ;
#line 4412
  if (BTCoexDbgLevel == 1U) {
#line 4412
    printk("bthci_HandleOGFInformationalParameters(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
#line 4413
  if (BTCoexDbgLevel == 1U) {
#line 4413
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4414
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4415
  goto ldv_55602;
  }
  ldv_55602: ;
#line 4417
  return (status);
}
}
#line 4421 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_HandleOGFSetEventMaskCMD(struct rtw_adapter *padapter ,
                                                      struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4424
  status = 0;
#line 4426
  switch ((int )pHciCmd->OCF) {
  case 1: ;
#line 4428
  if (BTCoexDbgLevel == 1U) {
#line 4428
    printk("HCI_SET_EVENT_MASK\n");
  } else {

  }
#line 4429
  status = bthci_CmdSetEventMask(padapter, pHciCmd);
#line 4430
  goto ldv_55614;
  case 3: ;
#line 4432
  if (BTCoexDbgLevel == 1U) {
#line 4432
    printk("HCI_RESET\n");
  } else {

  }
#line 4433
  status = bthci_CmdReset(padapter, 1);
#line 4434
  goto ldv_55614;
  case 21: ;
#line 4436
  if (BTCoexDbgLevel == 1U) {
#line 4436
    printk("HCI_READ_CONNECTION_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4437
  status = bthci_CmdReadConnectionAcceptTimeout(padapter);
#line 4438
  goto ldv_55614;
  case 5: ;
#line 4440
  if (BTCoexDbgLevel == 1U) {
#line 4440
    printk("HCI_SET_EVENT_FILTER\n");
  } else {

  }
#line 4441
  status = bthci_CmdSetEventFilter(padapter, pHciCmd);
#line 4442
  goto ldv_55614;
  case 22: ;
#line 4444
  if (BTCoexDbgLevel == 1U) {
#line 4444
    printk("HCI_WRITE_CONNECTION_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4445
  status = bthci_CmdWriteConnectionAcceptTimeout(padapter, pHciCmd);
#line 4446
  goto ldv_55614;
  case 23: ;
#line 4448
  if (BTCoexDbgLevel == 1U) {
#line 4448
    printk("HCI_READ_PAGE_TIMEOUT\n");
  } else {

  }
#line 4449
  status = bthci_CmdReadPageTimeout(padapter, pHciCmd);
#line 4450
  goto ldv_55614;
  case 24: ;
#line 4452
  if (BTCoexDbgLevel == 1U) {
#line 4452
    printk("HCI_WRITE_PAGE_TIMEOUT\n");
  } else {

  }
#line 4453
  status = bthci_CmdWritePageTimeout(padapter, pHciCmd);
#line 4454
  goto ldv_55614;
  case 53: ;
#line 4456
  if (BTCoexDbgLevel == 1U) {
#line 4456
    printk("HCI_HOST_NUMBER_OF_COMPLETED_PACKETS\n");
  } else {

  }
#line 4457
  status = bthci_CmdHostNumberOfCompletedPackets(padapter, pHciCmd);
#line 4458
  goto ldv_55614;
  case 54: ;
#line 4460
  if (BTCoexDbgLevel == 1U) {
#line 4460
    printk("HCI_READ_LINK_SUPERVISION_TIMEOUT\n");
  } else {

  }
#line 4461
  status = bthci_CmdReadLinkSupervisionTimeout(padapter, pHciCmd);
#line 4462
  goto ldv_55614;
  case 55: ;
#line 4464
  if (BTCoexDbgLevel == 1U) {
#line 4464
    printk("HCI_WRITE_LINK_SUPERVISION_TIMEOUT\n");
  } else {

  }
#line 4465
  status = bthci_CmdWriteLinkSupervisionTimeout(padapter, pHciCmd);
#line 4466
  goto ldv_55614;
  case 95: ;
#line 4468
  if (BTCoexDbgLevel == 1U) {
#line 4468
    printk("HCI_ENHANCED_FLUSH\n");
  } else {

  }
#line 4469
  status = bthci_CmdEnhancedFlush(padapter, pHciCmd);
#line 4470
  goto ldv_55614;
  case 97: ;
#line 4472
  if (BTCoexDbgLevel == 1U) {
#line 4472
    printk("HCI_READ_LOGICAL_LINK_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4473
  status = bthci_CmdReadLogicalLinkAcceptTimeout(padapter, pHciCmd);
#line 4474
  goto ldv_55614;
  case 98: ;
#line 4476
  if (BTCoexDbgLevel == 1U) {
#line 4476
    printk("HCI_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4477
  status = bthci_CmdWriteLogicalLinkAcceptTimeout(padapter, pHciCmd);
#line 4478
  goto ldv_55614;
  case 99: ;
#line 4480
  if (BTCoexDbgLevel == 1U) {
#line 4480
    printk("HCI_SET_EVENT_MASK_PAGE_2\n");
  } else {

  }
#line 4481
  status = bthci_CmdSetEventMaskPage2(padapter, pHciCmd);
#line 4482
  goto ldv_55614;
  case 100: ;
#line 4484
  if (BTCoexDbgLevel == 1U) {
#line 4484
    printk("HCI_READ_LOCATION_DATA\n");
  } else {

  }
#line 4485
  status = bthci_CmdReadLocationData(padapter, pHciCmd);
#line 4486
  goto ldv_55614;
  case 101: ;
#line 4488
  if (BTCoexDbgLevel == 1U) {
#line 4488
    printk("HCI_WRITE_LOCATION_DATA\n");
  } else {

  }
#line 4489
  status = bthci_CmdWriteLocationData(padapter, pHciCmd);
#line 4490
  goto ldv_55614;
  case 102: ;
#line 4492
  if (BTCoexDbgLevel == 1U) {
#line 4492
    printk("HCI_READ_FLOW_CONTROL_MODE\n");
  } else {

  }
#line 4493
  status = bthci_CmdReadFlowControlMode(padapter, pHciCmd);
#line 4494
  goto ldv_55614;
  case 103: ;
#line 4496
  if (BTCoexDbgLevel == 1U) {
#line 4496
    printk("HCI_WRITE_FLOW_CONTROL_MODE\n");
  } else {

  }
#line 4497
  status = bthci_CmdWriteFlowControlMode(padapter, pHciCmd);
#line 4498
  goto ldv_55614;
  case 105: ;
#line 4500
  if (BTCoexDbgLevel == 1U) {
#line 4500
    printk("HCI_READ_BEST_EFFORT_FLUSH_TIMEOUT\n");
  } else {

  }
#line 4501
  status = bthci_CmdReadBestEffortFlushTimeout(padapter, pHciCmd);
#line 4502
  goto ldv_55614;
  case 106: ;
#line 4504
  if (BTCoexDbgLevel == 1U) {
#line 4504
    printk("HCI_WRITE_BEST_EFFORT_FLUSH_TIMEOUT\n");
  } else {

  }
#line 4505
  status = bthci_CmdWriteBestEffortFlushTimeout(padapter, pHciCmd);
#line 4506
  goto ldv_55614;
  case 107: ;
#line 4508
  if (BTCoexDbgLevel == 1U) {
#line 4508
    printk("HCI_SHORT_RANGE_MODE\n");
  } else {

  }
#line 4509
  status = bthci_CmdShortRangeMode(padapter, pHciCmd);
#line 4510
  goto ldv_55614;
  case 51: ;
#line 4512
  if (BTCoexDbgLevel == 1U) {
#line 4512
    printk("HCI_HOST_BUFFER_SIZE\n");
  } else {

  }
#line 4513
  status = bthci_CmdHostBufferSize(padapter, pHciCmd);
#line 4514
  goto ldv_55614;
  default: ;
#line 4516
  if (BTCoexDbgLevel == 1U) {
#line 4516
    printk("bthci_HandleOGFSetEventMaskCMD(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
#line 4517
  if (BTCoexDbgLevel == 1U) {
#line 4517
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4518
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4519
  goto ldv_55614;
  }
  ldv_55614: ;
#line 4521
  return (status);
}
}
#line 4525 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_HandleOGFStatusParameters(struct rtw_adapter *padapter ,
                                                       struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4528
  status = 0;
#line 4530
  switch ((int )pHciCmd->OCF) {
  case 1: ;
#line 4532
  if (BTCoexDbgLevel == 1U) {
#line 4532
    printk("HCI_READ_FAILED_CONTACT_COUNTER\n");
  } else {

  }
#line 4533
  status = bthci_CmdReadFailedContactCounter(padapter, pHciCmd);
#line 4534
  goto ldv_55643;
  case 2: ;
#line 4536
  if (BTCoexDbgLevel == 1U) {
#line 4536
    printk("HCI_RESET_FAILED_CONTACT_COUNTER\n");
  } else {

  }
#line 4537
  status = bthci_CmdResetFailedContactCounter(padapter, pHciCmd);
#line 4538
  goto ldv_55643;
  case 3: ;
#line 4540
  if (BTCoexDbgLevel == 1U) {
#line 4540
    printk("HCI_READ_LINK_QUALITY\n");
  } else {

  }
#line 4541
  status = bthci_CmdReadLinkQuality(padapter, pHciCmd);
#line 4542
  goto ldv_55643;
  case 5: ;
#line 4544
  if (BTCoexDbgLevel == 1U) {
#line 4544
    printk("HCI_READ_RSSI\n");
  } else {

  }
#line 4545
  status = bthci_CmdReadRSSI(padapter);
#line 4546
  goto ldv_55643;
  case 9: ;
#line 4548
  if (BTCoexDbgLevel == 1U) {
#line 4548
    printk("HCI_READ_LOCAL_AMP_INFO\n");
  } else {

  }
#line 4549
  status = bthci_CmdReadLocalAMPInfo(padapter);
#line 4550
  goto ldv_55643;
  case 10: ;
#line 4552
  if (BTCoexDbgLevel == 1U) {
#line 4552
    printk("HCI_READ_LOCAL_AMP_ASSOC\n");
  } else {

  }
#line 4553
  status = bthci_CmdReadLocalAMPAssoc(padapter, pHciCmd);
#line 4554
  goto ldv_55643;
  case 11: ;
#line 4556
  if (BTCoexDbgLevel == 1U) {
#line 4556
    printk("HCI_WRITE_REMOTE_AMP_ASSOC\n");
  } else {

  }
#line 4557
  status = bthci_CmdWriteRemoteAMPAssoc(padapter, pHciCmd);
#line 4558
  goto ldv_55643;
  default: ;
#line 4560
  if (BTCoexDbgLevel == 1U) {
#line 4560
    printk("bthci_HandleOGFStatusParameters(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
#line 4561
  if (BTCoexDbgLevel == 1U) {
#line 4561
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4562
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4563
  goto ldv_55643;
  }
  ldv_55643: ;
#line 4565
  return (status);
}
}
#line 4569 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_HandleOGFLinkControlCMD(struct rtw_adapter *padapter ,
                                                     struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4572
  status = 0;
#line 4574
  switch ((int )pHciCmd->OCF) {
  case 53: ;
#line 4576
  if (BTCoexDbgLevel == 1U) {
#line 4576
    printk("HCI_CREATE_PHYSICAL_LINK\n");
  } else {

  }
#line 4577
  status = bthci_CmdCreatePhysicalLink(padapter, pHciCmd);
#line 4578
  goto ldv_55657;
  case 54: ;
#line 4580
  if (BTCoexDbgLevel == 1U) {
#line 4580
    printk("HCI_ACCEPT_PHYSICAL_LINK\n");
  } else {

  }
#line 4581
  status = bthci_CmdAcceptPhysicalLink(padapter, pHciCmd);
#line 4582
  goto ldv_55657;
  case 55: ;
#line 4584
  if (BTCoexDbgLevel == 1U) {
#line 4584
    printk("HCI_DISCONNECT_PHYSICAL_LINK\n");
  } else {

  }
#line 4585
  status = bthci_CmdDisconnectPhysicalLink(padapter, pHciCmd);
#line 4586
  goto ldv_55657;
  case 56: ;
#line 4588
  if (BTCoexDbgLevel == 1U) {
#line 4588
    printk("HCI_CREATE_LOGICAL_LINK\n");
  } else {

  }
#line 4589
  status = bthci_CmdCreateLogicalLink(padapter, pHciCmd);
#line 4590
  goto ldv_55657;
  case 57: ;
#line 4592
  if (BTCoexDbgLevel == 1U) {
#line 4592
    printk("HCI_ACCEPT_LOGICAL_LINK\n");
  } else {

  }
#line 4593
  status = bthci_CmdAcceptLogicalLink(padapter, pHciCmd);
#line 4594
  goto ldv_55657;
  case 58: ;
#line 4596
  if (BTCoexDbgLevel == 1U) {
#line 4596
    printk("HCI_DISCONNECT_LOGICAL_LINK\n");
  } else {

  }
#line 4597
  status = bthci_CmdDisconnectLogicalLink(padapter, pHciCmd);
#line 4598
  goto ldv_55657;
  case 59: ;
#line 4600
  if (BTCoexDbgLevel == 1U) {
#line 4600
    printk("HCI_LOGICAL_LINK_CANCEL\n");
  } else {

  }
#line 4601
  status = bthci_CmdLogicalLinkCancel(padapter, pHciCmd);
#line 4602
  goto ldv_55657;
  case 60: ;
#line 4604
  if (BTCoexDbgLevel == 1U) {
#line 4604
    printk("HCI_FLOW_SPEC_MODIFY\n");
  } else {

  }
#line 4605
  status = bthci_CmdFlowSpecModify(padapter, pHciCmd);
#line 4606
  goto ldv_55657;
  default: ;
#line 4608
  if (BTCoexDbgLevel == 1U) {
#line 4608
    printk("bthci_HandleOGFLinkControlCMD(), Unknown case = 0x%x\n", (int )pHciCmd->OCF);
  } else {

  }
#line 4609
  if (BTCoexDbgLevel == 1U) {
#line 4609
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4610
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4611
  goto ldv_55657;
  }
  ldv_55657: ;
#line 4613
  return (status);
}
}
#line 4617 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_HandleOGFTestingCMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4620
  status = 0;
#line 4621
  switch ((int )pHciCmd->OCF) {
  case 3: ;
#line 4623
  if (BTCoexDbgLevel == 1U) {
#line 4623
    printk("HCI_ENABLE_DEVICE_UNDER_TEST_MODE\n");
  } else {

  }
#line 4624
  bthci_CmdEnableDeviceUnderTestMode(padapter, pHciCmd);
#line 4625
  goto ldv_55672;
  case 8: ;
#line 4627
  if (BTCoexDbgLevel == 1U) {
#line 4627
    printk("HCI_AMP_TEST_END\n");
  } else {

  }
#line 4628
  bthci_CmdAMPTestEnd(padapter, pHciCmd);
#line 4629
  goto ldv_55672;
  case 9: ;
#line 4631
  if (BTCoexDbgLevel == 1U) {
#line 4631
    printk("HCI_AMP_TEST_COMMAND\n");
  } else {

  }
#line 4632
  bthci_CmdAMPTestCommand(padapter, pHciCmd);
#line 4633
  goto ldv_55672;
  case 7: ;
#line 4635
  if (BTCoexDbgLevel == 1U) {
#line 4635
    printk("HCI_ENABLE_AMP_RECEIVER_REPORTS\n");
  } else {

  }
#line 4636
  bthci_CmdEnableAMPReceiverReports(padapter, pHciCmd);
#line 4637
  goto ldv_55672;
  default: ;
#line 4639
  if (BTCoexDbgLevel == 1U) {
#line 4639
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4640
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4641
  goto ldv_55672;
  }
  ldv_55672: ;
#line 4643
  return (status);
}
}
#line 4647 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static enum hci_status bthci_HandleOGFExtension(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;

  {
#line 4650
  status = 0;
#line 4651
  switch ((int )pHciCmd->OCF) {
  case 16: ;
#line 4653
  if (BTCoexDbgLevel == 1U) {
#line 4653
    printk("HCI_SET_ACL_LINK_DATA_FLOW_MODE\n");
  } else {

  }
#line 4654
  status = bthci_CmdSetACLLinkDataFlowMode(padapter, pHciCmd);
#line 4655
  goto ldv_55683;
  case 32: ;
#line 4657
  if (BTCoexDbgLevel == 1U) {
#line 4657
    printk("HCI_SET_ACL_LINK_STATUS\n");
  } else {

  }
#line 4658
  status = bthci_CmdSetACLLinkStatus(padapter, pHciCmd);
#line 4659
  goto ldv_55683;
  case 48: ;
#line 4661
  if (BTCoexDbgLevel == 1U) {
#line 4661
    printk("HCI_SET_SCO_LINK_STATUS\n");
  } else {

  }
#line 4662
  status = bthci_CmdSetSCOLinkStatus(padapter, pHciCmd);
#line 4663
  goto ldv_55683;
  case 64: ;
#line 4665
  if (BTCoexDbgLevel == 1U) {
#line 4665
    printk("HCI_SET_RSSI_VALUE\n");
  } else {

  }
#line 4666
  status = bthci_CmdSetRSSIValue(padapter, pHciCmd);
#line 4667
  goto ldv_55683;
  case 65: ;
#line 4669
  if (BTCoexDbgLevel == 1U) {
#line 4669
    printk("HCI_SET_CURRENT_BLUETOOTH_STATUS\n");
  } else {

  }
#line 4670
  status = bthci_CmdSetCurrentBluetoothStatus(padapter, pHciCmd);
#line 4671
  goto ldv_55683;
  case 256: ;
#line 4675
  if (BTCoexDbgLevel == 1U) {
#line 4675
    printk("HCI_EXTENSION_VERSION_NOTIFY\n");
  } else {

  }
#line 4676
  status = bthci_CmdExtensionVersionNotify(padapter, pHciCmd);
#line 4677
  goto ldv_55683;
  case 257: ;
#line 4679
  if (BTCoexDbgLevel == 1U) {
#line 4679
    printk("HCI_LINK_STATUS_NOTIFY\n");
  } else {

  }
#line 4680
  status = bthci_CmdLinkStatusNotify(padapter, pHciCmd);
#line 4681
  goto ldv_55683;
  case 258: ;
#line 4683
  if (BTCoexDbgLevel == 1U) {
#line 4683
    printk("HCI_BT_OPERATION_NOTIFY\n");
  } else {

  }
#line 4684
  status = bthci_CmdBtOperationNotify(padapter, pHciCmd);
#line 4685
  goto ldv_55683;
  case 259: ;
#line 4687
  if (BTCoexDbgLevel == 1U) {
#line 4687
    printk("HCI_ENABLE_WIFI_SCAN_NOTIFY\n");
  } else {

  }
#line 4688
  status = bthci_CmdEnableWifiScanNotify(padapter, pHciCmd);
#line 4689
  goto ldv_55683;
  case 768: ;
#line 4693
  if (BTCoexDbgLevel == 1U) {
#line 4693
    printk("HCI_WIFI_CURRENT_CHANNEL\n");
  } else {

  }
#line 4694
  status = bthci_CmdWIFICurrentChannel(padapter, pHciCmd);
#line 4695
  goto ldv_55683;
  case 769: ;
#line 4697
  if (BTCoexDbgLevel == 1U) {
#line 4697
    printk("HCI_WIFI_CURRENT_BANDWIDTH\n");
  } else {

  }
#line 4698
  status = bthci_CmdWIFICurrentBandwidth(padapter, pHciCmd);
#line 4699
  goto ldv_55683;
  case 770: ;
#line 4701
  if (BTCoexDbgLevel == 1U) {
#line 4701
    printk("HCI_WIFI_CONNECTION_STATUS\n");
  } else {

  }
#line 4702
  status = bthci_CmdWIFIConnectionStatus(padapter, pHciCmd);
#line 4703
  goto ldv_55683;
  default: ;
#line 4706
  if (BTCoexDbgLevel == 1U) {
#line 4706
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 4707
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 4708
  goto ldv_55683;
  }
  ldv_55683: ;
#line 4710
  return (status);
}
}
#line 4714 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_StateStarting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4717
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4718
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4720
  if (BTCoexDbgLevel == 1U) {
#line 4720
    printk("[BT state], [Starting], ");
  } else {

  }
#line 4721
  switch ((unsigned int )StateCmd) {
  case 3U: ;
#line 4723
  if (BTCoexDbgLevel == 1U) {
#line 4723
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4724
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
#line 4725
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
#line 4726
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4727
  goto ldv_55704;
  case 2U: ;
#line 4729
  if (BTCoexDbgLevel == 1U) {
#line 4729
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4731
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4736
  ldv_del_timer_sync_2429(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4738
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
#line 4740
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4741
  goto ldv_55704;
  case 4U: ;
#line 4743
  if (BTCoexDbgLevel == 1U) {
#line 4743
    printk("STATE_CMD_MAC_START_COMPLETE\n");
  } else {

  }
#line 4744
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 1U) {
#line 4745
    bthci_EventChannelSelected(padapter, (int )EntryNum);
  } else {

  }
#line 4746
  goto ldv_55704;
  default: ;
#line 4748
  if (BTCoexDbgLevel == 1U) {
#line 4748
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4749
  goto ldv_55704;
  }
  ldv_55704: ;
#line 4752
  return;
}
}
#line 4754 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_StateConnecting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                  u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4757
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4758
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4760
  if (BTCoexDbgLevel == 1U) {
#line 4760
    printk("[BT state], [Connecting], ");
  } else {

  }
#line 4761
  switch ((unsigned int )StateCmd) {
  case 3U: ;
#line 4763
  if (BTCoexDbgLevel == 1U) {
#line 4763
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4764
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
#line 4765
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
#line 4766
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4767
  goto ldv_55716;
  case 6U: ;
#line 4769
  if (BTCoexDbgLevel == 1U) {
#line 4769
    printk("STATE_CMD_MAC_CONNECT_COMPLETE\n");
  } else {

  }
#line 4771
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole == 2U) {
#line 4772
    if (GlobalDebugLevel23A > 6U) {
#line 4772
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 4096U, 7);
#line 4772
      printk("\016StateConnecting \n");
    } else {

    }
  } else {

  }
#line 4775
  goto ldv_55716;
  case 2U: ;
#line 4777
  if (BTCoexDbgLevel == 1U) {
#line 4777
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4779
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4784
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
#line 4786
  ldv_del_timer_sync_2430(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4788
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4790
  goto ldv_55716;
  case 9U: ;
#line 4792
  if (BTCoexDbgLevel == 1U) {
#line 4792
    printk("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n");
  } else {

  }
#line 4793
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 58;
#line 4796
  pBtMgnt->bNeedNotifyAMPNoCap = 0U;
#line 4797
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4798
  goto ldv_55716;
  default: ;
#line 4800
  if (BTCoexDbgLevel == 1U) {
#line 4800
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4801
  goto ldv_55716;
  }
  ldv_55716: ;
#line 4804
  return;
}
}
#line 4806 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_StateConnected(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                 u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;
  u16 logicHandle ;

  {
#line 4810
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4811
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4813
  logicHandle = 0U;
#line 4815
  if (BTCoexDbgLevel == 1U) {
#line 4815
    printk("[BT state], [Connected], ");
  } else {

  }
#line 4816
  switch ((unsigned int )StateCmd) {
  case 2U: ;
#line 4818
  if (BTCoexDbgLevel == 1U) {
#line 4818
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4821
  i = 0U;
#line 4821
  goto ldv_55732;
  ldv_55731: ;
#line 4822
  if ((unsigned int )((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle != 0U) {
#line 4823
    logicHandle = ((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle;
#line 4825
    bthci_EventDisconnectLogicalLinkComplete(padapter, 0, (int )logicHandle, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason);
#line 4828
    ((struct hci_log_link_cmd_data *)(& pBTInfo->BtAsocEntry[(int )EntryNum].LogLinkCmdData))->BtLogLinkhandle = 0U;
  } else {

  }
#line 4821
  i = (u8 )((int )i + 1);
  ldv_55732: ;
#line 4821
  if ((unsigned int )i <= 1U) {
#line 4823
    goto ldv_55731;
  } else {

  }
#line 4832
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4837
  ldv_del_timer_sync_2431(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4839
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4840
  goto ldv_55734;
  case 8U: ;
#line 4843
  if (BTCoexDbgLevel == 1U) {
#line 4843
    printk("STATE_CMD_MAC_DISCONNECT_INDICATE\n");
  } else {

  }
#line 4845
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, 22, (int )EntryNum);
#line 4850
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4852
  goto ldv_55734;
  case 12U: ;
#line 4854
  if (BTCoexDbgLevel == 1U) {
#line 4854
    printk("STATE_CMD_ENTER_STATE\n");
  } else {

  }
#line 4856
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 4857
    pBtMgnt->bBTConnectInProgress = 0U;
#line 4858
    if (BTCoexDbgLevel == 1U) {
#line 4858
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
#line 4860
  pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState = 8U;
#line 4861
  pBTInfo->BtAsocEntry[(int )EntryNum].b4waySuccess = 1U;
#line 4862
  pBtMgnt->bStartSendSupervisionPkt = 1U;
#line 4866
  rtl8723a_update_ramask(padapter, (u32 )(63 - (int )EntryNum), 0);
#line 4869
  HalSetBrateCfg23a(padapter, (u8 *)(& padapter->mlmepriv.cur_network.network.SupportedRates));
#line 4870
  BTDM_SetFwChnlInfo(padapter, 1);
#line 4871
  goto ldv_55734;
  default: ;
#line 4873
  if (BTCoexDbgLevel == 1U) {
#line 4873
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4874
  goto ldv_55734;
  }
  ldv_55734: ;
#line 4877
  return;
}
}
#line 4879 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_StateAuth(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                            u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4882
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4883
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4885
  if (BTCoexDbgLevel == 1U) {
#line 4885
    printk("[BT state], [Authenticating], ");
  } else {

  }
#line 4886
  switch ((unsigned int )StateCmd) {
  case 3U: ;
#line 4888
  if (BTCoexDbgLevel == 1U) {
#line 4888
    printk("STATE_CMD_CONNECT_ACCEPT_TIMEOUT\n");
  } else {

  }
#line 4889
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 16;
#line 4890
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
#line 4891
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4892
  goto ldv_55746;
  case 2U: ;
#line 4894
  if (BTCoexDbgLevel == 1U) {
#line 4894
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4895
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4900
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 2;
#line 4902
  ldv_del_timer_sync_2432(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4904
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4905
  goto ldv_55746;
  case 10U: ;
#line 4907
  if (BTCoexDbgLevel == 1U) {
#line 4907
    printk("STATE_CMD_4WAY_FAILED\n");
  } else {

  }
#line 4909
  pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus = 5;
#line 4910
  pBtMgnt->bNeedNotifyAMPNoCap = 1U;
#line 4912
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4914
  ldv_del_timer_sync_2433(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4915
  goto ldv_55746;
  case 11U: ;
#line 4917
  if (BTCoexDbgLevel == 1U) {
#line 4917
    printk("STATE_CMD_4WAY_SUCCESSED\n");
  } else {

  }
#line 4919
  bthci_EventPhysicalLinkComplete(padapter, 0, (int )EntryNum, 255);
#line 4921
  ldv_del_timer_sync_2434(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4923
  if (BTCoexDbgLevel == 1U) {
#line 4923
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateAuth", 4923);
  } else {

  }
#line 4923
  BTHCI_StateMachine(padapter, 8, 12, (int )EntryNum);
#line 4924
  goto ldv_55746;
  default: ;
#line 4926
  if (BTCoexDbgLevel == 1U) {
#line 4926
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4927
  goto ldv_55746;
  }
  ldv_55746: ;
#line 4930
  return;
}
}
#line 4932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_StateDisconnecting(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                     u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 4935
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4936
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4938
  if (BTCoexDbgLevel == 1U) {
#line 4938
    printk("[BT state], [Disconnecting], ");
  } else {

  }
#line 4939
  switch ((unsigned int )StateCmd) {
  case 9U: ;
#line 4941
  if (BTCoexDbgLevel == 1U) {
#line 4941
    printk("STATE_CMD_MAC_CONNECT_CANCEL_INDICATE\n");
  } else {

  }
#line 4942
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent != 0U) {
#line 4943
    bthci_EventPhysicalLinkComplete(padapter, pBTInfo->BtAsocEntry[(int )EntryNum].PhysLinkCompleteStatus,
                                    (int )EntryNum, 255);
  } else {

  }
#line 4948
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 4949
    pBtMgnt->bBTConnectInProgress = 0U;
#line 4950
    if (BTCoexDbgLevel == 1U) {
#line 4950
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
#line 4953
  if (BTCoexDbgLevel == 1U) {
#line 4953
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateDisconnecting",
           4953);
  } else {

  }
#line 4953
  BTHCI_StateMachine(padapter, 32, 12, (int )EntryNum);
#line 4954
  goto ldv_55761;
  case 2U: ;
#line 4956
  if (BTCoexDbgLevel == 1U) {
#line 4956
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 4958
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 4963
  ldv_del_timer_sync_2435(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 4965
  BTHCI_DisconnectPeer(padapter, (int )EntryNum);
#line 4966
  goto ldv_55761;
  default: ;
#line 4968
  if (BTCoexDbgLevel == 1U) {
#line 4968
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 4969
  goto ldv_55761;
  }
  ldv_55761: ;
#line 4972
  return;
}
}
#line 4974 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void bthci_StateDisconnected(struct rtw_adapter *padapter , enum hci_state_with_cmd StateCmd ,
                                    u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  struct bt_mgnt *pBtMgnt ;
  unsigned long __ms ;
  unsigned long tmp ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 4978
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 4979
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 4980
  pBtMgnt = & pBTInfo->BtMgnt;
#line 4982
  if (BTCoexDbgLevel == 1U) {
#line 4982
    printk("[BT state], [Disconnected], ");
  } else {

  }
#line 4983
  switch ((unsigned int )StateCmd) {
  case 0U: ;
  case 1U: ;
#line 4986
  if ((unsigned int )StateCmd == 0U) {
#line 4987
    if (BTCoexDbgLevel == 1U) {
#line 4987
      printk("STATE_CMD_CREATE_PHY_LINK\n");
    } else {

    }
  } else
#line 4989
  if (BTCoexDbgLevel == 1U) {
#line 4989
    printk("STATE_CMD_ACCEPT_PHY_LINK\n");
  } else {

  }
#line 4991
  if (BTCoexDbgLevel == 1U) {
#line 4991
    printk("[BT PS], Disable IPS and LPS\n");
  } else {

  }
#line 4992
  ips_leave23a(padapter);
#line 4993
  LPS_Leave23a(padapter);
#line 4995
  pBtMgnt->bPhyLinkInProgress = 1U;
#line 4996
  pBtMgnt->BTCurrentConnectType = 4;
#line 4997
  pBtMgnt->CurrentBTConnectionCnt = (u8 )((int )pBtMgnt->CurrentBTConnectionCnt + 1);
#line 4998
  if (BTCoexDbgLevel == 1U) {
#line 4998
    printk("[BT Flag], CurrentBTConnectionCnt = %d\n", (int )pBtMgnt->CurrentBTConnectionCnt);
  } else {

  }
#line 5000
  pBtMgnt->BtOperationOn = 1U;
#line 5001
  if (BTCoexDbgLevel == 1U) {
#line 5001
    printk("[BT Flag], Bt Operation ON!! CurrentConnectEntryNum = %d\n", (int )pBtMgnt->CurrentConnectEntryNum);
  } else {

  }
#line 5004
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 5005
    bthci_EventPhysicalLinkComplete(padapter, 58, 255, (int )pBtMgnt->BtCurrentPhyLinkhandle);
#line 5006
    bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
#line 5007
    return;
  } else {

  }
#line 5010
  if ((unsigned int )StateCmd == 0U) {
#line 5011
    pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole = 1;
  } else {
#line 5013
    pBTInfo->BtAsocEntry[(int )EntryNum].AMPRole = 2;
  }
#line 5016
  goto ldv_55779;
  ldv_55778: ;
#line 5017
  if (BTCoexDbgLevel == 1U) {
#line 5017
    printk("Scan/Roaming/Wifi Link is in Progress, wait 200 ms\n");
  } else {

  }
#line 5018
  __ms = 200UL;
#line 5018
  goto ldv_55776;
  ldv_55775: 
#line 5018
  __const_udelay(4295000UL);
  ldv_55776: 
#line 5018
  tmp = __ms;
#line 5018
  __ms = __ms - 1UL;
#line 5018
  if (tmp != 0UL) {
#line 5020
    goto ldv_55775;
  } else {

  }

  ldv_55779: 
#line 5016
  tmp___0 = check_fwstate(& padapter->mlmepriv, 2049);
#line 5016
  if ((int )tmp___0) {
#line 5018
    goto ldv_55778;
  } else {

  }

#line 5021
  if (BTCoexDbgLevel == 1U) {
#line 5021
    printk("Channel is Ready\n");
  } else {

  }
#line 5022
  tmp___1 = msecs_to_jiffies((unsigned int const   )pBtHciInfo->ConnAcceptTimeout);
#line 5022
  ldv_mod_timer_2436(& pBTInfo->BTHCIJoinTimeoutTimer, tmp___1 + (unsigned long )jiffies);
#line 5025
  pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent = 1U;
#line 5026
  goto ldv_55781;
  case 2U: ;
#line 5028
  if (BTCoexDbgLevel == 1U) {
#line 5028
    printk("STATE_CMD_DISCONNECT_PHY_LINK\n");
  } else {

  }
#line 5030
  ldv_del_timer_sync_2437(& pBTInfo->BTHCIJoinTimeoutTimer);
#line 5032
  bthci_EventDisconnectPhyLinkComplete(padapter, 0, pBTInfo->BtAsocEntry[(int )EntryNum].PhyLinkDisconnectReason,
                                       (int )EntryNum);
#line 5037
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )EntryNum].bNeedPhysLinkCompleteEvent != 0U) {
#line 5038
    bthci_EventPhysicalLinkComplete(padapter, 2, (int )EntryNum, 255);
  } else {

  }
#line 5043
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 5044
    pBtMgnt->bBTConnectInProgress = 0U;
#line 5045
    if (BTCoexDbgLevel == 1U) {
#line 5045
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
#line 5047
  if (BTCoexDbgLevel == 1U) {
#line 5047
    printk("[BT state change] caused by %s, line =%d\n", "bthci_StateDisconnected",
           5047);
  } else {

  }
#line 5047
  BTHCI_StateMachine(padapter, 32, 12, (int )EntryNum);
#line 5048
  bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
#line 5049
  goto ldv_55781;
  case 12U: ;
#line 5051
  if (BTCoexDbgLevel == 1U) {
#line 5051
    printk("STATE_CMD_ENTER_STATE\n");
  } else {

  }
#line 5052
  goto ldv_55781;
  default: ;
#line 5054
  if (BTCoexDbgLevel == 1U) {
#line 5054
    printk("State command(%d) is Wrong !!!\n", (unsigned int )StateCmd);
  } else {

  }
#line 5055
  goto ldv_55781;
  }
  ldv_55781: ;
#line 5058
  return;
}
}
#line 5059 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTHCI_EventParse(struct rtw_adapter *padapter , void *pEvntData , u32 dataLen ) 
{ 


  {
#line 5061
  return;
}
}
#line 5063 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTHCI_HsConnectionEstablished(struct rtw_adapter *padapter ) 
{ 
  u8 bBtConnectionExist ;
  struct bt_30info *pBtinfo ;
  u8 i ;

  {
#line 5065
  bBtConnectionExist = 0U;
#line 5066
  pBtinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5069
  i = 0U;
#line 5069
  goto ldv_55799;
  ldv_55798: ;
#line 5070
  if ((unsigned int )pBtinfo->BtAsocEntry[(int )i].b4waySuccess != 0U) {
#line 5071
    bBtConnectionExist = 1U;
#line 5072
    goto ldv_55797;
  } else {

  }
#line 5069
  i = (u8 )((int )i + 1);
  ldv_55799: ;
#line 5069
  if ((unsigned int )i <= 1U) {
#line 5071
    goto ldv_55798;
  } else {

  }
  ldv_55797: ;
#line 5078
  return (bBtConnectionExist);
}
}
#line 5082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 BTHCI_CheckProfileExist(struct rtw_adapter *padapter , enum bt_traffic_mode_profile Profile ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 IsPRofile ;
  u8 i ;

  {
#line 5085
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5086
  pBtMgnt = & pBTInfo->BtMgnt;
#line 5087
  IsPRofile = 0U;
#line 5088
  i = 0U;
#line 5090
  i = 0U;
#line 5090
  goto ldv_55810;
  ldv_55809: ;
#line 5091
  if ((unsigned int )pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile == (unsigned int )Profile) {
#line 5092
    IsPRofile = 1U;
#line 5093
    goto ldv_55808;
  } else {

  }
#line 5090
  i = (u8 )((int )i + 1);
  ldv_55810: ;
#line 5090
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 5092
    goto ldv_55809;
  } else {

  }
  ldv_55808: ;
#line 5097
  return (IsPRofile);
}
}
#line 5100 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTHCI_UpdateBTProfileRTKToMoto(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 i ;

  {
#line 5102
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5103
  pBtMgnt = & pBTInfo->BtMgnt;
#line 5104
  i = 0U;
#line 5106
  pBtMgnt->ExtConfig.NumberOfSCO = 0U;
#line 5108
  i = 0U;
#line 5108
  goto ldv_55824;
  ldv_55823: 
#line 5109
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = 0U;
#line 5111
  if ((unsigned int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile == 4U) {
#line 5112
    pBtMgnt->ExtConfig.NumberOfSCO = (u8 )((int )pBtMgnt->ExtConfig.NumberOfSCO + 1);
  } else {

  }
#line 5114
  pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile = pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile;
#line 5115
  switch ((int )pBtMgnt->ExtConfig.linkInfo[(int )i].TrafficProfile) {
  case 4: ;
#line 5117
  goto ldv_55818;
  case 2: 
#line 5119
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 0U;
#line 5120
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
#line 5121
  goto ldv_55818;
  case 1: 
#line 5123
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 3U;
#line 5124
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 3U;
#line 5125
  goto ldv_55818;
  case 3: 
#line 5127
  pBtMgnt->ExtConfig.linkInfo[(int )i].IncomingTrafficMode = 1U;
#line 5128
  pBtMgnt->ExtConfig.linkInfo[(int )i].OutgoingTrafficMode = 0U;
#line 5129
  goto ldv_55818;
  default: ;
#line 5131
  goto ldv_55818;
  }
  ldv_55818: 
#line 5108
  i = (u8 )((int )i + 1);
  ldv_55824: ;
#line 5108
  if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 5110
    goto ldv_55823;
  } else {

  }

#line 5135
  if (BTCoexDbgLevel == 1U) {
#line 5135
    printk("[DM][BT], RTK, NumberOfHandle = %d, NumberOfSCO = %d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle,
           (int )pBtMgnt->ExtConfig.NumberOfSCO);
  } else {

  }
#line 5136
  return;
}
}
#line 5139 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTHCI_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 5141
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5142
  pBtMgnt = & pBTInfo->BtMgnt;
#line 5144
  if ((unsigned int )pBtMgnt->ExtConfig.bEnableWifiScanNotify != 0U) {
#line 5145
    bthci_EventExtWifiScanNotify(padapter, (int )scanType);
  } else {

  }
#line 5146
  return;
}
}
#line 5149 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTHCI_StateMachine(struct rtw_adapter *padapter , u8 StateToEnter , enum hci_state_with_cmd StateCmd ,
                        u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 5156
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5157
  pBtMgnt = & pBTInfo->BtMgnt;
#line 5159
  if ((unsigned int )EntryNum == 255U) {
#line 5160
    if (BTCoexDbgLevel == 1U) {
#line 5160
      printk(" StateMachine, error EntryNum = 0x%x \n", (int )EntryNum);
    } else {

    }
#line 5161
    return;
  } else {

  }
#line 5163
  if (BTCoexDbgLevel == 1U) {
#line 5163
    printk(" StateMachine, EntryNum = 0x%x, CurrentState = 0x%x, BtNextState = 0x%x,  StateCmd = 0x%x , StateToEnter = 0x%x\n",
           (int )EntryNum, (int )pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState,
           (int )pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState, (unsigned int )StateCmd,
           (int )StateToEnter);
  } else {

  }
#line 5166
  if ((unsigned int )((int )pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState & (int )StateToEnter) != 0U) {
#line 5167
    pBTInfo->BtAsocEntry[(int )EntryNum].BtCurrentState = StateToEnter;
#line 5169
    switch ((int )StateToEnter) {
    case 1: 
#line 5171
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 18U;
#line 5172
    bthci_StateStarting(padapter, StateCmd, (int )EntryNum);
#line 5173
    goto ldv_55841;
    case 2: 
#line 5175
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 22U;
#line 5176
    bthci_StateConnecting(padapter, StateCmd, (int )EntryNum);
#line 5177
    goto ldv_55841;
    case 4: 
#line 5179
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 24U;
#line 5180
    bthci_StateAuth(padapter, StateCmd, (int )EntryNum);
#line 5181
    goto ldv_55841;
    case 8: 
#line 5183
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 24U;
#line 5184
    bthci_StateConnected(padapter, StateCmd, (int )EntryNum);
#line 5185
    goto ldv_55841;
    case 16: 
#line 5187
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 48U;
#line 5188
    bthci_StateDisconnecting(padapter, StateCmd, (int )EntryNum);
#line 5189
    goto ldv_55841;
    case 32: 
#line 5191
    pBTInfo->BtAsocEntry[(int )EntryNum].BtNextState = 35U;
#line 5192
    bthci_StateDisconnected(padapter, StateCmd, (int )EntryNum);
#line 5193
    goto ldv_55841;
    default: ;
#line 5195
    if (BTCoexDbgLevel == 1U) {
#line 5195
      printk(" StateMachine, Unknown state to enter!!!\n");
    } else {

    }
#line 5196
    goto ldv_55841;
    }
    ldv_55841: ;
  } else
#line 5199
  if (BTCoexDbgLevel == 1U) {
#line 5199
    printk(" StateMachine, Wrong state to enter\n");
  } else {

  }
#line 5203
  if ((unsigned int )pBtMgnt->bBTConnectInProgress == 0U && (unsigned int )pBtMgnt->BtOperationOn == 0U) {
#line 5204
    if (BTCoexDbgLevel == 1U) {
#line 5204
      printk("[BT PS], ips_enter23a()\n");
    } else {

    }
#line 5205
    ips_enter23a(padapter);
  } else {

  }
#line 5207
  return;
}
}
#line 5209 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTHCI_DisconnectPeer(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 5211
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5212
  pBtMgnt = & pBTInfo->BtMgnt;
#line 5214
  if (BTCoexDbgLevel == 1U) {
#line 5214
    printk(" BTHCI_DisconnectPeer()\n");
  } else {

  }
#line 5216
  if (BTCoexDbgLevel == 1U) {
#line 5216
    printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectPeer", 5216);
  } else {

  }
#line 5216
  BTHCI_StateMachine(padapter, 16, 9, (int )EntryNum);
#line 5222
  if ((unsigned int )pBtMgnt->bBTConnectInProgress != 0U) {
#line 5223
    pBtMgnt->bBTConnectInProgress = 0U;
#line 5224
    if (BTCoexDbgLevel == 1U) {
#line 5224
      printk("[BT Flag], BT Connect in progress OFF!!\n");
    } else {

    }
  } else {

  }
#line 5227
  bthci_RemoveEntryByEntryNum(padapter, (int )EntryNum);
#line 5229
  if ((unsigned int )pBtMgnt->bNeedNotifyAMPNoCap != 0U) {
#line 5230
    if (BTCoexDbgLevel == 1U) {
#line 5230
      printk("[BT AMPStatus], set to invalid in BTHCI_DisconnectPeer()\n");
    } else {

    }
#line 5231
    BTHCI_EventAMPStatusChange(padapter, 2);
  } else {

  }
#line 5233
  return;
}
}
#line 5235 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTHCI_EventNumOfCompletedDataBlocks(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_hci_info *pBtHciInfo ;
  u8 localBuf[256U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  u8 *pTriple ;
  u8 len ;
  u8 i ;
  u8 j ;
  u8 handleNum ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u16 *pu2Temp ;
  u16 *pPackets ;
  u16 *pHandle ;
  u16 *pDblocks ;
  u8 sent ;

  {
#line 5238
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5239
  pBtHciInfo = & pBTInfo->BtHciInfo;
#line 5240
  localBuf[0] = '\000';
#line 5240
  tmp = 1U;
#line 5240
  while (1) {
#line 5240
    if (tmp >= 256U) {
#line 5240
      break;
    } else {

    }
#line 5240
    localBuf[tmp] = (unsigned char)0;
#line 5240
    tmp = tmp + 1U;
  }
#line 5242
  len = 0U;
#line 5242
  handleNum = 0U;
#line 5245
  sent = 0U;
#line 5247
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 5249
  if ((pBtHciInfo->BTEventMaskPage2 & 256ULL) == 0ULL) {
#line 5250
    if (BTCoexDbgLevel == 1U) {
#line 5250
      printk("[BT event], Num Of Completed DataBlocks, Ignore to send NumOfCompletedDataBlocksEvent due to event mask page 2\n");
    } else {

    }
#line 5251
    return;
  } else {

  }
#line 5255
  pRetPar = (u8 *)(& PPacketIrpEvent->Data);
#line 5256
  pTriple = pRetPar + 3UL;
#line 5257
  j = 0U;
#line 5257
  goto ldv_55877;
  ldv_55876: 
#line 5259
  i = 0U;
#line 5259
  goto ldv_55874;
  ldv_55873: ;
#line 5260
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle != 0U) {
#line 5261
    handleNum = (u8 )((int )handleNum + 1);
#line 5262
    pHandle = (u16 *)pTriple;
#line 5263
    pPackets = (u16 *)pTriple + 2U;
#line 5264
    pDblocks = (u16 *)pTriple + 4U;
#line 5265
    *pHandle = pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].BtLogLinkhandle;
#line 5266
    *pPackets = (unsigned short )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount;
#line 5267
    *pDblocks = (unsigned short )pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount;
#line 5268
    if (pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount != 0U) {
#line 5269
      sent = 1U;
#line 5270
      if (BTCoexDbgLevel == 1U) {
#line 5270
        printk("[BT event], Num Of Completed DataBlocks, Handle = 0x%x, Num_Of_Completed_Packets = 0x%x, Num_Of_Completed_Blocks = 0x%x\n",
               (int )*pHandle, (int )*pPackets, (int )*pDblocks);
      } else {

      }
    } else {

    }
#line 5274
    pBTInfo->BtAsocEntry[(int )j].LogLinkCmdData[(int )i].TxPacketCount = 0U;
#line 5275
    len = (unsigned int )len + 6U;
#line 5276
    pTriple = pTriple + (unsigned long )len;
  } else {

  }
#line 5259
  i = (u8 )((int )i + 1);
  ldv_55874: ;
#line 5259
  if ((unsigned int )i <= 1U) {
#line 5261
    goto ldv_55873;
  } else {

  }
#line 5257
  j = (u8 )((int )j + 1);
  ldv_55877: ;
#line 5257
  if ((unsigned int )j <= 1U) {
#line 5259
    goto ldv_55876;
  } else {

  }
#line 5281
  *(pRetPar + 2UL) = handleNum;
#line 5282
  len = (unsigned int )len + 1U;
#line 5283
  pu2Temp = (u16 *)pRetPar;
#line 5284
  *pu2Temp = 256U;
#line 5285
  len = (unsigned int )len + 2U;
#line 5287
  PPacketIrpEvent->EventCode = 72U;
#line 5288
  PPacketIrpEvent->Length = len;
#line 5289
  if ((unsigned int )handleNum != 0U && (unsigned int )sent != 0U) {
#line 5290
    bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
  } else {

  }
#line 5291
  return;
}
}
#line 5293 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTHCI_EventAMPStatusChange(struct rtw_adapter *padapter , u8 AMP_Status ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct packet_irp_hcievent_data *PPacketIrpEvent ;
  u8 len ;
  u8 localBuf[7U] ;
  unsigned int tmp ;
  u8 *pRetPar ;
  enum rt_status tmp___0 ;

  {
#line 5295
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5296
  pBtMgnt = & pBTInfo->BtMgnt;
#line 5298
  len = 0U;
#line 5299
  localBuf[0] = '\000';
#line 5299
  tmp = 1U;
#line 5299
  while (1) {
#line 5299
    if (tmp >= 7U) {
#line 5299
      break;
    } else {

    }
#line 5299
    localBuf[tmp] = (unsigned char)0;
#line 5299
    tmp = tmp + 1U;
  }
#line 5302
  if ((unsigned int )AMP_Status == 2U) {
#line 5303
    pBtMgnt->BTNeedAMPStatusChg = 1U;
#line 5304
    pBtMgnt->bNeedNotifyAMPNoCap = 0U;
#line 5306
    BTHCI_DisconnectAll(padapter);
  } else
#line 5307
  if ((unsigned int )AMP_Status == 6U) {
#line 5308
    pBtMgnt->BTNeedAMPStatusChg = 0U;
  } else {

  }
#line 5311
  PPacketIrpEvent = (struct packet_irp_hcievent_data *)(& localBuf);
#line 5313
  pRetPar = (u8 *)(& PPacketIrpEvent->Data);
#line 5315
  *pRetPar = 0U;
#line 5316
  len = (unsigned int )len + 1U;
#line 5317
  *(pRetPar + 1UL) = AMP_Status;
#line 5318
  len = (unsigned int )len + 1U;
#line 5320
  PPacketIrpEvent->EventCode = 77U;
#line 5321
  PPacketIrpEvent->Length = len;
#line 5322
  tmp___0 = bthci_IndicateEvent(padapter, (void *)PPacketIrpEvent, (u32 )((int )len + 2));
#line 5322
  if ((unsigned int )tmp___0 == 0U) {
#line 5323
    if (BTCoexDbgLevel == 1U) {
#line 5323
      printk("[BT event], AMP Status Change, AMP_Status = %d\n", (int )AMP_Status);
    } else {

    }
  } else {

  }
#line 5324
  return;
}
}
#line 5326 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTHCI_DisconnectAll(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  u8 i ;

  {
#line 5328
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5331
  if (BTCoexDbgLevel == 1U) {
#line 5331
    printk(" DisconnectALL()\n");
  } else {

  }
#line 5333
  i = 0U;
#line 5333
  goto ldv_55896;
  ldv_55895: ;
#line 5334
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].b4waySuccess != 0U) {
#line 5335
    if (BTCoexDbgLevel == 1U) {
#line 5335
      printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
             5335);
    } else {

    }
#line 5335
    BTHCI_StateMachine(padapter, 8, 2, (int )i);
  } else
#line 5336
  if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U) {
#line 5337
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].BtCurrentState == 2U) {
#line 5338
      if (BTCoexDbgLevel == 1U) {
#line 5338
        printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
               5338);
      } else {

      }
#line 5338
      BTHCI_StateMachine(padapter, 2, 9, (int )i);
    } else
#line 5339
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].BtCurrentState == 16U) {
#line 5340
      if (BTCoexDbgLevel == 1U) {
#line 5340
        printk("[BT state change] caused by %s, line =%d\n", "BTHCI_DisconnectAll",
               5340);
      } else {

      }
#line 5340
      BTHCI_StateMachine(padapter, 16, 9, (int )i);
    } else {

    }
  } else {

  }
#line 5333
  i = (u8 )((int )i + 1);
  ldv_55896: ;
#line 5333
  if ((unsigned int )i <= 1U) {
#line 5335
    goto ldv_55895;
  } else {

  }

#line 5340
  return;
}
}
#line 5347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
enum hci_status BTHCI_HandleHCICMD(struct rtw_adapter *padapter , struct packet_irp_hcicmd_data *pHciCmd ) 
{ 
  enum hci_status status ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u32 __i ;
  u8 *ptr ;

  {
#line 5352
  status = 0;
#line 5353
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 5354
  pBtDbg = & pBTInfo->BtDbg;
#line 5356
  if (BTCoexDbgLevel == 1U) {
#line 5356
    printk("\n");
  } else {

  }
#line 5357
  if (BTCoexDbgLevel == 1U) {
#line 5357
    printk("HCI Command start, OGF = 0x%x, OCF = 0x%x, Length = 0x%x\n", (int )pHciCmd->OGF,
           (int )pHciCmd->OCF, (int )pHciCmd->Length);
  } else {

  }
#line 5359
  if ((unsigned int )pHciCmd->Length != 0U) {
#line 5360
    if (BTCoexDbgLevel == 1U) {
#line 5360
      ptr = (u8 *)(& pHciCmd->Data);
#line 5360
      printk("HCI Command, Hex Data :\n");
#line 5360
      __i = 0U;
#line 5360
      goto ldv_55908;
      ldv_55907: 
#line 5360
      printk("%02X%s", (int )*(ptr + (unsigned long )__i), ((__i + 1U) & 3U) == 0U ? (char *)"  " : (char *)" ");
#line 5360
      if (((__i + 1U) & 15U) == 0U) {
#line 5360
        printk("\n");
      } else {

      }
#line 5360
      __i = __i + 1U;
      ldv_55908: ;
#line 5360
      if ((u32 )pHciCmd->Length > __i) {
#line 5362
        goto ldv_55907;
      } else {

      }
#line 5360
      printk("\n");
    } else {

    }
  } else {

  }
#line 5363
  if ((unsigned int )*((unsigned char *)pHciCmd + 1UL) == 252U) {
#line 5364
    if ((unsigned int )*((unsigned short *)pHciCmd + 0UL) == 64U) {
#line 5365
      if (BTCoexDbgLevel == 1U) {
#line 5365
        printk("[BT cmd], ");
      } else {

      }
    } else
#line 5367
    if (BTCoexDbgLevel == 1U) {
#line 5367
      printk("[BT cmd], ");
    } else {

    }
  } else
#line 5369
  if (BTCoexDbgLevel == 1U) {
#line 5369
    printk("[BT cmd], ");
  } else {

  }
#line 5372
  pBtDbg->dbgHciInfo.hciCmdCnt = pBtDbg->dbgHciInfo.hciCmdCnt + 1U;
#line 5374
  switch ((int )pHciCmd->OGF) {
  case 1: 
#line 5376
  status = bthci_HandleOGFLinkControlCMD(padapter, pHciCmd);
#line 5377
  goto ldv_55911;
  case 2: ;
#line 5379
  goto ldv_55911;
  case 3: 
#line 5381
  status = bthci_HandleOGFSetEventMaskCMD(padapter, pHciCmd);
#line 5382
  goto ldv_55911;
  case 4: 
#line 5384
  status = bthci_HandleOGFInformationalParameters(padapter, pHciCmd);
#line 5385
  goto ldv_55911;
  case 5: 
#line 5387
  status = bthci_HandleOGFStatusParameters(padapter, pHciCmd);
#line 5388
  goto ldv_55911;
  case 6: 
#line 5390
  status = bthci_HandleOGFTestingCMD(padapter, pHciCmd);
#line 5391
  goto ldv_55911;
  case 63: 
#line 5393
  status = bthci_HandleOGFExtension(padapter, pHciCmd);
#line 5394
  goto ldv_55911;
  default: ;
#line 5396
  if (BTCoexDbgLevel == 1U) {
#line 5396
    printk("HCI Command(), Unknown OGF = 0x%x\n", (int )pHciCmd->OGF);
  } else {

  }
#line 5397
  if (BTCoexDbgLevel == 1U) {
#line 5397
    printk("HCI_UNKNOWN_COMMAND\n");
  } else {

  }
#line 5398
  status = bthci_UnknownCMD(padapter, pHciCmd);
#line 5399
  goto ldv_55911;
  }
  ldv_55911: ;
#line 5401
  if (BTCoexDbgLevel == 1U) {
#line 5401
    printk("HCI Command execution end!!\n");
  } else {

  }
#line 5403
  return (status);
}
}
#line 5408 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static char const   * const  BtStateString[9U]  = 
#line 5408
  {      "BT_DISABLED",      "BT_NO_CONNECTION",      "BT_CONNECT_IDLE",      "BT_INQ_OR_PAG", 
        "BT_ACL_ONLY_BUSY",      "BT_SCO_ONLY_BUSY",      "BT_ACL_SCO_BUSY",      "BT_ACL_INQ_OR_PAG", 
        "BT_STATE_NOT_DEFINED"};
#line 5422 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_SetFwIgnoreWlanAct(struct rtw_adapter *padapter , u8 bEnable ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[1U] ;

  {
#line 5424
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5425
  H2C_Parameter[0] = 0U;
#line 5427
  if ((unsigned int )bEnable != 0U) {
#line 5428
    if (BTCoexDbgLevel == 1U) {
#line 5428
      printk("[BTCoex], BT Ignore Wlan_Act !!\n");
    } else {

    }
#line 5429
    H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 1U);
#line 5430
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else
#line 5432
  if (BTCoexDbgLevel == 1U) {
#line 5432
    printk("[BTCoex], BT don\'t ignore Wlan_Act !!\n");
  } else {

  }
#line 5435
  if (BTCoexDbgLevel == 1U) {
#line 5435
    printk("[BTCoex], set FW for BT Ignore Wlan_Act, write 0x25 = 0x%02x\n", (int )H2C_Parameter[0]);
  } else {

  }
#line 5438
  FillH2CCmd(padapter, 37, 1U, (u8 *)(& H2C_Parameter));
#line 5439
  return;
}
}
#line 5441 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_NotifyFwScan(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  u8 H2C_Parameter[1U] ;

  {
#line 5443
  H2C_Parameter[0] = 0U;
#line 5445
  if ((unsigned int )scanType == 1U) {
#line 5446
    H2C_Parameter[0] = 1U;
  } else {

  }
#line 5448
  if (BTCoexDbgLevel == 1U) {
#line 5448
    printk("[BTCoex], Notify FW for wifi scan, write 0x3b = 0x%02x\n", (int )H2C_Parameter[0]);
  } else {

  }
#line 5451
  FillH2CCmd(padapter, 59, 1U, (u8 *)(& H2C_Parameter));
#line 5452
  return;
}
}
#line 5454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntSetPSMode(struct rtw_adapter *padapter , u8 enable , u8 smartps ,
                               u8 mode ) 
{ 
  struct pwrctrl_priv *pwrctrl ;

  {
#line 5459
  if (BTCoexDbgLevel == 1U) {
#line 5459
    printk("[BTCoex], Current LPS(%s, %d), smartps =%d\n", (unsigned int )enable == 1U ? (char *)"ON" : (char *)"OFF",
           (int )mode, (int )smartps);
  } else {

  }
#line 5461
  pwrctrl = & padapter->pwrctrlpriv;
#line 5463
  if ((unsigned int )enable == 1U) {
#line 5464
    rtw_set_ps_mode23a(padapter, 1, (int )smartps, (int )mode);
  } else {
#line 5466
    rtw_set_ps_mode23a(padapter, 0, 0, 0);
#line 5467
    LPS_RF_ON_check23a(padapter, 100U);
  }
#line 5469
  return;
}
}
#line 5471 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntTSFSwitch(struct rtw_adapter *padapter , u8 enable ) 
{ 
  u8 oldVal ;
  u8 newVal ;

  {
#line 5475
  oldVal = rtl8723au_read8(padapter, 1360U);
#line 5477
  if ((unsigned int )enable != 0U) {
#line 5478
    newVal = (u8 )((unsigned int )oldVal | 8U);
  } else {
#line 5480
    newVal = (unsigned int )oldVal & 247U;
  }
#line 5482
  if ((int )oldVal != (int )newVal) {
#line 5483
    rtl8723au_write8(padapter, 1360U, (int )newVal);
  } else {

  }
#line 5484
  return;
}
}
#line 5486 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 btdm_Is1AntPsTdmaStateChange(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;

  {
#line 5488
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5489
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5491
  if ((int )pBtdm8723->bPrePsTdmaOn != (int )pBtdm8723->bCurPsTdmaOn || (int )pBtdm8723->prePsTdma != (int )pBtdm8723->curPsTdma) {
#line 5493
    return (1U);
  } else {
#line 5495
    return (0U);
  }
}
}
#line 5500 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntPsTdma(struct rtw_adapter *padapter , u8 bTurnOn , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;
  u8 tmp___15 ;
  u8 tmp___16 ;
  u8 tmp___17 ;
  u8 tmp___18 ;
  u8 tmp___19 ;
  u8 tmp___20 ;

  {
#line 5506
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5507
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5509
  pBtdm8723->bCurPsTdmaOn = bTurnOn;
#line 5510
  pBtdm8723->curPsTdma = type;
#line 5511
  if ((unsigned int )bTurnOn != 0U) {
#line 5512
    switch ((int )type) {
    case 1: ;
    default: 
#line 5515
    tmp = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5515
    if ((unsigned int )tmp != 0U) {
#line 5517
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 88);
    } else {

    }
#line 5519
    goto ldv_55958;
    case 2: 
#line 5521
    tmp___0 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5521
    if ((unsigned int )tmp___0 != 0U) {
#line 5523
      BTDM_SetFw3a(padapter, 211, 18, 18, 0, 88);
    } else {

    }
#line 5525
    goto ldv_55958;
    case 3: 
#line 5527
    tmp___1 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5527
    if ((unsigned int )tmp___1 != 0U) {
#line 5529
      BTDM_SetFw3a(padapter, 211, 48, 3, 16, 88);
    } else {

    }
#line 5532
    goto ldv_55958;
    case 4: 
#line 5534
    tmp___2 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5534
    if ((unsigned int )tmp___2 != 0U) {
#line 5536
      BTDM_SetFw3a(padapter, 147, 21, 3, 20, 0);
    } else {

    }
#line 5538
    goto ldv_55958;
    case 5: 
#line 5540
    tmp___3 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5540
    if ((unsigned int )tmp___3 != 0U) {
#line 5542
      BTDM_SetFw3a(padapter, 97, 21, 3, 49, 0);
    } else {

    }
#line 5544
    goto ldv_55958;
    case 9: 
#line 5546
    tmp___4 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5546
    if ((unsigned int )tmp___4 != 0U) {
#line 5548
      BTDM_SetFw3a(padapter, 211, 10, 10, 0, 88);
    } else {

    }
#line 5550
    goto ldv_55958;
    case 10: 
#line 5552
    tmp___5 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5552
    if ((unsigned int )tmp___5 != 0U) {
#line 5553
      BTDM_SetFw3a(padapter, 19, 10, 10, 0, 64);
    } else {

    }
#line 5554
    goto ldv_55958;
    case 11: 
#line 5556
    tmp___6 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5556
    if ((unsigned int )tmp___6 != 0U) {
#line 5558
      BTDM_SetFw3a(padapter, 211, 5, 5, 0, 88);
    } else {

    }
#line 5560
    goto ldv_55958;
    case 12: 
#line 5562
    tmp___7 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5562
    if ((unsigned int )tmp___7 != 0U) {
#line 5564
      BTDM_SetFw3a(padapter, 235, 10, 3, 49, 24);
    } else {

    }
#line 5566
    goto ldv_55958;
    case 20: 
#line 5568
    tmp___8 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5568
    if ((unsigned int )tmp___8 != 0U) {
#line 5569
      BTDM_SetFw3a(padapter, 19, 37, 37, 0, 0);
    } else {

    }
#line 5570
    goto ldv_55958;
    case 27: 
#line 5572
    tmp___9 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5572
    if ((unsigned int )tmp___9 != 0U) {
#line 5573
      BTDM_SetFw3a(padapter, 163, 37, 3, 49, 152);
    } else {

    }
#line 5574
    goto ldv_55958;
    case 28: 
#line 5576
    tmp___10 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5576
    if ((unsigned int )tmp___10 != 0U) {
#line 5577
      BTDM_SetFw3a(padapter, 105, 37, 3, 49, 0);
    } else {

    }
#line 5578
    goto ldv_55958;
    case 29: 
#line 5580
    tmp___11 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5580
    if ((unsigned int )tmp___11 != 0U) {
#line 5581
      BTDM_SetFw3a(padapter, 235, 26, 26, 1, 24);
#line 5582
      rtl8723au_write32(padapter, 1728U, 1526356730U);
#line 5583
      rtl8723au_write32(padapter, 1732U, 1526356730U);
    } else {

    }
#line 5585
    goto ldv_55958;
    case 30: 
#line 5587
    tmp___12 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5587
    if ((unsigned int )tmp___12 != 0U) {
#line 5588
      BTDM_SetFw3a(padapter, 147, 21, 3, 20, 0);
    } else {

    }
#line 5589
    goto ldv_55958;
    case 31: 
#line 5591
    tmp___13 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5591
    if ((unsigned int )tmp___13 != 0U) {
#line 5592
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 88);
    } else {

    }
#line 5593
    goto ldv_55958;
    case 32: 
#line 5595
    tmp___14 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5595
    if ((unsigned int )tmp___14 != 0U) {
#line 5596
      BTDM_SetFw3a(padapter, 171, 10, 3, 17, 152);
    } else {

    }
#line 5597
    goto ldv_55958;
    case 33: 
#line 5599
    tmp___15 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5599
    if ((unsigned int )tmp___15 != 0U) {
#line 5600
      BTDM_SetFw3a(padapter, 163, 37, 3, 48, 152);
    } else {

    }
#line 5601
    goto ldv_55958;
    case 34: 
#line 5603
    tmp___16 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5603
    if ((unsigned int )tmp___16 != 0U) {
#line 5604
      BTDM_SetFw3a(padapter, 211, 26, 26, 0, 24);
    } else {

    }
#line 5605
    goto ldv_55958;
    case 35: 
#line 5607
    tmp___17 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5607
    if ((unsigned int )tmp___17 != 0U) {
#line 5608
      BTDM_SetFw3a(padapter, 227, 26, 26, 0, 24);
    } else {

    }
#line 5609
    goto ldv_55958;
    }
    ldv_55958: ;
  } else {
#line 5613
    switch ((int )type) {
    case 8: 
#line 5615
    tmp___18 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5615
    if ((unsigned int )tmp___18 != 0U) {
#line 5617
      BTDM_SetFw3a(padapter, 8, 0, 0, 0, 0);
    } else {

    }
#line 5619
    goto ldv_55978;
    case 0: ;
    default: 
#line 5622
    tmp___19 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5622
    if ((unsigned int )tmp___19 != 0U) {
#line 5624
      BTDM_SetFw3a(padapter, 0, 0, 0, 8, 0);
    } else {

    }
#line 5627
    rtl8723au_write16(padapter, 2144U, 528);
#line 5628
    if (BTCoexDbgLevel == 1U) {
#line 5628
      printk("[BTCoex], 0x860 = 0x210, Switch Antenna to BT\n");
    } else {

    }
#line 5629
    goto ldv_55978;
    case 9: 
#line 5631
    tmp___20 = btdm_Is1AntPsTdmaStateChange(padapter);
#line 5631
    if ((unsigned int )tmp___20 != 0U) {
#line 5633
      BTDM_SetFw3a(padapter, 0, 0, 0, 8, 0);
    } else {

    }
#line 5636
    rtl8723au_write16(padapter, 2144U, 272);
#line 5637
    if (BTCoexDbgLevel == 1U) {
#line 5637
      printk("[BTCoex], 0x860 = 0x110, Switch Antenna to WiFi\n");
    } else {

    }
#line 5638
    goto ldv_55978;
    }
    ldv_55978: ;
  }
#line 5642
  if (BTCoexDbgLevel == 1U) {
#line 5642
    printk("[BTCoex], Current TDMA(%s, %d)\n", (unsigned int )pBtdm8723->bCurPsTdmaOn != 0U ? (char *)"ON" : (char *)"OFF",
           (int )pBtdm8723->curPsTdma);
  } else {

  }
#line 5646
  pBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;
#line 5647
  pBtdm8723->prePsTdma = pBtdm8723->curPsTdma;
#line 5648
  return;
}
}
#line 5651 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void _btdm_1AntSetPSTDMA(struct rtw_adapter *padapter , u8 bPSEn , u8 smartps ,
                                u8 psOption , u8 bTDMAOn , u8 tdmaType ) 
{ 
  struct pwrctrl_priv *pwrctrl ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 psMode ;
  u8 bSwitchPS ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 5660
  tmp = check_fwstate(& padapter->mlmepriv, 8);
#line 5660
  if (tmp) {
#line 5660
    tmp___0 = 0;
  } else {
#line 5660
    tmp___0 = 1;
  }
#line 5660
  if (tmp___0) {
#line 5660
    tmp___1 = get_fwstate(& padapter->mlmepriv);
#line 5660
    if (tmp___1 != 0) {
#line 5662
      btdm_1AntPsTdma(padapter, (int )bTDMAOn, (int )tdmaType);
#line 5663
      return;
    } else {

    }
  } else {

  }
#line 5665
  psOption = (unsigned int )psOption & 254U;
#line 5667
  if (BTCoexDbgLevel == 1U) {
#line 5667
    printk("[BTCoex], Set LPS(%s, %d) TDMA(%s, %d)\n", (unsigned int )bPSEn == 1U ? (char *)"ON" : (char *)"OFF",
           (int )psOption, (unsigned int )bTDMAOn == 1U ? (char *)"ON" : (char *)"OFF",
           (int )tdmaType);
  } else {

  }
#line 5672
  pwrctrl = & padapter->pwrctrlpriv;
#line 5673
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5674
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5676
  if ((unsigned int )bPSEn != 0U) {
#line 5677
    if ((unsigned int )pBtdm8723->bWiFiHalt != 0U) {
#line 5678
      if (BTCoexDbgLevel == 1U) {
#line 5678
        printk("[BTCoex], Enable PS Fail, WiFi in Halt!!\n");
      } else {

      }
#line 5679
      return;
    } else {

    }
#line 5682
    if ((unsigned int )pwrctrl->bInSuspend != 0U) {
#line 5683
      if (BTCoexDbgLevel == 1U) {
#line 5683
        printk("[BTCoex], Enable PS Fail, WiFi in Suspend!!\n");
      } else {

      }
#line 5684
      return;
    } else {

    }
#line 5687
    if (padapter->bDriverStopped != 0) {
#line 5688
      if (BTCoexDbgLevel == 1U) {
#line 5688
        printk("[BTCoex], Enable PS Fail, WiFi driver stopped!!\n");
      } else {

      }
#line 5689
      return;
    } else {

    }
#line 5692
    if (padapter->bSurpriseRemoved != 0) {
#line 5693
      if (BTCoexDbgLevel == 1U) {
#line 5693
        printk("[BTCoex], Enable PS Fail, WiFi Surprise Removed!!\n");
      } else {

      }
#line 5694
      return;
    } else {

    }
#line 5697
    psMode = 1U;
  } else {
#line 5699
    psMode = 0U;
#line 5700
    psOption = 0U;
  }
#line 5703
  if ((int )pwrctrl->pwr_mode != (int )psMode) {
#line 5704
    bSwitchPS = 1U;
  } else
#line 5705
  if ((unsigned int )psMode != 0U) {
#line 5706
    if ((int )pwrctrl->bcn_ant_mode != (int )psOption) {
#line 5707
      bSwitchPS = 1U;
    } else
#line 5708
    if ((int )pwrctrl->smart_ps != (int )smartps) {
#line 5709
      bSwitchPS = 1U;
    } else {
#line 5711
      bSwitchPS = 0U;
    }
  } else {
#line 5713
    bSwitchPS = 0U;
  }
#line 5716
  if ((unsigned int )bSwitchPS != 0U) {
#line 5718
    if ((unsigned int )pBtdm8723->bCurPsTdmaOn != 0U) {
#line 5719
      if ((unsigned int )bTDMAOn == 0U) {
#line 5720
        btdm_1AntPsTdma(padapter, 0, (int )tdmaType);
      } else {
#line 5722
        tmp___2 = rtl8723a_BT_enabled(padapter);
#line 5722
        if (tmp___2) {
#line 5722
          tmp___3 = 0;
        } else {
#line 5722
          tmp___3 = 1;
        }
#line 5722
        if (((tmp___3 || (unsigned int )pHalData->bt_coexist.halCoex8723.c2hBtInfo == 1U) || (unsigned int )pHalData->bt_coexist.halCoex8723.c2hBtInfo == 2U) || (unsigned int )tdmaType == 29U) {
#line 5726
          btdm_1AntPsTdma(padapter, 0, 9);
        } else {
#line 5728
          btdm_1AntPsTdma(padapter, 0, 0);
        }
      }
    } else {

    }
#line 5733
    btdm_1AntSetPSMode(padapter, (int )bPSEn, (int )smartps, (int )psOption);
  } else {

  }
#line 5736
  btdm_1AntPsTdma(padapter, (int )bTDMAOn, (int )tdmaType);
#line 5737
  return;
}
}
#line 5740 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntSetPSTDMA(struct rtw_adapter *padapter , u8 bPSEn , u8 psOption ,
                               u8 bTDMAOn , u8 tdmaType ) 
{ 


  {
#line 5743
  _btdm_1AntSetPSTDMA(padapter, (int )bPSEn, 0, (int )psOption, (int )bTDMAOn, (int )tdmaType);
#line 5744
  return;
}
}
#line 5746 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntWifiParaAdjust(struct rtw_adapter *padapter , u8 bEnable ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;

  {
#line 5748
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5749
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5751
  if ((unsigned int )bEnable != 0U) {
#line 5752
    pBtdm8723->curWifiPara = 1U;
#line 5753
    if ((int )pBtdm8723->preWifiPara != (int )pBtdm8723->curWifiPara) {
#line 5754
      BTDM_SetSwPenaltyTxRateAdaptive(padapter, 1);
    } else {

    }
  } else {
#line 5756
    pBtdm8723->curWifiPara = 2U;
#line 5757
    if ((int )pBtdm8723->preWifiPara != (int )pBtdm8723->curWifiPara) {
#line 5758
      BTDM_SetSwPenaltyTxRateAdaptive(padapter, 0);
    } else {

    }
  }
#line 5760
  return;
}
}
#line 5763 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntPtaParaReload(struct rtw_adapter *padapter ) 
{ 


  {
#line 5766
  rtl8723au_write8(padapter, 1740U, 0);
#line 5767
  rtl8723au_write32(padapter, 1736U, 65535U);
#line 5768
  rtl8723au_write32(padapter, 1732U, 1431655765U);
#line 5771
  rtl8723au_write32(padapter, 2136U, 2863311530U);
#line 5772
  if ((unsigned int )((struct hal_data_8723a *)padapter->HalData)->VersionID.ICType == 4U && (unsigned int )((struct hal_data_8723a *)padapter->HalData)->VersionID.CUTVersion == 0U) {
#line 5774
    rtl8723au_write32(padapter, 2160U, 0U);
#line 5775
    rtl8723au_write8(padapter, 64U, 36);
  } else {
#line 5777
    rtl8723au_write8(padapter, 64U, 32);
#line 5779
    rtl8723au_write16(padapter, 2144U, 528);
#line 5781
    rtl8723au_write32(padapter, 2160U, 768U);
#line 5783
    rtl8723au_write32(padapter, 2164U, 578830336U);
  }
#line 5787
  rtl8723au_write8(padapter, 1912U, 1);
#line 5790
  btdm_SetFwIgnoreWlanAct(padapter, 0);
#line 5791
  return;
}
}
#line 5799 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static s8 btdm_1AntTdmaJudgement(struct rtw_adapter *padapter , u8 retry ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  s8 up___0 ;
  s8 dn ;
  s8 m ;
  s8 n ;
  s8 WaitCount ;
  s8 ret ;

  {
#line 5803
  m = 1;
#line 5803
  n = 3;
#line 5806
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5807
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5808
  ret = 0;
#line 5810
  if (pBtdm8723->psTdmaMonitorCnt == 0U) {
#line 5811
    up___0 = 0;
#line 5812
    dn = 0;
#line 5813
    m = 1;
#line 5814
    n = 3;
#line 5815
    WaitCount = 0;
  } else {
#line 5817
    WaitCount = (s8 )((int )WaitCount + 1);
  }
#line 5820
  if ((unsigned int )retry == 0U) {
#line 5822
    up___0 = (s8 )((int )up___0 + 1);
#line 5823
    dn = (s8 )((int )dn - 1);
#line 5824
    if ((int )dn < 0) {
#line 5825
      dn = 0;
    } else {

    }
#line 5826
    if ((int )up___0 >= (int )m * 3) {
#line 5828
      ret = 1;
#line 5830
      n = 3;
#line 5831
      up___0 = 0;
#line 5832
      dn = 0;
#line 5833
      WaitCount = 0;
    } else {

    }
  } else
#line 5835
  if ((unsigned int )retry <= 3U) {
#line 5837
    up___0 = (s8 )((int )up___0 - 1);
#line 5838
    dn = (s8 )((int )dn + 1);
#line 5839
    if ((int )up___0 < 0) {
#line 5840
      up___0 = 0;
    } else {

    }
#line 5842
    if ((int )dn == 2) {
#line 5844
      ret = -1;
#line 5847
      if ((int )WaitCount <= 2) {
#line 5848
        m = (s8 )((int )m + 1);
      } else {
#line 5850
        m = 1;
      }
#line 5853
      if ((int )m > 19) {
#line 5854
        m = 20;
      } else {

      }
#line 5855
      up___0 = 0;
#line 5856
      dn = 0;
#line 5857
      WaitCount = 0;
    } else {

    }
  } else {
#line 5862
    ret = -1;
#line 5865
    if ((int )WaitCount == 1) {
#line 5866
      m = (s8 )((int )m + 1);
    } else {
#line 5868
      m = 1;
    }
#line 5869
    if ((int )m > 19) {
#line 5870
      m = 20;
    } else {

    }
#line 5872
    up___0 = 0;
#line 5873
    dn = 0;
#line 5874
    WaitCount = 0;
  }
#line 5876
  return (ret);
}
}
#line 5879 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntTdmaDurationAdjustForACL(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  s32 judge ;
  s8 tmp ;

  {
#line 5881
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5882
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 5884
  if (pBtdm8723->psTdmaGlobalCnt != pBtdm8723->psTdmaMonitorCnt) {
#line 5885
    pBtdm8723->psTdmaMonitorCnt = 0U;
#line 5886
    pBtdm8723->psTdmaGlobalCnt = 0U;
  } else {

  }
#line 5888
  if (pBtdm8723->psTdmaMonitorCnt == 0U) {
#line 5889
    btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 2);
#line 5890
    pBtdm8723->psTdmaDuAdjType = 2U;
  } else {
#line 5895
    if ((((unsigned int )pBtdm8723->curPsTdma != 1U && (unsigned int )pBtdm8723->curPsTdma != 2U) && (unsigned int )pBtdm8723->curPsTdma != 9U) && (unsigned int )pBtdm8723->curPsTdma != 11U) {
#line 5899
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
    } else {
#line 5901
      judge = 0;
#line 5903
      tmp = btdm_1AntTdmaJudgement(padapter, (int )pHalData->bt_coexist.halCoex8723.btRetryCnt);
#line 5903
      judge = (s32 )tmp;
#line 5904
      if (judge == -1) {
#line 5905
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 5907
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
#line 5908
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
#line 5910
            pBtdm8723->psTdmaDuAdjType = 2U;
          }
#line 5911
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else
#line 5912
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 5913
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 9);
#line 5914
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
#line 5915
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 5916
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 11);
#line 5917
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else {

        }
      } else
#line 5919
      if (judge == 1) {
#line 5920
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 5921
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 9);
#line 5922
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
#line 5923
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 5924
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
#line 5925
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
#line 5927
            pBtdm8723->psTdmaDuAdjType = 2U;
          }
#line 5928
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else
#line 5929
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 5930
          if ((unsigned int )pHalData->bt_coexist.halCoex8723.btInfoExt != 0U) {
#line 5931
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {
#line 5933
            pBtdm8723->psTdmaDuAdjType = 1U;
          }
#line 5934
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, (int )pBtdm8723->psTdmaDuAdjType);
        } else {

        }
      } else {

      }
    }
#line 5938
    if (BTCoexDbgLevel == 1U) {
#line 5938
      printk("[BTCoex], ACL current TDMA(%s, %d)\n", (unsigned int )pBtdm8723->bCurPsTdmaOn != 0U ? (char *)"ON" : (char *)"OFF",
             (int )pBtdm8723->curPsTdma);
    } else {

    }
  }
#line 5942
  pBtdm8723->psTdmaMonitorCnt = pBtdm8723->psTdmaMonitorCnt + 1U;
#line 5943
  return;
}
}
#line 5945 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntCoexProcessForWifiConnect(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 BtState ;
  u8 tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 5953
  pmlmepriv = & padapter->mlmepriv;
#line 5954
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 5955
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 5956
  pBtdm8723 = & pBtCoex->btdm1Ant;
#line 5957
  BtState = pBtCoex->c2hBtInfo;
#line 5959
  if (BTCoexDbgLevel == 1U) {
#line 5959
    tmp = BTDM_IsWifiBusy(padapter);
#line 5959
    printk("[BTCoex], WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {

  }
#line 5961
  if (BTCoexDbgLevel == 1U) {
#line 5961
    printk("[BTCoex], BT is %s\n", BtStateString[(int )BtState]);
  } else {

  }
#line 5964
  padapter->pwrctrlpriv.btcoex_rfon = 0U;
#line 5966
  tmp___0 = BTDM_IsWifiBusy(padapter);
#line 5966
  if ((unsigned int )tmp___0 == 0U) {
#line 5966
    tmp___1 = check_fwstate(& padapter->mlmepriv, 16);
#line 5966
    if (tmp___1) {
#line 5966
      tmp___2 = 0;
    } else {
#line 5966
      tmp___2 = 1;
    }
#line 5966
    if (tmp___2) {
#line 5966
      if ((unsigned int )BtState == 1U || (unsigned int )BtState == 2U) {
#line 5970
        switch ((int )BtState) {
        case 1: 
#line 5972
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 38, 0, 9);
#line 5973
        goto ldv_56038;
        case 2: 
#line 5975
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 38, 0, 0);
#line 5976
        goto ldv_56038;
        }
        ldv_56038: ;
      } else {
#line 5966
        goto _L___0;
      }
    } else {
#line 5966
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 5979
    switch ((int )BtState) {
    case 1: ;
    case 2: 
#line 5983
    btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 5);
#line 5984
    rtl8723au_write32(padapter, 1728U, 1515870810U);
#line 5985
    rtl8723au_write32(padapter, 1732U, 1515870810U);
#line 5986
    goto ldv_56042;
    case 7: ;
#line 5988
    if (BTCoexDbgLevel == 1U) {
#line 5988
      printk("[BTCoex], BT PROFILE is BT_INFO_STATE_ACL_INQ_OR_PAG\n");
    } else {

    }
    case 3: 
#line 5992
    padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 5993
    btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 30);
#line 5994
    goto ldv_56042;
    case 5: ;
    case 6: ;
#line 5997
    if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
#line 5998
      btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 32);
    } else {
#line 6005
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
#line 6007
      rtl8723au_write32(padapter, 1728U, 1515870810U);
#line 6008
      rtl8723au_write32(padapter, 1732U, 1515870810U);
    }
#line 6011
    goto ldv_56042;
    case 4: 
#line 6013
    padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 6014
    if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
#line 6015
      if (BTCoexDbgLevel == 1U) {
#line 6015
        printk("[BTCoex], BT PROFILE is HID\n");
      } else {

      }
#line 6017
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 31);
    } else
#line 6018
    if ((unsigned int )pBtCoex->c2hBtProfile == 128U) {
#line 6019
      if (BTCoexDbgLevel == 1U) {
#line 6019
        printk("[BTCoex], BT PROFILE is FTP/OPP\n");
      } else {

      }
#line 6021
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 3);
    } else
#line 6022
    if ((unsigned int )pBtCoex->c2hBtProfile == 192U) {
#line 6023
      if (BTCoexDbgLevel == 1U) {
#line 6023
        printk("[BTCoex], BT PROFILE is A2DP_FTP\n");
      } else {

      }
#line 6025
      btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 11);
    } else {
#line 6027
      if ((unsigned int )pBtCoex->c2hBtProfile == 64U) {
#line 6028
        if (BTCoexDbgLevel == 1U) {
#line 6028
          printk("[BTCoex], BT PROFILE is A2DP\n");
        } else {

        }
      } else
#line 6032
      if (BTCoexDbgLevel == 1U) {
#line 6032
        printk("[BTCoex], BT PROFILE is UNKNOWN(0x%02X)! Use A2DP Profile\n", (int )pBtCoex->c2hBtProfile);
      } else {

      }
#line 6037
      btdm_1AntTdmaDurationAdjustForACL(padapter);
    }
#line 6039
    goto ldv_56042;
    }
    ldv_56042: ;
  }
#line 6043
  pBtdm8723->psTdmaGlobalCnt = pBtdm8723->psTdmaGlobalCnt + 1U;
#line 6044
  return;
}
}
#line 6047 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntUpdateHalRAMask(struct rtw_adapter *padapter , u32 mac_id , u32 filter ) 
{ 
  u8 init_rate ;
  u8 raid ;
  u32 mask ;
  u8 shortGIrate ;
  int supportRateNum ;
  struct sta_info *psta ;
  struct hal_data_8723a *pHalData ;
  struct dm_priv *pdmpriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *cur_network ;
  uint tmp ;
  unsigned int tmp___0 ;
  u32 tmp___1 ;
  int tmp___2 ;
  uint tmp___3 ;
  uint tmp___4 ;
  unsigned char tmp___5 ;
  u8 arg ;

  {
#line 6049
  init_rate = 0U;
#line 6052
  shortGIrate = 0U;
#line 6053
  supportRateNum = 0;
#line 6061
  if (BTCoexDbgLevel == 1U) {
#line 6061
    printk("[BTCoex], %s, MACID =%d, filter = 0x%08x!!\n", "btdm_1AntUpdateHalRAMask",
           mac_id, filter);
  } else {

  }
#line 6064
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6065
  pdmpriv = & pHalData->dmpriv;
#line 6066
  pmlmeext = & padapter->mlmeextpriv;
#line 6067
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 6068
  cur_network = & pmlmeinfo->network;
#line 6070
  if (mac_id > 31U) {
#line 6071
    if (BTCoexDbgLevel == 1U) {
#line 6071
      printk("[BTCoex], %s, MACID =%d illegal!!\n", "btdm_1AntUpdateHalRAMask", mac_id);
    } else {

    }
#line 6073
    return;
  } else {

  }
#line 6076
  psta = pmlmeinfo->FW_sta_info[mac_id].psta;
#line 6077
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 6078
    if (BTCoexDbgLevel == 1U) {
#line 6078
      printk("[BTCoex], %s, Can\'t find station!!\n", "btdm_1AntUpdateHalRAMask");
    } else {

    }
#line 6080
    return;
  } else {

  }
#line 6083
  raid = psta->raid;
#line 6085
  switch (mac_id) {
  case 0U: 
#line 6087
  tmp = rtw_get_rateset_len23a((u8 *)(& cur_network->SupportedRates));
#line 6087
  supportRateNum = (int )tmp;
#line 6089
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
#line 6091
  if ((unsigned int )pmlmeinfo->HT_enable != 0U) {
#line 6091
    tmp___0 = update_MSC_rate23a(& pmlmeinfo->HT_caps);
#line 6091
    tmp___1 = tmp___0;
  } else {
#line 6091
    tmp___1 = 0U;
  }
#line 6091
  mask = tmp___1 | mask;
#line 6093
  tmp___2 = support_short_GI23a(padapter, & pmlmeinfo->HT_caps);
#line 6093
  if (tmp___2 != 0) {
#line 6094
    shortGIrate = 1U;
  } else {

  }
#line 6095
  goto ldv_56066;
  case 1U: 
#line 6097
  tmp___3 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
#line 6097
  supportRateNum = (int )tmp___3;
#line 6099
  mask = update_basic_rate23a((unsigned char *)(& cur_network->SupportedRates), (unsigned int )supportRateNum);
#line 6101
  goto ldv_56066;
  default: 
#line 6103
  tmp___4 = rtw_get_rateset_len23a((u8 *)(& pmlmeinfo->FW_sta_info[mac_id].SupportedRates));
#line 6103
  supportRateNum = (int )tmp___4;
#line 6105
  mask = update_supported_rate23a((unsigned char *)(& cur_network->SupportedRates),
                                  (unsigned int )supportRateNum);
#line 6107
  goto ldv_56066;
  }
  ldv_56066: 
#line 6109
  mask = (u32 )((int )raid << 28) | mask;
#line 6110
  mask = mask;
#line 6111
  mask = ~ filter & mask;
#line 6112
  tmp___5 = get_highest_rate_idx23a(mask);
#line 6112
  init_rate = (unsigned int )tmp___5 & 63U;
#line 6114
  if ((unsigned int )pHalData->fw_ractrl != 0U) {
#line 6115
    arg = 0U;
#line 6117
    arg = (unsigned int )((u8 )mac_id) & 31U;
#line 6118
    arg = (u8 )((unsigned int )arg | 128U);
#line 6119
    if ((unsigned int )shortGIrate == 1U) {
#line 6120
      arg = (u8 )((unsigned int )arg | 32U);
    } else {

    }
#line 6122
    if (BTCoexDbgLevel == 1U) {
#line 6122
      printk("[BTCoex], Update FW RAID entry, MASK = 0x%08x, arg = 0x%02x\n", mask,
             (int )arg);
    } else {

    }
#line 6126
    rtl8723a_set_raid_cmd(padapter, mask, (int )arg);
  } else {
#line 6128
    if ((unsigned int )shortGIrate != 0U) {
#line 6129
      init_rate = (u8 )((unsigned int )init_rate | 64U);
    } else {

    }
#line 6131
    rtl8723au_write8(padapter, mac_id + 1156U, (int )init_rate);
  }
#line 6135
  psta->init_rate = init_rate;
#line 6136
  pdmpriv->INIDATA_RATE[mac_id] = init_rate;
#line 6137
  return;
}
}
#line 6140 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntUpdateHalRAMaskForSCO(struct rtw_adapter *padapter , u8 forceUpdate ) 
{ 
  struct btdm_8723a_1ant *pBtdm8723 ;
  struct sta_priv *pstapriv ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_info *psta ;
  u32 macid ;
  u32 filter ;

  {
#line 6147
  filter = 0U;
#line 6149
  pBtdm8723 = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant;
#line 6151
  if ((unsigned int )pBtdm8723->bRAChanged == 1U && (unsigned int )forceUpdate == 0U) {
#line 6152
    return;
  } else {

  }
#line 6154
  pstapriv = & padapter->stapriv;
#line 6155
  cur_network = & padapter->mlmeextpriv.mlmext_info.network;
#line 6156
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
#line 6157
  macid = psta->mac_id;
#line 6159
  filter = filter | 1U;
#line 6160
  filter = filter | 2U;
#line 6161
  filter = filter | 4U;
#line 6162
  filter = filter | 8U;
#line 6163
  filter = filter | 16U;
#line 6164
  filter = filter | 32U;
#line 6166
  btdm_1AntUpdateHalRAMask(padapter, macid, filter);
#line 6168
  pBtdm8723->bRAChanged = 1U;
#line 6169
  return;
}
}
#line 6171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntRecoverHalRAMask(struct rtw_adapter *padapter ) 
{ 
  struct btdm_8723a_1ant *pBtdm8723 ;
  struct sta_priv *pstapriv ;
  struct wlan_bssid_ex *cur_network ;
  struct sta_info *psta ;

  {
#line 6178
  pBtdm8723 = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant;
#line 6180
  if ((unsigned int )pBtdm8723->bRAChanged == 0U) {
#line 6181
    return;
  } else {

  }
#line 6183
  pstapriv = & padapter->stapriv;
#line 6184
  cur_network = & padapter->mlmeextpriv.mlmext_info.network;
#line 6185
  psta = rtw_get_stainfo23a(pstapriv, (u8 const   *)(& cur_network->MacAddress));
#line 6187
  Update_RA_Entry23a(padapter, psta);
#line 6189
  pBtdm8723->bRAChanged = 0U;
#line 6190
  return;
}
}
#line 6193 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntBTStateChangeHandler(struct rtw_adapter *padapter , enum bt_state_1ant oldState ,
                                          enum bt_state_1ant newState ) 
{ 
  struct hal_data_8723a *phaldata ;
  bool tmp ;
  u8 tmp___0 ;
  struct hal_data_8723a *Hal ;
  struct hal_data_8723a *Hal___0 ;

  {
#line 6198
  if (BTCoexDbgLevel == 1U) {
#line 6198
    printk("[BTCoex], BT state change, %s => %s\n", BtStateString[(unsigned int )oldState],
           BtStateString[(unsigned int )newState]);
  } else {

  }
#line 6204
  if ((unsigned int )newState != 0U) {
#line 6205
    btdm_SetFwIgnoreWlanAct(padapter, 0);
  } else {

  }
#line 6207
  tmp = check_fwstate(& padapter->mlmepriv, 8);
#line 6207
  if ((int )tmp) {
#line 6207
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
#line 6207
    if ((unsigned int )tmp___0 != 0U) {
#line 6209
      if ((unsigned int )newState == 5U || (unsigned int )newState == 6U) {
#line 6211
        btdm_1AntUpdateHalRAMaskForSCO(padapter, 0);
      } else {
#line 6214
        btdm_1AntRecoverHalRAMask(padapter);
      }
    } else {
#line 6217
      phaldata = (struct hal_data_8723a *)padapter->HalData;
#line 6218
      phaldata->bt_coexist.halCoex8723.btdm1Ant.bRAChanged = 0U;
    }
  } else {
#line 6217
    phaldata = (struct hal_data_8723a *)padapter->HalData;
#line 6218
    phaldata->bt_coexist.halCoex8723.btdm1Ant.bRAChanged = 0U;
  }
#line 6221
  if ((unsigned int )oldState == (unsigned int )newState) {
#line 6222
    return;
  } else {

  }
#line 6224
  if ((unsigned int )oldState == 4U) {
#line 6225
    Hal = (struct hal_data_8723a *)padapter->HalData;
#line 6226
    Hal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCnt = 0U;
#line 6227
    Hal->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0U;
  } else {

  }
#line 6230
  if ((unsigned int )oldState == 5U || (unsigned int )oldState == 6U) {
#line 6232
    Hal___0 = (struct hal_data_8723a *)padapter->HalData;
#line 6233
    Hal___0->bt_coexist.halCoex8723.btdm1Ant.psTdmaMonitorCntForSCO = 0U;
  } else {

  }
#line 6237
  if ((unsigned int )oldState == 0U || (unsigned int )oldState == 1U) {
#line 6239
    if ((unsigned int )newState != 0U && (unsigned int )newState != 1U) {
#line 6241
      BTDM_SetSwRfRxLpfCorner(padapter, 1);
#line 6243
      BTDM_AGCTable(padapter, 1);
#line 6244
      BTDM_BBBackOffLevel(padapter, 1);
    } else {

    }
  } else
#line 6247
  if ((unsigned int )newState == 0U || (unsigned int )newState == 1U) {
#line 6249
    BTDM_SetSwRfRxLpfCorner(padapter, 0);
#line 6251
    BTDM_AGCTable(padapter, 0);
#line 6252
    BTDM_BBBackOffLevel(padapter, 0);
  } else {

  }
#line 6254
  return;
}
}
#line 6257 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_1AntBtCoexistHandler(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex8723 ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 6263
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6264
  pBtCoex8723 = & pHalData->bt_coexist.halCoex8723;
#line 6265
  pBtdm8723 = & pBtCoex8723->btdm1Ant;
#line 6266
  padapter->pwrctrlpriv.btcoex_rfon = 0U;
#line 6267
  tmp___2 = rtl8723a_BT_enabled(padapter);
#line 6267
  if (tmp___2) {
#line 6267
    tmp___3 = 0;
  } else {
#line 6267
    tmp___3 = 1;
  }
#line 6267
  if (tmp___3) {
#line 6268
    if (BTCoexDbgLevel == 1U) {
#line 6268
      printk("[BTCoex], BT is disabled\n");
    } else {

    }
#line 6270
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
#line 6270
    if ((unsigned int )tmp___0 != 0U) {
#line 6271
      if (BTCoexDbgLevel == 1U) {
#line 6271
        printk("[BTCoex], wifi is connected\n");
      } else {

      }
#line 6274
      tmp = BTDM_IsWifiBusy(padapter);
#line 6274
      if ((unsigned int )tmp != 0U) {
#line 6275
        if (BTCoexDbgLevel == 1U) {
#line 6275
          printk("[BTCoex], Wifi is busy\n");
        } else {

        }
#line 6277
        btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
      } else {
#line 6280
        if (BTCoexDbgLevel == 1U) {
#line 6280
          printk("[BTCoex], Wifi is idle\n");
        } else {

        }
#line 6282
        _btdm_1AntSetPSTDMA(padapter, 1, 2, 1, 0, 9);
      }
    } else {
#line 6286
      if (BTCoexDbgLevel == 1U) {
#line 6286
        printk("[BTCoex], wifi is disconnected\n");
      } else {

      }
#line 6289
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    }
  } else {
#line 6292
    if (BTCoexDbgLevel == 1U) {
#line 6292
      printk("[BTCoex], BT is enabled\n");
    } else {

    }
#line 6294
    tmp___1 = BTDM_IsWifiConnectionExist(padapter);
#line 6294
    if ((unsigned int )tmp___1 != 0U) {
#line 6295
      if (BTCoexDbgLevel == 1U) {
#line 6295
        printk("[BTCoex], wifi is connected\n");
      } else {

      }
#line 6298
      btdm_1AntWifiParaAdjust(padapter, 1);
#line 6299
      btdm_1AntCoexProcessForWifiConnect(padapter);
    } else {
#line 6301
      if (BTCoexDbgLevel == 1U) {
#line 6301
        printk("[BTCoex], wifi is disconnected\n");
      } else {

      }
#line 6306
      btdm_1AntWifiParaAdjust(padapter, 0);
#line 6307
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 0);
    }
  }
#line 6311
  btdm_1AntBTStateChangeHandler(padapter, (enum bt_state_1ant )pBtCoex8723->prec2hBtInfo,
                                (enum bt_state_1ant )pBtCoex8723->c2hBtInfo);
#line 6313
  pBtCoex8723->prec2hBtInfo = pBtCoex8723->c2hBtInfo;
#line 6314
  return;
}
}
#line 6316 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_1AntSignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 RSSI_WiFi_Cmpnstn ;
  u8 RSSI_BT_Cmpnstn ;

  {
#line 6323
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6324
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm1Ant;
#line 6325
  RSSI_WiFi_Cmpnstn = 0U;
#line 6326
  RSSI_BT_Cmpnstn = 0U;
#line 6328
  switch ((int )pBtdm8723->curPsTdma) {
  case 1: 
#line 6330
  RSSI_WiFi_Cmpnstn = 11U;
#line 6331
  goto ldv_56111;
  case 2: 
#line 6333
  RSSI_WiFi_Cmpnstn = 14U;
#line 6334
  goto ldv_56111;
  case 9: 
#line 6336
  RSSI_WiFi_Cmpnstn = 18U;
#line 6337
  goto ldv_56111;
  case 11: 
#line 6339
  RSSI_WiFi_Cmpnstn = 20U;
#line 6340
  goto ldv_56111;
  case 4: 
#line 6342
  RSSI_WiFi_Cmpnstn = 17U;
#line 6343
  goto ldv_56111;
  case 16: 
#line 6345
  RSSI_WiFi_Cmpnstn = 18U;
#line 6346
  goto ldv_56111;
  case 18: 
#line 6348
  RSSI_WiFi_Cmpnstn = 14U;
#line 6349
  goto ldv_56111;
  case 23: ;
  case 24: ;
  case 25: ;
  case 26: ;
  case 27: ;
  case 33: 
#line 6356
  RSSI_WiFi_Cmpnstn = 22U;
#line 6357
  goto ldv_56111;
  default: ;
#line 6359
  goto ldv_56111;
  }
  ldv_56111: ;
#line 6362
  if ((unsigned long )rssi_wifi != (unsigned long )((u8 *)0U) && (unsigned int )RSSI_WiFi_Cmpnstn != 0U) {
#line 6363
    if (BTCoexDbgLevel == 1U) {
#line 6363
      printk("[BTCoex], 1AntSgnlCmpnstn, case %d, WiFiCmpnstn =%d(%d => %d)\n", (int )pBtdm8723->curPsTdma,
             (int )RSSI_WiFi_Cmpnstn, (int )*rssi_wifi, (int )*rssi_wifi + (int )RSSI_WiFi_Cmpnstn);
    } else {

    }
#line 6368
    *rssi_wifi = (int )*rssi_wifi + (int )RSSI_WiFi_Cmpnstn;
  } else {

  }
#line 6371
  if ((unsigned long )rssi_bt != (unsigned long )((u8 *)0U) && (unsigned int )RSSI_BT_Cmpnstn != 0U) {
#line 6372
    if (BTCoexDbgLevel == 1U) {
#line 6372
      printk("[BTCoex], 1AntSgnlCmpnstn, case %d, BTCmpnstn =%d(%d => %d)\n", (int )pBtdm8723->curPsTdma,
             (int )RSSI_BT_Cmpnstn, (int )*rssi_bt, (int )*rssi_bt + (int )RSSI_BT_Cmpnstn);
    } else {

    }
#line 6376
    *rssi_bt = (int )*rssi_bt + (int )RSSI_BT_Cmpnstn;
  } else {

  }
#line 6378
  return;
}
}
#line 6380 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_1AntParaInit(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;

  {
#line 6386
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6387
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6388
  pBtdm8723 = & pBtCoex->btdm1Ant;
#line 6391
  rtl8723au_write8(padapter, 1902U, 4);
#line 6392
  btdm_1AntPtaParaReload(padapter);
#line 6394
  pBtdm8723->wifiRssiThresh = 48U;
#line 6396
  pBtdm8723->bWiFiHalt = 0U;
#line 6397
  pBtdm8723->bRAChanged = 0U;
#line 6399
  if ((unsigned int )pBtCoex->c2hBtInfo != 0U && (unsigned int )pBtCoex->c2hBtInfo != 1U) {
#line 6401
    BTDM_SetSwRfRxLpfCorner(padapter, 1);
#line 6402
    BTDM_AGCTable(padapter, 1);
#line 6403
    BTDM_BBBackOffLevel(padapter, 1);
  } else {

  }
#line 6405
  return;
}
}
#line 6407 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_1AntForHalt(struct rtw_adapter *padapter ) 
{ 


  {
#line 6409
  if (BTCoexDbgLevel == 1U) {
#line 6409
    printk("\n[BTCoex], 1Ant for halt\n");
  } else {

  }
#line 6411
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt = 1U;
#line 6414
  btdm_1AntWifiParaAdjust(padapter, 0);
#line 6420
  btdm_1AntPsTdma(padapter, 0, 0);
#line 6422
  btdm_SetFwIgnoreWlanAct(padapter, 1);
#line 6423
  return;
}
}
#line 6425 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_1AntLpsLeave(struct rtw_adapter *padapter ) 
{ 


  {
#line 6427
  if (BTCoexDbgLevel == 1U) {
#line 6427
    printk("\n[BTCoex], 1Ant for LPS Leave\n");
  } else {

  }
#line 6430
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723.btdm1Ant.bWiFiHalt = 1U;
#line 6433
  btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
#line 6434
  return;
}
}
#line 6437 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_1AntWifiAssociateNotify(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 BtState ;
  bool tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 6439
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6441
  if (BTCoexDbgLevel == 1U) {
#line 6441
    printk("\n[BTCoex], 1Ant for associate, type =%d\n", (int )type);
  } else {

  }
#line 6444
  if ((unsigned int )type != 0U) {
#line 6445
    rtl8723a_CheckAntenna_Selection(padapter);
#line 6446
    tmp = rtl8723a_BT_enabled(padapter);
#line 6446
    if (tmp) {
#line 6446
      tmp___0 = 0;
    } else {
#line 6446
      tmp___0 = 1;
    }
#line 6446
    if (tmp___0) {
#line 6447
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    } else {
#line 6452
      pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6453
      BtState = pBtCoex->c2hBtInfo;
#line 6455
      btdm_1AntTSFSwitch(padapter, 1);
#line 6457
      if ((unsigned int )BtState == 1U || (unsigned int )BtState == 2U) {
#line 6459
        btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 28);
      } else
#line 6461
      if ((unsigned int )BtState == 5U || (unsigned int )BtState == 6U) {
#line 6463
        btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 8);
#line 6465
        rtl8723au_write32(padapter, 1728U, 1515870810U);
#line 6466
        rtl8723au_write32(padapter, 1732U, 1515870810U);
      } else
#line 6467
      if ((unsigned int )BtState == 4U || (unsigned int )BtState == 7U) {
#line 6469
        if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
#line 6470
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 35);
        } else {
#line 6473
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 29);
        }
      } else {

      }
    }
  } else {
#line 6478
    tmp___2 = rtl8723a_BT_enabled(padapter);
#line 6478
    if (tmp___2) {
#line 6478
      tmp___3 = 0;
    } else {
#line 6478
      tmp___3 = 1;
    }
#line 6478
    if (tmp___3) {
#line 6479
      tmp___1 = BTDM_IsWifiConnectionExist(padapter);
#line 6479
      if ((unsigned int )tmp___1 == 0U) {
#line 6480
        btdm_1AntPsTdma(padapter, 0, 0);
#line 6481
        btdm_1AntTSFSwitch(padapter, 0);
      } else {

      }
    } else {

    }
#line 6485
    btdm_1AntBtCoexistHandler(padapter);
  }
#line 6487
  return;
}
}
#line 6490 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_1AntMediaStatusNotify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;

  {
#line 6495
  pBtCoex = & ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.halCoex8723;
#line 6497
  if (BTCoexDbgLevel == 1U) {
#line 6497
    printk("\n\n[BTCoex]******************************\n");
  } else {

  }
#line 6499
  if (BTCoexDbgLevel == 1U) {
#line 6499
    printk("[BTCoex], MediaStatus, WiFi %s !!\n", (unsigned int )mstatus == 1U ? (char *)"CONNECT" : (char *)"DISCONNECT");
  } else {

  }
#line 6501
  if (BTCoexDbgLevel == 1U) {
#line 6501
    printk("[BTCoex]******************************\n");
  } else {

  }
#line 6503
  if ((unsigned int )mstatus == 1U) {
#line 6504
    tmp = check_fwstate(& padapter->mlmepriv, 8);
#line 6504
    if ((int )tmp) {
#line 6505
      if ((unsigned int )pBtCoex->c2hBtInfo == 5U || (unsigned int )pBtCoex->c2hBtInfo == 6U) {
#line 6507
        btdm_1AntUpdateHalRAMaskForSCO(padapter, 1);
      } else {

      }
    } else {

    }
#line 6510
    padapter->pwrctrlpriv.DelayLPSLastTimeStamp = jiffies;
#line 6511
    BTDM_1AntForDhcp(padapter);
  } else {
#line 6515
    rtl8723a_DeinitAntenna_Selection(padapter);
#line 6516
    btdm_1AntBtCoexistHandler(padapter);
#line 6517
    pBtCoex->btdm1Ant.bRAChanged = 0U;
  }
#line 6519
  return;
}
}
#line 6521 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_1AntForDhcp(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 BtState ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;

  {
#line 6528
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6529
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6530
  BtState = pBtCoex->c2hBtInfo;
#line 6531
  pBtdm8723 = & pBtCoex->btdm1Ant;
#line 6533
  if (BTCoexDbgLevel == 1U) {
#line 6533
    printk("\n[BTCoex], 1Ant for DHCP\n");
  } else {

  }
#line 6534
  if (BTCoexDbgLevel == 1U) {
#line 6534
    tmp = BTDM_IsWifiBusy(padapter);
#line 6534
    printk("[BTCoex], 1Ant for DHCP, WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {

  }
#line 6536
  if (BTCoexDbgLevel == 1U) {
#line 6536
    printk("[BTCoex], 1Ant for DHCP, %s\n", BtStateString[(int )BtState]);
  } else {

  }
#line 6539
  BTDM_1AntWifiAssociateNotify(padapter, 1);
#line 6540
  return;
}
}
#line 6542 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_1AntWifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 BtState ;
  struct bt_coexist_8723a *pBtCoex ;
  struct btdm_8723a_1ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 6549
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6550
  BtState = pHalData->bt_coexist.halCoex8723.c2hBtInfo;
#line 6551
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6552
  pBtdm8723 = & pBtCoex->btdm1Ant;
#line 6554
  if (BTCoexDbgLevel == 1U) {
#line 6554
    printk("\n[BTCoex], 1Ant for wifi scan =%d!!\n", (int )scanType);
  } else {

  }
#line 6556
  if (BTCoexDbgLevel == 1U) {
#line 6556
    tmp = BTDM_IsWifiBusy(padapter);
#line 6556
    printk("[BTCoex], 1Ant for wifi scan, WiFi is %s\n", (unsigned int )tmp != 0U ? (char *)"Busy" : (char *)"IDLE");
  } else {

  }
#line 6558
  if (BTCoexDbgLevel == 1U) {
#line 6558
    printk("[BTCoex], 1Ant for wifi scan, %s\n", BtStateString[(int )BtState]);
  } else {

  }
#line 6561
  if ((unsigned int )scanType != 0U) {
#line 6562
    rtl8723a_CheckAntenna_Selection(padapter);
#line 6563
    tmp___1 = rtl8723a_BT_enabled(padapter);
#line 6563
    if (tmp___1) {
#line 6563
      tmp___2 = 0;
    } else {
#line 6563
      tmp___2 = 1;
    }
#line 6563
    if (tmp___2) {
#line 6564
      btdm_1AntSetPSTDMA(padapter, 0, 0, 0, 9);
    } else {
#line 6565
      tmp___0 = BTDM_IsWifiConnectionExist(padapter);
#line 6565
      if ((unsigned int )tmp___0 == 0U) {
#line 6566
        BTDM_1AntWifiAssociateNotify(padapter, 1);
      } else
#line 6568
      if ((unsigned int )BtState == 5U || (unsigned int )BtState == 6U) {
#line 6570
        if ((unsigned int )pBtCoex->bC2hBtInquiryPage != 0U) {
#line 6571
          btdm_1AntSetPSTDMA(padapter, 0, 0, 1, 32);
        } else {
#line 6574
          padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 6576
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 33);
        }
      } else
#line 6579
      if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
#line 6580
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 6581
        btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 30);
      } else
#line 6582
      if ((unsigned int )BtState == 4U) {
#line 6583
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 6584
        if ((unsigned int )pBtCoex->c2hBtProfile == 32U) {
#line 6585
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 34);
        } else {
#line 6588
          btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 4);
        }
      } else {
#line 6591
        padapter->pwrctrlpriv.btcoex_rfon = 1U;
#line 6592
        btdm_1AntSetPSTDMA(padapter, 1, 0, 1, 5);
      }
    }
#line 6596
    btdm_NotifyFwScan(padapter, 1);
  } else {
#line 6599
    btdm_NotifyFwScan(padapter, 0);
#line 6600
    btdm_1AntBtCoexistHandler(padapter);
  }
#line 6602
  return;
}
}
#line 6604 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_1AntFwC2hBtInfo8723A(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 u1tmp ;
  u8 btState ;

  {
#line 6612
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6613
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 6614
  pBtMgnt = & pBTInfo->BtMgnt;
#line 6615
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 6617
  u1tmp = pBtCoex->c2hBtInfoOriginal;
#line 6619
  btState = (unsigned int )u1tmp & 15U;
#line 6620
  pBtCoex->c2hBtProfile = (unsigned int )u1tmp & 224U;
#line 6623
  pBtMgnt->ExtConfig.bBTBusy = 0U;
#line 6624
  pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
#line 6627
  if (((unsigned long )btState & 4UL) != 0UL) {
#line 6628
    pBtCoex->bC2hBtInquiryPage = 1U;
  } else {
#line 6630
    pBtCoex->bC2hBtInquiryPage = 0U;
  }
#line 6631
  btState = (unsigned int )btState & 251U;
#line 6633
  if (((unsigned long )btState & 1UL) == 0UL) {
#line 6634
    pBtCoex->c2hBtInfo = 1U;
  } else {
#line 6636
    if ((unsigned int )btState == 1U) {
#line 6637
      pBtCoex->c2hBtInfo = 2U;
    } else
#line 6638
    if ((unsigned int )btState == 9U) {
#line 6639
      if ((unsigned int )pBtCoex->bC2hBtInquiryPage == 1U) {
#line 6640
        pBtCoex->c2hBtInfo = 7U;
      } else {
#line 6643
        pBtCoex->c2hBtInfo = 4U;
      }
#line 6645
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else
#line 6646
    if ((unsigned int )btState == 3U) {
#line 6647
      pBtCoex->c2hBtInfo = 5U;
#line 6648
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else
#line 6649
    if ((unsigned int )btState == 11U) {
#line 6650
      pBtCoex->c2hBtInfo = 6U;
#line 6651
      pBtMgnt->ExtConfig.bBTBusy = 1U;
    } else {
#line 6653
      pBtCoex->c2hBtInfo = 8U;
    }
#line 6654
    if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy != 0U) {
#line 6655
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffefffULL;
    } else {

    }
  }
#line 6659
  if ((unsigned int )pBtCoex->c2hBtInfo == 1U || (unsigned int )pBtCoex->c2hBtInfo == 2U) {
#line 6661
    if ((unsigned int )pBtCoex->bC2hBtInquiryPage != 0U) {
#line 6662
      pBtCoex->c2hBtInfo = 3U;
    } else {

    }
  } else {

  }
#line 6665
  if (BTCoexDbgLevel == 1U) {
#line 6665
    printk("[BTC2H], %s(%d)\n", BtStateString[(int )pBtCoex->c2hBtInfo], (int )pBtCoex->c2hBtInfo);
  } else {

  }
#line 6668
  if ((unsigned int )pBtCoex->c2hBtProfile != 32U) {
#line 6669
    pBtCoex->c2hBtProfile = (unsigned int )pBtCoex->c2hBtProfile & 223U;
  } else {

  }
#line 6670
  return;
}
}
#line 6672 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_1AntBtCoexist8723A(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  unsigned long delta_time ;
  bool tmp ;
  bool tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 6678
  pmlmepriv = & padapter->mlmepriv;
#line 6679
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6681
  tmp = check_fwstate(pmlmepriv, 2048);
#line 6681
  if ((int )tmp) {
#line 6683
    if (BTCoexDbgLevel == 1U) {
#line 6683
      printk("[BTCoex], wifi is under scan progress!!\n");
    } else {

    }
#line 6685
    return;
  } else {

  }
#line 6688
  tmp___0 = check_fwstate(pmlmepriv, 128);
#line 6688
  if ((int )tmp___0) {
#line 6689
    if (BTCoexDbgLevel == 1U) {
#line 6689
      printk("[BTCoex], wifi is under link progress!!\n");
    } else {

    }
#line 6691
    return;
  } else {

  }
#line 6695
  delta_time = (unsigned long )jiffies - padapter->pwrctrlpriv.DelayLPSLastTimeStamp;
#line 6696
  tmp___1 = jiffies_to_msecs(delta_time);
#line 6696
  delta_time = (unsigned long )tmp___1;
#line 6697
  if (delta_time <= 499UL) {
#line 6698
    if (BTCoexDbgLevel == 1U) {
#line 6698
      printk("[BTCoex], wifi is under DHCP progress(%li ms)!!\n", delta_time);
    } else {

    }
#line 6700
    return;
  } else {

  }
#line 6703
  BTDM_CheckWiFiState(padapter);
#line 6705
  btdm_1AntBtCoexistHandler(padapter);
#line 6706
  return;
}
}
#line 6713 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 btdm_ActionAlgorithm(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 bScoExist ;
  u8 bBtLinkExist ;
  u8 bBtHsModeExist ;
  u8 algorithm ;
  u32 tmp ;
  u8 tmp___0 ;
  u32 tmp___1 ;
  u8 tmp___2 ;
  u32 tmp___3 ;
  u8 tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;
  u8 tmp___15 ;
  u8 tmp___16 ;
  u8 tmp___17 ;
  u8 tmp___18 ;
  u8 tmp___19 ;
  u8 tmp___20 ;
  u8 tmp___21 ;
  u8 tmp___22 ;
  u8 tmp___23 ;
  u8 tmp___24 ;
  u8 tmp___25 ;
  u8 tmp___26 ;
  u8 tmp___27 ;
  u8 tmp___28 ;
  u8 tmp___29 ;
  u8 tmp___30 ;

  {
#line 6715
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 6716
  pBtMgnt = & pBTInfo->BtMgnt;
#line 6717
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6718
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 6719
  bScoExist = 0U;
#line 6719
  bBtLinkExist = 0U;
#line 6719
  bBtHsModeExist = 0U;
#line 6720
  algorithm = 0U;
#line 6722
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle != 0U) {
#line 6723
    bBtLinkExist = 1U;
  } else {

  }
#line 6724
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfSCO != 0U) {
#line 6725
    bScoExist = 1U;
  } else {

  }
#line 6731
  pBtdm8723->btStatus = 0U;
#line 6733
  if ((unsigned int )bScoExist != 0U || (unsigned int )bBtHsModeExist != 0U) {
#line 6733
    goto _L;
  } else {
#line 6733
    tmp___6 = BTHCI_CheckProfileExist(padapter, 3);
#line 6733
    if ((unsigned int )tmp___6 != 0U) {
      _L: /* CIL Label */ 
#line 6735
      if (BTCoexDbgLevel == 1U) {
#line 6735
        printk("[BTCoex], SCO or HID or HS exists, set BT non-idle !!!\n");
      } else {

      }
#line 6736
      pBtdm8723->btStatus = 2U;
    } else {
#line 6739
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 6739
        tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
#line 6739
        if ((unsigned int )tmp___0 != 0U) {
#line 6741
          tmp = BTDM_BtTxRxCounterL(padapter);
#line 6741
          if (tmp <= 99U) {
#line 6742
            if (BTCoexDbgLevel == 1U) {
#line 6742
              printk("[BTCoex], A2DP, low priority tx+rx < 100, set BT connected-idle!!!\n");
            } else {

            }
#line 6743
            pBtdm8723->btStatus = 1U;
          } else {
#line 6745
            if (BTCoexDbgLevel == 1U) {
#line 6745
              printk("[BTCoex], A2DP, low priority tx+rx >= 100, set BT non-idle!!!\n");
            } else {

            }
#line 6746
            pBtdm8723->btStatus = 2U;
          }
        } else {

        }
      } else {

      }
#line 6750
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 6750
        tmp___2 = BTHCI_CheckProfileExist(padapter, 2);
#line 6750
        if ((unsigned int )tmp___2 != 0U) {
#line 6752
          tmp___1 = BTDM_BtTxRxCounterL(padapter);
#line 6752
          if (tmp___1 <= 599U) {
#line 6753
            if (BTCoexDbgLevel == 1U) {
#line 6753
              printk("[BTCoex], PAN, low priority tx+rx < 600, set BT connected-idle!!!\n");
            } else {

            }
#line 6754
            pBtdm8723->btStatus = 1U;
          } else
#line 6756
          if (pHalData->bt_coexist.halCoex8723.lowPriorityTx != 0U) {
#line 6757
            if (pHalData->bt_coexist.halCoex8723.lowPriorityRx / pHalData->bt_coexist.halCoex8723.lowPriorityTx > 9U) {
#line 6759
              if (BTCoexDbgLevel == 1U) {
#line 6759
                printk("[BTCoex], PAN, low priority rx/tx > 9, set BT connected-idle!!!\n");
              } else {

              }
#line 6760
              pBtdm8723->btStatus = 1U;
            } else {

            }
          } else {

          }
#line 6764
          if ((unsigned int )pBtdm8723->btStatus != 1U) {
#line 6765
            if (BTCoexDbgLevel == 1U) {
#line 6765
              printk("[BTCoex], PAN, set BT non-idle!!!\n");
            } else {

            }
#line 6766
            pBtdm8723->btStatus = 2U;
          } else {

          }
        } else {

        }
      } else {

      }
#line 6770
      if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 2U) {
#line 6770
        tmp___4 = BTHCI_CheckProfileExist(padapter, 1);
#line 6770
        if ((unsigned int )tmp___4 != 0U) {
#line 6770
          tmp___5 = BTHCI_CheckProfileExist(padapter, 2);
#line 6770
          if ((unsigned int )tmp___5 != 0U) {
#line 6773
            tmp___3 = BTDM_BtTxRxCounterL(padapter);
#line 6773
            if (tmp___3 <= 599U) {
#line 6774
              if (BTCoexDbgLevel == 1U) {
#line 6774
                printk("[BTCoex], PAN+A2DP, low priority tx+rx < 600, set BT connected-idle!!!\n");
              } else {

              }
#line 6775
              pBtdm8723->btStatus = 1U;
            } else
#line 6777
            if (pHalData->bt_coexist.halCoex8723.lowPriorityTx != 0U) {
#line 6778
              if (pHalData->bt_coexist.halCoex8723.lowPriorityRx / pHalData->bt_coexist.halCoex8723.lowPriorityTx > 9U) {
#line 6780
                if (BTCoexDbgLevel == 1U) {
#line 6780
                  printk("[BTCoex], PAN+A2DP, low priority rx/tx > 9, set BT connected-idle!!!\n");
                } else {

                }
#line 6781
                pBtdm8723->btStatus = 1U;
              } else {

              }
            } else {

            }
#line 6785
            if ((unsigned int )pBtdm8723->btStatus != 1U) {
#line 6786
              if (BTCoexDbgLevel == 1U) {
#line 6786
                printk("[BTCoex], PAN+A2DP, set BT non-idle!!!\n");
              } else {

              }
#line 6787
              pBtdm8723->btStatus = 2U;
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    }
  }
#line 6791
  if ((unsigned int )pBtdm8723->btStatus != 0U) {
#line 6792
    pBtMgnt->ExtConfig.bBTBusy = 1U;
  } else {
#line 6794
    pBtMgnt->ExtConfig.bBTBusy = 0U;
  }
#line 6796
  if ((unsigned int )bBtLinkExist == 0U) {
#line 6797
    if (BTCoexDbgLevel == 1U) {
#line 6797
      printk("[BTCoex], No profile exists!!!\n");
    } else {

    }
#line 6798
    return (algorithm);
  } else {

  }
#line 6801
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 6802
    if ((unsigned int )bScoExist != 0U) {
#line 6803
      if (BTCoexDbgLevel == 1U) {
#line 6803
        printk("[BTCoex], SCO only\n");
      } else {

      }
#line 6804
      algorithm = 1U;
    } else {
#line 6806
      tmp___9 = BTHCI_CheckProfileExist(padapter, 3);
#line 6806
      if ((unsigned int )tmp___9 != 0U) {
#line 6807
        if (BTCoexDbgLevel == 1U) {
#line 6807
          printk("[BTCoex], HID only\n");
        } else {

        }
#line 6808
        algorithm = 2U;
      } else {
#line 6809
        tmp___8 = BTHCI_CheckProfileExist(padapter, 1);
#line 6809
        if ((unsigned int )tmp___8 != 0U) {
#line 6810
          if (BTCoexDbgLevel == 1U) {
#line 6810
            printk("[BTCoex], A2DP only\n");
          } else {

          }
#line 6811
          algorithm = 3U;
        } else {
#line 6812
          tmp___7 = BTHCI_CheckProfileExist(padapter, 2);
#line 6812
          if ((unsigned int )tmp___7 != 0U) {
#line 6813
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6814
              if (BTCoexDbgLevel == 1U) {
#line 6814
                printk("[BTCoex], PAN(HS) only\n");
              } else {

              }
#line 6815
              algorithm = 5U;
            } else {
#line 6817
              if (BTCoexDbgLevel == 1U) {
#line 6817
                printk("[BTCoex], PAN(EDR) only\n");
              } else {

              }
#line 6818
              algorithm = 4U;
            }
          } else
#line 6821
          if (BTCoexDbgLevel == 1U) {
#line 6821
            printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d \n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    }
  } else
#line 6825
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 2U) {
#line 6826
    if ((unsigned int )bScoExist != 0U) {
#line 6827
      tmp___12 = BTHCI_CheckProfileExist(padapter, 3);
#line 6827
      if ((unsigned int )tmp___12 != 0U) {
#line 6828
        if (BTCoexDbgLevel == 1U) {
#line 6828
          printk("[BTCoex], SCO + HID\n");
        } else {

        }
#line 6829
        algorithm = 2U;
      } else {
#line 6830
        tmp___11 = BTHCI_CheckProfileExist(padapter, 1);
#line 6830
        if ((unsigned int )tmp___11 != 0U) {
#line 6831
          if (BTCoexDbgLevel == 1U) {
#line 6831
            printk("[BTCoex], Error!!! SCO + A2DP\n");
          } else {

          }
        } else {
#line 6832
          tmp___10 = BTHCI_CheckProfileExist(padapter, 2);
#line 6832
          if ((unsigned int )tmp___10 != 0U) {
#line 6833
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6834
              if (BTCoexDbgLevel == 1U) {
#line 6834
                printk("[BTCoex], SCO + PAN(HS)\n");
              } else {

              }
#line 6835
              algorithm = 1U;
            } else {
#line 6837
              if (BTCoexDbgLevel == 1U) {
#line 6837
                printk("[BTCoex], SCO + PAN(EDR)\n");
              } else {

              }
#line 6838
              algorithm = 7U;
            }
          } else
#line 6841
          if (BTCoexDbgLevel == 1U) {
#line 6841
            printk("[BTCoex], Error!!! SCO exists but why NO matched ACL profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    } else {
#line 6845
      tmp___17 = BTHCI_CheckProfileExist(padapter, 3);
#line 6845
      if ((unsigned int )tmp___17 != 0U) {
#line 6845
        tmp___18 = BTHCI_CheckProfileExist(padapter, 1);
#line 6845
        if ((unsigned int )tmp___18 != 0U) {
#line 6847
          if (BTCoexDbgLevel == 1U) {
#line 6847
            printk("[BTCoex], HID + A2DP\n");
          } else {

          }
#line 6848
          algorithm = 9U;
        } else {
#line 6845
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 6849
        tmp___15 = BTHCI_CheckProfileExist(padapter, 3);
#line 6849
        if ((unsigned int )tmp___15 != 0U) {
#line 6849
          tmp___16 = BTHCI_CheckProfileExist(padapter, 2);
#line 6849
          if ((unsigned int )tmp___16 != 0U) {
#line 6851
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6852
              if (BTCoexDbgLevel == 1U) {
#line 6852
                printk("[BTCoex], HID + PAN(HS)\n");
              } else {

              }
#line 6853
              algorithm = 9U;
            } else {
#line 6855
              if (BTCoexDbgLevel == 1U) {
#line 6855
                printk("[BTCoex], HID + PAN(EDR)\n");
              } else {

              }
#line 6856
              algorithm = 7U;
            }
          } else {
#line 6849
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 6858
          tmp___13 = BTHCI_CheckProfileExist(padapter, 2);
#line 6858
          if ((unsigned int )tmp___13 != 0U) {
#line 6858
            tmp___14 = BTHCI_CheckProfileExist(padapter, 1);
#line 6858
            if ((unsigned int )tmp___14 != 0U) {
#line 6860
              if ((unsigned int )bBtHsModeExist != 0U) {
#line 6861
                if (BTCoexDbgLevel == 1U) {
#line 6861
                  printk("[BTCoex], A2DP + PAN(HS)\n");
                } else {

                }
#line 6862
                algorithm = 3U;
              } else {
#line 6864
                if (BTCoexDbgLevel == 1U) {
#line 6864
                  printk("[BTCoex], A2DP + PAN(EDR)\n");
                } else {

                }
#line 6865
                algorithm = 6U;
              }
            } else {
#line 6858
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 6868
          if (BTCoexDbgLevel == 1U) {
#line 6868
            printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    }
  } else
#line 6872
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 3U) {
#line 6873
    if ((unsigned int )bScoExist != 0U) {
#line 6874
      tmp___23 = BTHCI_CheckProfileExist(padapter, 3);
#line 6874
      if ((unsigned int )tmp___23 != 0U) {
#line 6874
        tmp___24 = BTHCI_CheckProfileExist(padapter, 1);
#line 6874
        if ((unsigned int )tmp___24 != 0U) {
#line 6876
          if (BTCoexDbgLevel == 1U) {
#line 6876
            printk("[BTCoex], Error!!! SCO + HID + A2DP\n");
          } else {

          }
        } else {
#line 6874
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 6877
        tmp___21 = BTHCI_CheckProfileExist(padapter, 3);
#line 6877
        if ((unsigned int )tmp___21 != 0U) {
#line 6877
          tmp___22 = BTHCI_CheckProfileExist(padapter, 2);
#line 6877
          if ((unsigned int )tmp___22 != 0U) {
#line 6879
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6880
              if (BTCoexDbgLevel == 1U) {
#line 6880
                printk("[BTCoex], SCO + HID + PAN(HS)\n");
              } else {

              }
#line 6881
              algorithm = 9U;
            } else {
#line 6883
              if (BTCoexDbgLevel == 1U) {
#line 6883
                printk("[BTCoex], SCO + HID + PAN(EDR)\n");
              } else {

              }
#line 6884
              algorithm = 7U;
            }
          } else {
#line 6877
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 6886
          tmp___19 = BTHCI_CheckProfileExist(padapter, 2);
#line 6886
          if ((unsigned int )tmp___19 != 0U) {
#line 6886
            tmp___20 = BTHCI_CheckProfileExist(padapter, 1);
#line 6886
            if ((unsigned int )tmp___20 != 0U) {
#line 6888
              if ((unsigned int )bBtHsModeExist != 0U) {
#line 6889
                if (BTCoexDbgLevel == 1U) {
#line 6889
                  printk("[BTCoex], Error!!! SCO + A2DP + PAN(HS)\n");
                } else {

                }
#line 6890
                algorithm = 1U;
              } else
#line 6892
              if (BTCoexDbgLevel == 1U) {
#line 6892
                printk("[BTCoex], Error!!! SCO + A2DP + PAN(EDR)\n");
              } else {

              }
            } else {
#line 6886
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 6895
          if (BTCoexDbgLevel == 1U) {
#line 6895
            printk("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",
                   (int )pBtMgnt->ExtConfig.NumberOfHandle);
          } else {

          }
        }
      }
    } else {
#line 6899
      tmp___25 = BTHCI_CheckProfileExist(padapter, 3);
#line 6899
      if ((unsigned int )tmp___25 != 0U) {
#line 6899
        tmp___26 = BTHCI_CheckProfileExist(padapter, 2);
#line 6899
        if ((unsigned int )tmp___26 != 0U) {
#line 6899
          tmp___27 = BTHCI_CheckProfileExist(padapter, 1);
#line 6899
          if ((unsigned int )tmp___27 != 0U) {
#line 6902
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6903
              if (BTCoexDbgLevel == 1U) {
#line 6903
                printk("[BTCoex], HID + A2DP + PAN(HS)\n");
              } else {

              }
#line 6904
              algorithm = 10U;
            } else {
#line 6906
              if (BTCoexDbgLevel == 1U) {
#line 6906
                printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
              } else {

              }
#line 6907
              algorithm = 8U;
            }
          } else {
#line 6899
            goto _L___7;
          }
        } else {
#line 6899
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 6910
      if (BTCoexDbgLevel == 1U) {
#line 6910
        printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
      } else {

      }
    }
  } else
#line 6914
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle > 2U) {
#line 6915
    if ((unsigned int )bScoExist != 0U) {
#line 6916
      tmp___28 = BTHCI_CheckProfileExist(padapter, 3);
#line 6916
      if ((unsigned int )tmp___28 != 0U) {
#line 6916
        tmp___29 = BTHCI_CheckProfileExist(padapter, 2);
#line 6916
        if ((unsigned int )tmp___29 != 0U) {
#line 6916
          tmp___30 = BTHCI_CheckProfileExist(padapter, 1);
#line 6916
          if ((unsigned int )tmp___30 != 0U) {
#line 6919
            if ((unsigned int )bBtHsModeExist != 0U) {
#line 6920
              if (BTCoexDbgLevel == 1U) {
#line 6920
                printk("[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n");
              } else {

              }
            } else
#line 6922
            if (BTCoexDbgLevel == 1U) {
#line 6922
              printk("[BTCoex], Error!!! SCO + HID + A2DP + PAN(EDR)\n");
            } else {

            }
          } else {
#line 6916
            goto _L___9;
          }
        } else {
#line 6916
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 6924
      if (BTCoexDbgLevel == 1U) {
#line 6924
        printk("[BTCoex], Error!!! SCO exists but why NO matched profile for NumberOfHandle =%d\n",
               (int )pBtMgnt->ExtConfig.NumberOfHandle);
      } else {

      }
    } else
#line 6928
    if (BTCoexDbgLevel == 1U) {
#line 6928
      printk("[BTCoex], Error!!! NO matched profile for NumberOfHandle =%d\n", (int )pBtMgnt->ExtConfig.NumberOfHandle);
    } else {

    }
  } else {

  }
#line 6932
  return (algorithm);
}
}
#line 6935 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 btdm_NeedToDecBtPwr(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 6937
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6938
  bRet = 0U;
#line 6940
  tmp___0 = BT_Operation(padapter);
#line 6940
  if ((unsigned int )tmp___0 != 0U) {
#line 6941
    if (pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB > 47) {
#line 6942
      if (BTCoexDbgLevel == 1U) {
#line 6942
        printk("Need to decrease bt power for HS mode!!\n");
      } else {

      }
#line 6943
      bRet = 1U;
    } else
#line 6945
    if (BTCoexDbgLevel == 1U) {
#line 6945
      printk("NO Need to decrease bt power for HS mode!!\n");
    } else {

    }
  } else {
#line 6948
    tmp = BTDM_IsWifiConnectionExist(padapter);
#line 6948
    if ((unsigned int )tmp != 0U) {
#line 6949
      if (BTCoexDbgLevel == 1U) {
#line 6949
        printk("Need to decrease bt power for Wifi is connected!!\n");
      } else {

      }
#line 6950
      bRet = 1U;
    } else {

    }
  }
#line 6953
  return (bRet);
}
}
#line 6957 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_SetCoexTable(struct rtw_adapter *padapter , u32 val0x6c0 , u32 val0x6c8 ,
                              u8 val0x6cc ) 
{ 


  {
#line 6960
  if (BTCoexDbgLevel == 1U) {
#line 6960
    printk("set coex table, set 0x6c0 = 0x%x\n", val0x6c0);
  } else {

  }
#line 6961
  rtl8723au_write32(padapter, 1728U, val0x6c0);
#line 6963
  if (BTCoexDbgLevel == 1U) {
#line 6963
    printk("set coex table, set 0x6c8 = 0x%x\n", val0x6c8);
  } else {

  }
#line 6964
  rtl8723au_write32(padapter, 1736U, val0x6c8);
#line 6966
  if (BTCoexDbgLevel == 1U) {
#line 6966
    printk("set coex table, set 0x6cc = 0x%x\n", (int )val0x6cc);
  } else {

  }
#line 6967
  rtl8723au_write8(padapter, 1740U, (int )val0x6cc);
#line 6968
  return;
}
}
#line 6971 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_SetSwFullTimeDacSwing(struct rtw_adapter *padapter , u8 bSwDacSwingOn ,
                                       u32 swDacSwingLvl ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 6974
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 6976
  if ((unsigned int )bSwDacSwingOn != 0U) {
#line 6977
    if (BTCoexDbgLevel == 1U) {
#line 6977
      printk("[BTCoex], SwDacSwing = 0x%x\n", swDacSwingLvl);
    } else {

    }
#line 6978
    PHY_SetBBReg(padapter, 2176U, 4278190080U, swDacSwingLvl);
#line 6979
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {
#line 6981
    if (BTCoexDbgLevel == 1U) {
#line 6981
      printk("[BTCoex], SwDacSwing Off!\n");
    } else {

    }
#line 6982
    PHY_SetBBReg(padapter, 2176U, 4278190080U, 192U);
  }
#line 6984
  return;
}
}
#line 6987 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_SetFwDacSwingLevel(struct rtw_adapter *padapter , u8 dacSwingLvl ) 
{ 
  u8 H2C_Parameter[1U] ;

  {
#line 6989
  H2C_Parameter[0] = 0U;
#line 6991
  H2C_Parameter[0] = dacSwingLvl;
#line 6993
  if (BTCoexDbgLevel == 1U) {
#line 6993
    printk("[BTCoex], Set Dac Swing Level = 0x%x\n", (int )dacSwingLvl);
  } else {

  }
#line 6994
  if (BTCoexDbgLevel == 1U) {
#line 6994
    printk("[BTCoex], write 0x29 = 0x%x\n", (int )H2C_Parameter[0]);
  } else {

  }
#line 6996
  FillH2CCmd(padapter, 41, 1U, (u8 *)(& H2C_Parameter));
#line 6997
  return;
}
}
#line 6999 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 7001
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7002
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7004
  if (BTCoexDbgLevel == 1U) {
#line 7004
    printk("[BTCoex], Dec BT power = %s\n", (unsigned int )bDecBtPwr != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 7007
  pBtdm8723->bCurDecBtPwr = bDecBtPwr;
#line 7009
  if ((int )pBtdm8723->bPreDecBtPwr == (int )pBtdm8723->bCurDecBtPwr) {
#line 7010
    return;
  } else {

  }
#line 7012
  BTDM_SetFwDecBtPwr(padapter, (int )pBtdm8723->bCurDecBtPwr);
#line 7014
  pBtdm8723->bPreDecBtPwr = pBtdm8723->bCurDecBtPwr;
#line 7015
  return;
}
}
#line 7018 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntFwDacSwingLvl(struct rtw_adapter *padapter , u8 fwDacSwingLvl ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 7020
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7021
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7023
  if (BTCoexDbgLevel == 1U) {
#line 7023
    printk("[BTCoex], set FW Dac Swing level = %d\n", (int )fwDacSwingLvl);
  } else {

  }
#line 7024
  pBtdm8723->curFwDacSwingLvl = fwDacSwingLvl;
#line 7029
  if ((int )pBtdm8723->preFwDacSwingLvl == (int )pBtdm8723->curFwDacSwingLvl) {
#line 7030
    return;
  } else {

  }
#line 7032
  btdm_SetFwDacSwingLevel(padapter, (int )pBtdm8723->curFwDacSwingLvl);
#line 7034
  pBtdm8723->preFwDacSwingLvl = pBtdm8723->curFwDacSwingLvl;
#line 7035
  return;
}
}
#line 7038 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntRfShrink(struct rtw_adapter *padapter , u8 bRxRfShrinkOn ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 7040
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7041
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7043
  if (BTCoexDbgLevel == 1U) {
#line 7043
    printk("[BTCoex], turn Rx RF Shrink = %s\n", (unsigned int )bRxRfShrinkOn != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 7046
  pBtdm8723->bCurRfRxLpfShrink = bRxRfShrinkOn;
#line 7051
  if ((int )pBtdm8723->bPreRfRxLpfShrink == (int )pBtdm8723->bCurRfRxLpfShrink) {
#line 7052
    return;
  } else {

  }
#line 7054
  BTDM_SetSwRfRxLpfCorner(padapter, (int )pBtdm8723->bCurRfRxLpfShrink);
#line 7056
  pBtdm8723->bPreRfRxLpfShrink = pBtdm8723->bCurRfRxLpfShrink;
#line 7057
  return;
}
}
#line 7060 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntLowPenaltyRa(struct rtw_adapter *padapter , u8 bLowPenaltyRa ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 7062
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7063
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7065
  if (BTCoexDbgLevel == 1U) {
#line 7065
    printk("[BTCoex], turn LowPenaltyRA = %s\n", (unsigned int )bLowPenaltyRa != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 7068
  pBtdm8723->bCurLowPenaltyRa = bLowPenaltyRa;
#line 7073
  if ((int )pBtdm8723->bPreLowPenaltyRa == (int )pBtdm8723->bCurLowPenaltyRa) {
#line 7074
    return;
  } else {

  }
#line 7076
  BTDM_SetSwPenaltyTxRateAdaptive(padapter, (int )pBtdm8723->bCurLowPenaltyRa);
#line 7078
  pBtdm8723->bPreLowPenaltyRa = pBtdm8723->bCurLowPenaltyRa;
#line 7079
  return;
}
}
#line 7082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntDacSwing(struct rtw_adapter *padapter , u8 bDacSwingOn , u32 dacSwingLvl ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  unsigned long __ms ;
  unsigned long tmp ;

  {
#line 7085
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7086
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7088
  if (BTCoexDbgLevel == 1U) {
#line 7088
    printk("[BTCoex], turn DacSwing =%s, dacSwingLvl = 0x%x\n", (unsigned int )bDacSwingOn != 0U ? (char *)"ON" : (char *)"OFF",
           dacSwingLvl);
  } else {

  }
#line 7091
  pBtdm8723->bCurDacSwingOn = bDacSwingOn;
#line 7092
  pBtdm8723->curDacSwingLvl = dacSwingLvl;
#line 7094
  if ((int )pBtdm8723->bPreDacSwingOn == (int )pBtdm8723->bCurDacSwingOn && pBtdm8723->preDacSwingLvl == pBtdm8723->curDacSwingLvl) {
#line 7096
    return;
  } else {

  }
#line 7098
  __ms = 30UL;
#line 7098
  goto ldv_56245;
  ldv_56244: 
#line 7098
  __const_udelay(4295000UL);
  ldv_56245: 
#line 7098
  tmp = __ms;
#line 7098
  __ms = __ms - 1UL;
#line 7098
  if (tmp != 0UL) {
#line 7100
    goto ldv_56244;
  } else {

  }
#line 7099
  btdm_SetSwFullTimeDacSwing(padapter, (int )bDacSwingOn, dacSwingLvl);
#line 7101
  pBtdm8723->bPreDacSwingOn = pBtdm8723->bCurDacSwingOn;
#line 7102
  pBtdm8723->preDacSwingLvl = pBtdm8723->curDacSwingLvl;
#line 7103
  return;
}
}
#line 7105 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntAdcBackOff(struct rtw_adapter *padapter , u8 bAdcBackOff ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 7107
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7108
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7110
  if (BTCoexDbgLevel == 1U) {
#line 7110
    printk("[BTCoex], turn AdcBackOff = %s\n", (unsigned int )bAdcBackOff != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 7113
  pBtdm8723->bCurAdcBackOff = bAdcBackOff;
#line 7115
  if ((int )pBtdm8723->bPreAdcBackOff == (int )pBtdm8723->bCurAdcBackOff) {
#line 7116
    return;
  } else {

  }
#line 7118
  BTDM_BBBackOffLevel(padapter, (int )pBtdm8723->bCurAdcBackOff);
#line 7120
  pBtdm8723->bPreAdcBackOff = pBtdm8723->bCurAdcBackOff;
#line 7121
  return;
}
}
#line 7123 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntAgcTable(struct rtw_adapter *padapter , u8 bAgcTableEn ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 7125
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7126
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7128
  if (BTCoexDbgLevel == 1U) {
#line 7128
    printk("[BTCoex], %s Agc Table\n", (unsigned int )bAgcTableEn != 0U ? (char *)"Enable" : (char *)"Disable");
  } else {

  }
#line 7130
  pBtdm8723->bCurAgcTableEn = bAgcTableEn;
#line 7135
  if ((int )pBtdm8723->bPreAgcTableEn == (int )pBtdm8723->bCurAgcTableEn) {
#line 7136
    return;
  } else {

  }
#line 7138
  BTDM_AGCTable(padapter, (int )bAgcTableEn);
#line 7140
  pBtdm8723->bPreAgcTableEn = pBtdm8723->bCurAgcTableEn;
#line 7141
  return;
}
}
#line 7144 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntCoexTable(struct rtw_adapter *padapter , u32 val0x6c0 , u32 val0x6c8 ,
                               u8 val0x6cc ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 7147
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7148
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7150
  if (BTCoexDbgLevel == 1U) {
#line 7150
    printk("[BTCoex], write Coex Table 0x6c0 = 0x%x, 0x6c8 = 0x%x, 0x6cc = 0x%x\n",
           val0x6c0, val0x6c8, (int )val0x6cc);
  } else {

  }
#line 7152
  pBtdm8723->curVal0x6c0 = val0x6c0;
#line 7153
  pBtdm8723->curVal0x6c8 = val0x6c8;
#line 7154
  pBtdm8723->curVal0x6cc = val0x6cc;
#line 7161
  if ((pBtdm8723->preVal0x6c0 == pBtdm8723->curVal0x6c0 && pBtdm8723->preVal0x6c8 == pBtdm8723->curVal0x6c8) && (int )pBtdm8723->preVal0x6cc == (int )pBtdm8723->curVal0x6cc) {
#line 7164
    return;
  } else {

  }
#line 7166
  btdm_SetCoexTable(padapter, val0x6c0, val0x6c8, (int )val0x6cc);
#line 7168
  pBtdm8723->preVal0x6c0 = pBtdm8723->curVal0x6c0;
#line 7169
  pBtdm8723->preVal0x6c8 = pBtdm8723->curVal0x6c8;
#line 7170
  pBtdm8723->preVal0x6cc = pBtdm8723->curVal0x6cc;
#line 7171
  return;
}
}
#line 7173 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntIgnoreWlanAct(struct rtw_adapter *padapter , u8 bEnable ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 7175
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7176
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7178
  if (BTCoexDbgLevel == 1U) {
#line 7178
    printk("[BTCoex], turn Ignore WlanAct %s\n", (unsigned int )bEnable != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 7180
  pBtdm8723->bCurIgnoreWlanAct = bEnable;
#line 7183
  if ((int )pBtdm8723->bPreIgnoreWlanAct == (int )pBtdm8723->bCurIgnoreWlanAct) {
#line 7184
    return;
  } else {

  }
#line 7186
  btdm_SetFwIgnoreWlanAct(padapter, (int )bEnable);
#line 7187
  pBtdm8723->bPreIgnoreWlanAct = pBtdm8723->bCurIgnoreWlanAct;
#line 7188
  return;
}
}
#line 7191 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntSetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 ,
                             u8 byte3 , u8 byte4 , u8 byte5 ) 
{ 
  u8 H2C_Parameter[5U] ;
  unsigned int tmp ;
  struct hal_data_8723a *pHalData ;

  {
#line 7194
  H2C_Parameter[0] = 0U;
#line 7194
  tmp = 1U;
#line 7194
  while (1) {
#line 7194
    if (tmp >= 5U) {
#line 7194
      break;
    } else {

    }
#line 7194
    H2C_Parameter[tmp] = (unsigned char)0;
#line 7194
    tmp = tmp + 1U;
  }
#line 7196
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7200
  if ((unsigned int )byte1 != 0U) {
#line 7201
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 7202
  H2C_Parameter[0] = byte1;
#line 7203
  H2C_Parameter[1] = byte2;
#line 7204
  H2C_Parameter[2] = byte3;
#line 7205
  H2C_Parameter[3] = byte4;
#line 7206
  H2C_Parameter[4] = byte5;
#line 7208
  pHalData->bt_coexist.fw3aVal[0] = byte1;
#line 7209
  pHalData->bt_coexist.fw3aVal[1] = byte2;
#line 7210
  pHalData->bt_coexist.fw3aVal[2] = byte3;
#line 7211
  pHalData->bt_coexist.fw3aVal[3] = byte4;
#line 7212
  pHalData->bt_coexist.fw3aVal[4] = byte5;
#line 7214
  if (BTCoexDbgLevel == 1U) {
#line 7214
    printk("[BTCoex], FW write 0x3a(5bytes) = 0x%x%08x\n", (int )H2C_Parameter[0],
           ((((int )H2C_Parameter[1] << 24) | ((int )H2C_Parameter[2] << 16)) | ((int )H2C_Parameter[3] << 8)) | (int )H2C_Parameter[4]);
  } else {

  }
#line 7218
  FillH2CCmd(padapter, 58, 5U, (u8 *)(& H2C_Parameter));
#line 7219
  return;
}
}
#line 7221 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntPsTdma(struct rtw_adapter *padapter , u8 bTurnOn , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u32 btTxRxCnt ;
  u8 bTurnOnByCnt ;
  u8 psTdmaTypeByCnt ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 7223
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7224
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7225
  btTxRxCnt = 0U;
#line 7226
  bTurnOnByCnt = 0U;
#line 7227
  psTdmaTypeByCnt = 0U;
#line 7229
  tmp = BTDM_BtTxRxCounterH(padapter);
#line 7229
  tmp___0 = BTDM_BtTxRxCounterL(padapter);
#line 7229
  btTxRxCnt = tmp + tmp___0;
#line 7230
  if (BTCoexDbgLevel == 1U) {
#line 7230
    printk("[BTCoex], BT TxRx Counters = %d\n", btTxRxCnt);
  } else {

  }
#line 7231
  if (btTxRxCnt > 3000U) {
#line 7232
    bTurnOnByCnt = 1U;
#line 7233
    psTdmaTypeByCnt = 8U;
#line 7235
    if (BTCoexDbgLevel == 1U) {
#line 7235
      printk("[BTCoex], For BTTxRxCounters, turn %s PS TDMA, type =%d\n", (unsigned int )bTurnOnByCnt != 0U ? (char *)"ON" : (char *)"OFF",
             (int )psTdmaTypeByCnt);
    } else {

    }
#line 7238
    pBtdm8723->bCurPsTdmaOn = bTurnOnByCnt;
#line 7239
    pBtdm8723->curPsTdma = psTdmaTypeByCnt;
  } else {
#line 7241
    if (BTCoexDbgLevel == 1U) {
#line 7241
      printk("[BTCoex], turn %s PS TDMA, type =%d\n", (unsigned int )bTurnOn != 0U ? (char *)"ON" : (char *)"OFF",
             (int )type);
    } else {

    }
#line 7244
    pBtdm8723->bCurPsTdmaOn = bTurnOn;
#line 7245
    pBtdm8723->curPsTdma = type;
  }
#line 7248
  if ((int )pBtdm8723->bPrePsTdmaOn == (int )pBtdm8723->bCurPsTdmaOn && (int )pBtdm8723->prePsTdma == (int )pBtdm8723->curPsTdma) {
#line 7250
    return;
  } else {

  }
#line 7252
  if ((unsigned int )bTurnOn != 0U) {
#line 7253
    switch ((int )type) {
    case 1: ;
    default: 
#line 7256
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 161, 152);
#line 7257
    goto ldv_56295;
    case 2: 
#line 7259
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 161, 152);
#line 7260
    goto ldv_56295;
    case 3: 
#line 7262
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 161, 152);
#line 7263
    goto ldv_56295;
    case 4: 
#line 7265
    btdm_2AntSetFw3a(padapter, 163, 5, 5, 161, 128);
#line 7266
    goto ldv_56295;
    case 5: 
#line 7268
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 32, 152);
#line 7269
    goto ldv_56295;
    case 6: 
#line 7271
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 32, 152);
#line 7272
    goto ldv_56295;
    case 7: 
#line 7274
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 32, 152);
#line 7275
    goto ldv_56295;
    case 8: 
#line 7277
    btdm_2AntSetFw3a(padapter, 163, 5, 5, 32, 128);
#line 7278
    goto ldv_56295;
    case 9: 
#line 7280
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 161, 152);
#line 7281
    goto ldv_56295;
    case 10: 
#line 7283
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 161, 152);
#line 7284
    goto ldv_56295;
    case 11: 
#line 7286
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 161, 152);
#line 7287
    goto ldv_56295;
    case 12: 
#line 7289
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 161, 152);
#line 7290
    goto ldv_56295;
    case 13: 
#line 7292
    btdm_2AntSetFw3a(padapter, 227, 26, 26, 32, 152);
#line 7293
    goto ldv_56295;
    case 14: 
#line 7295
    btdm_2AntSetFw3a(padapter, 227, 18, 18, 32, 152);
#line 7296
    goto ldv_56295;
    case 15: 
#line 7298
    btdm_2AntSetFw3a(padapter, 227, 10, 10, 32, 152);
#line 7299
    goto ldv_56295;
    case 16: 
#line 7301
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 32, 152);
#line 7302
    goto ldv_56295;
    case 17: 
#line 7304
    btdm_2AntSetFw3a(padapter, 163, 47, 47, 32, 128);
#line 7305
    goto ldv_56295;
    case 18: 
#line 7307
    btdm_2AntSetFw3a(padapter, 227, 5, 5, 161, 152);
#line 7308
    goto ldv_56295;
    case 19: 
#line 7310
    btdm_2AntSetFw3a(padapter, 227, 37, 37, 161, 152);
#line 7311
    goto ldv_56295;
    case 20: 
#line 7313
    btdm_2AntSetFw3a(padapter, 227, 37, 37, 32, 152);
#line 7314
    goto ldv_56295;
    }
    ldv_56295: ;
  } else {
#line 7318
    switch ((int )type) {
    case 0: 
#line 7320
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 8, 0);
#line 7321
    goto ldv_56316;
    case 1: 
#line 7323
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 0, 0);
#line 7324
    goto ldv_56316;
    default: 
#line 7326
    btdm_2AntSetFw3a(padapter, 0, 0, 0, 8, 0);
#line 7327
    goto ldv_56316;
    }
    ldv_56316: ;
  }
#line 7332
  pBtdm8723->bPrePsTdmaOn = pBtdm8723->bCurPsTdmaOn;
#line 7333
  pBtdm8723->prePsTdma = pBtdm8723->curPsTdma;
#line 7334
  return;
}
}
#line 7336 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntBtInquiryPage(struct rtw_adapter *padapter ) 
{ 


  {
#line 7338
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7339
  btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7340
  btdm_2AntPsTdma(padapter, 1, 8);
#line 7341
  return;
}
}
#line 7343 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 btdm_HoldForBtInqPage(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 curTime ;

  {
#line 7345
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7346
  curTime = (u32 )jiffies;
#line 7348
  if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage != 0U) {
#line 7350
    if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime == 0UL) {
#line 7351
      pHalData->bt_coexist.halCoex8723.btInqPageStartTime = (unsigned long )curTime;
#line 7352
      if (BTCoexDbgLevel == 1U) {
#line 7352
        printk("[BTCoex], BT Inquiry/page is started at time : 0x%lx \n", pHalData->bt_coexist.halCoex8723.btInqPageStartTime);
      } else {

      }
    } else {

    }
  } else {

  }
#line 7356
  if (BTCoexDbgLevel == 1U) {
#line 7356
    printk("[BTCoex], BT Inquiry/page started time : 0x%lx, curTime : 0x%x \n", pHalData->bt_coexist.halCoex8723.btInqPageStartTime,
           curTime);
  } else {

  }
#line 7359
  if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime != 0UL) {
#line 7360
    if ((unsigned long )curTime - pHalData->bt_coexist.halCoex8723.btInqPageStartTime > 9999999UL) {
#line 7361
      if (BTCoexDbgLevel == 1U) {
#line 7361
        printk("[BTCoex], BT Inquiry/page >= 10sec!!!");
      } else {

      }
#line 7362
      pHalData->bt_coexist.halCoex8723.btInqPageStartTime = 0UL;
    } else {

    }
  } else {

  }
#line 7366
  if (pHalData->bt_coexist.halCoex8723.btInqPageStartTime != 0UL) {
#line 7367
    btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7368
    btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7369
    btdm_2AntPsTdma(padapter, 1, 8);
#line 7370
    return (1U);
  } else {
#line 7372
    return (0U);
  }
}
}
#line 7376 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 btdm_Is2Ant8723ACommonAction(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 bCommon ;
  bool tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  u8 tmp___4 ;
  bool tmp___5 ;
  u8 tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  u8 tmp___9 ;
  bool tmp___10 ;
  u8 tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;

  {
#line 7378
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7379
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7380
  bCommon = 0U;
#line 7382
  if (BTCoexDbgLevel == 1U) {
#line 7382
    tmp = check_fwstate(& padapter->mlmepriv, 2176);
#line 7382
    tmp___0 = BTDM_IsWifiConnectionExist(padapter);
#line 7382
    printk("%s :BTDM_IsWifiConnectionExist =%x check_fwstate =%x pmlmepriv->fw_state = 0x%x\n",
           "btdm_Is2Ant8723ACommonAction", (int )tmp___0, (int )tmp, padapter->mlmepriv.fw_state);
  } else {

  }
#line 7384
  tmp___11 = BTDM_IsWifiConnectionExist(padapter);
#line 7384
  if ((unsigned int )tmp___11 == 0U) {
#line 7384
    tmp___12 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7384
    if (tmp___12) {
#line 7384
      tmp___13 = 0;
    } else {
#line 7384
      tmp___13 = 1;
    }
#line 7384
    if (tmp___13) {
#line 7384
      if ((unsigned int )pBtdm8723->btStatus == 0U) {
#line 7387
        if (BTCoexDbgLevel == 1U) {
#line 7387
          printk("Wifi idle + Bt idle!!\n");
        } else {

        }
#line 7389
        btdm_2AntLowPenaltyRa(padapter, 0);
#line 7390
        btdm_2AntRfShrink(padapter, 0);
#line 7391
        btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7393
        btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7394
        btdm_2AntPsTdma(padapter, 0, 0);
#line 7395
        btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7396
        btdm_2AntDecBtPwr(padapter, 0);
#line 7398
        btdm_2AntAgcTable(padapter, 0);
#line 7399
        btdm_2AntAdcBackOff(padapter, 0);
#line 7400
        btdm_2AntDacSwing(padapter, 0, 192U);
#line 7402
        bCommon = 1U;
      } else {
#line 7384
        goto _L___8;
      }
    } else {
#line 7384
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
#line 7403
    tmp___9 = BTDM_IsWifiConnectionExist(padapter);
#line 7403
    if ((unsigned int )tmp___9 != 0U) {
#line 7403
      goto _L___6;
    } else {
#line 7403
      tmp___10 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7403
      if ((int )tmp___10) {
        _L___6: /* CIL Label */ 
#line 7403
        if ((unsigned int )pBtdm8723->btStatus == 0U) {
#line 7406
          if (BTCoexDbgLevel == 1U) {
#line 7406
            printk("Wifi non-idle + BT idle!!\n");
          } else {

          }
#line 7408
          btdm_2AntLowPenaltyRa(padapter, 1);
#line 7409
          btdm_2AntRfShrink(padapter, 0);
#line 7410
          btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7412
          btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7413
          btdm_2AntPsTdma(padapter, 0, 0);
#line 7414
          btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7415
          btdm_2AntDecBtPwr(padapter, 1);
#line 7417
          btdm_2AntAgcTable(padapter, 0);
#line 7418
          btdm_2AntAdcBackOff(padapter, 0);
#line 7419
          btdm_2AntDacSwing(padapter, 0, 192U);
#line 7421
          bCommon = 1U;
        } else {
#line 7403
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 7422
        tmp___6 = BTDM_IsWifiConnectionExist(padapter);
#line 7422
        if ((unsigned int )tmp___6 == 0U) {
#line 7422
          tmp___7 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7422
          if (tmp___7) {
#line 7422
            tmp___8 = 0;
          } else {
#line 7422
            tmp___8 = 1;
          }
#line 7422
          if (tmp___8) {
#line 7422
            if ((unsigned int )pBtdm8723->btStatus == 1U) {
#line 7425
              if (BTCoexDbgLevel == 1U) {
#line 7425
                printk("Wifi idle + Bt connected idle!!\n");
              } else {

              }
#line 7427
              btdm_2AntLowPenaltyRa(padapter, 1);
#line 7428
              btdm_2AntRfShrink(padapter, 1);
#line 7429
              btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7431
              btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7432
              btdm_2AntPsTdma(padapter, 0, 0);
#line 7433
              btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7434
              btdm_2AntDecBtPwr(padapter, 0);
#line 7436
              btdm_2AntAgcTable(padapter, 0);
#line 7437
              btdm_2AntAdcBackOff(padapter, 0);
#line 7438
              btdm_2AntDacSwing(padapter, 0, 192U);
#line 7440
              bCommon = 1U;
            } else {
#line 7422
              goto _L___4;
            }
          } else {
#line 7422
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 7441
          tmp___4 = BTDM_IsWifiConnectionExist(padapter);
#line 7441
          if ((unsigned int )tmp___4 != 0U) {
#line 7441
            goto _L___2;
          } else {
#line 7441
            tmp___5 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7441
            if ((int )tmp___5) {
              _L___2: /* CIL Label */ 
#line 7441
              if ((unsigned int )pBtdm8723->btStatus == 1U) {
#line 7444
                if (BTCoexDbgLevel == 1U) {
#line 7444
                  printk("Wifi non-idle + Bt connected idle!!\n");
                } else {

                }
#line 7446
                btdm_2AntLowPenaltyRa(padapter, 1);
#line 7447
                btdm_2AntRfShrink(padapter, 1);
#line 7448
                btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7450
                btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7451
                btdm_2AntPsTdma(padapter, 0, 0);
#line 7452
                btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7453
                btdm_2AntDecBtPwr(padapter, 1);
#line 7455
                btdm_2AntAgcTable(padapter, 0);
#line 7456
                btdm_2AntAdcBackOff(padapter, 0);
#line 7457
                btdm_2AntDacSwing(padapter, 0, 192U);
#line 7459
                bCommon = 1U;
              } else {
#line 7441
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
#line 7460
              tmp___1 = BTDM_IsWifiConnectionExist(padapter);
#line 7460
              if ((unsigned int )tmp___1 == 0U) {
#line 7460
                tmp___2 = check_fwstate(& padapter->mlmepriv, 2176);
#line 7460
                if (tmp___2) {
#line 7460
                  tmp___3 = 0;
                } else {
#line 7460
                  tmp___3 = 1;
                }
#line 7460
                if (tmp___3) {
#line 7460
                  if ((unsigned int )pBtdm8723->btStatus == 2U) {
#line 7463
                    if (BTCoexDbgLevel == 1U) {
#line 7463
                      printk("Wifi idle + BT non-idle!!\n");
                    } else {

                    }
#line 7465
                    btdm_2AntLowPenaltyRa(padapter, 1);
#line 7466
                    btdm_2AntRfShrink(padapter, 1);
#line 7467
                    btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7469
                    btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7470
                    btdm_2AntPsTdma(padapter, 0, 0);
#line 7471
                    btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7472
                    btdm_2AntDecBtPwr(padapter, 0);
#line 7474
                    btdm_2AntAgcTable(padapter, 0);
#line 7475
                    btdm_2AntAdcBackOff(padapter, 0);
#line 7476
                    btdm_2AntDacSwing(padapter, 0, 192U);
#line 7478
                    bCommon = 1U;
                  } else {
#line 7460
                    goto _L___0;
                  }
                } else {
#line 7460
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
#line 7480
                if (BTCoexDbgLevel == 1U) {
#line 7480
                  printk("Wifi non-idle + BT non-idle!!\n");
                } else {

                }
#line 7481
                btdm_2AntLowPenaltyRa(padapter, 1);
#line 7482
                btdm_2AntRfShrink(padapter, 1);
#line 7483
                btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 7484
                btdm_2AntIgnoreWlanAct(padapter, 0);
#line 7485
                btdm_2AntFwDacSwingLvl(padapter, 32);
#line 7487
                bCommon = 0U;
              }
            }
          }
        }
      }
    }
  }
#line 7489
  return (bCommon);
}
}
#line 7493 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2AntTdmaDurationAdjust(struct rtw_adapter *padapter , u8 bScoHid ,
                                        u8 bTxPause , u8 maxInterval ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  s32 up___0 ;
  s32 dn ;
  s32 m ;
  s32 n ;
  s32 WaitCount ;
  s32 result ;
  u8 retryCount ;
  bool tmp ;
  int tmp___0 ;

  {
#line 7496
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 7497
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 7500
  retryCount = 0U;
#line 7502
  if (BTCoexDbgLevel == 1U) {
#line 7502
    printk("[BTCoex], TdmaDurationAdjust()\n");
  } else {

  }
#line 7504
  if ((unsigned int )pBtdm8723->bResetTdmaAdjust != 0U) {
#line 7505
    pBtdm8723->bResetTdmaAdjust = 0U;
#line 7506
    if (BTCoexDbgLevel == 1U) {
#line 7506
      printk("[BTCoex], first run TdmaDurationAdjust()!!\n");
    } else {

    }
#line 7507
    if ((unsigned int )bScoHid != 0U) {
#line 7508
      if ((unsigned int )bTxPause != 0U) {
#line 7509
        if ((unsigned int )maxInterval == 1U) {
#line 7510
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7511
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7512
        if ((unsigned int )maxInterval == 2U) {
#line 7513
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7514
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7515
        if ((unsigned int )maxInterval == 3U) {
#line 7516
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7517
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else {
#line 7519
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7520
          pBtdm8723->psTdmaDuAdjType = 15U;
        }
      } else
#line 7523
      if ((unsigned int )maxInterval == 1U) {
#line 7524
        btdm_2AntPsTdma(padapter, 1, 11);
#line 7525
        pBtdm8723->psTdmaDuAdjType = 11U;
      } else
#line 7526
      if ((unsigned int )maxInterval == 2U) {
#line 7527
        btdm_2AntPsTdma(padapter, 1, 11);
#line 7528
        pBtdm8723->psTdmaDuAdjType = 11U;
      } else
#line 7529
      if ((unsigned int )maxInterval == 3U) {
#line 7530
        btdm_2AntPsTdma(padapter, 1, 11);
#line 7531
        pBtdm8723->psTdmaDuAdjType = 11U;
      } else {
#line 7533
        btdm_2AntPsTdma(padapter, 1, 11);
#line 7534
        pBtdm8723->psTdmaDuAdjType = 11U;
      }
    } else
#line 7538
    if ((unsigned int )bTxPause != 0U) {
#line 7539
      if ((unsigned int )maxInterval == 1U) {
#line 7540
        btdm_2AntPsTdma(padapter, 1, 7);
#line 7541
        pBtdm8723->psTdmaDuAdjType = 7U;
      } else
#line 7542
      if ((unsigned int )maxInterval == 2U) {
#line 7543
        btdm_2AntPsTdma(padapter, 1, 7);
#line 7544
        pBtdm8723->psTdmaDuAdjType = 7U;
      } else
#line 7545
      if ((unsigned int )maxInterval == 3U) {
#line 7546
        btdm_2AntPsTdma(padapter, 1, 7);
#line 7547
        pBtdm8723->psTdmaDuAdjType = 7U;
      } else {
#line 7549
        btdm_2AntPsTdma(padapter, 1, 7);
#line 7550
        pBtdm8723->psTdmaDuAdjType = 7U;
      }
    } else
#line 7553
    if ((unsigned int )maxInterval == 1U) {
#line 7554
      btdm_2AntPsTdma(padapter, 1, 3);
#line 7555
      pBtdm8723->psTdmaDuAdjType = 3U;
    } else
#line 7556
    if ((unsigned int )maxInterval == 2U) {
#line 7557
      btdm_2AntPsTdma(padapter, 1, 3);
#line 7558
      pBtdm8723->psTdmaDuAdjType = 3U;
    } else
#line 7559
    if ((unsigned int )maxInterval == 3U) {
#line 7560
      btdm_2AntPsTdma(padapter, 1, 3);
#line 7561
      pBtdm8723->psTdmaDuAdjType = 3U;
    } else {
#line 7563
      btdm_2AntPsTdma(padapter, 1, 3);
#line 7564
      pBtdm8723->psTdmaDuAdjType = 3U;
    }
#line 7568
    up___0 = 0;
#line 7569
    dn = 0;
#line 7570
    m = 1;
#line 7571
    n = 3;
#line 7572
    result = 0;
#line 7573
    WaitCount = 0;
  } else {
#line 7576
    retryCount = pHalData->bt_coexist.halCoex8723.btRetryCnt;
#line 7577
    if (BTCoexDbgLevel == 1U) {
#line 7577
      printk("[BTCoex], retryCount = %d\n", (int )retryCount);
    } else {

    }
#line 7578
    result = 0;
#line 7579
    WaitCount = WaitCount + 1;
#line 7581
    if ((unsigned int )retryCount == 0U) {
#line 7582
      up___0 = up___0 + 1;
#line 7583
      dn = dn - 1;
#line 7585
      if (dn <= 0) {
#line 7586
        dn = 0;
      } else {

      }
#line 7588
      if (up___0 >= n) {
#line 7589
        WaitCount = 0;
#line 7590
        n = 3;
#line 7591
        up___0 = 0;
#line 7592
        dn = 0;
#line 7593
        result = 1;
#line 7594
        if (BTCoexDbgLevel == 1U) {
#line 7594
          printk("[BTCoex], Increase wifi duration!!\n");
        } else {

        }
      } else {

      }
    } else
#line 7596
    if ((unsigned int )retryCount <= 3U) {
#line 7597
      up___0 = up___0 - 1;
#line 7598
      dn = dn + 1;
#line 7600
      if (up___0 <= 0) {
#line 7601
        up___0 = 0;
      } else {

      }
#line 7603
      if (dn == 2) {
#line 7604
        if (WaitCount <= 2) {
#line 7605
          m = m + 1;
        } else {
#line 7607
          m = 1;
        }
#line 7609
        if (m > 19) {
#line 7610
          m = 20;
        } else {

        }
#line 7612
        n = m * 3;
#line 7613
        up___0 = 0;
#line 7614
        dn = 0;
#line 7615
        WaitCount = 0;
#line 7616
        result = -1;
#line 7617
        if (BTCoexDbgLevel == 1U) {
#line 7617
          printk("[BTCoex], Decrease wifi duration for retryCounter<3!!\n");
        } else {

        }
      } else {

      }
    } else {
#line 7620
      if (WaitCount == 1) {
#line 7621
        m = m + 1;
      } else {
#line 7623
        m = 1;
      }
#line 7625
      if (m > 19) {
#line 7626
        m = 20;
      } else {

      }
#line 7627
      n = m * 3;
#line 7628
      up___0 = 0;
#line 7629
      dn = 0;
#line 7630
      WaitCount = 0;
#line 7631
      result = -1;
#line 7632
      if (BTCoexDbgLevel == 1U) {
#line 7632
        printk("[BTCoex], Decrease wifi duration for retryCounter>3!!\n");
      } else {

      }
    }
#line 7635
    if (BTCoexDbgLevel == 1U) {
#line 7635
      printk("[BTCoex], max Interval = %d\n", (int )maxInterval);
    } else {

    }
#line 7636
    if ((unsigned int )maxInterval == 1U) {
#line 7637
      if ((unsigned int )bTxPause != 0U) {
#line 7638
        if (BTCoexDbgLevel == 1U) {
#line 7638
          printk("[BTCoex], TxPause = 1\n");
        } else {

        }
#line 7639
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7640
          btdm_2AntPsTdma(padapter, 1, 5);
#line 7641
          pBtdm8723->psTdmaDuAdjType = 5U;
        } else
#line 7642
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7643
          btdm_2AntPsTdma(padapter, 1, 6);
#line 7644
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
#line 7645
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7646
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7647
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7648
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7649
          btdm_2AntPsTdma(padapter, 1, 8);
#line 7650
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {

        }
#line 7652
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7653
          btdm_2AntPsTdma(padapter, 1, 13);
#line 7654
          pBtdm8723->psTdmaDuAdjType = 13U;
        } else
#line 7655
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7656
          btdm_2AntPsTdma(padapter, 1, 14);
#line 7657
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
#line 7658
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7659
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7660
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7661
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7662
          btdm_2AntPsTdma(padapter, 1, 16);
#line 7663
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {

        }
#line 7666
        if (result == -1) {
#line 7667
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7668
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7669
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7670
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7671
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7672
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7673
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7674
            btdm_2AntPsTdma(padapter, 1, 8);
#line 7675
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
#line 7676
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7677
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7678
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
#line 7679
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7680
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7681
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7682
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7683
            btdm_2AntPsTdma(padapter, 1, 16);
#line 7684
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {

          }
        } else
#line 7686
        if (result == 1) {
#line 7687
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7688
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7689
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7690
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7691
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7692
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7693
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7694
            btdm_2AntPsTdma(padapter, 1, 5);
#line 7695
            pBtdm8723->psTdmaDuAdjType = 5U;
          } else
#line 7696
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7697
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7698
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7699
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7700
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7701
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
#line 7702
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7703
            btdm_2AntPsTdma(padapter, 1, 13);
#line 7704
            pBtdm8723->psTdmaDuAdjType = 13U;
          } else {

          }
        } else {

        }
      } else {
#line 7708
        if (BTCoexDbgLevel == 1U) {
#line 7708
          printk("[BTCoex], TxPause = 0\n");
        } else {

        }
#line 7709
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7710
          btdm_2AntPsTdma(padapter, 1, 1);
#line 7711
          pBtdm8723->psTdmaDuAdjType = 1U;
        } else
#line 7712
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7713
          btdm_2AntPsTdma(padapter, 1, 2);
#line 7714
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
#line 7715
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7716
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7717
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7718
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7719
          btdm_2AntPsTdma(padapter, 1, 4);
#line 7720
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {

        }
#line 7722
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7723
          btdm_2AntPsTdma(padapter, 1, 9);
#line 7724
          pBtdm8723->psTdmaDuAdjType = 9U;
        } else
#line 7725
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7726
          btdm_2AntPsTdma(padapter, 1, 10);
#line 7727
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
#line 7728
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7729
          btdm_2AntPsTdma(padapter, 1, 11);
#line 7730
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 7731
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7732
          btdm_2AntPsTdma(padapter, 1, 12);
#line 7733
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {

        }
#line 7736
        if (result == -1) {
#line 7737
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7738
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7739
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7740
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7741
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7742
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7743
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7744
            btdm_2AntPsTdma(padapter, 1, 4);
#line 7745
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
#line 7746
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7747
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7748
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
#line 7749
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7750
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7751
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7752
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7753
            btdm_2AntPsTdma(padapter, 1, 12);
#line 7754
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {

          }
        } else
#line 7756
        if (result == 1) {
#line 7757
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7758
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7759
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7760
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7761
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7762
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7763
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7764
            btdm_2AntPsTdma(padapter, 1, 1);
#line 7765
            pBtdm8723->psTdmaDuAdjType = 1U;
          } else
#line 7766
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7767
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7768
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7769
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7770
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7771
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
#line 7772
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7773
            btdm_2AntPsTdma(padapter, 1, 9);
#line 7774
            pBtdm8723->psTdmaDuAdjType = 9U;
          } else {

          }
        } else {

        }
      }
    } else
#line 7778
    if ((unsigned int )maxInterval == 2U) {
#line 7779
      if ((unsigned int )bTxPause != 0U) {
#line 7780
        if (BTCoexDbgLevel == 1U) {
#line 7780
          printk("[BTCoex], TxPause = 1\n");
        } else {

        }
#line 7781
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7782
          btdm_2AntPsTdma(padapter, 1, 6);
#line 7783
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
#line 7784
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7785
          btdm_2AntPsTdma(padapter, 1, 6);
#line 7786
          pBtdm8723->psTdmaDuAdjType = 6U;
        } else
#line 7787
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7788
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7789
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7790
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7791
          btdm_2AntPsTdma(padapter, 1, 8);
#line 7792
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {

        }
#line 7794
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7795
          btdm_2AntPsTdma(padapter, 1, 14);
#line 7796
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
#line 7797
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7798
          btdm_2AntPsTdma(padapter, 1, 14);
#line 7799
          pBtdm8723->psTdmaDuAdjType = 14U;
        } else
#line 7800
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7801
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7802
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7803
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7804
          btdm_2AntPsTdma(padapter, 1, 16);
#line 7805
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {

        }
#line 7807
        if (result == -1) {
#line 7808
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7809
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7810
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7811
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7812
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7813
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7814
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7815
            btdm_2AntPsTdma(padapter, 1, 8);
#line 7816
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
#line 7817
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7818
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7819
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
#line 7820
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7821
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7822
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7823
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7824
            btdm_2AntPsTdma(padapter, 1, 16);
#line 7825
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {

          }
        } else
#line 7827
        if (result == 1) {
#line 7828
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7829
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7830
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7831
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7832
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7833
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7834
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7835
            btdm_2AntPsTdma(padapter, 1, 6);
#line 7836
            pBtdm8723->psTdmaDuAdjType = 6U;
          } else
#line 7837
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7838
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7839
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7840
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7841
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7842
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else
#line 7843
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7844
            btdm_2AntPsTdma(padapter, 1, 14);
#line 7845
            pBtdm8723->psTdmaDuAdjType = 14U;
          } else {

          }
        } else {

        }
      } else {
#line 7849
        if (BTCoexDbgLevel == 1U) {
#line 7849
          printk("[BTCoex], TxPause = 0\n");
        } else {

        }
#line 7850
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7851
          btdm_2AntPsTdma(padapter, 1, 2);
#line 7852
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
#line 7853
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7854
          btdm_2AntPsTdma(padapter, 1, 2);
#line 7855
          pBtdm8723->psTdmaDuAdjType = 2U;
        } else
#line 7856
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7857
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7858
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7859
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7860
          btdm_2AntPsTdma(padapter, 1, 4);
#line 7861
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {

        }
#line 7863
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7864
          btdm_2AntPsTdma(padapter, 1, 10);
#line 7865
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
#line 7866
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7867
          btdm_2AntPsTdma(padapter, 1, 10);
#line 7868
          pBtdm8723->psTdmaDuAdjType = 10U;
        } else
#line 7869
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7870
          btdm_2AntPsTdma(padapter, 1, 11);
#line 7871
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 7872
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7873
          btdm_2AntPsTdma(padapter, 1, 12);
#line 7874
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {

        }
#line 7876
        if (result == -1) {
#line 7877
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7878
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7879
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7880
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7881
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7882
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7883
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7884
            btdm_2AntPsTdma(padapter, 1, 4);
#line 7885
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
#line 7886
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7887
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7888
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
#line 7889
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7890
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7891
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7892
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7893
            btdm_2AntPsTdma(padapter, 1, 12);
#line 7894
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {

          }
        } else
#line 7896
        if (result == 1) {
#line 7897
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7898
            btdm_2AntPsTdma(padapter, 1, 3);
#line 7899
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 7900
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7901
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7902
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7903
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7904
            btdm_2AntPsTdma(padapter, 1, 2);
#line 7905
            pBtdm8723->psTdmaDuAdjType = 2U;
          } else
#line 7906
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7907
            btdm_2AntPsTdma(padapter, 1, 11);
#line 7908
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 7909
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7910
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7911
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else
#line 7912
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7913
            btdm_2AntPsTdma(padapter, 1, 10);
#line 7914
            pBtdm8723->psTdmaDuAdjType = 10U;
          } else {

          }
        } else {

        }
      }
    } else
#line 7918
    if ((unsigned int )maxInterval == 3U) {
#line 7919
      if ((unsigned int )bTxPause != 0U) {
#line 7920
        if (BTCoexDbgLevel == 1U) {
#line 7920
          printk("[BTCoex], TxPause = 1\n");
        } else {

        }
#line 7921
        if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 7922
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7923
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7924
        if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 7925
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7926
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7927
        if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 7928
          btdm_2AntPsTdma(padapter, 1, 7);
#line 7929
          pBtdm8723->psTdmaDuAdjType = 7U;
        } else
#line 7930
        if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 7931
          btdm_2AntPsTdma(padapter, 1, 8);
#line 7932
          pBtdm8723->psTdmaDuAdjType = 8U;
        } else {

        }
#line 7934
        if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 7935
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7936
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7937
        if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 7938
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7939
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7940
        if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 7941
          btdm_2AntPsTdma(padapter, 1, 15);
#line 7942
          pBtdm8723->psTdmaDuAdjType = 15U;
        } else
#line 7943
        if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 7944
          btdm_2AntPsTdma(padapter, 1, 16);
#line 7945
          pBtdm8723->psTdmaDuAdjType = 16U;
        } else {

        }
#line 7947
        if (result == -1) {
#line 7948
          if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7949
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7950
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7951
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7952
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7953
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7954
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7955
            btdm_2AntPsTdma(padapter, 1, 8);
#line 7956
            pBtdm8723->psTdmaDuAdjType = 8U;
          } else
#line 7957
          if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 7958
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7959
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7960
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7961
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7962
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7963
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7964
            btdm_2AntPsTdma(padapter, 1, 16);
#line 7965
            pBtdm8723->psTdmaDuAdjType = 16U;
          } else {

          }
        } else
#line 7967
        if (result == 1) {
#line 7968
          if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 7969
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7970
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7971
          if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7972
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7973
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7974
          if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7975
            btdm_2AntPsTdma(padapter, 1, 7);
#line 7976
            pBtdm8723->psTdmaDuAdjType = 7U;
          } else
#line 7977
          if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 7978
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7979
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7980
          if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 7981
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7982
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else
#line 7983
          if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 7984
            btdm_2AntPsTdma(padapter, 1, 15);
#line 7985
            pBtdm8723->psTdmaDuAdjType = 15U;
          } else {

          }
        } else {

        }
      } else {
#line 7989
        if (BTCoexDbgLevel == 1U) {
#line 7989
          printk("[BTCoex], TxPause = 0\n");
        } else {

        }
#line 7990
        if ((unsigned int )pBtdm8723->curPsTdma == 5U) {
#line 7991
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7992
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7993
        if ((unsigned int )pBtdm8723->curPsTdma == 6U) {
#line 7994
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7995
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7996
        if ((unsigned int )pBtdm8723->curPsTdma == 7U) {
#line 7997
          btdm_2AntPsTdma(padapter, 1, 3);
#line 7998
          pBtdm8723->psTdmaDuAdjType = 3U;
        } else
#line 7999
        if ((unsigned int )pBtdm8723->curPsTdma == 8U) {
#line 8000
          btdm_2AntPsTdma(padapter, 1, 4);
#line 8001
          pBtdm8723->psTdmaDuAdjType = 4U;
        } else {

        }
#line 8003
        if ((unsigned int )pBtdm8723->curPsTdma == 13U) {
#line 8004
          btdm_2AntPsTdma(padapter, 1, 11);
#line 8005
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 8006
        if ((unsigned int )pBtdm8723->curPsTdma == 14U) {
#line 8007
          btdm_2AntPsTdma(padapter, 1, 11);
#line 8008
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 8009
        if ((unsigned int )pBtdm8723->curPsTdma == 15U) {
#line 8010
          btdm_2AntPsTdma(padapter, 1, 11);
#line 8011
          pBtdm8723->psTdmaDuAdjType = 11U;
        } else
#line 8012
        if ((unsigned int )pBtdm8723->curPsTdma == 16U) {
#line 8013
          btdm_2AntPsTdma(padapter, 1, 12);
#line 8014
          pBtdm8723->psTdmaDuAdjType = 12U;
        } else {

        }
#line 8016
        if (result == -1) {
#line 8017
          if ((unsigned int )pBtdm8723->curPsTdma == 1U) {
#line 8018
            btdm_2AntPsTdma(padapter, 1, 3);
#line 8019
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 8020
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 8021
            btdm_2AntPsTdma(padapter, 1, 3);
#line 8022
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 8023
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 8024
            btdm_2AntPsTdma(padapter, 1, 4);
#line 8025
            pBtdm8723->psTdmaDuAdjType = 4U;
          } else
#line 8026
          if ((unsigned int )pBtdm8723->curPsTdma == 9U) {
#line 8027
            btdm_2AntPsTdma(padapter, 1, 11);
#line 8028
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 8029
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 8030
            btdm_2AntPsTdma(padapter, 1, 11);
#line 8031
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 8032
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 8033
            btdm_2AntPsTdma(padapter, 1, 12);
#line 8034
            pBtdm8723->psTdmaDuAdjType = 12U;
          } else {

          }
        } else
#line 8036
        if (result == 1) {
#line 8037
          if ((unsigned int )pBtdm8723->curPsTdma == 4U) {
#line 8038
            btdm_2AntPsTdma(padapter, 1, 3);
#line 8039
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 8040
          if ((unsigned int )pBtdm8723->curPsTdma == 3U) {
#line 8041
            btdm_2AntPsTdma(padapter, 1, 3);
#line 8042
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 8043
          if ((unsigned int )pBtdm8723->curPsTdma == 2U) {
#line 8044
            btdm_2AntPsTdma(padapter, 1, 3);
#line 8045
            pBtdm8723->psTdmaDuAdjType = 3U;
          } else
#line 8046
          if ((unsigned int )pBtdm8723->curPsTdma == 12U) {
#line 8047
            btdm_2AntPsTdma(padapter, 1, 11);
#line 8048
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 8049
          if ((unsigned int )pBtdm8723->curPsTdma == 11U) {
#line 8050
            btdm_2AntPsTdma(padapter, 1, 11);
#line 8051
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else
#line 8052
          if ((unsigned int )pBtdm8723->curPsTdma == 10U) {
#line 8053
            btdm_2AntPsTdma(padapter, 1, 11);
#line 8054
            pBtdm8723->psTdmaDuAdjType = 11U;
          } else {

          }
        } else {

        }
      }
    } else {

    }
  }
#line 8060
  if (BTCoexDbgLevel == 1U) {
#line 8060
    printk("[BTCoex], PsTdma type : recordPsTdma =%d\n", (int )pBtdm8723->psTdmaDuAdjType);
  } else {

  }
#line 8063
  if ((int )pBtdm8723->curPsTdma != (int )pBtdm8723->psTdmaDuAdjType) {
#line 8064
    if (BTCoexDbgLevel == 1U) {
#line 8064
      printk("[BTCoex], PsTdma type dismatch!!!, curPsTdma =%d, recordPsTdma =%d\n",
             (int )pBtdm8723->curPsTdma, (int )pBtdm8723->psTdmaDuAdjType);
    } else {

    }
#line 8067
    tmp = check_fwstate(& padapter->mlmepriv, 2176);
#line 8067
    if (tmp) {
#line 8067
      tmp___0 = 0;
    } else {
#line 8067
      tmp___0 = 1;
    }
#line 8067
    if (tmp___0) {
#line 8068
      btdm_2AntPsTdma(padapter, 1, (int )pBtdm8723->psTdmaDuAdjType);
    } else
#line 8070
    if (BTCoexDbgLevel == 1U) {
#line 8070
      printk("[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n");
    } else {

    }
  } else {

  }
#line 8072
  return;
}
}
#line 8076 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723ASCOAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8080
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8080
  if ((unsigned int )tmp != 0U) {
#line 8081
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8083
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8085
  tmp___0 = BTDM_IsHT40(padapter);
#line 8085
  if ((unsigned int )tmp___0 != 0U) {
#line 8086
    if (BTCoexDbgLevel == 1U) {
#line 8086
      printk("HT40\n");
    } else {

    }
#line 8087
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8089
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8091
      if (BTCoexDbgLevel == 1U) {
#line 8091
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8092
      rtl8723au_write8(padapter, 2179U, 64);
#line 8093
      btdm_2AntPsTdma(padapter, 1, 11);
    } else {
#line 8095
      if (BTCoexDbgLevel == 1U) {
#line 8095
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8096
      btdm_2AntPsTdma(padapter, 1, 15);
    }
#line 8100
    btdm_2AntAgcTable(padapter, 0);
#line 8101
    btdm_2AntAdcBackOff(padapter, 1);
#line 8102
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8104
    if (BTCoexDbgLevel == 1U) {
#line 8104
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8105
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8106
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8109
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8111
      if (BTCoexDbgLevel == 1U) {
#line 8111
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8112
      rtl8723au_write8(padapter, 2179U, 64);
#line 8113
      btdm_2AntPsTdma(padapter, 1, 11);
    } else {
#line 8115
      if (BTCoexDbgLevel == 1U) {
#line 8115
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8116
      btdm_2AntPsTdma(padapter, 1, 15);
    }
#line 8120
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8122
      if (BTCoexDbgLevel == 1U) {
#line 8122
        printk("Wifi rssi high \n");
      } else {

      }
#line 8123
      btdm_2AntAgcTable(padapter, 1);
#line 8124
      btdm_2AntAdcBackOff(padapter, 1);
#line 8125
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8127
      if (BTCoexDbgLevel == 1U) {
#line 8127
        printk("Wifi rssi low \n");
      } else {

      }
#line 8128
      btdm_2AntAgcTable(padapter, 0);
#line 8129
      btdm_2AntAdcBackOff(padapter, 0);
#line 8130
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8133
  return;
}
}
#line 8135 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723AHIDAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8139
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8139
  if ((unsigned int )tmp != 0U) {
#line 8140
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8142
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8144
  tmp___0 = BTDM_IsHT40(padapter);
#line 8144
  if ((unsigned int )tmp___0 != 0U) {
#line 8145
    if (BTCoexDbgLevel == 1U) {
#line 8145
      printk("HT40\n");
    } else {

    }
#line 8146
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8148
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8150
      if (BTCoexDbgLevel == 1U) {
#line 8150
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8151
      rtl8723au_write8(padapter, 2179U, 64);
#line 8152
      btdm_2AntPsTdma(padapter, 1, 9);
    } else {
#line 8154
      if (BTCoexDbgLevel == 1U) {
#line 8154
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8155
      btdm_2AntPsTdma(padapter, 1, 13);
    }
#line 8159
    btdm_2AntAgcTable(padapter, 0);
#line 8160
    btdm_2AntAdcBackOff(padapter, 0);
#line 8161
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8163
    if (BTCoexDbgLevel == 1U) {
#line 8163
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8164
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8165
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8168
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8170
      if (BTCoexDbgLevel == 1U) {
#line 8170
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8171
      rtl8723au_write8(padapter, 2179U, 64);
#line 8172
      btdm_2AntPsTdma(padapter, 1, 9);
    } else {
#line 8174
      if (BTCoexDbgLevel == 1U) {
#line 8174
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8175
      btdm_2AntPsTdma(padapter, 1, 13);
    }
#line 8179
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8181
      if (BTCoexDbgLevel == 1U) {
#line 8181
        printk("Wifi rssi high \n");
      } else {

      }
#line 8182
      btdm_2AntAgcTable(padapter, 1);
#line 8183
      btdm_2AntAdcBackOff(padapter, 1);
#line 8184
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8186
      if (BTCoexDbgLevel == 1U) {
#line 8186
        printk("Wifi rssi low \n");
      } else {

      }
#line 8187
      btdm_2AntAgcTable(padapter, 0);
#line 8188
      btdm_2AntAdcBackOff(padapter, 0);
#line 8189
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8192
  return;
}
}
#line 8195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723AA2DPAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  struct hal_data_8723a *pHalData ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8198
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8199
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 8201
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8201
  if ((unsigned int )tmp != 0U) {
#line 8202
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8204
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8206
  tmp___0 = BTDM_IsHT40(padapter);
#line 8206
  if ((unsigned int )tmp___0 != 0U) {
#line 8207
    if (BTCoexDbgLevel == 1U) {
#line 8207
      printk("HT40\n");
    } else {

    }
#line 8208
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8211
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8213
      if (BTCoexDbgLevel == 1U) {
#line 8213
        printk("Wifi rssi high \n");
      } else {

      }
#line 8214
      rtl8723au_write8(padapter, 2179U, 64);
#line 8216
      if ((int )btInfoExt & 1) {
#line 8217
        if (BTCoexDbgLevel == 1U) {
#line 8217
          printk("a2dp basic rate \n");
        } else {

        }
#line 8218
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 3);
      } else {
#line 8220
        if (BTCoexDbgLevel == 1U) {
#line 8220
          printk("a2dp edr rate \n");
        } else {

        }
#line 8221
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
      }
    } else {
#line 8224
      if (BTCoexDbgLevel == 1U) {
#line 8224
        printk("Wifi rssi low \n");
      } else {

      }
#line 8225
      if ((int )btInfoExt & 1) {
#line 8226
        if (BTCoexDbgLevel == 1U) {
#line 8226
          printk("a2dp basic rate \n");
        } else {

        }
#line 8227
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 3);
      } else {
#line 8229
        if (BTCoexDbgLevel == 1U) {
#line 8229
          printk("a2dp edr rate \n");
        } else {

        }
#line 8230
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
      }
    }
#line 8235
    btdm_2AntAgcTable(padapter, 0);
#line 8236
    btdm_2AntAdcBackOff(padapter, 1);
#line 8237
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8239
    if (BTCoexDbgLevel == 1U) {
#line 8239
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8240
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8241
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8244
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8246
      if (BTCoexDbgLevel == 1U) {
#line 8246
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8247
      rtl8723au_write8(padapter, 2179U, 64);
#line 8248
      if ((int )btInfoExt & 1) {
#line 8249
        if (BTCoexDbgLevel == 1U) {
#line 8249
          printk("a2dp basic rate \n");
        } else {

        }
#line 8250
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 3);
      } else {
#line 8252
        if (BTCoexDbgLevel == 1U) {
#line 8252
          printk("a2dp edr rate \n");
        } else {

        }
#line 8253
        btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
      }
    } else {
#line 8256
      if (BTCoexDbgLevel == 1U) {
#line 8256
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8257
      if ((int )btInfoExt & 1) {
#line 8258
        if (BTCoexDbgLevel == 1U) {
#line 8258
          printk("a2dp basic rate \n");
        } else {

        }
#line 8259
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 3);
      } else {
#line 8261
        if (BTCoexDbgLevel == 1U) {
#line 8261
          printk("a2dp edr rate \n");
        } else {

        }
#line 8262
        btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
      }
    }
#line 8267
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8269
      if (BTCoexDbgLevel == 1U) {
#line 8269
        printk("Wifi rssi high \n");
      } else {

      }
#line 8270
      btdm_2AntAgcTable(padapter, 1);
#line 8271
      btdm_2AntAdcBackOff(padapter, 1);
#line 8272
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8274
      if (BTCoexDbgLevel == 1U) {
#line 8274
        printk("Wifi rssi low \n");
      } else {

      }
#line 8275
      btdm_2AntAgcTable(padapter, 0);
#line 8276
      btdm_2AntAdcBackOff(padapter, 0);
#line 8277
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8280
  return;
}
}
#line 8282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723APANEDRAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8286
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8286
  if ((unsigned int )tmp != 0U) {
#line 8287
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8289
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8291
  tmp___0 = BTDM_IsHT40(padapter);
#line 8291
  if ((unsigned int )tmp___0 != 0U) {
#line 8292
    if (BTCoexDbgLevel == 1U) {
#line 8292
      printk("HT40\n");
    } else {

    }
#line 8293
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8296
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8298
      if (BTCoexDbgLevel == 1U) {
#line 8298
        printk("Wifi rssi high \n");
      } else {

      }
#line 8299
      rtl8723au_write8(padapter, 2179U, 64);
#line 8300
      btdm_2AntPsTdma(padapter, 1, 2);
    } else {
#line 8302
      if (BTCoexDbgLevel == 1U) {
#line 8302
        printk("Wifi rssi low \n");
      } else {

      }
#line 8303
      btdm_2AntPsTdma(padapter, 1, 6);
    }
#line 8307
    btdm_2AntAgcTable(padapter, 0);
#line 8308
    btdm_2AntAdcBackOff(padapter, 1);
#line 8309
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8311
    if (BTCoexDbgLevel == 1U) {
#line 8311
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8312
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8313
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8316
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8318
      if (BTCoexDbgLevel == 1U) {
#line 8318
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8319
      rtl8723au_write8(padapter, 2179U, 64);
#line 8320
      btdm_2AntPsTdma(padapter, 1, 2);
    } else {
#line 8322
      if (BTCoexDbgLevel == 1U) {
#line 8322
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8323
      btdm_2AntPsTdma(padapter, 1, 6);
    }
#line 8327
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8329
      if (BTCoexDbgLevel == 1U) {
#line 8329
        printk("Wifi rssi high \n");
      } else {

      }
#line 8330
      btdm_2AntAgcTable(padapter, 1);
#line 8331
      btdm_2AntAdcBackOff(padapter, 1);
#line 8332
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8334
      if (BTCoexDbgLevel == 1U) {
#line 8334
        printk("Wifi rssi low \n");
      } else {

      }
#line 8335
      btdm_2AntAgcTable(padapter, 0);
#line 8336
      btdm_2AntAdcBackOff(padapter, 0);
#line 8337
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8340
  return;
}
}
#line 8343 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723APANHSAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 tmp ;

  {
#line 8347
  tmp = BTDM_IsHT40(padapter);
#line 8347
  if ((unsigned int )tmp != 0U) {
#line 8348
    if (BTCoexDbgLevel == 1U) {
#line 8348
      printk("HT40\n");
    } else {

    }
#line 8349
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
#line 8351
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8353
      if (BTCoexDbgLevel == 1U) {
#line 8353
        printk("Wifi rssi high \n");
      } else {

      }
#line 8354
      btdm_2AntDecBtPwr(padapter, 1);
    } else {
#line 8356
      if (BTCoexDbgLevel == 1U) {
#line 8356
        printk("Wifi rssi low \n");
      } else {

      }
#line 8357
      btdm_2AntDecBtPwr(padapter, 0);
    }
#line 8359
    btdm_2AntPsTdma(padapter, 0, 0);
#line 8362
    btdm_2AntAgcTable(padapter, 0);
#line 8363
    btdm_2AntAdcBackOff(padapter, 1);
#line 8364
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8366
    if (BTCoexDbgLevel == 1U) {
#line 8366
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8367
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
#line 8369
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8371
      if (BTCoexDbgLevel == 1U) {
#line 8371
        printk("Wifi rssi high\n");
      } else {

      }
#line 8373
      btdm_2AntDecBtPwr(padapter, 1);
#line 8374
      btdm_2AntPsTdma(padapter, 0, 0);
#line 8377
      btdm_2AntAgcTable(padapter, 1);
#line 8378
      btdm_2AntAdcBackOff(padapter, 1);
#line 8379
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8381
      if (BTCoexDbgLevel == 1U) {
#line 8381
        printk("Wifi rssi low\n");
      } else {

      }
#line 8383
      btdm_2AntDecBtPwr(padapter, 0);
#line 8384
      btdm_2AntPsTdma(padapter, 0, 0);
#line 8387
      btdm_2AntAgcTable(padapter, 0);
#line 8388
      btdm_2AntAdcBackOff(padapter, 0);
#line 8389
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8392
  return;
}
}
#line 8395 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723APANEDRA2DPAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8398
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8400
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 8402
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8402
  if ((unsigned int )tmp != 0U) {
#line 8403
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8405
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8407
  tmp___0 = BTDM_IsHT40(padapter);
#line 8407
  if ((unsigned int )tmp___0 != 0U) {
#line 8408
    if (BTCoexDbgLevel == 1U) {
#line 8408
      printk("HT40\n");
    } else {

    }
#line 8409
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8411
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8413
      if (BTCoexDbgLevel == 1U) {
#line 8413
        printk("Wifi rssi high \n");
      } else {

      }
#line 8415
      rtl8723au_write8(padapter, 2179U, 64);
#line 8417
      if ((int )btInfoExt & 1) {
#line 8418
        if (BTCoexDbgLevel == 1U) {
#line 8418
          printk("a2dp basic rate \n");
        } else {

        }
#line 8419
        btdm_2AntPsTdma(padapter, 1, 4);
      } else {
#line 8421
        if (BTCoexDbgLevel == 1U) {
#line 8421
          printk("a2dp edr rate \n");
        } else {

        }
#line 8422
        btdm_2AntPsTdma(padapter, 1, 2);
      }
    } else {
#line 8425
      if (BTCoexDbgLevel == 1U) {
#line 8425
        printk("Wifi rssi low \n");
      } else {

      }
#line 8427
      if ((int )btInfoExt & 1) {
#line 8428
        if (BTCoexDbgLevel == 1U) {
#line 8428
          printk("a2dp basic rate \n");
        } else {

        }
#line 8429
        btdm_2AntPsTdma(padapter, 1, 8);
      } else {
#line 8431
        if (BTCoexDbgLevel == 1U) {
#line 8431
          printk("a2dp edr rate \n");
        } else {

        }
#line 8432
        btdm_2AntPsTdma(padapter, 1, 6);
      }
    }
#line 8437
    btdm_2AntAgcTable(padapter, 0);
#line 8438
    btdm_2AntAdcBackOff(padapter, 1);
#line 8439
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8441
    if (BTCoexDbgLevel == 1U) {
#line 8441
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8442
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8443
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8445
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8447
      if (BTCoexDbgLevel == 1U) {
#line 8447
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8448
      rtl8723au_write8(padapter, 2179U, 64);
#line 8450
      if ((int )btInfoExt & 1) {
#line 8451
        if (BTCoexDbgLevel == 1U) {
#line 8451
          printk("a2dp basic rate \n");
        } else {

        }
#line 8452
        btdm_2AntPsTdma(padapter, 1, 4);
      } else {
#line 8454
        if (BTCoexDbgLevel == 1U) {
#line 8454
          printk("a2dp edr rate \n");
        } else {

        }
#line 8455
        btdm_2AntPsTdma(padapter, 1, 2);
      }
    } else {
#line 8458
      if (BTCoexDbgLevel == 1U) {
#line 8458
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8460
      if ((int )btInfoExt & 1) {
#line 8461
        if (BTCoexDbgLevel == 1U) {
#line 8461
          printk("a2dp basic rate \n");
        } else {

        }
#line 8462
        btdm_2AntPsTdma(padapter, 1, 8);
      } else {
#line 8464
        if (BTCoexDbgLevel == 1U) {
#line 8464
          printk("a2dp edr rate \n");
        } else {

        }
#line 8465
        btdm_2AntPsTdma(padapter, 1, 6);
      }
    }
#line 8470
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8472
      if (BTCoexDbgLevel == 1U) {
#line 8472
        printk("Wifi rssi high \n");
      } else {

      }
#line 8473
      btdm_2AntAgcTable(padapter, 1);
#line 8474
      btdm_2AntAdcBackOff(padapter, 1);
#line 8475
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8477
      if (BTCoexDbgLevel == 1U) {
#line 8477
        printk("Wifi rssi low \n");
      } else {

      }
#line 8478
      btdm_2AntAgcTable(padapter, 0);
#line 8479
      btdm_2AntAdcBackOff(padapter, 0);
#line 8480
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8483
  return;
}
}
#line 8485 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723APANEDRHIDAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8489
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8489
  if ((unsigned int )tmp != 0U) {
#line 8490
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8492
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8494
  tmp___0 = BTDM_IsHT40(padapter);
#line 8494
  if ((unsigned int )tmp___0 != 0U) {
#line 8495
    if (BTCoexDbgLevel == 1U) {
#line 8495
      printk("HT40\n");
    } else {

    }
#line 8496
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8498
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8500
      if (BTCoexDbgLevel == 1U) {
#line 8500
        printk("Wifi rssi high \n");
      } else {

      }
#line 8501
      rtl8723au_write8(padapter, 2179U, 64);
#line 8502
      btdm_2AntPsTdma(padapter, 1, 10);
    } else {
#line 8504
      if (BTCoexDbgLevel == 1U) {
#line 8504
        printk("Wifi rssi low \n");
      } else {

      }
#line 8505
      btdm_2AntPsTdma(padapter, 1, 14);
    }
#line 8509
    btdm_2AntAgcTable(padapter, 0);
#line 8510
    btdm_2AntAdcBackOff(padapter, 1);
#line 8511
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8513
    if (BTCoexDbgLevel == 1U) {
#line 8513
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8514
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8515
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8518
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8520
      if (BTCoexDbgLevel == 1U) {
#line 8520
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8521
      rtl8723au_write8(padapter, 2179U, 64);
#line 8522
      btdm_2AntPsTdma(padapter, 1, 10);
    } else {
#line 8524
      if (BTCoexDbgLevel == 1U) {
#line 8524
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8525
      btdm_2AntPsTdma(padapter, 1, 14);
    }
#line 8529
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8531
      if (BTCoexDbgLevel == 1U) {
#line 8531
        printk("Wifi rssi high \n");
      } else {

      }
#line 8532
      btdm_2AntAgcTable(padapter, 1);
#line 8533
      btdm_2AntAdcBackOff(padapter, 1);
#line 8534
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8536
      if (BTCoexDbgLevel == 1U) {
#line 8536
        printk("Wifi rssi low \n");
      } else {

      }
#line 8537
      btdm_2AntAgcTable(padapter, 0);
#line 8538
      btdm_2AntAdcBackOff(padapter, 0);
#line 8539
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8542
  return;
}
}
#line 8545 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723AHIDA2DPPANEDRAction(struct rtw_adapter *padapter ) 
{ 
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8548
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8550
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 8552
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8552
  if ((unsigned int )tmp != 0U) {
#line 8553
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8555
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8557
  tmp___0 = BTDM_IsHT40(padapter);
#line 8557
  if ((unsigned int )tmp___0 != 0U) {
#line 8558
    if (BTCoexDbgLevel == 1U) {
#line 8558
      printk("HT40\n");
    } else {

    }
#line 8559
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8560
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8562
      if (BTCoexDbgLevel == 1U) {
#line 8562
        printk("Wifi rssi high \n");
      } else {

      }
#line 8563
      rtl8723au_write8(padapter, 2179U, 64);
#line 8565
      if ((int )btInfoExt & 1) {
#line 8566
        if (BTCoexDbgLevel == 1U) {
#line 8566
          printk("a2dp basic rate \n");
        } else {

        }
#line 8567
        btdm_2AntPsTdma(padapter, 1, 12);
      } else {
#line 8569
        if (BTCoexDbgLevel == 1U) {
#line 8569
          printk("a2dp edr rate \n");
        } else {

        }
#line 8570
        btdm_2AntPsTdma(padapter, 1, 10);
      }
    } else {
#line 8573
      if (BTCoexDbgLevel == 1U) {
#line 8573
        printk("Wifi rssi low \n");
      } else {

      }
#line 8574
      if ((int )btInfoExt & 1) {
#line 8575
        if (BTCoexDbgLevel == 1U) {
#line 8575
          printk("a2dp basic rate \n");
        } else {

        }
#line 8576
        btdm_2AntPsTdma(padapter, 1, 16);
      } else {
#line 8578
        if (BTCoexDbgLevel == 1U) {
#line 8578
          printk("a2dp edr rate \n");
        } else {

        }
#line 8579
        btdm_2AntPsTdma(padapter, 1, 14);
      }
    }
#line 8584
    btdm_2AntAgcTable(padapter, 0);
#line 8585
    btdm_2AntAdcBackOff(padapter, 1);
#line 8586
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8588
    if (BTCoexDbgLevel == 1U) {
#line 8588
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8589
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 37, 0);
#line 8590
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);
#line 8591
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8593
      if (BTCoexDbgLevel == 1U) {
#line 8593
        printk("Wifi rssi high \n");
      } else {

      }
#line 8594
      rtl8723au_write8(padapter, 2179U, 64);
#line 8596
      if ((int )btInfoExt & 1) {
#line 8597
        if (BTCoexDbgLevel == 1U) {
#line 8597
          printk("a2dp basic rate \n");
        } else {

        }
#line 8598
        btdm_2AntPsTdma(padapter, 1, 12);
      } else {
#line 8600
        if (BTCoexDbgLevel == 1U) {
#line 8600
          printk("a2dp edr rate \n");
        } else {

        }
#line 8601
        btdm_2AntPsTdma(padapter, 1, 10);
      }
    } else {
#line 8604
      if (BTCoexDbgLevel == 1U) {
#line 8604
        printk("Wifi rssi low \n");
      } else {

      }
#line 8605
      if ((int )btInfoExt & 1) {
#line 8606
        if (BTCoexDbgLevel == 1U) {
#line 8606
          printk("a2dp basic rate \n");
        } else {

        }
#line 8607
        btdm_2AntPsTdma(padapter, 1, 16);
      } else {
#line 8609
        if (BTCoexDbgLevel == 1U) {
#line 8609
          printk("a2dp edr rate \n");
        } else {

        }
#line 8610
        btdm_2AntPsTdma(padapter, 1, 14);
      }
    }
#line 8615
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8617
      if (BTCoexDbgLevel == 1U) {
#line 8617
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8618
      btdm_2AntAgcTable(padapter, 1);
#line 8619
      btdm_2AntAdcBackOff(padapter, 1);
#line 8620
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8622
      if (BTCoexDbgLevel == 1U) {
#line 8622
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8623
      btdm_2AntAgcTable(padapter, 0);
#line 8624
      btdm_2AntAdcBackOff(padapter, 0);
#line 8625
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8628
  return;
}
}
#line 8630 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723AHIDA2DPAction(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8632
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8635
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 8637
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8637
  if ((unsigned int )tmp != 0U) {
#line 8638
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8640
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8642
  tmp___0 = BTDM_IsHT40(padapter);
#line 8642
  if ((unsigned int )tmp___0 != 0U) {
#line 8643
    if (BTCoexDbgLevel == 1U) {
#line 8643
      printk("HT40\n");
    } else {

    }
#line 8644
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8645
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8647
      if (BTCoexDbgLevel == 1U) {
#line 8647
        printk("Wifi rssi high \n");
      } else {

      }
#line 8648
      rtl8723au_write8(padapter, 2179U, 64);
#line 8650
      if ((int )btInfoExt & 1) {
#line 8651
        if (BTCoexDbgLevel == 1U) {
#line 8651
          printk("a2dp basic rate \n");
        } else {

        }
#line 8652
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 3);
      } else {
#line 8654
        if (BTCoexDbgLevel == 1U) {
#line 8654
          printk("a2dp edr rate \n");
        } else {

        }
#line 8655
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 1);
      }
    } else {
#line 8658
      if (BTCoexDbgLevel == 1U) {
#line 8658
        printk("Wifi rssi low \n");
      } else {

      }
#line 8659
      if ((int )btInfoExt & 1) {
#line 8660
        if (BTCoexDbgLevel == 1U) {
#line 8660
          printk("a2dp basic rate \n");
        } else {

        }
#line 8661
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 3);
      } else {
#line 8663
        if (BTCoexDbgLevel == 1U) {
#line 8663
          printk("a2dp edr rate \n");
        } else {

        }
#line 8664
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 1);
      }
    }
#line 8668
    btdm_2AntAgcTable(padapter, 0);
#line 8669
    btdm_2AntAdcBackOff(padapter, 1);
#line 8670
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8672
    if (BTCoexDbgLevel == 1U) {
#line 8672
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8673
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8674
    btRssiState1 = BTDM_CheckCoexRSSIState(padapter, 2, 27, 0);
#line 8676
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8678
      if (BTCoexDbgLevel == 1U) {
#line 8678
        printk("Wifi rssi high \n");
      } else {

      }
#line 8679
      rtl8723au_write8(padapter, 2179U, 64);
#line 8681
      if ((int )btInfoExt & 1) {
#line 8682
        if (BTCoexDbgLevel == 1U) {
#line 8682
          printk("a2dp basic rate \n");
        } else {

        }
#line 8683
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 3);
      } else {
#line 8685
        if (BTCoexDbgLevel == 1U) {
#line 8685
          printk("a2dp edr rate \n");
        } else {

        }
#line 8686
        btdm_2AntTdmaDurationAdjust(padapter, 1, 0, 1);
      }
    } else {
#line 8689
      if (BTCoexDbgLevel == 1U) {
#line 8689
        printk("Wifi rssi low \n");
      } else {

      }
#line 8690
      if ((int )btInfoExt & 1) {
#line 8691
        if (BTCoexDbgLevel == 1U) {
#line 8691
          printk("a2dp basic rate \n");
        } else {

        }
#line 8692
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 3);
      } else {
#line 8694
        if (BTCoexDbgLevel == 1U) {
#line 8694
          printk("a2dp edr rate \n");
        } else {

        }
#line 8695
        btdm_2AntTdmaDurationAdjust(padapter, 1, 1, 1);
      }
    }
#line 8698
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8700
      if (BTCoexDbgLevel == 1U) {
#line 8700
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8702
      btdm_2AntAgcTable(padapter, 1);
#line 8703
      btdm_2AntAdcBackOff(padapter, 1);
#line 8704
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8706
      if (BTCoexDbgLevel == 1U) {
#line 8706
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8708
      btdm_2AntAgcTable(padapter, 0);
#line 8709
      btdm_2AntAdcBackOff(padapter, 0);
#line 8710
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8713
  return;
}
}
#line 8715 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_2Ant8723AA2dp(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 btRssiState ;
  u8 btRssiState1 ;
  u8 btInfoExt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 8717
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8720
  btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 8722
  tmp = btdm_NeedToDecBtPwr(padapter);
#line 8722
  if ((unsigned int )tmp != 0U) {
#line 8723
    btdm_2AntDecBtPwr(padapter, 1);
  } else {
#line 8725
    btdm_2AntDecBtPwr(padapter, 0);
  }
#line 8727
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 8728
  btdm_2AntIgnoreWlanAct(padapter, 0);
#line 8730
  tmp___0 = BTDM_IsHT40(padapter);
#line 8730
  if ((unsigned int )tmp___0 != 0U) {
#line 8731
    if (BTCoexDbgLevel == 1U) {
#line 8731
      printk("HT40\n");
    } else {

    }
#line 8732
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 37, 0);
#line 8734
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8736
      if (BTCoexDbgLevel == 1U) {
#line 8736
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8737
      rtl8723au_write8(padapter, 2179U, 64);
#line 8738
      btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
    } else {
#line 8740
      if (BTCoexDbgLevel == 1U) {
#line 8740
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8741
      btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
    }
#line 8745
    btdm_2AntAgcTable(padapter, 0);
#line 8746
    btdm_2AntAdcBackOff(padapter, 1);
#line 8747
    btdm_2AntDacSwing(padapter, 0, 192U);
  } else {
#line 8749
    if (BTCoexDbgLevel == 1U) {
#line 8749
      printk("HT20 or Legacy\n");
    } else {

    }
#line 8750
    btRssiState = BTDM_CheckCoexRSSIState(padapter, 2, 47, 0);
#line 8751
    btRssiState1 = BTDM_CheckCoexRSSIState1(padapter, 2, 27, 0);
#line 8754
    if ((unsigned int )btRssiState1 == 0U || (unsigned int )btRssiState1 == 3U) {
#line 8756
      if (BTCoexDbgLevel == 1U) {
#line 8756
        printk("Wifi rssi-1 high \n");
      } else {

      }
#line 8757
      rtl8723au_write8(padapter, 2179U, 64);
#line 8758
      btdm_2AntTdmaDurationAdjust(padapter, 0, 0, 1);
    } else {
#line 8760
      if (BTCoexDbgLevel == 1U) {
#line 8760
        printk("Wifi rssi-1 low \n");
      } else {

      }
#line 8761
      btdm_2AntTdmaDurationAdjust(padapter, 0, 1, 1);
    }
#line 8765
    if ((unsigned int )btRssiState == 0U || (unsigned int )btRssiState == 3U) {
#line 8767
      if (BTCoexDbgLevel == 1U) {
#line 8767
        printk("Wifi rssi high \n");
      } else {

      }
#line 8768
      btdm_2AntAgcTable(padapter, 1);
#line 8769
      btdm_2AntAdcBackOff(padapter, 1);
#line 8770
      btdm_2AntDacSwing(padapter, 0, 192U);
    } else {
#line 8772
      if (BTCoexDbgLevel == 1U) {
#line 8772
        printk("Wifi rssi low \n");
      } else {

      }
#line 8773
      btdm_2AntAgcTable(padapter, 0);
#line 8774
      btdm_2AntAdcBackOff(padapter, 0);
#line 8775
      btdm_2AntDacSwing(padapter, 0, 192U);
    }
  }
#line 8778
  return;
}
}
#line 8781 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_2AntParaInit(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;

  {
#line 8784
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8785
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 8787
  if (BTCoexDbgLevel == 1U) {
#line 8787
    printk("[BTCoex], 2Ant Parameter Init!!\n");
  } else {

  }
#line 8790
  rtl8723au_write8(padapter, 1902U, 4);
#line 8791
  rtl8723au_write8(padapter, 1912U, 3);
#line 8792
  rtl8723au_write8(padapter, 64U, 32);
#line 8795
  pBtdm8723->preVal0x6c0 = 0U;
#line 8796
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 8798
  pBtdm8723->bPrePsTdmaOn = 1U;
#line 8799
  btdm_2AntPsTdma(padapter, 0, 0);
#line 8801
  pBtdm8723->preFwDacSwingLvl = 16U;
#line 8802
  btdm_2AntFwDacSwingLvl(padapter, 32);
#line 8804
  pBtdm8723->bPreDecBtPwr = 1U;
#line 8805
  btdm_2AntDecBtPwr(padapter, 0);
#line 8807
  pBtdm8723->bPreAgcTableEn = 1U;
#line 8808
  btdm_2AntAgcTable(padapter, 0);
#line 8810
  pBtdm8723->bPreAdcBackOff = 1U;
#line 8811
  btdm_2AntAdcBackOff(padapter, 0);
#line 8813
  pBtdm8723->bPreLowPenaltyRa = 1U;
#line 8814
  btdm_2AntLowPenaltyRa(padapter, 0);
#line 8816
  pBtdm8723->bPreRfRxLpfShrink = 1U;
#line 8817
  btdm_2AntRfShrink(padapter, 0);
#line 8819
  pBtdm8723->bPreDacSwingOn = 1U;
#line 8820
  btdm_2AntDacSwing(padapter, 0, 192U);
#line 8822
  pBtdm8723->bPreIgnoreWlanAct = 1U;
#line 8823
  btdm_2AntIgnoreWlanAct(padapter, 0);
#line 8824
  return;
}
}
#line 8826 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_2AntHwCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 8828
  btdm_2AntCoexTable(padapter, 1431655765U, 65535U, 3);
#line 8829
  return;
}
}
#line 8831 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_2AntFwCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 8833
  btdm_2AntIgnoreWlanAct(padapter, 0);
#line 8834
  btdm_2AntPsTdma(padapter, 0, 0);
#line 8835
  btdm_2AntFwDacSwingLvl(padapter, 32);
#line 8836
  btdm_2AntDecBtPwr(padapter, 0);
#line 8837
  return;
}
}
#line 8839 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_2AntSwCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 8841
  btdm_2AntAgcTable(padapter, 0);
#line 8842
  btdm_2AntAdcBackOff(padapter, 0);
#line 8843
  btdm_2AntLowPenaltyRa(padapter, 0);
#line 8844
  btdm_2AntRfShrink(padapter, 0);
#line 8845
  btdm_2AntDacSwing(padapter, 0, 192U);
#line 8846
  return;
}
}
#line 8848 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_2AntFwC2hBtInfo8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 btInfo ;
  u8 algorithm ;
  u8 bBtLinkExist ;
  u8 bBtHsModeExist ;

  {
#line 8850
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 8851
  pBtMgnt = & pBTInfo->BtMgnt;
#line 8852
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 8853
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 8854
  btInfo = 0U;
#line 8855
  algorithm = 0U;
#line 8856
  bBtLinkExist = 0U;
#line 8856
  bBtHsModeExist = 0U;
#line 8858
  btInfo = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;
#line 8859
  pBtdm8723->btStatus = 0U;
#line 8862
  if (((unsigned long )btInfo & 4UL) != 0UL) {
#line 8863
    if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage == 0U) {
#line 8864
      pBtMgnt->ExtConfig.bHoldForBtOperation = 1U;
#line 8865
      pBtMgnt->ExtConfig.bHoldPeriodCnt = 1U;
#line 8866
      btdm_2AntBtInquiryPage(padapter);
    } else {
#line 8868
      pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
#line 8869
      btdm_HoldForBtInqPage(padapter);
    }
#line 8871
    pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = 1U;
  } else {
#line 8874
    pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage = 0U;
#line 8875
    pBtMgnt->ExtConfig.bHoldForBtOperation = 0U;
#line 8876
    pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
  }
#line 8879
  if (BTCoexDbgLevel == 1U) {
#line 8879
    printk("[BTC2H], pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage =%x pBtMgnt->ExtConfig.bHoldPeriodCnt =%x pBtMgnt->ExtConfig.bHoldForBtOperation =%x\n",
           (int )pHalData->bt_coexist.halCoex8723.bC2hBtInquiryPage, pBtMgnt->ExtConfig.bHoldPeriodCnt,
           (int )pBtMgnt->ExtConfig.bHoldForBtOperation);
  } else {

  }
#line 8885
  if (BTCoexDbgLevel == 1U) {
#line 8885
    printk("[BTC2H],   btInfo =%x   pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal =%x\n",
           (int )btInfo, (int )pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal);
  } else {

  }
#line 8888
  if ((int )btInfo & 1) {
#line 8889
    if (BTCoexDbgLevel == 1U) {
#line 8889
      printk("[BTC2H], BTInfo: bConnect = true   btInfo =%x\n", (int )btInfo);
    } else {

    }
#line 8890
    bBtLinkExist = 1U;
#line 8891
    if (((unsigned long )btInfo & 240UL) != 0UL || (unsigned int )pHalData->bt_coexist.halCoex8723.btRetryCnt != 0U) {
#line 8893
      pBtdm8723->btStatus = 2U;
    } else {
#line 8895
      pBtdm8723->btStatus = 1U;
    }
#line 8898
    if (((unsigned long )btInfo & 2UL) != 0UL || ((unsigned long )btInfo & 16UL) != 0UL) {
#line 8899
      if (((int )((signed char )btInfo) < 0 || ((unsigned long )btInfo & 64UL) != 0UL) || ((unsigned long )btInfo & 32UL) != 0UL) {
#line 8900
        switch ((int )btInfo & 224) {
        case 32: ;
#line 8902
        if (BTCoexDbgLevel == 1U) {
#line 8902
          printk("[BTCoex], SCO + HID\n");
        } else {

        }
#line 8903
        algorithm = 2U;
#line 8904
        goto ldv_56434;
        case 64: ;
#line 8906
        if (BTCoexDbgLevel == 1U) {
#line 8906
          printk("[BTCoex], Error!!! SCO + A2DP\n");
        } else {

        }
#line 8907
        goto ldv_56434;
        case 128: ;
#line 8909
        if ((unsigned int )bBtHsModeExist != 0U) {
#line 8910
          if (BTCoexDbgLevel == 1U) {
#line 8910
            printk("[BTCoex], SCO + PAN(HS)\n");
          } else {

          }
#line 8911
          algorithm = 1U;
        } else {
#line 8913
          if (BTCoexDbgLevel == 1U) {
#line 8913
            printk("[BTCoex], SCO + PAN(EDR)\n");
          } else {

          }
#line 8914
          algorithm = 7U;
        }
#line 8916
        goto ldv_56434;
        case 96: ;
#line 8918
        if (BTCoexDbgLevel == 1U) {
#line 8918
          printk("[BTCoex], HID + A2DP\n");
        } else {

        }
#line 8919
        algorithm = 9U;
#line 8920
        goto ldv_56434;
        case 160: ;
#line 8922
        if ((unsigned int )bBtHsModeExist != 0U) {
#line 8923
          if (BTCoexDbgLevel == 1U) {
#line 8923
            printk("[BTCoex], HID + PAN(HS)\n");
          } else {

          }
#line 8924
          algorithm = 9U;
        } else {
#line 8926
          if (BTCoexDbgLevel == 1U) {
#line 8926
            printk("[BTCoex], HID + PAN(EDR)\n");
          } else {

          }
#line 8927
          algorithm = 7U;
        }
#line 8929
        goto ldv_56434;
        case 192: ;
#line 8931
        if ((unsigned int )bBtHsModeExist != 0U) {
#line 8932
          if (BTCoexDbgLevel == 1U) {
#line 8932
            printk("[BTCoex], A2DP + PAN(HS)\n");
          } else {

          }
#line 8933
          algorithm = 3U;
        } else {
#line 8935
          if (BTCoexDbgLevel == 1U) {
#line 8935
            printk("[BTCoex], A2DP + PAN(EDR)\n");
          } else {

          }
#line 8936
          algorithm = 6U;
        }
#line 8938
        goto ldv_56434;
        case 224: ;
#line 8940
        if ((unsigned int )bBtHsModeExist != 0U) {
#line 8941
          if (BTCoexDbgLevel == 1U) {
#line 8941
            printk("[BTCoex], HID + A2DP + PAN(HS)\n");
          } else {

          }
#line 8942
          algorithm = 9U;
        } else {
#line 8944
          if (BTCoexDbgLevel == 1U) {
#line 8944
            printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
          } else {

          }
#line 8945
          algorithm = 8U;
        }
#line 8947
        goto ldv_56434;
        }
        ldv_56434: ;
      } else {
#line 8950
        if (BTCoexDbgLevel == 1U) {
#line 8950
          printk("[BTCoex], SCO only\n");
        } else {

        }
#line 8951
        algorithm = 1U;
      }
    } else {
#line 8954
      if (BTCoexDbgLevel == 1U) {
#line 8954
        printk("[BTCoex], non SCO\n");
      } else {

      }
#line 8955
      switch ((int )btInfo & 224) {
      case 32: ;
#line 8957
      if (BTCoexDbgLevel == 1U) {
#line 8957
        printk("[BTCoex], HID\n");
      } else {

      }
#line 8958
      algorithm = 2U;
#line 8959
      goto ldv_56442;
      case 64: ;
#line 8961
      if (BTCoexDbgLevel == 1U) {
#line 8961
        printk("[BTCoex],  A2DP\n");
      } else {

      }
#line 8962
      algorithm = 3U;
#line 8963
      goto ldv_56442;
      case 128: ;
#line 8965
      if (BTCoexDbgLevel == 1U) {
#line 8965
        printk("[BTCoex], PAN(EDR)\n");
      } else {

      }
#line 8966
      algorithm = 7U;
#line 8967
      goto ldv_56442;
      case 96: ;
#line 8969
      if (BTCoexDbgLevel == 1U) {
#line 8969
        printk("[BTCoex], HID + A2DP\n");
      } else {

      }
#line 8970
      algorithm = 9U;
#line 8971
      goto ldv_56442;
      case 160: ;
#line 8973
      if ((unsigned int )bBtHsModeExist != 0U) {
#line 8974
        if (BTCoexDbgLevel == 1U) {
#line 8974
          printk("[BTCoex], HID + PAN(HS)\n");
        } else {

        }
#line 8975
        algorithm = 9U;
      } else {
#line 8977
        if (BTCoexDbgLevel == 1U) {
#line 8977
          printk("[BTCoex], HID + PAN(EDR)\n");
        } else {

        }
#line 8978
        algorithm = 7U;
      }
#line 8980
      goto ldv_56442;
      case 192: ;
#line 8982
      if ((unsigned int )bBtHsModeExist != 0U) {
#line 8983
        if (BTCoexDbgLevel == 1U) {
#line 8983
          printk("[BTCoex], A2DP + PAN(HS)\n");
        } else {

        }
#line 8984
        algorithm = 3U;
      } else {
#line 8986
        if (BTCoexDbgLevel == 1U) {
#line 8986
          printk("[BTCoex], A2DP + PAN(EDR)\n");
        } else {

        }
#line 8987
        algorithm = 6U;
      }
#line 8989
      goto ldv_56442;
      case 224: ;
#line 8991
      if ((unsigned int )bBtHsModeExist != 0U) {
#line 8992
        if (BTCoexDbgLevel == 1U) {
#line 8992
          printk("[BTCoex], HID + A2DP + PAN(HS)\n");
        } else {

        }
#line 8993
        algorithm = 9U;
      } else {
#line 8995
        if (BTCoexDbgLevel == 1U) {
#line 8995
          printk("[BTCoex], HID + A2DP + PAN(EDR)\n");
        } else {

        }
#line 8996
        algorithm = 8U;
      }
#line 8998
      goto ldv_56442;
      }
      ldv_56442: ;
    }
  } else {
#line 9003
    if (BTCoexDbgLevel == 1U) {
#line 9003
      printk("[BTC2H], BTInfo: bConnect = false\n");
    } else {

    }
#line 9004
    pBtdm8723->btStatus = 0U;
  }
#line 9007
  pBtdm8723->curAlgorithm = algorithm;
#line 9008
  if (BTCoexDbgLevel == 1U) {
#line 9008
    printk("[BTCoex], Algorithm = %d \n", (int )pBtdm8723->curAlgorithm);
  } else {

  }
#line 9011
  BTDM_CheckWiFiState(padapter);
#line 9012
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9013
    if (BTCoexDbgLevel == 1U) {
#line 9013
      printk("Action Manual control, won\'t execute bt coexist mechanism!!\n");
    } else {

    }
#line 9014
    return;
  } else {

  }
#line 9016
  return;
}
}
#line 9018 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_2AntBtCoexist8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 btInfoOriginal ;
  struct hal_data_8723a *pHalData ;
  struct btdm_8723a_2ant *pBtdm8723 ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;

  {
#line 9020
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9021
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9022
  pBtDbg = & pBTInfo->BtDbg;
#line 9023
  btInfoOriginal = 0U;
#line 9024
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9025
  pBtdm8723 = & pHalData->bt_coexist.halCoex8723.btdm2Ant;
#line 9027
  tmp___1 = BTDM_BtProfileSupport(padapter);
#line 9027
  if ((unsigned int )tmp___1 != 0U) {
#line 9028
    if ((unsigned int )pBtMgnt->ExtConfig.bHoldForBtOperation != 0U) {
#line 9029
      if (BTCoexDbgLevel == 1U) {
#line 9029
        printk("Action for BT Operation adjust!!\n");
      } else {

      }
#line 9030
      return;
    } else {

    }
#line 9032
    if (pBtMgnt->ExtConfig.bHoldPeriodCnt != 0U) {
#line 9033
      if (BTCoexDbgLevel == 1U) {
#line 9033
        printk("Hold BT inquiry/page scan setting (cnt = %d)!!\n", pBtMgnt->ExtConfig.bHoldPeriodCnt);
      } else {

      }
#line 9035
      if (pBtMgnt->ExtConfig.bHoldPeriodCnt > 10U) {
#line 9036
        pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
      } else {
#line 9039
        pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      }
#line 9041
      return;
    } else {

    }
#line 9044
    if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 9045
      if (BTCoexDbgLevel == 1U) {
#line 9045
        printk("[Dbg control], ");
      } else {

      }
    } else {

    }
#line 9047
    pBtdm8723->curAlgorithm = btdm_ActionAlgorithm(padapter);
#line 9048
    if (BTCoexDbgLevel == 1U) {
#line 9048
      printk("[BTCoex], Algorithm = %d \n", (int )pBtdm8723->curAlgorithm);
    } else {

    }
#line 9050
    tmp = btdm_Is2Ant8723ACommonAction(padapter);
#line 9050
    if ((unsigned int )tmp != 0U) {
#line 9051
      if (BTCoexDbgLevel == 1U) {
#line 9051
        printk("Action 2-Ant common.\n");
      } else {

      }
#line 9052
      pBtdm8723->bResetTdmaAdjust = 1U;
    } else {
#line 9054
      if ((int )pBtdm8723->curAlgorithm != (int )pBtdm8723->preAlgorithm) {
#line 9055
        if (BTCoexDbgLevel == 1U) {
#line 9055
          printk("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n", (int )pBtdm8723->preAlgorithm,
                 (int )pBtdm8723->curAlgorithm);
        } else {

        }
#line 9057
        pBtdm8723->bResetTdmaAdjust = 1U;
      } else {

      }
#line 9059
      switch ((int )pBtdm8723->curAlgorithm) {
      case 1: ;
#line 9061
      if (BTCoexDbgLevel == 1U) {
#line 9061
        printk("Action 2-Ant, algorithm = SCO.\n");
      } else {

      }
#line 9062
      btdm_2Ant8723ASCOAction(padapter);
#line 9063
      goto ldv_56459;
      case 2: ;
#line 9065
      if (BTCoexDbgLevel == 1U) {
#line 9065
        printk("Action 2-Ant, algorithm = HID.\n");
      } else {

      }
#line 9066
      btdm_2Ant8723AHIDAction(padapter);
#line 9067
      goto ldv_56459;
      case 3: ;
#line 9069
      if (BTCoexDbgLevel == 1U) {
#line 9069
        printk("Action 2-Ant, algorithm = A2DP.\n");
      } else {

      }
#line 9070
      btdm_2Ant8723AA2DPAction(padapter);
#line 9071
      goto ldv_56459;
      case 4: ;
#line 9073
      if (BTCoexDbgLevel == 1U) {
#line 9073
        printk("Action 2-Ant, algorithm = PAN(EDR).\n");
      } else {

      }
#line 9074
      btdm_2Ant8723APANEDRAction(padapter);
#line 9075
      goto ldv_56459;
      case 5: ;
#line 9077
      if (BTCoexDbgLevel == 1U) {
#line 9077
        printk("Action 2-Ant, algorithm = HS mode.\n");
      } else {

      }
#line 9078
      btdm_2Ant8723APANHSAction(padapter);
#line 9079
      goto ldv_56459;
      case 6: ;
#line 9081
      if (BTCoexDbgLevel == 1U) {
#line 9081
        printk("Action 2-Ant, algorithm = PAN+A2DP.\n");
      } else {

      }
#line 9082
      btdm_2Ant8723APANEDRA2DPAction(padapter);
#line 9083
      goto ldv_56459;
      case 7: ;
#line 9085
      if (BTCoexDbgLevel == 1U) {
#line 9085
        printk("Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
      } else {

      }
#line 9086
      btdm_2Ant8723APANEDRHIDAction(padapter);
#line 9087
      goto ldv_56459;
      case 8: ;
#line 9089
      if (BTCoexDbgLevel == 1U) {
#line 9089
        printk("Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
      } else {

      }
#line 9090
      btdm_2Ant8723AHIDA2DPPANEDRAction(padapter);
#line 9091
      goto ldv_56459;
      case 9: ;
#line 9093
      if (BTCoexDbgLevel == 1U) {
#line 9093
        printk("Action 2-Ant, algorithm = HID+A2DP.\n");
      } else {

      }
#line 9094
      btdm_2Ant8723AHIDA2DPAction(padapter);
#line 9095
      goto ldv_56459;
      default: ;
#line 9097
      if (BTCoexDbgLevel == 1U) {
#line 9097
        printk("Action 2-Ant, algorithm = 0.\n");
      } else {

      }
#line 9098
      btdm_2Ant8723AA2DPAction(padapter);
#line 9099
      goto ldv_56459;
      }
      ldv_56459: 
#line 9101
      pBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;
    }
  } else {
#line 9104
    if (BTCoexDbgLevel == 1U) {
#line 9104
      printk("[BTCoex] Get bt info by fw!!\n");
    } else {

    }
#line 9106
    if ((unsigned int )pHalData->bt_coexist.halCoex8723.bC2hBtInfoReqSent != 0U) {
#line 9107
      if (BTCoexDbgLevel == 1U) {
#line 9107
        printk("[BTCoex] c2h for btInfo not rcvd yet!!\n");
      } else {

      }
    } else {

    }
#line 9109
    btInfoOriginal = pHalData->bt_coexist.halCoex8723.c2hBtInfoOriginal;
#line 9111
    if ((unsigned int )pBtMgnt->ExtConfig.bHoldForBtOperation != 0U) {
#line 9112
      if (BTCoexDbgLevel == 1U) {
#line 9112
        printk("Action for BT Operation adjust!!\n");
      } else {

      }
#line 9113
      return;
    } else {

    }
#line 9115
    if (pBtMgnt->ExtConfig.bHoldPeriodCnt != 0U) {
#line 9116
      if (BTCoexDbgLevel == 1U) {
#line 9116
        printk("Hold BT inquiry/page scan setting (cnt = %d)!!\n", pBtMgnt->ExtConfig.bHoldPeriodCnt);
      } else {

      }
#line 9119
      if (pBtMgnt->ExtConfig.bHoldPeriodCnt > 10U) {
#line 9120
        pBtMgnt->ExtConfig.bHoldPeriodCnt = 0U;
      } else {
#line 9123
        pBtMgnt->ExtConfig.bHoldPeriodCnt = pBtMgnt->ExtConfig.bHoldPeriodCnt + 1U;
      }
#line 9125
      return;
    } else {

    }
#line 9128
    if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 9129
      if (BTCoexDbgLevel == 1U) {
#line 9129
        printk("[Dbg control], ");
      } else {

      }
    } else {

    }
#line 9130
    tmp___0 = btdm_Is2Ant8723ACommonAction(padapter);
#line 9130
    if ((unsigned int )tmp___0 != 0U) {
#line 9131
      if (BTCoexDbgLevel == 1U) {
#line 9131
        printk("Action 2-Ant common.\n");
      } else {

      }
#line 9132
      pBtdm8723->bResetTdmaAdjust = 1U;
    } else {
#line 9134
      if ((int )pBtdm8723->curAlgorithm != (int )pBtdm8723->preAlgorithm) {
#line 9135
        if (BTCoexDbgLevel == 1U) {
#line 9135
          printk("[BTCoex], preAlgorithm =%d, curAlgorithm =%d\n", (int )pBtdm8723->preAlgorithm,
                 (int )pBtdm8723->curAlgorithm);
        } else {

        }
#line 9139
        pBtdm8723->bResetTdmaAdjust = 1U;
      } else {

      }
#line 9141
      switch ((int )pBtdm8723->curAlgorithm) {
      case 1: ;
#line 9143
      if (BTCoexDbgLevel == 1U) {
#line 9143
        printk("Action 2-Ant, algorithm = SCO.\n");
      } else {

      }
#line 9144
      btdm_2Ant8723ASCOAction(padapter);
#line 9145
      goto ldv_56470;
      case 2: ;
#line 9147
      if (BTCoexDbgLevel == 1U) {
#line 9147
        printk("Action 2-Ant, algorithm = HID.\n");
      } else {

      }
#line 9148
      btdm_2Ant8723AHIDAction(padapter);
#line 9149
      goto ldv_56470;
      case 3: ;
#line 9151
      if (BTCoexDbgLevel == 1U) {
#line 9151
        printk("Action 2-Ant, algorithm = A2DP.\n");
      } else {

      }
#line 9152
      btdm_2Ant8723AA2dp(padapter);
#line 9153
      goto ldv_56470;
      case 4: ;
#line 9155
      if (BTCoexDbgLevel == 1U) {
#line 9155
        printk("Action 2-Ant, algorithm = PAN(EDR).\n");
      } else {

      }
#line 9156
      btdm_2Ant8723APANEDRAction(padapter);
#line 9157
      goto ldv_56470;
      case 5: ;
#line 9159
      if (BTCoexDbgLevel == 1U) {
#line 9159
        printk("Action 2-Ant, algorithm = HS mode.\n");
      } else {

      }
#line 9160
      btdm_2Ant8723APANHSAction(padapter);
#line 9161
      goto ldv_56470;
      case 6: ;
#line 9163
      if (BTCoexDbgLevel == 1U) {
#line 9163
        printk("Action 2-Ant, algorithm = PAN+A2DP.\n");
      } else {

      }
#line 9164
      btdm_2Ant8723APANEDRA2DPAction(padapter);
#line 9165
      goto ldv_56470;
      case 7: ;
#line 9167
      if (BTCoexDbgLevel == 1U) {
#line 9167
        printk("Action 2-Ant, algorithm = PAN(EDR)+HID.\n");
      } else {

      }
#line 9168
      btdm_2Ant8723APANEDRHIDAction(padapter);
#line 9169
      goto ldv_56470;
      case 8: ;
#line 9171
      if (BTCoexDbgLevel == 1U) {
#line 9171
        printk("Action 2-Ant, algorithm = HID+A2DP+PAN.\n");
      } else {

      }
#line 9172
      btdm_2Ant8723AHIDA2DPPANEDRAction(padapter);
#line 9173
      goto ldv_56470;
      case 9: ;
#line 9175
      if (BTCoexDbgLevel == 1U) {
#line 9175
        printk("Action 2-Ant, algorithm = HID+A2DP.\n");
      } else {

      }
#line 9176
      btdm_2Ant8723AHIDA2DPAction(padapter);
#line 9177
      goto ldv_56470;
      default: ;
#line 9179
      if (BTCoexDbgLevel == 1U) {
#line 9179
        printk("Action 2-Ant, algorithm = 0.\n");
      } else {

      }
#line 9180
      btdm_2Ant8723AA2DPAction(padapter);
#line 9181
      goto ldv_56470;
      }
      ldv_56470: 
#line 9183
      pBtdm8723->preAlgorithm = pBtdm8723->curAlgorithm;
    }
  }
#line 9186
  return;
}
}
#line 9192 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 btCoexDbgBuf[100U]  ;
#line 9194 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static char const   * const  BtProfileString[5U]  = {      "NONE",      "A2DP",      "PAN",      "HID", 
        "SCO"};
#line 9202 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static char const   * const  BtSpecString[7U]  = {      "1.0b",      "1.1",      "1.2",      "2.0+EDR", 
        "2.1+EDR",      "3.0+HS",      "4.0"};
#line 9212 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static char const   * const  BtLinkRoleString[2U]  = {      "Master",      "Slave"};
#line 9217 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static u8 btdm_BtWifiAntNum(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;

  {
#line 9219
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9220
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9222
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U) {
#line 9223
    if ((unsigned int )pBtCoex->TotalAntNum == 0U) {
#line 9224
      return (0U);
    } else {
#line 9226
      return (1U);
    }
  } else {
#line 9228
    return (1U);
  }
#line 9230
  return (0U);
}
}
#line 9233 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_BtHwCountersMonitor(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 regHPTxRx ;
  u32 regLPTxRx ;
  u32 u4Tmp ;
  u32 regHPTx ;
  u32 regHPRx ;
  u32 regLPTx ;
  u32 regLPRx ;

  {
#line 9235
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9237
  regHPTx = 0U;
#line 9237
  regHPRx = 0U;
#line 9237
  regLPTx = 0U;
#line 9237
  regLPRx = 0U;
#line 9239
  regHPTxRx = 1904U;
#line 9240
  regLPTxRx = 1908U;
#line 9242
  u4Tmp = rtl8723au_read32(padapter, regHPTxRx);
#line 9243
  regHPTx = u4Tmp & 65535U;
#line 9244
  regHPRx = u4Tmp >> 16;
#line 9246
  u4Tmp = rtl8723au_read32(padapter, regLPTxRx);
#line 9247
  regLPTx = u4Tmp & 65535U;
#line 9248
  regLPRx = u4Tmp >> 16;
#line 9250
  pHalData->bt_coexist.halCoex8723.highPriorityTx = regHPTx;
#line 9251
  pHalData->bt_coexist.halCoex8723.highPriorityRx = regHPRx;
#line 9252
  pHalData->bt_coexist.halCoex8723.lowPriorityTx = regLPTx;
#line 9253
  pHalData->bt_coexist.halCoex8723.lowPriorityRx = regLPRx;
#line 9255
  if (BTCoexDbgLevel == 1U) {
#line 9255
    printk("High Priority Tx/Rx = %d / %d\n", regHPTx, regHPRx);
  } else {

  }
#line 9256
  if (BTCoexDbgLevel == 1U) {
#line 9256
    printk("Low Priority Tx/Rx = %d / %d\n", regLPTx, regLPRx);
  } else {

  }
#line 9259
  rtl8723au_write8(padapter, 1902U, 12);
#line 9260
  return;
}
}
#line 9263 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_BtEnableDisableCheck8723A(struct rtw_adapter *padapter ) 
{ 
  u8 btAlife ;
  struct hal_data_8723a *pHalData ;
  u8 tmp ;

  {
#line 9265
  btAlife = 1U;
#line 9266
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9281
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 0U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 0U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 0U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 0U) {
#line 9285
    btAlife = 0U;
  } else {

  }
#line 9286
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 60138U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 60138U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 60138U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 60138U) {
#line 9290
    btAlife = 0U;
  } else {

  }
#line 9291
  if (((pHalData->bt_coexist.halCoex8723.highPriorityTx == 65535U && pHalData->bt_coexist.halCoex8723.highPriorityRx == 65535U) && pHalData->bt_coexist.halCoex8723.lowPriorityTx == 65535U) && pHalData->bt_coexist.halCoex8723.lowPriorityRx == 65535U) {
#line 9295
    btAlife = 0U;
  } else {

  }
#line 9296
  if ((unsigned int )btAlife != 0U) {
#line 9297
    pHalData->bt_coexist.btActiveZeroCnt = 0U;
#line 9298
    pHalData->bt_coexist.bCurBtDisabled = 0U;
#line 9299
    if (BTCoexDbgLevel == 1U) {
#line 9299
      printk("8723A BT is enabled !!\n");
    } else {

    }
  } else {
#line 9301
    pHalData->bt_coexist.btActiveZeroCnt = (u8 )((int )pHalData->bt_coexist.btActiveZeroCnt + 1);
#line 9302
    if (BTCoexDbgLevel == 1U) {
#line 9302
      printk("8723A bt all counters = 0, %d times!!\n", (int )pHalData->bt_coexist.btActiveZeroCnt);
    } else {

    }
#line 9304
    if ((unsigned int )pHalData->bt_coexist.btActiveZeroCnt > 1U) {
#line 9305
      pHalData->bt_coexist.bCurBtDisabled = 1U;
#line 9306
      if (BTCoexDbgLevel == 1U) {
#line 9306
        printk("8723A BT is disabled !!\n");
      } else {

      }
    } else {

    }
  }
#line 9311
  if ((unsigned int )pHalData->bt_coexist.bCurBtDisabled == 0U) {
#line 9312
    tmp = BTDM_IsWifiConnectionExist(padapter);
#line 9312
    if ((unsigned int )tmp != 0U) {
#line 9313
      BTDM_SetFwChnlInfo(padapter, 1);
    } else {
#line 9315
      BTDM_SetFwChnlInfo(padapter, 0);
    }
  } else {

  }
#line 9318
  if ((int )pHalData->bt_coexist.bPreBtDisabled != (int )pHalData->bt_coexist.bCurBtDisabled) {
#line 9320
    if (BTCoexDbgLevel == 1U) {
#line 9320
      printk("8723A BT is from %s to %s!!\n", (unsigned int )pHalData->bt_coexist.bPreBtDisabled != 0U ? (char *)"disabled" : (char *)"enabled",
             (unsigned int )pHalData->bt_coexist.bCurBtDisabled != 0U ? (char *)"disabled" : (char *)"enabled");
    } else {

    }
#line 9323
    pHalData->bt_coexist.bPreBtDisabled = pHalData->bt_coexist.bCurBtDisabled;
  } else {

  }
#line 9325
  return;
}
}
#line 9327 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_BTCoexist8723AHandler(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 9331
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9333
  tmp = btdm_BtWifiAntNum(padapter);
#line 9333
  if ((unsigned int )tmp == 0U) {
#line 9334
    if (BTCoexDbgLevel == 1U) {
#line 9334
      printk("[BTCoex], 2 Ant mechanism\n");
    } else {

    }
#line 9335
    BTDM_2AntBtCoexist8723A(padapter);
  } else {
#line 9337
    if (BTCoexDbgLevel == 1U) {
#line 9337
      printk("[BTCoex], 1 Ant mechanism\n");
    } else {

    }
#line 9338
    BTDM_1AntBtCoexist8723A(padapter);
  }
#line 9341
  tmp___0 = BTDM_IsSameCoexistState(padapter);
#line 9341
  if ((unsigned int )tmp___0 == 0U) {
#line 9342
    if (BTCoexDbgLevel == 1U) {
#line 9342
      printk("[BTCoex], Coexist State[bitMap] change from 0x%llx to 0x%llx\n", pHalData->bt_coexist.PreviousState,
             pHalData->bt_coexist.CurrentState);
    } else {

    }
#line 9345
    pHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;
#line 9347
    if (BTCoexDbgLevel == 1U) {
#line 9347
      printk("[");
    } else {

    }
#line 9348
    if ((int )pHalData->bt_coexist.CurrentState & 1) {
#line 9349
      if (BTCoexDbgLevel == 1U) {
#line 9349
        printk("BT 3.0, ");
      } else {

      }
    } else {

    }
#line 9350
    if ((pHalData->bt_coexist.CurrentState & 2ULL) != 0ULL) {
#line 9351
      if (BTCoexDbgLevel == 1U) {
#line 9351
        printk("HT20, ");
      } else {

      }
    } else {

    }
#line 9352
    if ((pHalData->bt_coexist.CurrentState & 4ULL) != 0ULL) {
#line 9353
      if (BTCoexDbgLevel == 1U) {
#line 9353
        printk("HT40, ");
      } else {

      }
    } else {

    }
#line 9354
    if ((pHalData->bt_coexist.CurrentState & 8ULL) != 0ULL) {
#line 9355
      if (BTCoexDbgLevel == 1U) {
#line 9355
        printk("Legacy, ");
      } else {

      }
    } else {

    }
#line 9356
    if ((pHalData->bt_coexist.CurrentState & 16ULL) != 0ULL) {
#line 9357
      if (BTCoexDbgLevel == 1U) {
#line 9357
        printk("Rssi_Low, ");
      } else {

      }
    } else {

    }
#line 9358
    if ((pHalData->bt_coexist.CurrentState & 32ULL) != 0ULL) {
#line 9359
      if (BTCoexDbgLevel == 1U) {
#line 9359
        printk("Rssi_Mid, ");
      } else {

      }
    } else {

    }
#line 9360
    if ((pHalData->bt_coexist.CurrentState & 64ULL) != 0ULL) {
#line 9361
      if (BTCoexDbgLevel == 1U) {
#line 9361
        printk("Rssi_High, ");
      } else {

      }
    } else {

    }
#line 9362
    if ((pHalData->bt_coexist.CurrentState & 256ULL) != 0ULL) {
#line 9363
      if (BTCoexDbgLevel == 1U) {
#line 9363
        printk("Wifi_Idle, ");
      } else {

      }
    } else {

    }
#line 9364
    if ((pHalData->bt_coexist.CurrentState & 512ULL) != 0ULL) {
#line 9365
      if (BTCoexDbgLevel == 1U) {
#line 9365
        printk("Wifi_Uplink, ");
      } else {

      }
    } else {

    }
#line 9366
    if ((pHalData->bt_coexist.CurrentState & 1024ULL) != 0ULL) {
#line 9367
      if (BTCoexDbgLevel == 1U) {
#line 9367
        printk("Wifi_Downlink, ");
      } else {

      }
    } else {

    }
#line 9368
    if ((pHalData->bt_coexist.CurrentState & 4096ULL) != 0ULL) {
#line 9369
      if (BTCoexDbgLevel == 1U) {
#line 9369
        printk("BT_idle, ");
      } else {

      }
    } else {

    }
#line 9370
    if ((pHalData->bt_coexist.CurrentState & 1048576ULL) != 0ULL) {
#line 9371
      if (BTCoexDbgLevel == 1U) {
#line 9371
        printk("PRO_HID, ");
      } else {

      }
    } else {

    }
#line 9372
    if ((pHalData->bt_coexist.CurrentState & 2097152ULL) != 0ULL) {
#line 9373
      if (BTCoexDbgLevel == 1U) {
#line 9373
        printk("PRO_A2DP, ");
      } else {

      }
    } else {

    }
#line 9374
    if ((pHalData->bt_coexist.CurrentState & 4194304ULL) != 0ULL) {
#line 9375
      if (BTCoexDbgLevel == 1U) {
#line 9375
        printk("PRO_PAN, ");
      } else {

      }
    } else {

    }
#line 9376
    if ((pHalData->bt_coexist.CurrentState & 8388608ULL) != 0ULL) {
#line 9377
      if (BTCoexDbgLevel == 1U) {
#line 9377
        printk("PRO_SCO, ");
      } else {

      }
    } else {

    }
#line 9378
    if (BTCoexDbgLevel == 1U) {
#line 9378
      printk("]\n");
    } else {

    }
  } else {

  }
#line 9380
  return;
}
}
#line 9383 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u32 BTDM_BtTxRxCounterH(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 counters ;

  {
#line 9385
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9386
  counters = 0U;
#line 9388
  counters = pHalData->bt_coexist.halCoex8723.highPriorityTx + pHalData->bt_coexist.halCoex8723.highPriorityRx;
#line 9390
  return (counters);
}
}
#line 9393 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u32 BTDM_BtTxRxCounterL(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u32 counters ;

  {
#line 9395
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9396
  counters = 0U;
#line 9398
  counters = pHalData->bt_coexist.halCoex8723.lowPriorityTx + pHalData->bt_coexist.halCoex8723.lowPriorityRx;
#line 9400
  return (counters);
}
}
#line 9403 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_SetFwChnlInfo(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  u8 chnl ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;
  u8 tmp___3 ;

  {
#line 9405
  pmlmeext = & padapter->mlmeextpriv;
#line 9406
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9407
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9408
  H2C_Parameter[0] = 0U;
#line 9408
  tmp = 1U;
#line 9408
  while (1) {
#line 9408
    if (tmp >= 3U) {
#line 9408
      break;
    } else {

    }
#line 9408
    H2C_Parameter[tmp] = (unsigned char)0;
#line 9408
    tmp = tmp + 1U;
  }
#line 9412
  if ((unsigned int )mstatus == 1U) {
#line 9413
    H2C_Parameter[0] = 1U;
  } else {

  }
#line 9415
  tmp___2 = check_fwstate(& padapter->mlmepriv, 1);
#line 9415
  if ((int )tmp___2) {
#line 9417
    chnl = pmlmeext->cur_channel;
#line 9418
    tmp___0 = BTDM_IsHT40(padapter);
#line 9418
    if ((unsigned int )tmp___0 != 0U) {
#line 9419
      if ((unsigned int )pmlmeext->cur_ch_offset == 2U) {
#line 9420
        chnl = (unsigned int )chnl + 254U;
      } else
#line 9421
      if ((unsigned int )pmlmeext->cur_ch_offset == 1U) {
#line 9422
        chnl = (unsigned int )chnl + 2U;
      } else {

      }
    } else {

    }
#line 9424
    H2C_Parameter[1] = chnl;
  } else {
#line 9427
    tmp___1 = BT_Operation(padapter);
#line 9427
    if ((unsigned int )tmp___1 != 0U) {
#line 9428
      H2C_Parameter[1] = pBtMgnt->BTChannel;
    } else {
#line 9430
      H2C_Parameter[1] = pmlmeext->cur_channel;
    }
  }
#line 9433
  tmp___3 = BTDM_IsHT40(padapter);
#line 9433
  if ((unsigned int )tmp___3 != 0U) {
#line 9434
    H2C_Parameter[2] = 48U;
  } else {
#line 9436
    H2C_Parameter[2] = 32U;
  }
#line 9438
  FillH2CCmd(padapter, 25, 3U, (u8 *)(& H2C_Parameter));
#line 9439
  return;
}
}
#line 9441 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsWifiConnectionExist(struct rtw_adapter *padapter ) 
{ 
  u8 bRet ;
  u8 tmp ;
  bool tmp___0 ;

  {
#line 9443
  bRet = 0U;
#line 9445
  tmp = BTHCI_HsConnectionEstablished(padapter);
#line 9445
  if ((unsigned int )tmp != 0U) {
#line 9446
    bRet = 1U;
  } else {

  }
#line 9448
  tmp___0 = check_fwstate(& padapter->mlmepriv, 1);
#line 9448
  if ((int )tmp___0) {
#line 9449
    bRet = 1U;
  } else {

  }
#line 9451
  return (bRet);
}
}
#line 9454 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_SetFw3a(struct rtw_adapter *padapter , u8 byte1 , u8 byte2 , u8 byte3 ,
                  u8 byte4 , u8 byte5 ) 
{ 
  u8 H2C_Parameter[5U] ;
  unsigned int tmp ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 BtState ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 9463
  H2C_Parameter[0] = 0U;
#line 9463
  tmp = 1U;
#line 9463
  while (1) {
#line 9463
    if (tmp >= 5U) {
#line 9463
      break;
    } else {

    }
#line 9463
    H2C_Parameter[tmp] = (unsigned char)0;
#line 9463
    tmp = tmp + 1U;
  }
#line 9465
  tmp___3 = rtl8723a_BT_using_antenna_1(padapter);
#line 9465
  if ((int )tmp___3) {
#line 9466
    tmp___0 = check_fwstate(& padapter->mlmepriv, 8);
#line 9466
    if (tmp___0) {
#line 9466
      tmp___1 = 0;
    } else {
#line 9466
      tmp___1 = 1;
    }
#line 9466
    if (tmp___1) {
#line 9466
      tmp___2 = get_fwstate(& padapter->mlmepriv);
#line 9466
      if (tmp___2 != 0) {
#line 9469
        pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9470
        pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9471
        BtState = pBtCoex->c2hBtInfo;
#line 9473
        if ((unsigned int )BtState != 1U && (unsigned int )BtState != 2U) {
#line 9475
          if (((unsigned long )byte1 & 16UL) != 0UL) {
#line 9476
            byte1 = (unsigned int )byte1 & 239U;
#line 9477
            byte1 = (u8 )((unsigned int )byte1 | 32U);
          } else {

          }
#line 9480
          byte5 = (u8 )((unsigned int )byte5 | 32U);
#line 9481
          if (((unsigned long )byte5 & 64UL) != 0UL) {
#line 9482
            byte5 = (unsigned int )byte5 & 191U;
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 9487
  H2C_Parameter[0] = byte1;
#line 9488
  H2C_Parameter[1] = byte2;
#line 9489
  H2C_Parameter[2] = byte3;
#line 9490
  H2C_Parameter[3] = byte4;
#line 9491
  H2C_Parameter[4] = byte5;
#line 9493
  if (BTCoexDbgLevel == 1U) {
#line 9493
    printk("[BTCoex], FW write 0x3a(5bytes) = 0x%02x%08x\n", (int )H2C_Parameter[0],
           ((((int )H2C_Parameter[1] << 24) | ((int )H2C_Parameter[2] << 16)) | ((int )H2C_Parameter[3] << 8)) | (int )H2C_Parameter[4]);
  } else {

  }
#line 9497
  FillH2CCmd(padapter, 58, 5U, (u8 *)(& H2C_Parameter));
#line 9498
  return;
}
}
#line 9500 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_QueryBtInformation(struct rtw_adapter *padapter ) 
{ 
  u8 H2C_Parameter[1U] ;
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;
  int tmp___0 ;

  {
#line 9502
  H2C_Parameter[0] = 0U;
#line 9506
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9507
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9509
  tmp = rtl8723a_BT_enabled(padapter);
#line 9509
  if (tmp) {
#line 9509
    tmp___0 = 0;
  } else {
#line 9509
    tmp___0 = 1;
  }
#line 9509
  if (tmp___0) {
#line 9510
    pBtCoex->c2hBtInfo = 0U;
#line 9511
    pBtCoex->bC2hBtInfoReqSent = 0U;
#line 9512
    return;
  } else {

  }
#line 9515
  if ((unsigned int )pBtCoex->c2hBtInfo == 0U) {
#line 9516
    pBtCoex->c2hBtInfo = 1U;
  } else {

  }
#line 9518
  if ((unsigned int )pBtCoex->bC2hBtInfoReqSent == 1U) {
#line 9519
    if (BTCoexDbgLevel == 1U) {
#line 9519
      printk("[BTCoex], didn\'t recv previous BtInfo report!\n");
    } else {

    }
  } else {
#line 9521
    pBtCoex->bC2hBtInfoReqSent = 1U;
  }
#line 9523
  H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 1U);
#line 9528
  FillH2CCmd(padapter, 56, 1U, (u8 *)(& H2C_Parameter));
#line 9529
  return;
}
}
#line 9531 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_SetSwRfRxLpfCorner(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 9533
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9535
  if ((unsigned int )type == 1U) {
#line 9537
    if (BTCoexDbgLevel == 1U) {
#line 9537
      printk("Shrink RF Rx LPF corner!!\n");
    } else {

    }
#line 9538
    PHY_SetRFReg(padapter, 0, 30U, 1048575U, 987127U);
#line 9539
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else
#line 9540
  if ((unsigned int )type == 0U) {
#line 9542
    if (BTCoexDbgLevel == 1U) {
#line 9542
      printk("Resume RF Rx LPF corner!!\n");
    } else {

    }
#line 9543
    PHY_SetRFReg(padapter, 0, 30U, 1048575U, pHalData->bt_coexist.BtRfRegOrigin1E);
  } else {

  }
#line 9545
  return;
}
}
#line 9548 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_SetSwPenaltyTxRateAdaptive(struct rtw_adapter *padapter , u8 raType ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmpU1 ;

  {
#line 9553
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9556
  tmpU1 = rtl8723au_read8(padapter, 1277U);
#line 9557
  tmpU1 = (u8 )((unsigned int )tmpU1 | 1U);
#line 9558
  if ((unsigned int )raType == 1U) {
#line 9559
    tmpU1 = (unsigned int )tmpU1 & 251U;
#line 9560
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else
#line 9561
  if ((unsigned int )raType == 0U) {
#line 9562
    tmpU1 = (u8 )((unsigned int )tmpU1 | 4U);
  } else {

  }
#line 9565
  rtl8723au_write8(padapter, 1277U, (int )tmpU1);
#line 9566
  return;
}
}
#line 9568 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_SetFwDecBtPwr(struct rtw_adapter *padapter , u8 bDecBtPwr ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[1U] ;

  {
#line 9570
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9571
  H2C_Parameter[0] = 0U;
#line 9573
  H2C_Parameter[0] = 0U;
#line 9575
  if ((unsigned int )bDecBtPwr != 0U) {
#line 9576
    H2C_Parameter[0] = (u8 )((unsigned int )H2C_Parameter[0] | 2U);
#line 9577
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 9580
  if (BTCoexDbgLevel == 1U) {
#line 9580
    printk("[BTCoex], decrease Bt Power : %s, write 0x21 = 0x%x\n", (unsigned int )bDecBtPwr != 0U ? (char *)"Yes!!" : (char *)"No!!",
           (int )H2C_Parameter[0]);
  } else {

  }
#line 9583
  FillH2CCmd(padapter, 33, 1U, (u8 *)(& H2C_Parameter));
#line 9584
  return;
}
}
#line 9586 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_BtProfileSupport(struct rtw_adapter *padapter ) 
{ 
  u8 bRet ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;

  {
#line 9588
  bRet = 0U;
#line 9589
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9590
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9591
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9593
  if ((unsigned int )pBtMgnt->bSupportProfile != 0U && (unsigned int )pHalData->bt_coexist.halCoex8723.bForceFwBtInfo == 0U) {
#line 9595
    bRet = 1U;
  } else {

  }
#line 9597
  return (bRet);
}
}
#line 9600 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_AdjustForBtOperation8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 9602
  return;
}
}
#line 9605 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_FwC2hBtRssi8723A(struct rtw_adapter *padapter , u8 *tmpBuf ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 percent ;
  u8 u1tmp ;

  {
#line 9607
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9608
  percent = 0U;
#line 9608
  u1tmp = 0U;
#line 9610
  u1tmp = *tmpBuf;
#line 9611
  percent = (unsigned int )((u8 )((int )u1tmp + 5)) * 2U;
#line 9613
  pHalData->bt_coexist.halCoex8723.btRssi = percent;
#line 9614
  return;
}
}
#line 9618 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_fw_c2h_BT_info(struct rtw_adapter *padapter , u8 *tmpBuf , u8 length ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  u8 i ;
  u8 tmp ;

  {
#line 9626
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9627
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9628
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9629
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9631
  pBtCoex->bC2hBtInfoReqSent = 0U;
#line 9633
  if (BTCoexDbgLevel == 1U) {
#line 9633
    printk("[BTC2H], BT info[%d]=[", (int )length);
  } else {

  }
#line 9635
  pBtCoex->btRetryCnt = 0U;
#line 9636
  i = 0U;
#line 9636
  goto ldv_56600;
  ldv_56599: ;
#line 9637
  switch ((int )i) {
  case 0: 
#line 9639
  pBtCoex->c2hBtInfoOriginal = *(tmpBuf + (unsigned long )i);
#line 9640
  goto ldv_56595;
  case 1: 
#line 9642
  pBtCoex->btRetryCnt = *(tmpBuf + (unsigned long )i);
#line 9643
  goto ldv_56595;
  case 2: 
#line 9645
  BTDM_FwC2hBtRssi8723A(padapter, tmpBuf + (unsigned long )i);
#line 9646
  goto ldv_56595;
  case 3: 
#line 9648
  pBtCoex->btInfoExt = (unsigned int )*(tmpBuf + (unsigned long )i) & 1U;
#line 9649
  goto ldv_56595;
  }
  ldv_56595: ;
#line 9652
  if ((int )i == (int )length + -1) {
#line 9653
    if (BTCoexDbgLevel == 1U) {
#line 9653
      printk("0x%02x]\n", (int )*(tmpBuf + (unsigned long )i));
    } else {

    }
  } else
#line 9655
  if (BTCoexDbgLevel == 1U) {
#line 9655
    printk("0x%02x, ", (int )*(tmpBuf + (unsigned long )i));
  } else {

  }
#line 9636
  i = (u8 )((int )i + 1);
  ldv_56600: ;
#line 9636
  if ((int )i < (int )length) {
#line 9638
    goto ldv_56599;
  } else {

  }

#line 9657
  if (BTCoexDbgLevel == 1U) {
#line 9657
    printk("[BTC2H], BT RSSI =%d\n", (int )pBtCoex->btRssi);
  } else {

  }
#line 9658
  if ((unsigned int )pBtCoex->btInfoExt != 0U) {
#line 9659
    if (BTCoexDbgLevel == 1U) {
#line 9659
      printk("[BTC2H], pBtCoex->btInfoExt =%x\n", (int )pBtCoex->btInfoExt);
    } else {

    }
  } else {

  }
#line 9661
  tmp = btdm_BtWifiAntNum(padapter);
#line 9661
  if ((unsigned int )tmp == 1U) {
#line 9662
    BTDM_1AntFwC2hBtInfo8723A(padapter);
  } else {
#line 9664
    BTDM_2AntFwC2hBtInfo8723A(padapter);
  }
#line 9666
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9667
    if (BTCoexDbgLevel == 1U) {
#line 9667
      printk("%s: Action Manual control!!\n", "rtl8723a_fw_c2h_BT_info");
    } else {

    }
#line 9668
    return;
  } else {

  }
#line 9671
  btdm_BTCoexist8723AHandler(padapter);
#line 9672
  return;
}
}
#line 9674 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_Display8723ABtCoexInfo(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 u1Tmp ;
  u8 u1Tmp1 ;
  u8 u1Tmp2 ;
  u8 i ;
  u8 btInfoExt ;
  u8 psTdmaCase ;
  u32 u4Tmp[4U] ;
  u8 antNum ;
  bool tmp ;
  int tmp___0 ;
  s32 tmp___1 ;
  u8 tmp___3 ;
  char *tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___7 ;
  char *tmp___8 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  u8 tmp___11 ;
  u8 tmp___12 ;
  u8 tmp___13 ;
  u8 tmp___14 ;

  {
#line 9676
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9677
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9678
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9679
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9680
  psTdmaCase = 0U;
#line 9682
  antNum = 0U;
#line 9684
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n ============[BT Coexist info]============");
#line 9687
  tmp = rtl8723a_BT_coexist(padapter);
#line 9687
  if (tmp) {
#line 9687
    tmp___0 = 0;
  } else {
#line 9687
    tmp___0 = 1;
  }
#line 9687
  if (tmp___0) {
#line 9688
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n BT not exists !!!");
#line 9690
    return;
  } else {

  }
#line 9693
  antNum = btdm_BtWifiAntNum(padapter);
#line 9694
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d/%d ", (char *)"Ant mechanism PG/Now run :",
           (unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U ? 2 : 1, (unsigned int )antNum == 0U ? 2 : 1);
#line 9698
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9699
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"[Action Manual control]!!");
  } else {
#line 9702
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s / %d", (char *)"BT stack/ hci ext ver",
             (unsigned int )pBtMgnt->bSupportProfile != 0U ? (char *)"Yes" : (char *)"No",
             (int )pBtMgnt->ExtConfig.HCIExtensionVer);
  }
#line 9707
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = / %d", (char *)"Dot11 channel / BT channel",
           (int )pBtMgnt->BTChannel);
#line 9711
  tmp___1 = BTDM_GetRxSS(padapter);
#line 9711
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = %d / %d / %d", (char *)"Wifi/BT/HS rssi",
           tmp___1, (int )pHalData->bt_coexist.halCoex8723.btRssi, pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB);
#line 9717
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9718
    tmp___5 = BTDM_IsWifiBusy(padapter);
#line 9718
    if ((unsigned int )tmp___5 != 0U) {
#line 9718
      tmp___3 = BTDM_IsWifiUplink(padapter);
#line 9718
      tmp___4 = (unsigned int )tmp___3 != 0U ? (char *)"uplink" : (char *)"downlink";
    } else {
#line 9718
      tmp___4 = (char *)"idle";
    }
#line 9718
    tmp___9 = BTDM_Legacy(padapter);
#line 9718
    if ((unsigned int )tmp___9 == 0U) {
#line 9718
      tmp___7 = BTDM_IsHT40(padapter);
#line 9718
      tmp___8 = (unsigned int )tmp___7 != 0U ? (char *)"HT40" : (char *)"HT20";
    } else {
#line 9718
      tmp___8 = (char *)"Legacy";
    }
#line 9718
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\n %-35s = %s / %s ", (char *)"WIfi status",
             tmp___8, tmp___4);
#line 9723
    if ((unsigned int )pBtMgnt->bSupportProfile != 0U) {
#line 9724
      tmp___10 = BTHCI_CheckProfileExist(padapter, 1);
#line 9724
      tmp___11 = BTHCI_CheckProfileExist(padapter, 2);
#line 9724
      tmp___12 = BTHCI_CheckProfileExist(padapter, 3);
#line 9724
      tmp___13 = BTHCI_CheckProfileExist(padapter, 4);
#line 9724
      snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d / %d / %d",
               (char *)"SCO/HID/PAN/A2DP", (unsigned int )tmp___13 != 0U, (unsigned int )tmp___12 != 0U,
               (unsigned int )tmp___11 != 0U, (unsigned int )tmp___10 != 0U);
#line 9731
      i = 0U;
#line 9731
      goto ldv_56619;
      ldv_56618: ;
#line 9732
      if ((unsigned int )pBtMgnt->ExtConfig.HCIExtensionVer != 0U) {
#line 9733
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s/ %s/ %s", (char *)"Bt link type/spec/role",
                 BtProfileString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile],
                 BtSpecString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec],
                 BtLinkRoleString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].linkRole]);
#line 9739
        btInfoExt = pHalData->bt_coexist.halCoex8723.btInfoExt;
#line 9740
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s", (char *)"A2DP rate",
                 (int )btInfoExt & 1 ? (char *)"Basic rate" : (char *)"EDR rate");
      } else {
#line 9745
        snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %s/ %s", (char *)"Bt link type/spec",
                 BtProfileString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTProfile],
                 BtSpecString[(int )pBtMgnt->ExtConfig.linkInfo[(int )i].BTCoreSpec]);
      }
#line 9731
      i = (u8 )((int )i + 1);
      ldv_56619: ;
#line 9731
      if ((int )pBtMgnt->ExtConfig.NumberOfHandle > (int )i) {
#line 9733
        goto ldv_56618;
      } else {

      }

    } else {

    }
  } else {

  }
#line 9755
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9756
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Sw BT Coex mechanism]============");
#line 9758
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"AGC Table",
             (int )pBtCoex->btdm2Ant.bCurAgcTableEn);
#line 9761
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"ADC Backoff",
             (int )pBtCoex->btdm2Ant.bCurAdcBackOff);
#line 9764
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"Low penalty RA",
             (int )pBtCoex->btdm2Ant.bCurLowPenaltyRa);
#line 9767
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"RF Rx LPF Shrink",
             (int )pBtCoex->btdm2Ant.bCurRfRxLpfShrink);
  } else {

  }
#line 9771
  u4Tmp[0] = PHY_QueryRFReg(padapter, 0, 30U, 4080U);
#line 9772
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x", (char *)"RF-A, 0x1e[11:4]/original val",
           u4Tmp[0], pHalData->bt_coexist.BtRfRegOrigin1E);
#line 9777
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9778
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Fw BT Coex mechanism]============");
  } else {

  }
#line 9781
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9782
    tmp___14 = btdm_BtWifiAntNum(padapter);
#line 9782
    if ((unsigned int )tmp___14 == 1U) {
#line 9783
      psTdmaCase = pHalData->bt_coexist.halCoex8723.btdm1Ant.curPsTdma;
    } else {
#line 9785
      psTdmaCase = pHalData->bt_coexist.halCoex8723.btdm2Ant.curPsTdma;
    }
#line 9786
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %02x %02x %02x %02x %02x case-%d",
             (char *)"PS TDMA(0x3a)", (int )pHalData->bt_coexist.fw3aVal[0], (int )pHalData->bt_coexist.fw3aVal[1],
             (int )pHalData->bt_coexist.fw3aVal[2], (int )pHalData->bt_coexist.fw3aVal[3],
             (int )pHalData->bt_coexist.fw3aVal[4], (int )psTdmaCase);
#line 9792
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d ", (char *)"Decrease Bt Power",
             (int )pBtCoex->btdm2Ant.bCurDecBtPwr);
  } else {

  }
#line 9796
  u1Tmp = rtl8723au_read8(padapter, 1912U);
#line 9797
  u1Tmp1 = rtl8723au_read8(padapter, 1923U);
#line 9798
  u1Tmp2 = rtl8723au_read8(padapter, 1942U);
#line 9799
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", (char *)"0x778/ 0x783/ 0x796",
           (int )u1Tmp, (int )u1Tmp1, (int )u1Tmp2);
#line 9803
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9804
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x / 0x%x", (char *)"Sw DacSwing Ctrl/Val",
             (int )pBtCoex->btdm2Ant.bCurDacSwingOn, pBtCoex->btdm2Ant.curDacSwingLvl);
  } else {

  }
#line 9808
  u4Tmp[0] = rtl8723au_read32(padapter, 2176U);
#line 9809
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x880",
           u4Tmp[0]);
#line 9814
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl == 0U) {
#line 9815
    snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s", (char *)"============[Hw BT Coex mechanism]============");
  } else {

  }
#line 9819
  u1Tmp = rtl8723au_read8(padapter, 64U);
#line 9820
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x40", (int )u1Tmp);
#line 9824
  u4Tmp[0] = rtl8723au_read32(padapter, 1360U);
#line 9825
  u1Tmp = rtl8723au_read8(padapter, 1314U);
#line 9826
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/0x%x", (char *)"0x550(bcn contrl)/0x522",
           u4Tmp[0], (int )u1Tmp);
#line 9830
  u4Tmp[0] = rtl8723au_read32(padapter, 1156U);
#line 9831
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x484(rate adaptive)",
           u4Tmp[0]);
#line 9835
  u4Tmp[0] = rtl8723au_read32(padapter, 80U);
#line 9836
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0xc50(dig)",
           u4Tmp[0]);
#line 9840
  u4Tmp[0] = rtl8723au_read32(padapter, 3488U);
#line 9841
  u4Tmp[1] = rtl8723au_read32(padapter, 3492U);
#line 9842
  u4Tmp[2] = rtl8723au_read32(padapter, 3496U);
#line 9843
  u4Tmp[3] = rtl8723au_read32(padapter, 3500U);
#line 9844
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
           (char *)"0xda0/0xda4/0xda8/0xdac(FA cnt)", u4Tmp[0], u4Tmp[1], u4Tmp[2],
           u4Tmp[3]);
#line 9848
  u4Tmp[0] = rtl8723au_read32(padapter, 1728U);
#line 9849
  u4Tmp[1] = rtl8723au_read32(padapter, 1732U);
#line 9850
  u4Tmp[2] = rtl8723au_read32(padapter, 1736U);
#line 9851
  u1Tmp = rtl8723au_read8(padapter, 1740U);
#line 9852
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x",
           (char *)"0x6c0/0x6c4/0x6c8/0x6cc(coexTable)", u4Tmp[0], u4Tmp[1], u4Tmp[2],
           (int )u1Tmp);
#line 9857
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d", (char *)"0x770(Hi pri Rx[31:16]/Tx[15:0])",
           pHalData->bt_coexist.halCoex8723.highPriorityRx, pHalData->bt_coexist.halCoex8723.highPriorityTx);
#line 9862
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = %d / %d", (char *)"0x774(Lo pri Rx[31:16]/Tx[15:0])",
           pHalData->bt_coexist.halCoex8723.lowPriorityRx, pHalData->bt_coexist.halCoex8723.lowPriorityTx);
#line 9868
  u1Tmp = rtl8723au_read8(padapter, 1051U);
#line 9869
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"0x41b (hang chk == 0xf)",
           (int )u1Tmp);
#line 9872
  snprintf((char *)(& btCoexDbgBuf), 100UL, "\r\n %-35s = 0x%x", (char *)"lastHMEBoxNum",
           (int )pHalData->LastHMEBoxNum);
#line 9874
  return;
}
}
#line 9878 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_8723ASignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi ,
                                         u8 *rssi_bt ) 
{ 
  u8 tmp ;

  {
#line 9881
  tmp = btdm_BtWifiAntNum(padapter);
#line 9881
  if ((unsigned int )tmp == 1U) {
#line 9882
    BTDM_1AntSignalCompensation(padapter, rssi_wifi, rssi_bt);
  } else {

  }
#line 9883
  return;
}
}
#line 9885 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_8723AInit(struct rtw_adapter *padapter ) 
{ 
  u8 tmp ;

  {
#line 9887
  tmp = btdm_BtWifiAntNum(padapter);
#line 9887
  if ((unsigned int )tmp == 0U) {
#line 9888
    BTDM_2AntParaInit(padapter);
  } else {
#line 9890
    BTDM_1AntParaInit(padapter);
  }
#line 9891
  return;
}
}
#line 9893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_HWCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9895
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9896
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9898
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9899
    return;
  } else {

  }
#line 9901
  tmp = btdm_BtWifiAntNum(padapter);
#line 9901
  if ((unsigned int )tmp == 0U) {
#line 9902
    BTDM_2AntHwCoexAllOff8723A(padapter);
  } else {

  }
#line 9903
  return;
}
}
#line 9905 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_FWCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9907
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9908
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9910
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9911
    return;
  } else {

  }
#line 9913
  tmp = btdm_BtWifiAntNum(padapter);
#line 9913
  if ((unsigned int )tmp == 0U) {
#line 9914
    BTDM_2AntFwCoexAllOff8723A(padapter);
  } else {

  }
#line 9915
  return;
}
}
#line 9917 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_SWCoexAllOff8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9919
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9920
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9922
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9923
    return;
  } else {

  }
#line 9925
  tmp = btdm_BtWifiAntNum(padapter);
#line 9925
  if ((unsigned int )tmp == 0U) {
#line 9926
    BTDM_2AntSwCoexAllOff8723A(padapter);
  } else {

  }
#line 9927
  return;
}
}
#line 9930 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_Set8723ABtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_coexist_8723a *pBtCoex ;

  {
#line 9932
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 9933
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 9935
  if ((unsigned int )antNum == 1U) {
#line 9936
    pBtCoex->TotalAntNum = 1U;
  } else
#line 9937
  if ((unsigned int )antNum == 2U) {
#line 9938
    pBtCoex->TotalAntNum = 0U;
  } else {

  }
#line 9939
  return;
}
}
#line 9941 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_BT_lps_leave(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9943
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9944
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9946
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9947
    return;
  } else {

  }
#line 9949
  tmp = btdm_BtWifiAntNum(padapter);
#line 9949
  if ((unsigned int )tmp == 1U) {
#line 9950
    BTDM_1AntLpsLeave(padapter);
  } else {

  }
#line 9951
  return;
}
}
#line 9953 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_ForHalt8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9955
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9956
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9958
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9959
    return;
  } else {

  }
#line 9961
  tmp = btdm_BtWifiAntNum(padapter);
#line 9961
  if ((unsigned int )tmp == 1U) {
#line 9962
    BTDM_1AntForHalt(padapter);
  } else {

  }
#line 9963
  return;
}
}
#line 9965 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_WifiScanNotify8723A(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9967
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9968
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9970
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9971
    return;
  } else {

  }
#line 9973
  tmp = btdm_BtWifiAntNum(padapter);
#line 9973
  if ((unsigned int )tmp == 1U) {
#line 9974
    BTDM_1AntWifiScanNotify(padapter, (int )scanType);
  } else {

  }
#line 9975
  return;
}
}
#line 9978 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_WifiAssociateNotify8723A(struct rtw_adapter *padapter , u8 action ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9980
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9981
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9983
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 9984
    return;
  } else {

  }
#line 9986
  tmp = btdm_BtWifiAntNum(padapter);
#line 9986
  if ((unsigned int )tmp == 1U) {
#line 9987
    BTDM_1AntWifiAssociateNotify(padapter, (int )action);
  } else {

  }
#line 9988
  return;
}
}
#line 9991 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_MediaStatusNotify8723A(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 9994
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 9995
  pBtMgnt = & pBTInfo->BtMgnt;
#line 9997
  if (BTCoexDbgLevel == 1U) {
#line 9997
    printk("[BTCoex], MediaStatusNotify, %s\n", (unsigned int )mstatus != 0U ? (char *)"connect" : (char *)"disconnect");
  } else {

  }
#line 10000
  BTDM_SetFwChnlInfo(padapter, mstatus);
#line 10002
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 10003
    return;
  } else {

  }
#line 10005
  tmp = btdm_BtWifiAntNum(padapter);
#line 10005
  if ((unsigned int )tmp == 1U) {
#line 10006
    BTDM_1AntMediaStatusNotify(padapter, mstatus);
  } else {

  }
#line 10007
  return;
}
}
#line 10009 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_ForDhcp8723A(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;

  {
#line 10011
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10012
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10014
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 10015
    return;
  } else {

  }
#line 10017
  tmp = btdm_BtWifiAntNum(padapter);
#line 10017
  if ((unsigned int )tmp == 1U) {
#line 10018
    BTDM_1AntForDhcp(padapter);
  } else {

  }
#line 10019
  return;
}
}
#line 10021 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
bool rtl8723a_BT_using_antenna_1(struct rtw_adapter *padapter ) 
{ 
  u8 tmp ;

  {
#line 10023
  tmp = btdm_BtWifiAntNum(padapter);
#line 10023
  if ((unsigned int )tmp == 1U) {
#line 10024
    return (1);
  } else {
#line 10026
    return (0);
  }
}
}
#line 10029 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_BTCoexist8723A(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_coexist_8723a *pBtCoex ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 10036
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10037
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10038
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10039
  pBtCoex = & pHalData->bt_coexist.halCoex8723;
#line 10041
  if (BTCoexDbgLevel == 1U) {
#line 10041
    printk("[BTCoex], beacon RSSI = 0x%x(%d)\n", pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB,
           pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB);
  } else {

  }
#line 10045
  btdm_BtHwCountersMonitor(padapter);
#line 10046
  btdm_BtEnableDisableCheck8723A(padapter);
#line 10048
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 10049
    if (BTCoexDbgLevel == 1U) {
#line 10049
      printk("%s: Action Manual control!!\n", "BTDM_BTCoexist8723A");
    } else {

    }
#line 10050
    return;
  } else {

  }
#line 10053
  if ((unsigned int )pBtCoex->bC2hBtInfoReqSent != 0U) {
#line 10054
    tmp = rtl8723a_BT_enabled(padapter);
#line 10054
    if (tmp) {
#line 10054
      tmp___0 = 0;
    } else {
#line 10054
      tmp___0 = 1;
    }
#line 10054
    if (tmp___0) {
#line 10055
      pBtCoex->c2hBtInfo = 0U;
    } else
#line 10057
    if ((unsigned int )pBtCoex->c2hBtInfo == 0U) {
#line 10058
      pBtCoex->c2hBtInfo = 1U;
    } else {

    }
#line 10061
    btdm_BTCoexist8723AHandler(padapter);
  } else {
#line 10062
    tmp___1 = rtl8723a_BT_enabled(padapter);
#line 10062
    if (tmp___1) {
#line 10062
      tmp___2 = 0;
    } else {
#line 10062
      tmp___2 = 1;
    }
#line 10062
    if (tmp___2) {
#line 10063
      pBtCoex->c2hBtInfo = 0U;
#line 10064
      btdm_BTCoexist8723AHandler(padapter);
    } else {

    }
  }
#line 10067
  BTDM_QueryBtInformation(padapter);
#line 10068
  return;
}
}
#line 10077 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void BTDM_SetAntenna(struct rtw_adapter *padapter , u8 who ) 
{ 


  {
#line 10079
  return;
}
}
#line 10082 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_SingleAnt(struct rtw_adapter *padapter , u8 bSingleAntOn , u8 bInterruptOn ,
                    u8 bMultiNAVOn ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;

  {
#line 10089
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10090
  H2C_Parameter[0] = 0U;
#line 10090
  tmp = 1U;
#line 10090
  while (1) {
#line 10090
    if (tmp >= 3U) {
#line 10090
      break;
    } else {

    }
#line 10090
    H2C_Parameter[tmp] = (unsigned char)0;
#line 10090
    tmp = tmp + 1U;
  }
#line 10092
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 1U) {
#line 10093
    return;
  } else {

  }
#line 10095
  H2C_Parameter[2] = 0U;
#line 10096
  H2C_Parameter[1] = 0U;
#line 10097
  H2C_Parameter[0] = 0U;
#line 10099
  if ((unsigned int )bInterruptOn != 0U) {
#line 10100
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 2U);
#line 10101
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 10103
  pHalData->bt_coexist.bInterruptOn = bInterruptOn;
#line 10105
  if ((unsigned int )bSingleAntOn != 0U) {
#line 10106
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 16U);
#line 10107
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 10109
  pHalData->bt_coexist.bSingleAntOn = bSingleAntOn;
#line 10111
  if ((unsigned int )bMultiNAVOn != 0U) {
#line 10112
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 32U);
#line 10113
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 10115
  pHalData->bt_coexist.bMultiNAVOn = bMultiNAVOn;
#line 10117
  if (BTCoexDbgLevel == 1U) {
#line 10117
    printk("[DM][BT], SingleAntenna =[%s:%s:%s], write 0xe = 0x%x\n", (unsigned int )bSingleAntOn != 0U ? (char *)"ON" : (char *)"OFF",
           (unsigned int )bInterruptOn != 0U ? (char *)"ON" : (char *)"OFF", (unsigned int )bMultiNAVOn != 0U ? (char *)"ON" : (char *)"OFF",
           (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {

  }
#line 10118
  return;
}
}
#line 10122 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_CheckBTIdleChange1Ant(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 stateChange ;
  u32 BT_Polling ;
  u32 Ratio_Act ;
  u32 Ratio_STA ;
  u32 BT_Active ;
  u32 BT_State ;
  u32 regBTActive ;
  u32 regBTState ;
  u32 regBTPolling ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 10124
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10125
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10126
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10128
  stateChange = 0U;
#line 10131
  regBTActive = 0U;
#line 10131
  regBTState = 0U;
#line 10131
  regBTPolling = 0U;
#line 10133
  tmp = rtl8723a_BT_coexist(padapter);
#line 10133
  if (tmp) {
#line 10133
    tmp___0 = 0;
  } else {
#line 10133
    tmp___0 = 1;
  }
#line 10133
  if (tmp___0) {
#line 10134
    return;
  } else {

  }
#line 10135
  if ((unsigned int )pBtMgnt->ExtConfig.bManualControl != 0U) {
#line 10136
    return;
  } else {

  }
#line 10137
  if ((unsigned int )pHalData->bt_coexist.BT_CoexistType != 4U) {
#line 10138
    return;
  } else {

  }
#line 10139
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 1U) {
#line 10140
    return;
  } else {

  }
#line 10143
  if (BTCoexDbgLevel == 1U) {
#line 10143
    printk("[DM][BT], FirmwareVersion = 0x%x(%d)\n", (int )pHalData->FirmwareVersion,
           (int )pHalData->FirmwareVersion);
  } else {

  }
#line 10145
  regBTActive = 1092U;
#line 10146
  regBTState = 1096U;
#line 10147
  if ((unsigned int )pHalData->FirmwareVersion > 73U) {
#line 10148
    regBTPolling = 1100U;
  } else {
#line 10150
    regBTPolling = 1792U;
  }
#line 10152
  BT_Active = rtl8723au_read32(padapter, regBTActive);
#line 10153
  if (BTCoexDbgLevel == 1U) {
#line 10153
    printk("[DM][BT], BT_Active(0x%x) =%x\n", regBTActive, BT_Active);
  } else {

  }
#line 10154
  BT_Active = BT_Active & 16777215U;
#line 10156
  BT_State = rtl8723au_read32(padapter, regBTState);
#line 10157
  if (BTCoexDbgLevel == 1U) {
#line 10157
    printk("[DM][BT], BT_State(0x%x) =%x\n", regBTState, BT_State);
  } else {

  }
#line 10158
  BT_State = BT_State & 16777215U;
#line 10160
  BT_Polling = rtl8723au_read32(padapter, regBTPolling);
#line 10161
  if (BTCoexDbgLevel == 1U) {
#line 10161
    printk("[DM][BT], BT_Polling(0x%x) =%x\n", regBTPolling, BT_Polling);
  } else {

  }
#line 10163
  if ((BT_Active == 4294967295U && BT_State == 4294967295U) && BT_Polling == 4294967295U) {
#line 10164
    return;
  } else {

  }
#line 10165
  if (BT_Polling == 0U) {
#line 10166
    return;
  } else {

  }
#line 10168
  Ratio_Act = (BT_Active * 1000U) / BT_Polling;
#line 10169
  Ratio_STA = (BT_State * 1000U) / BT_Polling;
#line 10171
  pHalData->bt_coexist.Ratio_Tx = Ratio_Act;
#line 10172
  pHalData->bt_coexist.Ratio_PRI = Ratio_STA;
#line 10174
  if (BTCoexDbgLevel == 1U) {
#line 10174
    printk("[DM][BT], Ratio_Act =%d\n", Ratio_Act);
  } else {

  }
#line 10175
  if (BTCoexDbgLevel == 1U) {
#line 10175
    printk("[DM][BT], Ratio_STA =%d\n", Ratio_STA);
  } else {

  }
#line 10177
  if (Ratio_STA <= 59U && Ratio_Act <= 499U) {
#line 10178
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32768ULL;
#line 10179
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffdffffULL;
#line 10180
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
  } else {
#line 10182
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffff7fffULL;
#line 10184
    if (Ratio_STA != 0U) {
#line 10186
      if (Ratio_Act / Ratio_STA <= 1U) {
#line 10188
        pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 1U;
#line 10189
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 65536ULL;
#line 10190
        pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 0U;
#line 10191
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffdffffULL;
      } else {
#line 10194
        pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 0U;
#line 10195
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
#line 10196
        pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 1U;
#line 10197
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 131072ULL;
      }
    } else {
#line 10201
      pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic = 0U;
#line 10202
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffeffffULL;
#line 10203
      pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic = 1U;
#line 10204
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 131072ULL;
    }
  }
#line 10209
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfSCO == 0U) {
#line 10211
    pBtMgnt->ExtConfig.bBTBusy = 0U;
#line 10212
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  } else
#line 10214
  if (Ratio_STA <= 59U) {
#line 10215
    pBtMgnt->ExtConfig.bBTBusy = 0U;
#line 10216
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4096ULL;
  } else {
#line 10218
    pBtMgnt->ExtConfig.bBTBusy = 1U;
#line 10219
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffefffULL;
  }
#line 10223
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfSCO == 0U) {
#line 10225
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffff7ffffULL;
#line 10226
    pBtMgnt->ExtConfig.MIN_BT_RSSI = 0;
#line 10227
    BTDM_SetAntenna(padapter, 0);
  } else
#line 10229
  if ((int )pBtMgnt->ExtConfig.MIN_BT_RSSI < -4) {
#line 10230
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 524288ULL;
#line 10231
    if (BTCoexDbgLevel == 1U) {
#line 10231
      printk("[DM][BT], core stack notify bt rssi Low\n");
    } else {

    }
  } else {
#line 10233
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffff7ffffULL;
#line 10234
    if (BTCoexDbgLevel == 1U) {
#line 10234
      printk("[DM][BT], core stack notify bt rssi Normal\n");
    } else {

    }
  }
#line 10238
  if ((int )pHalData->bt_coexist.bBTBusyTraffic != (int )pBtMgnt->ExtConfig.bBTBusy) {
#line 10240
    pHalData->bt_coexist.bBTBusyTraffic = pBtMgnt->ExtConfig.bBTBusy;
#line 10241
    stateChange = 1U;
  } else {

  }
#line 10244
  if ((unsigned int )stateChange != 0U) {
#line 10245
    if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy == 0U) {
#line 10246
      if (BTCoexDbgLevel == 1U) {
#line 10246
        printk("[DM][BT], BT is idle or disable\n");
      } else {

      }
    } else
#line 10248
    if (BTCoexDbgLevel == 1U) {
#line 10248
      printk("[DM][BT], BT is non-idle\n");
    } else {

    }
  } else {

  }
#line 10250
  if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy == 0U) {
#line 10251
    if (BTCoexDbgLevel == 1U) {
#line 10251
      printk("[DM][BT], BT is idle or disable\n");
    } else {

    }
#line 10252
    tmp___1 = check_fwstate(& padapter->mlmepriv, 2176);
#line 10252
    if ((int )tmp___1) {
#line 10253
      BTDM_SetAntenna(padapter, 1);
    } else {

    }
  } else {

  }
#line 10255
  return;
}
}
#line 10271 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_DiminishWiFi(struct rtw_adapter *padapter , u8 bDACOn , u8 bInterruptOn ,
                       u8 DACSwingLevel , u8 bNAVOn ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;

  {
#line 10279
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10280
  H2C_Parameter[0] = 0U;
#line 10280
  tmp = 1U;
#line 10280
  while (1) {
#line 10280
    if (tmp >= 3U) {
#line 10280
      break;
    } else {

    }
#line 10280
    H2C_Parameter[tmp] = (unsigned char)0;
#line 10280
    tmp = tmp + 1U;
  }
#line 10282
  if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num != 0U) {
#line 10283
    return;
  } else {

  }
#line 10285
  if ((pHalData->bt_coexist.CurrentState & 524288ULL) != 0ULL && (unsigned int )DACSwingLevel == 32U) {
#line 10287
    if (BTCoexDbgLevel == 1U) {
#line 10287
      printk("[BT]DiminishWiFi 0x20 original, but set 0x18 for Low RSSI!\n");
    } else {

    }
#line 10288
    DACSwingLevel = 24U;
  } else {

  }
#line 10291
  H2C_Parameter[2] = 0U;
#line 10292
  H2C_Parameter[1] = DACSwingLevel;
#line 10293
  H2C_Parameter[0] = 0U;
#line 10294
  if ((unsigned int )bDACOn != 0U) {
#line 10295
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 1U);
#line 10296
    if ((unsigned int )bInterruptOn != 0U) {
#line 10297
      H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 2U);
    } else {

    }
#line 10298
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 10300
  if ((unsigned int )bNAVOn != 0U) {
#line 10301
    H2C_Parameter[2] = (u8 )((unsigned int )H2C_Parameter[2] | 8U);
#line 10302
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {

  }
#line 10305
  if (BTCoexDbgLevel == 1U) {
#line 10305
    printk("[DM][BT], bDACOn = %s, bInterruptOn = %s, write 0xe = 0x%x\n", (unsigned int )bDACOn != 0U ? (char *)"ON" : (char *)"OFF",
           (unsigned int )bInterruptOn != 0U ? (char *)"ON" : (char *)"OFF", (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {

  }
#line 10308
  if (BTCoexDbgLevel == 1U) {
#line 10308
    printk("[DM][BT], bNAVOn = %s\n", (unsigned int )bNAVOn != 0U ? (char *)"ON" : (char *)"OFF");
  } else {

  }
#line 10309
  return;
}
}
#line 10317 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_ResetFWCoexState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10319
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10321
  pHalData->bt_coexist.CurrentState = 0ULL;
#line 10322
  pHalData->bt_coexist.PreviousState = 0ULL;
#line 10323
  return;
}
}
#line 10325 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void btdm_InitBtCoexistDM(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10327
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10330
  pHalData->bt_coexist.BtRfRegOrigin1E = PHY_QueryRFReg(padapter, 0, 30U, 1048575U);
#line 10331
  pHalData->bt_coexist.BtRfRegOrigin1F = PHY_QueryRFReg(padapter, 0, 31U, 240U);
#line 10333
  pHalData->bt_coexist.CurrentState = 0ULL;
#line 10334
  pHalData->bt_coexist.PreviousState = 0ULL;
#line 10336
  BTDM_8723AInit(padapter);
#line 10337
  pHalData->bt_coexist.bInitlized = 1U;
#line 10338
  return;
}
}
#line 10343 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_CheckAntSelMode(struct rtw_adapter *padapter ) 
{ 


  {
#line 10345
  return;
}
}
#line 10347 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_FwC2hBtRssi(struct rtw_adapter *padapter , u8 *tmpBuf ) 
{ 


  {
#line 10349
  BTDM_FwC2hBtRssi8723A(padapter, tmpBuf);
#line 10350
  return;
}
}
#line 10352 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_DisplayBtCoexInfo(struct rtw_adapter *padapter ) 
{ 


  {
#line 10354
  BTDM_Display8723ABtCoexInfo(padapter);
#line 10355
  return;
}
}
#line 10357 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_RejectAPAggregatedPacket(struct rtw_adapter *padapter , u8 bReject ) 
{ 


  {
#line 10359
  return;
}
}
#line 10361 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsHT40(struct rtw_adapter *padapter ) 
{ 
  u8 isht40 ;
  enum ht_channel_width bw ;

  {
#line 10363
  isht40 = 1U;
#line 10366
  bw = (enum ht_channel_width )padapter->mlmeextpriv.cur_bwmode;
#line 10368
  if ((unsigned int )bw == 0U) {
#line 10369
    isht40 = 0U;
  } else
#line 10370
  if ((unsigned int )bw == 1U) {
#line 10371
    isht40 = 1U;
  } else {

  }
#line 10373
  return (isht40);
}
}
#line 10376 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_Legacy(struct rtw_adapter *padapter ) 
{ 
  struct mlme_ext_priv *pmlmeext ;
  u8 isLegacy ;

  {
#line 10379
  isLegacy = 0U;
#line 10381
  pmlmeext = & padapter->mlmeextpriv;
#line 10382
  if (((unsigned int )pmlmeext->cur_wireless_mode == 1U || (unsigned int )pmlmeext->cur_wireless_mode == 2U) || (unsigned int )pmlmeext->cur_wireless_mode == 3U) {
#line 10385
    isLegacy = 1U;
  } else {

  }
#line 10387
  return (isLegacy);
}
}
#line 10390 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_CheckWiFiState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 10397
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10398
  pmlmepriv = & padapter->mlmepriv;
#line 10399
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 10400
  pBtMgnt = & pBTInfo->BtMgnt;
#line 10402
  if ((int )pmlmepriv->LinkDetectInfo.bBusyTraffic) {
#line 10403
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffeffULL;
#line 10405
    if ((int )pmlmepriv->LinkDetectInfo.bTxBusyTraffic) {
#line 10406
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 512ULL;
    } else {
#line 10408
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffdffULL;
    }
#line 10410
    if ((int )pmlmepriv->LinkDetectInfo.bRxBusyTraffic) {
#line 10411
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1024ULL;
    } else {
#line 10413
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffbffULL;
    }
  } else {
#line 10415
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 256ULL;
#line 10416
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffdffULL;
#line 10417
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffbffULL;
  }
#line 10420
  tmp___0 = BTDM_Legacy(padapter);
#line 10420
  if ((unsigned int )tmp___0 != 0U) {
#line 10421
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8ULL;
#line 10422
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffdULL;
#line 10423
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffbULL;
  } else {
#line 10425
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffff7ULL;
#line 10426
    tmp = BTDM_IsHT40(padapter);
#line 10426
    if ((unsigned int )tmp != 0U) {
#line 10427
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4ULL;
#line 10428
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffdULL;
    } else {
#line 10430
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2ULL;
#line 10431
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffbULL;
    }
  }
#line 10435
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
#line 10436
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1ULL;
  } else {
#line 10438
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffffffffeULL;
  }
#line 10439
  return;
}
}
#line 10441 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
s32 BTDM_GetRxSS(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  bool tmp ;

  {
#line 10446
  UndecoratedSmoothedPWDB = 0;
#line 10448
  pmlmepriv = & padapter->mlmepriv;
#line 10449
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10451
  tmp = check_fwstate(pmlmepriv, 1);
#line 10451
  if ((int )tmp) {
#line 10452
    UndecoratedSmoothedPWDB = ((struct hal_data_8723a *)padapter->HalData)->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  } else {
#line 10454
    UndecoratedSmoothedPWDB = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  }
#line 10457
  if (BTCoexDbgLevel == 1U) {
#line 10457
    printk("BTDM_GetRxSS() = %d\n", UndecoratedSmoothedPWDB);
  } else {

  }
#line 10458
  return (UndecoratedSmoothedPWDB);
}
}
#line 10461 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static s32 BTDM_GetRxBeaconSS(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct hal_data_8723a *pHalData ;
  s32 pwdbBeacon ;
  bool tmp ;

  {
#line 10466
  pwdbBeacon = 0;
#line 10468
  pmlmepriv = & padapter->mlmepriv;
#line 10469
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10471
  tmp = check_fwstate(pmlmepriv, 1);
#line 10471
  if ((int )tmp) {
#line 10473
    pwdbBeacon = pHalData->dmpriv.EntryMinUndecoratedSmoothedPWDB;
  } else {

  }
#line 10475
  if (BTCoexDbgLevel == 1U) {
#line 10475
    printk("BTDM_GetRxBeaconSS() = %d\n", pwdbBeacon);
  } else {

  }
#line 10476
  return (pwdbBeacon);
}
}
#line 10480 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_CheckCoexBcnRssiState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                              u8 RssiThresh1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  s32 pwdbBeacon ;
  u8 bcnRssiState ;

  {
#line 10483
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10484
  pwdbBeacon = 0;
#line 10485
  bcnRssiState = 0U;
#line 10487
  pwdbBeacon = BTDM_GetRxBeaconSS(padapter);
#line 10489
  if ((unsigned int )levelNum == 2U) {
#line 10490
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
#line 10492
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 2U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 5U) {
#line 10494
      if ((int )RssiThresh + 6 <= pwdbBeacon) {
#line 10495
        bcnRssiState = 0U;
#line 10496
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 536870912ULL;
#line 10497
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
#line 10498
        if (BTCoexDbgLevel == 1U) {
#line 10498
          printk("[DM][BT], RSSI_BEACON state switch to High\n");
        } else {

        }
      } else {
#line 10500
        bcnRssiState = 5U;
#line 10501
        if (BTCoexDbgLevel == 1U) {
#line 10501
          printk("[DM][BT], RSSI_BEACON state stay at Low\n");
        } else {

        }
      }
    } else
#line 10504
    if ((int )RssiThresh > pwdbBeacon) {
#line 10505
      bcnRssiState = 2U;
#line 10506
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 134217728ULL;
#line 10507
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
#line 10508
      if (BTCoexDbgLevel == 1U) {
#line 10508
        printk("[DM][BT], RSSI_BEACON state switch to Low\n");
      } else {

      }
    } else {
#line 10510
      bcnRssiState = 3U;
#line 10511
      if (BTCoexDbgLevel == 1U) {
#line 10511
        printk("[DM][BT], RSSI_BEACON state stay at High\n");
      } else {

      }
    }
  } else
#line 10514
  if ((unsigned int )levelNum == 3U) {
#line 10515
    if ((int )RssiThresh > (int )RssiThresh1) {
#line 10516
      if (BTCoexDbgLevel == 1U) {
#line 10516
        printk("[DM][BT], RSSI_BEACON thresh error!!\n");
      } else {

      }
#line 10517
      return (pHalData->bt_coexist.preRssiStateBeacon);
    } else {

    }
#line 10520
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 2U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 5U) {
#line 10522
      if ((int )RssiThresh + 6 <= pwdbBeacon) {
#line 10523
        bcnRssiState = 1U;
#line 10524
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 268435456ULL;
#line 10525
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
#line 10526
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
#line 10527
        if (BTCoexDbgLevel == 1U) {
#line 10527
          printk("[DM][BT], RSSI_BEACON state switch to Medium\n");
        } else {

        }
      } else {
#line 10529
        bcnRssiState = 5U;
#line 10530
        if (BTCoexDbgLevel == 1U) {
#line 10530
          printk("[DM][BT], RSSI_BEACON state stay at Low\n");
        } else {

        }
      }
    } else
#line 10532
    if ((unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 1U || (unsigned int )pHalData->bt_coexist.preRssiStateBeacon == 4U) {
#line 10534
      if ((int )RssiThresh1 + 6 <= pwdbBeacon) {
#line 10535
        bcnRssiState = 0U;
#line 10536
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 536870912ULL;
#line 10537
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
#line 10538
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
#line 10539
        if (BTCoexDbgLevel == 1U) {
#line 10539
          printk("[DM][BT], RSSI_BEACON state switch to High\n");
        } else {

        }
      } else
#line 10540
      if ((int )RssiThresh > pwdbBeacon) {
#line 10541
        bcnRssiState = 2U;
#line 10542
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 134217728ULL;
#line 10543
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
#line 10544
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffefffffffULL;
#line 10545
        if (BTCoexDbgLevel == 1U) {
#line 10545
          printk("[DM][BT], RSSI_BEACON state switch to Low\n");
        } else {

        }
      } else {
#line 10547
        bcnRssiState = 4U;
#line 10548
        if (BTCoexDbgLevel == 1U) {
#line 10548
          printk("[DM][BT], RSSI_BEACON state stay at Medium\n");
        } else {

        }
      }
    } else
#line 10551
    if ((int )RssiThresh1 > pwdbBeacon) {
#line 10552
      bcnRssiState = 1U;
#line 10553
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 268435456ULL;
#line 10554
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffdfffffffULL;
#line 10555
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffff7ffffffULL;
#line 10556
      if (BTCoexDbgLevel == 1U) {
#line 10556
        printk("[DM][BT], RSSI_BEACON state switch to Medium\n");
      } else {

      }
    } else {
#line 10558
      bcnRssiState = 3U;
#line 10559
      if (BTCoexDbgLevel == 1U) {
#line 10559
        printk("[DM][BT], RSSI_BEACON state stay at High\n");
      } else {

      }
    }
  } else {

  }
#line 10564
  pHalData->bt_coexist.preRssiStateBeacon = bcnRssiState;
#line 10566
  return (bcnRssiState);
}
}
#line 10569 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_CheckCoexRSSIState1(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                            u8 RssiThresh1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  u8 btRssiState ;

  {
#line 10572
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10573
  UndecoratedSmoothedPWDB = 0;
#line 10574
  btRssiState = 0U;
#line 10576
  UndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);
#line 10578
  if ((unsigned int )levelNum == 2U) {
#line 10579
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
#line 10581
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 2U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 5U) {
#line 10583
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
#line 10584
        btRssiState = 0U;
#line 10585
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 67108864ULL;
#line 10586
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
#line 10587
        if (BTCoexDbgLevel == 1U) {
#line 10587
          printk("[DM][BT], RSSI_1 state switch to High\n");
        } else {

        }
      } else {
#line 10589
        btRssiState = 5U;
#line 10590
        if (BTCoexDbgLevel == 1U) {
#line 10590
          printk("[DM][BT], RSSI_1 state stay at Low\n");
        } else {

        }
      }
    } else
#line 10593
    if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
#line 10594
      btRssiState = 2U;
#line 10595
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16777216ULL;
#line 10596
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
#line 10597
      if (BTCoexDbgLevel == 1U) {
#line 10597
        printk("[DM][BT], RSSI_1 state switch to Low\n");
      } else {

      }
    } else {
#line 10599
      btRssiState = 3U;
#line 10600
      if (BTCoexDbgLevel == 1U) {
#line 10600
        printk("[DM][BT], RSSI_1 state stay at High\n");
      } else {

      }
    }
  } else
#line 10603
  if ((unsigned int )levelNum == 3U) {
#line 10604
    if ((int )RssiThresh > (int )RssiThresh1) {
#line 10605
      if (BTCoexDbgLevel == 1U) {
#line 10605
        printk("[DM][BT], RSSI_1 thresh error!!\n");
      } else {

      }
#line 10606
      return (pHalData->bt_coexist.preRssiState1);
    } else {

    }
#line 10609
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 2U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 5U) {
#line 10611
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
#line 10612
        btRssiState = 1U;
#line 10613
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 33554432ULL;
#line 10614
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
#line 10615
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
#line 10616
        if (BTCoexDbgLevel == 1U) {
#line 10616
          printk("[DM][BT], RSSI_1 state switch to Medium\n");
        } else {

        }
      } else {
#line 10618
        btRssiState = 5U;
#line 10619
        if (BTCoexDbgLevel == 1U) {
#line 10619
          printk("[DM][BT], RSSI_1 state stay at Low\n");
        } else {

        }
      }
    } else
#line 10621
    if ((unsigned int )pHalData->bt_coexist.preRssiState1 == 1U || (unsigned int )pHalData->bt_coexist.preRssiState1 == 4U) {
#line 10623
      if ((int )RssiThresh1 + 6 <= UndecoratedSmoothedPWDB) {
#line 10624
        btRssiState = 0U;
#line 10625
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 67108864ULL;
#line 10626
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
#line 10627
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
#line 10628
        if (BTCoexDbgLevel == 1U) {
#line 10628
          printk("[DM][BT], RSSI_1 state switch to High\n");
        } else {

        }
      } else
#line 10629
      if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
#line 10630
        btRssiState = 2U;
#line 10631
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16777216ULL;
#line 10632
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
#line 10633
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffdffffffULL;
#line 10634
        if (BTCoexDbgLevel == 1U) {
#line 10634
          printk("[DM][BT], RSSI_1 state switch to Low\n");
        } else {

        }
      } else {
#line 10636
        btRssiState = 4U;
#line 10637
        if (BTCoexDbgLevel == 1U) {
#line 10637
          printk("[DM][BT], RSSI_1 state stay at Medium\n");
        } else {

        }
      }
    } else
#line 10640
    if ((int )RssiThresh1 > UndecoratedSmoothedPWDB) {
#line 10641
      btRssiState = 1U;
#line 10642
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 33554432ULL;
#line 10643
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffbffffffULL;
#line 10644
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xfffffffffeffffffULL;
#line 10645
      if (BTCoexDbgLevel == 1U) {
#line 10645
        printk("[DM][BT], RSSI_1 state switch to Medium\n");
      } else {

      }
    } else {
#line 10647
      btRssiState = 3U;
#line 10648
      if (BTCoexDbgLevel == 1U) {
#line 10648
        printk("[DM][BT], RSSI_1 state stay at High\n");
      } else {

      }
    }
  } else {

  }
#line 10653
  pHalData->bt_coexist.preRssiState1 = btRssiState;
#line 10655
  return (btRssiState);
}
}
#line 10658 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_CheckCoexRSSIState(struct rtw_adapter *padapter , u8 levelNum , u8 RssiThresh ,
                           u8 RssiThresh1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  s32 UndecoratedSmoothedPWDB ;
  u8 btRssiState ;

  {
#line 10661
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10662
  UndecoratedSmoothedPWDB = 0;
#line 10663
  btRssiState = 0U;
#line 10665
  UndecoratedSmoothedPWDB = BTDM_GetRxSS(padapter);
#line 10667
  if ((unsigned int )levelNum == 2U) {
#line 10668
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
#line 10670
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 2U || (unsigned int )pHalData->bt_coexist.preRssiState == 5U) {
#line 10672
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
#line 10673
        btRssiState = 0U;
#line 10674
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 64ULL;
#line 10675
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
#line 10676
        if (BTCoexDbgLevel == 1U) {
#line 10676
          printk("[DM][BT], RSSI state switch to High\n");
        } else {

        }
      } else {
#line 10678
        btRssiState = 5U;
#line 10679
        if (BTCoexDbgLevel == 1U) {
#line 10679
          printk("[DM][BT], RSSI state stay at Low\n");
        } else {

        }
      }
    } else
#line 10682
    if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
#line 10683
      btRssiState = 2U;
#line 10684
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16ULL;
#line 10685
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
#line 10686
      if (BTCoexDbgLevel == 1U) {
#line 10686
        printk("[DM][BT], RSSI state switch to Low\n");
      } else {

      }
    } else {
#line 10688
      btRssiState = 3U;
#line 10689
      if (BTCoexDbgLevel == 1U) {
#line 10689
        printk("[DM][BT], RSSI state stay at High\n");
      } else {

      }
    }
  } else
#line 10692
  if ((unsigned int )levelNum == 3U) {
#line 10693
    if ((int )RssiThresh > (int )RssiThresh1) {
#line 10694
      if (BTCoexDbgLevel == 1U) {
#line 10694
        printk("[DM][BT], RSSI thresh error!!\n");
      } else {

      }
#line 10695
      return (pHalData->bt_coexist.preRssiState);
    } else {

    }
#line 10698
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 2U || (unsigned int )pHalData->bt_coexist.preRssiState == 5U) {
#line 10700
      if ((int )RssiThresh + 6 <= UndecoratedSmoothedPWDB) {
#line 10701
        btRssiState = 1U;
#line 10702
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32ULL;
#line 10703
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
#line 10704
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
#line 10705
        if (BTCoexDbgLevel == 1U) {
#line 10705
          printk("[DM][BT], RSSI state switch to Medium\n");
        } else {

        }
      } else {
#line 10707
        btRssiState = 5U;
#line 10708
        if (BTCoexDbgLevel == 1U) {
#line 10708
          printk("[DM][BT], RSSI state stay at Low\n");
        } else {

        }
      }
    } else
#line 10710
    if ((unsigned int )pHalData->bt_coexist.preRssiState == 1U || (unsigned int )pHalData->bt_coexist.preRssiState == 4U) {
#line 10712
      if ((int )RssiThresh1 + 6 <= UndecoratedSmoothedPWDB) {
#line 10713
        btRssiState = 0U;
#line 10714
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 64ULL;
#line 10715
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
#line 10716
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
#line 10717
        if (BTCoexDbgLevel == 1U) {
#line 10717
          printk("[DM][BT], RSSI state switch to High\n");
        } else {

        }
      } else
#line 10718
      if ((int )RssiThresh > UndecoratedSmoothedPWDB) {
#line 10719
        btRssiState = 2U;
#line 10720
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 16ULL;
#line 10721
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
#line 10722
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffdfULL;
#line 10723
        if (BTCoexDbgLevel == 1U) {
#line 10723
          printk("[DM][BT], RSSI state switch to Low\n");
        } else {

        }
      } else {
#line 10725
        btRssiState = 4U;
#line 10726
        if (BTCoexDbgLevel == 1U) {
#line 10726
          printk("[DM][BT], RSSI state stay at Medium\n");
        } else {

        }
      }
    } else
#line 10729
    if ((int )RssiThresh1 > UndecoratedSmoothedPWDB) {
#line 10730
      btRssiState = 1U;
#line 10731
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 32ULL;
#line 10732
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffbfULL;
#line 10733
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffffffffefULL;
#line 10734
      if (BTCoexDbgLevel == 1U) {
#line 10734
        printk("[DM][BT], RSSI state switch to Medium\n");
      } else {

      }
    } else {
#line 10736
      btRssiState = 3U;
#line 10737
      if (BTCoexDbgLevel == 1U) {
#line 10737
        printk("[DM][BT], RSSI state stay at High\n");
      } else {

      }
    }
  } else {

  }
#line 10742
  pHalData->bt_coexist.preRssiState = btRssiState;
#line 10744
  return (btRssiState);
}
}
#line 10747 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
bool rtl8723a_BT_disable_EDCA_turbo(struct rtw_adapter *padapter ) 
{ 
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 bBtChangeEDCA ;
  u32 EDCA_BT_BE ;
  u32 cur_EDCA_reg ;
  bool bRet ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 10751
  bBtChangeEDCA = 0U;
#line 10752
  EDCA_BT_BE = 6202411U;
#line 10753
  bRet = 0;
#line 10755
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10756
  pBtMgnt = & pHalData->BtInfo.BtMgnt;
#line 10758
  tmp = rtl8723a_BT_coexist(padapter);
#line 10758
  if (tmp) {
#line 10758
    tmp___0 = 0;
  } else {
#line 10758
    tmp___0 = 1;
  }
#line 10758
  if (tmp___0) {
#line 10759
    bRet = 0;
#line 10760
    pHalData->bt_coexist.lastBtEdca = 0U;
#line 10761
    return (bRet);
  } else {

  }
#line 10763
  if ((unsigned int )pBtMgnt->bSupportProfile == 0U && (unsigned int )pHalData->bt_coexist.BT_CoexistType != 4U) {
#line 10765
    bRet = 0;
#line 10766
    pHalData->bt_coexist.lastBtEdca = 0U;
#line 10767
    return (bRet);
  } else {

  }
#line 10770
  tmp___1 = rtl8723a_BT_using_antenna_1(padapter);
#line 10770
  if ((int )tmp___1) {
#line 10771
    bRet = 0;
#line 10772
    pHalData->bt_coexist.lastBtEdca = 0U;
#line 10773
    return (bRet);
  } else {

  }
#line 10776
  if ((unsigned int )pHalData->bt_coexist.exec_cnt <= 2U) {
#line 10777
    pHalData->bt_coexist.exec_cnt = (u8 )((int )pHalData->bt_coexist.exec_cnt + 1);
  } else {
#line 10779
    pHalData->bt_coexist.bEDCAInitialized = 1U;
  }
#line 10782
  if ((pHalData->bt_coexist.CurrentState & 4096ULL) == 0ULL) {
#line 10783
    if (BTCoexDbgLevel == 1U) {
#line 10783
      printk("BT state non idle, set bt EDCA\n");
    } else {

    }
#line 10786
    if ((int )pHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA) {
#line 10787
      bBtChangeEDCA = 1U;
#line 10788
      pHalData->odmpriv.DM_EDCA_Table.bCurrentTurboEDCA = 0;
#line 10789
      pHalData->dmpriv.prv_traffic_idx = 3U;
    } else {

    }
#line 10791
    cur_EDCA_reg = rtl8723au_read32(padapter, 1288U);
#line 10793
    if (cur_EDCA_reg != EDCA_BT_BE) {
#line 10794
      bBtChangeEDCA = 1U;
    } else {

    }
#line 10795
    if ((unsigned int )bBtChangeEDCA != 0U || (unsigned int )pHalData->bt_coexist.bEDCAInitialized == 0U) {
#line 10796
      rtl8723au_write32(padapter, 1288U, EDCA_BT_BE);
#line 10798
      pHalData->bt_coexist.lastBtEdca = EDCA_BT_BE;
    } else {

    }
#line 10800
    bRet = 1;
  } else {
#line 10802
    if (BTCoexDbgLevel == 1U) {
#line 10802
      printk("BT state idle, set original EDCA\n");
    } else {

    }
#line 10803
    pHalData->bt_coexist.lastBtEdca = 0U;
#line 10804
    bRet = 0;
  }
#line 10806
  return (bRet);
}
}
#line 10810 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_Balance(struct rtw_adapter *padapter , u8 bBalanceOn , u8 ms0 , u8 ms1 ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;

  {
#line 10817
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10818
  H2C_Parameter[0] = 0U;
#line 10818
  tmp = 1U;
#line 10818
  while (1) {
#line 10818
    if (tmp >= 3U) {
#line 10818
      break;
    } else {

    }
#line 10818
    H2C_Parameter[tmp] = (unsigned char)0;
#line 10818
    tmp = tmp + 1U;
  }
#line 10820
  if ((unsigned int )bBalanceOn != 0U) {
#line 10821
    H2C_Parameter[2] = 1U;
#line 10822
    H2C_Parameter[1] = ms1;
#line 10823
    H2C_Parameter[0] = ms0;
#line 10824
    pHalData->bt_coexist.bFWCoexistAllOff = 0U;
  } else {
#line 10826
    H2C_Parameter[2] = 0U;
#line 10827
    H2C_Parameter[1] = 0U;
#line 10828
    H2C_Parameter[0] = 0U;
  }
#line 10830
  pHalData->bt_coexist.bBalanceOn = bBalanceOn;
#line 10832
  if (BTCoexDbgLevel == 1U) {
#line 10832
    printk("[DM][BT], Balance =[%s:%dms:%dms], write 0xc = 0x%x\n", (unsigned int )bBalanceOn != 0U ? (char *)"ON" : (char *)"OFF",
           (int )ms0, (int )ms1, (((int )H2C_Parameter[0] << 16) | ((int )H2C_Parameter[1] << 8)) | (int )H2C_Parameter[2]);
  } else {

  }
#line 10836
  FillH2CCmd(padapter, 12, 3U, (u8 *)(& H2C_Parameter));
#line 10837
  return;
}
}
#line 10839 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_AGCTable(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10841
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10842
  if ((unsigned int )type == 0U) {
#line 10843
    if (BTCoexDbgLevel == 1U) {
#line 10843
      printk("[BT]AGCTable Off!\n");
    } else {

    }
#line 10844
    rtl8723au_write32(padapter, 3192U, 1679556609U);
#line 10845
    rtl8723au_write32(padapter, 3192U, 1662844929U);
#line 10846
    rtl8723au_write32(padapter, 3192U, 1646133249U);
#line 10847
    rtl8723au_write32(padapter, 3192U, 1629421569U);
#line 10848
    rtl8723au_write32(padapter, 3192U, 1612709889U);
#line 10850
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 204800U);
#line 10851
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 462848U);
#line 10852
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 720896U);
#line 10853
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 1032192U);
#line 10854
    PHY_SetRFReg(padapter, 0, 26U, 1048575U, 197461U);
#line 10856
    pHalData->bt_coexist.b8723aAgcTableOn = 0U;
  } else
#line 10857
  if ((unsigned int )type == 1U) {
#line 10858
    if (BTCoexDbgLevel == 1U) {
#line 10858
      printk("[BT]AGCTable On!\n");
    } else {

    }
#line 10859
    rtl8723au_write32(padapter, 3192U, 1310457857U);
#line 10860
    rtl8723au_write32(padapter, 3192U, 1293746177U);
#line 10861
    rtl8723au_write32(padapter, 3192U, 1277034497U);
#line 10862
    rtl8723au_write32(padapter, 3192U, 1260322817U);
#line 10863
    rtl8723au_write32(padapter, 3192U, 1243611137U);
#line 10865
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 901120U);
#line 10866
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 589824U);
#line 10867
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 331776U);
#line 10868
    PHY_SetRFReg(padapter, 0, 18U, 1048575U, 73728U);
#line 10869
    PHY_SetRFReg(padapter, 0, 26U, 1048575U, 853U);
#line 10871
    pHalData->bt_coexist.b8723aAgcTableOn = 1U;
#line 10873
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {

  }
#line 10875
  return;
}
}
#line 10877 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_BBBackOffLevel(struct rtw_adapter *padapter , u8 type ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10879
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10881
  if ((unsigned int )type == 0U) {
#line 10882
    if (BTCoexDbgLevel == 1U) {
#line 10882
      printk("[BT]BBBackOffLevel Off!\n");
    } else {

    }
#line 10883
    rtl8723au_write32(padapter, 3076U, 60839441U);
  } else
#line 10884
  if ((unsigned int )type == 1U) {
#line 10885
    if (BTCoexDbgLevel == 1U) {
#line 10885
      printk("[BT]BBBackOffLevel On!\n");
    } else {

    }
#line 10886
    rtl8723au_write32(padapter, 3076U, 60847633U);
#line 10887
    pHalData->bt_coexist.bSWCoexistAllOff = 0U;
  } else {

  }
#line 10889
  return;
}
}
#line 10891 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_FWCoexAllOff(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10893
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10895
  if (BTCoexDbgLevel == 1U) {
#line 10895
    printk("BTDM_FWCoexAllOff()\n");
  } else {

  }
#line 10896
  if ((unsigned int )pHalData->bt_coexist.bFWCoexistAllOff != 0U) {
#line 10897
    return;
  } else {

  }
#line 10898
  if (BTCoexDbgLevel == 1U) {
#line 10898
    printk("BTDM_FWCoexAllOff(), real Do\n");
  } else {

  }
#line 10900
  BTDM_FWCoexAllOff8723A(padapter);
#line 10902
  pHalData->bt_coexist.bFWCoexistAllOff = 1U;
#line 10903
  return;
}
}
#line 10905 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_SWCoexAllOff(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10907
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10909
  if (BTCoexDbgLevel == 1U) {
#line 10909
    printk("BTDM_SWCoexAllOff()\n");
  } else {

  }
#line 10910
  if ((unsigned int )pHalData->bt_coexist.bSWCoexistAllOff != 0U) {
#line 10911
    return;
  } else {

  }
#line 10912
  if (BTCoexDbgLevel == 1U) {
#line 10912
    printk("BTDM_SWCoexAllOff(), real Do\n");
  } else {

  }
#line 10913
  BTDM_SWCoexAllOff8723A(padapter);
#line 10915
  pHalData->bt_coexist.bSWCoexistAllOff = 1U;
#line 10916
  return;
}
}
#line 10918 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_HWCoexAllOff(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 10920
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10922
  if (BTCoexDbgLevel == 1U) {
#line 10922
    printk("BTDM_HWCoexAllOff()\n");
  } else {

  }
#line 10923
  if ((unsigned int )pHalData->bt_coexist.bHWCoexistAllOff != 0U) {
#line 10924
    return;
  } else {

  }
#line 10925
  if (BTCoexDbgLevel == 1U) {
#line 10925
    printk("BTDM_HWCoexAllOff(), real Do\n");
  } else {

  }
#line 10927
  BTDM_HWCoexAllOff8723A(padapter);
#line 10929
  pHalData->bt_coexist.bHWCoexistAllOff = 1U;
#line 10930
  return;
}
}
#line 10932 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_CoexAllOff(struct rtw_adapter *padapter ) 
{ 


  {
#line 10934
  BTDM_FWCoexAllOff(padapter);
#line 10935
  BTDM_SWCoexAllOff(padapter);
#line 10936
  BTDM_HWCoexAllOff(padapter);
#line 10937
  return;
}
}
#line 10939 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_BT_disable_coexist(struct rtw_adapter *padapter ) 
{ 
  struct pwrctrl_priv *ppwrctrl ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
#line 10941
  ppwrctrl = & padapter->pwrctrlpriv;
#line 10943
  tmp = rtl8723a_BT_coexist(padapter);
#line 10943
  if (tmp) {
#line 10943
    tmp___0 = 0;
  } else {
#line 10943
    tmp___0 = 1;
  }
#line 10943
  if (tmp___0) {
#line 10944
    return;
  } else {

  }
#line 10947
  tmp___1 = rtl8723a_BT_using_antenna_1(padapter);
#line 10947
  if ((int )tmp___1) {
#line 10948
    return;
  } else {

  }
#line 10951
  if ((unsigned int )ppwrctrl->reg_rfoff == 0U) {
#line 10952
    if (BTCoexDbgLevel == 1U) {
#line 10952
      printk("[BT][DM], Before enter IPS, turn off all Coexist DM\n");
    } else {

    }
#line 10953
    btdm_ResetFWCoexState(padapter);
#line 10954
    BTDM_CoexAllOff(padapter);
#line 10955
    BTDM_SetAntenna(padapter, 2);
  } else {

  }
#line 10957
  return;
}
}
#line 10959 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_SignalCompensation(struct rtw_adapter *padapter , u8 *rssi_wifi , u8 *rssi_bt ) 
{ 


  {
#line 10961
  BTDM_8723ASignalCompensation(padapter, rssi_wifi, rssi_bt);
#line 10962
  return;
}
}
#line 10964 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_BT_do_coexist(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  int tmp___0 ;

  {
#line 10966
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10968
  tmp = rtl8723a_BT_coexist(padapter);
#line 10968
  if (tmp) {
#line 10968
    tmp___0 = 0;
  } else {
#line 10968
    tmp___0 = 1;
  }
#line 10968
  if (tmp___0) {
#line 10969
    if (BTCoexDbgLevel == 1U) {
#line 10969
      printk("[DM][BT], BT not exists!!\n");
    } else {

    }
#line 10970
    return;
  } else {

  }
#line 10973
  if ((unsigned int )pHalData->bt_coexist.bInitlized == 0U) {
#line 10974
    if (BTCoexDbgLevel == 1U) {
#line 10974
      printk("[DM][BT], btdm_InitBtCoexistDM()\n");
    } else {

    }
#line 10975
    btdm_InitBtCoexistDM(padapter);
  } else {

  }
#line 10978
  if (BTCoexDbgLevel == 1U) {
#line 10978
    printk("\n\n[DM][BT], BTDM start!!\n");
  } else {

  }
#line 10980
  BTDM_PWDBMonitor(padapter);
#line 10982
  if (BTCoexDbgLevel == 1U) {
#line 10982
    printk("[DM][BT], HW type is 8723\n");
  } else {

  }
#line 10983
  BTDM_BTCoexist8723A(padapter);
#line 10984
  if (BTCoexDbgLevel == 1U) {
#line 10984
    printk("[DM][BT], BTDM end!!\n\n");
  } else {

  }
#line 10985
  return;
}
}
#line 10987 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_UpdateCoexState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  u8 tmp ;

  {
#line 10989
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 10991
  tmp = BTDM_IsSameCoexistState(padapter);
#line 10991
  if ((unsigned int )tmp == 0U) {
#line 10992
    if (BTCoexDbgLevel == 1U) {
#line 10992
      printk("[BTCoex], Coexist State[bitMap] change from 0x%llx to 0x%llx,  changeBits = 0x%llx\n",
             pHalData->bt_coexist.PreviousState, pHalData->bt_coexist.CurrentState,
             pHalData->bt_coexist.PreviousState ^ pHalData->bt_coexist.CurrentState);
    } else {

    }
#line 10996
    pHalData->bt_coexist.PreviousState = pHalData->bt_coexist.CurrentState;
  } else {

  }
#line 10998
  return;
}
}
#line 11000 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsSameCoexistState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11002
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11004
  if (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState) {
#line 11005
    return (1U);
  } else {
#line 11007
    if (BTCoexDbgLevel == 1U) {
#line 11007
      printk("[DM][BT], Coexist state changed!!\n");
    } else {

    }
#line 11008
    return (0U);
  }
}
}
#line 11012 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_PWDBMonitor(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct hal_data_8723a *pHalData ;
  u8 H2C_Parameter[3U] ;
  unsigned int tmp ;
  s32 tmpBTEntryMaxPWDB ;
  s32 tmpBTEntryMinPWDB ;
  u8 i ;
  u32 __i ;
  u8 *ptr ;

  {
#line 11014
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11015
  pBtMgnt = & pBTInfo->BtMgnt;
#line 11016
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11017
  H2C_Parameter[0] = 0U;
#line 11017
  tmp = 1U;
#line 11017
  while (1) {
#line 11017
    if (tmp >= 3U) {
#line 11017
      break;
    } else {

    }
#line 11017
    H2C_Parameter[tmp] = (unsigned char)0;
#line 11017
    tmp = tmp + 1U;
  }
#line 11018
  tmpBTEntryMaxPWDB = 0;
#line 11018
  tmpBTEntryMinPWDB = 255;
#line 11021
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
#line 11022
    i = 0U;
#line 11022
    goto ldv_56887;
    ldv_56886: ;
#line 11023
    if ((unsigned int )pBTInfo->BtAsocEntry[(int )i].bUsed != 0U) {
#line 11024
      if (pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB < tmpBTEntryMinPWDB) {
#line 11025
        tmpBTEntryMinPWDB = pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      } else {

      }
#line 11026
      if (pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB > tmpBTEntryMaxPWDB) {
#line 11027
        tmpBTEntryMaxPWDB = pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
      } else {

      }
#line 11029
      H2C_Parameter[2] = (unsigned char )pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB;
#line 11030
      H2C_Parameter[0] = 63U - (unsigned int )i;
#line 11031
      if (BTCoexDbgLevel == 1U) {
#line 11031
        printk("RSSI report for BT[%d], H2C_Par = 0x%x\n", (int )i, (int )H2C_Parameter[0]);
      } else {

      }
#line 11032
      FillH2CCmd(padapter, 5, 3U, (u8 *)(& H2C_Parameter));
#line 11033
      if (BTCoexDbgLevel == 1U) {
#line 11033
        ptr = (u8 *)(& pBTInfo->BtAsocEntry[(int )i].BTRemoteMACAddr);
#line 11033
        printk("BT_Entry Mac :");
#line 11033
        printk(" ");
#line 11033
        __i = 0U;
#line 11033
        goto ldv_56884;
        ldv_56883: 
#line 11033
        printk("%02X%s", (int )*(ptr + (unsigned long )__i), __i == 5U ? (char *)"" : (char *)"-");
#line 11033
        __i = __i + 1U;
        ldv_56884: ;
#line 11033
        if (__i <= 5U) {
#line 11035
          goto ldv_56883;
        } else {

        }
#line 11033
        printk("\n");
      } else {

      }
#line 11035
      if (BTCoexDbgLevel == 1U) {
#line 11035
        printk("BT rx pwdb[%d] = 0x%x(%d)\n", (int )i, pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB,
               pBTInfo->BtAsocEntry[(int )i].UndecoratedSmoothedPWDB);
      } else {

      }
    } else {

    }
#line 11022
    i = (u8 )((int )i + 1);
    ldv_56887: ;
#line 11022
    if ((unsigned int )i <= 1U) {
#line 11024
      goto ldv_56886;
    } else {

    }

#line 11041
    if (tmpBTEntryMaxPWDB != 0) {
#line 11042
      pHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = tmpBTEntryMaxPWDB;
#line 11043
      if (BTCoexDbgLevel == 1U) {
#line 11043
        printk("BT_EntryMaxPWDB = 0x%x(%d)\n", tmpBTEntryMaxPWDB, tmpBTEntryMaxPWDB);
      } else {

      }
    } else {
#line 11046
      pHalData->dmpriv.BT_EntryMaxUndecoratedSmoothedPWDB = 0;
    }
#line 11048
    if (tmpBTEntryMinPWDB != 255) {
#line 11049
      pHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = tmpBTEntryMinPWDB;
#line 11050
      if (BTCoexDbgLevel == 1U) {
#line 11050
        printk("BT_EntryMinPWDB = 0x%x(%d)\n", tmpBTEntryMinPWDB, tmpBTEntryMinPWDB);
      } else {

      }
    } else {
#line 11053
      pHalData->dmpriv.BT_EntryMinUndecoratedSmoothedPWDB = 0;
    }
  } else {

  }
#line 11055
  return;
}
}
#line 11058 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsBTBusy(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 11060
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11061
  pBtMgnt = & pBTInfo->BtMgnt;
#line 11063
  if ((unsigned int )pBtMgnt->ExtConfig.bBTBusy != 0U) {
#line 11064
    return (1U);
  } else {
#line 11066
    return (0U);
  }
}
}
#line 11069 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsWifiBusy(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;

  {
#line 11072
  pmlmepriv = & padapter->mlmepriv;
#line 11073
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11074
  pBtTraffic = & pBTInfo->BtTraffic;
#line 11076
  if (((int )pmlmepriv->LinkDetectInfo.bBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic != 0U) || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic != 0U) {
#line 11079
    return (1U);
  } else {
#line 11081
    return (0U);
  }
}
}
#line 11084 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsCoexistStateChanged(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11086
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11088
  if (pHalData->bt_coexist.PreviousState == pHalData->bt_coexist.CurrentState) {
#line 11089
    return (0U);
  } else {
#line 11091
    return (1U);
  }
}
}
#line 11094 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsWifiUplink(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;

  {
#line 11101
  pmlmepriv = & padapter->mlmepriv;
#line 11102
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11103
  pBtTraffic = & pBTInfo->BtTraffic;
#line 11105
  if ((int )pmlmepriv->LinkDetectInfo.bTxBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bTxBusyTraffic != 0U) {
#line 11107
    return (1U);
  } else {
#line 11109
    return (0U);
  }
}
}
#line 11112 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsWifiDownlink(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct bt_30info *pBTInfo ;
  struct bt_traffic *pBtTraffic ;

  {
#line 11119
  pmlmepriv = & padapter->mlmepriv;
#line 11120
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11121
  pBtTraffic = & pBTInfo->BtTraffic;
#line 11123
  if ((int )pmlmepriv->LinkDetectInfo.bRxBusyTraffic || (unsigned int )pBtTraffic->Bt30TrafficStatistics.bRxBusyTraffic != 0U) {
#line 11125
    return (1U);
  } else {
#line 11127
    return (0U);
  }
}
}
#line 11130 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsBTHSMode(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_mgnt *pBtMgnt ;

  {
#line 11136
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11137
  pBtMgnt = & pHalData->BtInfo.BtMgnt;
#line 11139
  if ((unsigned int )pBtMgnt->BtOperationOn != 0U) {
#line 11140
    return (1U);
  } else {
#line 11142
    return (0U);
  }
}
}
#line 11145 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsBTUplink(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11147
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11149
  if ((unsigned int )pHalData->bt_coexist.BT21TrafficStatistics.bTxBusyTraffic != 0U) {
#line 11150
    return (1U);
  } else {
#line 11152
    return (0U);
  }
}
}
#line 11155 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsBTDownlink(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11157
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11159
  if ((unsigned int )pHalData->bt_coexist.BT21TrafficStatistics.bRxBusyTraffic != 0U) {
#line 11160
    return (1U);
  } else {
#line 11162
    return (0U);
  }
}
}
#line 11165 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_AdjustForBtOperation(struct rtw_adapter *padapter ) 
{ 


  {
#line 11167
  if (BTCoexDbgLevel == 1U) {
#line 11167
    printk("[BT][DM], BTDM_AdjustForBtOperation()\n");
  } else {

  }
#line 11168
  BTDM_AdjustForBtOperation8723A(padapter);
#line 11169
  return;
}
}
#line 11171 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_SetBtCoexCurrAntNum(struct rtw_adapter *padapter , u8 antNum ) 
{ 


  {
#line 11173
  BTDM_Set8723ABtCoexCurrAntNum(padapter, (int )antNum);
#line 11174
  return;
}
}
#line 11176 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_ForHalt(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 11178
  tmp = rtl8723a_BT_coexist(padapter);
#line 11178
  if (tmp) {
#line 11178
    tmp___0 = 0;
  } else {
#line 11178
    tmp___0 = 1;
  }
#line 11178
  if (tmp___0) {
#line 11179
    return;
  } else {

  }
#line 11181
  BTDM_ForHalt8723A(padapter);
#line 11182
  ((struct hal_data_8723a *)padapter->HalData)->bt_coexist.bInitlized = 0U;
#line 11183
  return;
}
}
#line 11185 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_WifiScanNotify(struct rtw_adapter *padapter , u8 scanType ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 11187
  tmp = rtl8723a_BT_coexist(padapter);
#line 11187
  if (tmp) {
#line 11187
    tmp___0 = 0;
  } else {
#line 11187
    tmp___0 = 1;
  }
#line 11187
  if (tmp___0) {
#line 11188
    return;
  } else {

  }
#line 11190
  BTDM_WifiScanNotify8723A(padapter, (int )scanType);
#line 11191
  return;
}
}
#line 11193 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_WifiAssociateNotify(struct rtw_adapter *padapter , u8 action ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 11195
  tmp = rtl8723a_BT_coexist(padapter);
#line 11195
  if (tmp) {
#line 11195
    tmp___0 = 0;
  } else {
#line 11195
    tmp___0 = 1;
  }
#line 11195
  if (tmp___0) {
#line 11196
    return;
  } else {

  }
#line 11198
  BTDM_WifiAssociateNotify8723A(padapter, (int )action);
#line 11199
  return;
}
}
#line 11201 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_BT_mediastatus_notify(struct rtw_adapter *padapter , enum rt_media_status mstatus ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 11204
  tmp = rtl8723a_BT_coexist(padapter);
#line 11204
  if (tmp) {
#line 11204
    tmp___0 = 0;
  } else {
#line 11204
    tmp___0 = 1;
  }
#line 11204
  if (tmp___0) {
#line 11205
    return;
  } else {

  }
#line 11207
  BTDM_MediaStatusNotify8723A(padapter, mstatus);
#line 11208
  return;
}
}
#line 11210 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_BT_specialpacket_notify(struct rtw_adapter *padapter ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 11212
  tmp = rtl8723a_BT_coexist(padapter);
#line 11212
  if (tmp) {
#line 11212
    tmp___0 = 0;
  } else {
#line 11212
    tmp___0 = 1;
  }
#line 11212
  if (tmp___0) {
#line 11213
    return;
  } else {

  }
#line 11215
  BTDM_ForDhcp8723A(padapter);
#line 11216
  return;
}
}
#line 11218 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void BTDM_ResetActionProfileState(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11220
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11222
  pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState & 0xffffffffff0fffffULL;
#line 11223
  return;
}
}
#line 11227 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsActionSCO(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;

  {
#line 11235
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11236
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11237
  pBtMgnt = & pBTInfo->BtMgnt;
#line 11238
  pBtDbg = & pBTInfo->BtDbg;
#line 11239
  bRet = 0U;
#line 11241
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11242
    if (pBtDbg->dbgProfile == 1U) {
#line 11243
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8388608ULL;
#line 11244
      bRet = 1U;
    } else {

    }
  } else
#line 11247
  if ((unsigned int )pBtMgnt->ExtConfig.NumberOfSCO != 0U) {
#line 11248
    pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 8388608ULL;
#line 11249
    bRet = 1U;
  } else {

  }
#line 11252
  return (bRet);
}
}
#line 11255 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsActionHID(struct rtw_adapter *padapter ) 
{ 
  struct bt_30info *pBTInfo ;
  struct hal_data_8723a *pHalData ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;

  {
#line 11263
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11264
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11265
  pBtMgnt = & pBTInfo->BtMgnt;
#line 11266
  pBtDbg = & pBTInfo->BtDbg;
#line 11267
  bRet = 0U;
#line 11269
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11270
    if (pBtDbg->dbgProfile == 2U) {
#line 11271
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1048576ULL;
#line 11272
      bRet = 1U;
    } else {

    }
  } else {
#line 11275
    tmp = BTHCI_CheckProfileExist(padapter, 3);
#line 11275
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 11277
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 1048576ULL;
#line 11278
      bRet = 1U;
    } else {

    }
  }
#line 11281
  return (bRet);
}
}
#line 11284 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsActionA2DP(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;

  {
#line 11292
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11293
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11294
  pBtMgnt = & pBTInfo->BtMgnt;
#line 11295
  pBtDbg = & pBTInfo->BtDbg;
#line 11296
  bRet = 0U;
#line 11298
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11299
    if (pBtDbg->dbgProfile == 3U) {
#line 11300
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2097152ULL;
#line 11301
      bRet = 1U;
    } else {

    }
  } else {
#line 11304
    tmp = BTHCI_CheckProfileExist(padapter, 1);
#line 11304
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 11306
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 2097152ULL;
#line 11307
      bRet = 1U;
    } else {

    }
  }
#line 11310
  return (bRet);
}
}
#line 11313 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsActionPAN(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;

  {
#line 11321
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11322
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11323
  pBtMgnt = & pBTInfo->BtMgnt;
#line 11324
  pBtDbg = & pBTInfo->BtDbg;
#line 11325
  bRet = 0U;
#line 11327
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11328
    if (pBtDbg->dbgProfile == 4U) {
#line 11329
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4194304ULL;
#line 11330
      bRet = 1U;
    } else {

    }
  } else {
#line 11333
    tmp = BTHCI_CheckProfileExist(padapter, 2);
#line 11333
    if ((unsigned int )tmp != 0U && (unsigned int )pBtMgnt->ExtConfig.NumberOfHandle == 1U) {
#line 11335
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 4194304ULL;
#line 11336
      bRet = 1U;
    } else {

    }
  }
#line 11339
  return (bRet);
}
}
#line 11342 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsActionHIDA2DP(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_mgnt *pBtMgnt ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 11350
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11351
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11352
  pBtMgnt = & pBTInfo->BtMgnt;
#line 11353
  pBtDbg = & pBTInfo->BtDbg;
#line 11354
  bRet = 0U;
#line 11356
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11357
    if (pBtDbg->dbgProfile == 5U) {
#line 11358
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 3145728ULL;
#line 11359
      bRet = 1U;
    } else {

    }
  } else {
#line 11362
    tmp = BTHCI_CheckProfileExist(padapter, 3);
#line 11362
    if ((unsigned int )tmp != 0U) {
#line 11362
      tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
#line 11362
      if ((unsigned int )tmp___0 != 0U) {
#line 11364
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 3145728ULL;
#line 11365
        bRet = 1U;
      } else {

      }
    } else {

    }
  }
#line 11368
  return (bRet);
}
}
#line 11371 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsActionHIDPAN(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 11378
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11379
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11380
  pBtDbg = & pBTInfo->BtDbg;
#line 11381
  bRet = 0U;
#line 11383
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11384
    if (pBtDbg->dbgProfile == 6U) {
#line 11385
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 5242880ULL;
#line 11386
      bRet = 1U;
    } else {

    }
  } else {
#line 11389
    tmp = BTHCI_CheckProfileExist(padapter, 3);
#line 11389
    if ((unsigned int )tmp != 0U) {
#line 11389
      tmp___0 = BTHCI_CheckProfileExist(padapter, 2);
#line 11389
      if ((unsigned int )tmp___0 != 0U) {
#line 11391
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 5242880ULL;
#line 11392
        bRet = 1U;
      } else {

      }
    } else {

    }
  }
#line 11395
  return (bRet);
}
}
#line 11398 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 BTDM_IsActionPANA2DP(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct bt_30info *pBTInfo ;
  struct bt_dgb *pBtDbg ;
  u8 bRet ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 11405
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11406
  pBTInfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11407
  pBtDbg = & pBTInfo->BtDbg;
#line 11408
  bRet = 0U;
#line 11410
  if ((unsigned int )pBtDbg->dbgCtrl != 0U) {
#line 11411
    if (pBtDbg->dbgProfile == 7U) {
#line 11412
      pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 6291456ULL;
#line 11413
      bRet = 1U;
    } else {

    }
  } else {
#line 11416
    tmp = BTHCI_CheckProfileExist(padapter, 2);
#line 11416
    if ((unsigned int )tmp != 0U) {
#line 11416
      tmp___0 = BTHCI_CheckProfileExist(padapter, 1);
#line 11416
      if ((unsigned int )tmp___0 != 0U) {
#line 11417
        pHalData->bt_coexist.CurrentState = pHalData->bt_coexist.CurrentState | 6291456ULL;
#line 11418
        bRet = 1U;
      } else {

      }
    } else {

    }
  }
#line 11421
  return (bRet);
}
}
#line 11424 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
bool rtl8723a_BT_enabled(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11426
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11428
  if ((unsigned int )pHalData->bt_coexist.bCurBtDisabled != 0U) {
#line 11429
    return (0);
  } else {
#line 11431
    return (1);
  }
}
}
#line 11442 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
static void halbt_InitHwConfig8723A(struct rtw_adapter *padapter ) 
{ 


  {
#line 11444
  return;
}
}
#line 11449 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 HALBT_GetPGAntNum(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11451
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11453
  return (pHalData->bt_coexist.BT_Ant_Num);
}
}
#line 11456 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void HALBT_SetKey(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTinfo ;
  struct bt_asoc_entry *pBtAssocEntry ;
  u16 usConfig ;

  {
#line 11460
  usConfig = 0U;
#line 11462
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11463
  pBtAssocEntry = (struct bt_asoc_entry *)(& pBTinfo->BtAsocEntry) + (unsigned long )EntryNum;
#line 11465
  pBtAssocEntry->HwCAMIndex = (unsigned int )EntryNum + 12U;
#line 11467
  usConfig = 32784U;
#line 11468
  rtl8723a_cam_write(padapter, (int )pBtAssocEntry->HwCAMIndex, (int )usConfig, (u8 const   *)(& pBtAssocEntry->BTRemoteMACAddr),
                     (u8 const   *)(& pBtAssocEntry->PTK) + 32U);
#line 11471
  return;
}
}
#line 11473 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void HALBT_RemoveKey(struct rtw_adapter *padapter , u8 EntryNum ) 
{ 
  struct bt_30info *pBTinfo ;
  struct bt_asoc_entry *pBtAssocEntry ;

  {
#line 11478
  pBTinfo = & ((struct hal_data_8723a *)padapter->HalData)->BtInfo;
#line 11479
  pBtAssocEntry = (struct bt_asoc_entry *)(& pBTinfo->BtAsocEntry) + (unsigned long )EntryNum;
#line 11481
  if ((unsigned int )pBTinfo->BtAsocEntry[(int )EntryNum].HwCAMIndex != 0U) {
#line 11483
    if ((unsigned int )pBtAssocEntry->HwCAMIndex > 11U && (unsigned int )pBtAssocEntry->HwCAMIndex <= 15U) {
#line 11485
      rtl8723a_cam_empty_entry(padapter, (int )pBtAssocEntry->HwCAMIndex);
    } else {

    }
#line 11487
    pBTinfo->BtAsocEntry[(int )EntryNum].HwCAMIndex = 0U;
  } else {

  }
#line 11489
  return;
}
}
#line 11491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_BT_init_hal_vars(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 11495
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11497
  pHalData->bt_coexist.BluetoothCoexist = pHalData->EEPROMBluetoothCoexist;
#line 11498
  pHalData->bt_coexist.BT_Ant_Num = pHalData->EEPROMBluetoothAntNum;
#line 11499
  pHalData->bt_coexist.BT_CoexistType = pHalData->EEPROMBluetoothType;
#line 11500
  pHalData->bt_coexist.BT_Ant_isolation = pHalData->EEPROMBluetoothAntIsolation;
#line 11501
  pHalData->bt_coexist.bt_radiosharedtype = pHalData->EEPROMBluetoothRadioShared;
#line 11503
  if (GlobalDebugLevel23A > 6U) {
#line 11503
    printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 11503
    tmp = rtl8723a_BT_coexist(padapter);
#line 11503
    printk("\016BT Coexistance = 0x%x\n", (int )tmp);
  } else {

  }
#line 11506
  tmp___0 = rtl8723a_BT_coexist(padapter);
#line 11506
  if ((int )tmp___0) {
#line 11507
    if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 0U) {
#line 11508
      BTDM_SetBtCoexCurrAntNum(padapter, 2);
#line 11509
      if (GlobalDebugLevel23A > 6U) {
#line 11509
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 11509
        printk("\016BlueTooth BT_Ant_Num = Antx2\n");
      } else {

      }
    } else
#line 11510
    if ((unsigned int )pHalData->bt_coexist.BT_Ant_Num == 1U) {
#line 11511
      BTDM_SetBtCoexCurrAntNum(padapter, 1);
#line 11512
      if (GlobalDebugLevel23A > 6U) {
#line 11512
        printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 11512
        printk("\016BlueTooth BT_Ant_Num = Antx1\n");
      } else {

      }
    } else {

    }
#line 11514
    pHalData->bt_coexist.bBTBusyTraffic = 0U;
#line 11515
    pHalData->bt_coexist.bBTTrafficModeSet = 0U;
#line 11516
    pHalData->bt_coexist.bBTNonTrafficModeSet = 0U;
#line 11517
    pHalData->bt_coexist.CurrentState = 0ULL;
#line 11518
    pHalData->bt_coexist.PreviousState = 0ULL;
#line 11520
    if (GlobalDebugLevel23A > 6U) {
#line 11520
      printk("\016%s [0x%08x,%d]", (char *)"RTL8723AU: ", 16384U, 7);
#line 11520
      printk("\016bt_radiosharedType = 0x%x\n", (int )pHalData->bt_coexist.bt_radiosharedtype);
    } else {

    }
  } else {

  }
#line 11523
  return;
}
}
#line 11526 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
bool rtl8723a_BT_coexist(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11528
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11530
  if ((unsigned int )pHalData->bt_coexist.BluetoothCoexist != 0U) {
#line 11531
    return (1);
  } else {
#line 11533
    return (0);
  }
}
}
#line 11536 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
u8 HALBT_BTChipType(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;

  {
#line 11538
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11540
  return (pHalData->bt_coexist.BT_CoexistType);
}
}
#line 11543 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_BT_init_hwconfig(struct rtw_adapter *padapter ) 
{ 


  {
#line 11545
  halbt_InitHwConfig8723A(padapter);
#line 11546
  rtl8723a_BT_do_coexist(padapter);
#line 11547
  return;
}
}
#line 11549 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void HALBT_SetRtsCtsNoLenLimit(struct rtw_adapter *padapter ) 
{ 


  {
#line 11551
  return;
}
}
#line 11555 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void rtl8723a_dual_antenna_detection(struct rtw_adapter *padapter ) 
{ 
  struct hal_data_8723a *pHalData ;
  struct dm_odm_t *pDM_Odm ;
  struct sw_ant_sw *pDM_SWAT_Table ;
  u8 i ;
  u8 btAntNum ;
  u8 tmp ;
  bool tmp___0 ;

  {
#line 11562
  pHalData = (struct hal_data_8723a *)padapter->HalData;
#line 11563
  pDM_Odm = & pHalData->odmpriv;
#line 11564
  pDM_SWAT_Table = & pDM_Odm->DM_SWAT_Table;
#line 11573
  if ((unsigned int )pHalData->bAntennaDetected == 0U) {
#line 11574
    tmp = HALBT_GetPGAntNum(padapter);
#line 11574
    btAntNum = tmp;
#line 11577
    if ((unsigned int )btAntNum == 0U) {
#line 11578
      pDM_SWAT_Table->ANTB_ON = 1;
    } else
#line 11579
    if ((unsigned int )btAntNum == 1U) {
#line 11580
      pDM_SWAT_Table->ANTB_ON = 0;
    } else {
#line 11582
      pDM_SWAT_Table->ANTB_ON = 1;
    }
#line 11584
    if ((unsigned int )pHalData->CustomerID != 9U) {
#line 11585
      i = 0U;
#line 11585
      goto ldv_57064;
      ldv_57063: 
#line 11586
      tmp___0 = ODM_SingleDualAntennaDetection(& pHalData->odmpriv, 0);
#line 11586
      if ((int )tmp___0) {
#line 11588
        goto ldv_57062;
      } else {

      }
#line 11585
      i = (u8 )((int )i + 1);
      ldv_57064: ;
#line 11585
      if ((unsigned int )i <= 9U) {
#line 11587
        goto ldv_57063;
      } else {

      }
      ldv_57062: ;
#line 11592
      if ((unsigned int )btAntNum == 0U) {
#line 11593
        BTDM_SetBtCoexCurrAntNum(padapter, (int )pDM_SWAT_Table->ANTB_ON ? 2 : 1);
      } else {

      }
    } else {

    }
#line 11597
    pHalData->bAntennaDetected = 1U;
  } else {

  }
#line 11599
  return;
}
}
#line 11728 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
void *ldv_kmem_cache_alloc_2404(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 11731
  ldv_check_alloc_flags(flags);
#line 11733
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 11734
  return ((void *)0);
}
}
#line 11772 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_pskb_expand_head_2410(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 11775
  ldv_check_alloc_flags(flags);
#line 11777
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 11777
  return (tmp);
}
}
#line 11788 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
struct sk_buff *ldv_skb_clone_2412(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 11791
  ldv_check_alloc_flags(flags);
#line 11793
  tmp = skb_clone(ldv_func_arg1, flags);
#line 11793
  return (tmp);
}
}
#line 11804 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
struct sk_buff *ldv_skb_copy_2414(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 11807
  ldv_check_alloc_flags(flags);
#line 11809
  tmp = skb_copy(ldv_func_arg1, flags);
#line 11809
  return (tmp);
}
}
#line 11812 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2415(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 11815
  ldv_check_alloc_flags(flags);
#line 11817
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 11817
  return (tmp);
}
}
#line 11820 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2416(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 11823
  ldv_check_alloc_flags(flags);
#line 11825
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 11825
  return (tmp);
}
}
#line 11828 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2417(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 11831
  ldv_check_alloc_flags(flags);
#line 11833
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 11833
  return (tmp);
}
}
#line 11836 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_pskb_expand_head_2418(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 11839
  ldv_check_alloc_flags(flags);
#line 11841
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 11841
  return (tmp);
}
}
#line 11844 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_pskb_expand_head_2419(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 11847
  ldv_check_alloc_flags(flags);
#line 11849
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 11849
  return (tmp);
}
}
#line 11852 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
struct sk_buff *ldv_skb_clone_2420(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 11855
  ldv_check_alloc_flags(flags);
#line 11857
  tmp = skb_clone(ldv_func_arg1, flags);
#line 11857
  return (tmp);
}
}
#line 11860 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_mod_timer_2421(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
#line 11864
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 11864
  ldv_func_res = tmp;
#line 11866
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 11868
  return (ldv_func_res);
}
}
#line 11871 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2422(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 11875
  tmp = del_timer_sync(ldv_func_arg1);
#line 11875
  ldv_func_res = tmp;
#line 11877
  disable_suitable_timer_6(ldv_func_arg1);
#line 11879
  return (ldv_func_res);
}
}
#line 11882 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2423(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 11886
  tmp = del_timer_sync(ldv_func_arg1);
#line 11886
  ldv_func_res = tmp;
#line 11888
  disable_suitable_timer_6(ldv_func_arg1);
#line 11890
  return (ldv_func_res);
}
}
#line 11893 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2424(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 11897
  tmp = del_timer_sync(ldv_func_arg1);
#line 11897
  ldv_func_res = tmp;
#line 11899
  disable_suitable_timer_6(ldv_func_arg1);
#line 11901
  return (ldv_func_res);
}
}
#line 11904 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2425(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 11908
  tmp = del_timer_sync(ldv_func_arg1);
#line 11908
  ldv_func_res = tmp;
#line 11910
  disable_suitable_timer_6(ldv_func_arg1);
#line 11912
  return (ldv_func_res);
}
}
#line 11915 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_mod_timer_2426(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 11919
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 11919
  ldv_func_res = tmp;
#line 11921
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 11923
  return (ldv_func_res);
}
}
#line 11926 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2427(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 11930
  tmp = del_timer_sync(ldv_func_arg1);
#line 11930
  ldv_func_res = tmp;
#line 11932
  disable_suitable_timer_6(ldv_func_arg1);
#line 11934
  return (ldv_func_res);
}
}
#line 11937 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_mod_timer_2428(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 11941
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 11941
  ldv_func_res = tmp;
#line 11943
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 11945
  return (ldv_func_res);
}
}
#line 11948 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2429(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 11952
  tmp = del_timer_sync(ldv_func_arg1);
#line 11952
  ldv_func_res = tmp;
#line 11954
  disable_suitable_timer_6(ldv_func_arg1);
#line 11956
  return (ldv_func_res);
}
}
#line 11959 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2430(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 11963
  tmp = del_timer_sync(ldv_func_arg1);
#line 11963
  ldv_func_res = tmp;
#line 11965
  disable_suitable_timer_6(ldv_func_arg1);
#line 11967
  return (ldv_func_res);
}
}
#line 11970 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2431(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 11974
  tmp = del_timer_sync(ldv_func_arg1);
#line 11974
  ldv_func_res = tmp;
#line 11976
  disable_suitable_timer_6(ldv_func_arg1);
#line 11978
  return (ldv_func_res);
}
}
#line 11981 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2432(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 11985
  tmp = del_timer_sync(ldv_func_arg1);
#line 11985
  ldv_func_res = tmp;
#line 11987
  disable_suitable_timer_6(ldv_func_arg1);
#line 11989
  return (ldv_func_res);
}
}
#line 11992 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2433(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 11996
  tmp = del_timer_sync(ldv_func_arg1);
#line 11996
  ldv_func_res = tmp;
#line 11998
  disable_suitable_timer_6(ldv_func_arg1);
#line 12000
  return (ldv_func_res);
}
}
#line 12003 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2434(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
#line 12007
  tmp = del_timer_sync(ldv_func_arg1);
#line 12007
  ldv_func_res = tmp;
#line 12009
  disable_suitable_timer_6(ldv_func_arg1);
#line 12011
  return (ldv_func_res);
}
}
#line 12014 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2435(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
#line 12018
  tmp = del_timer_sync(ldv_func_arg1);
#line 12018
  ldv_func_res = tmp;
#line 12020
  disable_suitable_timer_6(ldv_func_arg1);
#line 12022
  return (ldv_func_res);
}
}
#line 12025 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_mod_timer_2436(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
#line 12029
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 12029
  ldv_func_res = tmp;
#line 12031
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 12033
  return (ldv_func_res);
}
}
#line 12036 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/hal/rtl8723a_bt-coexist.o.c.prepared"
int ldv_del_timer_sync_2437(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;

  {
#line 12040
  tmp = del_timer_sync(ldv_func_arg1);
#line 12040
  ldv_func_res = tmp;
#line 12042
  disable_suitable_timer_6(ldv_func_arg1);
#line 12044
  return (ldv_func_res);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) ;
#line 354
__inline static void spin_unlock_bh(spinlock_t *lock ) ;
#line 319 "include/linux/slab.h"
void *ldv_kmem_cache_alloc_2480(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) ;
#line 445
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 759 "include/linux/skbuff.h"
struct sk_buff *ldv_skb_clone_2488(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 763
struct sk_buff *ldv_skb_clone_2496(struct sk_buff *ldv_func_arg1 , gfp_t flags ) ;
#line 768
struct sk_buff *ldv_skb_copy_2490(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) ;
#line 781
int ldv_pskb_expand_head_2486(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 785
int ldv_pskb_expand_head_2494(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 789
int ldv_pskb_expand_head_2495(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) ;
#line 2020
struct sk_buff *ldv___netdev_alloc_skb_2491(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2024
struct sk_buff *ldv___netdev_alloc_skb_2492(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 2028
struct sk_buff *ldv___netdev_alloc_skb_2493(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) ;
#line 34 "drivers/staging/rtl8723au/include/rtw_ap.h"
void update_sta_info23a_apmode23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 37
void rtw_set_macaddr_acl23a(struct rtw_adapter *padapter , int mode ) ;
#line 38
int rtw_acl_add_sta23a(struct rtw_adapter *padapter , u8 *addr ) ;
#line 39
int rtw_acl_remove_sta23a(struct rtw_adapter *padapter , u8 *addr ) ;
#line 43
u8 bss_cap_update_on_sta_leave23a(struct rtw_adapter *padapter , struct sta_info *psta ) ;
#line 48
int rtw_ap_inform_ch_switch23a(struct rtw_adapter *padapter , u8 new_ch , u8 ch_offset ) ;
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void init_mlme_ap_info23a(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct lock_class_key __key ;

  {
#line 249
  pmlmepriv = & padapter->mlmepriv;
#line 250
  pstapriv = & padapter->stapriv;
#line 251
  pacl_list = & pstapriv->acl_list;
#line 253
  spinlock_check(& pmlmepriv->bcn_update_lock);
#line 253
  __raw_spin_lock_init(& pmlmepriv->bcn_update_lock.ldv_6347.rlock, "&(&pmlmepriv->bcn_update_lock)->rlock",
                       & __key);
#line 256
  _rtw_init_queue23a(& pacl_list->acl_node_q);
#line 258
  start_ap_mode23a(padapter);
#line 259
  return;
}
}
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void free_mlme_ap_info23a(struct rtw_adapter *padapter ) 
{ 
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 263
  psta = (struct sta_info *)0;
#line 264
  pstapriv = & padapter->stapriv;
#line 265
  pmlmepriv = & padapter->mlmepriv;
#line 266
  pmlmeext = & padapter->mlmeextpriv;
#line 267
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 269
  pmlmepriv->update_bcn = 0U;
#line 270
  pmlmeext->bstart_bss = 0U;
#line 272
  rtw_sta_flush23a(padapter);
#line 274
  pmlmeinfo->state = 0U;
#line 277
  rtw_free_all_stainfo23a(padapter);
#line 280
  psta = rtw_get_bcmc_stainfo23a(padapter);
#line 281
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 282
  rtw_free_stainfo23a(padapter, psta);
#line 283
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 284
  return;
}
}
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_BCNTIM(struct rtw_adapter *padapter ) 
{ 
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork_mlmeext ;
  unsigned char *pie ;
  u8 *p ;
  u8 *dst_ie ;
  u8 *premainder_ie ;
  u8 *pbackup_remainder_ie ;
  __le16 tim_bitmap_le ;
  uint offset ;
  uint tmp_len ;
  uint tim_ielen ;
  uint tim_ie_offset ;
  uint remainder_ielen ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 288
  pstapriv = & padapter->stapriv;
#line 289
  pmlmeext = & padapter->mlmeextpriv;
#line 290
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 291
  pnetwork_mlmeext = & pmlmeinfo->network;
#line 292
  pie = (unsigned char *)(& pnetwork_mlmeext->IEs);
#line 293
  premainder_ie = (u8 *)0U;
#line 293
  pbackup_remainder_ie = (u8 *)0U;
#line 297
  tim_bitmap_le = pstapriv->tim_bitmap;
#line 299
  p = rtw_get_ie23a(pie + 12U, 5, (int *)(& tim_ielen), (int )(pnetwork_mlmeext->IELength - 12U));
#line 301
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && tim_ielen != 0U) {
#line 302
    tim_ielen = tim_ielen + 2U;
#line 304
    premainder_ie = p + (unsigned long )tim_ielen;
#line 306
    tim_ie_offset = (unsigned int )((long )p) - (unsigned int )((long )pie);
#line 308
    remainder_ielen = (pnetwork_mlmeext->IELength - tim_ie_offset) - tim_ielen;
#line 311
    dst_ie = p;
  } else {
#line 313
    tim_ielen = 0U;
#line 316
    offset = 12U;
#line 319
    p = rtw_get_ie23a(pie + 12U, 0, (int *)(& tmp_len), (int )(pnetwork_mlmeext->IELength - 12U));
#line 322
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 323
      offset = (tmp_len + offset) + 2U;
    } else {

    }
#line 326
    p = rtw_get_ie23a(pie + 12U, 1, (int *)(& tmp_len), (int )(pnetwork_mlmeext->IELength - 12U));
#line 329
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 330
      offset = (tmp_len + offset) + 2U;
    } else {

    }
#line 333
    offset = offset + 3U;
#line 335
    premainder_ie = pie + (unsigned long )offset;
#line 337
    remainder_ielen = (pnetwork_mlmeext->IELength - offset) - tim_ielen;
#line 340
    dst_ie = pie + (unsigned long )offset;
  }
#line 343
  if (remainder_ielen != 0U) {
#line 344
    tmp = kmalloc((size_t )remainder_ielen, 32U);
#line 344
    pbackup_remainder_ie = (u8 *)tmp;
#line 345
    if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U) && (unsigned long )premainder_ie != (unsigned long )((u8 *)0U)) {
#line 346
      __len = (size_t )remainder_ielen;
#line 346
      __ret = __builtin_memcpy((void *)pbackup_remainder_ie, (void const   *)premainder_ie,
                               __len);
    } else {

    }
  } else {

  }
#line 349
  tmp___0 = dst_ie;
#line 349
  dst_ie = dst_ie + 1;
#line 349
  *tmp___0 = 5U;
#line 351
  if (((int )pstapriv->tim_bitmap & 65280) != 0 && ((int )pstapriv->tim_bitmap & 252) != 0) {
#line 352
    tim_ielen = 5U;
  } else {
#line 354
    tim_ielen = 4U;
  }
#line 356
  tmp___1 = dst_ie;
#line 356
  dst_ie = dst_ie + 1;
#line 356
  *tmp___1 = (u8 )tim_ielen;
#line 358
  tmp___2 = dst_ie;
#line 358
  dst_ie = dst_ie + 1;
#line 358
  *tmp___2 = 0U;
#line 359
  tmp___3 = dst_ie;
#line 359
  dst_ie = dst_ie + 1;
#line 359
  *tmp___3 = 1U;
#line 361
  if ((int )pstapriv->tim_bitmap & 1) {
#line 362
    tmp___4 = dst_ie;
#line 362
    dst_ie = dst_ie + 1;
#line 362
    *tmp___4 = 1U;
  } else {
#line 364
    tmp___5 = dst_ie;
#line 364
    dst_ie = dst_ie + 1;
#line 364
    *tmp___5 = 0U;
  }
#line 366
  if (tim_ielen == 4U) {
#line 367
    tmp___6 = dst_ie;
#line 367
    dst_ie = dst_ie + 1;
#line 367
    *tmp___6 = *((u8 *)(& tim_bitmap_le));
  } else
#line 368
  if (tim_ielen == 5U) {
#line 369
    __len___0 = 2UL;
#line 369
    if (__len___0 > 63UL) {
#line 369
      __ret___0 = __memcpy((void *)dst_ie, (void const   *)(& tim_bitmap_le), __len___0);
    } else {
#line 369
      __ret___0 = __builtin_memcpy((void *)dst_ie, (void const   *)(& tim_bitmap_le),
                                   __len___0);
    }
#line 370
    dst_ie = dst_ie + 2UL;
  } else {

  }
#line 374
  if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
#line 375
    __len___1 = (size_t )remainder_ielen;
#line 375
    __ret___1 = __builtin_memcpy((void *)dst_ie, (void const   *)pbackup_remainder_ie,
                                 __len___1);
#line 377
    kfree((void const   *)pbackup_remainder_ie);
  } else {

  }
#line 380
  offset = (unsigned int )((long )dst_ie) - (unsigned int )((long )pie);
#line 381
  pnetwork_mlmeext->IELength = offset + remainder_ielen;
#line 383
  set_tx_beacon_cmd23a(padapter);
#line 384
  return;
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static u8 chk_sta_is_alive(struct sta_info *psta ) 
{ 
  u8 ret ;

  {
#line 388
  ret = 0U;
#line 390
  if (psta->sta_stats.last_rx_data_pkts + psta->sta_stats.last_rx_ctrl_pkts != psta->sta_stats.rx_data_pkts + psta->sta_stats.rx_ctrl_pkts) {
#line 393
    ret = 1U;
  } else {

  }
#line 395
  psta->sta_stats.last_rx_mgnt_pkts = psta->sta_stats.rx_mgnt_pkts;
#line 395
  psta->sta_stats.last_rx_beacon_pkts = psta->sta_stats.rx_beacon_pkts;
#line 395
  psta->sta_stats.last_rx_probereq_pkts = psta->sta_stats.rx_probereq_pkts;
#line 395
  psta->sta_stats.last_rx_probersp_pkts = psta->sta_stats.rx_probersp_pkts;
#line 395
  psta->sta_stats.last_rx_probersp_bm_pkts = psta->sta_stats.rx_probersp_bm_pkts;
#line 395
  psta->sta_stats.last_rx_probersp_uo_pkts = psta->sta_stats.rx_probersp_uo_pkts;
#line 395
  psta->sta_stats.last_rx_ctrl_pkts = psta->sta_stats.rx_ctrl_pkts;
#line 395
  psta->sta_stats.last_rx_data_pkts = psta->sta_stats.rx_data_pkts;
#line 397
  return (ret);
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void expire_timeout_chk23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 updated ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u8 tmp ;
  struct mlme_ext_priv *pmlmeext ;
  u32 tmp___0 ;
  u8 tmp___1 ;
  u8 backup_oper_channel ;
  struct mlme_ext_priv *pmlmeext___0 ;
  u8 tmp___2 ;
  int ret ;
  int tmp___3 ;

  {
#line 403
  updated = 0U;
#line 405
  pstapriv = & padapter->stapriv;
#line 406
  chk_alive_num = 0U;
#line 410
  spin_lock_bh(& pstapriv->auth_list_lock);
#line 412
  phead = & pstapriv->auth_list;
#line 415
  plist = phead->next;
#line 415
  ptmp = plist->next;
#line 415
  goto ldv_54265;
  ldv_54264: 
#line 416
  __mptr = (struct list_head  const  *)plist;
#line 416
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb80UL;
#line 418
  if (psta->expire_to != 0U) {
#line 419
    psta->expire_to = psta->expire_to - 1U;
#line 420
    if (psta->expire_to == 0U) {
#line 421
      list_del_init(& psta->auth_list);
#line 422
      pstapriv->auth_list_cnt = (u8 )((int )pstapriv->auth_list_cnt - 1);
#line 424
      if (GlobalDebugLevel23A > 3U) {
#line 424
        printk("\016RTL8723AU: auth expire %pM\n", (u8 *)(& psta->hwaddr));
      } else {

      }
#line 426
      spin_unlock_bh(& pstapriv->auth_list_lock);
#line 428
      spin_lock_bh(& pstapriv->sta_hash_lock);
#line 429
      rtw_free_stainfo23a(padapter, psta);
#line 430
      spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 432
      spin_lock_bh(& pstapriv->auth_list_lock);
    } else {

    }
  } else {

  }
#line 415
  plist = ptmp;
#line 415
  ptmp = plist->next;
  ldv_54265: ;
#line 415
  if ((unsigned long )plist != (unsigned long )phead) {
#line 417
    goto ldv_54264;
  } else {

  }
#line 438
  spin_unlock_bh(& pstapriv->auth_list_lock);
#line 440
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 442
  phead = & pstapriv->asoc_list;
#line 445
  plist = phead->next;
#line 445
  ptmp = plist->next;
#line 445
  goto ldv_54273;
  ldv_54272: 
#line 446
  __mptr___0 = (struct list_head  const  *)plist;
#line 446
  psta = (struct sta_info *)__mptr___0 + 0xffffffffffffeb90UL;
#line 448
  tmp = chk_sta_is_alive(psta);
#line 448
  if ((unsigned int )tmp != 0U || psta->expire_to == 0U) {
#line 449
    psta->expire_to = pstapriv->expire_to;
#line 450
    psta->keep_alive_trycnt = 0U;
  } else {
#line 452
    psta->expire_to = psta->expire_to - 1U;
  }
#line 455
  if (psta->expire_to == 0U) {
#line 457
    pmlmeext = & padapter->mlmeextpriv;
#line 459
    if ((unsigned int )padapter->registrypriv.wifi_spec == 1U) {
#line 461
      psta->expire_to = pstapriv->expire_to;
#line 462
      goto ldv_54270;
    } else {

    }
#line 465
    if ((psta->state & 4U) != 0U) {
#line 466
      if ((psta->state & 1024U) == 0U) {
#line 468
        psta->expire_to = pstapriv->expire_to;
#line 469
        psta->state = psta->state | 1024U;
#line 472
        tmp___0 = CHKBIT(psta->aid);
#line 472
        pstapriv->tim_bitmap = (int )pstapriv->tim_bitmap | (int )((u16 )tmp___0);
#line 473
        update_beacon23a(padapter, 5, (u8 *)0U, 0);
#line 475
        if ((unsigned int )pmlmeext->active_keep_alive_check == 0U) {
#line 476
          goto ldv_54270;
        } else {

        }
      } else {

      }
    } else {

    }
#line 480
    if ((unsigned int )pmlmeext->active_keep_alive_check != 0U) {
#line 481
      tmp___1 = chk_alive_num;
#line 481
      chk_alive_num = (u8 )((int )chk_alive_num + 1);
#line 481
      chk_alive_list[(int )tmp___1] = psta;
#line 482
      goto ldv_54270;
    } else {

    }
#line 485
    list_del_init(& psta->asoc_list);
#line 486
    pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 488
    if (GlobalDebugLevel23A > 3U) {
#line 488
      printk("\016RTL8723AU: asoc expire %02x:%02x:%02x:%02x:%02x:%02x, state = 0x%x\n",
             (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
             (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
             (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
             psta->state);
    } else {

    }
#line 489
    updated = ap_free_sta23a(padapter, psta, 0, 3);
  } else
#line 492
  if (psta->sleepq_len > (unsigned int )(256 / (int )pstapriv->asoc_list_cnt) && padapter->xmitpriv.free_xmitframe_cnt < 128 / (int )pstapriv->asoc_list_cnt) {
#line 495
    if (GlobalDebugLevel23A > 3U) {
#line 495
      printk("\016RTL8723AU: %s sta:%02x:%02x:%02x:%02x:%02x:%02x, sleepq_len:%u, free_xmitframe_cnt:%u, asoc_list_cnt:%u, clear sleep_q\n",
             "expire_timeout_chk23a", (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
             (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
             (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
             psta->sleepq_len, padapter->xmitpriv.free_xmitframe_cnt, (int )pstapriv->asoc_list_cnt);
    } else {

    }
#line 500
    wakeup_sta_to_xmit23a(padapter, psta);
  } else {

  }
  ldv_54270: 
#line 445
  plist = ptmp;
#line 445
  ptmp = plist->next;
  ldv_54273: ;
#line 445
  if ((unsigned long )plist != (unsigned long )phead) {
#line 447
    goto ldv_54272;
  } else {

  }
#line 505
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 507
  if ((unsigned int )chk_alive_num != 0U) {
#line 509
    backup_oper_channel = 0U;
#line 510
    pmlmeext___0 = & padapter->mlmeextpriv;
#line 512
    tmp___2 = rtw_get_oper_ch23a(padapter);
#line 512
    if ((int )tmp___2 != (int )pmlmeext___0->cur_channel) {
#line 513
      backup_oper_channel = rtw_get_oper_ch23a(padapter);
#line 514
      SelectChannel23a(padapter, (int )pmlmeext___0->cur_channel);
    } else {

    }
#line 518
    i = 0;
#line 518
    goto ldv_54280;
    ldv_54279: 
#line 520
    ret = 0;
#line 522
    psta = chk_alive_list[i];
#line 523
    if ((psta->state & 1U) == 0U) {
#line 524
      goto ldv_54278;
    } else {

    }
#line 526
    if ((psta->state & 4U) != 0U) {
#line 527
      ret = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 1,
                              50);
    } else {
#line 529
      ret = issue_nulldata23a(padapter, (unsigned char *)(& psta->hwaddr), 0U, 3,
                              50);
    }
#line 531
    psta->keep_alive_trycnt = (u8 )((int )psta->keep_alive_trycnt + 1);
#line 532
    if (ret == 1) {
#line 534
      if (GlobalDebugLevel23A > 3U) {
#line 534
        printk("\016RTL8723AU: asoc check, sta(%02x:%02x:%02x:%02x:%02x:%02x) is alive\n",
               (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
               (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
               (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL));
      } else {

      }
#line 535
      psta->expire_to = pstapriv->expire_to;
#line 536
      psta->keep_alive_trycnt = 0U;
#line 537
      goto ldv_54278;
    } else
#line 539
    if ((unsigned int )psta->keep_alive_trycnt <= 3U) {
#line 541
      if (GlobalDebugLevel23A > 3U) {
#line 541
        printk("\016RTL8723AU: ack check for asoc expire, keep_alive_trycnt =%d\n",
               (int )psta->keep_alive_trycnt);
      } else {

      }
#line 542
      psta->expire_to = 1U;
#line 543
      goto ldv_54278;
    } else {

    }
#line 546
    psta->keep_alive_trycnt = 0U;
#line 548
    if (GlobalDebugLevel23A > 3U) {
#line 548
      printk("\016RTL8723AU: asoc expire %02x:%02x:%02x:%02x:%02x:%02x, state = 0x%x\n",
             (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
             (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
             (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
             psta->state);
    } else {

    }
#line 549
    spin_lock_bh(& pstapriv->asoc_list_lock);
#line 550
    tmp___3 = list_empty((struct list_head  const  *)(& psta->asoc_list));
#line 550
    if (tmp___3 == 0) {
#line 551
      list_del_init(& psta->asoc_list);
#line 552
      pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 553
      updated = ap_free_sta23a(padapter, psta, 0, 3);
    } else {

    }
#line 555
    spin_unlock_bh(& pstapriv->asoc_list_lock);
    ldv_54278: 
#line 518
    i = i + 1;
    ldv_54280: ;
#line 518
    if ((int )chk_alive_num > i) {
#line 520
      goto ldv_54279;
    } else {

    }

#line 559
    if ((unsigned int )backup_oper_channel != 0U) {
#line 560
      SelectChannel23a(padapter, (int )backup_oper_channel);
    } else {

    }
  } else {

  }
#line 563
  associated_clients_update23a(padapter, (int )updated);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void add_RATid23a(struct rtw_adapter *padapter , struct sta_info *psta , u8 rssi_level ) 
{ 
  int i ;
  u8 rf_type ;
  u32 init_rate ;
  unsigned char sta_band ;
  unsigned char raid ;
  unsigned char shortGIrate ;
  unsigned char limit ;
  unsigned int tx_ra_bitmap ;
  struct ht_priv *psta_ht ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_network ;
  int tmp ;
  unsigned char tmp___0 ;
  u8 arg ;

  {
#line 570
  init_rate = 0U;
#line 571
  sta_band = 0U;
#line 571
  shortGIrate = 0U;
#line 573
  tx_ra_bitmap = 0U;
#line 574
  psta_ht = (struct ht_priv *)0;
#line 575
  pmlmepriv = & padapter->mlmepriv;
#line 576
  pcur_network = & pmlmepriv->cur_network.network;
#line 578
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 579
    psta_ht = & psta->htpriv;
  } else {
#line 581
    return;
  }
#line 583
  if ((psta->state & 1U) == 0U) {
#line 584
    return;
  } else {

  }
#line 587
  i = 0;
#line 587
  goto ldv_54299;
  ldv_54298: ;
#line 589
  if ((unsigned int )psta->bssrateset[i] != 0U) {
#line 590
    tmp = rtw_get_bit_value_from_ieee_value23a((int )psta->bssrateset[i] & 127);
#line 590
    tx_ra_bitmap = (unsigned int )tmp | tx_ra_bitmap;
  } else {

  }
#line 587
  i = i + 1;
  ldv_54299: ;
#line 587
  if ((unsigned int )i <= 15U) {
#line 589
    goto ldv_54298;
  } else {

  }

#line 593
  if (psta_ht->ht_option != 0U) {
#line 594
    rf_type = rtl8723a_get_rf_type(padapter);
#line 596
    if ((unsigned int )rf_type == 2U) {
#line 597
      limit = 16U;
    } else {
#line 599
      limit = 8U;
    }
#line 601
    i = 0;
#line 601
    goto ldv_54302;
    ldv_54301: ;
#line 602
    if ((int )((unsigned long )psta_ht->ht_cap.mcs.rx_mask[i / 8] >> i % 8) & 1) {
#line 603
      tx_ra_bitmap = (unsigned int )(1UL << (i + 12)) | tx_ra_bitmap;
    } else {

    }
#line 601
    i = i + 1;
    ldv_54302: ;
#line 601
    if ((int )limit > i) {
#line 603
      goto ldv_54301;
    } else {

    }
#line 607
    shortGIrate = psta_ht->sgi;
  } else {

  }
#line 610
  if (pcur_network->DSConfig > 14U) {
#line 612
    if ((tx_ra_bitmap & 268431360U) != 0U) {
#line 613
      sta_band = (unsigned int )sta_band | 20U;
    } else {
#line 615
      sta_band = (unsigned int )sta_band | 4U;
    }
  } else
#line 617
  if ((tx_ra_bitmap & 268431360U) != 0U) {
#line 618
    sta_band = (unsigned int )sta_band | 11U;
  } else
#line 619
  if ((tx_ra_bitmap & 4080U) != 0U) {
#line 620
    sta_band = (unsigned int )sta_band | 3U;
  } else {
#line 622
    sta_band = (unsigned int )sta_band | 1U;
  }
#line 625
  psta->wireless_mode = sta_band;
#line 627
  raid = networktype_to_raid23a((int )sta_band);
#line 628
  tmp___0 = get_highest_rate_idx23a(tx_ra_bitmap & 268435455U);
#line 628
  init_rate = (u32 )tmp___0 & 63U;
#line 630
  if (psta->aid <= 31U) {
#line 632
    arg = 0U;
#line 634
    arg = (unsigned int )((u8 )psta->mac_id) & 31U;
#line 636
    arg = (u8 )((unsigned int )arg | 128U);
#line 638
    if ((unsigned int )shortGIrate == 1U) {
#line 639
      arg = (u8 )((unsigned int )arg | 32U);
    } else {

    }
#line 641
    tx_ra_bitmap = (unsigned int )((int )raid << 28) | tx_ra_bitmap;
#line 643
    if (GlobalDebugLevel23A > 3U) {
#line 643
      printk("\016RTL8723AU: %s => mac_id:%d , raid:%d , bitmap = 0x%x, arg = 0x%x\n",
             "add_RATid23a", psta->mac_id, (int )raid, tx_ra_bitmap, (int )arg);
    } else {

    }
#line 651
    rtl8723a_add_rateatid(padapter, tx_ra_bitmap, (int )arg, (int )rssi_level);
#line 653
    if ((unsigned int )shortGIrate == 1U) {
#line 654
      init_rate = init_rate | 64U;
    } else {

    }
#line 657
    psta->raid = raid;
#line 658
    psta->init_rate = (u8 )init_rate;
  } else
#line 663
  if (GlobalDebugLevel23A > 3U) {
#line 663
    printk("\016RTL8723AU: station aid %d exceed the max number\n", psta->aid);
  } else {

  }
#line 664
  return;
}
}
#line 667 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bmc_sta(struct rtw_adapter *padapter ) 
{ 
  u32 init_rate ;
  unsigned char network_type ;
  unsigned char raid ;
  int i ;
  int supportRateNum ;
  unsigned int tx_ra_bitmap ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pcur_network ;
  struct sta_info *psta ;
  struct sta_info *tmp ;
  uint tmp___0 ;
  int tmp___1 ;
  size_t __len ;
  void *__ret ;
  int tmp___2 ;
  unsigned char tmp___3 ;
  u8 arg ;

  {
#line 669
  init_rate = 0U;
#line 671
  supportRateNum = 0;
#line 672
  tx_ra_bitmap = 0U;
#line 673
  pmlmepriv = & padapter->mlmepriv;
#line 674
  pcur_network = & pmlmepriv->cur_network.network;
#line 675
  tmp = rtw_get_bcmc_stainfo23a(padapter);
#line 675
  psta = tmp;
#line 677
  if ((unsigned long )psta != (unsigned long )((struct sta_info *)0)) {
#line 679
    psta->aid = 0U;
#line 680
    psta->mac_id = psta->aid + 1U;
#line 682
    psta->qos_option = 0U;
#line 683
    psta->htpriv.ht_option = 0U;
#line 685
    psta->ieee8021x_blocked = 0U;
#line 687
    memset((void *)(& psta->sta_stats), 0, 168UL);
#line 690
    tmp___0 = rtw_get_rateset_len23a((u8 *)(& pcur_network->SupportedRates));
#line 690
    supportRateNum = (int )tmp___0;
#line 691
    tmp___1 = rtw_check_network_type23a((unsigned char *)(& pcur_network->SupportedRates),
                                        supportRateNum, 1);
#line 691
    network_type = (unsigned char )tmp___1;
#line 693
    __len = (size_t )supportRateNum;
#line 693
    __ret = __builtin_memcpy((void *)(& psta->bssrateset), (void const   *)(& pcur_network->SupportedRates),
                             __len);
#line 694
    psta->bssratelen = (u32 )supportRateNum;
#line 697
    i = 0;
#line 697
    goto ldv_54322;
    ldv_54321: ;
#line 699
    if ((unsigned int )psta->bssrateset[i] != 0U) {
#line 700
      tmp___2 = rtw_get_bit_value_from_ieee_value23a((int )psta->bssrateset[i] & 127);
#line 700
      tx_ra_bitmap = (unsigned int )tmp___2 | tx_ra_bitmap;
    } else {

    }
#line 697
    i = i + 1;
    ldv_54322: ;
#line 697
    if (i < supportRateNum) {
#line 699
      goto ldv_54321;
    } else {

    }

#line 703
    if (pcur_network->DSConfig > 14U) {
#line 705
      network_type = 4U;
#line 706
      tx_ra_bitmap = 336U;
    } else {
#line 709
      network_type = 1U;
#line 710
      tx_ra_bitmap = 15U;
    }
#line 713
    raid = networktype_to_raid23a((int )network_type);
#line 714
    tmp___3 = get_highest_rate_idx23a(tx_ra_bitmap & 268435455U);
#line 714
    init_rate = (u32 )tmp___3 & 63U;
#line 717
    rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
#line 720
    arg = 0U;
#line 722
    arg = (unsigned int )((u8 )psta->mac_id) & 31U;
#line 724
    arg = (u8 )((unsigned int )arg | 128U);
#line 726
    tx_ra_bitmap = (unsigned int )((int )raid << 28) | tx_ra_bitmap;
#line 728
    if (GlobalDebugLevel23A > 3U) {
#line 728
      printk("\016RTL8723AU: update_bmc_sta, mask = 0x%x, arg = 0x%x\n", tx_ra_bitmap,
             (int )arg);
    } else {

    }
#line 734
    rtl8723a_add_rateatid(padapter, tx_ra_bitmap, (int )arg, 0);
#line 738
    psta->raid = raid;
#line 739
    psta->init_rate = (u8 )init_rate;
#line 741
    spin_lock_bh(& psta->lock);
#line 742
    psta->state = 1U;
#line 743
    spin_unlock_bh(& psta->lock);
  } else
#line 748
  if (GlobalDebugLevel23A > 3U) {
#line 748
    printk("\016RTL8723AU: add_RATid23a_bmc_sta error!\n");
  } else {

  }
#line 749
  return;
}
}
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void update_sta_info23a_apmode23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct ht_priv *phtpriv_ap ;
  struct ht_priv *phtpriv_sta ;

  {
#line 761
  pmlmepriv = & padapter->mlmepriv;
#line 762
  psecuritypriv = & padapter->securitypriv;
#line 763
  pmlmeext = & padapter->mlmeextpriv;
#line 764
  phtpriv_ap = & pmlmepriv->htpriv;
#line 765
  phtpriv_sta = & psta->htpriv;
#line 768
  psta->mac_id = psta->aid + 1U;
#line 769
  if (GlobalDebugLevel23A > 3U) {
#line 769
    printk("\016RTL8723AU: %s\n", "update_sta_info23a_apmode23a");
  } else {

  }
#line 772
  rtl8723a_SetHalODMVar(padapter, 0, (void *)psta, 1);
#line 774
  if (psecuritypriv->dot11AuthAlgrthm == 2U) {
#line 775
    psta->ieee8021x_blocked = 1U;
  } else {
#line 777
    psta->ieee8021x_blocked = 0U;
  }
#line 782
  VCS_update23a(padapter, psta);
#line 784
  if (phtpriv_sta->ht_option != 0U) {
#line 787
    phtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;
#line 790
    if ((((int )phtpriv_sta->ht_cap.cap_info & (int )phtpriv_ap->ht_cap.cap_info) & 96) != 0) {
#line 791
      phtpriv_sta->sgi = 1U;
    } else {

    }
#line 794
    if ((((int )phtpriv_sta->ht_cap.cap_info & (int )phtpriv_ap->ht_cap.cap_info) & 2) != 0) {
#line 796
      phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
#line 797
      phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
    } else {

    }
#line 801
    psta->qos_option = 1U;
  } else {
#line 806
    phtpriv_sta->ampdu_enable = 0U;
#line 808
    phtpriv_sta->sgi = 0U;
#line 809
    phtpriv_sta->bwmode = 0U;
#line 810
    phtpriv_sta->ch_offset = 0U;
  }
#line 814
  send_delba23a(padapter, 0, (u8 *)(& psta->hwaddr));
#line 817
  send_delba23a(padapter, 1, (u8 *)(& psta->hwaddr));
#line 818
  phtpriv_sta->agg_enable_bitmap = 0U;
#line 819
  phtpriv_sta->candidate_tid_bitmap = 0U;
#line 823
  memset((void *)(& psta->sta_stats), 0, 168UL);
#line 825
  spin_lock_bh(& psta->lock);
#line 826
  psta->state = psta->state | 1U;
#line 827
  spin_unlock_bh(& psta->lock);
#line 828
  return;
}
}
#line 830 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_hw_ht_param(struct rtw_adapter *padapter ) 
{ 
  unsigned char max_AMPDU_len ;
  unsigned char min_MPDU_spacing ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;

  {
#line 834
  pmlmeext = & padapter->mlmeextpriv;
#line 835
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 837
  if (GlobalDebugLevel23A > 3U) {
#line 837
    printk("\016RTL8723AU: %s\n", "update_hw_ht_param");
  } else {

  }
#line 844
  max_AMPDU_len = (unsigned int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 3U;
#line 846
  min_MPDU_spacing = (unsigned char )(((int )pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 28) >> 2);
#line 848
  rtl8723a_set_ampdu_min_space(padapter, (int )min_MPDU_spacing);
#line 849
  rtl8723a_set_ampdu_factor(padapter, (int )max_AMPDU_len);
#line 852
  pmlmeinfo->SM_PS = (u8 )(((int )pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 12) >> 2);
#line 853
  if ((unsigned int )pmlmeinfo->SM_PS == 0U) {
#line 854
    if (GlobalDebugLevel23A > 3U) {
#line 854
      printk("\016RTL8723AU: %s(): WLAN_HT_CAP_SM_PS_STATIC\n", "update_hw_ht_param");
    } else {

    }
  } else {

  }
#line 855
  return;
}
}
#line 857 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void start_bss_network(struct rtw_adapter *padapter , u8 *pbuf ) 
{ 
  u8 const   *p ;
  u8 val8 ;
  u8 cur_channel ;
  u8 cur_bwmode ;
  u8 cur_ch_offset ;
  u16 bcn_interval ;
  u32 acparm ;
  struct registry_priv *pregpriv ;
  struct mlme_priv *pmlmepriv ;
  struct security_priv *psecuritypriv ;
  struct wlan_bssid_ex *pnetwork ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork_mlmeext ;
  struct HT_info_element *pht_info ;
  int bcn_fixed_size ;
  u8 *tmp ;
  u16 tmp___0 ;
  size_t __len ;
  void *__ret ;
  int tmp___1 ;

  {
#line 863
  pregpriv = & padapter->registrypriv;
#line 864
  pmlmepriv = & padapter->mlmepriv;
#line 865
  psecuritypriv = & padapter->securitypriv;
#line 866
  pnetwork = & pmlmepriv->cur_network.network;
#line 867
  pmlmeext = & padapter->mlmeextpriv;
#line 868
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 869
  pnetwork_mlmeext = & pmlmeinfo->network;
#line 870
  pht_info = (struct HT_info_element *)0;
#line 873
  bcn_interval = pnetwork->BeaconPeriod;
#line 874
  cur_channel = (u8 )pnetwork->DSConfig;
#line 875
  cur_bwmode = 0U;
#line 876
  cur_ch_offset = 0U;
#line 881
  tmp = rtw_get_wps_ie23a((u8 *)(& pnetwork->IEs) + 12UL, pnetwork->IELength - 12U,
                          (u8 *)0U, (uint *)0U);
#line 881
  if ((unsigned long )tmp == (unsigned long )((u8 *)0U)) {
#line 882
    pmlmeext->bstart_bss = 1U;
  } else {

  }
#line 887
  if (pmlmepriv->qos_option != 0U) {
#line 888
    pmlmeinfo->WMM_enable = 1U;
  } else {

  }
#line 889
  if (pmlmepriv->htpriv.ht_option != 0U) {
#line 890
    pmlmeinfo->WMM_enable = 1U;
#line 891
    pmlmeinfo->HT_enable = 1U;
#line 893
    update_hw_ht_param(padapter);
  } else {

  }
#line 896
  if (pmlmepriv->cur_network.join_res != 1) {
#line 899
    if (psecuritypriv->dot11PrivacyAlgrthm != 1027073U && psecuritypriv->dot11PrivacyAlgrthm != 1027077U) {
#line 903
      flush_all_cam_entry23a(padapter);
    } else {

    }
  } else {

  }
#line 907
  Set_MSR23a(padapter, 3);
#line 910
  hw_var_set_bssid(padapter, (u8 *)(& pnetwork->MacAddress));
#line 913
  acparm = 3093015U;
#line 914
  rtl8723a_set_ac_param_vo(padapter, acparm);
#line 915
  acparm = 6177559U;
#line 916
  rtl8723a_set_ac_param_vi(padapter, acparm);
#line 917
  acparm = 6202411U;
#line 918
  rtl8723a_set_ac_param_be(padapter, acparm);
#line 919
  acparm = 42052U;
#line 920
  rtl8723a_set_ac_param_bk(padapter, acparm);
#line 923
  val8 = psecuritypriv->dot11AuthAlgrthm == 2U ? 204U : 207U;
#line 925
  rtl8723a_set_sec_cfg(padapter, (int )val8);
#line 928
  rtl8723a_set_beacon_interval(padapter, (int )bcn_interval);
#line 930
  UpdateBrateTbl23a(padapter, (u8 *)(& pnetwork->SupportedRates));
#line 931
  HalSetBrateCfg23a(padapter, (u8 *)(& pnetwork->SupportedRates));
#line 933
  if (pmlmepriv->cur_network.join_res == 0) {
#line 939
    rtl8723a_odm_support_ability_set(padapter, 268435455U);
  } else {

  }
#line 943
  bcn_fixed_size = 12;
#line 946
  p = cfg80211_find_ie(61, (u8 const   *)(& pnetwork->IEs) + (unsigned long )bcn_fixed_size,
                       (int )(pnetwork->IELength - (u32 )bcn_fixed_size));
#line 949
  if ((unsigned long )p != (unsigned long )((u8 const   *)0U) && (unsigned int )((unsigned char )*(p + 1UL)) != 0U) {
#line 950
    pht_info = (struct HT_info_element *)p + 2U;
#line 952
    if ((unsigned int )pregpriv->cbw40_enable != 0U && ((unsigned long )pht_info->infos[0] & 4UL) != 0UL) {
#line 954
      cur_bwmode = 1U;
#line 955
      switch ((int )pht_info->infos[0] & 3) {
      case 1: 
#line 959
      cur_ch_offset = 1U;
#line 960
      goto ldv_54364;
      case 3: 
#line 962
      cur_ch_offset = 2U;
#line 963
      goto ldv_54364;
      default: 
#line 965
      cur_ch_offset = 0U;
#line 966
      goto ldv_54364;
      }
      ldv_54364: ;
    } else {

    }
  } else {

  }
#line 971
  set_channel_bwmode23a(padapter, (int )cur_channel, (int )cur_ch_offset, (int )cur_bwmode);
#line 973
  if (GlobalDebugLevel23A > 3U) {
#line 973
    printk("\016RTL8723AU: CH =%d, BW =%d, offset =%d\n", (int )cur_channel, (int )cur_bwmode,
           (int )cur_ch_offset);
  } else {

  }
#line 976
  pmlmeext->cur_channel = cur_channel;
#line 977
  pmlmeext->cur_bwmode = cur_bwmode;
#line 978
  pmlmeext->cur_ch_offset = cur_ch_offset;
#line 979
  pmlmeext->cur_wireless_mode = (unsigned char )pmlmepriv->cur_network.network_type;
#line 982
  update_wireless_mode23a(padapter);
#line 985
  tmp___0 = rtw_get_capability23a(pnetwork);
#line 985
  update_capinfo23a(padapter, (int )tmp___0);
#line 988
  __len = (size_t )pnetwork->Length;
#line 988
  __ret = __builtin_memcpy((void *)pnetwork_mlmeext, (void const   *)pnetwork, __len);
#line 990
  if ((unsigned int )pmlmeext->bstart_bss != 0U) {
#line 991
    update_beacon23a(padapter, 5, (u8 *)0U, 0);
#line 994
    tmp___1 = send_beacon23a(padapter);
#line 994
    if (tmp___1 == 0) {
#line 995
      if (GlobalDebugLevel23A > 3U) {
#line 995
        printk("\016RTL8723AU: issue_beacon23a, fail!\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 999
  update_bmc_sta(padapter);
#line 1000
  return;
}
}
#line 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
int rtw_check_beacon_data23a(struct rtw_adapter *padapter , u8 *pbuf , unsigned int len ) 
{ 
  int ret ;
  u8 *p ;
  u8 *pHT_caps_ie ;
  u8 *pHT_info_ie ;
  struct sta_info *psta ;
  __le16 *pbeacon ;
  u16 cap ;
  u16 ht_cap ;
  uint ie_len ;
  int group_cipher ;
  int pairwise_cipher ;
  u8 channel ;
  u8 network_type ;
  u8 supportRate[16U] ;
  int supportRateNum ;
  u8 WMM_PARA_IE[6U] ;
  struct registry_priv *pregistrypriv ;
  struct security_priv *psecuritypriv ;
  struct mlme_priv *pmlmepriv ;
  struct wlan_bssid_ex *pbss_network ;
  u8 *ie ;
  bool tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  size_t __len___1 ;
  void *__ret___1 ;
  size_t __len___2 ;
  void *__ret___2 ;
  size_t __len___3 ;
  void *__ret___3 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  u8 rf_type ;
  struct ieee80211_ht_cap *pht_cap ;
  size_t __len___4 ;
  void *__ret___4 ;

  {
#line 1005
  ret = 1;
#line 1007
  pHT_caps_ie = (u8 *)0U;
#line 1008
  pHT_info_ie = (u8 *)0U;
#line 1009
  psta = (struct sta_info *)0;
#line 1011
  ht_cap = 0U;
#line 1012
  ie_len = 0U;
#line 1015
  supportRateNum = 0;
#line 1016
  WMM_PARA_IE[0] = 0U;
#line 1016
  WMM_PARA_IE[1] = 80U;
#line 1016
  WMM_PARA_IE[2] = 242U;
#line 1016
  WMM_PARA_IE[3] = 2U;
#line 1016
  WMM_PARA_IE[4] = 1U;
#line 1016
  WMM_PARA_IE[5] = 1U;
#line 1017
  pregistrypriv = & padapter->registrypriv;
#line 1018
  psecuritypriv = & padapter->securitypriv;
#line 1019
  pmlmepriv = & padapter->mlmepriv;
#line 1020
  pbss_network = & pmlmepriv->cur_network.network;
#line 1021
  ie = (u8 *)(& pbss_network->IEs);
#line 1034
  if (GlobalDebugLevel23A > 3U) {
#line 1034
    printk("\016RTL8723AU: %s, len =%d\n", "rtw_check_beacon_data23a", len);
  } else {

  }
#line 1036
  tmp = check_fwstate(pmlmepriv, 16);
#line 1036
  if (tmp) {
#line 1036
    tmp___0 = 0;
  } else {
#line 1036
    tmp___0 = 1;
  }
#line 1036
  if (tmp___0) {
#line 1037
    return (0);
  } else {

  }
#line 1039
  if (len > 768U) {
#line 1040
    return (0);
  } else {

  }
#line 1042
  pbss_network->IELength = len;
#line 1044
  memset((void *)ie, 0, 768UL);
#line 1046
  __len = (size_t )pbss_network->IELength;
#line 1046
  __ret = __builtin_memcpy((void *)ie, (void const   *)pbuf, __len);
#line 1048
  if ((unsigned int )pbss_network->ifmode != 3U && (unsigned int )pbss_network->ifmode != 9U) {
#line 1050
    return (0);
  } else {

  }
#line 1052
  pbss_network->Rssi = 0L;
#line 1054
  __len___0 = 6UL;
#line 1054
  if (__len___0 > 63UL) {
#line 1054
    tmp___1 = myid(& padapter->eeprompriv);
#line 1054
    __ret___0 = __memcpy((void *)(& pbss_network->MacAddress), (void const   *)tmp___1,
                         __len___0);
  } else {
#line 1054
    tmp___2 = myid(& padapter->eeprompriv);
#line 1054
    __ret___0 = __builtin_memcpy((void *)(& pbss_network->MacAddress), (void const   *)tmp___2,
                                 __len___0);
  }
#line 1058
  pbeacon = rtw_get_beacon_interval23a_from_ie(ie);
#line 1059
  pbss_network->BeaconPeriod = get_unaligned_le16((void const   *)pbeacon);
#line 1062
  cap = get_unaligned_le16((void const   *)ie);
#line 1065
  p = rtw_get_ie23a(ie + 12UL, 0, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
#line 1067
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 1068
    memset((void *)(& pbss_network->Ssid), 0, 33UL);
#line 1069
    __len___1 = (size_t )ie_len;
#line 1069
    __ret___1 = __builtin_memcpy((void *)(& pbss_network->Ssid.ssid), (void const   *)p + 2U,
                                 __len___1);
#line 1070
    pbss_network->Ssid.ssid_len = (u8 )ie_len;
  } else {

  }
#line 1074
  channel = 0U;
#line 1075
  p = rtw_get_ie23a(ie + 12UL, 3, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
#line 1077
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 1078
    channel = *(p + 2UL);
  } else {

  }
#line 1080
  pbss_network->DSConfig = (u32 )channel;
#line 1082
  memset((void *)(& supportRate), 0, 16UL);
#line 1084
  p = rtw_get_ie23a(ie + 12UL, 1, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
#line 1086
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 1087
    __len___2 = (size_t )ie_len;
#line 1087
    __ret___2 = __builtin_memcpy((void *)(& supportRate), (void const   *)p + 2U,
                                 __len___2);
#line 1088
    supportRateNum = (int )ie_len;
  } else {

  }
#line 1092
  p = rtw_get_ie23a(ie + 12UL, 50, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
#line 1094
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 1095
    __len___3 = (size_t )ie_len;
#line 1095
    __ret___3 = __builtin_memcpy((void *)(& supportRate) + (unsigned long )supportRateNum,
                                 (void const   *)p + 2U, __len___3);
#line 1096
    supportRateNum = (int )((uint )supportRateNum + ie_len);
  } else {

  }
#line 1099
  tmp___3 = rtw_check_network_type23a((unsigned char *)(& supportRate), supportRateNum,
                                      (int )channel);
#line 1099
  network_type = (u8 )tmp___3;
#line 1102
  rtw_set_supported_rate23a((u8 *)(& pbss_network->SupportedRates), (uint )network_type);
#line 1105
  p = rtw_get_ie23a(ie + 12UL, 42, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
#line 1107
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 1108
    ERP_IE_handler23a(padapter, p);
  } else {

  }
#line 1111
  if (((unsigned long )cap & 16UL) != 0UL) {
#line 1112
    pbss_network->Privacy = 1U;
  } else {
#line 1114
    pbss_network->Privacy = 0U;
  }
#line 1116
  psecuritypriv->wpa_psk = 0U;
#line 1119
  group_cipher = 0;
#line 1119
  pairwise_cipher = 0;
#line 1120
  psecuritypriv->wpa2_group_cipher = 0U;
#line 1121
  psecuritypriv->wpa2_pairwise_cipher = 0U;
#line 1122
  p = rtw_get_ie23a(ie + 12UL, 48, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
#line 1124
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 1125
    tmp___4 = rtw_parse_wpa2_ie23a((u8 const   *)p, (int )(ie_len + 2U), & group_cipher,
                                   & pairwise_cipher, (int *)0);
#line 1125
    if (tmp___4 == 1) {
#line 1127
      psecuritypriv->dot11AuthAlgrthm = 2U;
#line 1129
      psecuritypriv->dot8021xalg = 1U;
#line 1130
      psecuritypriv->wpa_psk = psecuritypriv->wpa_psk | 2U;
#line 1132
      psecuritypriv->wpa2_group_cipher = (unsigned int )group_cipher;
#line 1133
      psecuritypriv->wpa2_pairwise_cipher = (unsigned int )pairwise_cipher;
    } else {

    }
  } else {

  }
#line 1138
  ie_len = 0U;
#line 1139
  group_cipher = 0;
#line 1140
  pairwise_cipher = 0;
#line 1141
  psecuritypriv->wpa_group_cipher = 0U;
#line 1142
  psecuritypriv->wpa_pairwise_cipher = 0U;
#line 1143
  p = ie + 12UL;
  ldv_54413: 
#line 1144
  p = rtw_get_ie23a(p, 221, (int *)(& ie_len), (int )((pbss_network->IELength - ie_len) - 14U));
#line 1147
  if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 1147
    tmp___6 = memcmp((void const   *)p + 2U, (void const   *)(& RTW_WPA_OUI23A_TYPE),
                     4UL);
#line 1147
    if (tmp___6 == 0) {
#line 1148
      tmp___5 = rtw_parse_wpa_ie23a((u8 const   *)p, (int )(ie_len + 2U), & group_cipher,
                                    & pairwise_cipher, (int *)0);
#line 1148
      if (tmp___5 == 1) {
#line 1150
        psecuritypriv->dot11AuthAlgrthm = 2U;
#line 1153
        psecuritypriv->dot8021xalg = 1U;
#line 1155
        psecuritypriv->wpa_psk = psecuritypriv->wpa_psk | 1U;
#line 1157
        psecuritypriv->wpa_group_cipher = (unsigned int )group_cipher;
#line 1158
        psecuritypriv->wpa_pairwise_cipher = (unsigned int )pairwise_cipher;
      } else {

      }
#line 1160
      goto ldv_54412;
    } else {

    }
  } else {

  }
#line 1163
  if ((unsigned long )p == (unsigned long )((u8 *)0U) || ie_len == 0U) {
#line 1164
    goto ldv_54412;
  } else {

  }
#line 1143
  p = p + (unsigned long )(ie_len + 2U);
#line 1165
  goto ldv_54413;
  ldv_54412: 
#line 1168
  ie_len = 0U;
#line 1169
  pmlmepriv->qos_option = 0U;
#line 1170
  if ((unsigned int )pregistrypriv->wmm_enable != 0U) {
#line 1171
    p = ie + 12UL;
    ldv_54415: 
#line 1172
    p = rtw_get_ie23a(p, 221, (int *)(& ie_len), (int )((pbss_network->IELength - ie_len) - 14U));
#line 1175
    if ((unsigned long )p != (unsigned long )((u8 *)0U)) {
#line 1175
      tmp___7 = memcmp((void const   *)p + 2U, (void const   *)(& WMM_PARA_IE), 6UL);
#line 1175
      if (tmp___7 == 0) {
#line 1176
        pmlmepriv->qos_option = 1U;
#line 1178
        *(p + 8UL) = (u8 )((unsigned int )*(p + 8UL) | 128U);
#line 1183
        *(p + 10UL) = (unsigned int )*(p + 10UL) & 239U;
#line 1184
        *(p + 14UL) = (unsigned int )*(p + 14UL) & 239U;
#line 1185
        *(p + 18UL) = (unsigned int )*(p + 18UL) & 239U;
#line 1186
        *(p + 22UL) = (unsigned int )*(p + 22UL) & 239U;
#line 1187
        goto ldv_54414;
      } else {

      }
    } else {

    }
#line 1189
    if ((unsigned long )p == (unsigned long )((u8 *)0U) || ie_len == 0U) {
#line 1190
      goto ldv_54414;
    } else {

    }
#line 1171
    p = p + (unsigned long )(ie_len + 2U);
#line 1191
    goto ldv_54415;
    ldv_54414: ;
  } else {

  }
#line 1194
  p = rtw_get_ie23a(ie + 12UL, 45, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
#line 1196
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 1199
    pht_cap = (struct ieee80211_ht_cap *)p + 2U;
#line 1201
    pHT_caps_ie = p;
#line 1203
    ht_cap = 1U;
#line 1204
    network_type = (u8 )((unsigned int )network_type | 8U);
#line 1206
    rf_type = rtl8723a_get_rf_type(padapter);
#line 1208
    if (((unsigned long )psecuritypriv->wpa_pairwise_cipher & 16UL) != 0UL || ((unsigned long )psecuritypriv->wpa2_pairwise_cipher & 16UL) != 0UL) {
#line 1210
      pht_cap->ampdu_params_info = (u8 )((unsigned int )pht_cap->ampdu_params_info | 28U);
    } else {
#line 1212
      pht_cap->ampdu_params_info = pht_cap->ampdu_params_info;
    }
#line 1215
    pht_cap->ampdu_params_info = (u8 )((unsigned int )pht_cap->ampdu_params_info | 3U);
#line 1217
    if ((unsigned int )rf_type == 3U) {
#line 1218
      pht_cap->mcs.rx_mask[0] = 255U;
#line 1219
      pht_cap->mcs.rx_mask[1] = 0U;
    } else {

    }
#line 1222
    __len___4 = (size_t )ie_len;
#line 1222
    __ret___4 = __builtin_memcpy((void *)(& pmlmepriv->htpriv.ht_cap), (void const   *)p + 2U,
                                 __len___4);
  } else {

  }
#line 1226
  p = rtw_get_ie23a(ie + 12UL, 61, (int *)(& ie_len), (int )(pbss_network->IELength - 12U));
#line 1228
  if ((unsigned long )p != (unsigned long )((u8 *)0U) && ie_len != 0U) {
#line 1229
    pHT_info_ie = p;
  } else {

  }
#line 1231
  pmlmepriv->cur_network.network_type = (int )network_type;
#line 1233
  pmlmepriv->htpriv.ht_option = 0U;
#line 1236
  if ((unsigned int )pregistrypriv->ht_enable != 0U && (unsigned int )ht_cap != 0U) {
#line 1237
    pmlmepriv->htpriv.ht_option = 1U;
#line 1238
    pmlmepriv->qos_option = 1U;
#line 1240
    if ((unsigned int )pregistrypriv->ampdu_enable == 1U) {
#line 1241
      pmlmepriv->htpriv.ampdu_enable = 1U;
    } else {

    }
#line 1243
    HT_caps_handler23a(padapter, pHT_caps_ie);
#line 1245
    HT_info_handler23a(padapter, pHT_info_ie);
  } else {

  }
#line 1248
  pbss_network->Length = get_wlan_bssid_ex_sz(pbss_network);
#line 1251
  start_bss_network(padapter, (u8 *)pbss_network);
#line 1254
  psta = rtw_get_stainfo23a(& padapter->stapriv, (u8 const   *)(& pbss_network->MacAddress));
#line 1255
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1256
    psta = rtw_alloc_stainfo23a(& padapter->stapriv, (u8 *)(& pbss_network->MacAddress),
                                208U);
#line 1259
    if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1260
      return (0);
    } else {

    }
  } else {

  }
#line 1263
  psta->state = psta->state | 16U;
#line 1264
  rtw_indicate_connect23a(padapter);
#line 1267
  pmlmepriv->cur_network.join_res = 1;
#line 1269
  return (ret);
}
}
#line 1272 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void rtw_set_macaddr_acl23a(struct rtw_adapter *padapter , int mode ) 
{ 
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;

  {
#line 1274
  pstapriv = & padapter->stapriv;
#line 1275
  pacl_list = & pstapriv->acl_list;
#line 1277
  if (GlobalDebugLevel23A > 3U) {
#line 1277
    printk("\016RTL8723AU: %s, mode =%d\n", "rtw_set_macaddr_acl23a", mode);
  } else {

  }
#line 1279
  pacl_list->mode = mode;
#line 1280
  return;
}
}
#line 1282 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
int rtw_acl_add_sta23a(struct rtw_adapter *padapter , u8 *addr ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  u8 added ;
  int i ;
  int ret ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;
  int tmp ;
  size_t __len ;
  void *__ret ;
  struct list_head *tmp___0 ;

  {
#line 1285
  added = 0U;
#line 1286
  ret = 0;
#line 1288
  pstapriv = & padapter->stapriv;
#line 1289
  pacl_list = & pstapriv->acl_list;
#line 1290
  pacl_node_q = & pacl_list->acl_node_q;
#line 1292
  if (GlobalDebugLevel23A > 3U) {
#line 1292
    printk("\016RTL8723AU: %s(acl_num =%d) =%02x:%02x:%02x:%02x:%02x:%02x\n", "rtw_acl_add_sta23a",
           pacl_list->num, (int )*addr, (int )*(addr + 1UL), (int )*(addr + 2UL),
           (int )*(addr + 3UL), (int )*(addr + 4UL), (int )*(addr + 5UL));
  } else {

  }
#line 1294
  if (pacl_list->num > 15) {
#line 1295
    return (-1);
  } else {

  }
#line 1297
  spin_lock_bh(& pacl_node_q->lock);
#line 1299
  phead = get_list_head(pacl_node_q);
#line 1301
  plist = phead->next;
#line 1301
  goto ldv_54446;
  ldv_54445: 
#line 1302
  __mptr = (struct list_head  const  *)plist;
#line 1302
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
#line 1304
  tmp = memcmp((void const   *)(& paclnode->addr), (void const   *)addr, 6UL);
#line 1304
  if (tmp == 0) {
#line 1305
    if ((unsigned int )paclnode->valid == 1U) {
#line 1306
      added = 1U;
#line 1307
      if (GlobalDebugLevel23A > 3U) {
#line 1307
        printk("\016RTL8723AU: %s, sta has been added\n", "rtw_acl_add_sta23a");
      } else {

      }
#line 1308
      goto ldv_54444;
    } else {

    }
  } else {

  }
#line 1301
  plist = plist->next;
  ldv_54446: ;
#line 1301
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1303
    goto ldv_54445;
  } else {

  }
  ldv_54444: 
#line 1313
  spin_unlock_bh(& pacl_node_q->lock);
#line 1315
  if ((unsigned int )added != 0U) {
#line 1316
    return (ret);
  } else {

  }
#line 1318
  spin_lock_bh(& pacl_node_q->lock);
#line 1320
  i = 0;
#line 1320
  goto ldv_54452;
  ldv_54451: 
#line 1321
  paclnode = (struct rtw_wlan_acl_node *)(& pacl_list->aclnode) + (unsigned long )i;
#line 1323
  if ((unsigned int )paclnode->valid == 0U) {
#line 1324
    INIT_LIST_HEAD(& paclnode->list);
#line 1326
    __len = 6UL;
#line 1326
    if (__len > 63UL) {
#line 1326
      __ret = __memcpy((void *)(& paclnode->addr), (void const   *)addr, __len);
    } else {
#line 1326
      __ret = __builtin_memcpy((void *)(& paclnode->addr), (void const   *)addr, __len);
    }
#line 1328
    paclnode->valid = 1U;
#line 1330
    tmp___0 = get_list_head(pacl_node_q);
#line 1330
    list_add_tail(& paclnode->list, tmp___0);
#line 1332
    pacl_list->num = pacl_list->num + 1;
#line 1334
    goto ldv_54450;
  } else {

  }
#line 1320
  i = i + 1;
  ldv_54452: ;
#line 1320
  if (i <= 15) {
#line 1322
    goto ldv_54451;
  } else {

  }
  ldv_54450: ;
#line 1338
  if (GlobalDebugLevel23A > 3U) {
#line 1338
    printk("\016RTL8723AU: %s, acl_num =%d\n", "rtw_acl_add_sta23a", pacl_list->num);
  } else {

  }
#line 1340
  spin_unlock_bh(& pacl_node_q->lock);
#line 1341
  return (ret);
}
}
#line 1344 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
int rtw_acl_remove_sta23a(struct rtw_adapter *padapter , u8 *addr ) 
{ 
  struct list_head *plist ;
  struct list_head *phead ;
  struct list_head *ptmp ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_priv *pstapriv ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  int ret ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
#line 1348
  pstapriv = & padapter->stapriv;
#line 1349
  pacl_list = & pstapriv->acl_list;
#line 1350
  pacl_node_q = & pacl_list->acl_node_q;
#line 1351
  ret = 0;
#line 1353
  if (GlobalDebugLevel23A > 3U) {
#line 1353
    printk("\016RTL8723AU: %s(acl_num =%d) = %pM\n", "rtw_acl_remove_sta23a", pacl_list->num,
           addr);
  } else {

  }
#line 1355
  spin_lock_bh(& pacl_node_q->lock);
#line 1357
  phead = get_list_head(pacl_node_q);
#line 1359
  plist = phead->next;
#line 1359
  ptmp = plist->next;
#line 1359
  goto ldv_54469;
  ldv_54468: 
#line 1360
  __mptr = (struct list_head  const  *)plist;
#line 1360
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
#line 1362
  tmp = memcmp((void const   *)(& paclnode->addr), (void const   *)addr, 6UL);
#line 1362
  if (tmp == 0) {
#line 1363
    if ((unsigned int )paclnode->valid != 0U) {
#line 1364
      paclnode->valid = 0U;
#line 1366
      list_del_init(& paclnode->list);
#line 1368
      pacl_list->num = pacl_list->num - 1;
    } else {

    }
  } else {

  }
#line 1359
  plist = ptmp;
#line 1359
  ptmp = plist->next;
  ldv_54469: ;
#line 1359
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1361
    goto ldv_54468;
  } else {

  }
#line 1373
  spin_unlock_bh(& pacl_node_q->lock);
#line 1375
  if (GlobalDebugLevel23A > 3U) {
#line 1375
    printk("\016RTL8723AU: %s, acl_num =%d\n", "rtw_acl_remove_sta23a", pacl_list->num);
  } else {

  }
#line 1377
  return (ret);
}
}
#line 1380 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_fixed_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1382
  if (GlobalDebugLevel23A > 3U) {
#line 1382
    printk("\016RTL8723AU: %s\n", "update_bcn_fixed_ie");
  } else {

  }
#line 1383
  return;
}
}
#line 1385 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_erpinfo_ie(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  unsigned char *p ;
  unsigned char *ie ;
  u32 len ;
  u8 *tmp ;

  {
#line 1387
  pmlmepriv = & padapter->mlmepriv;
#line 1388
  pmlmeext = & padapter->mlmeextpriv;
#line 1389
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1390
  pnetwork = & pmlmeinfo->network;
#line 1391
  ie = (unsigned char *)(& pnetwork->IEs);
#line 1392
  len = 0U;
#line 1394
  if (GlobalDebugLevel23A > 3U) {
#line 1394
    printk("\016RTL8723AU: %s, ERP_enable =%d\n", "update_bcn_erpinfo_ie", (int )pmlmeinfo->ERP_enable);
  } else {

  }
#line 1396
  if ((unsigned int )pmlmeinfo->ERP_enable == 0U) {
#line 1397
    return;
  } else {

  }
#line 1400
  tmp = rtw_get_ie23a(ie + 12U, 42, (int *)(& len), (int )(pnetwork->IELength - 12U));
#line 1400
  p = tmp;
#line 1401
  if ((unsigned long )p != (unsigned long )((unsigned char *)0U) && len != 0U) {
#line 1402
    if (pmlmepriv->num_sta_non_erp == 1) {
#line 1403
      *(p + 2UL) = (unsigned int )*(p + 2UL) | 3U;
    } else {
#line 1406
      *(p + 2UL) = (unsigned int )*(p + 2UL) & 252U;
    }
#line 1409
    if (pmlmepriv->num_sta_no_short_preamble > 0) {
#line 1410
      *(p + 2UL) = (unsigned int )*(p + 2UL) | 4U;
    } else {
#line 1412
      *(p + 2UL) = (unsigned int )*(p + 2UL) & 251U;
    }
#line 1414
    ERP_IE_handler23a(padapter, p);
  } else {

  }
#line 1416
  return;
}
}
#line 1418 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_htcap_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1420
  if (GlobalDebugLevel23A > 3U) {
#line 1420
    printk("\016RTL8723AU: %s\n", "update_bcn_htcap_ie");
  } else {

  }
#line 1421
  return;
}
}
#line 1423 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_htinfo_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1425
  if (GlobalDebugLevel23A > 3U) {
#line 1425
    printk("\016RTL8723AU: %s\n", "update_bcn_htinfo_ie");
  } else {

  }
#line 1426
  return;
}
}
#line 1428 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_rsn_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1430
  if (GlobalDebugLevel23A > 3U) {
#line 1430
    printk("\016RTL8723AU: %s\n", "update_bcn_rsn_ie");
  } else {

  }
#line 1431
  return;
}
}
#line 1433 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_wpa_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1435
  if (GlobalDebugLevel23A > 3U) {
#line 1435
    printk("\016RTL8723AU: %s\n", "update_bcn_wpa_ie");
  } else {

  }
#line 1436
  return;
}
}
#line 1438 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_wmm_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1440
  if (GlobalDebugLevel23A > 3U) {
#line 1440
    printk("\016RTL8723AU: %s\n", "update_bcn_wmm_ie");
  } else {

  }
#line 1441
  return;
}
}
#line 1443 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_wps_ie(struct rtw_adapter *padapter ) 
{ 
  u8 *pwps_ie ;
  u8 *pwps_ie_src ;
  u8 *premainder_ie ;
  u8 *pbackup_remainder_ie ;
  uint wps_ielen ;
  uint wps_offset ;
  uint remainder_ielen ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  struct wlan_bssid_ex *pnetwork ;
  unsigned char *ie ;
  u32 ielen ;
  void *tmp ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
#line 1445
  pwps_ie = (u8 *)0U;
#line 1445
  pbackup_remainder_ie = (u8 *)0U;
#line 1446
  wps_ielen = 0U;
#line 1447
  pmlmepriv = & padapter->mlmepriv;
#line 1448
  pmlmeext = & padapter->mlmeextpriv;
#line 1449
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1450
  pnetwork = & pmlmeinfo->network;
#line 1451
  ie = (unsigned char *)(& pnetwork->IEs);
#line 1452
  ielen = pnetwork->IELength;
#line 1454
  if (GlobalDebugLevel23A > 3U) {
#line 1454
    printk("\016RTL8723AU: %s\n", "update_bcn_wps_ie");
  } else {

  }
#line 1456
  pwps_ie_src = pmlmepriv->wps_beacon_ie;
#line 1457
  if ((unsigned long )pwps_ie_src == (unsigned long )((u8 *)0U)) {
#line 1458
    return;
  } else {

  }
#line 1460
  pwps_ie = rtw_get_wps_ie23a(ie + 12U, ielen - 12U, (u8 *)0U, & wps_ielen);
#line 1462
  if ((unsigned long )pwps_ie == (unsigned long )((u8 *)0U) || wps_ielen == 0U) {
#line 1463
    return;
  } else {

  }
#line 1465
  wps_offset = (unsigned int )((long )pwps_ie) - (unsigned int )((long )ie);
#line 1467
  premainder_ie = pwps_ie + (unsigned long )wps_ielen;
#line 1469
  remainder_ielen = (ielen - wps_offset) - wps_ielen;
#line 1471
  if (remainder_ielen != 0U) {
#line 1472
    tmp = kmalloc((size_t )remainder_ielen, 32U);
#line 1472
    pbackup_remainder_ie = (u8 *)tmp;
#line 1473
    if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
#line 1474
      __len = (size_t )remainder_ielen;
#line 1474
      __ret = __builtin_memcpy((void *)pbackup_remainder_ie, (void const   *)premainder_ie,
                               __len);
    } else {

    }
  } else {

  }
#line 1478
  wps_ielen = (unsigned int )*(pwps_ie_src + 1UL);
#line 1479
  if (((wps_offset + wps_ielen) + remainder_ielen) + 2U <= 768U) {
#line 1481
    __len___0 = (size_t )(wps_ielen + 2U);
#line 1481
    __ret___0 = __builtin_memcpy((void *)pwps_ie, (void const   *)pwps_ie_src, __len___0);
#line 1482
    pwps_ie = pwps_ie + (unsigned long )(wps_ielen + 2U);
#line 1484
    if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
#line 1485
      __len___1 = (size_t )remainder_ielen;
#line 1485
      __ret___1 = __builtin_memcpy((void *)pwps_ie, (void const   *)pbackup_remainder_ie,
                                   __len___1);
    } else {

    }
#line 1488
    pnetwork->IELength = ((wps_ielen + wps_offset) + remainder_ielen) + 2U;
  } else {

  }
#line 1491
  if ((unsigned long )pbackup_remainder_ie != (unsigned long )((u8 *)0U)) {
#line 1492
    kfree((void const   *)pbackup_remainder_ie);
  } else {

  }
#line 1493
  return;
}
}
#line 1495 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_p2p_ie(struct rtw_adapter *padapter ) 
{ 


  {
#line 1497
  return;
}
}
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static void update_bcn_vendor_spec_ie(struct rtw_adapter *padapter , u8 *oui ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1501
  if (GlobalDebugLevel23A > 3U) {
#line 1501
    printk("\016RTL8723AU: %s\n", "update_bcn_vendor_spec_ie");
  } else {

  }
#line 1503
  tmp___2 = memcmp((void const   *)(& RTW_WPA_OUI23A_TYPE), (void const   *)oui, 4UL);
#line 1503
  if (tmp___2 == 0) {
#line 1504
    update_bcn_wpa_ie(padapter);
  } else {
#line 1505
    tmp___1 = memcmp((void const   *)(& WMM_OUI23A), (void const   *)oui, 4UL);
#line 1505
    if (tmp___1 == 0) {
#line 1506
      update_bcn_wmm_ie(padapter);
    } else {
#line 1507
      tmp___0 = memcmp((void const   *)(& WPS_OUI23A), (void const   *)oui, 4UL);
#line 1507
      if (tmp___0 == 0) {
#line 1508
        update_bcn_wps_ie(padapter);
      } else {
#line 1509
        tmp = memcmp((void const   *)(& P2P_OUI23A), (void const   *)oui, 4UL);
#line 1509
        if (tmp == 0) {
#line 1510
          update_bcn_p2p_ie(padapter);
        } else
#line 1512
        if (GlobalDebugLevel23A > 3U) {
#line 1512
          printk("\016RTL8723AU: unknown OUI type!\n");
        } else {

        }
      }
    }
  }
#line 1513
  return;
}
}
#line 1515 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void update_beacon23a(struct rtw_adapter *padapter , u8 ie_id , u8 *oui , u8 tx ) 
{ 
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;

  {
#line 1523
  if ((unsigned long )padapter == (unsigned long )((struct rtw_adapter *)0)) {
#line 1524
    return;
  } else {

  }
#line 1526
  pmlmepriv = & padapter->mlmepriv;
#line 1527
  pmlmeext = & padapter->mlmeextpriv;
#line 1530
  if ((unsigned int )pmlmeext->bstart_bss == 0U) {
#line 1531
    return;
  } else {

  }
#line 1533
  spin_lock_bh(& pmlmepriv->bcn_update_lock);
#line 1535
  switch ((int )ie_id) {
  case 255: 
#line 1539
  update_bcn_fixed_ie(padapter);
#line 1540
  goto ldv_54549;
  case 5: 
#line 1543
  update_BCNTIM(padapter);
#line 1544
  goto ldv_54549;
  case 42: 
#line 1547
  update_bcn_erpinfo_ie(padapter);
#line 1548
  goto ldv_54549;
  case 45: 
#line 1551
  update_bcn_htcap_ie(padapter);
#line 1552
  goto ldv_54549;
  case 48: 
#line 1555
  update_bcn_rsn_ie(padapter);
#line 1556
  goto ldv_54549;
  case 61: 
#line 1559
  update_bcn_htinfo_ie(padapter);
#line 1560
  goto ldv_54549;
  case 221: 
#line 1563
  update_bcn_vendor_spec_ie(padapter, oui);
#line 1564
  goto ldv_54549;
  default: ;
#line 1567
  goto ldv_54549;
  }
  ldv_54549: 
#line 1570
  pmlmepriv->update_bcn = 1U;
#line 1572
  spin_unlock_bh(& pmlmepriv->bcn_update_lock);
#line 1574
  if ((unsigned int )tx != 0U) {
#line 1575
    set_tx_beacon_cmd23a(padapter);
  } else {

  }
#line 1576
  return;
}
}
#line 1590 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
static int rtw_ht_operation_update(struct rtw_adapter *padapter ) 
{ 
  u16 cur_op_mode ;
  u16 new_op_mode ;
  int op_mode_changes ;
  struct mlme_priv *pmlmepriv ;
  struct ht_priv *phtpriv_ap ;

  {
#line 1593
  op_mode_changes = 0;
#line 1594
  pmlmepriv = & padapter->mlmepriv;
#line 1595
  phtpriv_ap = & pmlmepriv->htpriv;
#line 1597
  if (pmlmepriv->htpriv.ht_option == 1U) {
#line 1598
    return (0);
  } else {

  }
#line 1603
  if (GlobalDebugLevel23A > 3U) {
#line 1603
    printk("\016RTL8723AU: %s current operation mode = 0x%X\n", "rtw_ht_operation_update",
           (int )pmlmepriv->ht_op_mode);
  } else {

  }
#line 1606
  if (((int )pmlmepriv->ht_op_mode & 4) == 0 && pmlmepriv->num_sta_ht_no_gf != 0) {
#line 1608
    pmlmepriv->ht_op_mode = (u16 )((unsigned int )pmlmepriv->ht_op_mode | 4U);
#line 1610
    op_mode_changes = op_mode_changes + 1;
  } else
#line 1611
  if (((int )pmlmepriv->ht_op_mode & 4) != 0 && pmlmepriv->num_sta_ht_no_gf == 0) {
#line 1614
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65531U;
#line 1616
    op_mode_changes = op_mode_changes + 1;
  } else {

  }
#line 1619
  if (((int )pmlmepriv->ht_op_mode & 16) == 0 && (pmlmepriv->num_sta_no_ht != 0 || pmlmepriv->olbc_ht != 0)) {
#line 1621
    pmlmepriv->ht_op_mode = (u16 )((unsigned int )pmlmepriv->ht_op_mode | 16U);
#line 1622
    op_mode_changes = op_mode_changes + 1;
  } else
#line 1623
  if (((int )pmlmepriv->ht_op_mode & 16) != 0 && (pmlmepriv->num_sta_no_ht == 0 && pmlmepriv->olbc_ht == 0)) {
#line 1626
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65519U;
#line 1628
    op_mode_changes = op_mode_changes + 1;
  } else {

  }
#line 1635
  if (pmlmepriv->num_sta_no_ht != 0 || ((int )pmlmepriv->ht_op_mode & 4) != 0) {
#line 1637
    new_op_mode = 3U;
  } else
#line 1638
  if (((int )phtpriv_ap->ht_cap.cap_info & 2) != 0 && pmlmepriv->num_sta_ht_20mhz != 0) {
#line 1641
    new_op_mode = 2U;
  } else
#line 1642
  if (pmlmepriv->olbc_ht != 0) {
#line 1643
    new_op_mode = 1U;
  } else {
#line 1645
    new_op_mode = 0U;
  }
#line 1647
  cur_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 3U;
#line 1648
  if ((int )cur_op_mode != (int )new_op_mode) {
#line 1649
    pmlmepriv->ht_op_mode = (unsigned int )pmlmepriv->ht_op_mode & 65532U;
#line 1650
    pmlmepriv->ht_op_mode = (u16 )((int )pmlmepriv->ht_op_mode | (int )new_op_mode);
#line 1651
    op_mode_changes = op_mode_changes + 1;
  } else {

  }
#line 1654
  if (GlobalDebugLevel23A > 3U) {
#line 1654
    printk("\016RTL8723AU: %s new operation mode = 0x%X changes =%d\n", "rtw_ht_operation_update",
           (int )pmlmepriv->ht_op_mode, op_mode_changes);
  } else {

  }
#line 1657
  return (op_mode_changes);
}
}
#line 1660 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void associated_clients_update23a(struct rtw_adapter *padapter , u8 updated ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct list_head  const  *__mptr ;

  {
#line 1663
  if ((unsigned int )updated == 1U) {
#line 1667
    pstapriv = & padapter->stapriv;
#line 1669
    spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1671
    phead = & pstapriv->asoc_list;
#line 1673
    plist = phead->next;
#line 1673
    ptmp = plist->next;
#line 1673
    goto ldv_54578;
    ldv_54577: 
#line 1674
    __mptr = (struct list_head  const  *)plist;
#line 1674
    psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 1676
    VCS_update23a(padapter, psta);
#line 1673
    plist = ptmp;
#line 1673
    ptmp = plist->next;
    ldv_54578: ;
#line 1673
    if ((unsigned long )plist != (unsigned long )phead) {
#line 1675
      goto ldv_54577;
    } else {

    }
#line 1679
    spin_unlock_bh(& pstapriv->asoc_list_lock);
  } else {

  }
#line 1681
  return;
}
}
#line 1684 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void bss_cap_update_on_sta_join23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 beacon_updated ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  u16 ht_capab ;
  int tmp ;

  {
#line 1686
  beacon_updated = 0U;
#line 1687
  pmlmepriv = & padapter->mlmepriv;
#line 1688
  pmlmeext = & padapter->mlmeextpriv;
#line 1690
  if (((unsigned long )psta->flags & 128UL) == 0UL) {
#line 1692
    if ((unsigned int )psta->no_short_preamble_set == 0U) {
#line 1694
      psta->no_short_preamble_set = 1U;
#line 1696
      pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble + 1;
#line 1698
      if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 1) {
#line 1701
        beacon_updated = 1U;
#line 1702
        update_beacon23a(padapter, 255, (u8 *)0U, 1);
      } else {

      }
    } else {

    }
  } else
#line 1709
  if ((unsigned int )psta->no_short_preamble_set != 0U) {
#line 1711
    psta->no_short_preamble_set = 0U;
#line 1713
    pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble - 1;
#line 1715
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 0) {
#line 1718
      beacon_updated = 1U;
#line 1719
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1725
  if (psta->flags < 0) {
#line 1727
    if ((unsigned int )psta->nonerp_set == 0U) {
#line 1729
      psta->nonerp_set = 1U;
#line 1731
      pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp + 1;
#line 1733
      if (pmlmepriv->num_sta_non_erp == 1) {
#line 1735
        beacon_updated = 1U;
#line 1736
        update_beacon23a(padapter, 42, (u8 *)0U, 1);
      } else {

      }
    } else {

    }
  } else
#line 1743
  if ((unsigned int )psta->nonerp_set != 0U) {
#line 1745
    psta->nonerp_set = 0U;
#line 1747
    pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp - 1;
#line 1749
    if (pmlmepriv->num_sta_non_erp == 0) {
#line 1751
      beacon_updated = 1U;
#line 1752
      update_beacon23a(padapter, 42, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1758
  if (((int )psta->capability & 1024) == 0) {
#line 1760
    if ((unsigned int )psta->no_short_slot_time_set == 0U) {
#line 1762
      psta->no_short_slot_time_set = 1U;
#line 1764
      pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time + 1;
#line 1766
      if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 1) {
#line 1769
        beacon_updated = 1U;
#line 1770
        update_beacon23a(padapter, 255, (u8 *)0U, 1);
      } else {

      }
    } else {

    }
  } else
#line 1777
  if ((unsigned int )psta->no_short_slot_time_set != 0U) {
#line 1779
    psta->no_short_slot_time_set = 0U;
#line 1781
    pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time - 1;
#line 1783
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 0) {
#line 1786
      beacon_updated = 1U;
#line 1787
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1792
  if (((unsigned long )psta->flags & 2048UL) != 0UL) {
#line 1794
    ht_capab = psta->htpriv.ht_cap.cap_info;
#line 1796
    if (GlobalDebugLevel23A > 3U) {
#line 1796
      printk("\016RTL8723AU: HT: STA %02x:%02x:%02x:%02x:%02x:%02x HT Capabilities Info: 0x%04x\n",
             (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
             (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
             (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
             (int )ht_capab);
    } else {

    }
#line 1799
    if ((unsigned int )psta->no_ht_set != 0U) {
#line 1800
      psta->no_ht_set = 0U;
#line 1801
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht - 1;
    } else {

    }
#line 1804
    if (((int )ht_capab & 16) == 0) {
#line 1805
      if ((unsigned int )psta->no_ht_gf_set == 0U) {
#line 1806
        psta->no_ht_gf_set = 1U;
#line 1807
        pmlmepriv->num_sta_ht_no_gf = pmlmepriv->num_sta_ht_no_gf + 1;
      } else {

      }
#line 1809
      if (GlobalDebugLevel23A > 3U) {
#line 1809
        printk("\016RTL8723AU: %s STA %02x:%02x:%02x:%02x:%02x:%02x - no greenfield, num of non-gf stations %d\n",
               "bss_cap_update_on_sta_join23a", (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
               (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
               (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
               pmlmepriv->num_sta_ht_no_gf);
      } else {

      }
    } else {

    }
#line 1815
    if (((int )ht_capab & 2) == 0) {
#line 1816
      if ((unsigned int )psta->ht_20mhz_set == 0U) {
#line 1817
        psta->ht_20mhz_set = 1U;
#line 1818
        pmlmepriv->num_sta_ht_20mhz = pmlmepriv->num_sta_ht_20mhz + 1;
      } else {

      }
#line 1820
      if (GlobalDebugLevel23A > 3U) {
#line 1820
        printk("\016RTL8723AU: %s STA %02x:%02x:%02x:%02x:%02x:%02x - 20 MHz HT, num of 20MHz HT STAs %d\n",
               "bss_cap_update_on_sta_join23a", (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
               (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
               (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
               pmlmepriv->num_sta_ht_20mhz);
      } else {

      }
    } else {

    }
  } else {
#line 1829
    if ((unsigned int )psta->no_ht_set == 0U) {
#line 1830
      psta->no_ht_set = 1U;
#line 1831
      pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht + 1;
    } else {

    }
#line 1833
    if (pmlmepriv->htpriv.ht_option == 1U) {
#line 1834
      if (GlobalDebugLevel23A > 3U) {
#line 1834
        printk("\016RTL8723AU: %s STA %02x:%02x:%02x:%02x:%02x:%02x - no HT, num of non-HT stations %d\n",
               "bss_cap_update_on_sta_join23a", (int )*((u8 *)(& psta->hwaddr)), (int )*((u8 *)(& psta->hwaddr) + 1UL),
               (int )*((u8 *)(& psta->hwaddr) + 2UL), (int )*((u8 *)(& psta->hwaddr) + 3UL),
               (int )*((u8 *)(& psta->hwaddr) + 4UL), (int )*((u8 *)(& psta->hwaddr) + 5UL),
               pmlmepriv->num_sta_no_ht);
      } else {

      }
    } else {

    }
  }
#line 1841
  tmp = rtw_ht_operation_update(padapter);
#line 1841
  if (tmp > 0) {
#line 1843
    update_beacon23a(padapter, 45, (u8 *)0U, 0);
#line 1844
    update_beacon23a(padapter, 61, (u8 *)0U, 1);
  } else {

  }
#line 1848
  associated_clients_update23a(padapter, (int )beacon_updated);
#line 1850
  if (GlobalDebugLevel23A > 3U) {
#line 1850
    printk("\016RTL8723AU: %s, updated =%d\n", "bss_cap_update_on_sta_join23a", (int )beacon_updated);
  } else {

  }
#line 1851
  return;
}
}
#line 1853 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
u8 bss_cap_update_on_sta_leave23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  u8 beacon_updated ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  int tmp ;

  {
#line 1855
  beacon_updated = 0U;
#line 1856
  pmlmepriv = & padapter->mlmepriv;
#line 1857
  pmlmeext = & padapter->mlmeextpriv;
#line 1859
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1860
    return (beacon_updated);
  } else {

  }
#line 1862
  if ((unsigned int )psta->no_short_preamble_set != 0U) {
#line 1863
    psta->no_short_preamble_set = 0U;
#line 1864
    pmlmepriv->num_sta_no_short_preamble = pmlmepriv->num_sta_no_short_preamble - 1;
#line 1865
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_preamble == 0) {
#line 1868
      beacon_updated = 1U;
#line 1869
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1873
  if ((unsigned int )psta->nonerp_set != 0U) {
#line 1874
    psta->nonerp_set = 0U;
#line 1875
    pmlmepriv->num_sta_non_erp = pmlmepriv->num_sta_non_erp - 1;
#line 1876
    if (pmlmepriv->num_sta_non_erp == 0) {
#line 1878
      beacon_updated = 1U;
#line 1879
      update_beacon23a(padapter, 42, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1884
  if ((unsigned int )psta->no_short_slot_time_set != 0U) {
#line 1885
    psta->no_short_slot_time_set = 0U;
#line 1886
    pmlmepriv->num_sta_no_short_slot_time = pmlmepriv->num_sta_no_short_slot_time - 1;
#line 1887
    if ((unsigned int )pmlmeext->cur_wireless_mode > 1U && pmlmepriv->num_sta_no_short_slot_time == 0) {
#line 1890
      beacon_updated = 1U;
#line 1891
      update_beacon23a(padapter, 255, (u8 *)0U, 1);
    } else {

    }
  } else {

  }
#line 1895
  if ((unsigned int )psta->no_ht_gf_set != 0U) {
#line 1896
    psta->no_ht_gf_set = 0U;
#line 1897
    pmlmepriv->num_sta_ht_no_gf = pmlmepriv->num_sta_ht_no_gf - 1;
  } else {

  }
#line 1900
  if ((unsigned int )psta->no_ht_set != 0U) {
#line 1901
    psta->no_ht_set = 0U;
#line 1902
    pmlmepriv->num_sta_no_ht = pmlmepriv->num_sta_no_ht - 1;
  } else {

  }
#line 1905
  if ((unsigned int )psta->ht_20mhz_set != 0U) {
#line 1906
    psta->ht_20mhz_set = 0U;
#line 1907
    pmlmepriv->num_sta_ht_20mhz = pmlmepriv->num_sta_ht_20mhz - 1;
  } else {

  }
#line 1910
  tmp = rtw_ht_operation_update(padapter);
#line 1910
  if (tmp > 0) {
#line 1912
    update_beacon23a(padapter, 45, (u8 *)0U, 0);
#line 1913
    update_beacon23a(padapter, 61, (u8 *)0U, 1);
  } else {

  }
#line 1918
  if (GlobalDebugLevel23A > 3U) {
#line 1918
    printk("\016RTL8723AU: %s, updated =%d\n", "bss_cap_update_on_sta_leave23a", (int )beacon_updated);
  } else {

  }
#line 1920
  return (beacon_updated);
}
}
#line 1923 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
u8 ap_free_sta23a(struct rtw_adapter *padapter , struct sta_info *psta , bool active ,
                  u16 reason ) 
{ 
  struct sta_priv *pstapriv ;
  u8 beacon_updated ;

  {
#line 1925
  pstapriv = & padapter->stapriv;
#line 1926
  beacon_updated = 0U;
#line 1928
  if ((unsigned long )psta == (unsigned long )((struct sta_info *)0)) {
#line 1929
    return (beacon_updated);
  } else {

  }
#line 1931
  if ((int )active) {
#line 1934
    send_delba23a(padapter, 0, (u8 *)(& psta->hwaddr));
#line 1937
    send_delba23a(padapter, 1, (u8 *)(& psta->hwaddr));
#line 1939
    issue_deauth23a(padapter, (unsigned char *)(& psta->hwaddr), (int )reason);
  } else {

  }
#line 1942
  psta->htpriv.agg_enable_bitmap = 0U;
#line 1943
  psta->htpriv.candidate_tid_bitmap = 0U;
#line 1949
  rtw_clearstakey_cmd23a(padapter, (u8 *)psta, (int )((unsigned int )((unsigned char )psta->mac_id) + 3U),
                         1);
#line 1951
  spin_lock_bh(& psta->lock);
#line 1952
  psta->state = psta->state & 4294967294U;
#line 1953
  spin_unlock_bh(& psta->lock);
#line 1955
  rtw_cfg80211_indicate_sta_disassoc(padapter, (unsigned char *)(& psta->hwaddr),
                                     (int )reason);
#line 1957
  report_del_sta_event23a(padapter, (unsigned char *)(& psta->hwaddr), (int )reason);
#line 1959
  beacon_updated = bss_cap_update_on_sta_leave23a(padapter, psta);
#line 1961
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 1962
  rtw_free_stainfo23a(padapter, psta);
#line 1963
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 1965
  return (beacon_updated);
}
}
#line 1968 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
int rtw_ap_inform_ch_switch23a(struct rtw_adapter *padapter , u8 new_ch , u8 ch_offset ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  int ret ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 bc_addr[6U] ;
  struct list_head  const  *__mptr ;

  {
#line 1971
  ret = 0;
#line 1972
  psta = (struct sta_info *)0;
#line 1973
  pstapriv = & padapter->stapriv;
#line 1974
  pmlmeext = & padapter->mlmeextpriv;
#line 1975
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 1976
  bc_addr[0] = 255U;
#line 1976
  bc_addr[1] = 255U;
#line 1976
  bc_addr[2] = 255U;
#line 1976
  bc_addr[3] = 255U;
#line 1976
  bc_addr[4] = 255U;
#line 1976
  bc_addr[5] = 255U;
#line 1978
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 1979
    return (ret);
  } else {

  }
#line 1981
  if (GlobalDebugLevel23A > 3U) {
#line 1981
    printk("\016RTL8723AU: %s(%s): with ch:%u, offset:%u\n", "rtw_ap_inform_ch_switch23a",
           (char *)(& (padapter->pnetdev)->name), (int )new_ch, (int )ch_offset);
  } else {

  }
#line 1984
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 1985
  phead = & pstapriv->asoc_list;
#line 1987
  plist = phead->next;
#line 1987
  goto ldv_54622;
  ldv_54621: 
#line 1988
  __mptr = (struct list_head  const  *)plist;
#line 1988
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 1990
  issue_action_spct_ch_switch23a(padapter, (u8 *)(& psta->hwaddr), (int )new_ch, (int )ch_offset);
#line 1991
  psta->expire_to = 5U < pstapriv->expire_to * 2U ? 5U : pstapriv->expire_to * 2U;
#line 1987
  plist = plist->next;
  ldv_54622: ;
#line 1987
  if ((unsigned long )plist != (unsigned long )phead) {
#line 1989
    goto ldv_54621;
  } else {

  }
#line 1993
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 1995
  issue_action_spct_ch_switch23a(padapter, (u8 *)(& bc_addr), (int )new_ch, (int )ch_offset);
#line 1997
  return (ret);
}
}
#line 2000 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
int rtw_sta_flush23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  int ret ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct mlme_ext_info *pmlmeinfo ;
  u8 bc_addr[6U] ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head  const  *__mptr ;
  u8 tmp ;

  {
#line 2003
  ret = 0;
#line 2005
  pstapriv = & padapter->stapriv;
#line 2006
  pmlmeext = & padapter->mlmeextpriv;
#line 2007
  pmlmeinfo = & pmlmeext->mlmext_info;
#line 2008
  bc_addr[0] = 255U;
#line 2008
  bc_addr[1] = 255U;
#line 2008
  bc_addr[2] = 255U;
#line 2008
  bc_addr[3] = 255U;
#line 2008
  bc_addr[4] = 255U;
#line 2008
  bc_addr[5] = 255U;
#line 2009
  chk_alive_num = 0U;
#line 2013
  if (GlobalDebugLevel23A > 3U) {
#line 2013
    printk("\016RTL8723AU: %s(%s)\n", "rtw_sta_flush23a", (char *)(& (padapter->pnetdev)->name));
  } else {

  }
#line 2015
  if ((pmlmeinfo->state & 3U) != 3U) {
#line 2016
    return (ret);
  } else {

  }
#line 2018
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 2019
  phead = & pstapriv->asoc_list;
#line 2021
  plist = phead->next;
#line 2021
  ptmp = plist->next;
#line 2021
  goto ldv_54643;
  ldv_54642: 
#line 2022
  __mptr = (struct list_head  const  *)plist;
#line 2022
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 2025
  list_del_init(& psta->asoc_list);
#line 2026
  pstapriv->asoc_list_cnt = (u8 )((int )pstapriv->asoc_list_cnt - 1);
#line 2029
  tmp = chk_alive_num;
#line 2029
  chk_alive_num = (u8 )((int )chk_alive_num + 1);
#line 2029
  chk_alive_list[(int )tmp] = psta;
#line 2021
  plist = ptmp;
#line 2021
  ptmp = plist->next;
  ldv_54643: ;
#line 2021
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2023
    goto ldv_54642;
  } else {

  }
#line 2031
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 2034
  i = 0;
#line 2034
  goto ldv_54646;
  ldv_54645: 
#line 2035
  ap_free_sta23a(padapter, chk_alive_list[i], 1, 3);
#line 2034
  i = i + 1;
  ldv_54646: ;
#line 2034
  if ((int )chk_alive_num > i) {
#line 2036
    goto ldv_54645;
  } else {

  }
#line 2038
  issue_deauth23a(padapter, (unsigned char *)(& bc_addr), 3);
#line 2040
  associated_clients_update23a(padapter, 1);
#line 2042
  return (ret);
}
}
#line 2046 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void sta_info_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 
  int flags ;
  struct mlme_priv *pmlmepriv ;

  {
#line 2048
  flags = psta->flags;
#line 2049
  pmlmepriv = & padapter->mlmepriv;
#line 2052
  if ((flags & 512) != 0) {
#line 2053
    psta->qos_option = 1U;
  } else {
#line 2055
    psta->qos_option = 0U;
  }
#line 2057
  if (pmlmepriv->qos_option == 0U) {
#line 2058
    psta->qos_option = 0U;
  } else {

  }
#line 2061
  if ((flags & 2048) != 0) {
#line 2063
    psta->htpriv.ht_option = 1U;
#line 2064
    psta->qos_option = 1U;
  } else {
#line 2068
    psta->htpriv.ht_option = 0U;
  }
#line 2071
  if (pmlmepriv->htpriv.ht_option == 0U) {
#line 2072
    psta->htpriv.ht_option = 0U;
  } else {

  }
#line 2074
  update_sta_info23a_apmode23a(padapter, psta);
#line 2075
  return;
}
}
#line 2078 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void ap_sta_info_defer_update23a(struct rtw_adapter *padapter , struct sta_info *psta ) 
{ 


  {
#line 2080
  if ((int )psta->state & 1) {
#line 2083
    add_RATid23a(padapter, psta, 0);
  } else {

  }
#line 2084
  return;
}
}
#line 2088 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void rtw_ap_restore_network(struct rtw_adapter *padapter ) 
{ 
  struct mlme_priv *mlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct sta_priv *pstapriv ;
  struct sta_info *psta ;
  struct security_priv *psecuritypriv ;
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  u8 chk_alive_num ;
  struct sta_info *chk_alive_list[32U] ;
  int i ;
  struct list_head  const  *__mptr ;
  u8 tmp ;

  {
#line 2090
  mlmepriv = & padapter->mlmepriv;
#line 2091
  pmlmeext = & padapter->mlmeextpriv;
#line 2092
  pstapriv = & padapter->stapriv;
#line 2094
  psecuritypriv = & padapter->securitypriv;
#line 2096
  chk_alive_num = 0U;
#line 2100
  rtw_setopmode_cmd23a(padapter, 3);
#line 2102
  set_channel_bwmode23a(padapter, (int )pmlmeext->cur_channel, (int )pmlmeext->cur_ch_offset,
                        (int )pmlmeext->cur_bwmode);
#line 2104
  start_bss_network(padapter, (u8 *)(& mlmepriv->cur_network.network));
#line 2106
  if (padapter->securitypriv.dot11PrivacyAlgrthm == 1027074U || padapter->securitypriv.dot11PrivacyAlgrthm == 1027076U) {
#line 2111
    rtw_set_key23a(padapter, psecuritypriv, (int )psecuritypriv->dot118021XGrpKeyid,
                   0);
  } else {

  }
#line 2116
  if (padapter->securitypriv.dot11PrivacyAlgrthm != 1027074U && padapter->securitypriv.dot11PrivacyAlgrthm != 1027076U) {
#line 2120
    return;
  } else {

  }
#line 2123
  spin_lock_bh(& pstapriv->asoc_list_lock);
#line 2125
  phead = & pstapriv->asoc_list;
#line 2127
  plist = phead->next;
#line 2127
  ptmp = plist->next;
#line 2127
  goto ldv_54675;
  ldv_54674: 
#line 2128
  __mptr = (struct list_head  const  *)plist;
#line 2128
  psta = (struct sta_info *)__mptr + 0xffffffffffffeb90UL;
#line 2130
  tmp = chk_alive_num;
#line 2130
  chk_alive_num = (u8 )((int )chk_alive_num + 1);
#line 2130
  chk_alive_list[(int )tmp] = psta;
#line 2127
  plist = ptmp;
#line 2127
  ptmp = plist->next;
  ldv_54675: ;
#line 2127
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2129
    goto ldv_54674;
  } else {

  }
#line 2133
  spin_unlock_bh(& pstapriv->asoc_list_lock);
#line 2135
  i = 0;
#line 2135
  goto ldv_54678;
  ldv_54677: 
#line 2136
  psta = chk_alive_list[i];
#line 2138
  if ((int )psta->state & 1) {
#line 2139
    Update_RA_Entry23a(padapter, psta);
#line 2141
    rtw_setstakey_cmd23a(padapter, (u8 *)psta, 1);
  } else {

  }
#line 2135
  i = i + 1;
  ldv_54678: ;
#line 2135
  if ((int )chk_alive_num > i) {
#line 2137
    goto ldv_54677;
  } else {

  }

#line 2142
  return;
}
}
#line 2146 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void start_ap_mode23a(struct rtw_adapter *padapter ) 
{ 
  int i ;
  struct mlme_priv *pmlmepriv ;
  struct sta_priv *pstapriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_acl_pool *pacl_list ;

  {
#line 2149
  pmlmepriv = & padapter->mlmepriv;
#line 2150
  pstapriv = & padapter->stapriv;
#line 2151
  pmlmeext = & padapter->mlmeextpriv;
#line 2152
  pacl_list = & pstapriv->acl_list;
#line 2154
  pmlmepriv->update_bcn = 0U;
#line 2157
  pmlmeext->bstart_bss = 0U;
#line 2159
  pmlmepriv->num_sta_non_erp = 0;
#line 2161
  pmlmepriv->num_sta_no_short_slot_time = 0;
#line 2163
  pmlmepriv->num_sta_no_short_preamble = 0;
#line 2165
  pmlmepriv->num_sta_ht_no_gf = 0;
#line 2166
  pmlmepriv->num_sta_no_ht = 0;
#line 2167
  pmlmepriv->num_sta_ht_20mhz = 0;
#line 2169
  pmlmepriv->olbc = 0;
#line 2171
  pmlmepriv->olbc_ht = 0;
#line 2173
  pmlmepriv->ht_op_mode = 0U;
#line 2175
  i = 0;
#line 2175
  goto ldv_54689;
  ldv_54688: 
#line 2176
  pstapriv->sta_aid[i] = (struct sta_info *)0;
#line 2175
  i = i + 1;
  ldv_54689: ;
#line 2175
  if (i <= 31) {
#line 2177
    goto ldv_54688;
  } else {

  }
#line 2178
  pmlmepriv->wps_beacon_ie = (u8 *)0U;
#line 2179
  pmlmepriv->wps_probe_resp_ie = (u8 *)0U;
#line 2180
  pmlmepriv->wps_assoc_resp_ie = (u8 *)0U;
#line 2182
  pmlmepriv->p2p_beacon_ie = (u8 *)0U;
#line 2183
  pmlmepriv->p2p_probe_resp_ie = (u8 *)0U;
#line 2186
  INIT_LIST_HEAD(& pacl_list->acl_node_q.queue);
#line 2187
  pacl_list->num = 0;
#line 2188
  pacl_list->mode = 0;
#line 2189
  i = 0;
#line 2189
  goto ldv_54692;
  ldv_54691: 
#line 2190
  INIT_LIST_HEAD(& pacl_list->aclnode[i].list);
#line 2191
  pacl_list->aclnode[i].valid = 0U;
#line 2189
  i = i + 1;
  ldv_54692: ;
#line 2189
  if (i <= 15) {
#line 2191
    goto ldv_54691;
  } else {

  }

#line 2196
  return;
}
}
#line 2195 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void stop_ap_mode23a(struct rtw_adapter *padapter ) 
{ 
  struct list_head *phead ;
  struct list_head *plist ;
  struct list_head *ptmp ;
  struct rtw_wlan_acl_node *paclnode ;
  struct sta_info *psta ;
  struct sta_priv *pstapriv ;
  struct mlme_priv *pmlmepriv ;
  struct mlme_ext_priv *pmlmeext ;
  struct wlan_acl_pool *pacl_list ;
  struct rtw_queue *pacl_node_q ;
  struct list_head  const  *__mptr ;

  {
#line 2199
  psta = (struct sta_info *)0;
#line 2200
  pstapriv = & padapter->stapriv;
#line 2201
  pmlmepriv = & padapter->mlmepriv;
#line 2202
  pmlmeext = & padapter->mlmeextpriv;
#line 2203
  pacl_list = & pstapriv->acl_list;
#line 2204
  pacl_node_q = & pacl_list->acl_node_q;
#line 2206
  pmlmepriv->update_bcn = 0U;
#line 2207
  pmlmeext->bstart_bss = 0U;
#line 2210
  memset((void *)(& padapter->securitypriv), 0, 4776UL);
#line 2211
  padapter->securitypriv.ndisauthtype = 0U;
#line 2212
  padapter->securitypriv.ndisencryptstatus = 1U;
#line 2215
  spin_lock_bh(& pacl_node_q->lock);
#line 2216
  phead = get_list_head(pacl_node_q);
#line 2218
  plist = phead->next;
#line 2218
  ptmp = plist->next;
#line 2218
  goto ldv_54710;
  ldv_54709: 
#line 2219
  __mptr = (struct list_head  const  *)plist;
#line 2219
  paclnode = (struct rtw_wlan_acl_node *)__mptr;
#line 2221
  if ((unsigned int )paclnode->valid == 1U) {
#line 2222
    paclnode->valid = 0U;
#line 2224
    list_del_init(& paclnode->list);
#line 2226
    pacl_list->num = pacl_list->num - 1;
  } else {

  }
#line 2218
  plist = ptmp;
#line 2218
  ptmp = plist->next;
  ldv_54710: ;
#line 2218
  if ((unsigned long )plist != (unsigned long )phead) {
#line 2220
    goto ldv_54709;
  } else {

  }
#line 2229
  spin_unlock_bh(& pacl_node_q->lock);
#line 2231
  if (GlobalDebugLevel23A > 3U) {
#line 2231
    printk("\016RTL8723AU: %s, free acl_node_queue, num =%d\n", "stop_ap_mode23a",
           pacl_list->num);
  } else {

  }
#line 2233
  rtw_sta_flush23a(padapter);
#line 2236
  rtw_free_all_stainfo23a(padapter);
#line 2238
  psta = rtw_get_bcmc_stainfo23a(padapter);
#line 2239
  spin_lock_bh(& pstapriv->sta_hash_lock);
#line 2240
  rtw_free_stainfo23a(padapter, psta);
#line 2241
  spin_unlock_bh(& pstapriv->sta_hash_lock);
#line 2243
  rtw_init_bcmc_stainfo23a(padapter);
#line 2245
  rtw23a_free_mlme_priv_ie_data(pmlmepriv);
#line 2246
  return;
}
}
#line 2375 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
void *ldv_kmem_cache_alloc_2480(struct kmem_cache *ldv_func_arg1 , gfp_t flags ) 
{ 


  {
#line 2378
  ldv_check_alloc_flags(flags);
#line 2380
  kmem_cache_alloc(ldv_func_arg1, flags);
#line 2381
  return ((void *)0);
}
}
#line 2419 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
int ldv_pskb_expand_head_2486(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2422
  ldv_check_alloc_flags(flags);
#line 2424
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2424
  return (tmp);
}
}
#line 2435 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
struct sk_buff *ldv_skb_clone_2488(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2438
  ldv_check_alloc_flags(flags);
#line 2440
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2440
  return (tmp);
}
}
#line 2451 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
struct sk_buff *ldv_skb_copy_2490(struct sk_buff  const  *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2454
  ldv_check_alloc_flags(flags);
#line 2456
  tmp = skb_copy(ldv_func_arg1, flags);
#line 2456
  return (tmp);
}
}
#line 2459 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2491(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2462
  ldv_check_alloc_flags(flags);
#line 2464
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2464
  return (tmp);
}
}
#line 2467 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2492(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2470
  ldv_check_alloc_flags(flags);
#line 2472
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2472
  return (tmp);
}
}
#line 2475 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
struct sk_buff *ldv___netdev_alloc_skb_2493(struct net_device *ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                            gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2478
  ldv_check_alloc_flags(flags);
#line 2480
  tmp = __netdev_alloc_skb(ldv_func_arg1, ldv_func_arg2, flags);
#line 2480
  return (tmp);
}
}
#line 2483 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
int ldv_pskb_expand_head_2494(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2486
  ldv_check_alloc_flags(flags);
#line 2488
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2488
  return (tmp);
}
}
#line 2491 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
int ldv_pskb_expand_head_2495(struct sk_buff *ldv_func_arg1 , int ldv_func_arg2 ,
                              int ldv_func_arg3 , gfp_t flags ) 
{ 
  int tmp ;

  {
#line 2494
  ldv_check_alloc_flags(flags);
#line 2496
  tmp = pskb_expand_head(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, flags);
#line 2496
  return (tmp);
}
}
#line 2499 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/dscv/ri/43_2a/drivers/staging/rtl8723au/core/rtw_ap.o.c.prepared"
struct sk_buff *ldv_skb_clone_2496(struct sk_buff *ldv_func_arg1 , gfp_t flags ) 
{ 
  struct sk_buff *tmp ;

  {
#line 2502
  ldv_check_alloc_flags(flags);
#line 2504
  tmp = skb_clone(ldv_func_arg1, flags);
#line 2504
  return (tmp);
}
}
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error___49(void)  __attribute__((__no_instrument_function__)) ;
#line 12 "/home/ldvuser/ldv/inst-cpa/kernel-rules/verifier/rcv.h"
__inline static void ldv_error___49(void) 
{ 


  {
  ERROR: 
#line 14
  goto ERROR;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin  =    0;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 27
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 27
    ldv_error___49();
  }
#line 28
  return;
}
}
#line 30
extern struct page___0 *ldv_some_page(void) ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
struct page___0 *ldv_check_alloc_flags_and_return_some_page(gfp_t flags ) 
{ 
  struct page___0 *tmp ;

  {
#line 36
  if (ldv_spin == 0 || ! (flags & 16U)) {

  } else {
#line 36
    ldv_error___49();
  }
#line 38
  tmp = ldv_some_page();
#line 38
  return (tmp);
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
#line 45
  if (ldv_spin == 0) {

  } else {
#line 45
    ldv_error___49();
  }
#line 46
  return;
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_lock(void) 
{ 


  {
#line 52
  ldv_spin = 1;
#line 53
  return;
}
}
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
void ldv_spin_unlock(void) 
{ 


  {
#line 59
  ldv_spin = 0;
#line 60
  return;
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers--X--defaultlinux-3.16-rc1.tar.xz--X--43_2a--X--cpachecker/linux-3.16-rc1.tar.xz/csd_deg_dscv/5848/dscv_tempdir/rule-instrumentor/43_2a/common-model/ldv_common_model.c"
int ldv_spin_trylock(void) 
{ 
  int is_lock ;

  {
#line 68
  is_lock = ldv_undef_int();
#line 70
  if (is_lock) {
#line 73
    return (0);
  } else {
#line 78
    ldv_spin = 1;
#line 80
    return (1);
  }
}
}
